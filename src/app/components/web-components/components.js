function userAgentPolyfill() {
  var W;
  const z = ((W = navigator.userAgent.split(" ").pop()) == null ? void 0 : W.split("/")) ?? [], D = !!navigator.maxTouchPoints, O = navigator.platform, U = { MacIntel: D ? "iOS" : "macOS", Win32: "Windows", iPhone: "iOS", iPad: "iOS" };
  return {
    brands: [{ brand: (z == null ? void 0 : z[0]) ?? "", version: (z == null ? void 0 : z[1]) ?? "" }],
    mobile: D || /Android|iPhone|iPad|Mobi/i.test(navigator.userAgent),
    platform: U[O] ?? O
  };
}
const polyfill = navigator.userAgentData ?? userAgentPolyfill();
Object.defineProperty(navigator, "userAgentData", {
  get: () => polyfill
});
/**
 * @license
 * Copyright 2019 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const t$7 = globalThis, e$f = t$7.ShadowRoot && (t$7.ShadyCSS === void 0 || t$7.ShadyCSS.nativeShadow) && "adoptedStyleSheets" in Document.prototype && "replace" in CSSStyleSheet.prototype, s$9 = Symbol(), o$f = /* @__PURE__ */ new WeakMap();
let n$9 = class {
  constructor(D, O, F) {
    if (this._$cssResult$ = !0, F !== s$9)
      throw Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");
    this.cssText = D, this.t = O;
  }
  get styleSheet() {
    let D = this.o;
    const O = this.t;
    if (e$f && D === void 0) {
      const F = O !== void 0 && O.length === 1;
      F && (D = o$f.get(O)), D === void 0 && ((this.o = D = new CSSStyleSheet()).replaceSync(this.cssText), F && o$f.set(O, D));
    }
    return D;
  }
  toString() {
    return this.cssText;
  }
};
const r$9 = (z) => new n$9(typeof z == "string" ? z : z + "", void 0, s$9), i$7 = (z, ...D) => {
  const O = z.length === 1 ? z[0] : D.reduce((F, U, W) => F + ((B) => {
    if (B._$cssResult$ === !0)
      return B.cssText;
    if (typeof B == "number")
      return B;
    throw Error("Value passed to 'css' function must be a 'css' function result: " + B + ". Use 'unsafeCSS' to pass non-literal values, but take care to ensure page security.");
  })(U) + z[W + 1], z[0]);
  return new n$9(O, z, s$9);
}, S$1 = (z, D) => {
  if (e$f)
    z.adoptedStyleSheets = D.map((O) => O instanceof CSSStyleSheet ? O : O.styleSheet);
  else
    for (const O of D) {
      const F = document.createElement("style"), U = t$7.litNonce;
      U !== void 0 && F.setAttribute("nonce", U), F.textContent = O.cssText, z.appendChild(F);
    }
}, c$5 = e$f ? (z) => z : (z) => z instanceof CSSStyleSheet ? ((D) => {
  let O = "";
  for (const F of D.cssRules)
    O += F.cssText;
  return r$9(O);
})(z) : z;
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const { is: i$6, defineProperty: e$e, getOwnPropertyDescriptor: r$8, getOwnPropertyNames: h$4, getOwnPropertySymbols: o$e, getPrototypeOf: n$8 } = Object, a$3 = globalThis, c$4 = a$3.trustedTypes, l$4 = c$4 ? c$4.emptyScript : "", p$2 = a$3.reactiveElementPolyfillSupport, d$2 = (z, D) => z, u$3 = { toAttribute(z, D) {
  switch (D) {
    case Boolean:
      z = z ? l$4 : null;
      break;
    case Object:
    case Array:
      z = z == null ? z : JSON.stringify(z);
  }
  return z;
}, fromAttribute(z, D) {
  let O = z;
  switch (D) {
    case Boolean:
      O = z !== null;
      break;
    case Number:
      O = z === null ? null : Number(z);
      break;
    case Object:
    case Array:
      try {
        O = JSON.parse(z);
      } catch {
        O = null;
      }
  }
  return O;
} }, f$4 = (z, D) => !i$6(z, D), y$2 = { attribute: !0, type: String, converter: u$3, reflect: !1, hasChanged: f$4 };
Symbol.metadata ?? (Symbol.metadata = Symbol("metadata")), a$3.litPropertyMetadata ?? (a$3.litPropertyMetadata = /* @__PURE__ */ new WeakMap());
let b$2 = class extends HTMLElement {
  static addInitializer(D) {
    this._$Ei(), (this.l ?? (this.l = [])).push(D);
  }
  static get observedAttributes() {
    return this.finalize(), this._$Eh && [...this._$Eh.keys()];
  }
  static createProperty(D, O = y$2) {
    if (O.state && (O.attribute = !1), this._$Ei(), this.elementProperties.set(D, O), !O.noAccessor) {
      const F = Symbol(), U = this.getPropertyDescriptor(D, F, O);
      U !== void 0 && e$e(this.prototype, D, U);
    }
  }
  static getPropertyDescriptor(D, O, F) {
    const { get: U, set: W } = r$8(this.prototype, D) ?? { get() {
      return this[O];
    }, set(B) {
      this[O] = B;
    } };
    return { get() {
      return U == null ? void 0 : U.call(this);
    }, set(B) {
      const K = U == null ? void 0 : U.call(this);
      W.call(this, B), this.requestUpdate(D, K, F);
    }, configurable: !0, enumerable: !0 };
  }
  static getPropertyOptions(D) {
    return this.elementProperties.get(D) ?? y$2;
  }
  static _$Ei() {
    if (this.hasOwnProperty(d$2("elementProperties")))
      return;
    const D = n$8(this);
    D.finalize(), D.l !== void 0 && (this.l = [...D.l]), this.elementProperties = new Map(D.elementProperties);
  }
  static finalize() {
    if (this.hasOwnProperty(d$2("finalized")))
      return;
    if (this.finalized = !0, this._$Ei(), this.hasOwnProperty(d$2("properties"))) {
      const O = this.properties, F = [...h$4(O), ...o$e(O)];
      for (const U of F)
        this.createProperty(U, O[U]);
    }
    const D = this[Symbol.metadata];
    if (D !== null) {
      const O = litPropertyMetadata.get(D);
      if (O !== void 0)
        for (const [F, U] of O)
          this.elementProperties.set(F, U);
    }
    this._$Eh = /* @__PURE__ */ new Map();
    for (const [O, F] of this.elementProperties) {
      const U = this._$Eu(O, F);
      U !== void 0 && this._$Eh.set(U, O);
    }
    this.elementStyles = this.finalizeStyles(this.styles);
  }
  static finalizeStyles(D) {
    const O = [];
    if (Array.isArray(D)) {
      const F = new Set(D.flat(1 / 0).reverse());
      for (const U of F)
        O.unshift(c$5(U));
    } else
      D !== void 0 && O.push(c$5(D));
    return O;
  }
  static _$Eu(D, O) {
    const F = O.attribute;
    return F === !1 ? void 0 : typeof F == "string" ? F : typeof D == "string" ? D.toLowerCase() : void 0;
  }
  constructor() {
    super(), this._$Ep = void 0, this.isUpdatePending = !1, this.hasUpdated = !1, this._$Em = null, this._$Ev();
  }
  _$Ev() {
    var D;
    this._$ES = new Promise((O) => this.enableUpdating = O), this._$AL = /* @__PURE__ */ new Map(), this._$E_(), this.requestUpdate(), (D = this.constructor.l) == null || D.forEach((O) => O(this));
  }
  addController(D) {
    var O;
    (this._$EO ?? (this._$EO = /* @__PURE__ */ new Set())).add(D), this.renderRoot !== void 0 && this.isConnected && ((O = D.hostConnected) == null || O.call(D));
  }
  removeController(D) {
    var O;
    (O = this._$EO) == null || O.delete(D);
  }
  _$E_() {
    const D = /* @__PURE__ */ new Map(), O = this.constructor.elementProperties;
    for (const F of O.keys())
      this.hasOwnProperty(F) && (D.set(F, this[F]), delete this[F]);
    D.size > 0 && (this._$Ep = D);
  }
  createRenderRoot() {
    const D = this.shadowRoot ?? this.attachShadow(this.constructor.shadowRootOptions);
    return S$1(D, this.constructor.elementStyles), D;
  }
  connectedCallback() {
    var D;
    this.renderRoot ?? (this.renderRoot = this.createRenderRoot()), this.enableUpdating(!0), (D = this._$EO) == null || D.forEach((O) => {
      var F;
      return (F = O.hostConnected) == null ? void 0 : F.call(O);
    });
  }
  enableUpdating(D) {
  }
  disconnectedCallback() {
    var D;
    (D = this._$EO) == null || D.forEach((O) => {
      var F;
      return (F = O.hostDisconnected) == null ? void 0 : F.call(O);
    });
  }
  attributeChangedCallback(D, O, F) {
    this._$AK(D, F);
  }
  _$EC(D, O) {
    var W;
    const F = this.constructor.elementProperties.get(D), U = this.constructor._$Eu(D, F);
    if (U !== void 0 && F.reflect === !0) {
      const B = (((W = F.converter) == null ? void 0 : W.toAttribute) !== void 0 ? F.converter : u$3).toAttribute(O, F.type);
      this._$Em = D, B == null ? this.removeAttribute(U) : this.setAttribute(U, B), this._$Em = null;
    }
  }
  _$AK(D, O) {
    var W;
    const F = this.constructor, U = F._$Eh.get(D);
    if (U !== void 0 && this._$Em !== U) {
      const B = F.getPropertyOptions(U), K = typeof B.converter == "function" ? { fromAttribute: B.converter } : ((W = B.converter) == null ? void 0 : W.fromAttribute) !== void 0 ? B.converter : u$3;
      this._$Em = U, this[U] = K.fromAttribute(O, B.type), this._$Em = null;
    }
  }
  requestUpdate(D, O, F) {
    if (D !== void 0) {
      if (F ?? (F = this.constructor.getPropertyOptions(D)), !(F.hasChanged ?? f$4)(this[D], O))
        return;
      this.P(D, O, F);
    }
    this.isUpdatePending === !1 && (this._$ES = this._$ET());
  }
  P(D, O, F) {
    this._$AL.has(D) || this._$AL.set(D, O), F.reflect === !0 && this._$Em !== D && (this._$Ej ?? (this._$Ej = /* @__PURE__ */ new Set())).add(D);
  }
  async _$ET() {
    this.isUpdatePending = !0;
    try {
      await this._$ES;
    } catch (O) {
      Promise.reject(O);
    }
    const D = this.scheduleUpdate();
    return D != null && await D, !this.isUpdatePending;
  }
  scheduleUpdate() {
    return this.performUpdate();
  }
  performUpdate() {
    var F;
    if (!this.isUpdatePending)
      return;
    if (!this.hasUpdated) {
      if (this.renderRoot ?? (this.renderRoot = this.createRenderRoot()), this._$Ep) {
        for (const [W, B] of this._$Ep)
          this[W] = B;
        this._$Ep = void 0;
      }
      const U = this.constructor.elementProperties;
      if (U.size > 0)
        for (const [W, B] of U)
          B.wrapped !== !0 || this._$AL.has(W) || this[W] === void 0 || this.P(W, this[W], B);
    }
    let D = !1;
    const O = this._$AL;
    try {
      D = this.shouldUpdate(O), D ? (this.willUpdate(O), (F = this._$EO) == null || F.forEach((U) => {
        var W;
        return (W = U.hostUpdate) == null ? void 0 : W.call(U);
      }), this.update(O)) : this._$EU();
    } catch (U) {
      throw D = !1, this._$EU(), U;
    }
    D && this._$AE(O);
  }
  willUpdate(D) {
  }
  _$AE(D) {
    var O;
    (O = this._$EO) == null || O.forEach((F) => {
      var U;
      return (U = F.hostUpdated) == null ? void 0 : U.call(F);
    }), this.hasUpdated || (this.hasUpdated = !0, this.firstUpdated(D)), this.updated(D);
  }
  _$EU() {
    this._$AL = /* @__PURE__ */ new Map(), this.isUpdatePending = !1;
  }
  get updateComplete() {
    return this.getUpdateComplete();
  }
  getUpdateComplete() {
    return this._$ES;
  }
  shouldUpdate(D) {
    return !0;
  }
  update(D) {
    this._$Ej && (this._$Ej = this._$Ej.forEach((O) => this._$EC(O, this[O]))), this._$EU();
  }
  updated(D) {
  }
  firstUpdated(D) {
  }
};
b$2.elementStyles = [], b$2.shadowRootOptions = { mode: "open" }, b$2[d$2("elementProperties")] = /* @__PURE__ */ new Map(), b$2[d$2("finalized")] = /* @__PURE__ */ new Map(), p$2 == null || p$2({ ReactiveElement: b$2 }), (a$3.reactiveElementVersions ?? (a$3.reactiveElementVersions = [])).push("2.0.4");
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const t$6 = globalThis, i$5 = t$6.trustedTypes, s$8 = i$5 ? i$5.createPolicy("lit-html", { createHTML: (z) => z }) : void 0, e$d = "$lit$", h$3 = `lit$${Math.random().toFixed(9).slice(2)}$`, o$d = "?" + h$3, n$7 = `<${o$d}>`, r$7 = document, l$3 = () => r$7.createComment(""), c$3 = (z) => z === null || typeof z != "object" && typeof z != "function", a$2 = Array.isArray, u$2 = (z) => a$2(z) || typeof (z == null ? void 0 : z[Symbol.iterator]) == "function", d$1 = `[ 	
\f\r]`, f$3 = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g, v$1 = /-->/g, _$1 = />/g, m$1 = RegExp(`>|${d$1}(?:([^\\s"'>=/]+)(${d$1}*=${d$1}*(?:[^ 	
\f\r"'\`<>=]|("|')|))|$)`, "g"), p$1 = /'/g, g$3 = /"/g, $ = /^(?:script|style|textarea|title)$/i, y$1 = (z) => (D, ...O) => ({ _$litType$: z, strings: D, values: O }), x = y$1(1), b$1 = y$1(2), w$1 = Symbol.for("lit-noChange"), T = Symbol.for("lit-nothing"), A = /* @__PURE__ */ new WeakMap(), E$1 = r$7.createTreeWalker(r$7, 129);
function C(z, D) {
  if (!Array.isArray(z) || !z.hasOwnProperty("raw"))
    throw Error("invalid template strings array");
  return s$8 !== void 0 ? s$8.createHTML(D) : D;
}
const P = (z, D) => {
  const O = z.length - 1, F = [];
  let U, W = D === 2 ? "<svg>" : "", B = f$3;
  for (let K = 0; K < O; K++) {
    const X = z[K];
    let Y, Q, J = -1, ee = 0;
    for (; ee < X.length && (B.lastIndex = ee, Q = B.exec(X), Q !== null); )
      ee = B.lastIndex, B === f$3 ? Q[1] === "!--" ? B = v$1 : Q[1] !== void 0 ? B = _$1 : Q[2] !== void 0 ? ($.test(Q[2]) && (U = RegExp("</" + Q[2], "g")), B = m$1) : Q[3] !== void 0 && (B = m$1) : B === m$1 ? Q[0] === ">" ? (B = U ?? f$3, J = -1) : Q[1] === void 0 ? J = -2 : (J = B.lastIndex - Q[2].length, Y = Q[1], B = Q[3] === void 0 ? m$1 : Q[3] === '"' ? g$3 : p$1) : B === g$3 || B === p$1 ? B = m$1 : B === v$1 || B === _$1 ? B = f$3 : (B = m$1, U = void 0);
    const ae = B === m$1 && z[K + 1].startsWith("/>") ? " " : "";
    W += B === f$3 ? X + n$7 : J >= 0 ? (F.push(Y), X.slice(0, J) + e$d + X.slice(J) + h$3 + ae) : X + h$3 + (J === -2 ? K : ae);
  }
  return [C(z, W + (z[O] || "<?>") + (D === 2 ? "</svg>" : "")), F];
};
class V {
  constructor({ strings: D, _$litType$: O }, F) {
    let U;
    this.parts = [];
    let W = 0, B = 0;
    const K = D.length - 1, X = this.parts, [Y, Q] = P(D, O);
    if (this.el = V.createElement(Y, F), E$1.currentNode = this.el.content, O === 2) {
      const J = this.el.content.firstChild;
      J.replaceWith(...J.childNodes);
    }
    for (; (U = E$1.nextNode()) !== null && X.length < K; ) {
      if (U.nodeType === 1) {
        if (U.hasAttributes())
          for (const J of U.getAttributeNames())
            if (J.endsWith(e$d)) {
              const ee = Q[B++], ae = U.getAttribute(J).split(h$3), re = /([.?@])?(.*)/.exec(ee);
              X.push({ type: 1, index: W, name: re[2], strings: ae, ctor: re[1] === "." ? k : re[1] === "?" ? H$1 : re[1] === "@" ? I : R$1 }), U.removeAttribute(J);
            } else
              J.startsWith(h$3) && (X.push({ type: 6, index: W }), U.removeAttribute(J));
        if ($.test(U.tagName)) {
          const J = U.textContent.split(h$3), ee = J.length - 1;
          if (ee > 0) {
            U.textContent = i$5 ? i$5.emptyScript : "";
            for (let ae = 0; ae < ee; ae++)
              U.append(J[ae], l$3()), E$1.nextNode(), X.push({ type: 2, index: ++W });
            U.append(J[ee], l$3());
          }
        }
      } else if (U.nodeType === 8)
        if (U.data === o$d)
          X.push({ type: 2, index: W });
        else {
          let J = -1;
          for (; (J = U.data.indexOf(h$3, J + 1)) !== -1; )
            X.push({ type: 7, index: W }), J += h$3.length - 1;
        }
      W++;
    }
  }
  static createElement(D, O) {
    const F = r$7.createElement("template");
    return F.innerHTML = D, F;
  }
}
function N(z, D, O = z, F) {
  var B, K;
  if (D === w$1)
    return D;
  let U = F !== void 0 ? (B = O._$Co) == null ? void 0 : B[F] : O._$Cl;
  const W = c$3(D) ? void 0 : D._$litDirective$;
  return (U == null ? void 0 : U.constructor) !== W && ((K = U == null ? void 0 : U._$AO) == null || K.call(U, !1), W === void 0 ? U = void 0 : (U = new W(z), U._$AT(z, O, F)), F !== void 0 ? (O._$Co ?? (O._$Co = []))[F] = U : O._$Cl = U), U !== void 0 && (D = N(z, U._$AS(z, D.values), U, F)), D;
}
class S {
  constructor(D, O) {
    this._$AV = [], this._$AN = void 0, this._$AD = D, this._$AM = O;
  }
  get parentNode() {
    return this._$AM.parentNode;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  u(D) {
    const { el: { content: O }, parts: F } = this._$AD, U = ((D == null ? void 0 : D.creationScope) ?? r$7).importNode(O, !0);
    E$1.currentNode = U;
    let W = E$1.nextNode(), B = 0, K = 0, X = F[0];
    for (; X !== void 0; ) {
      if (B === X.index) {
        let Y;
        X.type === 2 ? Y = new M(W, W.nextSibling, this, D) : X.type === 1 ? Y = new X.ctor(W, X.name, X.strings, this, D) : X.type === 6 && (Y = new L(W, this, D)), this._$AV.push(Y), X = F[++K];
      }
      B !== (X == null ? void 0 : X.index) && (W = E$1.nextNode(), B++);
    }
    return E$1.currentNode = r$7, U;
  }
  p(D) {
    let O = 0;
    for (const F of this._$AV)
      F !== void 0 && (F.strings !== void 0 ? (F._$AI(D, F, O), O += F.strings.length - 2) : F._$AI(D[O])), O++;
  }
}
class M {
  get _$AU() {
    var D;
    return ((D = this._$AM) == null ? void 0 : D._$AU) ?? this._$Cv;
  }
  constructor(D, O, F, U) {
    this.type = 2, this._$AH = T, this._$AN = void 0, this._$AA = D, this._$AB = O, this._$AM = F, this.options = U, this._$Cv = (U == null ? void 0 : U.isConnected) ?? !0;
  }
  get parentNode() {
    let D = this._$AA.parentNode;
    const O = this._$AM;
    return O !== void 0 && (D == null ? void 0 : D.nodeType) === 11 && (D = O.parentNode), D;
  }
  get startNode() {
    return this._$AA;
  }
  get endNode() {
    return this._$AB;
  }
  _$AI(D, O = this) {
    D = N(this, D, O), c$3(D) ? D === T || D == null || D === "" ? (this._$AH !== T && this._$AR(), this._$AH = T) : D !== this._$AH && D !== w$1 && this._(D) : D._$litType$ !== void 0 ? this.$(D) : D.nodeType !== void 0 ? this.T(D) : u$2(D) ? this.k(D) : this._(D);
  }
  S(D) {
    return this._$AA.parentNode.insertBefore(D, this._$AB);
  }
  T(D) {
    this._$AH !== D && (this._$AR(), this._$AH = this.S(D));
  }
  _(D) {
    this._$AH !== T && c$3(this._$AH) ? this._$AA.nextSibling.data = D : this.T(r$7.createTextNode(D)), this._$AH = D;
  }
  $(D) {
    var W;
    const { values: O, _$litType$: F } = D, U = typeof F == "number" ? this._$AC(D) : (F.el === void 0 && (F.el = V.createElement(C(F.h, F.h[0]), this.options)), F);
    if (((W = this._$AH) == null ? void 0 : W._$AD) === U)
      this._$AH.p(O);
    else {
      const B = new S(U, this), K = B.u(this.options);
      B.p(O), this.T(K), this._$AH = B;
    }
  }
  _$AC(D) {
    let O = A.get(D.strings);
    return O === void 0 && A.set(D.strings, O = new V(D)), O;
  }
  k(D) {
    a$2(this._$AH) || (this._$AH = [], this._$AR());
    const O = this._$AH;
    let F, U = 0;
    for (const W of D)
      U === O.length ? O.push(F = new M(this.S(l$3()), this.S(l$3()), this, this.options)) : F = O[U], F._$AI(W), U++;
    U < O.length && (this._$AR(F && F._$AB.nextSibling, U), O.length = U);
  }
  _$AR(D = this._$AA.nextSibling, O) {
    var F;
    for ((F = this._$AP) == null ? void 0 : F.call(this, !1, !0, O); D && D !== this._$AB; ) {
      const U = D.nextSibling;
      D.remove(), D = U;
    }
  }
  setConnected(D) {
    var O;
    this._$AM === void 0 && (this._$Cv = D, (O = this._$AP) == null || O.call(this, D));
  }
}
let R$1 = class {
  get tagName() {
    return this.element.tagName;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  constructor(D, O, F, U, W) {
    this.type = 1, this._$AH = T, this._$AN = void 0, this.element = D, this.name = O, this._$AM = U, this.options = W, F.length > 2 || F[0] !== "" || F[1] !== "" ? (this._$AH = Array(F.length - 1).fill(new String()), this.strings = F) : this._$AH = T;
  }
  _$AI(D, O = this, F, U) {
    const W = this.strings;
    let B = !1;
    if (W === void 0)
      D = N(this, D, O, 0), B = !c$3(D) || D !== this._$AH && D !== w$1, B && (this._$AH = D);
    else {
      const K = D;
      let X, Y;
      for (D = W[0], X = 0; X < W.length - 1; X++)
        Y = N(this, K[F + X], O, X), Y === w$1 && (Y = this._$AH[X]), B || (B = !c$3(Y) || Y !== this._$AH[X]), Y === T ? D = T : D !== T && (D += (Y ?? "") + W[X + 1]), this._$AH[X] = Y;
    }
    B && !U && this.j(D);
  }
  j(D) {
    D === T ? this.element.removeAttribute(this.name) : this.element.setAttribute(this.name, D ?? "");
  }
};
class k extends R$1 {
  constructor() {
    super(...arguments), this.type = 3;
  }
  j(D) {
    this.element[this.name] = D === T ? void 0 : D;
  }
}
let H$1 = class extends R$1 {
  constructor() {
    super(...arguments), this.type = 4;
  }
  j(D) {
    this.element.toggleAttribute(this.name, !!D && D !== T);
  }
};
class I extends R$1 {
  constructor(D, O, F, U, W) {
    super(D, O, F, U, W), this.type = 5;
  }
  _$AI(D, O = this) {
    if ((D = N(this, D, O, 0) ?? T) === w$1)
      return;
    const F = this._$AH, U = D === T && F !== T || D.capture !== F.capture || D.once !== F.once || D.passive !== F.passive, W = D !== T && (F === T || U);
    U && this.element.removeEventListener(this.name, this, F), W && this.element.addEventListener(this.name, this, D), this._$AH = D;
  }
  handleEvent(D) {
    var O;
    typeof this._$AH == "function" ? this._$AH.call(((O = this.options) == null ? void 0 : O.host) ?? this.element, D) : this._$AH.handleEvent(D);
  }
}
class L {
  constructor(D, O, F) {
    this.element = D, this.type = 6, this._$AN = void 0, this._$AM = O, this.options = F;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AI(D) {
    N(this, D);
  }
}
const Z = t$6.litHtmlPolyfillSupport;
Z == null || Z(V, M), (t$6.litHtmlVersions ?? (t$6.litHtmlVersions = [])).push("3.1.3");
const j = (z, D, O) => {
  const F = (O == null ? void 0 : O.renderBefore) ?? D;
  let U = F._$litPart$;
  if (U === void 0) {
    const W = (O == null ? void 0 : O.renderBefore) ?? null;
    F._$litPart$ = U = new M(D.insertBefore(l$3(), W), W, void 0, O ?? {});
  }
  return U._$AI(z), U;
};
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
let s$7 = class extends b$2 {
  constructor() {
    super(...arguments), this.renderOptions = { host: this }, this._$Do = void 0;
  }
  createRenderRoot() {
    var O;
    const D = super.createRenderRoot();
    return (O = this.renderOptions).renderBefore ?? (O.renderBefore = D.firstChild), D;
  }
  update(D) {
    const O = this.render();
    this.hasUpdated || (this.renderOptions.isConnected = this.isConnected), super.update(D), this._$Do = j(O, this.renderRoot, this.renderOptions);
  }
  connectedCallback() {
    var D;
    super.connectedCallback(), (D = this._$Do) == null || D.setConnected(!0);
  }
  disconnectedCallback() {
    var D;
    super.disconnectedCallback(), (D = this._$Do) == null || D.setConnected(!1);
  }
  render() {
    return w$1;
  }
};
var pt;
s$7._$litElement$ = !0, s$7.finalized = !0, (pt = globalThis.litElementHydrateSupport) == null || pt.call(globalThis, { LitElement: s$7 });
const r$6 = globalThis.litElementPolyfillSupport;
r$6 == null || r$6({ LitElement: s$7 });
(globalThis.litElementVersions ?? (globalThis.litElementVersions = [])).push("4.0.5");
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const t$5 = (z) => (D, O) => {
  O !== void 0 ? O.addInitializer(() => {
    customElements.define(z, D);
  }) : customElements.define(z, D);
};
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const o$c = { attribute: !0, type: String, converter: u$3, reflect: !1, hasChanged: f$4 }, r$5 = (z = o$c, D, O) => {
  const { kind: F, metadata: U } = O;
  let W = globalThis.litPropertyMetadata.get(U);
  if (W === void 0 && globalThis.litPropertyMetadata.set(U, W = /* @__PURE__ */ new Map()), W.set(O.name, z), F === "accessor") {
    const { name: B } = O;
    return { set(K) {
      const X = D.get.call(this);
      D.set.call(this, K), this.requestUpdate(B, X, z);
    }, init(K) {
      return K !== void 0 && this.P(B, void 0, z), K;
    } };
  }
  if (F === "setter") {
    const { name: B } = O;
    return function(K) {
      const X = this[B];
      D.call(this, K), this.requestUpdate(B, X, z);
    };
  }
  throw Error("Unsupported decorator location: " + F);
};
function n$6(z) {
  return (D, O) => typeof O == "object" ? r$5(z, D, O) : ((F, U, W) => {
    const B = U.hasOwnProperty(W);
    return U.constructor.createProperty(W, B ? { ...F, wrapped: !0 } : F), B ? Object.getOwnPropertyDescriptor(U, W) : void 0;
  })(z, D, O);
}
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
function r$4(z) {
  return n$6({ ...z, state: !0, attribute: !1 });
}
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
function t$4(z) {
  return (D, O) => {
    const F = typeof D == "function" ? D : D[O];
    Object.assign(F, z);
  };
}
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const e$c = (z, D, O) => (O.configurable = !0, O.enumerable = !0, Reflect.decorate && typeof D != "object" && Object.defineProperty(z, D, O), O);
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
function e$b(z, D) {
  return (O, F, U) => {
    const W = (B) => {
      var K;
      return ((K = B.renderRoot) == null ? void 0 : K.querySelector(z)) ?? null;
    };
    return e$c(O, F, { get() {
      return W(this);
    } });
  };
}
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
let e$a;
function r$3(z) {
  return (D, O) => e$c(D, O, { get() {
    return (this.renderRoot ?? e$a ?? (e$a = document.createDocumentFragment())).querySelectorAll(z);
  } });
}
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
function r$2(z) {
  return (D, O) => e$c(D, O, { async get() {
    var F;
    return await this.updateComplete, ((F = this.renderRoot) == null ? void 0 : F.querySelector(z)) ?? null;
  } });
}
/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
function o$b(z) {
  return (D, O) => {
    const { slot: F, selector: U } = {}, W = "slot" + (F ? `[name=${F}]` : ":not([name])");
    return e$c(D, O, { get() {
      var X;
      const B = (X = this.renderRoot) == null ? void 0 : X.querySelector(W), K = (B == null ? void 0 : B.assignedElements(z)) ?? [];
      return U === void 0 ? K : K.filter((Y) => Y.matches(U));
    } });
  };
}
const mediaControlsStyles = i$7`
  sl-menu-item[checked]::part(base) {
    background-color: var(--oe-selected-color);
    color: var(--oe-font-color);
  }

  .container {
    display: flex;
    position: relative;
    align-items: center;
    justify-content: center;
    margin-top: var(--oe-spacing);
    margin-bottom: var(--oe-spacing);
    color: var(--oe-font-color);
    width: fit-content;
    background-color: var(--oe-background-color);
    border-radius: var(--oe-border-rounding);
    box-shadow: var(--oe-box-shadow);
    font-size: calc(var(--oe-font-size));
    overflow: hidden;

    > :hover {
      background-color: var(--oe-panel-color);
    }

    > *:not(:last-child) {
      border-right: 1px solid var(--oe-font-color-lighter);
    }
  }
`;
/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
let s$6 = class extends Event {
  constructor(D, O, F) {
    super("context-request", { bubbles: !0, composed: !0 }), this.context = D, this.callback = O, this.subscribe = F ?? !1;
  }
};
/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
function n$5(z) {
  return z;
}
/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
let s$5 = class {
  constructor(D, O, F, U) {
    if (this.subscribe = !1, this.provided = !1, this.value = void 0, this.t = (W, B) => {
      this.unsubscribe && (this.unsubscribe !== B && (this.provided = !1, this.unsubscribe()), this.subscribe || this.unsubscribe()), this.value = W, this.host.requestUpdate(), this.provided && !this.subscribe || (this.provided = !0, this.callback && this.callback(W, B)), this.unsubscribe = B;
    }, this.host = D, O.context !== void 0) {
      const W = O;
      this.context = W.context, this.callback = W.callback, this.subscribe = W.subscribe ?? !1;
    } else
      this.context = O, this.callback = F, this.subscribe = U ?? !1;
    this.host.addController(this);
  }
  hostConnected() {
    this.dispatchRequest();
  }
  hostDisconnected() {
    this.unsubscribe && (this.unsubscribe(), this.unsubscribe = void 0);
  }
  dispatchRequest() {
    this.host.dispatchEvent(new s$6(this.context, this.t, this.subscribe));
  }
};
/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
let s$4 = class {
  get value() {
    return this.o;
  }
  set value(D) {
    this.setValue(D);
  }
  setValue(D, O = !1) {
    const F = O || !Object.is(D, this.o);
    this.o = D, F && this.updateObservers();
  }
  constructor(D) {
    this.subscriptions = /* @__PURE__ */ new Map(), this.updateObservers = () => {
      for (const [O, { disposer: F }] of this.subscriptions)
        O(this.o, F);
    }, D !== void 0 && (this.value = D);
  }
  addCallback(D, O, F) {
    if (!F)
      return void D(this.value);
    this.subscriptions.has(D) || this.subscriptions.set(D, { disposer: () => {
      this.subscriptions.delete(D);
    }, consumerHost: O });
    const { disposer: U } = this.subscriptions.get(D);
    D(this.value, U);
  }
  clearCallbacks() {
    this.subscriptions.clear();
  }
};
/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
let e$9 = class extends Event {
  constructor(D) {
    super("context-provider", { bubbles: !0, composed: !0 }), this.context = D;
  }
}, i$4 = class extends s$4 {
  constructor(D, O, F) {
    var U, W;
    super(O.context !== void 0 ? O.initialValue : F), this.onContextRequest = (B) => {
      const K = B.composedPath()[0];
      B.context === this.context && K !== this.host && (B.stopPropagation(), this.addCallback(B.callback, K, B.subscribe));
    }, this.onProviderRequest = (B) => {
      const K = B.composedPath()[0];
      if (B.context !== this.context || K === this.host)
        return;
      const X = /* @__PURE__ */ new Set();
      for (const [Y, { consumerHost: Q }] of this.subscriptions)
        X.has(Y) || (X.add(Y), Q.dispatchEvent(new s$6(this.context, Y, !0)));
      B.stopPropagation();
    }, this.host = D, O.context !== void 0 ? this.context = O.context : this.context = O, this.attachListeners(), (W = (U = this.host).addController) == null || W.call(U, this);
  }
  attachListeners() {
    this.host.addEventListener("context-request", this.onContextRequest), this.host.addEventListener("context-provider", this.onProviderRequest);
  }
  hostConnected() {
    this.host.dispatchEvent(new e$9(this.context));
  }
};
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
function e$8({ context: z }) {
  return (D, O) => {
    const F = /* @__PURE__ */ new WeakMap();
    if (typeof O == "object")
      return O.addInitializer(function() {
        F.set(this, new i$4(this, { context: z }));
      }), { get() {
        return D.get.call(this);
      }, set(U) {
        var W;
        return (W = F.get(this)) == null || W.setValue(U), D.set.call(this, U);
      }, init(U) {
        var W;
        return (W = F.get(this)) == null || W.setValue(U), U;
      } };
    {
      D.constructor.addInitializer((B) => {
        F.set(B, new i$4(B, { context: z }));
      });
      const U = Object.getOwnPropertyDescriptor(D, O);
      let W;
      if (U === void 0) {
        const B = /* @__PURE__ */ new WeakMap();
        W = { get: function() {
          return B.get(this);
        }, set: function(K) {
          F.get(this).setValue(K), B.set(this, K);
        }, configurable: !0, enumerable: !0 };
      } else {
        const B = U.set;
        W = { ...U, set: function(K) {
          F.get(this).setValue(K), B == null || B.call(this, K);
        } };
      }
      return void Object.defineProperty(D, O, W);
    }
  };
}
/**
 * @license
 * Copyright 2022 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
function c$2({ context: z, subscribe: D }) {
  return (O, F) => {
    typeof F == "object" ? F.addInitializer(function() {
      new s$5(this, { context: z, callback: (U) => {
        this[F.name] = U;
      }, subscribe: D });
    }) : O.constructor.addInitializer((U) => {
      new s$5(U, { context: z, callback: (W) => {
        U[F] = W;
      }, subscribe: D });
    });
  };
}
var __defProp$b = Object.defineProperty, __decorateClass$b = (z, D, O, F) => {
  for (var U = void 0, W = z.length - 1, B; W >= 0; W--)
    (B = z[W]) && (U = B(D, O, U) || U);
  return U && __defProp$b(D, O, U), U;
};
const rootContext = Symbol("rootContext");
class LoggerImplementation extends s$7 {
  doThing() {
    var D;
    (D = this.logger) == null || D.log("Hello, world!");
  }
}
__decorateClass$b([
  c$2({ context: rootContext, subscribe: !0 }),
  n$6({ attribute: !1 })
], LoggerImplementation.prototype, "logger");
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const t$3 = { ATTRIBUTE: 1, CHILD: 2, PROPERTY: 3, BOOLEAN_ATTRIBUTE: 4, EVENT: 5, ELEMENT: 6 }, e$7 = (z) => (...D) => ({ _$litDirective$: z, values: D });
let i$3 = class {
  constructor(D) {
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AT(D, O, F) {
    this._$Ct = D, this._$AM = O, this._$Ci = F;
  }
  _$AS(D, O) {
    return this.update(D, O);
  }
  update(D, O) {
    return this.render(...O);
  }
};
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
let e$6 = class extends i$3 {
  constructor(D) {
    if (super(D), this.it = T, D.type !== t$3.CHILD)
      throw Error(this.constructor.directiveName + "() can only be used in child bindings");
  }
  render(D) {
    if (D === T || D == null)
      return this._t = void 0, this.it = D;
    if (D === w$1)
      return D;
    if (typeof D != "string")
      throw Error(this.constructor.directiveName + "() called with a non-string value");
    if (D === this.it)
      return this._t;
    this.it = D;
    const O = [D];
    return O.raw = O, this._t = { _$litType$: this.constructor.resultType, strings: O, values: [] };
  }
};
e$6.directiveName = "unsafeHTML", e$6.resultType = 1;
const o$a = e$7(e$6);
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
let t$2 = class extends e$6 {
};
t$2.directiveName = "unsafeSVG", t$2.resultType = 2;
const o$9 = e$7(t$2);
class ReactiveController {
  constructor(D) {
    this.host = D, this.host.addController(this);
  }
  hostConnected() {
    this.host.shadowRoot.addEventListener("slotchange", (D) => this.handleSlotChange(D));
  }
  hostDisconnected() {
    this.host.shadowRoot.removeEventListener("slotchange", (D) => this.handleSlotChange(D));
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  handleSlotChange(D) {
    this.host.requestUpdate();
  }
}
const theming = i$7`
  @import url("https://fonts.googleapis.com/css2?family=Roboto:ital,wght@0,100;0,300;0,400;0,500;0,700;0,900;1,100;1,300;1,400;1,500;1,700;1,900&display=swap");

  /* TODO: we probably only need :host here */
  :host,
  :root {
    --oe-theme-hue: 247deg;
    --oe-theme-saturation: 87%;
    --oe-theme-lightness: 54%;

    /* A2O Colours */
    /* --oe-theme-hue: 142deg;
    --oe-theme-saturation: 25%;
    --oe-theme-lightness: 35%; */

    /* Ecosounds Colours */
    /* --oe-theme-hue: 207;
    --oe-theme-saturation: 100%;
    --oe-theme-lightness: 25%; */

    --oe-background-color: hsl(var(--oe-theme-hue), var(--oe-theme-saturation), 100%);
    --oe-font-color: hsl(
      var(--oe-theme-hue),
      calc(var(--oe-theme-saturation) - 50%),
      calc(var(--oe-theme-lightness) - 90%)
    );

    --oe-border-rounding: 6px;
    --oe-border-color: hsl(var(--oe-theme-hue), var(--oe-theme-saturation), calc(var(--oe-theme-lightness) - 10%));
    --oe-border-width: 2px;

    --oe-box-shadow: 1px 1px 1px currentcolor;
    --oe-font-family: "Roboto", sans-serif;
    --oe-font-size: 11px;

    --oe-animation-time: 0.3s;
    --oe-spacing: 0.6em;

    --oe-primary-color: hsl(var(--oe-theme-hue), var(--oe-theme-saturation), var(--oe-theme-lightness));
    --oe-secondary-color: hsl(var(--oe-theme-hue), var(--oe-theme-saturation), calc(var(--oe-theme-lightness) + 25%));
    --oe-accent-color: hsl(var(--oe-theme-hue), var(--oe-theme-saturation), calc(var(--oe-theme-lightness) + 20%));
    --oe-info-color: hsl(207deg, calc(var(--oe-theme-saturation) + 45%), calc(var(--oe-theme-lightness) + 15%));
    --oe-danger-color: color-mix(in srgb, hsl(0deg, 80%, 46%) 85%, var(--oe-background-color));
    --oe-selected-color: hsl(
      var(--oe-theme-hue),
      var(--oe-theme-saturation),
      max(calc(var(--oe-theme-lightness) + 25%), 90%)
    );
    --oe-panel-color: hsl(
      var(--oe-theme-hue),
      var(--oe-theme-saturation),
      max(calc(var(--oe-theme-lightness) + 43%), 96%)
    );

    --oe-font-color-lighter: color-mix(in srgb, var(--oe-font-color) 10%, var(--oe-background-color));
    --oe-panel-color-lighter: color-mix(in srgb, var(--oe-panel-color) 1%, var(--oe-background-color));
  }

  * {
    font-family: var(--oe-font-family);

    /* CSS Resets */
    font-weight: normal;
  }

  :has(> svg.lucide) {
    padding: var(--oe-spacing);
    display: flex;
    align-items: center;
    justify-content: center;

    /* All icons should be the same size as the font */
    svg.lucide {
      width: calc(var(--oe-font-size) + var(--oe-spacing));
      height: calc(var(--oe-font-size) + var(--oe-spacing));
    }
  }

  button:disabled,
  input:disabled {
    filter: grayscale(100%);
    opacity: 0.5;
    cursor: not-allowed;
  }

  kbd {
    position: relative;
    display: inline-block;
    color: var(--oe-font-color);
    font-family: "Courier New", Courier, monospace;
    text-align: center;
    font-weight: bold;
    padding: 0.2rem;
    padding-left: 0.5em;
    padding-right: 0.5em;
    z-index: 0;
    margin-top: 0.2rem;
    margin: 0.5rem;
    width: max-content;

    &::before {
      content: "";
      position: absolute;
      top: 0px;
      left: 0px;
      width: 100%;
      height: 100%;
      border-radius: 0.13em;
      background: radial-gradient(circle farthest-corner at top right, #ededed, #c8c8c8);
      box-shadow: 0.13em 0.13em 0 0.1em rgba(0, 0, 0, 0.2);
      z-index: -1;
    }

    &::after {
      content: "";
      position: absolute;
      top: -0.065em;
      left: -0.065em;
      width: 100%;
      height: 100%;
      padding: 0.13em;
      border-radius: 0.15em;
      background: radial-gradient(circle farthest-corner at bottom right, #cacaca, #cacaca);
      box-shadow: 0.065em 0.065em 0.13em 0.13em rgba(0, 0, 0, 0.5);
      z-index: -2;
    }
  }

  a {
    text-decoration: underline;
    color: var(--oe-font-color);

    &:hover {
      text-decoration: none;
    }
  }

  hr {
    border: 0;
    height: 1px;
    background-color: var(--oe-font-color-lighter);
  }

  dialog {
    position: relative;
    box-shadow: var(--oe-box-shadow);
    border: var(--oe-border-width) solid var(--oe-selected-color);
    min-width: 70%;
    max-width: 80%;
    max-height: 100%;
    background-color: var(--oe-background-color);
    border-radius: var(--oe-border-rounding);
    padding: 2rem;

    animation: fade-in 600ms forwards;

    dialog[open] {
      animation: fade-in 600ms forwards;
    }

    /* Styles applied to mobile devices */
    @media (max-width: 600px) {
      max-width: 100%;
      padding: 1rem;
    }
  }

  p {
    margin-top: 0.5rem;
    font-size: 1rem;
    color: var(--oe-font-color);
  }

  input:not([type="checkbox"], [type="radio"]),
  textarea,
  select {
    box-shadow: 0 0 0 1px var(--oe-secondary-color);

    &:focus {
      box-shadow: 0 0 0 2px var(--oe-selected-color);
    }
  }

  input,
  textarea,
  select {
    font-size: 1rem;
    padding: var(--oe-spacing);
    border: none;
    border-radius: var(--oe-border-rounding);
    background-color: var(--oe-panel-color-lighter);
    color: var(--oe-font-color);

    &:focus {
      outline: none;
      border-color: var(--oe-selected-color);
      background-color: var(--oe-background-color);
    }
  }

  input[type="number"] {
    -moz-appearance: textfield;
    -webkit-appearance: none;
    appearance: textfield;
  }

  input[type="range"] {
    padding: 0;

    /* &::-webkit-slider-thumb,
    &::-moz-range-thumb {
      background: var(--oe-primary-color);
      border-radius: var(--oe-border-rounding);
    }

    &::-webkit-slider-runnable-track,
    &::-moz-range-track {
      background-color: var(--oe-panel-color);
    } */
  }

  input[type="checkbox"],
  input[type="radio"] {
    position: relative;
    accent-color: var(--oe-primary-color);
    width: 1.2rem;
    height: 1.2rem;
  }

  label:has(input) {
    display: flex;
    align-items: center;
    gap: var(--oe-spacing);
  }

  input[type="file"] {
    position: relative;
    padding: 0.5rem;
    border: none;

    &::file-selector-button {
      border: none;
      border-radius: var(--oe-border-rounding);
      color: var(--oe-font-color);
      font-weight: bold;
      background-color: var(--oe-panel-color);
      padding: 0.5rem;
    }
  }

  /*
    Ripple effect is modified from a CSS-Tricks article
    https://css-tricks.com/how-to-recreate-the-ripple-effect-of-material-design-buttons/#aa-css-only
  */
  button {
    --background-color: var(--oe-panel-color);
    --border: none;
    --ripple-color: color-mix(in srgb, var(--background-color) 90%, black);

    border: var(--border);
    border-radius: var(--oe-border-rounding);
    margin: 0.1rem;
    font-size: 1em;
    max-width: max-content;
    padding: var(--oe-spacing);
    background-color: var(--background-color);
    transition: background var(--oe-animation-time), border var(--oe-animation-time);
    cursor: pointer;

    /*
      Box shadows make a button look raised and clickable.
      Therefore, if the button is disabled, we do not want to show the box shadow.
    */
    &:not(:disabled, .disabled) {
      box-shadow: var(--oe-box-shadow);
    }

    &:hover:not(:disabled, .disabled) {
      background: var(--background-color) radial-gradient(circle, transparent 1%, var(--background-color) 1%)
        center/15000%;
    }

    &:active:not(:disabled, .disabled) {
      background-color: var(--ripple-color);
      background-size: 100%;
      transition: background 0s;
    }

    /*
      User agents create an outline around an element that has explicit focus
      (focus set through .focus)
      However, this is not the behavior that we want. Therefore, we use a CSS
      reset to disable this behavior
    */
    &:focus {
      outline: none;
    }
  }

  .hidden {
    display: none;
  }

  .disabled {
    filter: grayscale(100%);
    opacity: 0.5;
    cursor: not-allowed;
  }

  .oe-btn-primary {
    border: var(--oe-border-width) solid var(--oe-primary-color);
  }

  .oe-btn-secondary {
    border: var(--oe-border-width) solid var(--oe-secondary-color);
  }

  .oe-btn-info {
    --border: var(--oe-border-width) solid var(--oe-info-color);
  }

  .oe-btn-danger {
    --background-color: var(--oe-danger-color);
    color: white;
  }

  @keyframes fade-in {
    0% {
      opacity: 0;
    }
    100% {
      opacity: 1;
    }
  }
`, AbstractComponent = (z) => {
  class D extends z {
    constructor(...F) {
      super(F), this.reactiveController = new ReactiveController(this);
    }
    static finalizeStyles(F) {
      let U = [theming];
      return Array.isArray(F) ? U = [theming, ...F] : F !== void 0 && (U = [theming, F]), super.finalizeStyles(U);
    }
    // TODO: find out if we have to explicitly call hostConnected and hostDisconnected
    connectedCallback() {
      super.connectedCallback(), this.reactiveController.hostConnected();
    }
    disconnectedCallback() {
      super.disconnectedCallback(), this.reactiveController.hostDisconnected();
    }
  }
  return D;
}, lucidPlayIcon = `<!-- @license lucide-static v0.363.0 - ISC -->
<svg
  class="lucide lucide-play"
  xmlns="http://www.w3.org/2000/svg"
  width="24"
  height="24"
  viewBox="0 0 24 24"
  fill="none"
  stroke="currentColor"
  stroke-width="2"
  stroke-linecap="round"
  stroke-linejoin="round"
>
  <polygon points="6 3 20 12 6 21 6 3" />
</svg>
`, lucidPauseIcon = `<!-- @license lucide-static v0.363.0 - ISC -->
<svg
  class="lucide lucide-pause"
  xmlns="http://www.w3.org/2000/svg"
  width="24"
  height="24"
  viewBox="0 0 24 24"
  fill="none"
  stroke="currentColor"
  stroke-width="2"
  stroke-linecap="round"
  stroke-linejoin="round"
>
  <rect x="14" y="4" width="4" height="16" rx="1" />
  <rect x="6" y="4" width="4" height="16" rx="1" />
</svg>
`, lucideSettingsIcon = `<!-- @license lucide-static v0.363.0 - ISC -->
<svg
  class="lucide lucide-settings"
  xmlns="http://www.w3.org/2000/svg"
  width="24"
  height="24"
  viewBox="0 0 24 24"
  fill="none"
  stroke="currentColor"
  stroke-width="2"
  stroke-linecap="round"
  stroke-linejoin="round"
>
  <path d="M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 1 1.72v.51a2 2 0 0 1-1 1.74l-.15.09a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l.22-.39a2 2 0 0 0-.73-2.73l-.15-.08a2 2 0 0 1-1-1.74v-.5a2 2 0 0 1 1-1.74l.15-.09a2 2 0 0 0 .73-2.73l-.22-.38a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43-.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z" />
  <circle cx="12" cy="12" r="3" />
</svg>
`, lucidePalletteIcon = `<!-- @license lucide-static v0.363.0 - ISC -->
<svg
  class="lucide lucide-palette"
  xmlns="http://www.w3.org/2000/svg"
  width="24"
  height="24"
  viewBox="0 0 24 24"
  fill="none"
  stroke="currentColor"
  stroke-width="2"
  stroke-linecap="round"
  stroke-linejoin="round"
>
  <circle cx="13.5" cy="6.5" r=".5" fill="currentColor" />
  <circle cx="17.5" cy="10.5" r=".5" fill="currentColor" />
  <circle cx="8.5" cy="7.5" r=".5" fill="currentColor" />
  <circle cx="6.5" cy="12.5" r=".5" fill="currentColor" />
  <path d="M12 2C6.5 2 2 6.5 2 12s4.5 10 10 10c.926 0 1.648-.746 1.648-1.688 0-.437-.18-.835-.437-1.125-.29-.289-.438-.652-.438-1.125a1.64 1.64 0 0 1 1.668-1.668h1.996c3.051 0 5.555-2.503 5.555-5.554C21.965 6.012 17.461 2 12 2z" />
</svg>
`, lucideSunIcon = `<!-- @license lucide-static v0.363.0 - ISC -->
<svg
  class="lucide lucide-sun"
  xmlns="http://www.w3.org/2000/svg"
  width="24"
  height="24"
  viewBox="0 0 24 24"
  fill="none"
  stroke="currentColor"
  stroke-width="2"
  stroke-linecap="round"
  stroke-linejoin="round"
>
  <circle cx="12" cy="12" r="4" />
  <path d="M12 2v2" />
  <path d="M12 20v2" />
  <path d="m4.93 4.93 1.41 1.41" />
  <path d="m17.66 17.66 1.41 1.41" />
  <path d="M2 12h2" />
  <path d="M20 12h2" />
  <path d="m6.34 17.66-1.41 1.41" />
  <path d="m19.07 4.93-1.41 1.41" />
</svg>
`, lucideContrastIcon = `<!-- @license lucide-static v0.363.0 - ISC -->
<svg
  class="lucide lucide-contrast"
  xmlns="http://www.w3.org/2000/svg"
  width="24"
  height="24"
  viewBox="0 0 24 24"
  fill="none"
  stroke="currentColor"
  stroke-width="2"
  stroke-linecap="round"
  stroke-linejoin="round"
>
  <circle cx="12" cy="12" r="10" />
  <path d="M12 18a6 6 0 0 0 0-12v12z" />
</svg>
`, axesStyles = i$7`
  :host {
    position: relative;
    display: inline-block !important;
    width: 100%;
  }

  #wrapped-element {
    position: relative;
    padding-left: 3rem;
    padding-bottom: 1.5rem;
  }

  svg {
    position: absolute;
    /* width: 100%; */
    height: 100%;
    z-index: 1;
    overflow: visible;

    line {
      shape-rendering: crispEdges;
    }

    text {
      fill: var(--oe-font-color);
      stroke: none;
      font: 11px sans-serif;
    }

    g {
      stroke: currentColor;
    }
  }

  .grid-line {
    color: lightblue;
    stroke-width: 1;
    opacity: 0.4;
  }
`;
var i$2 = Symbol.for("preact-signals");
function t$1() {
  if (s$3 > 1)
    s$3--;
  else {
    for (var z, D = !1; h$2 !== void 0; ) {
      var O = h$2;
      for (h$2 = void 0, f$2++; O !== void 0; ) {
        var F = O.o;
        if (O.o = void 0, O.f &= -3, !(8 & O.f) && c$1(O))
          try {
            O.c();
          } catch (U) {
            D || (z = U, D = !0);
          }
        O = F;
      }
    }
    if (f$2 = 0, s$3--, D)
      throw z;
  }
}
var o$8 = void 0, h$2 = void 0, s$3 = 0, f$2 = 0, v = 0;
function e$5(z) {
  if (o$8 !== void 0) {
    var D = z.n;
    if (D === void 0 || D.t !== o$8)
      return D = { i: 0, S: z, p: o$8.s, n: void 0, t: o$8, e: void 0, x: void 0, r: D }, o$8.s !== void 0 && (o$8.s.n = D), o$8.s = D, z.n = D, 32 & o$8.f && z.S(D), D;
    if (D.i === -1)
      return D.i = 0, D.n !== void 0 && (D.n.p = D.p, D.p !== void 0 && (D.p.n = D.n), D.p = o$8.s, D.n = void 0, o$8.s.n = D, o$8.s = D), D;
  }
}
function u$1(z) {
  this.v = z, this.i = 0, this.n = void 0, this.t = void 0;
}
u$1.prototype.brand = i$2;
u$1.prototype.h = function() {
  return !0;
};
u$1.prototype.S = function(z) {
  this.t !== z && z.e === void 0 && (z.x = this.t, this.t !== void 0 && (this.t.e = z), this.t = z);
};
u$1.prototype.U = function(z) {
  if (this.t !== void 0) {
    var D = z.e, O = z.x;
    D !== void 0 && (D.x = O, z.e = void 0), O !== void 0 && (O.e = D, z.x = void 0), z === this.t && (this.t = O);
  }
};
u$1.prototype.subscribe = function(z) {
  var D = this;
  return E(function() {
    var O = D.value, F = o$8;
    o$8 = void 0;
    try {
      z(O);
    } finally {
      o$8 = F;
    }
  });
};
u$1.prototype.valueOf = function() {
  return this.value;
};
u$1.prototype.toString = function() {
  return this.value + "";
};
u$1.prototype.toJSON = function() {
  return this.value;
};
u$1.prototype.peek = function() {
  var z = o$8;
  o$8 = void 0;
  try {
    return this.value;
  } finally {
    o$8 = z;
  }
};
Object.defineProperty(u$1.prototype, "value", { get: function() {
  var z = e$5(this);
  return z !== void 0 && (z.i = this.i), this.v;
}, set: function(z) {
  if (z !== this.v) {
    if (f$2 > 100)
      throw new Error("Cycle detected");
    this.v = z, this.i++, v++, s$3++;
    try {
      for (var D = this.t; D !== void 0; D = D.x)
        D.t.N();
    } finally {
      t$1();
    }
  }
} });
function d(z) {
  return new u$1(z);
}
function c$1(z) {
  for (var D = z.s; D !== void 0; D = D.n)
    if (D.S.i !== D.i || !D.S.h() || D.S.i !== D.i)
      return !0;
  return !1;
}
function a$1(z) {
  for (var D = z.s; D !== void 0; D = D.n) {
    var O = D.S.n;
    if (O !== void 0 && (D.r = O), D.S.n = D, D.i = -1, D.n === void 0) {
      z.s = D;
      break;
    }
  }
}
function l$2(z) {
  for (var D = z.s, O = void 0; D !== void 0; ) {
    var F = D.p;
    D.i === -1 ? (D.S.U(D), F !== void 0 && (F.n = D.n), D.n !== void 0 && (D.n.p = F)) : O = D, D.S.n = D.r, D.r !== void 0 && (D.r = void 0), D = F;
  }
  z.s = O;
}
function y(z) {
  u$1.call(this, void 0), this.x = z, this.s = void 0, this.g = v - 1, this.f = 4;
}
(y.prototype = new u$1()).h = function() {
  if (this.f &= -3, 1 & this.f)
    return !1;
  if ((36 & this.f) == 32 || (this.f &= -5, this.g === v))
    return !0;
  if (this.g = v, this.f |= 1, this.i > 0 && !c$1(this))
    return this.f &= -2, !0;
  var z = o$8;
  try {
    a$1(this), o$8 = this;
    var D = this.x();
    (16 & this.f || this.v !== D || this.i === 0) && (this.v = D, this.f &= -17, this.i++);
  } catch (O) {
    this.v = O, this.f |= 16, this.i++;
  }
  return o$8 = z, l$2(this), this.f &= -2, !0;
};
y.prototype.S = function(z) {
  if (this.t === void 0) {
    this.f |= 36;
    for (var D = this.s; D !== void 0; D = D.n)
      D.S.S(D);
  }
  u$1.prototype.S.call(this, z);
};
y.prototype.U = function(z) {
  if (this.t !== void 0 && (u$1.prototype.U.call(this, z), this.t === void 0)) {
    this.f &= -33;
    for (var D = this.s; D !== void 0; D = D.n)
      D.S.U(D);
  }
};
y.prototype.N = function() {
  if (!(2 & this.f)) {
    this.f |= 6;
    for (var z = this.t; z !== void 0; z = z.x)
      z.t.N();
  }
};
Object.defineProperty(y.prototype, "value", { get: function() {
  if (1 & this.f)
    throw new Error("Cycle detected");
  var z = e$5(this);
  if (this.h(), z !== void 0 && (z.i = this.i), 16 & this.f)
    throw this.v;
  return this.v;
} });
function w(z) {
  return new y(z);
}
function _(z) {
  var D = z.u;
  if (z.u = void 0, typeof D == "function") {
    s$3++;
    var O = o$8;
    o$8 = void 0;
    try {
      D();
    } catch (F) {
      throw z.f &= -2, z.f |= 8, g$2(z), F;
    } finally {
      o$8 = O, t$1();
    }
  }
}
function g$2(z) {
  for (var D = z.s; D !== void 0; D = D.n)
    D.S.U(D);
  z.x = void 0, z.s = void 0, _(z);
}
function p(z) {
  if (o$8 !== this)
    throw new Error("Out-of-order effect");
  l$2(this), o$8 = z, this.f &= -2, 8 & this.f && g$2(this), t$1();
}
function b(z) {
  this.x = z, this.u = void 0, this.s = void 0, this.o = void 0, this.f = 32;
}
b.prototype.c = function() {
  var z = this.S();
  try {
    if (8 & this.f || this.x === void 0)
      return;
    var D = this.x();
    typeof D == "function" && (this.u = D);
  } finally {
    z();
  }
};
b.prototype.S = function() {
  if (1 & this.f)
    throw new Error("Cycle detected");
  this.f |= 1, this.f &= -9, _(this), a$1(this), s$3++;
  var z = o$8;
  return o$8 = this, p.bind(this, z);
};
b.prototype.N = function() {
  2 & this.f || (this.f |= 2, this.o = h$2, h$2 = this);
};
b.prototype.d = function() {
  this.f |= 8, 1 & this.f || g$2(this);
};
function E(z) {
  var D = new b(z);
  try {
    D.c();
  } catch (O) {
    throw D.d(), O;
  }
  return D.d.bind(D);
}
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
function e$4(z) {
  return class extends z {
    performUpdate() {
      var D;
      if (this.isUpdatePending === !1)
        return;
      (D = this._$Oo) === null || D === void 0 || D.call(this);
      let O = !0;
      this._$Oo = E(() => {
        O ? (O = !1, super.performUpdate()) : this.requestUpdate();
      });
    }
    connectedCallback() {
      super.connectedCallback(), this.requestUpdate();
    }
    disconnectedCallback() {
      var D;
      super.disconnectedCallback(), (D = this._$Oo) === null || D === void 0 || D.call(this);
    }
  };
}
/**
 * @license
 * Copyright 2020 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const e$3 = (z, D) => (z == null ? void 0 : z._$litType$) !== void 0, f$1 = (z) => z.strings === void 0, u = {}, m = (z, D = u) => z._$AH = D;
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const s$2 = (z, D) => {
  var F;
  const O = z._$AN;
  if (O === void 0)
    return !1;
  for (const U of O)
    (F = U._$AO) == null || F.call(U, D, !1), s$2(U, D);
  return !0;
}, o$7 = (z) => {
  let D, O;
  do {
    if ((D = z._$AM) === void 0)
      break;
    O = D._$AN, O.delete(z), z = D;
  } while ((O == null ? void 0 : O.size) === 0);
}, r$1 = (z) => {
  for (let D; D = z._$AM; z = D) {
    let O = D._$AN;
    if (O === void 0)
      D._$AN = O = /* @__PURE__ */ new Set();
    else if (O.has(z))
      break;
    O.add(z), c(D);
  }
};
function h$1(z) {
  this._$AN !== void 0 ? (o$7(this), this._$AM = z, r$1(this)) : this._$AM = z;
}
function n$4(z, D = !1, O = 0) {
  const F = this._$AH, U = this._$AN;
  if (U !== void 0 && U.size !== 0)
    if (D)
      if (Array.isArray(F))
        for (let W = O; W < F.length; W++)
          s$2(F[W], !1), o$7(F[W]);
      else
        F != null && (s$2(F, !1), o$7(F));
    else
      s$2(this, z);
}
const c = (z) => {
  z.type == t$3.CHILD && (z._$AP ?? (z._$AP = n$4), z._$AQ ?? (z._$AQ = h$1));
};
class f extends i$3 {
  constructor() {
    super(...arguments), this._$AN = void 0;
  }
  _$AT(D, O, F) {
    super._$AT(D, O, F), r$1(this), this.isConnected = D._$AU;
  }
  _$AO(D, O = !0) {
    var F, U;
    D !== this.isConnected && (this.isConnected = D, D ? (F = this.reconnected) == null || F.call(this) : (U = this.disconnected) == null || U.call(this)), O && (s$2(this, D), o$7(this));
  }
  setValue(D) {
    if (f$1(this._$Ct))
      this._$Ct._$AI(D, this);
    else {
      const O = [...this._$Ct._$AH];
      O[this._$Ci] = D, this._$Ct._$AI(O, this, 0);
    }
  }
  disconnected() {
  }
  reconnected() {
  }
}
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const s$1 = e$7(class extends f {
  render(z) {
    var D;
    if (z !== this._$Oi) {
      (D = this._$Oo) === null || D === void 0 || D.call(this), this._$Oi = z;
      let O = !0;
      this._$Oo = z.subscribe((F) => {
        O === !1 && this.setValue(F);
      }), O = !1;
    }
    return z.peek();
  }
  disconnected() {
    var z;
    (z = this._$Oo) === null || z === void 0 || z.call(this);
  }
  reconnected() {
    var z;
    this._$Oo = (z = this._$Oi) === null || z === void 0 ? void 0 : z.subscribe((D) => {
      this.setValue(D);
    });
  }
}), booleanConverter = (z) => z !== null && z !== "false";
function queryDeeplyAssignedElement(z) {
  return (D, O) => {
    Object.defineProperty(D, O, {
      get() {
        var B;
        const U = `slot${z.slot ?? ""}`, W = (B = this.renderRoot) == null ? void 0 : B.querySelectorAll(U);
        for (const K of W) {
          const X = K.assignedElements();
          for (const Y of X) {
            if (Y.matches(z.selector))
              return Y;
            const Q = Y.querySelector(z.selector);
            if (Q !== null)
              return Q;
          }
        }
        return null;
      }
    });
  };
}
function queryAllDeeplyAssignedElements(z) {
  return (D, O) => {
    Object.defineProperty(D, O, {
      get() {
        var K;
        const U = `slot${z.slot ?? ""}`, W = (K = this.renderRoot) == null ? void 0 : K.querySelectorAll(U), B = [];
        for (const X of W) {
          const Y = X.assignedElements();
          for (const Q of Y) {
            Q.matches(z.selector) && B.push(Q);
            const J = Q.querySelectorAll(z.selector);
            J.length > 0 && B.push(...J);
          }
        }
        return B.length > 0 ? B : null;
      }
    });
  };
}
var __defProp$a = Object.defineProperty, __getOwnPropDesc$a = Object.getOwnPropertyDescriptor, __decorateClass$a = (z, D, O, F) => {
  for (var U = F > 1 ? void 0 : F ? __getOwnPropDesc$a(D, O) : D, W = z.length - 1, B; W >= 0; W--)
    (B = z[W]) && (U = (F ? B(D, O, U) : B(U)) || U);
  return F && U && __defProp$a(D, O, U), U;
};
let Axes = class extends e$4(AbstractComponent(s$7)) {
  constructor() {
    super(...arguments), this.xLabel = "Time (Seconds)", this.yLabel = "Frequency (KHz)", this.showXTitle = !0, this.showYTitle = !0, this.showXAxis = !0, this.showYAxis = !0, this.showXGrid = !0, this.showYGrid = !0, this.labelPadding = 8, this.tickSize = 8, this.titleOffset = 4;
  }
  handleSlotchange() {
    this.unitConverter = this.spectrogram.unitConverters;
  }
  // because querying the DOM for the font size will cause a repaint and reflow
  // we calculate the value once using a canvas
  calculateFontSize(z = "M") {
    const O = document.createElement("canvas").getContext("2d");
    O.font = "var(--oe-font-size) var(--oe-font-family)";
    const F = O.measureText(z), U = F.width, W = F.actualBoundingBoxAscent + F.actualBoundingBoxDescent;
    return { width: U, height: W };
  }
  createGridLines(z, D, O) {
    const F = (X, Y) => X > 0 && X < Y.length - 1, U = (X) => {
      const Y = this.unitConverter.scaleX.value(X);
      return b$1`<line
        x1="${Y}"
        x2="${Y}"
        y1="0"
        y2="${O.height}"
        class="grid-line"
      ></line>`;
    }, W = (X) => {
      const Y = this.unitConverter.scaleY.value(X);
      return b$1`<line
        x1="0"
        x2="${O.width}"
        y1="${Y}"
        y2="${Y}"
        class="grid-line"
      ></line>`;
    }, B = b$1`${z.map(
      (X, Y) => b$1`${F(Y, z) && U(X)}`
    )}`, K = b$1`${D.map(
      (X, Y) => b$1`${F(Y, D) && W(X)}`
    )}`;
    return b$1`
      <g part="grid">
        ${this.showXGrid ? b$1`<g part="x-grid">${B}</g>` : ""}
        ${this.showYGrid ? b$1`<g part="y-grid">${K}</g>` : ""}
      </g>
    `;
  }
  // TODO: We should probably refactor this so that we only calculate the font size
  // once per each unique length of strings
  createAxisLabels(z, D, O) {
    const F = this.calculateFontSize(this.xLabel), U = this.calculateFontSize(this.yLabel), W = Math.max(...D.map((ie) => ie / 1e3)).toFixed(1), B = this.calculateFontSize(W), K = F.height + B.height + this.tickSize + this.titleOffset, X = U.height + B.width + this.tickSize, Y = (ie) => {
      const ue = this.unitConverter.scaleX.value(ie), q = O.height + this.tickSize;
      return b$1`<g>
        <line
          x1="${this.unitConverter.scaleX.value(ie)}"
          x2="${this.unitConverter.scaleX.value(ie)}"
          y1="${O.height}"
          y2="${O.height + this.tickSize}"
        ></line>
        <text
          part="label x-label"
          text-anchor="middle"
          dominant-baseline="end"
          x="${ue}"
          y="${q + this.tickSize}"
        >
          ${ie.toFixed(1)}
        </text>
      </g>`;
    }, Q = (ie) => {
      const ue = -this.tickSize, q = this.unitConverter.scaleY.value(ie);
      return b$1`<g>
        <line
          x1="${ue}"
          x2="${ue + this.tickSize}"
          y1="${this.unitConverter.scaleY.value(ie)}"
          y2="${this.unitConverter.scaleY.value(ie)}"
        ></line>
        <text
          part="label y-label"
          text-anchor="end"
          dominant-baseline="middle"
          x="${ue - this.labelPadding}"
          y="${q}"
        >
          ${(ie / 1e3).toFixed(1)}
        </text>
      </g>`;
    }, J = this.showXAxis ? b$1`${z.map((ie) => Y(ie))}` : T, ee = this.showYAxis ? b$1`${D.map((ie) => Q(ie))}` : T, ae = this.showXTitle ? b$1`
      <text
        part="title x-title"
        x="${O.width / 2}"
        y="${O.height + K}"
        text-anchor="middle"
        font-family="sans-serif"
      >
        ${this.xLabel}
      </text>
    ` : T, re = this.showYTitle ? b$1`
      <text
        part="title y-title"
        x="-${X}"
        y="${O.height / 2}"
        transform="rotate(270, -${X}, ${O.height / 2})"
        text-anchor="middle"
        font-family="sans-serif"
      >
        ${this.yLabel}
      </text>
    ` : T;
    return b$1`
      <g part="tick">
        <g part="x-tick">
          ${J}
          ${ae}
        </g>

        <g part="y-tick">
          ${ee}
          ${re}
        </g>
      </g>
    `;
  }
  createAxes() {
    const z = this.xValues(), D = this.yValues(), O = this.unitConverter.canvasSize.value, F = this.createGridLines(z, D, O), U = this.createAxisLabels(z, D, O);
    return x`<svg>${F} ${U}</svg>`;
  }
  xValues() {
    const z = this.xStepOverride || this.calculateStep(
      this.unitConverter.temporalDomain.value,
      this.unitConverter.temporalRange.value,
      this.unitConverter.scaleX.value,
      "width"
    );
    return this.generateAxisValues(
      this.unitConverter.renderWindow.value.startOffset,
      this.unitConverter.renderWindow.value.endOffset,
      z,
      this.unitConverter.scaleX.value
    );
  }
  yValues() {
    const z = this.yStepOverride || this.calculateStep(
      this.unitConverter.frequencyDomain.value,
      this.unitConverter.frequencyRange.value,
      this.unitConverter.scaleY.value,
      "height"
    );
    return this.generateAxisValues(
      this.unitConverter.renderWindow.value.lowFrequency,
      this.unitConverter.renderWindow.value.highFrequency,
      z,
      this.unitConverter.scaleY.value,
      !1
    );
  }
  willFitStep(z, D, O, F, U, W) {
    if (!W) {
      const Q = O[1] - O[0];
      return Math.ceil(Q / z) * (F + this.labelPadding) < D;
    }
    const X = this.generateAxisValues(O[0], O[1], z, U, !1).slice(-2).map((Q) => U(Q));
    return X[0] - X[1] > F + this.labelPadding;
  }
  // the calculate step function will use a binary search to find the largest
  // "nice" factor that will fit the axis
  calculateStep(z, D, O, F) {
    const U = [50, 20, 10, 5, 2, 1, 0.5, 0.2, 0.1, 0.05, 0.02], B = this.calculateFontSize("0.0")[F] + this.labelPadding, K = z[1] - z[0], X = Math.abs(D[1] - D[0]), Y = K / 2 + z[0], Q = Math.pow(10, Math.floor(Math.log10(Y)));
    for (const J of U) {
      const ee = Q / J;
      if (this.willFitStep(
        ee,
        X,
        z,
        B,
        O,
        F === "height" ? this.unitConverter.melScale.value : !1
      ))
        return ee;
    }
    return Q;
  }
  generateAxisValues(z, D, O, F, U = !0) {
    const W = [];
    for (let ae = z; ae < D; ae += O)
      W.push(ae);
    if (!U)
      return W;
    const B = W.at(-1), K = D, X = F(B), Y = F(K), Q = Math.abs(X - Y), J = this.calculateFontSize();
    return Q < J.width + this.labelPadding && W.pop(), W.push(D), W;
  }
  render() {
    return x`
      <div id="wrapped-element">
        ${this.unitConverter && this.createAxes()}
        <slot @slotchange="${this.handleSlotchange}"></slot>
      </div>
    `;
  }
};
Axes.styles = [theming, axesStyles];
Axes.fontCanvas = document.createElement("canvas");
__decorateClass$a([
  n$6({ attribute: "x-step", type: Number, reflect: !0 })
], Axes.prototype, "xStepOverride", 2);
__decorateClass$a([
  n$6({ attribute: "y-step", type: Number, reflect: !0 })
], Axes.prototype, "yStepOverride", 2);
__decorateClass$a([
  n$6({ attribute: "x-label", type: String, reflect: !0 })
], Axes.prototype, "xLabel", 2);
__decorateClass$a([
  n$6({ attribute: "y-label", type: String, reflect: !0 })
], Axes.prototype, "yLabel", 2);
__decorateClass$a([
  n$6({ attribute: "x-title", converter: booleanConverter })
], Axes.prototype, "showXTitle", 2);
__decorateClass$a([
  n$6({ attribute: "y-title", converter: booleanConverter })
], Axes.prototype, "showYTitle", 2);
__decorateClass$a([
  n$6({ attribute: "x-axis", converter: booleanConverter })
], Axes.prototype, "showXAxis", 2);
__decorateClass$a([
  n$6({ attribute: "y-axis", converter: booleanConverter })
], Axes.prototype, "showYAxis", 2);
__decorateClass$a([
  n$6({ attribute: "x-grid", converter: booleanConverter })
], Axes.prototype, "showXGrid", 2);
__decorateClass$a([
  n$6({ attribute: "y-grid", converter: booleanConverter })
], Axes.prototype, "showYGrid", 2);
__decorateClass$a([
  queryDeeplyAssignedElement({ selector: "oe-spectrogram" })
], Axes.prototype, "spectrogram", 2);
Axes = __decorateClass$a([
  t$5("oe-axes")
], Axes);
var __defProp$9 = Object.defineProperty, __getOwnPropDesc$9 = Object.getOwnPropertyDescriptor, __decorateClass$9 = (z, D, O, F) => {
  for (var U = F > 1 ? void 0 : F ? __getOwnPropDesc$9(D, O) : D, W = z.length - 1, B; W >= 0; W--)
    (B = z[W]) && (U = (F ? B(D, O, U) : B(U)) || U);
  return F && U && __defProp$9(D, O, U), U;
};
let MediaControls = class extends AbstractComponent(s$7) {
  constructor() {
    super(...arguments), this.for = "", this.playIconPosition = "default", this.logger = {
      log: console.log
    }, this.playHandler = this.handleUpdatePlaying.bind(this);
  }
  disconnectedCallback() {
    var z;
    (z = this.spectrogramElement) == null || z.removeEventListener("play", this.playHandler), super.disconnectedCallback();
  }
  toggleAudio() {
    this.spectrogramElement && (this.isSpectrogramPlaying() ? this.spectrogramElement.pause() : this.spectrogramElement.play());
  }
  willUpdate(z) {
    var D, O, F;
    if (z.has("for")) {
      if (!this.for || ((D = this.spectrogramElement) == null || D.removeEventListener("play", this.playHandler), this.spectrogramElement = (O = this.parentElement) == null ? void 0 : O.querySelector(`#${this.for}`), (F = this.spectrogramElement) == null || F.addEventListener("play", this.playHandler), !this.spectrogramElement))
        return;
      const U = (W) => W instanceof Axes ? W : W.parentElement ? U(W.parentElement) : null;
      this.axesElement = U(this.spectrogramElement);
    }
  }
  handleUpdatePlaying() {
    this.logger.log(`Audio ${this.isSpectrogramPlaying() ? "playing" : "paused"} `), this.requestUpdate();
  }
  isSpectrogramPlaying() {
    var z;
    return this.spectrogramElement ? !((z = this.spectrogramElement) != null && z.paused) : !1;
  }
  playIcon() {
    return x`<slot name="play-icon" part="play-icon">${o$9(lucidPlayIcon)}</slot>`;
  }
  pauseIcon() {
    return x`<slot name="pause-icon" part="pause-icon">${o$9(lucidPauseIcon)}</slot>`;
  }
  selectSettingsTemplate(z, D, O, F) {
    return x`
      <sl-menu-item>
        ${z}
        <sl-menu @sl-select="${F}" slot="submenu">
          ${D.map(
      (U) => x`<sl-menu-item type="checkbox" value="${U}" ?checked=${U == O}>
                ${U}
              </sl-menu-item>`
    )}
        </sl-menu>
      </sl-menu-item>
    `;
  }
  additionalSettingsTemplate() {
    var W, B, K, X, Y, Q;
    const z = [128, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768], D = z.filter(
      (J) => {
        var ee, ae;
        return J < (((ae = (ee = this.spectrogramElement) == null ? void 0 : ee.spectrogramOptions) == null ? void 0 : ae.windowSize) ?? 0);
      }
    );
    if (!this.spectrogramElement)
      return x``;
    const O = this.spectrogramElement.spectrogramOptions, F = (J) => (ee) => {
      let ae = ["windowSize", "windowOverlap"].includes(J) ? Number(ee.detail.item.value) : ee.detail.item.value;
      J === "melScale" && (ae = ae === "mel");
      const re = this.spectrogramElement.spectrogramOptions;
      J === "windowSize" && this.spectrogramElement && this.spectrogramElement.spectrogramOptions.windowOverlap >= ae && (re.windowOverlap = ae / 2), this.spectrogramElement.spectrogramOptions = {
        ...re,
        [J]: ae
      }, this.requestUpdate();
    }, U = (J) => {
      if (!this.axesElement)
        throw new Error("No axes element found");
      const ae = J.detail.item.querySelector("input[type=checkbox]");
      if (!ae)
        throw new Error("No checkbox element found");
      const re = ae.name, ie = ae.checked;
      this.axesElement[re] = ie;
    };
    return x`
      <sl-dropdown title="Additional Settings" hoist>
        <a slot="trigger">${o$9(lucideSettingsIcon)}</a>
        <sl-menu>
          ${this.selectSettingsTemplate(
      "Window Function",
      [
        "hann",
        "hamming",
        "cosine",
        "lanczos",
        "gaussian",
        "tukey",
        "blackman",
        "exact_blackman",
        "kaiser",
        "nuttall",
        "blackman_harris",
        "blackman_nuttall",
        "flat_top"
      ],
      O.windowFunction,
      F("windowFunction")
    )}
          ${this.selectSettingsTemplate(
      "Window Size",
      z,
      O.windowSize,
      F("windowSize")
    )}
          ${this.selectSettingsTemplate(
      "Window Overlap",
      [0, ...D],
      O.windowOverlap,
      F("windowOverlap")
    )}
          ${this.selectSettingsTemplate(
      "Scale",
      ["linear", "mel"],
      O.melScale ? "mel" : "linear",
      F("melScale")
    )}

          <sl-menu-item>
            Axes
            <sl-menu @sl-select="${U}" slot="submenu">
              <sl-menu-item>
                <label>
                  <input type="checkbox" name="showXTitle" ?checked=${(W = this.axesElement) == null ? void 0 : W.showXTitle} />
                  X-Axis Title
                </label>
              </sl-menu-item>

              <sl-menu-item>
                <label>
                  <input type="checkbox" name="showYTitle" ?checked=${(B = this.axesElement) == null ? void 0 : B.showYTitle} />
                  Y-Axis Title
                </label>
              </sl-menu-item>

              <sl-menu-item>
                <label>
                  <input type="checkbox" name="showXAxis" ?checked=${(K = this.axesElement) == null ? void 0 : K.showXAxis} />
                  X-Axis Labels
                </label>
              </sl-menu-item>

              <sl-menu-item>
                <label>
                  <input type="checkbox" name="showYAxis" ?checked=${(X = this.axesElement) == null ? void 0 : X.showYAxis} />
                  Y-Axis Labels
                </label>
              </sl-menu-item>

              <sl-menu-item>
                <label>
                  <input type="checkbox" name="showXGrid" ?checked=${(Y = this.axesElement) == null ? void 0 : Y.showXGrid} />
                  X-Axis Grid Lines
                </label>
              </sl-menu-item>

              <sl-menu-item>
                <label>
                  <input type="checkbox" name="showYGrid" ?checked=${(Q = this.axesElement) == null ? void 0 : Q.showYGrid} />
                  Y-Axis Grid Lines
                </label>
              </sl-menu-item>
            </sl-menu>
          </sl-menu-item>
      </sl-dropdown>
    `;
  }
  spectrogramSettingsTemplate() {
    const z = (F) => {
      const U = F.detail.item.value, W = this.spectrogramElement.spectrogramOptions;
      this.spectrogramElement.spectrogramOptions = {
        ...W,
        colorMap: U
      };
    }, D = (F) => {
      const U = F.target.value, W = this.spectrogramElement.spectrogramOptions;
      this.spectrogramElement.spectrogramOptions = {
        ...W,
        brightness: Number(U)
      };
    }, O = (F) => {
      const U = F.target.value, W = this.spectrogramElement.spectrogramOptions;
      this.spectrogramElement.spectrogramOptions = {
        ...W,
        contrast: Number(U)
      };
    };
    return x`
      <sl-dropdown title="Colour" hoist>
        <a slot="trigger">${o$9(lucidePalletteIcon)}</a>
        <sl-menu @sl-select="${z}">
          <sl-menu-item type="checkbox" value="grayscale">Grayscale</sl-menu-item>
          <sl-menu-item type="checkbox" value="audacity">Audacity</sl-menu-item>
          <sl-menu-item type="checkbox" value="raven">Raven</sl-menu-item>
          <sl-menu-item type="checkbox" value="cubeHelix">Cube Helix</sl-menu-item>
          <sl-menu-item type="checkbox" value="viridis">Viridis</sl-menu-item>
          <sl-menu-item type="checkbox" value="turbo">Turbo</sl-menu-item>
          <sl-menu-item type="checkbox" value="plasma">Plasma</sl-menu-item>
          <sl-menu-item type="checkbox" value="inferno">Inferno</sl-menu-item>
          <sl-menu-item type="checkbox" value="magma">Magma</sl-menu-item>
          <sl-menu-item type="checkbox" value="gammaII">Gamma II</sl-menu-item>
          <sl-menu-item type="checkbox" value="blue">Blue</sl-menu-item>
          <sl-menu-item type="checkbox" value="green">Green</sl-menu-item>
          <sl-menu-item type="checkbox" value="orange">Orange</sl-menu-item>
          <sl-menu-item type="checkbox" value="purple">Purple</sl-menu-item>
          <sl-menu-item type="checkbox" value="red">Red</sl-menu-item>
        </sl-menu>
      </sl-dropdown>

      <sl-dropdown title="Brightness" hoist>
        <a slot="trigger">${o$9(lucideSunIcon)}</a>
        <label>
          <input @change="${D}" type="range" min="-0.5" max="0.5" step="0.1" value="0" />
        </label>
      </sl-dropdown>

      <sl-dropdown title="Contrast" hoist>
        <a slot="trigger">${o$9(lucideContrastIcon)}</a>
        <label>
          <input @change="${O}" type="range" min="0" max="2" step="0.1" value="1" />
        </label>
      </sl-dropdown>

      ${this.additionalSettingsTemplate()}
    `;
  }
  render() {
    return x`
      <div class="container">
        <a id="action-button" @click="${this.toggleAudio}">
          ${this.isSpectrogramPlaying() ? this.pauseIcon() : this.playIcon()}
        </a>

        ${this.spectrogramSettingsTemplate()}
      </div>
    `;
  }
};
MediaControls.styles = mediaControlsStyles;
__decorateClass$9([
  n$6({ type: String })
], MediaControls.prototype, "for", 2);
__decorateClass$9([
  n$6({ type: String })
], MediaControls.prototype, "playIconPosition", 2);
__decorateClass$9([
  e$8({ context: rootContext })
], MediaControls.prototype, "logger", 2);
MediaControls = __decorateClass$9([
  t$5("oe-media-controls")
], MediaControls);
const spectrogramStyles = i$7`
  :host {
    display: block;
  }

  #spectrogram-container {
    position: relative;
    background-color: var(--oe-panel-color-lighter);
    width: 100%;
    height: 100%;
  }

  #spectrogram-container > canvas {
    position: relative;
    display: inherit;
    height: 100%;

    /*
      We set the minimum height to 64 because the minimum FFT window size that
      we support is 64 samples. Therefore, if the user does not specify a container
      with a minimum height, we should at least show 64px in height (the width will auto-scale)
    */
    min-height: 64px;
  }
`;
class RenderWindow {
  constructor(D) {
    this.startOffset = D.startOffset, this.endOffset = D.endOffset, this.lowFrequency = D.lowFrequency, this.highFrequency = D.highFrequency;
  }
  // changes the render window to a DOM representation that can be used in the
  // window="" attribute of the oe-spectrogram component
  // format: x0, y0, x1, y1
  toDom() {
    return `${this.startOffset}, ${this.lowFrequency}, ${this.endOffset}, ${this.highFrequency}`;
  }
}
class AudioModel {
  constructor(D) {
    this.duration = D.duration, this.sampleRate = D.sampleRate, this.originalAudioRecording = D.originalAudioRecording;
  }
}
function hertzToMels(z) {
  return 1127 * Math.log(1 + z / 700);
}
const identityFunction = (z) => z;
class UnitConverter {
  constructor(D, O, F, U) {
    this.nyquist = w(() => this.audioModel.value.sampleRate / 2), this.frequencyInterpolator = w(() => this.melScale.value ? hertzToMels : (W) => W), this.temporalDomain = w(() => [
      this.renderWindow.value.startOffset,
      this.renderWindow.value.endOffset
    ]), this.frequencyDomain = w(() => [
      this.frequencyInterpolator.value(0),
      this.frequencyInterpolator.value(this.nyquist.value)
    ]), this.temporalRange = w(() => [0, this.canvasSize.value.width]), this.frequencyRange = w(() => [this.canvasSize.value.height, 0]), this.scaleX = w(
      () => this.linearScale(this.temporalDomain.value, this.temporalRange.value)
    ), this.scaleXInverse = w(
      () => this.inverseLinearScale(this.temporalDomain.value, this.temporalRange.value)
    ), this.scaleY = w(
      () => this.linearScale(this.frequencyDomain.value, this.frequencyRange.value, this.frequencyInterpolator.value)
    ), this.scaleYInverse = w(
      () => this.inverseLinearScale(this.frequencyDomain.value, this.frequencyRange.value, this.frequencyInterpolator.value)
    ), this.renderWindow = D, this.canvasSize = O, this.audioModel = F, this.melScale = U;
  }
  // TODO: I think passing in a scaleConverter here is a hack
  /**
   * @returns a function that converts a value to a pixel value
   */
  linearScale(D, O, F = identityFunction) {
    const U = this.calculateMagnitude(D, O);
    return (W) => F(W) * U + O[0];
  }
  /**
   * @returns a function that converts a pixel value to a value
   */
  inverseLinearScale(D, O, F = identityFunction) {
    const U = this.calculateMagnitude(D, O);
    return (W) => (F(W) - O[0]) / U;
  }
  /**
   * calculate the magnitude of a linear function using
   * (y_2 - y_1) / (x_2 - x_1)
   *
   * @returns the magnitude of the mathematical function
   */
  calculateMagnitude(D, O) {
    return (O[1] - O[0]) / (D[1] - D[0]);
  }
}
const ht = class ht {
  constructor() {
  }
  static get instance() {
    return this._instance || (this._instance = new ResizeObserver((D) => {
      var O;
      for (const F of D)
        (O = this.callbacks.get(F.target)) == null || O(D, this._instance);
    })), this._instance;
  }
  static observe(D, O) {
    this.callbacks.set(D, O), this.instance.observe(D);
  }
  static unobserve(D) {
    this.instance.unobserve(D), this.callbacks.delete(D);
  }
};
ht.callbacks = /* @__PURE__ */ new WeakMap();
let OeResizeObserver = ht;
function sleep(z) {
  return new Promise((D) => setTimeout(D, z));
}
var STATE = /* @__PURE__ */ ((z) => (z[z.BUFFER_AVAILABLE = 0] = "BUFFER_AVAILABLE", z[z.BUFFER_WRITE_HEAD = 1] = "BUFFER_WRITE_HEAD", z[z.WORKER_STATE = 2] = "WORKER_STATE", z[z.GENERATION = 3] = "GENERATION", z[z.PROCESSOR_READY = 4] = "PROCESSOR_READY", z[z.PROCESSOR_COMPLETE = 5] = "PROCESSOR_COMPLETE", z))(STATE || {});
const INITIAL_GENERATION = -1;
class State {
  /**
   * Create a new SharedArrayBuffer that backs the state object.
   * @param fullBufferLength The number of samples after which the worker will be activated.
   */
  static createState() {
    const D = new SharedArrayBuffer(Object.keys(STATE).length / 2 * Int32Array.BYTES_PER_ELEMENT), O = new State(D);
    return O.processorReadyGeneration = INITIAL_GENERATION, O.processorCompleteGeneration = INITIAL_GENERATION, O;
  }
  constructor(D) {
    this.state = new Int32Array(D);
  }
  /**
   * Export the storage buffer for the state as a SharedArrayBuffer.
   */
  get stateBuffer() {
    return this.state.buffer;
  }
  get bufferAvailable() {
    return Atomics.load(
      this.state,
      0
      /* BUFFER_AVAILABLE */
    ) === 1;
  }
  /**
   * Notifies!
   */
  set bufferAvailable(D) {
    Atomics.store(this.state, 0, D), Atomics.notify(this.state, 0, D);
  }
  get bufferWriteHead() {
    return Atomics.load(
      this.state,
      1
      /* BUFFER_WRITE_HEAD */
    );
  }
  set bufferWriteHead(D) {
    Atomics.store(this.state, 1, D);
  }
  get workerNew() {
    return Atomics.load(
      this.state,
      2
      /* WORKER_STATE */
    ) === 0;
  }
  get workerIdle() {
    return Atomics.load(
      this.state,
      2
      /* WORKER_STATE */
    ) === 1;
  }
  get workerProcessing() {
    return Atomics.load(
      this.state,
      2
      /* WORKER_STATE */
    ) === 2;
  }
  set workerProcessing(D) {
    Atomics.store(this.state, 2, D), Atomics.notify(this.state, 2, D);
  }
  get generation() {
    return Atomics.load(
      this.state,
      3
      /* GENERATION */
    );
  }
  get processorReadyGeneration() {
    return Atomics.load(
      this.state,
      4
      /* PROCESSOR_READY */
    );
  }
  set processorReadyGeneration(D) {
    Atomics.store(this.state, 4, D);
  }
  get processorCompleteGeneration() {
    return Atomics.load(
      this.state,
      5
      /* PROCESSOR_COMPLETE */
    );
  }
  set processorCompleteGeneration(D) {
    Atomics.store(this.state, 5, D);
  }
  isProcessorReady(D) {
    return Atomics.load(
      this.state,
      4
      /* PROCESSOR_READY */
    ) === D;
  }
  isProcessorComplete(D) {
    return Atomics.load(
      this.state,
      5
      /* PROCESSOR_COMPLETE */
    ) === D;
  }
  /**
   * Called by the main thread when the processor has finished writing to the buffer.
   * The processor has no more samples to write. We trigger the buffer available state
   * to signal the worker to process the buffer.
   */
  processorComplete(D) {
    const O = this.processorCompleteGeneration;
    D > O && (this.processorCompleteGeneration = D), D === O + 1 && (this.bufferAvailable = 1);
  }
  /**
   * Called by the main thread when options have changed.
   * The generation is incremented.
   * The old processor should be discarded.
   * The worker should be updated.
   * @returns The new generation.
   */
  reset() {
    const O = Atomics.add(this.state, 3, 1) + 1;
    return this.bufferWriteHead = 0, this.bufferAvailable = 0, O;
  }
  matchesCurrentGeneration(D) {
    return Atomics.load(
      this.state,
      3
      /* GENERATION */
    ) === D;
  }
  /**
   * Called by the main thread when it is waiting for the processor to be ready.
   */
  async waitForProcessorReady(D) {
    for (; this.processorReadyGeneration < D; )
      await sleep(0);
    return this.matchesCurrentGeneration(D);
  }
  /**
   * Called by the main thread when it is waiting for the processor to be ready.
   */
  async waitForWorkerReady() {
    for (; this.workerNew; )
      await sleep(0);
  }
  async waitForWorkerIdle() {
    for (; !this.workerIdle; )
      await sleep(0);
  }
}
var commonjsGlobal = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function getDefaultExportFromCjs$1(z) {
  return z && z.__esModule && Object.prototype.hasOwnProperty.call(z, "default") ? z.default : z;
}
function getAugmentedNamespace(z) {
  if (z.__esModule)
    return z;
  var D = z.default;
  if (typeof D == "function") {
    var O = function F() {
      return this instanceof F ? Reflect.construct(D, arguments, this.constructor) : D.apply(this, arguments);
    };
    O.prototype = D.prototype;
  } else
    O = {};
  return Object.defineProperty(O, "__esModule", { value: !0 }), Object.keys(z).forEach(function(F) {
    var U = Object.getOwnPropertyDescriptor(z, F);
    Object.defineProperty(O, F, U.get ? U : {
      enumerable: !0,
      get: function() {
        return z[F];
      }
    });
  }), O;
}
var lib$3 = {};
function getDefaultExportFromCjs(z) {
  return z && z.__esModule && Object.prototype.hasOwnProperty.call(z, "default") ? z.default : z;
}
var browser$3 = { exports: {} }, process = browser$3.exports = {}, cachedSetTimeout, cachedClearTimeout;
function defaultSetTimout() {
  throw new Error("setTimeout has not been defined");
}
function defaultClearTimeout() {
  throw new Error("clearTimeout has not been defined");
}
(function() {
  try {
    typeof setTimeout == "function" ? cachedSetTimeout = setTimeout : cachedSetTimeout = defaultSetTimout;
  } catch {
    cachedSetTimeout = defaultSetTimout;
  }
  try {
    typeof clearTimeout == "function" ? cachedClearTimeout = clearTimeout : cachedClearTimeout = defaultClearTimeout;
  } catch {
    cachedClearTimeout = defaultClearTimeout;
  }
})();
function runTimeout(z) {
  if (cachedSetTimeout === setTimeout)
    return setTimeout(z, 0);
  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout)
    return cachedSetTimeout = setTimeout, setTimeout(z, 0);
  try {
    return cachedSetTimeout(z, 0);
  } catch {
    try {
      return cachedSetTimeout.call(null, z, 0);
    } catch {
      return cachedSetTimeout.call(this, z, 0);
    }
  }
}
function runClearTimeout(z) {
  if (cachedClearTimeout === clearTimeout)
    return clearTimeout(z);
  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout)
    return cachedClearTimeout = clearTimeout, clearTimeout(z);
  try {
    return cachedClearTimeout(z);
  } catch {
    try {
      return cachedClearTimeout.call(null, z);
    } catch {
      return cachedClearTimeout.call(this, z);
    }
  }
}
var queue = [], draining = !1, currentQueue, queueIndex = -1;
function cleanUpNextTick() {
  !draining || !currentQueue || (draining = !1, currentQueue.length ? queue = currentQueue.concat(queue) : queueIndex = -1, queue.length && drainQueue());
}
function drainQueue() {
  if (!draining) {
    var z = runTimeout(cleanUpNextTick);
    draining = !0;
    for (var D = queue.length; D; ) {
      for (currentQueue = queue, queue = []; ++queueIndex < D; )
        currentQueue && currentQueue[queueIndex].run();
      queueIndex = -1, D = queue.length;
    }
    currentQueue = null, draining = !1, runClearTimeout(z);
  }
}
process.nextTick = function(z) {
  var D = new Array(arguments.length - 1);
  if (arguments.length > 1)
    for (var O = 1; O < arguments.length; O++)
      D[O - 1] = arguments[O];
  queue.push(new Item(z, D)), queue.length === 1 && !draining && runTimeout(drainQueue);
};
function Item(z, D) {
  this.fun = z, this.array = D;
}
Item.prototype.run = function() {
  this.fun.apply(null, this.array);
};
process.title = "browser";
process.browser = !0;
process.env = {};
process.argv = [];
process.version = "";
process.versions = {};
function noop$2() {
}
process.on = noop$2;
process.addListener = noop$2;
process.once = noop$2;
process.off = noop$2;
process.removeListener = noop$2;
process.removeAllListeners = noop$2;
process.emit = noop$2;
process.prependListener = noop$2;
process.prependOnceListener = noop$2;
process.listeners = function(z) {
  return [];
};
process.binding = function(z) {
  throw new Error("process.binding is not supported");
};
process.cwd = function() {
  return "/";
};
process.chdir = function(z) {
  throw new Error("process.chdir is not supported");
};
process.umask = function() {
  return 0;
};
var browserExports$1 = browser$3.exports;
const process$1 = /* @__PURE__ */ getDefaultExportFromCjs(browserExports$1);
var browser$2 = { exports: {} }, ms, hasRequiredMs;
function requireMs() {
  if (hasRequiredMs)
    return ms;
  hasRequiredMs = 1;
  var z = 1e3, D = z * 60, O = D * 60, F = O * 24, U = F * 7, W = F * 365.25;
  ms = function(Q, J) {
    J = J || {};
    var ee = typeof Q;
    if (ee === "string" && Q.length > 0)
      return B(Q);
    if (ee === "number" && isFinite(Q))
      return J.long ? X(Q) : K(Q);
    throw new Error(
      "val is not a non-empty string or a valid number. val=" + JSON.stringify(Q)
    );
  };
  function B(Q) {
    if (Q = String(Q), !(Q.length > 100)) {
      var J = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        Q
      );
      if (J) {
        var ee = parseFloat(J[1]), ae = (J[2] || "ms").toLowerCase();
        switch (ae) {
          case "years":
          case "year":
          case "yrs":
          case "yr":
          case "y":
            return ee * W;
          case "weeks":
          case "week":
          case "w":
            return ee * U;
          case "days":
          case "day":
          case "d":
            return ee * F;
          case "hours":
          case "hour":
          case "hrs":
          case "hr":
          case "h":
            return ee * O;
          case "minutes":
          case "minute":
          case "mins":
          case "min":
          case "m":
            return ee * D;
          case "seconds":
          case "second":
          case "secs":
          case "sec":
          case "s":
            return ee * z;
          case "milliseconds":
          case "millisecond":
          case "msecs":
          case "msec":
          case "ms":
            return ee;
          default:
            return;
        }
      }
    }
  }
  function K(Q) {
    var J = Math.abs(Q);
    return J >= F ? Math.round(Q / F) + "d" : J >= O ? Math.round(Q / O) + "h" : J >= D ? Math.round(Q / D) + "m" : J >= z ? Math.round(Q / z) + "s" : Q + "ms";
  }
  function X(Q) {
    var J = Math.abs(Q);
    return J >= F ? Y(Q, J, F, "day") : J >= O ? Y(Q, J, O, "hour") : J >= D ? Y(Q, J, D, "minute") : J >= z ? Y(Q, J, z, "second") : Q + " ms";
  }
  function Y(Q, J, ee, ae) {
    var re = J >= ee * 1.5;
    return Math.round(Q / ee) + " " + ae + (re ? "s" : "");
  }
  return ms;
}
function setup(z) {
  O.debug = O, O.default = O, O.coerce = X, O.disable = W, O.enable = U, O.enabled = B, O.humanize = requireMs(), O.destroy = Y, Object.keys(z).forEach((Q) => {
    O[Q] = z[Q];
  }), O.names = [], O.skips = [], O.formatters = {};
  function D(Q) {
    let J = 0;
    for (let ee = 0; ee < Q.length; ee++)
      J = (J << 5) - J + Q.charCodeAt(ee), J |= 0;
    return O.colors[Math.abs(J) % O.colors.length];
  }
  O.selectColor = D;
  function O(Q) {
    let J, ee = null, ae, re;
    function ie(...ue) {
      if (!ie.enabled)
        return;
      const q = ie, ne = Number(/* @__PURE__ */ new Date()), ce = ne - (J || ne);
      q.diff = ce, q.prev = J, q.curr = ne, J = ne, ue[0] = O.coerce(ue[0]), typeof ue[0] != "string" && ue.unshift("%O");
      let he = 0;
      ue[0] = ue[0].replace(/%([a-zA-Z%])/g, (me, de) => {
        if (me === "%%")
          return "%";
        he++;
        const be = O.formatters[de];
        if (typeof be == "function") {
          const _e = ue[he];
          me = be.call(q, _e), ue.splice(he, 1), he--;
        }
        return me;
      }), O.formatArgs.call(q, ue), (q.log || O.log).apply(q, ue);
    }
    return ie.namespace = Q, ie.useColors = O.useColors(), ie.color = O.selectColor(Q), ie.extend = F, ie.destroy = O.destroy, Object.defineProperty(ie, "enabled", {
      enumerable: !0,
      configurable: !1,
      get: () => ee !== null ? ee : (ae !== O.namespaces && (ae = O.namespaces, re = O.enabled(Q)), re),
      set: (ue) => {
        ee = ue;
      }
    }), typeof O.init == "function" && O.init(ie), ie;
  }
  function F(Q, J) {
    const ee = O(this.namespace + (typeof J > "u" ? ":" : J) + Q);
    return ee.log = this.log, ee;
  }
  function U(Q) {
    O.save(Q), O.namespaces = Q, O.names = [], O.skips = [];
    let J;
    const ee = (typeof Q == "string" ? Q : "").split(/[\s,]+/), ae = ee.length;
    for (J = 0; J < ae; J++)
      ee[J] && (Q = ee[J].replace(/\*/g, ".*?"), Q[0] === "-" ? O.skips.push(new RegExp("^" + Q.slice(1) + "$")) : O.names.push(new RegExp("^" + Q + "$")));
  }
  function W() {
    const Q = [
      ...O.names.map(K),
      ...O.skips.map(K).map((J) => "-" + J)
    ].join(",");
    return O.enable(""), Q;
  }
  function B(Q) {
    if (Q[Q.length - 1] === "*")
      return !0;
    let J, ee;
    for (J = 0, ee = O.skips.length; J < ee; J++)
      if (O.skips[J].test(Q))
        return !1;
    for (J = 0, ee = O.names.length; J < ee; J++)
      if (O.names[J].test(Q))
        return !0;
    return !1;
  }
  function K(Q) {
    return Q.toString().substring(2, Q.toString().length - 2).replace(/\.\*\?$/, "*");
  }
  function X(Q) {
    return Q instanceof Error ? Q.stack || Q.message : Q;
  }
  function Y() {
    console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
  }
  return O.enable(O.load()), O;
}
var common$3 = setup;
(function(z, D) {
  D.formatArgs = F, D.save = U, D.load = W, D.useColors = O, D.storage = B(), D.destroy = /* @__PURE__ */ (() => {
    let X = !1;
    return () => {
      X || (X = !0, console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."));
    };
  })(), D.colors = [
    "#0000CC",
    "#0000FF",
    "#0033CC",
    "#0033FF",
    "#0066CC",
    "#0066FF",
    "#0099CC",
    "#0099FF",
    "#00CC00",
    "#00CC33",
    "#00CC66",
    "#00CC99",
    "#00CCCC",
    "#00CCFF",
    "#3300CC",
    "#3300FF",
    "#3333CC",
    "#3333FF",
    "#3366CC",
    "#3366FF",
    "#3399CC",
    "#3399FF",
    "#33CC00",
    "#33CC33",
    "#33CC66",
    "#33CC99",
    "#33CCCC",
    "#33CCFF",
    "#6600CC",
    "#6600FF",
    "#6633CC",
    "#6633FF",
    "#66CC00",
    "#66CC33",
    "#9900CC",
    "#9900FF",
    "#9933CC",
    "#9933FF",
    "#99CC00",
    "#99CC33",
    "#CC0000",
    "#CC0033",
    "#CC0066",
    "#CC0099",
    "#CC00CC",
    "#CC00FF",
    "#CC3300",
    "#CC3333",
    "#CC3366",
    "#CC3399",
    "#CC33CC",
    "#CC33FF",
    "#CC6600",
    "#CC6633",
    "#CC9900",
    "#CC9933",
    "#CCCC00",
    "#CCCC33",
    "#FF0000",
    "#FF0033",
    "#FF0066",
    "#FF0099",
    "#FF00CC",
    "#FF00FF",
    "#FF3300",
    "#FF3333",
    "#FF3366",
    "#FF3399",
    "#FF33CC",
    "#FF33FF",
    "#FF6600",
    "#FF6633",
    "#FF9900",
    "#FF9933",
    "#FFCC00",
    "#FFCC33"
  ];
  function O() {
    return typeof window < "u" && window.process && (window.process.type === "renderer" || window.process.__nwjs) ? !0 : typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/) ? !1 : typeof document < "u" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
    typeof window < "u" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
    typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
  }
  function F(X) {
    if (X[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + X[0] + (this.useColors ? "%c " : " ") + "+" + z.exports.humanize(this.diff), !this.useColors)
      return;
    const Y = "color: " + this.color;
    X.splice(1, 0, Y, "color: inherit");
    let Q = 0, J = 0;
    X[0].replace(/%[a-zA-Z%]/g, (ee) => {
      ee !== "%%" && (Q++, ee === "%c" && (J = Q));
    }), X.splice(J, 0, Y);
  }
  D.log = console.debug || console.log || (() => {
  });
  function U(X) {
    try {
      X ? D.storage.setItem("debug", X) : D.storage.removeItem("debug");
    } catch {
    }
  }
  function W() {
    let X;
    try {
      X = D.storage.getItem("debug");
    } catch {
    }
    return !X && typeof process$1 < "u" && "env" in process$1 && (X = process$1.env.DEBUG), X;
  }
  function B() {
    try {
      return localStorage;
    } catch {
    }
  }
  z.exports = common$3(D);
  const { formatters: K } = z.exports;
  K.j = function(X) {
    try {
      return JSON.stringify(X);
    } catch (Y) {
      return "[UnexpectedJSONParseError]: " + Y.message;
    }
  };
})(browser$2, browser$2.exports);
var browserExports = browser$2.exports, core$2 = {}, core$1 = {}, ReadStreamTokenizer$1 = {}, buffer = {}, base64Js = {};
base64Js.byteLength = byteLength;
base64Js.toByteArray = toByteArray;
base64Js.fromByteArray = fromByteArray;
var lookup = [], revLookup = [], Arr = typeof Uint8Array < "u" ? Uint8Array : Array, code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (var i$1 = 0, len = code.length; i$1 < len; ++i$1)
  lookup[i$1] = code[i$1], revLookup[code.charCodeAt(i$1)] = i$1;
revLookup[45] = 62;
revLookup[95] = 63;
function getLens(z) {
  var D = z.length;
  if (D % 4 > 0)
    throw new Error("Invalid string. Length must be a multiple of 4");
  var O = z.indexOf("=");
  O === -1 && (O = D);
  var F = O === D ? 0 : 4 - O % 4;
  return [O, F];
}
function byteLength(z) {
  var D = getLens(z), O = D[0], F = D[1];
  return (O + F) * 3 / 4 - F;
}
function _byteLength(z, D, O) {
  return (D + O) * 3 / 4 - O;
}
function toByteArray(z) {
  var D, O = getLens(z), F = O[0], U = O[1], W = new Arr(_byteLength(z, F, U)), B = 0, K = U > 0 ? F - 4 : F, X;
  for (X = 0; X < K; X += 4)
    D = revLookup[z.charCodeAt(X)] << 18 | revLookup[z.charCodeAt(X + 1)] << 12 | revLookup[z.charCodeAt(X + 2)] << 6 | revLookup[z.charCodeAt(X + 3)], W[B++] = D >> 16 & 255, W[B++] = D >> 8 & 255, W[B++] = D & 255;
  return U === 2 && (D = revLookup[z.charCodeAt(X)] << 2 | revLookup[z.charCodeAt(X + 1)] >> 4, W[B++] = D & 255), U === 1 && (D = revLookup[z.charCodeAt(X)] << 10 | revLookup[z.charCodeAt(X + 1)] << 4 | revLookup[z.charCodeAt(X + 2)] >> 2, W[B++] = D >> 8 & 255, W[B++] = D & 255), W;
}
function tripletToBase64(z) {
  return lookup[z >> 18 & 63] + lookup[z >> 12 & 63] + lookup[z >> 6 & 63] + lookup[z & 63];
}
function encodeChunk(z, D, O) {
  for (var F, U = [], W = D; W < O; W += 3)
    F = (z[W] << 16 & 16711680) + (z[W + 1] << 8 & 65280) + (z[W + 2] & 255), U.push(tripletToBase64(F));
  return U.join("");
}
function fromByteArray(z) {
  for (var D, O = z.length, F = O % 3, U = [], W = 16383, B = 0, K = O - F; B < K; B += W)
    U.push(encodeChunk(z, B, B + W > K ? K : B + W));
  return F === 1 ? (D = z[O - 1], U.push(
    lookup[D >> 2] + lookup[D << 4 & 63] + "=="
  )) : F === 2 && (D = (z[O - 2] << 8) + z[O - 1], U.push(
    lookup[D >> 10] + lookup[D >> 4 & 63] + lookup[D << 2 & 63] + "="
  )), U.join("");
}
var ieee754$1 = {};
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
ieee754$1.read = function(z, D, O, F, U) {
  var W, B, K = U * 8 - F - 1, X = (1 << K) - 1, Y = X >> 1, Q = -7, J = O ? U - 1 : 0, ee = O ? -1 : 1, ae = z[D + J];
  for (J += ee, W = ae & (1 << -Q) - 1, ae >>= -Q, Q += K; Q > 0; W = W * 256 + z[D + J], J += ee, Q -= 8)
    ;
  for (B = W & (1 << -Q) - 1, W >>= -Q, Q += F; Q > 0; B = B * 256 + z[D + J], J += ee, Q -= 8)
    ;
  if (W === 0)
    W = 1 - Y;
  else {
    if (W === X)
      return B ? NaN : (ae ? -1 : 1) * (1 / 0);
    B = B + Math.pow(2, F), W = W - Y;
  }
  return (ae ? -1 : 1) * B * Math.pow(2, W - F);
};
ieee754$1.write = function(z, D, O, F, U, W) {
  var B, K, X, Y = W * 8 - U - 1, Q = (1 << Y) - 1, J = Q >> 1, ee = U === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, ae = F ? 0 : W - 1, re = F ? 1 : -1, ie = D < 0 || D === 0 && 1 / D < 0 ? 1 : 0;
  for (D = Math.abs(D), isNaN(D) || D === 1 / 0 ? (K = isNaN(D) ? 1 : 0, B = Q) : (B = Math.floor(Math.log(D) / Math.LN2), D * (X = Math.pow(2, -B)) < 1 && (B--, X *= 2), B + J >= 1 ? D += ee / X : D += ee * Math.pow(2, 1 - J), D * X >= 2 && (B++, X /= 2), B + J >= Q ? (K = 0, B = Q) : B + J >= 1 ? (K = (D * X - 1) * Math.pow(2, U), B = B + J) : (K = D * Math.pow(2, J - 1) * Math.pow(2, U), B = 0)); U >= 8; z[O + ae] = K & 255, ae += re, K /= 256, U -= 8)
    ;
  for (B = B << U | K, Y += U; Y > 0; z[O + ae] = B & 255, ae += re, B /= 256, Y -= 8)
    ;
  z[O + ae - re] |= ie * 128;
};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
(function(z) {
  const D = base64Js, O = ieee754$1, F = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
  z.Buffer = Q, z.SlowBuffer = we, z.INSPECT_MAX_BYTES = 50;
  const U = 2147483647;
  z.kMaxLength = U;
  const { Uint8Array: W, ArrayBuffer: B, SharedArrayBuffer: K } = globalThis;
  Q.TYPED_ARRAY_SUPPORT = X(), !Q.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error(
    "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
  );
  function X() {
    try {
      const ye = new W(1), se = { foo: function() {
        return 42;
      } };
      return Object.setPrototypeOf(se, W.prototype), Object.setPrototypeOf(ye, se), ye.foo() === 42;
    } catch {
      return !1;
    }
  }
  Object.defineProperty(Q.prototype, "parent", {
    enumerable: !0,
    get: function() {
      if (Q.isBuffer(this))
        return this.buffer;
    }
  }), Object.defineProperty(Q.prototype, "offset", {
    enumerable: !0,
    get: function() {
      if (Q.isBuffer(this))
        return this.byteOffset;
    }
  });
  function Y(ye) {
    if (ye > U)
      throw new RangeError('The value "' + ye + '" is invalid for option "size"');
    const se = new W(ye);
    return Object.setPrototypeOf(se, Q.prototype), se;
  }
  function Q(ye, se, oe) {
    if (typeof ye == "number") {
      if (typeof se == "string")
        throw new TypeError(
          'The "string" argument must be of type string. Received type number'
        );
      return re(ye);
    }
    return J(ye, se, oe);
  }
  Q.poolSize = 8192;
  function J(ye, se, oe) {
    if (typeof ye == "string")
      return ie(ye, se);
    if (B.isView(ye))
      return q(ye);
    if (ye == null)
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof ye
      );
    if (He(ye, B) || ye && He(ye.buffer, B) || typeof K < "u" && (He(ye, K) || ye && He(ye.buffer, K)))
      return ne(ye, se, oe);
    if (typeof ye == "number")
      throw new TypeError(
        'The "value" argument must not be of type number. Received type number'
      );
    const Le = ye.valueOf && ye.valueOf();
    if (Le != null && Le !== ye)
      return Q.from(Le, se, oe);
    const Ae = ce(ye);
    if (Ae)
      return Ae;
    if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof ye[Symbol.toPrimitive] == "function")
      return Q.from(ye[Symbol.toPrimitive]("string"), se, oe);
    throw new TypeError(
      "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof ye
    );
  }
  Q.from = function(ye, se, oe) {
    return J(ye, se, oe);
  }, Object.setPrototypeOf(Q.prototype, W.prototype), Object.setPrototypeOf(Q, W);
  function ee(ye) {
    if (typeof ye != "number")
      throw new TypeError('"size" argument must be of type number');
    if (ye < 0)
      throw new RangeError('The value "' + ye + '" is invalid for option "size"');
  }
  function ae(ye, se, oe) {
    return ee(ye), ye <= 0 ? Y(ye) : se !== void 0 ? typeof oe == "string" ? Y(ye).fill(se, oe) : Y(ye).fill(se) : Y(ye);
  }
  Q.alloc = function(ye, se, oe) {
    return ae(ye, se, oe);
  };
  function re(ye) {
    return ee(ye), Y(ye < 0 ? 0 : he(ye) | 0);
  }
  Q.allocUnsafe = function(ye) {
    return re(ye);
  }, Q.allocUnsafeSlow = function(ye) {
    return re(ye);
  };
  function ie(ye, se) {
    if ((typeof se != "string" || se === "") && (se = "utf8"), !Q.isEncoding(se))
      throw new TypeError("Unknown encoding: " + se);
    const oe = me(ye, se) | 0;
    let Le = Y(oe);
    const Ae = Le.write(ye, se);
    return Ae !== oe && (Le = Le.slice(0, Ae)), Le;
  }
  function ue(ye) {
    const se = ye.length < 0 ? 0 : he(ye.length) | 0, oe = Y(se);
    for (let Le = 0; Le < se; Le += 1)
      oe[Le] = ye[Le] & 255;
    return oe;
  }
  function q(ye) {
    if (He(ye, W)) {
      const se = new W(ye);
      return ne(se.buffer, se.byteOffset, se.byteLength);
    }
    return ue(ye);
  }
  function ne(ye, se, oe) {
    if (se < 0 || ye.byteLength < se)
      throw new RangeError('"offset" is outside of buffer bounds');
    if (ye.byteLength < se + (oe || 0))
      throw new RangeError('"length" is outside of buffer bounds');
    let Le;
    return se === void 0 && oe === void 0 ? Le = new W(ye) : oe === void 0 ? Le = new W(ye, se) : Le = new W(ye, se, oe), Object.setPrototypeOf(Le, Q.prototype), Le;
  }
  function ce(ye) {
    if (Q.isBuffer(ye)) {
      const se = he(ye.length) | 0, oe = Y(se);
      return oe.length === 0 || ye.copy(oe, 0, 0, se), oe;
    }
    if (ye.length !== void 0)
      return typeof ye.length != "number" || Ke(ye.length) ? Y(0) : ue(ye);
    if (ye.type === "Buffer" && Array.isArray(ye.data))
      return ue(ye.data);
  }
  function he(ye) {
    if (ye >= U)
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + U.toString(16) + " bytes");
    return ye | 0;
  }
  function we(ye) {
    return +ye != ye && (ye = 0), Q.alloc(+ye);
  }
  Q.isBuffer = function(se) {
    return se != null && se._isBuffer === !0 && se !== Q.prototype;
  }, Q.compare = function(se, oe) {
    if (He(se, W) && (se = Q.from(se, se.offset, se.byteLength)), He(oe, W) && (oe = Q.from(oe, oe.offset, oe.byteLength)), !Q.isBuffer(se) || !Q.isBuffer(oe))
      throw new TypeError(
        'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
      );
    if (se === oe)
      return 0;
    let Le = se.length, Ae = oe.length;
    for (let Re = 0, Ze = Math.min(Le, Ae); Re < Ze; ++Re)
      if (se[Re] !== oe[Re]) {
        Le = se[Re], Ae = oe[Re];
        break;
      }
    return Le < Ae ? -1 : Ae < Le ? 1 : 0;
  }, Q.isEncoding = function(se) {
    switch (String(se).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return !0;
      default:
        return !1;
    }
  }, Q.concat = function(se, oe) {
    if (!Array.isArray(se))
      throw new TypeError('"list" argument must be an Array of Buffers');
    if (se.length === 0)
      return Q.alloc(0);
    let Le;
    if (oe === void 0)
      for (oe = 0, Le = 0; Le < se.length; ++Le)
        oe += se[Le].length;
    const Ae = Q.allocUnsafe(oe);
    let Re = 0;
    for (Le = 0; Le < se.length; ++Le) {
      let Ze = se[Le];
      if (He(Ze, W))
        Re + Ze.length > Ae.length ? (Q.isBuffer(Ze) || (Ze = Q.from(Ze)), Ze.copy(Ae, Re)) : W.prototype.set.call(
          Ae,
          Ze,
          Re
        );
      else if (Q.isBuffer(Ze))
        Ze.copy(Ae, Re);
      else
        throw new TypeError('"list" argument must be an Array of Buffers');
      Re += Ze.length;
    }
    return Ae;
  };
  function me(ye, se) {
    if (Q.isBuffer(ye))
      return ye.length;
    if (B.isView(ye) || He(ye, B))
      return ye.byteLength;
    if (typeof ye != "string")
      throw new TypeError(
        'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof ye
      );
    const oe = ye.length, Le = arguments.length > 2 && arguments[2] === !0;
    if (!Le && oe === 0)
      return 0;
    let Ae = !1;
    for (; ; )
      switch (se) {
        case "ascii":
        case "latin1":
        case "binary":
          return oe;
        case "utf8":
        case "utf-8":
          return at(ye).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return oe * 2;
        case "hex":
          return oe >>> 1;
        case "base64":
          return Ue(ye).length;
        default:
          if (Ae)
            return Le ? -1 : at(ye).length;
          se = ("" + se).toLowerCase(), Ae = !0;
      }
  }
  Q.byteLength = me;
  function de(ye, se, oe) {
    let Le = !1;
    if ((se === void 0 || se < 0) && (se = 0), se > this.length || ((oe === void 0 || oe > this.length) && (oe = this.length), oe <= 0) || (oe >>>= 0, se >>>= 0, oe <= se))
      return "";
    for (ye || (ye = "utf8"); ; )
      switch (ye) {
        case "hex":
          return Ie(this, se, oe);
        case "utf8":
        case "utf-8":
          return We(this, se, oe);
        case "ascii":
          return ke(this, se, oe);
        case "latin1":
        case "binary":
          return je(this, se, oe);
        case "base64":
          return Be(this, se, oe);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return ve(this, se, oe);
        default:
          if (Le)
            throw new TypeError("Unknown encoding: " + ye);
          ye = (ye + "").toLowerCase(), Le = !0;
      }
  }
  Q.prototype._isBuffer = !0;
  function be(ye, se, oe) {
    const Le = ye[se];
    ye[se] = ye[oe], ye[oe] = Le;
  }
  Q.prototype.swap16 = function() {
    const se = this.length;
    if (se % 2 !== 0)
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    for (let oe = 0; oe < se; oe += 2)
      be(this, oe, oe + 1);
    return this;
  }, Q.prototype.swap32 = function() {
    const se = this.length;
    if (se % 4 !== 0)
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    for (let oe = 0; oe < se; oe += 4)
      be(this, oe, oe + 3), be(this, oe + 1, oe + 2);
    return this;
  }, Q.prototype.swap64 = function() {
    const se = this.length;
    if (se % 8 !== 0)
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    for (let oe = 0; oe < se; oe += 8)
      be(this, oe, oe + 7), be(this, oe + 1, oe + 6), be(this, oe + 2, oe + 5), be(this, oe + 3, oe + 4);
    return this;
  }, Q.prototype.toString = function() {
    const se = this.length;
    return se === 0 ? "" : arguments.length === 0 ? We(this, 0, se) : de.apply(this, arguments);
  }, Q.prototype.toLocaleString = Q.prototype.toString, Q.prototype.equals = function(se) {
    if (!Q.isBuffer(se))
      throw new TypeError("Argument must be a Buffer");
    return this === se ? !0 : Q.compare(this, se) === 0;
  }, Q.prototype.inspect = function() {
    let se = "";
    const oe = z.INSPECT_MAX_BYTES;
    return se = this.toString("hex", 0, oe).replace(/(.{2})/g, "$1 ").trim(), this.length > oe && (se += " ... "), "<Buffer " + se + ">";
  }, F && (Q.prototype[F] = Q.prototype.inspect), Q.prototype.compare = function(se, oe, Le, Ae, Re) {
    if (He(se, W) && (se = Q.from(se, se.offset, se.byteLength)), !Q.isBuffer(se))
      throw new TypeError(
        'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof se
      );
    if (oe === void 0 && (oe = 0), Le === void 0 && (Le = se ? se.length : 0), Ae === void 0 && (Ae = 0), Re === void 0 && (Re = this.length), oe < 0 || Le > se.length || Ae < 0 || Re > this.length)
      throw new RangeError("out of range index");
    if (Ae >= Re && oe >= Le)
      return 0;
    if (Ae >= Re)
      return -1;
    if (oe >= Le)
      return 1;
    if (oe >>>= 0, Le >>>= 0, Ae >>>= 0, Re >>>= 0, this === se)
      return 0;
    let Ze = Re - Ae, it = Le - oe;
    const lt = Math.min(Ze, it), ot = this.slice(Ae, Re), ct = se.slice(oe, Le);
    for (let nt = 0; nt < lt; ++nt)
      if (ot[nt] !== ct[nt]) {
        Ze = ot[nt], it = ct[nt];
        break;
      }
    return Ze < it ? -1 : it < Ze ? 1 : 0;
  };
  function _e(ye, se, oe, Le, Ae) {
    if (ye.length === 0)
      return -1;
    if (typeof oe == "string" ? (Le = oe, oe = 0) : oe > 2147483647 ? oe = 2147483647 : oe < -2147483648 && (oe = -2147483648), oe = +oe, Ke(oe) && (oe = Ae ? 0 : ye.length - 1), oe < 0 && (oe = ye.length + oe), oe >= ye.length) {
      if (Ae)
        return -1;
      oe = ye.length - 1;
    } else if (oe < 0)
      if (Ae)
        oe = 0;
      else
        return -1;
    if (typeof se == "string" && (se = Q.from(se, Le)), Q.isBuffer(se))
      return se.length === 0 ? -1 : Me(ye, se, oe, Le, Ae);
    if (typeof se == "number")
      return se = se & 255, typeof W.prototype.indexOf == "function" ? Ae ? W.prototype.indexOf.call(ye, se, oe) : W.prototype.lastIndexOf.call(ye, se, oe) : Me(ye, [se], oe, Le, Ae);
    throw new TypeError("val must be string, number or Buffer");
  }
  function Me(ye, se, oe, Le, Ae) {
    let Re = 1, Ze = ye.length, it = se.length;
    if (Le !== void 0 && (Le = String(Le).toLowerCase(), Le === "ucs2" || Le === "ucs-2" || Le === "utf16le" || Le === "utf-16le")) {
      if (ye.length < 2 || se.length < 2)
        return -1;
      Re = 2, Ze /= 2, it /= 2, oe /= 2;
    }
    function lt(ct, nt) {
      return Re === 1 ? ct[nt] : ct.readUInt16BE(nt * Re);
    }
    let ot;
    if (Ae) {
      let ct = -1;
      for (ot = oe; ot < Ze; ot++)
        if (lt(ye, ot) === lt(se, ct === -1 ? 0 : ot - ct)) {
          if (ct === -1 && (ct = ot), ot - ct + 1 === it)
            return ct * Re;
        } else
          ct !== -1 && (ot -= ot - ct), ct = -1;
    } else
      for (oe + it > Ze && (oe = Ze - it), ot = oe; ot >= 0; ot--) {
        let ct = !0;
        for (let nt = 0; nt < it; nt++)
          if (lt(ye, ot + nt) !== lt(se, nt)) {
            ct = !1;
            break;
          }
        if (ct)
          return ot;
      }
    return -1;
  }
  Q.prototype.includes = function(se, oe, Le) {
    return this.indexOf(se, oe, Le) !== -1;
  }, Q.prototype.indexOf = function(se, oe, Le) {
    return _e(this, se, oe, Le, !0);
  }, Q.prototype.lastIndexOf = function(se, oe, Le) {
    return _e(this, se, oe, Le, !1);
  };
  function Ne(ye, se, oe, Le) {
    oe = Number(oe) || 0;
    const Ae = ye.length - oe;
    Le ? (Le = Number(Le), Le > Ae && (Le = Ae)) : Le = Ae;
    const Re = se.length;
    Le > Re / 2 && (Le = Re / 2);
    let Ze;
    for (Ze = 0; Ze < Le; ++Ze) {
      const it = parseInt(se.substr(Ze * 2, 2), 16);
      if (Ke(it))
        return Ze;
      ye[oe + Ze] = it;
    }
    return Ze;
  }
  function Ee(ye, se, oe, Le) {
    return Ye(at(se, ye.length - oe), ye, oe, Le);
  }
  function $e(ye, se, oe, Le) {
    return Ye(dt(se), ye, oe, Le);
  }
  function De(ye, se, oe, Le) {
    return Ye(Ue(se), ye, oe, Le);
  }
  function Fe(ye, se, oe, Le) {
    return Ye(st(se, ye.length - oe), ye, oe, Le);
  }
  Q.prototype.write = function(se, oe, Le, Ae) {
    if (oe === void 0)
      Ae = "utf8", Le = this.length, oe = 0;
    else if (Le === void 0 && typeof oe == "string")
      Ae = oe, Le = this.length, oe = 0;
    else if (isFinite(oe))
      oe = oe >>> 0, isFinite(Le) ? (Le = Le >>> 0, Ae === void 0 && (Ae = "utf8")) : (Ae = Le, Le = void 0);
    else
      throw new Error(
        "Buffer.write(string, encoding, offset[, length]) is no longer supported"
      );
    const Re = this.length - oe;
    if ((Le === void 0 || Le > Re) && (Le = Re), se.length > 0 && (Le < 0 || oe < 0) || oe > this.length)
      throw new RangeError("Attempt to write outside buffer bounds");
    Ae || (Ae = "utf8");
    let Ze = !1;
    for (; ; )
      switch (Ae) {
        case "hex":
          return Ne(this, se, oe, Le);
        case "utf8":
        case "utf-8":
          return Ee(this, se, oe, Le);
        case "ascii":
        case "latin1":
        case "binary":
          return $e(this, se, oe, Le);
        case "base64":
          return De(this, se, oe, Le);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return Fe(this, se, oe, Le);
        default:
          if (Ze)
            throw new TypeError("Unknown encoding: " + Ae);
          Ae = ("" + Ae).toLowerCase(), Ze = !0;
      }
  }, Q.prototype.toJSON = function() {
    return {
      type: "Buffer",
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function Be(ye, se, oe) {
    return se === 0 && oe === ye.length ? D.fromByteArray(ye) : D.fromByteArray(ye.slice(se, oe));
  }
  function We(ye, se, oe) {
    oe = Math.min(ye.length, oe);
    const Le = [];
    let Ae = se;
    for (; Ae < oe; ) {
      const Re = ye[Ae];
      let Ze = null, it = Re > 239 ? 4 : Re > 223 ? 3 : Re > 191 ? 2 : 1;
      if (Ae + it <= oe) {
        let lt, ot, ct, nt;
        switch (it) {
          case 1:
            Re < 128 && (Ze = Re);
            break;
          case 2:
            lt = ye[Ae + 1], (lt & 192) === 128 && (nt = (Re & 31) << 6 | lt & 63, nt > 127 && (Ze = nt));
            break;
          case 3:
            lt = ye[Ae + 1], ot = ye[Ae + 2], (lt & 192) === 128 && (ot & 192) === 128 && (nt = (Re & 15) << 12 | (lt & 63) << 6 | ot & 63, nt > 2047 && (nt < 55296 || nt > 57343) && (Ze = nt));
            break;
          case 4:
            lt = ye[Ae + 1], ot = ye[Ae + 2], ct = ye[Ae + 3], (lt & 192) === 128 && (ot & 192) === 128 && (ct & 192) === 128 && (nt = (Re & 15) << 18 | (lt & 63) << 12 | (ot & 63) << 6 | ct & 63, nt > 65535 && nt < 1114112 && (Ze = nt));
        }
      }
      Ze === null ? (Ze = 65533, it = 1) : Ze > 65535 && (Ze -= 65536, Le.push(Ze >>> 10 & 1023 | 55296), Ze = 56320 | Ze & 1023), Le.push(Ze), Ae += it;
    }
    return ze(Le);
  }
  const Ve = 4096;
  function ze(ye) {
    const se = ye.length;
    if (se <= Ve)
      return String.fromCharCode.apply(String, ye);
    let oe = "", Le = 0;
    for (; Le < se; )
      oe += String.fromCharCode.apply(
        String,
        ye.slice(Le, Le += Ve)
      );
    return oe;
  }
  function ke(ye, se, oe) {
    let Le = "";
    oe = Math.min(ye.length, oe);
    for (let Ae = se; Ae < oe; ++Ae)
      Le += String.fromCharCode(ye[Ae] & 127);
    return Le;
  }
  function je(ye, se, oe) {
    let Le = "";
    oe = Math.min(ye.length, oe);
    for (let Ae = se; Ae < oe; ++Ae)
      Le += String.fromCharCode(ye[Ae]);
    return Le;
  }
  function Ie(ye, se, oe) {
    const Le = ye.length;
    (!se || se < 0) && (se = 0), (!oe || oe < 0 || oe > Le) && (oe = Le);
    let Ae = "";
    for (let Re = se; Re < oe; ++Re)
      Ae += tt[ye[Re]];
    return Ae;
  }
  function ve(ye, se, oe) {
    const Le = ye.slice(se, oe);
    let Ae = "";
    for (let Re = 0; Re < Le.length - 1; Re += 2)
      Ae += String.fromCharCode(Le[Re] + Le[Re + 1] * 256);
    return Ae;
  }
  Q.prototype.slice = function(se, oe) {
    const Le = this.length;
    se = ~~se, oe = oe === void 0 ? Le : ~~oe, se < 0 ? (se += Le, se < 0 && (se = 0)) : se > Le && (se = Le), oe < 0 ? (oe += Le, oe < 0 && (oe = 0)) : oe > Le && (oe = Le), oe < se && (oe = se);
    const Ae = this.subarray(se, oe);
    return Object.setPrototypeOf(Ae, Q.prototype), Ae;
  };
  function xe(ye, se, oe) {
    if (ye % 1 !== 0 || ye < 0)
      throw new RangeError("offset is not uint");
    if (ye + se > oe)
      throw new RangeError("Trying to access beyond buffer length");
  }
  Q.prototype.readUintLE = Q.prototype.readUIntLE = function(se, oe, Le) {
    se = se >>> 0, oe = oe >>> 0, Le || xe(se, oe, this.length);
    let Ae = this[se], Re = 1, Ze = 0;
    for (; ++Ze < oe && (Re *= 256); )
      Ae += this[se + Ze] * Re;
    return Ae;
  }, Q.prototype.readUintBE = Q.prototype.readUIntBE = function(se, oe, Le) {
    se = se >>> 0, oe = oe >>> 0, Le || xe(se, oe, this.length);
    let Ae = this[se + --oe], Re = 1;
    for (; oe > 0 && (Re *= 256); )
      Ae += this[se + --oe] * Re;
    return Ae;
  }, Q.prototype.readUint8 = Q.prototype.readUInt8 = function(se, oe) {
    return se = se >>> 0, oe || xe(se, 1, this.length), this[se];
  }, Q.prototype.readUint16LE = Q.prototype.readUInt16LE = function(se, oe) {
    return se = se >>> 0, oe || xe(se, 2, this.length), this[se] | this[se + 1] << 8;
  }, Q.prototype.readUint16BE = Q.prototype.readUInt16BE = function(se, oe) {
    return se = se >>> 0, oe || xe(se, 2, this.length), this[se] << 8 | this[se + 1];
  }, Q.prototype.readUint32LE = Q.prototype.readUInt32LE = function(se, oe) {
    return se = se >>> 0, oe || xe(se, 4, this.length), (this[se] | this[se + 1] << 8 | this[se + 2] << 16) + this[se + 3] * 16777216;
  }, Q.prototype.readUint32BE = Q.prototype.readUInt32BE = function(se, oe) {
    return se = se >>> 0, oe || xe(se, 4, this.length), this[se] * 16777216 + (this[se + 1] << 16 | this[se + 2] << 8 | this[se + 3]);
  }, Q.prototype.readBigUInt64LE = Je(function(se) {
    se = se >>> 0, Qe(se, "offset");
    const oe = this[se], Le = this[se + 7];
    (oe === void 0 || Le === void 0) && et(se, this.length - 8);
    const Ae = oe + this[++se] * 2 ** 8 + this[++se] * 2 ** 16 + this[++se] * 2 ** 24, Re = this[++se] + this[++se] * 2 ** 8 + this[++se] * 2 ** 16 + Le * 2 ** 24;
    return BigInt(Ae) + (BigInt(Re) << BigInt(32));
  }), Q.prototype.readBigUInt64BE = Je(function(se) {
    se = se >>> 0, Qe(se, "offset");
    const oe = this[se], Le = this[se + 7];
    (oe === void 0 || Le === void 0) && et(se, this.length - 8);
    const Ae = oe * 2 ** 24 + this[++se] * 2 ** 16 + this[++se] * 2 ** 8 + this[++se], Re = this[++se] * 2 ** 24 + this[++se] * 2 ** 16 + this[++se] * 2 ** 8 + Le;
    return (BigInt(Ae) << BigInt(32)) + BigInt(Re);
  }), Q.prototype.readIntLE = function(se, oe, Le) {
    se = se >>> 0, oe = oe >>> 0, Le || xe(se, oe, this.length);
    let Ae = this[se], Re = 1, Ze = 0;
    for (; ++Ze < oe && (Re *= 256); )
      Ae += this[se + Ze] * Re;
    return Re *= 128, Ae >= Re && (Ae -= Math.pow(2, 8 * oe)), Ae;
  }, Q.prototype.readIntBE = function(se, oe, Le) {
    se = se >>> 0, oe = oe >>> 0, Le || xe(se, oe, this.length);
    let Ae = oe, Re = 1, Ze = this[se + --Ae];
    for (; Ae > 0 && (Re *= 256); )
      Ze += this[se + --Ae] * Re;
    return Re *= 128, Ze >= Re && (Ze -= Math.pow(2, 8 * oe)), Ze;
  }, Q.prototype.readInt8 = function(se, oe) {
    return se = se >>> 0, oe || xe(se, 1, this.length), this[se] & 128 ? (255 - this[se] + 1) * -1 : this[se];
  }, Q.prototype.readInt16LE = function(se, oe) {
    se = se >>> 0, oe || xe(se, 2, this.length);
    const Le = this[se] | this[se + 1] << 8;
    return Le & 32768 ? Le | 4294901760 : Le;
  }, Q.prototype.readInt16BE = function(se, oe) {
    se = se >>> 0, oe || xe(se, 2, this.length);
    const Le = this[se + 1] | this[se] << 8;
    return Le & 32768 ? Le | 4294901760 : Le;
  }, Q.prototype.readInt32LE = function(se, oe) {
    return se = se >>> 0, oe || xe(se, 4, this.length), this[se] | this[se + 1] << 8 | this[se + 2] << 16 | this[se + 3] << 24;
  }, Q.prototype.readInt32BE = function(se, oe) {
    return se = se >>> 0, oe || xe(se, 4, this.length), this[se] << 24 | this[se + 1] << 16 | this[se + 2] << 8 | this[se + 3];
  }, Q.prototype.readBigInt64LE = Je(function(se) {
    se = se >>> 0, Qe(se, "offset");
    const oe = this[se], Le = this[se + 7];
    (oe === void 0 || Le === void 0) && et(se, this.length - 8);
    const Ae = this[se + 4] + this[se + 5] * 2 ** 8 + this[se + 6] * 2 ** 16 + (Le << 24);
    return (BigInt(Ae) << BigInt(32)) + BigInt(oe + this[++se] * 2 ** 8 + this[++se] * 2 ** 16 + this[++se] * 2 ** 24);
  }), Q.prototype.readBigInt64BE = Je(function(se) {
    se = se >>> 0, Qe(se, "offset");
    const oe = this[se], Le = this[se + 7];
    (oe === void 0 || Le === void 0) && et(se, this.length - 8);
    const Ae = (oe << 24) + // Overflow
    this[++se] * 2 ** 16 + this[++se] * 2 ** 8 + this[++se];
    return (BigInt(Ae) << BigInt(32)) + BigInt(this[++se] * 2 ** 24 + this[++se] * 2 ** 16 + this[++se] * 2 ** 8 + Le);
  }), Q.prototype.readFloatLE = function(se, oe) {
    return se = se >>> 0, oe || xe(se, 4, this.length), O.read(this, se, !0, 23, 4);
  }, Q.prototype.readFloatBE = function(se, oe) {
    return se = se >>> 0, oe || xe(se, 4, this.length), O.read(this, se, !1, 23, 4);
  }, Q.prototype.readDoubleLE = function(se, oe) {
    return se = se >>> 0, oe || xe(se, 8, this.length), O.read(this, se, !0, 52, 8);
  }, Q.prototype.readDoubleBE = function(se, oe) {
    return se = se >>> 0, oe || xe(se, 8, this.length), O.read(this, se, !1, 52, 8);
  };
  function Oe(ye, se, oe, Le, Ae, Re) {
    if (!Q.isBuffer(ye))
      throw new TypeError('"buffer" argument must be a Buffer instance');
    if (se > Ae || se < Re)
      throw new RangeError('"value" argument is out of bounds');
    if (oe + Le > ye.length)
      throw new RangeError("Index out of range");
  }
  Q.prototype.writeUintLE = Q.prototype.writeUIntLE = function(se, oe, Le, Ae) {
    if (se = +se, oe = oe >>> 0, Le = Le >>> 0, !Ae) {
      const it = Math.pow(2, 8 * Le) - 1;
      Oe(this, se, oe, Le, it, 0);
    }
    let Re = 1, Ze = 0;
    for (this[oe] = se & 255; ++Ze < Le && (Re *= 256); )
      this[oe + Ze] = se / Re & 255;
    return oe + Le;
  }, Q.prototype.writeUintBE = Q.prototype.writeUIntBE = function(se, oe, Le, Ae) {
    if (se = +se, oe = oe >>> 0, Le = Le >>> 0, !Ae) {
      const it = Math.pow(2, 8 * Le) - 1;
      Oe(this, se, oe, Le, it, 0);
    }
    let Re = Le - 1, Ze = 1;
    for (this[oe + Re] = se & 255; --Re >= 0 && (Ze *= 256); )
      this[oe + Re] = se / Ze & 255;
    return oe + Le;
  }, Q.prototype.writeUint8 = Q.prototype.writeUInt8 = function(se, oe, Le) {
    return se = +se, oe = oe >>> 0, Le || Oe(this, se, oe, 1, 255, 0), this[oe] = se & 255, oe + 1;
  }, Q.prototype.writeUint16LE = Q.prototype.writeUInt16LE = function(se, oe, Le) {
    return se = +se, oe = oe >>> 0, Le || Oe(this, se, oe, 2, 65535, 0), this[oe] = se & 255, this[oe + 1] = se >>> 8, oe + 2;
  }, Q.prototype.writeUint16BE = Q.prototype.writeUInt16BE = function(se, oe, Le) {
    return se = +se, oe = oe >>> 0, Le || Oe(this, se, oe, 2, 65535, 0), this[oe] = se >>> 8, this[oe + 1] = se & 255, oe + 2;
  }, Q.prototype.writeUint32LE = Q.prototype.writeUInt32LE = function(se, oe, Le) {
    return se = +se, oe = oe >>> 0, Le || Oe(this, se, oe, 4, 4294967295, 0), this[oe + 3] = se >>> 24, this[oe + 2] = se >>> 16, this[oe + 1] = se >>> 8, this[oe] = se & 255, oe + 4;
  }, Q.prototype.writeUint32BE = Q.prototype.writeUInt32BE = function(se, oe, Le) {
    return se = +se, oe = oe >>> 0, Le || Oe(this, se, oe, 4, 4294967295, 0), this[oe] = se >>> 24, this[oe + 1] = se >>> 16, this[oe + 2] = se >>> 8, this[oe + 3] = se & 255, oe + 4;
  };
  function Te(ye, se, oe, Le, Ae) {
    Ge(se, Le, Ae, ye, oe, 7);
    let Re = Number(se & BigInt(4294967295));
    ye[oe++] = Re, Re = Re >> 8, ye[oe++] = Re, Re = Re >> 8, ye[oe++] = Re, Re = Re >> 8, ye[oe++] = Re;
    let Ze = Number(se >> BigInt(32) & BigInt(4294967295));
    return ye[oe++] = Ze, Ze = Ze >> 8, ye[oe++] = Ze, Ze = Ze >> 8, ye[oe++] = Ze, Ze = Ze >> 8, ye[oe++] = Ze, oe;
  }
  function Ce(ye, se, oe, Le, Ae) {
    Ge(se, Le, Ae, ye, oe, 7);
    let Re = Number(se & BigInt(4294967295));
    ye[oe + 7] = Re, Re = Re >> 8, ye[oe + 6] = Re, Re = Re >> 8, ye[oe + 5] = Re, Re = Re >> 8, ye[oe + 4] = Re;
    let Ze = Number(se >> BigInt(32) & BigInt(4294967295));
    return ye[oe + 3] = Ze, Ze = Ze >> 8, ye[oe + 2] = Ze, Ze = Ze >> 8, ye[oe + 1] = Ze, Ze = Ze >> 8, ye[oe] = Ze, oe + 8;
  }
  Q.prototype.writeBigUInt64LE = Je(function(se, oe = 0) {
    return Te(this, se, oe, BigInt(0), BigInt("0xffffffffffffffff"));
  }), Q.prototype.writeBigUInt64BE = Je(function(se, oe = 0) {
    return Ce(this, se, oe, BigInt(0), BigInt("0xffffffffffffffff"));
  }), Q.prototype.writeIntLE = function(se, oe, Le, Ae) {
    if (se = +se, oe = oe >>> 0, !Ae) {
      const lt = Math.pow(2, 8 * Le - 1);
      Oe(this, se, oe, Le, lt - 1, -lt);
    }
    let Re = 0, Ze = 1, it = 0;
    for (this[oe] = se & 255; ++Re < Le && (Ze *= 256); )
      se < 0 && it === 0 && this[oe + Re - 1] !== 0 && (it = 1), this[oe + Re] = (se / Ze >> 0) - it & 255;
    return oe + Le;
  }, Q.prototype.writeIntBE = function(se, oe, Le, Ae) {
    if (se = +se, oe = oe >>> 0, !Ae) {
      const lt = Math.pow(2, 8 * Le - 1);
      Oe(this, se, oe, Le, lt - 1, -lt);
    }
    let Re = Le - 1, Ze = 1, it = 0;
    for (this[oe + Re] = se & 255; --Re >= 0 && (Ze *= 256); )
      se < 0 && it === 0 && this[oe + Re + 1] !== 0 && (it = 1), this[oe + Re] = (se / Ze >> 0) - it & 255;
    return oe + Le;
  }, Q.prototype.writeInt8 = function(se, oe, Le) {
    return se = +se, oe = oe >>> 0, Le || Oe(this, se, oe, 1, 127, -128), se < 0 && (se = 255 + se + 1), this[oe] = se & 255, oe + 1;
  }, Q.prototype.writeInt16LE = function(se, oe, Le) {
    return se = +se, oe = oe >>> 0, Le || Oe(this, se, oe, 2, 32767, -32768), this[oe] = se & 255, this[oe + 1] = se >>> 8, oe + 2;
  }, Q.prototype.writeInt16BE = function(se, oe, Le) {
    return se = +se, oe = oe >>> 0, Le || Oe(this, se, oe, 2, 32767, -32768), this[oe] = se >>> 8, this[oe + 1] = se & 255, oe + 2;
  }, Q.prototype.writeInt32LE = function(se, oe, Le) {
    return se = +se, oe = oe >>> 0, Le || Oe(this, se, oe, 4, 2147483647, -2147483648), this[oe] = se & 255, this[oe + 1] = se >>> 8, this[oe + 2] = se >>> 16, this[oe + 3] = se >>> 24, oe + 4;
  }, Q.prototype.writeInt32BE = function(se, oe, Le) {
    return se = +se, oe = oe >>> 0, Le || Oe(this, se, oe, 4, 2147483647, -2147483648), se < 0 && (se = 4294967295 + se + 1), this[oe] = se >>> 24, this[oe + 1] = se >>> 16, this[oe + 2] = se >>> 8, this[oe + 3] = se & 255, oe + 4;
  }, Q.prototype.writeBigInt64LE = Je(function(se, oe = 0) {
    return Te(this, se, oe, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  }), Q.prototype.writeBigInt64BE = Je(function(se, oe = 0) {
    return Ce(this, se, oe, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  function te(ye, se, oe, Le, Ae, Re) {
    if (oe + Le > ye.length)
      throw new RangeError("Index out of range");
    if (oe < 0)
      throw new RangeError("Index out of range");
  }
  function le(ye, se, oe, Le, Ae) {
    return se = +se, oe = oe >>> 0, Ae || te(ye, se, oe, 4), O.write(ye, se, oe, Le, 23, 4), oe + 4;
  }
  Q.prototype.writeFloatLE = function(se, oe, Le) {
    return le(this, se, oe, !0, Le);
  }, Q.prototype.writeFloatBE = function(se, oe, Le) {
    return le(this, se, oe, !1, Le);
  };
  function ge(ye, se, oe, Le, Ae) {
    return se = +se, oe = oe >>> 0, Ae || te(ye, se, oe, 8), O.write(ye, se, oe, Le, 52, 8), oe + 8;
  }
  Q.prototype.writeDoubleLE = function(se, oe, Le) {
    return ge(this, se, oe, !0, Le);
  }, Q.prototype.writeDoubleBE = function(se, oe, Le) {
    return ge(this, se, oe, !1, Le);
  }, Q.prototype.copy = function(se, oe, Le, Ae) {
    if (!Q.isBuffer(se))
      throw new TypeError("argument should be a Buffer");
    if (Le || (Le = 0), !Ae && Ae !== 0 && (Ae = this.length), oe >= se.length && (oe = se.length), oe || (oe = 0), Ae > 0 && Ae < Le && (Ae = Le), Ae === Le || se.length === 0 || this.length === 0)
      return 0;
    if (oe < 0)
      throw new RangeError("targetStart out of bounds");
    if (Le < 0 || Le >= this.length)
      throw new RangeError("Index out of range");
    if (Ae < 0)
      throw new RangeError("sourceEnd out of bounds");
    Ae > this.length && (Ae = this.length), se.length - oe < Ae - Le && (Ae = se.length - oe + Le);
    const Re = Ae - Le;
    return this === se && typeof W.prototype.copyWithin == "function" ? this.copyWithin(oe, Le, Ae) : W.prototype.set.call(
      se,
      this.subarray(Le, Ae),
      oe
    ), Re;
  }, Q.prototype.fill = function(se, oe, Le, Ae) {
    if (typeof se == "string") {
      if (typeof oe == "string" ? (Ae = oe, oe = 0, Le = this.length) : typeof Le == "string" && (Ae = Le, Le = this.length), Ae !== void 0 && typeof Ae != "string")
        throw new TypeError("encoding must be a string");
      if (typeof Ae == "string" && !Q.isEncoding(Ae))
        throw new TypeError("Unknown encoding: " + Ae);
      if (se.length === 1) {
        const Ze = se.charCodeAt(0);
        (Ae === "utf8" && Ze < 128 || Ae === "latin1") && (se = Ze);
      }
    } else
      typeof se == "number" ? se = se & 255 : typeof se == "boolean" && (se = Number(se));
    if (oe < 0 || this.length < oe || this.length < Le)
      throw new RangeError("Out of range index");
    if (Le <= oe)
      return this;
    oe = oe >>> 0, Le = Le === void 0 ? this.length : Le >>> 0, se || (se = 0);
    let Re;
    if (typeof se == "number")
      for (Re = oe; Re < Le; ++Re)
        this[Re] = se;
    else {
      const Ze = Q.isBuffer(se) ? se : Q.from(se, Ae), it = Ze.length;
      if (it === 0)
        throw new TypeError('The value "' + se + '" is invalid for argument "value"');
      for (Re = 0; Re < Le - oe; ++Re)
        this[Re + oe] = Ze[Re % it];
    }
    return this;
  };
  const pe = {};
  function fe(ye, se, oe) {
    pe[ye] = class extends oe {
      constructor() {
        super(), Object.defineProperty(this, "message", {
          value: se.apply(this, arguments),
          writable: !0,
          configurable: !0
        }), this.name = `${this.name} [${ye}]`, this.stack, delete this.name;
      }
      get code() {
        return ye;
      }
      set code(Ae) {
        Object.defineProperty(this, "code", {
          configurable: !0,
          enumerable: !0,
          value: Ae,
          writable: !0
        });
      }
      toString() {
        return `${this.name} [${ye}]: ${this.message}`;
      }
    };
  }
  fe(
    "ERR_BUFFER_OUT_OF_BOUNDS",
    function(ye) {
      return ye ? `${ye} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
    },
    RangeError
  ), fe(
    "ERR_INVALID_ARG_TYPE",
    function(ye, se) {
      return `The "${ye}" argument must be of type number. Received type ${typeof se}`;
    },
    TypeError
  ), fe(
    "ERR_OUT_OF_RANGE",
    function(ye, se, oe) {
      let Le = `The value of "${ye}" is out of range.`, Ae = oe;
      return Number.isInteger(oe) && Math.abs(oe) > 2 ** 32 ? Ae = Se(String(oe)) : typeof oe == "bigint" && (Ae = String(oe), (oe > BigInt(2) ** BigInt(32) || oe < -(BigInt(2) ** BigInt(32))) && (Ae = Se(Ae)), Ae += "n"), Le += ` It must be ${se}. Received ${Ae}`, Le;
    },
    RangeError
  );
  function Se(ye) {
    let se = "", oe = ye.length;
    const Le = ye[0] === "-" ? 1 : 0;
    for (; oe >= Le + 4; oe -= 3)
      se = `_${ye.slice(oe - 3, oe)}${se}`;
    return `${ye.slice(0, oe)}${se}`;
  }
  function Pe(ye, se, oe) {
    Qe(se, "offset"), (ye[se] === void 0 || ye[se + oe] === void 0) && et(se, ye.length - (oe + 1));
  }
  function Ge(ye, se, oe, Le, Ae, Re) {
    if (ye > oe || ye < se) {
      const Ze = typeof se == "bigint" ? "n" : "";
      let it;
      throw se === 0 || se === BigInt(0) ? it = `>= 0${Ze} and < 2${Ze} ** ${(Re + 1) * 8}${Ze}` : it = `>= -(2${Ze} ** ${(Re + 1) * 8 - 1}${Ze}) and < 2 ** ${(Re + 1) * 8 - 1}${Ze}`, new pe.ERR_OUT_OF_RANGE("value", it, ye);
    }
    Pe(Le, Ae, Re);
  }
  function Qe(ye, se) {
    if (typeof ye != "number")
      throw new pe.ERR_INVALID_ARG_TYPE(se, "number", ye);
  }
  function et(ye, se, oe) {
    throw Math.floor(ye) !== ye ? (Qe(ye, oe), new pe.ERR_OUT_OF_RANGE("offset", "an integer", ye)) : se < 0 ? new pe.ERR_BUFFER_OUT_OF_BOUNDS() : new pe.ERR_OUT_OF_RANGE(
      "offset",
      `>= 0 and <= ${se}`,
      ye
    );
  }
  const rt = /[^+/0-9A-Za-z-_]/g;
  function Xe(ye) {
    if (ye = ye.split("=")[0], ye = ye.trim().replace(rt, ""), ye.length < 2)
      return "";
    for (; ye.length % 4 !== 0; )
      ye = ye + "=";
    return ye;
  }
  function at(ye, se) {
    se = se || 1 / 0;
    let oe;
    const Le = ye.length;
    let Ae = null;
    const Re = [];
    for (let Ze = 0; Ze < Le; ++Ze) {
      if (oe = ye.charCodeAt(Ze), oe > 55295 && oe < 57344) {
        if (!Ae) {
          if (oe > 56319) {
            (se -= 3) > -1 && Re.push(239, 191, 189);
            continue;
          } else if (Ze + 1 === Le) {
            (se -= 3) > -1 && Re.push(239, 191, 189);
            continue;
          }
          Ae = oe;
          continue;
        }
        if (oe < 56320) {
          (se -= 3) > -1 && Re.push(239, 191, 189), Ae = oe;
          continue;
        }
        oe = (Ae - 55296 << 10 | oe - 56320) + 65536;
      } else
        Ae && (se -= 3) > -1 && Re.push(239, 191, 189);
      if (Ae = null, oe < 128) {
        if ((se -= 1) < 0)
          break;
        Re.push(oe);
      } else if (oe < 2048) {
        if ((se -= 2) < 0)
          break;
        Re.push(
          oe >> 6 | 192,
          oe & 63 | 128
        );
      } else if (oe < 65536) {
        if ((se -= 3) < 0)
          break;
        Re.push(
          oe >> 12 | 224,
          oe >> 6 & 63 | 128,
          oe & 63 | 128
        );
      } else if (oe < 1114112) {
        if ((se -= 4) < 0)
          break;
        Re.push(
          oe >> 18 | 240,
          oe >> 12 & 63 | 128,
          oe >> 6 & 63 | 128,
          oe & 63 | 128
        );
      } else
        throw new Error("Invalid code point");
    }
    return Re;
  }
  function dt(ye) {
    const se = [];
    for (let oe = 0; oe < ye.length; ++oe)
      se.push(ye.charCodeAt(oe) & 255);
    return se;
  }
  function st(ye, se) {
    let oe, Le, Ae;
    const Re = [];
    for (let Ze = 0; Ze < ye.length && !((se -= 2) < 0); ++Ze)
      oe = ye.charCodeAt(Ze), Le = oe >> 8, Ae = oe % 256, Re.push(Ae), Re.push(Le);
    return Re;
  }
  function Ue(ye) {
    return D.toByteArray(Xe(ye));
  }
  function Ye(ye, se, oe, Le) {
    let Ae;
    for (Ae = 0; Ae < Le && !(Ae + oe >= se.length || Ae >= ye.length); ++Ae)
      se[Ae + oe] = ye[Ae];
    return Ae;
  }
  function He(ye, se) {
    return ye instanceof se || ye != null && ye.constructor != null && ye.constructor.name != null && ye.constructor.name === se.name;
  }
  function Ke(ye) {
    return ye !== ye;
  }
  const tt = function() {
    const ye = "0123456789abcdef", se = new Array(256);
    for (let oe = 0; oe < 16; ++oe) {
      const Le = oe * 16;
      for (let Ae = 0; Ae < 16; ++Ae)
        se[Le + Ae] = ye[oe] + ye[Ae];
    }
    return se;
  }();
  function Je(ye) {
    return typeof BigInt > "u" ? qe : ye;
  }
  function qe() {
    throw new Error("BigInt not supported");
  }
})(buffer);
const Buffer = buffer.Buffer, Blob$1 = buffer.Blob, BlobOptions = buffer.BlobOptions, Buffer$1 = buffer.Buffer, File$1 = buffer.File, FileOptions = buffer.FileOptions, INSPECT_MAX_BYTES = buffer.INSPECT_MAX_BYTES, SlowBuffer = buffer.SlowBuffer, TranscodeEncoding = buffer.TranscodeEncoding, atob$1 = buffer.atob, btoa = buffer.btoa, constants = buffer.constants, isAscii = buffer.isAscii, isUtf8 = buffer.isUtf8, kMaxLength = buffer.kMaxLength, kStringMaxLength = buffer.kStringMaxLength, resolveObjectURL = buffer.resolveObjectURL, transcode = buffer.transcode, dist = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Blob: Blob$1,
  BlobOptions,
  Buffer: Buffer$1,
  File: File$1,
  FileOptions,
  INSPECT_MAX_BYTES,
  SlowBuffer,
  TranscodeEncoding,
  atob: atob$1,
  btoa,
  constants,
  default: Buffer,
  isAscii,
  isUtf8,
  kMaxLength,
  kStringMaxLength,
  resolveObjectURL,
  transcode
}, Symbol.toStringTag, { value: "Module" }));
var AbstractTokenizer$1 = {}, lib$2 = {}, EndOfFileStream = {};
(function(z) {
  Object.defineProperty(z, "__esModule", { value: !0 }), z.EndOfStreamError = z.defaultMessages = void 0, z.defaultMessages = "End-Of-Stream";
  class D extends Error {
    constructor() {
      super(z.defaultMessages);
    }
  }
  z.EndOfStreamError = D;
})(EndOfFileStream);
var StreamReader$1 = {}, Deferred$1 = {};
Object.defineProperty(Deferred$1, "__esModule", { value: !0 });
Deferred$1.Deferred = void 0;
class Deferred {
  constructor() {
    this.resolve = () => null, this.reject = () => null, this.promise = new Promise((D, O) => {
      this.reject = O, this.resolve = D;
    });
  }
}
Deferred$1.Deferred = Deferred;
(function(z) {
  Object.defineProperty(z, "__esModule", { value: !0 }), z.StreamReader = z.EndOfStreamError = void 0;
  const D = EndOfFileStream, O = Deferred$1;
  var F = EndOfFileStream;
  Object.defineProperty(z, "EndOfStreamError", { enumerable: !0, get: function() {
    return F.EndOfStreamError;
  } });
  const U = 1 * 1024 * 1024;
  class W {
    constructor(K) {
      if (this.s = K, this.deferred = null, this.endOfStream = !1, this.peekQueue = [], !K.read || !K.once)
        throw new Error("Expected an instance of stream.Readable");
      this.s.once("end", () => this.reject(new D.EndOfStreamError())), this.s.once("error", (X) => this.reject(X)), this.s.once("close", () => this.reject(new Error("Stream closed")));
    }
    /**
     * Read ahead (peek) from stream. Subsequent read or peeks will return the same data
     * @param uint8Array - Uint8Array (or Buffer) to store data read from stream in
     * @param offset - Offset target
     * @param length - Number of bytes to read
     * @returns Number of bytes peeked
     */
    async peek(K, X, Y) {
      const Q = await this.read(K, X, Y);
      return this.peekQueue.push(K.subarray(X, X + Q)), Q;
    }
    /**
     * Read chunk from stream
     * @param buffer - Target Uint8Array (or Buffer) to store data read from stream in
     * @param offset - Offset target
     * @param length - Number of bytes to read
     * @returns Number of bytes read
     */
    async read(K, X, Y) {
      if (Y === 0)
        return 0;
      if (this.peekQueue.length === 0 && this.endOfStream)
        throw new D.EndOfStreamError();
      let Q = Y, J = 0;
      for (; this.peekQueue.length > 0 && Q > 0; ) {
        const ee = this.peekQueue.pop();
        if (!ee)
          throw new Error("peekData should be defined");
        const ae = Math.min(ee.length, Q);
        K.set(ee.subarray(0, ae), X + J), J += ae, Q -= ae, ae < ee.length && this.peekQueue.push(ee.subarray(ae));
      }
      for (; Q > 0 && !this.endOfStream; ) {
        const ee = Math.min(Q, U), ae = await this.readFromStream(K, X + J, ee);
        if (J += ae, ae < ee)
          break;
        Q -= ae;
      }
      return J;
    }
    /**
     * Read chunk from stream
     * @param buffer Target Uint8Array (or Buffer) to store data read from stream in
     * @param offset Offset target
     * @param length Number of bytes to read
     * @returns Number of bytes read
     */
    async readFromStream(K, X, Y) {
      const Q = this.s.read(Y);
      if (Q)
        return K.set(Q, X), Q.length;
      {
        const J = {
          buffer: K,
          offset: X,
          length: Y,
          deferred: new O.Deferred()
        };
        return this.deferred = J.deferred, this.s.once("readable", () => {
          this.readDeferred(J);
        }), J.deferred.promise;
      }
    }
    /**
     * Process deferred read request
     * @param request Deferred read request
     */
    readDeferred(K) {
      const X = this.s.read(K.length);
      X ? (K.buffer.set(X, K.offset), K.deferred.resolve(X.length), this.deferred = null) : this.s.once("readable", () => {
        this.readDeferred(K);
      });
    }
    reject(K) {
      this.endOfStream = !0, this.deferred && (this.deferred.reject(K), this.deferred = null);
    }
  }
  z.StreamReader = W;
})(StreamReader$1);
(function(z) {
  Object.defineProperty(z, "__esModule", { value: !0 }), z.StreamReader = z.EndOfStreamError = void 0;
  var D = EndOfFileStream;
  Object.defineProperty(z, "EndOfStreamError", { enumerable: !0, get: function() {
    return D.EndOfStreamError;
  } });
  var O = StreamReader$1;
  Object.defineProperty(z, "StreamReader", { enumerable: !0, get: function() {
    return O.StreamReader;
  } });
})(lib$2);
Object.defineProperty(AbstractTokenizer$1, "__esModule", { value: !0 });
AbstractTokenizer$1.AbstractTokenizer = void 0;
const peek_readable_1$2 = lib$2;
class AbstractTokenizer {
  constructor(D) {
    this.position = 0, this.numBuffer = new Uint8Array(8), this.fileInfo = D || {};
  }
  /**
   * Read a token from the tokenizer-stream
   * @param token - The token to read
   * @param position - If provided, the desired position in the tokenizer-stream
   * @returns Promise with token data
   */
  async readToken(D, O = this.position) {
    const F = Buffer.alloc(D.len);
    if (await this.readBuffer(F, { position: O }) < D.len)
      throw new peek_readable_1$2.EndOfStreamError();
    return D.get(F, 0);
  }
  /**
   * Peek a token from the tokenizer-stream.
   * @param token - Token to peek from the tokenizer-stream.
   * @param position - Offset where to begin reading within the file. If position is null, data will be read from the current file position.
   * @returns Promise with token data
   */
  async peekToken(D, O = this.position) {
    const F = Buffer.alloc(D.len);
    if (await this.peekBuffer(F, { position: O }) < D.len)
      throw new peek_readable_1$2.EndOfStreamError();
    return D.get(F, 0);
  }
  /**
   * Read a numeric token from the stream
   * @param token - Numeric token
   * @returns Promise with number
   */
  async readNumber(D) {
    if (await this.readBuffer(this.numBuffer, { length: D.len }) < D.len)
      throw new peek_readable_1$2.EndOfStreamError();
    return D.get(this.numBuffer, 0);
  }
  /**
   * Read a numeric token from the stream
   * @param token - Numeric token
   * @returns Promise with number
   */
  async peekNumber(D) {
    if (await this.peekBuffer(this.numBuffer, { length: D.len }) < D.len)
      throw new peek_readable_1$2.EndOfStreamError();
    return D.get(this.numBuffer, 0);
  }
  /**
   * Ignore number of bytes, advances the pointer in under tokenizer-stream.
   * @param length - Number of bytes to ignore
   * @return resolves the number of bytes ignored, equals length if this available, otherwise the number of bytes available
   */
  async ignore(D) {
    if (this.fileInfo.size !== void 0) {
      const O = this.fileInfo.size - this.position;
      if (D > O)
        return this.position += O, O;
    }
    return this.position += D, D;
  }
  async close() {
  }
  normalizeOptions(D, O) {
    if (O && O.position !== void 0 && O.position < this.position)
      throw new Error("`options.position` must be equal or greater than `tokenizer.position`");
    return O ? {
      mayBeLess: O.mayBeLess === !0,
      offset: O.offset ? O.offset : 0,
      length: O.length ? O.length : D.length - (O.offset ? O.offset : 0),
      position: O.position ? O.position : this.position
    } : {
      mayBeLess: !1,
      offset: 0,
      length: D.length,
      position: this.position
    };
  }
}
AbstractTokenizer$1.AbstractTokenizer = AbstractTokenizer;
Object.defineProperty(ReadStreamTokenizer$1, "__esModule", { value: !0 });
ReadStreamTokenizer$1.ReadStreamTokenizer = void 0;
const AbstractTokenizer_1$1 = AbstractTokenizer$1, peek_readable_1$1 = lib$2, maxBufferSize = 256e3;
class ReadStreamTokenizer extends AbstractTokenizer_1$1.AbstractTokenizer {
  constructor(D, O) {
    super(O), this.streamReader = new peek_readable_1$1.StreamReader(D);
  }
  /**
   * Get file information, an HTTP-client may implement this doing a HEAD request
   * @return Promise with file information
   */
  async getFileInfo() {
    return this.fileInfo;
  }
  /**
   * Read buffer from tokenizer
   * @param uint8Array - Target Uint8Array to fill with data read from the tokenizer-stream
   * @param options - Read behaviour options
   * @returns Promise with number of bytes read
   */
  async readBuffer(D, O) {
    const F = this.normalizeOptions(D, O), U = F.position - this.position;
    if (U > 0)
      return await this.ignore(U), this.readBuffer(D, O);
    if (U < 0)
      throw new Error("`options.position` must be equal or greater than `tokenizer.position`");
    if (F.length === 0)
      return 0;
    const W = await this.streamReader.read(D, F.offset, F.length);
    if (this.position += W, (!O || !O.mayBeLess) && W < F.length)
      throw new peek_readable_1$1.EndOfStreamError();
    return W;
  }
  /**
   * Peek (read ahead) buffer from tokenizer
   * @param uint8Array - Uint8Array (or Buffer) to write data to
   * @param options - Read behaviour options
   * @returns Promise with number of bytes peeked
   */
  async peekBuffer(D, O) {
    const F = this.normalizeOptions(D, O);
    let U = 0;
    if (F.position) {
      const W = F.position - this.position;
      if (W > 0) {
        const B = new Uint8Array(F.length + W);
        return U = await this.peekBuffer(B, { mayBeLess: F.mayBeLess }), D.set(B.subarray(W), F.offset), U - W;
      } else if (W < 0)
        throw new Error("Cannot peek from a negative offset in a stream");
    }
    if (F.length > 0) {
      try {
        U = await this.streamReader.peek(D, F.offset, F.length);
      } catch (W) {
        if (O && O.mayBeLess && W instanceof peek_readable_1$1.EndOfStreamError)
          return 0;
        throw W;
      }
      if (!F.mayBeLess && U < F.length)
        throw new peek_readable_1$1.EndOfStreamError();
    }
    return U;
  }
  async ignore(D) {
    const O = Math.min(maxBufferSize, D), F = new Uint8Array(O);
    let U = 0;
    for (; U < D; ) {
      const W = D - U, B = await this.readBuffer(F, { length: Math.min(O, W) });
      if (B < 0)
        return B;
      U += B;
    }
    return U;
  }
}
ReadStreamTokenizer$1.ReadStreamTokenizer = ReadStreamTokenizer;
var BufferTokenizer$1 = {};
Object.defineProperty(BufferTokenizer$1, "__esModule", { value: !0 });
BufferTokenizer$1.BufferTokenizer = void 0;
const peek_readable_1 = lib$2, AbstractTokenizer_1 = AbstractTokenizer$1;
class BufferTokenizer extends AbstractTokenizer_1.AbstractTokenizer {
  /**
   * Construct BufferTokenizer
   * @param uint8Array - Uint8Array to tokenize
   * @param fileInfo - Pass additional file information to the tokenizer
   */
  constructor(D, O) {
    super(O), this.uint8Array = D, this.fileInfo.size = this.fileInfo.size ? this.fileInfo.size : D.length;
  }
  /**
   * Read buffer from tokenizer
   * @param uint8Array - Uint8Array to tokenize
   * @param options - Read behaviour options
   * @returns {Promise<number>}
   */
  async readBuffer(D, O) {
    if (O && O.position) {
      if (O.position < this.position)
        throw new Error("`options.position` must be equal or greater than `tokenizer.position`");
      this.position = O.position;
    }
    const F = await this.peekBuffer(D, O);
    return this.position += F, F;
  }
  /**
   * Peek (read ahead) buffer from tokenizer
   * @param uint8Array
   * @param options - Read behaviour options
   * @returns {Promise<number>}
   */
  async peekBuffer(D, O) {
    const F = this.normalizeOptions(D, O), U = Math.min(this.uint8Array.length - F.position, F.length);
    if (!F.mayBeLess && U < F.length)
      throw new peek_readable_1.EndOfStreamError();
    return D.set(this.uint8Array.subarray(F.position, F.position + U), F.offset), U;
  }
  async close() {
  }
}
BufferTokenizer$1.BufferTokenizer = BufferTokenizer;
(function(z) {
  Object.defineProperty(z, "__esModule", { value: !0 }), z.fromBuffer = z.fromStream = z.EndOfStreamError = void 0;
  const D = ReadStreamTokenizer$1, O = BufferTokenizer$1;
  var F = lib$2;
  Object.defineProperty(z, "EndOfStreamError", { enumerable: !0, get: function() {
    return F.EndOfStreamError;
  } });
  function U(B, K) {
    return K = K || {}, new D.ReadStreamTokenizer(B, K);
  }
  z.fromStream = U;
  function W(B, K) {
    return new O.BufferTokenizer(B, K);
  }
  z.fromBuffer = W;
})(core$1);
var ParserFactory$1 = {}, lib$1 = {}, ieee754 = {};
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
ieee754.read = function(z, D, O, F, U) {
  var W, B, K = U * 8 - F - 1, X = (1 << K) - 1, Y = X >> 1, Q = -7, J = O ? U - 1 : 0, ee = O ? -1 : 1, ae = z[D + J];
  for (J += ee, W = ae & (1 << -Q) - 1, ae >>= -Q, Q += K; Q > 0; W = W * 256 + z[D + J], J += ee, Q -= 8)
    ;
  for (B = W & (1 << -Q) - 1, W >>= -Q, Q += F; Q > 0; B = B * 256 + z[D + J], J += ee, Q -= 8)
    ;
  if (W === 0)
    W = 1 - Y;
  else {
    if (W === X)
      return B ? NaN : (ae ? -1 : 1) * (1 / 0);
    B = B + Math.pow(2, F), W = W - Y;
  }
  return (ae ? -1 : 1) * B * Math.pow(2, W - F);
};
ieee754.write = function(z, D, O, F, U, W) {
  var B, K, X, Y = W * 8 - U - 1, Q = (1 << Y) - 1, J = Q >> 1, ee = U === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, ae = F ? 0 : W - 1, re = F ? 1 : -1, ie = D < 0 || D === 0 && 1 / D < 0 ? 1 : 0;
  for (D = Math.abs(D), isNaN(D) || D === 1 / 0 ? (K = isNaN(D) ? 1 : 0, B = Q) : (B = Math.floor(Math.log(D) / Math.LN2), D * (X = Math.pow(2, -B)) < 1 && (B--, X *= 2), B + J >= 1 ? D += ee / X : D += ee * Math.pow(2, 1 - J), D * X >= 2 && (B++, X /= 2), B + J >= Q ? (K = 0, B = Q) : B + J >= 1 ? (K = (D * X - 1) * Math.pow(2, U), B = B + J) : (K = D * Math.pow(2, J - 1) * Math.pow(2, U), B = 0)); U >= 8; z[O + ae] = K & 255, ae += re, K /= 256, U -= 8)
    ;
  for (B = B << U | K, Y += U; Y > 0; z[O + ae] = B & 255, ae += re, B /= 256, Y -= 8)
    ;
  z[O + ae - re] |= ie * 128;
};
(function(z) {
  Object.defineProperty(z, "__esModule", { value: !0 }), z.AnsiStringType = z.StringType = z.BufferType = z.Uint8ArrayType = z.IgnoreType = z.Float80_LE = z.Float80_BE = z.Float64_LE = z.Float64_BE = z.Float32_LE = z.Float32_BE = z.Float16_LE = z.Float16_BE = z.INT64_BE = z.UINT64_BE = z.INT64_LE = z.UINT64_LE = z.INT32_LE = z.INT32_BE = z.INT24_BE = z.INT24_LE = z.INT16_LE = z.INT16_BE = z.INT8 = z.UINT32_BE = z.UINT32_LE = z.UINT24_BE = z.UINT24_LE = z.UINT16_BE = z.UINT16_LE = z.UINT8 = void 0;
  const D = ieee754;
  function O(X) {
    return new DataView(X.buffer, X.byteOffset);
  }
  z.UINT8 = {
    len: 1,
    get(X, Y) {
      return O(X).getUint8(Y);
    },
    put(X, Y, Q) {
      return O(X).setUint8(Y, Q), Y + 1;
    }
  }, z.UINT16_LE = {
    len: 2,
    get(X, Y) {
      return O(X).getUint16(Y, !0);
    },
    put(X, Y, Q) {
      return O(X).setUint16(Y, Q, !0), Y + 2;
    }
  }, z.UINT16_BE = {
    len: 2,
    get(X, Y) {
      return O(X).getUint16(Y);
    },
    put(X, Y, Q) {
      return O(X).setUint16(Y, Q), Y + 2;
    }
  }, z.UINT24_LE = {
    len: 3,
    get(X, Y) {
      const Q = O(X);
      return Q.getUint8(Y) + (Q.getUint16(Y + 1, !0) << 8);
    },
    put(X, Y, Q) {
      const J = O(X);
      return J.setUint8(Y, Q & 255), J.setUint16(Y + 1, Q >> 8, !0), Y + 3;
    }
  }, z.UINT24_BE = {
    len: 3,
    get(X, Y) {
      const Q = O(X);
      return (Q.getUint16(Y) << 8) + Q.getUint8(Y + 2);
    },
    put(X, Y, Q) {
      const J = O(X);
      return J.setUint16(Y, Q >> 8), J.setUint8(Y + 2, Q & 255), Y + 3;
    }
  }, z.UINT32_LE = {
    len: 4,
    get(X, Y) {
      return O(X).getUint32(Y, !0);
    },
    put(X, Y, Q) {
      return O(X).setUint32(Y, Q, !0), Y + 4;
    }
  }, z.UINT32_BE = {
    len: 4,
    get(X, Y) {
      return O(X).getUint32(Y);
    },
    put(X, Y, Q) {
      return O(X).setUint32(Y, Q), Y + 4;
    }
  }, z.INT8 = {
    len: 1,
    get(X, Y) {
      return O(X).getInt8(Y);
    },
    put(X, Y, Q) {
      return O(X).setInt8(Y, Q), Y + 1;
    }
  }, z.INT16_BE = {
    len: 2,
    get(X, Y) {
      return O(X).getInt16(Y);
    },
    put(X, Y, Q) {
      return O(X).setInt16(Y, Q), Y + 2;
    }
  }, z.INT16_LE = {
    len: 2,
    get(X, Y) {
      return O(X).getInt16(Y, !0);
    },
    put(X, Y, Q) {
      return O(X).setInt16(Y, Q, !0), Y + 2;
    }
  }, z.INT24_LE = {
    len: 3,
    get(X, Y) {
      const Q = z.UINT24_LE.get(X, Y);
      return Q > 8388607 ? Q - 16777216 : Q;
    },
    put(X, Y, Q) {
      const J = O(X);
      return J.setUint8(Y, Q & 255), J.setUint16(Y + 1, Q >> 8, !0), Y + 3;
    }
  }, z.INT24_BE = {
    len: 3,
    get(X, Y) {
      const Q = z.UINT24_BE.get(X, Y);
      return Q > 8388607 ? Q - 16777216 : Q;
    },
    put(X, Y, Q) {
      const J = O(X);
      return J.setUint16(Y, Q >> 8), J.setUint8(Y + 2, Q & 255), Y + 3;
    }
  }, z.INT32_BE = {
    len: 4,
    get(X, Y) {
      return O(X).getInt32(Y);
    },
    put(X, Y, Q) {
      return O(X).setInt32(Y, Q), Y + 4;
    }
  }, z.INT32_LE = {
    len: 4,
    get(X, Y) {
      return O(X).getInt32(Y, !0);
    },
    put(X, Y, Q) {
      return O(X).setInt32(Y, Q, !0), Y + 4;
    }
  }, z.UINT64_LE = {
    len: 8,
    get(X, Y) {
      return O(X).getBigUint64(Y, !0);
    },
    put(X, Y, Q) {
      return O(X).setBigUint64(Y, Q, !0), Y + 8;
    }
  }, z.INT64_LE = {
    len: 8,
    get(X, Y) {
      return O(X).getBigInt64(Y, !0);
    },
    put(X, Y, Q) {
      return O(X).setBigInt64(Y, Q, !0), Y + 8;
    }
  }, z.UINT64_BE = {
    len: 8,
    get(X, Y) {
      return O(X).getBigUint64(Y);
    },
    put(X, Y, Q) {
      return O(X).setBigUint64(Y, Q), Y + 8;
    }
  }, z.INT64_BE = {
    len: 8,
    get(X, Y) {
      return O(X).getBigInt64(Y);
    },
    put(X, Y, Q) {
      return O(X).setBigInt64(Y, Q), Y + 8;
    }
  }, z.Float16_BE = {
    len: 2,
    get(X, Y) {
      return D.read(X, Y, !1, 10, this.len);
    },
    put(X, Y, Q) {
      return D.write(X, Q, Y, !1, 10, this.len), Y + this.len;
    }
  }, z.Float16_LE = {
    len: 2,
    get(X, Y) {
      return D.read(X, Y, !0, 10, this.len);
    },
    put(X, Y, Q) {
      return D.write(X, Q, Y, !0, 10, this.len), Y + this.len;
    }
  }, z.Float32_BE = {
    len: 4,
    get(X, Y) {
      return O(X).getFloat32(Y);
    },
    put(X, Y, Q) {
      return O(X).setFloat32(Y, Q), Y + 4;
    }
  }, z.Float32_LE = {
    len: 4,
    get(X, Y) {
      return O(X).getFloat32(Y, !0);
    },
    put(X, Y, Q) {
      return O(X).setFloat32(Y, Q, !0), Y + 4;
    }
  }, z.Float64_BE = {
    len: 8,
    get(X, Y) {
      return O(X).getFloat64(Y);
    },
    put(X, Y, Q) {
      return O(X).setFloat64(Y, Q), Y + 8;
    }
  }, z.Float64_LE = {
    len: 8,
    get(X, Y) {
      return O(X).getFloat64(Y, !0);
    },
    put(X, Y, Q) {
      return O(X).setFloat64(Y, Q, !0), Y + 8;
    }
  }, z.Float80_BE = {
    len: 10,
    get(X, Y) {
      return D.read(X, Y, !1, 63, this.len);
    },
    put(X, Y, Q) {
      return D.write(X, Q, Y, !1, 63, this.len), Y + this.len;
    }
  }, z.Float80_LE = {
    len: 10,
    get(X, Y) {
      return D.read(X, Y, !0, 63, this.len);
    },
    put(X, Y, Q) {
      return D.write(X, Q, Y, !0, 63, this.len), Y + this.len;
    }
  };
  class F {
    /**
     * @param len number of bytes to ignore
     */
    constructor(Y) {
      this.len = Y;
    }
    // ToDo: don't read, but skip data
    get(Y, Q) {
    }
  }
  z.IgnoreType = F;
  class U {
    constructor(Y) {
      this.len = Y;
    }
    get(Y, Q) {
      return Y.subarray(Q, Q + this.len);
    }
  }
  z.Uint8ArrayType = U;
  class W {
    constructor(Y) {
      this.len = Y;
    }
    get(Y, Q) {
      return Buffer.from(Y.subarray(Q, Q + this.len));
    }
  }
  z.BufferType = W;
  class B {
    constructor(Y, Q) {
      this.len = Y, this.encoding = Q;
    }
    get(Y, Q) {
      return Buffer.from(Y).toString(this.encoding, Q, Q + this.len);
    }
  }
  z.StringType = B;
  class K {
    constructor(Y) {
      this.len = Y;
    }
    static decode(Y, Q, J) {
      let ee = "";
      for (let ae = Q; ae < J; ++ae)
        ee += K.codePointToString(K.singleByteDecoder(Y[ae]));
      return ee;
    }
    static inRange(Y, Q, J) {
      return Q <= Y && Y <= J;
    }
    static codePointToString(Y) {
      return Y <= 65535 ? String.fromCharCode(Y) : (Y -= 65536, String.fromCharCode((Y >> 10) + 55296, (Y & 1023) + 56320));
    }
    static singleByteDecoder(Y) {
      if (K.inRange(Y, 0, 127))
        return Y;
      const Q = K.windows1252[Y - 128];
      if (Q === null)
        throw Error("invaliding encoding");
      return Q;
    }
    get(Y, Q = 0) {
      return K.decode(Y, Q, Q + this.len);
    }
  }
  z.AnsiStringType = K, K.windows1252 = [
    8364,
    129,
    8218,
    402,
    8222,
    8230,
    8224,
    8225,
    710,
    8240,
    352,
    8249,
    338,
    141,
    381,
    143,
    144,
    8216,
    8217,
    8220,
    8221,
    8226,
    8211,
    8212,
    732,
    8482,
    353,
    8250,
    339,
    157,
    382,
    376,
    160,
    161,
    162,
    163,
    164,
    165,
    166,
    167,
    168,
    169,
    170,
    171,
    172,
    173,
    174,
    175,
    176,
    177,
    178,
    179,
    180,
    181,
    182,
    183,
    184,
    185,
    186,
    187,
    188,
    189,
    190,
    191,
    192,
    193,
    194,
    195,
    196,
    197,
    198,
    199,
    200,
    201,
    202,
    203,
    204,
    205,
    206,
    207,
    208,
    209,
    210,
    211,
    212,
    213,
    214,
    215,
    216,
    217,
    218,
    219,
    220,
    221,
    222,
    223,
    224,
    225,
    226,
    227,
    228,
    229,
    230,
    231,
    232,
    233,
    234,
    235,
    236,
    237,
    238,
    239,
    240,
    241,
    242,
    243,
    244,
    245,
    246,
    247,
    248,
    249,
    250,
    251,
    252,
    253,
    254,
    255
  ];
})(lib$1);
var util$c = {};
util$c.stringToBytes = (z) => [...z].map((D) => D.charCodeAt(0));
util$c.tarHeaderChecksumMatches = (z, D = 0) => {
  const O = parseInt(z.toString("utf8", 148, 154).replace(/\0.*$/, "").trim(), 8);
  if (isNaN(O))
    return !1;
  let F = 8 * 32;
  for (let U = D; U < D + 148; U++)
    F += z[U];
  for (let U = D + 156; U < D + 512; U++)
    F += z[U];
  return O === F;
};
util$c.uint32SyncSafeToken = {
  get: (z, D) => z[D + 3] & 127 | z[D + 2] << 7 | z[D + 1] << 14 | z[D] << 21,
  len: 4
};
var supported$1 = {
  extensions: [
    "jpg",
    "png",
    "apng",
    "gif",
    "webp",
    "flif",
    "xcf",
    "cr2",
    "cr3",
    "orf",
    "arw",
    "dng",
    "nef",
    "rw2",
    "raf",
    "tif",
    "bmp",
    "icns",
    "jxr",
    "psd",
    "indd",
    "zip",
    "tar",
    "rar",
    "gz",
    "bz2",
    "7z",
    "dmg",
    "mp4",
    "mid",
    "mkv",
    "webm",
    "mov",
    "avi",
    "mpg",
    "mp2",
    "mp3",
    "m4a",
    "oga",
    "ogg",
    "ogv",
    "opus",
    "flac",
    "wav",
    "spx",
    "amr",
    "pdf",
    "epub",
    "exe",
    "swf",
    "rtf",
    "wasm",
    "woff",
    "woff2",
    "eot",
    "ttf",
    "otf",
    "ico",
    "flv",
    "ps",
    "xz",
    "sqlite",
    "nes",
    "crx",
    "xpi",
    "cab",
    "deb",
    "ar",
    "rpm",
    "Z",
    "lz",
    "cfb",
    "mxf",
    "mts",
    "blend",
    "bpg",
    "docx",
    "pptx",
    "xlsx",
    "3gp",
    "3g2",
    "jp2",
    "jpm",
    "jpx",
    "mj2",
    "aif",
    "qcp",
    "odt",
    "ods",
    "odp",
    "xml",
    "mobi",
    "heic",
    "cur",
    "ktx",
    "ape",
    "wv",
    "dcm",
    "ics",
    "glb",
    "pcap",
    "dsf",
    "lnk",
    "alias",
    "voc",
    "ac3",
    "m4v",
    "m4p",
    "m4b",
    "f4v",
    "f4p",
    "f4b",
    "f4a",
    "mie",
    "asf",
    "ogm",
    "ogx",
    "mpc",
    "arrow",
    "shp",
    "aac",
    "mp1",
    "it",
    "s3m",
    "xm",
    "ai",
    "skp",
    "avif",
    "eps",
    "lzh",
    "pgp",
    "asar",
    "stl",
    "chm",
    "3mf",
    "zst",
    "jxl",
    "vcf"
  ],
  mimeTypes: [
    "image/jpeg",
    "image/png",
    "image/gif",
    "image/webp",
    "image/flif",
    "image/x-xcf",
    "image/x-canon-cr2",
    "image/x-canon-cr3",
    "image/tiff",
    "image/bmp",
    "image/vnd.ms-photo",
    "image/vnd.adobe.photoshop",
    "application/x-indesign",
    "application/epub+zip",
    "application/x-xpinstall",
    "application/vnd.oasis.opendocument.text",
    "application/vnd.oasis.opendocument.spreadsheet",
    "application/vnd.oasis.opendocument.presentation",
    "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
    "application/vnd.openxmlformats-officedocument.presentationml.presentation",
    "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
    "application/zip",
    "application/x-tar",
    "application/x-rar-compressed",
    "application/gzip",
    "application/x-bzip2",
    "application/x-7z-compressed",
    "application/x-apple-diskimage",
    "application/x-apache-arrow",
    "video/mp4",
    "audio/midi",
    "video/x-matroska",
    "video/webm",
    "video/quicktime",
    "video/vnd.avi",
    "audio/vnd.wave",
    "audio/qcelp",
    "audio/x-ms-asf",
    "video/x-ms-asf",
    "application/vnd.ms-asf",
    "video/mpeg",
    "video/3gpp",
    "audio/mpeg",
    "audio/mp4",
    // RFC 4337
    "audio/opus",
    "video/ogg",
    "audio/ogg",
    "application/ogg",
    "audio/x-flac",
    "audio/ape",
    "audio/wavpack",
    "audio/amr",
    "application/pdf",
    "application/x-msdownload",
    "application/x-shockwave-flash",
    "application/rtf",
    "application/wasm",
    "font/woff",
    "font/woff2",
    "application/vnd.ms-fontobject",
    "font/ttf",
    "font/otf",
    "image/x-icon",
    "video/x-flv",
    "application/postscript",
    "application/eps",
    "application/x-xz",
    "application/x-sqlite3",
    "application/x-nintendo-nes-rom",
    "application/x-google-chrome-extension",
    "application/vnd.ms-cab-compressed",
    "application/x-deb",
    "application/x-unix-archive",
    "application/x-rpm",
    "application/x-compress",
    "application/x-lzip",
    "application/x-cfb",
    "application/x-mie",
    "application/mxf",
    "video/mp2t",
    "application/x-blender",
    "image/bpg",
    "image/jp2",
    "image/jpx",
    "image/jpm",
    "image/mj2",
    "audio/aiff",
    "application/xml",
    "application/x-mobipocket-ebook",
    "image/heif",
    "image/heif-sequence",
    "image/heic",
    "image/heic-sequence",
    "image/icns",
    "image/ktx",
    "application/dicom",
    "audio/x-musepack",
    "text/calendar",
    "text/vcard",
    "model/gltf-binary",
    "application/vnd.tcpdump.pcap",
    "audio/x-dsf",
    // Non-standard
    "application/x.ms.shortcut",
    // Invented by us
    "application/x.apple.alias",
    // Invented by us
    "audio/x-voc",
    "audio/vnd.dolby.dd-raw",
    "audio/x-m4a",
    "image/apng",
    "image/x-olympus-orf",
    "image/x-sony-arw",
    "image/x-adobe-dng",
    "image/x-nikon-nef",
    "image/x-panasonic-rw2",
    "image/x-fujifilm-raf",
    "video/x-m4v",
    "video/3gpp2",
    "application/x-esri-shape",
    "audio/aac",
    "audio/x-it",
    "audio/x-s3m",
    "audio/x-xm",
    "video/MP1S",
    "video/MP2P",
    "application/vnd.sketchup.skp",
    "image/avif",
    "application/x-lzh-compressed",
    "application/pgp-encrypted",
    "application/x-asar",
    "model/stl",
    "application/vnd.ms-htmlhelp",
    "model/3mf",
    "image/jxl",
    "application/zstd"
  ]
};
const Token$s = lib$1, strtok3$5 = core$1, {
  stringToBytes,
  tarHeaderChecksumMatches,
  uint32SyncSafeToken
} = util$c, supported = supported$1, minimumBytes = 4100;
async function fromStream(z) {
  const D = await strtok3$5.fromStream(z);
  try {
    return await fromTokenizer(D);
  } finally {
    await D.close();
  }
}
async function fromBuffer(z) {
  if (!(z instanceof Uint8Array || z instanceof ArrayBuffer || Buffer.isBuffer(z)))
    throw new TypeError(`Expected the \`input\` argument to be of type \`Uint8Array\` or \`Buffer\` or \`ArrayBuffer\`, got \`${typeof z}\``);
  const D = z instanceof Buffer ? z : Buffer.from(z);
  if (!(D && D.length > 1))
    return;
  const O = strtok3$5.fromBuffer(D);
  return fromTokenizer(O);
}
function _check(z, D, O) {
  O = {
    offset: 0,
    ...O
  };
  for (const [F, U] of D.entries())
    if (O.mask) {
      if (U !== (O.mask[F] & z[F + O.offset]))
        return !1;
    } else if (U !== z[F + O.offset])
      return !1;
  return !0;
}
async function fromTokenizer(z) {
  try {
    return _fromTokenizer(z);
  } catch (D) {
    if (!(D instanceof strtok3$5.EndOfStreamError))
      throw D;
  }
}
async function _fromTokenizer(z) {
  let D = Buffer.alloc(minimumBytes);
  const O = 12, F = (W, B) => _check(D, W, B), U = (W, B) => F(stringToBytes(W), B);
  if (z.fileInfo.size || (z.fileInfo.size = Number.MAX_SAFE_INTEGER), await z.peekBuffer(D, { length: O, mayBeLess: !0 }), F([66, 77]))
    return {
      ext: "bmp",
      mime: "image/bmp"
    };
  if (F([11, 119]))
    return {
      ext: "ac3",
      mime: "audio/vnd.dolby.dd-raw"
    };
  if (F([120, 1]))
    return {
      ext: "dmg",
      mime: "application/x-apple-diskimage"
    };
  if (F([77, 90]))
    return {
      ext: "exe",
      mime: "application/x-msdownload"
    };
  if (F([37, 33]))
    return await z.peekBuffer(D, { length: 24, mayBeLess: !0 }), U("PS-Adobe-", { offset: 2 }) && U(" EPSF-", { offset: 14 }) ? {
      ext: "eps",
      mime: "application/eps"
    } : {
      ext: "ps",
      mime: "application/postscript"
    };
  if (F([31, 160]) || F([31, 157]))
    return {
      ext: "Z",
      mime: "application/x-compress"
    };
  if (F([255, 216, 255]))
    return {
      ext: "jpg",
      mime: "image/jpeg"
    };
  if (F([73, 73, 188]))
    return {
      ext: "jxr",
      mime: "image/vnd.ms-photo"
    };
  if (F([31, 139, 8]))
    return {
      ext: "gz",
      mime: "application/gzip"
    };
  if (F([66, 90, 104]))
    return {
      ext: "bz2",
      mime: "application/x-bzip2"
    };
  if (U("ID3")) {
    await z.ignore(6);
    const W = await z.readToken(uint32SyncSafeToken);
    return z.position + W > z.fileInfo.size ? {
      ext: "mp3",
      mime: "audio/mpeg"
    } : (await z.ignore(W), fromTokenizer(z));
  }
  if (U("MP+"))
    return {
      ext: "mpc",
      mime: "audio/x-musepack"
    };
  if ((D[0] === 67 || D[0] === 70) && F([87, 83], { offset: 1 }))
    return {
      ext: "swf",
      mime: "application/x-shockwave-flash"
    };
  if (F([71, 73, 70]))
    return {
      ext: "gif",
      mime: "image/gif"
    };
  if (U("FLIF"))
    return {
      ext: "flif",
      mime: "image/flif"
    };
  if (U("8BPS"))
    return {
      ext: "psd",
      mime: "image/vnd.adobe.photoshop"
    };
  if (U("WEBP", { offset: 8 }))
    return {
      ext: "webp",
      mime: "image/webp"
    };
  if (U("MPCK"))
    return {
      ext: "mpc",
      mime: "audio/x-musepack"
    };
  if (U("FORM"))
    return {
      ext: "aif",
      mime: "audio/aiff"
    };
  if (U("icns", { offset: 0 }))
    return {
      ext: "icns",
      mime: "image/icns"
    };
  if (F([80, 75, 3, 4])) {
    try {
      for (; z.position + 30 < z.fileInfo.size; ) {
        await z.readBuffer(D, { length: 30 });
        const W = {
          compressedSize: D.readUInt32LE(18),
          uncompressedSize: D.readUInt32LE(22),
          filenameLength: D.readUInt16LE(26),
          extraFieldLength: D.readUInt16LE(28)
        };
        if (W.filename = await z.readToken(new Token$s.StringType(W.filenameLength, "utf-8")), await z.ignore(W.extraFieldLength), W.filename === "META-INF/mozilla.rsa")
          return {
            ext: "xpi",
            mime: "application/x-xpinstall"
          };
        if (W.filename.endsWith(".rels") || W.filename.endsWith(".xml"))
          switch (W.filename.split("/")[0]) {
            case "_rels":
              break;
            case "word":
              return {
                ext: "docx",
                mime: "application/vnd.openxmlformats-officedocument.wordprocessingml.document"
              };
            case "ppt":
              return {
                ext: "pptx",
                mime: "application/vnd.openxmlformats-officedocument.presentationml.presentation"
              };
            case "xl":
              return {
                ext: "xlsx",
                mime: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
              };
            default:
              break;
          }
        if (W.filename.startsWith("xl/"))
          return {
            ext: "xlsx",
            mime: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
          };
        if (W.filename.startsWith("3D/") && W.filename.endsWith(".model"))
          return {
            ext: "3mf",
            mime: "model/3mf"
          };
        if (W.filename === "mimetype" && W.compressedSize === W.uncompressedSize)
          switch (await z.readToken(new Token$s.StringType(W.compressedSize, "utf-8"))) {
            case "application/epub+zip":
              return {
                ext: "epub",
                mime: "application/epub+zip"
              };
            case "application/vnd.oasis.opendocument.text":
              return {
                ext: "odt",
                mime: "application/vnd.oasis.opendocument.text"
              };
            case "application/vnd.oasis.opendocument.spreadsheet":
              return {
                ext: "ods",
                mime: "application/vnd.oasis.opendocument.spreadsheet"
              };
            case "application/vnd.oasis.opendocument.presentation":
              return {
                ext: "odp",
                mime: "application/vnd.oasis.opendocument.presentation"
              };
            default:
          }
        if (W.compressedSize === 0) {
          let B = -1;
          for (; B < 0 && z.position < z.fileInfo.size; )
            await z.peekBuffer(D, { mayBeLess: !0 }), B = D.indexOf("504B0304", 0, "hex"), await z.ignore(B >= 0 ? B : D.length);
        } else
          await z.ignore(W.compressedSize);
      }
    } catch (W) {
      if (!(W instanceof strtok3$5.EndOfStreamError))
        throw W;
    }
    return {
      ext: "zip",
      mime: "application/zip"
    };
  }
  if (U("OggS")) {
    await z.ignore(28);
    const W = Buffer.alloc(8);
    return await z.readBuffer(W), _check(W, [79, 112, 117, 115, 72, 101, 97, 100]) ? {
      ext: "opus",
      mime: "audio/opus"
    } : _check(W, [128, 116, 104, 101, 111, 114, 97]) ? {
      ext: "ogv",
      mime: "video/ogg"
    } : _check(W, [1, 118, 105, 100, 101, 111, 0]) ? {
      ext: "ogm",
      mime: "video/ogg"
    } : _check(W, [127, 70, 76, 65, 67]) ? {
      ext: "oga",
      mime: "audio/ogg"
    } : _check(W, [83, 112, 101, 101, 120, 32, 32]) ? {
      ext: "spx",
      mime: "audio/ogg"
    } : _check(W, [1, 118, 111, 114, 98, 105, 115]) ? {
      ext: "ogg",
      mime: "audio/ogg"
    } : {
      ext: "ogx",
      mime: "application/ogg"
    };
  }
  if (F([80, 75]) && (D[2] === 3 || D[2] === 5 || D[2] === 7) && (D[3] === 4 || D[3] === 6 || D[3] === 8))
    return {
      ext: "zip",
      mime: "application/zip"
    };
  if (U("ftyp", { offset: 4 }) && D[8] & 96) {
    const W = D.toString("binary", 8, 12).replace("\0", " ").trim();
    switch (W) {
      case "avif":
        return { ext: "avif", mime: "image/avif" };
      case "mif1":
        return { ext: "heic", mime: "image/heif" };
      case "msf1":
        return { ext: "heic", mime: "image/heif-sequence" };
      case "heic":
      case "heix":
        return { ext: "heic", mime: "image/heic" };
      case "hevc":
      case "hevx":
        return { ext: "heic", mime: "image/heic-sequence" };
      case "qt":
        return { ext: "mov", mime: "video/quicktime" };
      case "M4V":
      case "M4VH":
      case "M4VP":
        return { ext: "m4v", mime: "video/x-m4v" };
      case "M4P":
        return { ext: "m4p", mime: "video/mp4" };
      case "M4B":
        return { ext: "m4b", mime: "audio/mp4" };
      case "M4A":
        return { ext: "m4a", mime: "audio/x-m4a" };
      case "F4V":
        return { ext: "f4v", mime: "video/mp4" };
      case "F4P":
        return { ext: "f4p", mime: "video/mp4" };
      case "F4A":
        return { ext: "f4a", mime: "audio/mp4" };
      case "F4B":
        return { ext: "f4b", mime: "audio/mp4" };
      case "crx":
        return { ext: "cr3", mime: "image/x-canon-cr3" };
      default:
        return W.startsWith("3g") ? W.startsWith("3g2") ? { ext: "3g2", mime: "video/3gpp2" } : { ext: "3gp", mime: "video/3gpp" } : { ext: "mp4", mime: "video/mp4" };
    }
  }
  if (U("MThd"))
    return {
      ext: "mid",
      mime: "audio/midi"
    };
  if (U("wOFF") && (F([0, 1, 0, 0], { offset: 4 }) || U("OTTO", { offset: 4 })))
    return {
      ext: "woff",
      mime: "font/woff"
    };
  if (U("wOF2") && (F([0, 1, 0, 0], { offset: 4 }) || U("OTTO", { offset: 4 })))
    return {
      ext: "woff2",
      mime: "font/woff2"
    };
  if (F([212, 195, 178, 161]) || F([161, 178, 195, 212]))
    return {
      ext: "pcap",
      mime: "application/vnd.tcpdump.pcap"
    };
  if (U("DSD "))
    return {
      ext: "dsf",
      mime: "audio/x-dsf"
      // Non-standard
    };
  if (U("LZIP"))
    return {
      ext: "lz",
      mime: "application/x-lzip"
    };
  if (U("fLaC"))
    return {
      ext: "flac",
      mime: "audio/x-flac"
    };
  if (F([66, 80, 71, 251]))
    return {
      ext: "bpg",
      mime: "image/bpg"
    };
  if (U("wvpk"))
    return {
      ext: "wv",
      mime: "audio/wavpack"
    };
  if (U("%PDF")) {
    await z.ignore(1350);
    const W = 10 * 1024 * 1024, B = Buffer.alloc(Math.min(W, z.fileInfo.size));
    return await z.readBuffer(B, { mayBeLess: !0 }), B.includes(Buffer.from("AIPrivateData")) ? {
      ext: "ai",
      mime: "application/postscript"
    } : {
      ext: "pdf",
      mime: "application/pdf"
    };
  }
  if (F([0, 97, 115, 109]))
    return {
      ext: "wasm",
      mime: "application/wasm"
    };
  if (F([73, 73, 42, 0]))
    return U("CR", { offset: 8 }) ? {
      ext: "cr2",
      mime: "image/x-canon-cr2"
    } : F([28, 0, 254, 0], { offset: 8 }) || F([31, 0, 11, 0], { offset: 8 }) ? {
      ext: "nef",
      mime: "image/x-nikon-nef"
    } : F([8, 0, 0, 0], { offset: 4 }) && (F([45, 0, 254, 0], { offset: 8 }) || F([39, 0, 254, 0], { offset: 8 })) ? {
      ext: "dng",
      mime: "image/x-adobe-dng"
    } : (D = Buffer.alloc(24), await z.peekBuffer(D), (F([16, 251, 134, 1], { offset: 4 }) || F([8, 0, 0, 0], { offset: 4 })) && // This pattern differentiates ARW from other TIFF-ish file types:
    F([0, 254, 0, 4, 0, 1, 0, 0, 0, 1, 0, 0, 0, 3, 1], { offset: 9 }) ? {
      ext: "arw",
      mime: "image/x-sony-arw"
    } : {
      ext: "tif",
      mime: "image/tiff"
    });
  if (F([77, 77, 0, 42]))
    return {
      ext: "tif",
      mime: "image/tiff"
    };
  if (U("MAC "))
    return {
      ext: "ape",
      mime: "audio/ape"
    };
  if (F([26, 69, 223, 163])) {
    async function W() {
      const Q = await z.peekNumber(Token$s.UINT8);
      let J = 128, ee = 0;
      for (; !(Q & J) && J !== 0; )
        ++ee, J >>= 1;
      const ae = Buffer.alloc(ee + 1);
      return await z.readBuffer(ae), ae;
    }
    async function B() {
      const Q = await W(), J = await W();
      J[0] ^= 128 >> J.length - 1;
      const ee = Math.min(6, J.length);
      return {
        id: Q.readUIntBE(0, Q.length),
        len: J.readUIntBE(J.length - ee, ee)
      };
    }
    async function K(Q, J) {
      for (; J > 0; ) {
        const ee = await B();
        if (ee.id === 17026)
          return z.readToken(new Token$s.StringType(ee.len, "utf-8"));
        await z.ignore(ee.len), --J;
      }
    }
    const X = await B();
    switch (await K(1, X.len)) {
      case "webm":
        return {
          ext: "webm",
          mime: "video/webm"
        };
      case "matroska":
        return {
          ext: "mkv",
          mime: "video/x-matroska"
        };
      default:
        return;
    }
  }
  if (F([82, 73, 70, 70])) {
    if (F([65, 86, 73], { offset: 8 }))
      return {
        ext: "avi",
        mime: "video/vnd.avi"
      };
    if (F([87, 65, 86, 69], { offset: 8 }))
      return {
        ext: "wav",
        mime: "audio/vnd.wave"
      };
    if (F([81, 76, 67, 77], { offset: 8 }))
      return {
        ext: "qcp",
        mime: "audio/qcelp"
      };
  }
  if (U("SQLi"))
    return {
      ext: "sqlite",
      mime: "application/x-sqlite3"
    };
  if (F([78, 69, 83, 26]))
    return {
      ext: "nes",
      mime: "application/x-nintendo-nes-rom"
    };
  if (U("Cr24"))
    return {
      ext: "crx",
      mime: "application/x-google-chrome-extension"
    };
  if (U("MSCF") || U("ISc("))
    return {
      ext: "cab",
      mime: "application/vnd.ms-cab-compressed"
    };
  if (F([237, 171, 238, 219]))
    return {
      ext: "rpm",
      mime: "application/x-rpm"
    };
  if (F([197, 208, 211, 198]))
    return {
      ext: "eps",
      mime: "application/eps"
    };
  if (F([40, 181, 47, 253]))
    return {
      ext: "zst",
      mime: "application/zstd"
    };
  if (F([79, 84, 84, 79, 0]))
    return {
      ext: "otf",
      mime: "font/otf"
    };
  if (U("#!AMR"))
    return {
      ext: "amr",
      mime: "audio/amr"
    };
  if (U("{\\rtf"))
    return {
      ext: "rtf",
      mime: "application/rtf"
    };
  if (F([70, 76, 86, 1]))
    return {
      ext: "flv",
      mime: "video/x-flv"
    };
  if (U("IMPM"))
    return {
      ext: "it",
      mime: "audio/x-it"
    };
  if (U("-lh0-", { offset: 2 }) || U("-lh1-", { offset: 2 }) || U("-lh2-", { offset: 2 }) || U("-lh3-", { offset: 2 }) || U("-lh4-", { offset: 2 }) || U("-lh5-", { offset: 2 }) || U("-lh6-", { offset: 2 }) || U("-lh7-", { offset: 2 }) || U("-lzs-", { offset: 2 }) || U("-lz4-", { offset: 2 }) || U("-lz5-", { offset: 2 }) || U("-lhd-", { offset: 2 }))
    return {
      ext: "lzh",
      mime: "application/x-lzh-compressed"
    };
  if (F([0, 0, 1, 186])) {
    if (F([33], { offset: 4, mask: [241] }))
      return {
        ext: "mpg",
        // May also be .ps, .mpeg
        mime: "video/MP1S"
      };
    if (F([68], { offset: 4, mask: [196] }))
      return {
        ext: "mpg",
        // May also be .mpg, .m2p, .vob or .sub
        mime: "video/MP2P"
      };
  }
  if (U("ITSF"))
    return {
      ext: "chm",
      mime: "application/vnd.ms-htmlhelp"
    };
  if (F([253, 55, 122, 88, 90, 0]))
    return {
      ext: "xz",
      mime: "application/x-xz"
    };
  if (U("<?xml "))
    return {
      ext: "xml",
      mime: "application/xml"
    };
  if (F([55, 122, 188, 175, 39, 28]))
    return {
      ext: "7z",
      mime: "application/x-7z-compressed"
    };
  if (F([82, 97, 114, 33, 26, 7]) && (D[6] === 0 || D[6] === 1))
    return {
      ext: "rar",
      mime: "application/x-rar-compressed"
    };
  if (U("solid "))
    return {
      ext: "stl",
      mime: "model/stl"
    };
  if (U("BLENDER"))
    return {
      ext: "blend",
      mime: "application/x-blender"
    };
  if (U("!<arch>"))
    return await z.ignore(8), await z.readToken(new Token$s.StringType(13, "ascii")) === "debian-binary" ? {
      ext: "deb",
      mime: "application/x-deb"
    } : {
      ext: "ar",
      mime: "application/x-unix-archive"
    };
  if (F([137, 80, 78, 71, 13, 10, 26, 10])) {
    await z.ignore(8);
    async function W() {
      return {
        length: await z.readToken(Token$s.INT32_BE),
        type: await z.readToken(new Token$s.StringType(4, "binary"))
      };
    }
    do {
      const B = await W();
      if (B.length < 0)
        return;
      switch (B.type) {
        case "IDAT":
          return {
            ext: "png",
            mime: "image/png"
          };
        case "acTL":
          return {
            ext: "apng",
            mime: "image/apng"
          };
        default:
          await z.ignore(B.length + 4);
      }
    } while (z.position + 8 < z.fileInfo.size);
    return {
      ext: "png",
      mime: "image/png"
    };
  }
  if (F([65, 82, 82, 79, 87, 49, 0, 0]))
    return {
      ext: "arrow",
      mime: "application/x-apache-arrow"
    };
  if (F([103, 108, 84, 70, 2, 0, 0, 0]))
    return {
      ext: "glb",
      mime: "model/gltf-binary"
    };
  if (F([102, 114, 101, 101], { offset: 4 }) || // `free`
  F([109, 100, 97, 116], { offset: 4 }) || // `mdat` MJPEG
  F([109, 111, 111, 118], { offset: 4 }) || // `moov`
  F([119, 105, 100, 101], { offset: 4 }))
    return {
      ext: "mov",
      mime: "video/quicktime"
    };
  if (F([73, 73, 82, 79, 8, 0, 0, 0, 24]))
    return {
      ext: "orf",
      mime: "image/x-olympus-orf"
    };
  if (U("gimp xcf "))
    return {
      ext: "xcf",
      mime: "image/x-xcf"
    };
  if (F([73, 73, 85, 0, 24, 0, 0, 0, 136, 231, 116, 216]))
    return {
      ext: "rw2",
      mime: "image/x-panasonic-rw2"
    };
  if (F([48, 38, 178, 117, 142, 102, 207, 17, 166, 217])) {
    async function W() {
      const B = Buffer.alloc(16);
      return await z.readBuffer(B), {
        id: B,
        size: Number(await z.readToken(Token$s.UINT64_LE))
      };
    }
    for (await z.ignore(30); z.position + 24 < z.fileInfo.size; ) {
      const B = await W();
      let K = B.size - 24;
      if (_check(B.id, [145, 7, 220, 183, 183, 169, 207, 17, 142, 230, 0, 192, 12, 32, 83, 101])) {
        const X = Buffer.alloc(16);
        if (K -= await z.readBuffer(X), _check(X, [64, 158, 105, 248, 77, 91, 207, 17, 168, 253, 0, 128, 95, 92, 68, 43]))
          return {
            ext: "asf",
            mime: "audio/x-ms-asf"
          };
        if (_check(X, [192, 239, 25, 188, 77, 91, 207, 17, 168, 253, 0, 128, 95, 92, 68, 43]))
          return {
            ext: "asf",
            mime: "video/x-ms-asf"
          };
        break;
      }
      await z.ignore(K);
    }
    return {
      ext: "asf",
      mime: "application/vnd.ms-asf"
    };
  }
  if (F([171, 75, 84, 88, 32, 49, 49, 187, 13, 10, 26, 10]))
    return {
      ext: "ktx",
      mime: "image/ktx"
    };
  if ((F([126, 16, 4]) || F([126, 24, 4])) && F([48, 77, 73, 69], { offset: 4 }))
    return {
      ext: "mie",
      mime: "application/x-mie"
    };
  if (F([39, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], { offset: 2 }))
    return {
      ext: "shp",
      mime: "application/x-esri-shape"
    };
  if (F([0, 0, 0, 12, 106, 80, 32, 32, 13, 10, 135, 10]))
    switch (await z.ignore(20), await z.readToken(new Token$s.StringType(4, "ascii"))) {
      case "jp2 ":
        return {
          ext: "jp2",
          mime: "image/jp2"
        };
      case "jpx ":
        return {
          ext: "jpx",
          mime: "image/jpx"
        };
      case "jpm ":
        return {
          ext: "jpm",
          mime: "image/jpm"
        };
      case "mjp2":
        return {
          ext: "mj2",
          mime: "image/mj2"
        };
      default:
        return;
    }
  if (F([255, 10]) || F([0, 0, 0, 12, 74, 88, 76, 32, 13, 10, 135, 10]))
    return {
      ext: "jxl",
      mime: "image/jxl"
    };
  if (F([0, 0, 1, 186]) || F([0, 0, 1, 179]))
    return {
      ext: "mpg",
      mime: "video/mpeg"
    };
  if (F([0, 1, 0, 0, 0]))
    return {
      ext: "ttf",
      mime: "font/ttf"
    };
  if (F([0, 0, 1, 0]))
    return {
      ext: "ico",
      mime: "image/x-icon"
    };
  if (F([0, 0, 2, 0]))
    return {
      ext: "cur",
      mime: "image/x-icon"
    };
  if (F([208, 207, 17, 224, 161, 177, 26, 225]))
    return {
      ext: "cfb",
      mime: "application/x-cfb"
    };
  if (await z.peekBuffer(D, { length: Math.min(256, z.fileInfo.size), mayBeLess: !0 }), U("BEGIN:")) {
    if (U("VCARD", { offset: 6 }))
      return {
        ext: "vcf",
        mime: "text/vcard"
      };
    if (U("VCALENDAR", { offset: 6 }))
      return {
        ext: "ics",
        mime: "text/calendar"
      };
  }
  if (U("FUJIFILMCCD-RAW"))
    return {
      ext: "raf",
      mime: "image/x-fujifilm-raf"
    };
  if (U("Extended Module:"))
    return {
      ext: "xm",
      mime: "audio/x-xm"
    };
  if (U("Creative Voice File"))
    return {
      ext: "voc",
      mime: "audio/x-voc"
    };
  if (F([4, 0, 0, 0]) && D.length >= 16) {
    const W = D.readUInt32LE(12);
    if (W > 12 && D.length >= W + 16)
      try {
        const B = D.slice(16, W + 16).toString();
        if (JSON.parse(B).files)
          return {
            ext: "asar",
            mime: "application/x-asar"
          };
      } catch {
      }
  }
  if (F([6, 14, 43, 52, 2, 5, 1, 1, 13, 1, 2, 1, 1, 2]))
    return {
      ext: "mxf",
      mime: "application/mxf"
    };
  if (U("SCRM", { offset: 44 }))
    return {
      ext: "s3m",
      mime: "audio/x-s3m"
    };
  if (F([71], { offset: 4 }) && (F([71], { offset: 192 }) || F([71], { offset: 196 })))
    return {
      ext: "mts",
      mime: "video/mp2t"
    };
  if (F([66, 79, 79, 75, 77, 79, 66, 73], { offset: 60 }))
    return {
      ext: "mobi",
      mime: "application/x-mobipocket-ebook"
    };
  if (F([68, 73, 67, 77], { offset: 128 }))
    return {
      ext: "dcm",
      mime: "application/dicom"
    };
  if (F([76, 0, 0, 0, 1, 20, 2, 0, 0, 0, 0, 0, 192, 0, 0, 0, 0, 0, 0, 70]))
    return {
      ext: "lnk",
      mime: "application/x.ms.shortcut"
      // Invented by us
    };
  if (F([98, 111, 111, 107, 0, 0, 0, 0, 109, 97, 114, 107, 0, 0, 0, 0]))
    return {
      ext: "alias",
      mime: "application/x.apple.alias"
      // Invented by us
    };
  if (F([76, 80], { offset: 34 }) && (F([0, 0, 1], { offset: 8 }) || F([1, 0, 2], { offset: 8 }) || F([2, 0, 2], { offset: 8 })))
    return {
      ext: "eot",
      mime: "application/vnd.ms-fontobject"
    };
  if (F([6, 6, 237, 245, 216, 29, 70, 229, 189, 49, 239, 231, 254, 116, 183, 29]))
    return {
      ext: "indd",
      mime: "application/x-indesign"
    };
  if (await z.peekBuffer(D, { length: Math.min(512, z.fileInfo.size), mayBeLess: !0 }), tarHeaderChecksumMatches(D))
    return {
      ext: "tar",
      mime: "application/x-tar"
    };
  if (F([255, 254, 255, 14, 83, 0, 107, 0, 101, 0, 116, 0, 99, 0, 104, 0, 85, 0, 112, 0, 32, 0, 77, 0, 111, 0, 100, 0, 101, 0, 108, 0]))
    return {
      ext: "skp",
      mime: "application/vnd.sketchup.skp"
    };
  if (U("-----BEGIN PGP MESSAGE-----"))
    return {
      ext: "pgp",
      mime: "application/pgp-encrypted"
    };
  if (D.length >= 2 && F([255, 224], { offset: 0, mask: [255, 224] })) {
    if (F([16], { offset: 1, mask: [22] }))
      return F([8], { offset: 1, mask: [8] }) ? {
        ext: "aac",
        mime: "audio/aac"
      } : {
        ext: "aac",
        mime: "audio/aac"
      };
    if (F([2], { offset: 1, mask: [6] }))
      return {
        ext: "mp3",
        mime: "audio/mpeg"
      };
    if (F([4], { offset: 1, mask: [6] }))
      return {
        ext: "mp2",
        mime: "audio/mpeg"
      };
    if (F([6], { offset: 1, mask: [6] }))
      return {
        ext: "mp1",
        mime: "audio/mpeg"
      };
  }
}
const stream = (readableStream) => new Promise((resolve, reject) => {
  const stream = eval("require")("stream");
  readableStream.on("error", reject), readableStream.once("readable", async () => {
    const z = new stream.PassThrough();
    let D;
    stream.pipeline ? D = stream.pipeline(readableStream, z, () => {
    }) : D = readableStream.pipe(z);
    const O = readableStream.read(minimumBytes) || readableStream.read() || Buffer.alloc(0);
    try {
      const F = await fromBuffer(O);
      z.fileType = F;
    } catch (F) {
      reject(F);
    }
    resolve(D);
  });
}), fileType = {
  fromStream,
  fromTokenizer,
  fromBuffer,
  stream
};
Object.defineProperty(fileType, "extensions", {
  get() {
    return new Set(supported.extensions);
  }
});
Object.defineProperty(fileType, "mimeTypes", {
  get() {
    return new Set(supported.mimeTypes);
  }
});
var core = fileType, contentType = {};
/*!
 * content-type
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var PARAM_REGEXP = /; *([!#$%&'*+.^_`|~0-9A-Za-z-]+) *= *("(?:[\u000b\u0020\u0021\u0023-\u005b\u005d-\u007e\u0080-\u00ff]|\\[\u000b\u0020-\u00ff])*"|[!#$%&'*+.^_`|~0-9A-Za-z-]+) */g, TEXT_REGEXP = /^[\u000b\u0020-\u007e\u0080-\u00ff]+$/, TOKEN_REGEXP = /^[!#$%&'*+.^_`|~0-9A-Za-z-]+$/, QESC_REGEXP = /\\([\u000b\u0020-\u00ff])/g, QUOTE_REGEXP = /([\\"])/g, TYPE_REGEXP$1 = /^[!#$%&'*+.^_`|~0-9A-Za-z-]+\/[!#$%&'*+.^_`|~0-9A-Za-z-]+$/;
contentType.format = format$1;
contentType.parse = parse$2;
function format$1(z) {
  if (!z || typeof z != "object")
    throw new TypeError("argument obj is required");
  var D = z.parameters, O = z.type;
  if (!O || !TYPE_REGEXP$1.test(O))
    throw new TypeError("invalid type");
  var F = O;
  if (D && typeof D == "object")
    for (var U, W = Object.keys(D).sort(), B = 0; B < W.length; B++) {
      if (U = W[B], !TOKEN_REGEXP.test(U))
        throw new TypeError("invalid parameter name");
      F += "; " + U + "=" + qstring(D[U]);
    }
  return F;
}
function parse$2(z) {
  if (!z)
    throw new TypeError("argument string is required");
  var D = typeof z == "object" ? getcontenttype(z) : z;
  if (typeof D != "string")
    throw new TypeError("argument string is required to be a string");
  var O = D.indexOf(";"), F = O !== -1 ? D.slice(0, O).trim() : D.trim();
  if (!TYPE_REGEXP$1.test(F))
    throw new TypeError("invalid media type");
  var U = new ContentType$1(F.toLowerCase());
  if (O !== -1) {
    var W, B, K;
    for (PARAM_REGEXP.lastIndex = O; B = PARAM_REGEXP.exec(D); ) {
      if (B.index !== O)
        throw new TypeError("invalid parameter format");
      O += B[0].length, W = B[1].toLowerCase(), K = B[2], K.charCodeAt(0) === 34 && (K = K.slice(1, -1), K.indexOf("\\") !== -1 && (K = K.replace(QESC_REGEXP, "$1"))), U.parameters[W] = K;
    }
    if (O !== D.length)
      throw new TypeError("invalid parameter format");
  }
  return U;
}
function getcontenttype(z) {
  var D;
  if (typeof z.getHeader == "function" ? D = z.getHeader("content-type") : typeof z.headers == "object" && (D = z.headers && z.headers["content-type"]), typeof D != "string")
    throw new TypeError("content-type header is missing from object");
  return D;
}
function qstring(z) {
  var D = String(z);
  if (TOKEN_REGEXP.test(D))
    return D;
  if (D.length > 0 && !TEXT_REGEXP.test(D))
    throw new TypeError("invalid parameter value");
  return '"' + D.replace(QUOTE_REGEXP, "\\$1") + '"';
}
function ContentType$1(z) {
  this.parameters = /* @__PURE__ */ Object.create(null), this.type = z;
}
var mediaTyper = {};
/*!
 * media-typer
 * Copyright(c) 2014-2017 Douglas Christopher Wilson
 * MIT Licensed
 */
var SUBTYPE_NAME_REGEXP = /^[A-Za-z0-9][A-Za-z0-9!#$&^_.-]{0,126}$/, TYPE_NAME_REGEXP = /^[A-Za-z0-9][A-Za-z0-9!#$&^_-]{0,126}$/, TYPE_REGEXP = /^ *([A-Za-z0-9][A-Za-z0-9!#$&^_-]{0,126})\/([A-Za-z0-9][A-Za-z0-9!#$&^_.+-]{0,126}) *$/;
mediaTyper.format = format;
mediaTyper.parse = parse$1;
mediaTyper.test = test$1;
function format(z) {
  if (!z || typeof z != "object")
    throw new TypeError("argument obj is required");
  var D = z.subtype, O = z.suffix, F = z.type;
  if (!F || !TYPE_NAME_REGEXP.test(F))
    throw new TypeError("invalid type");
  if (!D || !SUBTYPE_NAME_REGEXP.test(D))
    throw new TypeError("invalid subtype");
  var U = F + "/" + D;
  if (O) {
    if (!TYPE_NAME_REGEXP.test(O))
      throw new TypeError("invalid suffix");
    U += "+" + O;
  }
  return U;
}
function test$1(z) {
  if (!z)
    throw new TypeError("argument string is required");
  if (typeof z != "string")
    throw new TypeError("argument string is required to be a string");
  return TYPE_REGEXP.test(z.toLowerCase());
}
function parse$1(z) {
  if (!z)
    throw new TypeError("argument string is required");
  if (typeof z != "string")
    throw new TypeError("argument string is required to be a string");
  var D = TYPE_REGEXP.exec(z.toLowerCase());
  if (!D)
    throw new TypeError("invalid media type");
  var O = D[1], F = D[2], U, W = F.lastIndexOf("+");
  return W !== -1 && (U = F.substr(W + 1), F = F.substr(0, W)), new MediaType(O, F, U);
}
function MediaType(z, D, O) {
  this.type = z, this.subtype = D, this.suffix = O;
}
var MetadataCollector$1 = {}, type$1 = {}, types$1 = {};
(function(z) {
  Object.defineProperty(z, "__esModule", { value: !0 }), z.TrackType = z.TargetType = z.DataType = void 0, function(D) {
    D[D.string = 0] = "string", D[D.uint = 1] = "uint", D[D.uid = 2] = "uid", D[D.bool = 3] = "bool", D[D.binary = 4] = "binary", D[D.float = 5] = "float";
  }(z.DataType || (z.DataType = {})), function(D) {
    D[D.shot = 10] = "shot", D[D.scene = 20] = "scene", D[D.track = 30] = "track", D[D.part = 40] = "part", D[D.album = 50] = "album", D[D.edition = 60] = "edition", D[D.collection = 70] = "collection";
  }(z.TargetType || (z.TargetType = {})), function(D) {
    D[D.video = 1] = "video", D[D.audio = 2] = "audio", D[D.complex = 3] = "complex", D[D.logo = 4] = "logo", D[D.subtitle = 17] = "subtitle", D[D.button = 18] = "button", D[D.control = 32] = "control";
  }(z.TrackType || (z.TrackType = {}));
})(types$1);
(function(z) {
  Object.defineProperty(z, "__esModule", { value: !0 }), z.TrackType = void 0;
  var D = types$1;
  Object.defineProperty(z, "TrackType", { enumerable: !0, get: function() {
    return D.TrackType;
  } });
})(type$1);
var GenericTagTypes = {};
(function(z) {
  Object.defineProperty(z, "__esModule", { value: !0 }), z.isUnique = z.isSingleton = z.commonTags = void 0, z.commonTags = {
    year: { multiple: !1 },
    track: { multiple: !1 },
    disk: { multiple: !1 },
    title: { multiple: !1 },
    artist: { multiple: !1 },
    artists: { multiple: !0, unique: !0 },
    albumartist: { multiple: !1 },
    album: { multiple: !1 },
    date: { multiple: !1 },
    originaldate: { multiple: !1 },
    originalyear: { multiple: !1 },
    comment: { multiple: !0, unique: !1 },
    genre: { multiple: !0, unique: !0 },
    picture: { multiple: !0, unique: !0 },
    composer: { multiple: !0, unique: !0 },
    lyrics: { multiple: !0, unique: !1 },
    albumsort: { multiple: !1, unique: !0 },
    titlesort: { multiple: !1, unique: !0 },
    work: { multiple: !1, unique: !0 },
    artistsort: { multiple: !1, unique: !0 },
    albumartistsort: { multiple: !1, unique: !0 },
    composersort: { multiple: !1, unique: !0 },
    lyricist: { multiple: !0, unique: !0 },
    writer: { multiple: !0, unique: !0 },
    conductor: { multiple: !0, unique: !0 },
    remixer: { multiple: !0, unique: !0 },
    arranger: { multiple: !0, unique: !0 },
    engineer: { multiple: !0, unique: !0 },
    producer: { multiple: !0, unique: !0 },
    technician: { multiple: !0, unique: !0 },
    djmixer: { multiple: !0, unique: !0 },
    mixer: { multiple: !0, unique: !0 },
    label: { multiple: !0, unique: !0 },
    grouping: { multiple: !1 },
    subtitle: { multiple: !0 },
    discsubtitle: { multiple: !1 },
    totaltracks: { multiple: !1 },
    totaldiscs: { multiple: !1 },
    compilation: { multiple: !1 },
    rating: { multiple: !0 },
    bpm: { multiple: !1 },
    mood: { multiple: !1 },
    media: { multiple: !1 },
    catalognumber: { multiple: !0, unique: !0 },
    tvShow: { multiple: !1 },
    tvShowSort: { multiple: !1 },
    tvSeason: { multiple: !1 },
    tvEpisode: { multiple: !1 },
    tvEpisodeId: { multiple: !1 },
    tvNetwork: { multiple: !1 },
    podcast: { multiple: !1 },
    podcasturl: { multiple: !1 },
    releasestatus: { multiple: !1 },
    releasetype: { multiple: !0 },
    releasecountry: { multiple: !1 },
    script: { multiple: !1 },
    language: { multiple: !1 },
    copyright: { multiple: !1 },
    license: { multiple: !1 },
    encodedby: { multiple: !1 },
    encodersettings: { multiple: !1 },
    gapless: { multiple: !1 },
    barcode: { multiple: !1 },
    isrc: { multiple: !0 },
    asin: { multiple: !1 },
    musicbrainz_recordingid: { multiple: !1 },
    musicbrainz_trackid: { multiple: !1 },
    musicbrainz_albumid: { multiple: !1 },
    musicbrainz_artistid: { multiple: !0 },
    musicbrainz_albumartistid: { multiple: !0 },
    musicbrainz_releasegroupid: { multiple: !1 },
    musicbrainz_workid: { multiple: !1 },
    musicbrainz_trmid: { multiple: !1 },
    musicbrainz_discid: { multiple: !1 },
    acoustid_id: { multiple: !1 },
    acoustid_fingerprint: { multiple: !1 },
    musicip_puid: { multiple: !1 },
    musicip_fingerprint: { multiple: !1 },
    website: { multiple: !1 },
    "performer:instrument": { multiple: !0, unique: !0 },
    averageLevel: { multiple: !1 },
    peakLevel: { multiple: !1 },
    notes: { multiple: !0, unique: !1 },
    key: { multiple: !1 },
    originalalbum: { multiple: !1 },
    originalartist: { multiple: !1 },
    discogs_artist_id: { multiple: !0, unique: !0 },
    discogs_release_id: { multiple: !1 },
    discogs_label_id: { multiple: !1 },
    discogs_master_release_id: { multiple: !1 },
    discogs_votes: { multiple: !1 },
    discogs_rating: { multiple: !1 },
    replaygain_track_peak: { multiple: !1 },
    replaygain_track_gain: { multiple: !1 },
    replaygain_album_peak: { multiple: !1 },
    replaygain_album_gain: { multiple: !1 },
    replaygain_track_minmax: { multiple: !1 },
    replaygain_album_minmax: { multiple: !1 },
    replaygain_undo: { multiple: !1 },
    description: { multiple: !0 },
    longDescription: { multiple: !1 },
    category: { multiple: !0 },
    hdVideo: { multiple: !1 },
    keywords: { multiple: !0 },
    movement: { multiple: !1 },
    movementIndex: { multiple: !1 },
    movementTotal: { multiple: !1 },
    podcastId: { multiple: !1 },
    showMovement: { multiple: !1 },
    stik: { multiple: !1 }
  };
  function D(F) {
    return z.commonTags.hasOwnProperty(F) && !z.commonTags[F].multiple;
  }
  z.isSingleton = D;
  function O(F) {
    return !z.commonTags[F].multiple || z.commonTags[F].unique;
  }
  z.isUnique = O;
})(GenericTagTypes);
var CombinedTagMapper$1 = {}, ID3v1TagMap = {}, GenericTagMapper = {};
Object.defineProperty(GenericTagMapper, "__esModule", { value: !0 });
GenericTagMapper.CommonTagMapper = void 0;
class CommonTagMapper {
  static toIntOrNull(D) {
    const O = parseInt(D, 10);
    return isNaN(O) ? null : O;
  }
  // TODO: a string of 1of1 would fail to be converted
  // converts 1/10 to no : 1, of : 10
  // or 1 to no : 1, of : 0
  static normalizeTrack(D) {
    const O = D.toString().split("/");
    return {
      no: parseInt(O[0], 10) || null,
      of: parseInt(O[1], 10) || null
    };
  }
  constructor(D, O) {
    this.tagTypes = D, this.tagMap = O;
  }
  /**
   * Process and set common tags
   * write common tags to
   * @param tag Native tag
   * @param warnings Register warnings
   * @return common name
   */
  mapGenericTag(D, O) {
    D = { id: D.id, value: D.value }, this.postMap(D, O);
    const F = this.getCommonName(D.id);
    return F ? { id: F, value: D.value } : null;
  }
  /**
   * Convert native tag key to common tag key
   * @tag  Native header tag
   * @return common tag name (alias)
   */
  getCommonName(D) {
    return this.tagMap[D];
  }
  /**
   * Handle post mapping exceptions / correction
   * @param tag Tag e.g. {"alb", "Buena Vista Social Club")
   * @param warnings Used to register warnings
   */
  postMap(D, O) {
  }
}
CommonTagMapper.maxRatingScore = 1;
GenericTagMapper.CommonTagMapper = CommonTagMapper;
Object.defineProperty(ID3v1TagMap, "__esModule", { value: !0 });
ID3v1TagMap.ID3v1TagMapper = void 0;
const GenericTagMapper_1$6 = GenericTagMapper, id3v1TagMap = {
  title: "title",
  artist: "artist",
  album: "album",
  year: "year",
  comment: "comment",
  track: "track",
  genre: "genre"
};
class ID3v1TagMapper extends GenericTagMapper_1$6.CommonTagMapper {
  constructor() {
    super(["ID3v1"], id3v1TagMap);
  }
}
ID3v1TagMap.ID3v1TagMapper = ID3v1TagMapper;
var ID3v24TagMapper$1 = {}, CaseInsensitiveTagMap$1 = {};
Object.defineProperty(CaseInsensitiveTagMap$1, "__esModule", { value: !0 });
CaseInsensitiveTagMap$1.CaseInsensitiveTagMap = void 0;
const GenericTagMapper_1$5 = GenericTagMapper;
class CaseInsensitiveTagMap extends GenericTagMapper_1$5.CommonTagMapper {
  constructor(D, O) {
    const F = {};
    for (const U of Object.keys(O))
      F[U.toUpperCase()] = O[U];
    super(D, F);
  }
  /**
   * @tag  Native header tag
   * @return common tag name (alias)
   */
  getCommonName(D) {
    return this.tagMap[D.toUpperCase()];
  }
}
CaseInsensitiveTagMap$1.CaseInsensitiveTagMap = CaseInsensitiveTagMap;
var Util = {};
Object.defineProperty(Util, "__esModule", { value: !0 });
Util.toRatio = Util.dbToRatio = Util.ratioToDb = Util.a2hex = Util.isBitSet = Util.getBitAllignedNumber = Util.stripNulls = Util.decodeString = Util.trimRightNull = Util.findZero = Util.getBit = void 0;
function getBit(z, D, O) {
  return (z[D] & 1 << O) !== 0;
}
Util.getBit = getBit;
function findZero(z, D, O, F) {
  let U = D;
  if (F === "utf16le") {
    for (; z[U] !== 0 || z[U + 1] !== 0; ) {
      if (U >= O)
        return O;
      U += 2;
    }
    return U;
  } else {
    for (; z[U] !== 0; ) {
      if (U >= O)
        return O;
      U++;
    }
    return U;
  }
}
Util.findZero = findZero;
function trimRightNull(z) {
  const D = z.indexOf("\0");
  return D === -1 ? z : z.substr(0, D);
}
Util.trimRightNull = trimRightNull;
function swapBytes(z) {
  const D = z.length;
  if (D & 1)
    throw new Error("Buffer length must be even");
  for (let O = 0; O < D; O += 2) {
    const F = z[O];
    z[O] = z[O + 1], z[O + 1] = F;
  }
  return z;
}
function decodeString(z, D) {
  if (z[0] === 255 && z[1] === 254)
    return decodeString(z.subarray(2), D);
  if (D === "utf16le" && z[0] === 254 && z[1] === 255) {
    if (z.length & 1)
      throw new Error("Expected even number of octets for 16-bit unicode string");
    return decodeString(swapBytes(z), D);
  }
  return Buffer.from(z).toString(D);
}
Util.decodeString = decodeString;
function stripNulls(z) {
  return z = z.replace(/^\x00+/g, ""), z = z.replace(/\x00+$/g, ""), z;
}
Util.stripNulls = stripNulls;
function getBitAllignedNumber(z, D, O, F) {
  const U = D + ~~(O / 8), W = O % 8;
  let B = z[U];
  B &= 255 >> W;
  const K = 8 - W, X = F - K;
  return X < 0 ? B >>= 8 - W - F : X > 0 && (B <<= X, B |= getBitAllignedNumber(z, D, O + K, X)), B;
}
Util.getBitAllignedNumber = getBitAllignedNumber;
function isBitSet(z, D, O) {
  return getBitAllignedNumber(z, D, O, 1) === 1;
}
Util.isBitSet = isBitSet;
function a2hex(z) {
  const D = [];
  for (let O = 0, F = z.length; O < F; O++) {
    const U = Number(z.charCodeAt(O)).toString(16);
    D.push(U.length === 1 ? "0" + U : U);
  }
  return D.join(" ");
}
Util.a2hex = a2hex;
function ratioToDb(z) {
  return 10 * Math.log10(z);
}
Util.ratioToDb = ratioToDb;
function dbToRatio(z) {
  return Math.pow(10, z / 10);
}
Util.dbToRatio = dbToRatio;
function toRatio(z) {
  const D = z.split(" ").map((O) => O.trim().toLowerCase());
  if (D.length >= 1) {
    const O = parseFloat(D[0]);
    return D.length === 2 && D[1] === "db" ? {
      dB: O,
      ratio: dbToRatio(O)
    } : {
      dB: ratioToDb(O),
      ratio: O
    };
  }
}
Util.toRatio = toRatio;
Object.defineProperty(ID3v24TagMapper$1, "__esModule", { value: !0 });
ID3v24TagMapper$1.ID3v24TagMapper = void 0;
const GenericTagMapper_1$4 = GenericTagMapper, CaseInsensitiveTagMap_1$2 = CaseInsensitiveTagMap$1, util$b = Util, id3v24TagMap = {
  // id3v2.3
  TIT2: "title",
  TPE1: "artist",
  "TXXX:Artists": "artists",
  TPE2: "albumartist",
  TALB: "album",
  TDRV: "date",
  /**
   * Original release year
   */
  TORY: "originalyear",
  TPOS: "disk",
  TCON: "genre",
  APIC: "picture",
  TCOM: "composer",
  "USLT:description": "lyrics",
  TSOA: "albumsort",
  TSOT: "titlesort",
  TOAL: "originalalbum",
  TSOP: "artistsort",
  TSO2: "albumartistsort",
  TSOC: "composersort",
  TEXT: "lyricist",
  "TXXX:Writer": "writer",
  TPE3: "conductor",
  // 'IPLS:instrument': 'performer:instrument', // ToDo
  TPE4: "remixer",
  "IPLS:arranger": "arranger",
  "IPLS:engineer": "engineer",
  "IPLS:producer": "producer",
  "IPLS:DJ-mix": "djmixer",
  "IPLS:mix": "mixer",
  TPUB: "label",
  TIT1: "grouping",
  TIT3: "subtitle",
  TRCK: "track",
  TCMP: "compilation",
  POPM: "rating",
  TBPM: "bpm",
  TMED: "media",
  "TXXX:CATALOGNUMBER": "catalognumber",
  "TXXX:MusicBrainz Album Status": "releasestatus",
  "TXXX:MusicBrainz Album Type": "releasetype",
  /**
   * Release country as documented: https://picard.musicbrainz.org/docs/mappings/#cite_note-0
   */
  "TXXX:MusicBrainz Album Release Country": "releasecountry",
  /**
   * Release country as implemented // ToDo: report
   */
  "TXXX:RELEASECOUNTRY": "releasecountry",
  "TXXX:SCRIPT": "script",
  TLAN: "language",
  TCOP: "copyright",
  WCOP: "license",
  TENC: "encodedby",
  TSSE: "encodersettings",
  "TXXX:BARCODE": "barcode",
  "TXXX:ISRC": "isrc",
  TSRC: "isrc",
  "TXXX:ASIN": "asin",
  "TXXX:originalyear": "originalyear",
  "UFID:http://musicbrainz.org": "musicbrainz_recordingid",
  "TXXX:MusicBrainz Release Track Id": "musicbrainz_trackid",
  "TXXX:MusicBrainz Album Id": "musicbrainz_albumid",
  "TXXX:MusicBrainz Artist Id": "musicbrainz_artistid",
  "TXXX:MusicBrainz Album Artist Id": "musicbrainz_albumartistid",
  "TXXX:MusicBrainz Release Group Id": "musicbrainz_releasegroupid",
  "TXXX:MusicBrainz Work Id": "musicbrainz_workid",
  "TXXX:MusicBrainz TRM Id": "musicbrainz_trmid",
  "TXXX:MusicBrainz Disc Id": "musicbrainz_discid",
  "TXXX:ACOUSTID_ID": "acoustid_id",
  "TXXX:Acoustid Id": "acoustid_id",
  "TXXX:Acoustid Fingerprint": "acoustid_fingerprint",
  "TXXX:MusicIP PUID": "musicip_puid",
  "TXXX:MusicMagic Fingerprint": "musicip_fingerprint",
  WOAR: "website",
  // id3v2.4
  // ToDo: In same sequence as defined at http://id3.org/id3v2.4.0-frames
  TDRC: "date",
  TYER: "year",
  TDOR: "originaldate",
  // 'TMCL:instrument': 'performer:instrument',
  "TIPL:arranger": "arranger",
  "TIPL:engineer": "engineer",
  "TIPL:producer": "producer",
  "TIPL:DJ-mix": "djmixer",
  "TIPL:mix": "mixer",
  TMOO: "mood",
  // additional mappings:
  SYLT: "lyrics",
  TSST: "discsubtitle",
  TKEY: "key",
  COMM: "comment",
  TOPE: "originalartist",
  // Windows Media Player
  "PRIV:AverageLevel": "averageLevel",
  "PRIV:PeakLevel": "peakLevel",
  // Discogs
  "TXXX:DISCOGS_ARTIST_ID": "discogs_artist_id",
  "TXXX:DISCOGS_ARTISTS": "artists",
  "TXXX:DISCOGS_ARTIST_NAME": "artists",
  "TXXX:DISCOGS_ALBUM_ARTISTS": "albumartist",
  "TXXX:DISCOGS_CATALOG": "catalognumber",
  "TXXX:DISCOGS_COUNTRY": "releasecountry",
  "TXXX:DISCOGS_DATE": "originaldate",
  "TXXX:DISCOGS_LABEL": "label",
  "TXXX:DISCOGS_LABEL_ID": "discogs_label_id",
  "TXXX:DISCOGS_MASTER_RELEASE_ID": "discogs_master_release_id",
  "TXXX:DISCOGS_RATING": "discogs_rating",
  "TXXX:DISCOGS_RELEASED": "date",
  "TXXX:DISCOGS_RELEASE_ID": "discogs_release_id",
  "TXXX:DISCOGS_VOTES": "discogs_votes",
  "TXXX:CATALOGID": "catalognumber",
  "TXXX:STYLE": "genre",
  "TXXX:REPLAYGAIN_TRACK_PEAK": "replaygain_track_peak",
  "TXXX:REPLAYGAIN_TRACK_GAIN": "replaygain_track_gain",
  "TXXX:REPLAYGAIN_ALBUM_PEAK": "replaygain_album_peak",
  "TXXX:REPLAYGAIN_ALBUM_GAIN": "replaygain_album_gain",
  "TXXX:MP3GAIN_MINMAX": "replaygain_track_minmax",
  "TXXX:MP3GAIN_ALBUM_MINMAX": "replaygain_album_minmax",
  "TXXX:MP3GAIN_UNDO": "replaygain_undo",
  MVNM: "movement",
  MVIN: "movementIndex",
  PCST: "podcast",
  TCAT: "category",
  TDES: "description",
  TDRL: "date",
  TGID: "podcastId",
  TKWD: "keywords",
  WFED: "podcasturl"
};
class ID3v24TagMapper extends CaseInsensitiveTagMap_1$2.CaseInsensitiveTagMap {
  static toRating(D) {
    return {
      source: D.email,
      rating: D.rating > 0 ? (D.rating - 1) / 254 * GenericTagMapper_1$4.CommonTagMapper.maxRatingScore : void 0
    };
  }
  constructor() {
    super(["ID3v2.3", "ID3v2.4"], id3v24TagMap);
  }
  /**
   * Handle post mapping exceptions / correction
   * @param tag to post map
   * @param warnings Wil be used to register (collect) warnings
   * @return Common value e.g. "Buena Vista Social Club"
   */
  postMap(D, O) {
    switch (D.id) {
      case "UFID":
        D.value.owner_identifier === "http://musicbrainz.org" && (D.id += ":" + D.value.owner_identifier, D.value = util$b.decodeString(D.value.identifier, "latin1"));
        break;
      case "PRIV":
        switch (D.value.owner_identifier) {
          case "AverageLevel":
          case "PeakValue":
            D.id += ":" + D.value.owner_identifier, D.value = D.value.data.length === 4 ? D.value.data.readUInt32LE(0) : null, D.value === null && O.addWarning("Failed to parse PRIV:PeakValue");
            break;
          default:
            O.addWarning(`Unknown PRIV owner-identifier: ${D.value.owner_identifier}`);
        }
        break;
      case "COMM":
        D.value = D.value ? D.value.text : null;
        break;
      case "POPM":
        D.value = ID3v24TagMapper.toRating(D.value);
        break;
    }
  }
}
ID3v24TagMapper$1.ID3v24TagMapper = ID3v24TagMapper;
var AsfTagMapper$1 = {};
Object.defineProperty(AsfTagMapper$1, "__esModule", { value: !0 });
AsfTagMapper$1.AsfTagMapper = void 0;
const GenericTagMapper_1$3 = GenericTagMapper, asfTagMap = {
  Title: "title",
  Author: "artist",
  "WM/AlbumArtist": "albumartist",
  "WM/AlbumTitle": "album",
  "WM/Year": "date",
  "WM/OriginalReleaseTime": "originaldate",
  "WM/OriginalReleaseYear": "originalyear",
  Description: "comment",
  "WM/TrackNumber": "track",
  "WM/PartOfSet": "disk",
  "WM/Genre": "genre",
  "WM/Composer": "composer",
  "WM/Lyrics": "lyrics",
  "WM/AlbumSortOrder": "albumsort",
  "WM/TitleSortOrder": "titlesort",
  "WM/ArtistSortOrder": "artistsort",
  "WM/AlbumArtistSortOrder": "albumartistsort",
  "WM/ComposerSortOrder": "composersort",
  "WM/Writer": "lyricist",
  "WM/Conductor": "conductor",
  "WM/ModifiedBy": "remixer",
  "WM/Engineer": "engineer",
  "WM/Producer": "producer",
  "WM/DJMixer": "djmixer",
  "WM/Mixer": "mixer",
  "WM/Publisher": "label",
  "WM/ContentGroupDescription": "grouping",
  "WM/SubTitle": "subtitle",
  "WM/SetSubTitle": "discsubtitle",
  // 'WM/PartOfSet': 'totaldiscs',
  "WM/IsCompilation": "compilation",
  "WM/SharedUserRating": "rating",
  "WM/BeatsPerMinute": "bpm",
  "WM/Mood": "mood",
  "WM/Media": "media",
  "WM/CatalogNo": "catalognumber",
  "MusicBrainz/Album Status": "releasestatus",
  "MusicBrainz/Album Type": "releasetype",
  "MusicBrainz/Album Release Country": "releasecountry",
  "WM/Script": "script",
  "WM/Language": "language",
  Copyright: "copyright",
  LICENSE: "license",
  "WM/EncodedBy": "encodedby",
  "WM/EncodingSettings": "encodersettings",
  "WM/Barcode": "barcode",
  "WM/ISRC": "isrc",
  "MusicBrainz/Track Id": "musicbrainz_recordingid",
  "MusicBrainz/Release Track Id": "musicbrainz_trackid",
  "MusicBrainz/Album Id": "musicbrainz_albumid",
  "MusicBrainz/Artist Id": "musicbrainz_artistid",
  "MusicBrainz/Album Artist Id": "musicbrainz_albumartistid",
  "MusicBrainz/Release Group Id": "musicbrainz_releasegroupid",
  "MusicBrainz/Work Id": "musicbrainz_workid",
  "MusicBrainz/TRM Id": "musicbrainz_trmid",
  "MusicBrainz/Disc Id": "musicbrainz_discid",
  "Acoustid/Id": "acoustid_id",
  "Acoustid/Fingerprint": "acoustid_fingerprint",
  "MusicIP/PUID": "musicip_puid",
  "WM/ARTISTS": "artists",
  "WM/InitialKey": "key",
  ASIN: "asin",
  "WM/Work": "work",
  "WM/AuthorURL": "website",
  "WM/Picture": "picture"
};
class AsfTagMapper extends GenericTagMapper_1$3.CommonTagMapper {
  static toRating(D) {
    return {
      rating: parseFloat(D + 1) / 5
    };
  }
  constructor() {
    super(["asf"], asfTagMap);
  }
  postMap(D) {
    switch (D.id) {
      case "WM/SharedUserRating":
        const O = D.id.split(":");
        D.value = AsfTagMapper.toRating(D.value), D.id = O[0];
        break;
    }
  }
}
AsfTagMapper$1.AsfTagMapper = AsfTagMapper;
var ID3v22TagMapper = {};
(function(z) {
  Object.defineProperty(z, "__esModule", { value: !0 }), z.ID3v22TagMapper = z.id3v22TagMap = void 0;
  const D = CaseInsensitiveTagMap$1;
  z.id3v22TagMap = {
    TT2: "title",
    TP1: "artist",
    TP2: "albumartist",
    TAL: "album",
    TYE: "year",
    COM: "comment",
    TRK: "track",
    TPA: "disk",
    TCO: "genre",
    PIC: "picture",
    TCM: "composer",
    TOR: "originaldate",
    TOT: "originalalbum",
    TXT: "lyricist",
    TP3: "conductor",
    TPB: "label",
    TT1: "grouping",
    TT3: "subtitle",
    TLA: "language",
    TCR: "copyright",
    WCP: "license",
    TEN: "encodedby",
    TSS: "encodersettings",
    WAR: "website",
    "COM:iTunPGAP": "gapless",
    PCS: "podcast",
    TCP: "compilation",
    TDR: "date",
    TS2: "albumartistsort",
    TSA: "albumsort",
    TSC: "composersort",
    TSP: "artistsort",
    TST: "titlesort",
    WFD: "podcasturl",
    TBP: "bpm"
  };
  class O extends D.CaseInsensitiveTagMap {
    constructor() {
      super(["ID3v2.2"], z.id3v22TagMap);
    }
  }
  z.ID3v22TagMapper = O;
})(ID3v22TagMapper);
var APEv2TagMapper$1 = {};
Object.defineProperty(APEv2TagMapper$1, "__esModule", { value: !0 });
APEv2TagMapper$1.APEv2TagMapper = void 0;
const CaseInsensitiveTagMap_1$1 = CaseInsensitiveTagMap$1, apev2TagMap = {
  Title: "title",
  Artist: "artist",
  Artists: "artists",
  "Album Artist": "albumartist",
  Album: "album",
  Year: "date",
  Originalyear: "originalyear",
  Originaldate: "originaldate",
  Comment: "comment",
  Track: "track",
  Disc: "disk",
  DISCNUMBER: "disk",
  Genre: "genre",
  "Cover Art (Front)": "picture",
  "Cover Art (Back)": "picture",
  Composer: "composer",
  Lyrics: "lyrics",
  ALBUMSORT: "albumsort",
  TITLESORT: "titlesort",
  WORK: "work",
  ARTISTSORT: "artistsort",
  ALBUMARTISTSORT: "albumartistsort",
  COMPOSERSORT: "composersort",
  Lyricist: "lyricist",
  Writer: "writer",
  Conductor: "conductor",
  // 'Performer=artist(instrument)': 'performer:instrument',
  MixArtist: "remixer",
  Arranger: "arranger",
  Engineer: "engineer",
  Producer: "producer",
  DJMixer: "djmixer",
  Mixer: "mixer",
  Label: "label",
  Grouping: "grouping",
  Subtitle: "subtitle",
  DiscSubtitle: "discsubtitle",
  Compilation: "compilation",
  BPM: "bpm",
  Mood: "mood",
  Media: "media",
  CatalogNumber: "catalognumber",
  MUSICBRAINZ_ALBUMSTATUS: "releasestatus",
  MUSICBRAINZ_ALBUMTYPE: "releasetype",
  RELEASECOUNTRY: "releasecountry",
  Script: "script",
  Language: "language",
  Copyright: "copyright",
  LICENSE: "license",
  EncodedBy: "encodedby",
  EncoderSettings: "encodersettings",
  Barcode: "barcode",
  ISRC: "isrc",
  ASIN: "asin",
  musicbrainz_trackid: "musicbrainz_recordingid",
  musicbrainz_releasetrackid: "musicbrainz_trackid",
  MUSICBRAINZ_ALBUMID: "musicbrainz_albumid",
  MUSICBRAINZ_ARTISTID: "musicbrainz_artistid",
  MUSICBRAINZ_ALBUMARTISTID: "musicbrainz_albumartistid",
  MUSICBRAINZ_RELEASEGROUPID: "musicbrainz_releasegroupid",
  MUSICBRAINZ_WORKID: "musicbrainz_workid",
  MUSICBRAINZ_TRMID: "musicbrainz_trmid",
  MUSICBRAINZ_DISCID: "musicbrainz_discid",
  Acoustid_Id: "acoustid_id",
  ACOUSTID_FINGERPRINT: "acoustid_fingerprint",
  MUSICIP_PUID: "musicip_puid",
  Weblink: "website",
  REPLAYGAIN_TRACK_GAIN: "replaygain_track_gain",
  REPLAYGAIN_TRACK_PEAK: "replaygain_track_peak",
  MP3GAIN_MINMAX: "replaygain_track_minmax",
  MP3GAIN_UNDO: "replaygain_undo"
};
class APEv2TagMapper extends CaseInsensitiveTagMap_1$1.CaseInsensitiveTagMap {
  constructor() {
    super(["APEv2"], apev2TagMap);
  }
}
APEv2TagMapper$1.APEv2TagMapper = APEv2TagMapper;
var MP4TagMapper = {};
(function(z) {
  Object.defineProperty(z, "__esModule", { value: !0 }), z.MP4TagMapper = z.tagType = void 0;
  const D = CaseInsensitiveTagMap$1, O = {
    "nam": "title",
    "ART": "artist",
    aART: "albumartist",
    /**
     * ToDo: Album artist seems to be stored here while Picard documentation says: aART
     */
    "----:com.apple.iTunes:Band": "albumartist",
    "alb": "album",
    "day": "date",
    "cmt": "comment",
    "com": "comment",
    trkn: "track",
    disk: "disk",
    "gen": "genre",
    covr: "picture",
    "wrt": "composer",
    "lyr": "lyrics",
    soal: "albumsort",
    sonm: "titlesort",
    soar: "artistsort",
    soaa: "albumartistsort",
    soco: "composersort",
    "----:com.apple.iTunes:LYRICIST": "lyricist",
    "----:com.apple.iTunes:CONDUCTOR": "conductor",
    "----:com.apple.iTunes:REMIXER": "remixer",
    "----:com.apple.iTunes:ENGINEER": "engineer",
    "----:com.apple.iTunes:PRODUCER": "producer",
    "----:com.apple.iTunes:DJMIXER": "djmixer",
    "----:com.apple.iTunes:MIXER": "mixer",
    "----:com.apple.iTunes:LABEL": "label",
    "grp": "grouping",
    "----:com.apple.iTunes:SUBTITLE": "subtitle",
    "----:com.apple.iTunes:DISCSUBTITLE": "discsubtitle",
    cpil: "compilation",
    tmpo: "bpm",
    "----:com.apple.iTunes:MOOD": "mood",
    "----:com.apple.iTunes:MEDIA": "media",
    "----:com.apple.iTunes:CATALOGNUMBER": "catalognumber",
    tvsh: "tvShow",
    tvsn: "tvSeason",
    tves: "tvEpisode",
    sosn: "tvShowSort",
    tven: "tvEpisodeId",
    tvnn: "tvNetwork",
    pcst: "podcast",
    purl: "podcasturl",
    "----:com.apple.iTunes:MusicBrainz Album Status": "releasestatus",
    "----:com.apple.iTunes:MusicBrainz Album Type": "releasetype",
    "----:com.apple.iTunes:MusicBrainz Album Release Country": "releasecountry",
    "----:com.apple.iTunes:SCRIPT": "script",
    "----:com.apple.iTunes:LANGUAGE": "language",
    cprt: "copyright",
    "cpy": "copyright",
    "----:com.apple.iTunes:LICENSE": "license",
    "too": "encodedby",
    pgap: "gapless",
    "----:com.apple.iTunes:BARCODE": "barcode",
    "----:com.apple.iTunes:ISRC": "isrc",
    "----:com.apple.iTunes:ASIN": "asin",
    "----:com.apple.iTunes:NOTES": "comment",
    "----:com.apple.iTunes:MusicBrainz Track Id": "musicbrainz_recordingid",
    "----:com.apple.iTunes:MusicBrainz Release Track Id": "musicbrainz_trackid",
    "----:com.apple.iTunes:MusicBrainz Album Id": "musicbrainz_albumid",
    "----:com.apple.iTunes:MusicBrainz Artist Id": "musicbrainz_artistid",
    "----:com.apple.iTunes:MusicBrainz Album Artist Id": "musicbrainz_albumartistid",
    "----:com.apple.iTunes:MusicBrainz Release Group Id": "musicbrainz_releasegroupid",
    "----:com.apple.iTunes:MusicBrainz Work Id": "musicbrainz_workid",
    "----:com.apple.iTunes:MusicBrainz TRM Id": "musicbrainz_trmid",
    "----:com.apple.iTunes:MusicBrainz Disc Id": "musicbrainz_discid",
    "----:com.apple.iTunes:Acoustid Id": "acoustid_id",
    "----:com.apple.iTunes:Acoustid Fingerprint": "acoustid_fingerprint",
    "----:com.apple.iTunes:MusicIP PUID": "musicip_puid",
    "----:com.apple.iTunes:fingerprint": "musicip_fingerprint",
    "----:com.apple.iTunes:replaygain_track_gain": "replaygain_track_gain",
    "----:com.apple.iTunes:replaygain_track_peak": "replaygain_track_peak",
    "----:com.apple.iTunes:replaygain_album_gain": "replaygain_album_gain",
    "----:com.apple.iTunes:replaygain_album_peak": "replaygain_album_peak",
    "----:com.apple.iTunes:replaygain_track_minmax": "replaygain_track_minmax",
    "----:com.apple.iTunes:replaygain_album_minmax": "replaygain_album_minmax",
    "----:com.apple.iTunes:replaygain_undo": "replaygain_undo",
    // Additional mappings:
    gnre: "genre",
    "----:com.apple.iTunes:ALBUMARTISTSORT": "albumartistsort",
    "----:com.apple.iTunes:ARTISTS": "artists",
    "----:com.apple.iTunes:ORIGINALDATE": "originaldate",
    "----:com.apple.iTunes:ORIGINALYEAR": "originalyear",
    // '----:com.apple.iTunes:PERFORMER': 'performer'
    desc: "description",
    ldes: "longDescription",
    "mvn": "movement",
    "mvi": "movementIndex",
    "mvc": "movementTotal",
    "wrk": "work",
    catg: "category",
    egid: "podcastId",
    hdvd: "hdVideo",
    keyw: "keywords",
    shwm: "showMovement",
    stik: "stik",
    rate: "rating"
  };
  z.tagType = "iTunes";
  class F extends D.CaseInsensitiveTagMap {
    constructor() {
      super([z.tagType], O);
    }
    postMap(W, B) {
      switch (W.id) {
        case "rate":
          W.value = {
            source: void 0,
            rating: parseFloat(W.value) / 100
          };
          break;
      }
    }
  }
  z.MP4TagMapper = F;
})(MP4TagMapper);
var VorbisTagMapper$1 = {};
Object.defineProperty(VorbisTagMapper$1, "__esModule", { value: !0 });
VorbisTagMapper$1.VorbisTagMapper = void 0;
const GenericTagMapper_1$2 = GenericTagMapper, vorbisTagMap = {
  TITLE: "title",
  ARTIST: "artist",
  ARTISTS: "artists",
  ALBUMARTIST: "albumartist",
  "ALBUM ARTIST": "albumartist",
  ALBUM: "album",
  DATE: "date",
  ORIGINALDATE: "originaldate",
  ORIGINALYEAR: "originalyear",
  COMMENT: "comment",
  TRACKNUMBER: "track",
  DISCNUMBER: "disk",
  GENRE: "genre",
  METADATA_BLOCK_PICTURE: "picture",
  COMPOSER: "composer",
  LYRICS: "lyrics",
  ALBUMSORT: "albumsort",
  TITLESORT: "titlesort",
  WORK: "work",
  ARTISTSORT: "artistsort",
  ALBUMARTISTSORT: "albumartistsort",
  COMPOSERSORT: "composersort",
  LYRICIST: "lyricist",
  WRITER: "writer",
  CONDUCTOR: "conductor",
  // 'PERFORMER=artist(instrument)': 'performer:instrument', // ToDo
  REMIXER: "remixer",
  ARRANGER: "arranger",
  ENGINEER: "engineer",
  PRODUCER: "producer",
  DJMIXER: "djmixer",
  MIXER: "mixer",
  LABEL: "label",
  GROUPING: "grouping",
  SUBTITLE: "subtitle",
  DISCSUBTITLE: "discsubtitle",
  TRACKTOTAL: "totaltracks",
  DISCTOTAL: "totaldiscs",
  COMPILATION: "compilation",
  RATING: "rating",
  BPM: "bpm",
  KEY: "key",
  MOOD: "mood",
  MEDIA: "media",
  CATALOGNUMBER: "catalognumber",
  RELEASESTATUS: "releasestatus",
  RELEASETYPE: "releasetype",
  RELEASECOUNTRY: "releasecountry",
  SCRIPT: "script",
  LANGUAGE: "language",
  COPYRIGHT: "copyright",
  LICENSE: "license",
  ENCODEDBY: "encodedby",
  ENCODERSETTINGS: "encodersettings",
  BARCODE: "barcode",
  ISRC: "isrc",
  ASIN: "asin",
  MUSICBRAINZ_TRACKID: "musicbrainz_recordingid",
  MUSICBRAINZ_RELEASETRACKID: "musicbrainz_trackid",
  MUSICBRAINZ_ALBUMID: "musicbrainz_albumid",
  MUSICBRAINZ_ARTISTID: "musicbrainz_artistid",
  MUSICBRAINZ_ALBUMARTISTID: "musicbrainz_albumartistid",
  MUSICBRAINZ_RELEASEGROUPID: "musicbrainz_releasegroupid",
  MUSICBRAINZ_WORKID: "musicbrainz_workid",
  MUSICBRAINZ_TRMID: "musicbrainz_trmid",
  MUSICBRAINZ_DISCID: "musicbrainz_discid",
  ACOUSTID_ID: "acoustid_id",
  ACOUSTID_ID_FINGERPRINT: "acoustid_fingerprint",
  MUSICIP_PUID: "musicip_puid",
  // 'FINGERPRINT=MusicMagic Fingerprint{fingerprint}': 'musicip_fingerprint', // ToDo
  WEBSITE: "website",
  NOTES: "notes",
  TOTALTRACKS: "totaltracks",
  TOTALDISCS: "totaldiscs",
  // Discogs
  DISCOGS_ARTIST_ID: "discogs_artist_id",
  DISCOGS_ARTISTS: "artists",
  DISCOGS_ARTIST_NAME: "artists",
  DISCOGS_ALBUM_ARTISTS: "albumartist",
  DISCOGS_CATALOG: "catalognumber",
  DISCOGS_COUNTRY: "releasecountry",
  DISCOGS_DATE: "originaldate",
  DISCOGS_LABEL: "label",
  DISCOGS_LABEL_ID: "discogs_label_id",
  DISCOGS_MASTER_RELEASE_ID: "discogs_master_release_id",
  DISCOGS_RATING: "discogs_rating",
  DISCOGS_RELEASED: "date",
  DISCOGS_RELEASE_ID: "discogs_release_id",
  DISCOGS_VOTES: "discogs_votes",
  CATALOGID: "catalognumber",
  STYLE: "genre",
  //
  REPLAYGAIN_TRACK_GAIN: "replaygain_track_gain",
  REPLAYGAIN_TRACK_PEAK: "replaygain_track_peak",
  REPLAYGAIN_ALBUM_GAIN: "replaygain_album_gain",
  REPLAYGAIN_ALBUM_PEAK: "replaygain_album_peak",
  // To Sure if these (REPLAYGAIN_MINMAX, REPLAYGAIN_ALBUM_MINMAX & REPLAYGAIN_UNDO) are used for Vorbis:
  REPLAYGAIN_MINMAX: "replaygain_track_minmax",
  REPLAYGAIN_ALBUM_MINMAX: "replaygain_album_minmax",
  REPLAYGAIN_UNDO: "replaygain_undo"
};
class VorbisTagMapper extends GenericTagMapper_1$2.CommonTagMapper {
  static toRating(D, O, F) {
    return {
      source: D && D.toLowerCase(),
      rating: parseFloat(O) / F * GenericTagMapper_1$2.CommonTagMapper.maxRatingScore
    };
  }
  constructor() {
    super(["vorbis"], vorbisTagMap);
  }
  postMap(D) {
    if (D.id === "RATING")
      D.value = VorbisTagMapper.toRating(void 0, D.value, 100);
    else if (D.id.indexOf("RATING:") === 0) {
      const O = D.id.split(":");
      D.value = VorbisTagMapper.toRating(O[1], D.value, 1), D.id = O[0];
    }
  }
}
VorbisTagMapper$1.VorbisTagMapper = VorbisTagMapper;
var RiffInfoTagMap = {};
(function(z) {
  Object.defineProperty(z, "__esModule", { value: !0 }), z.RiffInfoTagMapper = z.riffInfoTagMap = void 0;
  const D = GenericTagMapper;
  z.riffInfoTagMap = {
    IART: "artist",
    ICRD: "date",
    INAM: "title",
    TITL: "title",
    IPRD: "album",
    ITRK: "track",
    IPRT: "track",
    COMM: "comment",
    ICMT: "comment",
    ICNT: "releasecountry",
    GNRE: "genre",
    IWRI: "writer",
    RATE: "rating",
    YEAR: "year",
    ISFT: "encodedby",
    CODE: "encodedby",
    TURL: "website",
    IGNR: "genre",
    IENG: "engineer",
    ITCH: "technician",
    IMED: "media",
    IRPD: "album"
    // Product, where the file was intended for
  };
  class O extends D.CommonTagMapper {
    constructor() {
      super(["exif"], z.riffInfoTagMap);
    }
  }
  z.RiffInfoTagMapper = O;
})(RiffInfoTagMap);
var MatroskaTagMapper$1 = {};
Object.defineProperty(MatroskaTagMapper$1, "__esModule", { value: !0 });
MatroskaTagMapper$1.MatroskaTagMapper = void 0;
const CaseInsensitiveTagMap_1 = CaseInsensitiveTagMap$1, ebmlTagMap = {
  "segment:title": "title",
  "album:ARTIST": "albumartist",
  "album:ARTISTSORT": "albumartistsort",
  "album:TITLE": "album",
  "album:DATE_RECORDED": "originaldate",
  "album:PART_NUMBER": "disk",
  "album:TOTAL_PARTS": "totaltracks",
  "track:ARTIST": "artist",
  "track:ARTISTSORT": "artistsort",
  "track:TITLE": "title",
  "track:PART_NUMBER": "track",
  "track:MUSICBRAINZ_TRACKID": "musicbrainz_recordingid",
  "track:MUSICBRAINZ_ALBUMID": "musicbrainz_albumid",
  "track:MUSICBRAINZ_ARTISTID": "musicbrainz_artistid",
  "track:PUBLISHER": "label",
  "track:GENRE": "genre",
  "track:ENCODER": "encodedby",
  "track:ENCODER_OPTIONS": "encodersettings",
  "edition:TOTAL_PARTS": "totaldiscs",
  picture: "picture"
};
class MatroskaTagMapper extends CaseInsensitiveTagMap_1.CaseInsensitiveTagMap {
  constructor() {
    super(["matroska"], ebmlTagMap);
  }
}
MatroskaTagMapper$1.MatroskaTagMapper = MatroskaTagMapper;
var AiffTagMap = {};
Object.defineProperty(AiffTagMap, "__esModule", { value: !0 });
AiffTagMap.AiffTagMapper = void 0;
const GenericTagMapper_1$1 = GenericTagMapper, tagMap = {
  NAME: "title",
  AUTH: "artist",
  "(c) ": "copyright",
  ANNO: "comment"
};
class AiffTagMapper extends GenericTagMapper_1$1.CommonTagMapper {
  constructor() {
    super(["AIFF"], tagMap);
  }
}
AiffTagMap.AiffTagMapper = AiffTagMapper;
Object.defineProperty(CombinedTagMapper$1, "__esModule", { value: !0 });
CombinedTagMapper$1.CombinedTagMapper = void 0;
const ID3v1TagMap_1 = ID3v1TagMap, ID3v24TagMapper_1 = ID3v24TagMapper$1, AsfTagMapper_1 = AsfTagMapper$1, ID3v22TagMapper_1 = ID3v22TagMapper, APEv2TagMapper_1 = APEv2TagMapper$1, MP4TagMapper_1 = MP4TagMapper, VorbisTagMapper_1 = VorbisTagMapper$1, RiffInfoTagMap_1 = RiffInfoTagMap, MatroskaTagMapper_1 = MatroskaTagMapper$1, AiffTagMap_1 = AiffTagMap;
class CombinedTagMapper {
  constructor() {
    this.tagMappers = {}, [
      new ID3v1TagMap_1.ID3v1TagMapper(),
      new ID3v22TagMapper_1.ID3v22TagMapper(),
      new ID3v24TagMapper_1.ID3v24TagMapper(),
      new MP4TagMapper_1.MP4TagMapper(),
      new MP4TagMapper_1.MP4TagMapper(),
      new VorbisTagMapper_1.VorbisTagMapper(),
      new APEv2TagMapper_1.APEv2TagMapper(),
      new AsfTagMapper_1.AsfTagMapper(),
      new RiffInfoTagMap_1.RiffInfoTagMapper(),
      new MatroskaTagMapper_1.MatroskaTagMapper(),
      new AiffTagMap_1.AiffTagMapper()
    ].forEach((D) => {
      this.registerTagMapper(D);
    });
  }
  /**
   * Convert native to generic (common) tags
   * @param tagType Originating tag format
   * @param tag     Native tag to map to a generic tag id
   * @param warnings
   * @return Generic tag result (output of this function)
   */
  mapTag(D, O, F) {
    if (this.tagMappers[D])
      return this.tagMappers[D].mapGenericTag(O, F);
    throw new Error("No generic tag mapper defined for tag-format: " + D);
  }
  registerTagMapper(D) {
    for (const O of D.tagTypes)
      this.tagMappers[O] = D;
  }
}
CombinedTagMapper$1.CombinedTagMapper = CombinedTagMapper;
Object.defineProperty(MetadataCollector$1, "__esModule", { value: !0 });
MetadataCollector$1.joinArtists = MetadataCollector$1.MetadataCollector = void 0;
const type_1$2 = type$1, debug_1$n = browserExports, GenericTagTypes_1 = GenericTagTypes, CombinedTagMapper_1 = CombinedTagMapper$1, GenericTagMapper_1 = GenericTagMapper, Util_1$1 = Util, FileType$1 = core, debug$n = (0, debug_1$n.default)("music-metadata:collector"), TagPriority = ["matroska", "APEv2", "vorbis", "ID3v2.4", "ID3v2.3", "ID3v2.2", "exif", "asf", "iTunes", "AIFF", "ID3v1"];
class MetadataCollector {
  constructor(D) {
    this.opts = D, this.format = {
      tagTypes: [],
      trackInfo: []
    }, this.native = {}, this.common = {
      track: { no: null, of: null },
      disk: { no: null, of: null },
      movementIndex: {}
    }, this.quality = {
      warnings: []
    }, this.commonOrigin = {}, this.originPriority = {}, this.tagMapper = new CombinedTagMapper_1.CombinedTagMapper();
    let O = 1;
    for (const F of TagPriority)
      this.originPriority[F] = O++;
    this.originPriority.artificial = 500, this.originPriority.id3v1 = 600;
  }
  /**
   * @returns {boolean} true if one or more tags have been found
   */
  hasAny() {
    return Object.keys(this.native).length > 0;
  }
  addStreamInfo(D) {
    debug$n(`streamInfo: type=${type_1$2.TrackType[D.type]}, codec=${D.codecName}`), this.format.trackInfo.push(D);
  }
  setFormat(D, O) {
    debug$n(`format: ${D} = ${O}`), this.format[D] = O, this.opts.observer && this.opts.observer({ metadata: this, tag: { type: "format", id: D, value: O } });
  }
  addTag(D, O, F) {
    debug$n(`tag ${D}.${O} = ${F}`), this.native[D] || (this.format.tagTypes.push(D), this.native[D] = []), this.native[D].push({ id: O, value: F }), this.toCommon(D, O, F);
  }
  addWarning(D) {
    this.quality.warnings.push({ message: D });
  }
  postMap(D, O) {
    switch (O.id) {
      case "artist":
        if (this.commonOrigin.artist === this.originPriority[D])
          return this.postMap("artificial", { id: "artists", value: O.value });
        this.common.artists || this.setGenericTag("artificial", { id: "artists", value: O.value });
        break;
      case "artists":
        if ((!this.common.artist || this.commonOrigin.artist === this.originPriority.artificial) && (!this.common.artists || this.common.artists.indexOf(O.value) === -1)) {
          const B = (this.common.artists || []).concat([O.value]), X = { id: "artist", value: joinArtists(B) };
          this.setGenericTag("artificial", X);
        }
        break;
      case "picture":
        this.postFixPicture(O.value).then((B) => {
          B !== null && (O.value = B, this.setGenericTag(D, O));
        });
        return;
      case "totaltracks":
        this.common.track.of = GenericTagMapper_1.CommonTagMapper.toIntOrNull(O.value);
        return;
      case "totaldiscs":
        this.common.disk.of = GenericTagMapper_1.CommonTagMapper.toIntOrNull(O.value);
        return;
      case "movementTotal":
        this.common.movementIndex.of = GenericTagMapper_1.CommonTagMapper.toIntOrNull(O.value);
        return;
      case "track":
      case "disk":
      case "movementIndex":
        const F = this.common[O.id].of;
        this.common[O.id] = GenericTagMapper_1.CommonTagMapper.normalizeTrack(O.value), this.common[O.id].of = F ?? this.common[O.id].of;
        return;
      case "bpm":
      case "year":
      case "originalyear":
        O.value = parseInt(O.value, 10);
        break;
      case "date":
        const U = parseInt(O.value.substr(0, 4), 10);
        isNaN(U) || (this.common.year = U);
        break;
      case "discogs_label_id":
      case "discogs_release_id":
      case "discogs_master_release_id":
      case "discogs_artist_id":
      case "discogs_votes":
        O.value = typeof O.value == "string" ? parseInt(O.value, 10) : O.value;
        break;
      case "replaygain_track_gain":
      case "replaygain_track_peak":
      case "replaygain_album_gain":
      case "replaygain_album_peak":
        O.value = (0, Util_1$1.toRatio)(O.value);
        break;
      case "replaygain_track_minmax":
        O.value = O.value.split(",").map((B) => parseInt(B, 10));
        break;
      case "replaygain_undo":
        const W = O.value.split(",").map((B) => parseInt(B, 10));
        O.value = {
          leftChannel: W[0],
          rightChannel: W[1]
        };
        break;
      case "gapless":
      case "compilation":
      case "podcast":
      case "showMovement":
        O.value = O.value === "1" || O.value === 1;
        break;
      case "isrc":
        if (this.common[O.id] && this.common[O.id].indexOf(O.value) !== -1)
          return;
        break;
    }
    O.value !== null && this.setGenericTag(D, O);
  }
  /**
   * Convert native tags to common tags
   * @returns {IAudioMetadata} Native + common tags
   */
  toCommonMetadata() {
    return {
      format: this.format,
      native: this.native,
      quality: this.quality,
      common: this.common
    };
  }
  /**
   * Fix some common issues with picture object
   * @param picture Picture
   */
  async postFixPicture(D) {
    if (D.data && D.data.length > 0) {
      if (!D.format) {
        const O = await FileType$1.fromBuffer(D.data);
        if (O)
          D.format = O.mime;
        else
          return null;
      }
      switch (D.format = D.format.toLocaleLowerCase(), D.format) {
        case "image/jpg":
          D.format = "image/jpeg";
      }
      return D;
    }
    return this.addWarning("Empty picture tag found"), null;
  }
  /**
   * Convert native tag to common tags
   */
  toCommon(D, O, F) {
    const U = { id: O, value: F }, W = this.tagMapper.mapTag(D, U, this);
    W && this.postMap(D, W);
  }
  /**
   * Set generic tag
   */
  setGenericTag(D, O) {
    debug$n(`common.${O.id} = ${O.value}`);
    const F = this.commonOrigin[O.id] || 1e3, U = this.originPriority[D];
    if ((0, GenericTagTypes_1.isSingleton)(O.id))
      if (U <= F)
        this.common[O.id] = O.value, this.commonOrigin[O.id] = U;
      else
        return debug$n(`Ignore native tag (singleton): ${D}.${O.id} = ${O.value}`);
    else if (U === F)
      !(0, GenericTagTypes_1.isUnique)(O.id) || this.common[O.id].indexOf(O.value) === -1 ? this.common[O.id].push(O.value) : debug$n(`Ignore duplicate value: ${D}.${O.id} = ${O.value}`);
    else if (U < F)
      this.common[O.id] = [O.value], this.commonOrigin[O.id] = U;
    else
      return debug$n(`Ignore native tag (list): ${D}.${O.id} = ${O.value}`);
    this.opts.observer && this.opts.observer({ metadata: this, tag: { type: "common", id: O.id, value: O.value } });
  }
}
MetadataCollector$1.MetadataCollector = MetadataCollector;
function joinArtists(z) {
  return z.length > 2 ? z.slice(0, z.length - 1).join(", ") + " & " + z[z.length - 1] : z.join(" & ");
}
MetadataCollector$1.joinArtists = joinArtists;
var AiffParser = {}, ID3v2Parser$1 = {}, FrameParser$1 = {}, ID3v2Token = {};
(function(z) {
  Object.defineProperty(z, "__esModule", { value: !0 }), z.TextEncodingToken = z.ExtendedHeader = z.ID3v2Header = z.UINT32SYNCSAFE = z.AttachedPictureType = void 0;
  const D = lib$1, O = Util;
  (function(F) {
    F[F.Other = 0] = "Other", F[F["32x32 pixels 'file icon' (PNG only)"] = 1] = "32x32 pixels 'file icon' (PNG only)", F[F["Other file icon"] = 2] = "Other file icon", F[F["Cover (front)"] = 3] = "Cover (front)", F[F["Cover (back)"] = 4] = "Cover (back)", F[F["Leaflet page"] = 5] = "Leaflet page", F[F["Media (e.g. label side of CD)"] = 6] = "Media (e.g. label side of CD)", F[F["Lead artist/lead performer/soloist"] = 7] = "Lead artist/lead performer/soloist", F[F["Artist/performer"] = 8] = "Artist/performer", F[F.Conductor = 9] = "Conductor", F[F["Band/Orchestra"] = 10] = "Band/Orchestra", F[F.Composer = 11] = "Composer", F[F["Lyricist/text writer"] = 12] = "Lyricist/text writer", F[F["Recording Location"] = 13] = "Recording Location", F[F["During recording"] = 14] = "During recording", F[F["During performance"] = 15] = "During performance", F[F["Movie/video screen capture"] = 16] = "Movie/video screen capture", F[F["A bright coloured fish"] = 17] = "A bright coloured fish", F[F.Illustration = 18] = "Illustration", F[F["Band/artist logotype"] = 19] = "Band/artist logotype", F[F["Publisher/Studio logotype"] = 20] = "Publisher/Studio logotype";
  })(z.AttachedPictureType || (z.AttachedPictureType = {})), z.UINT32SYNCSAFE = {
    get: (F, U) => F[U + 3] & 127 | F[U + 2] << 7 | F[U + 1] << 14 | F[U] << 21,
    len: 4
  }, z.ID3v2Header = {
    len: 10,
    get: (F, U) => ({
      // ID3v2/file identifier   "ID3"
      fileIdentifier: new D.StringType(3, "ascii").get(F, U),
      // ID3v2 versionIndex
      version: {
        major: D.INT8.get(F, U + 3),
        revision: D.INT8.get(F, U + 4)
      },
      // ID3v2 flags
      flags: {
        // Unsynchronisation
        unsynchronisation: O.getBit(F, U + 5, 7),
        // Extended header
        isExtendedHeader: O.getBit(F, U + 5, 6),
        // Experimental indicator
        expIndicator: O.getBit(F, U + 5, 5),
        footer: O.getBit(F, U + 5, 4)
      },
      size: z.UINT32SYNCSAFE.get(F, U + 6)
    })
  }, z.ExtendedHeader = {
    len: 10,
    get: (F, U) => ({
      // Extended header size
      size: D.UINT32_BE.get(F, U),
      // Extended Flags
      extendedFlags: D.UINT16_BE.get(F, U + 4),
      // Size of padding
      sizeOfPadding: D.UINT32_BE.get(F, U + 6),
      // CRC data present
      crcDataPresent: O.getBit(F, U + 4, 31)
    })
  }, z.TextEncodingToken = {
    len: 1,
    get: (F, U) => {
      switch (F[U]) {
        case 0:
          return { encoding: "latin1" };
        case 1:
          return { encoding: "utf16le", bom: !0 };
        case 2:
          return { encoding: "utf16le", bom: !1 };
        case 3:
          return { encoding: "utf8", bom: !1 };
        default:
          return { encoding: "utf8", bom: !1 };
      }
    }
  };
})(ID3v2Token);
var ID3v1Parser = {}, BasicParser$1 = {};
Object.defineProperty(BasicParser$1, "__esModule", { value: !0 });
BasicParser$1.BasicParser = void 0;
class BasicParser {
  /**
   * Initialize parser with output (metadata), input (tokenizer) & parsing options (options).
   * @param {INativeMetadataCollector} metadata Output
   * @param {ITokenizer} tokenizer Input
   * @param {IOptions} options Parsing options
   */
  init(D, O, F) {
    return this.metadata = D, this.tokenizer = O, this.options = F, this;
  }
}
BasicParser$1.BasicParser = BasicParser;
var APEv2Parser$1 = {}, APEv2Token = {}, FourCC = {};
(function(z) {
  Object.defineProperty(z, "__esModule", { value: !0 }), z.FourCcToken = void 0;
  const D = Util, O = /^[\x21-\x7e][\x20-\x7e\x00()]{3}/;
  z.FourCcToken = {
    len: 4,
    get: (F, U) => {
      const W = F.toString("binary", U, U + z.FourCcToken.len);
      if (!W.match(O))
        throw new Error(`FourCC contains invalid characters: ${D.a2hex(W)} "${W}"`);
      return W;
    },
    put: (F, U, W) => {
      const B = Buffer.from(W, "binary");
      if (B.length !== 4)
        throw new Error("Invalid length");
      return B.copy(F, U);
    }
  };
})(FourCC);
(function(z) {
  Object.defineProperty(z, "__esModule", { value: !0 }), z.isBitSet = z.parseTagFlags = z.TagField = z.TagItemHeader = z.TagFooter = z.Header = z.DescriptorParser = z.DataType = void 0;
  const D = lib$1, O = FourCC;
  (function(B) {
    B[B.text_utf8 = 0] = "text_utf8", B[B.binary = 1] = "binary", B[B.external_info = 2] = "external_info", B[B.reserved = 3] = "reserved";
  })(z.DataType || (z.DataType = {})), z.DescriptorParser = {
    len: 52,
    get: (B, K) => ({
      // should equal 'MAC '
      ID: O.FourCcToken.get(B, K),
      // versionIndex number * 1000 (3.81 = 3810) (remember that 4-byte alignment causes this to take 4-bytes)
      version: D.UINT32_LE.get(B, K + 4) / 1e3,
      // the number of descriptor bytes (allows later expansion of this header)
      descriptorBytes: D.UINT32_LE.get(B, K + 8),
      // the number of header APE_HEADER bytes
      headerBytes: D.UINT32_LE.get(B, K + 12),
      // the number of header APE_HEADER bytes
      seekTableBytes: D.UINT32_LE.get(B, K + 16),
      // the number of header data bytes (from original file)
      headerDataBytes: D.UINT32_LE.get(B, K + 20),
      // the number of bytes of APE frame data
      apeFrameDataBytes: D.UINT32_LE.get(B, K + 24),
      // the high order number of APE frame data bytes
      apeFrameDataBytesHigh: D.UINT32_LE.get(B, K + 28),
      // the terminating data of the file (not including tag data)
      terminatingDataBytes: D.UINT32_LE.get(B, K + 32),
      // the MD5 hash of the file (see notes for usage... it's a little tricky)
      fileMD5: new D.Uint8ArrayType(16).get(B, K + 36)
    })
  }, z.Header = {
    len: 24,
    get: (B, K) => ({
      // the compression level (see defines I.E. COMPRESSION_LEVEL_FAST)
      compressionLevel: D.UINT16_LE.get(B, K),
      // any format flags (for future use)
      formatFlags: D.UINT16_LE.get(B, K + 2),
      // the number of audio blocks in one frame
      blocksPerFrame: D.UINT32_LE.get(B, K + 4),
      // the number of audio blocks in the final frame
      finalFrameBlocks: D.UINT32_LE.get(B, K + 8),
      // the total number of frames
      totalFrames: D.UINT32_LE.get(B, K + 12),
      // the bits per sample (typically 16)
      bitsPerSample: D.UINT16_LE.get(B, K + 16),
      // the number of channels (1 or 2)
      channel: D.UINT16_LE.get(B, K + 18),
      // the sample rate (typically 44100)
      sampleRate: D.UINT32_LE.get(B, K + 20)
    })
  }, z.TagFooter = {
    len: 32,
    get: (B, K) => ({
      // should equal 'APETAGEX'
      ID: new D.StringType(8, "ascii").get(B, K),
      // equals CURRENT_APE_TAG_VERSION
      version: D.UINT32_LE.get(B, K + 8),
      // the complete size of the tag, including this footer (excludes header)
      size: D.UINT32_LE.get(B, K + 12),
      // the number of fields in the tag
      fields: D.UINT32_LE.get(B, K + 16),
      // reserved for later use (must be zero),
      flags: U(D.UINT32_LE.get(B, K + 20))
    })
  }, z.TagItemHeader = {
    len: 8,
    get: (B, K) => ({
      // Length of assigned value in bytes
      size: D.UINT32_LE.get(B, K),
      // reserved for later use (must be zero),
      flags: U(D.UINT32_LE.get(B, K + 4))
    })
  };
  const F = (B) => new D.Uint8ArrayType(B.size - z.TagFooter.len);
  z.TagField = F;
  function U(B) {
    return {
      containsHeader: W(B, 31),
      containsFooter: W(B, 30),
      isHeader: W(B, 31),
      readOnly: W(B, 0),
      dataType: (B & 6) >> 1
    };
  }
  z.parseTagFlags = U;
  function W(B, K) {
    return (B & 1 << K) !== 0;
  }
  z.isBitSet = W;
})(APEv2Token);
Object.defineProperty(APEv2Parser$1, "__esModule", { value: !0 });
APEv2Parser$1.APEv2Parser = void 0;
const debug_1$m = browserExports, strtok3$4 = core$1, token_types_1$2 = lib$1, util$a = Util, BasicParser_1$b = BasicParser$1, APEv2Token_1 = APEv2Token, debug$m = (0, debug_1$m.default)("music-metadata:parser:APEv2"), tagFormat$1 = "APEv2", preamble = "APETAGEX";
class APEv2Parser extends BasicParser_1$b.BasicParser {
  constructor() {
    super(...arguments), this.ape = {};
  }
  static tryParseApeHeader(D, O, F) {
    const U = new APEv2Parser();
    return U.init(D, O, F), U.tryParseApeHeader();
  }
  /**
   * Calculate the media file duration
   * @param ah ApeHeader
   * @return {number} duration in seconds
   */
  static calculateDuration(D) {
    let O = D.totalFrames > 1 ? D.blocksPerFrame * (D.totalFrames - 1) : 0;
    return O += D.finalFrameBlocks, O / D.sampleRate;
  }
  /**
   * Calculates the APEv1 / APEv2 first field offset
   * @param reader
   * @param offset
   */
  static async findApeFooterOffset(D, O) {
    const F = Buffer.alloc(APEv2Token_1.TagFooter.len);
    await D.randomRead(F, 0, APEv2Token_1.TagFooter.len, O - APEv2Token_1.TagFooter.len);
    const U = APEv2Token_1.TagFooter.get(F, 0);
    if (U.ID === "APETAGEX")
      return debug$m(`APE footer header at offset=${O}`), { footer: U, offset: O - U.size };
  }
  static parseTagFooter(D, O, F) {
    const U = APEv2Token_1.TagFooter.get(O, O.length - APEv2Token_1.TagFooter.len);
    if (U.ID !== preamble)
      throw new Error("Unexpected APEv2 Footer ID preamble value.");
    strtok3$4.fromBuffer(O);
    const W = new APEv2Parser();
    return W.init(D, strtok3$4.fromBuffer(O), F), W.parseTags(U);
  }
  /**
   * Parse APEv1 / APEv2 header if header signature found
   */
  async tryParseApeHeader() {
    if (this.tokenizer.fileInfo.size && this.tokenizer.fileInfo.size - this.tokenizer.position < APEv2Token_1.TagFooter.len) {
      debug$m("No APEv2 header found, end-of-file reached");
      return;
    }
    const D = await this.tokenizer.peekToken(APEv2Token_1.TagFooter);
    if (D.ID === preamble)
      return await this.tokenizer.ignore(APEv2Token_1.TagFooter.len), this.parseTags(D);
    if (debug$m(`APEv2 header not found at offset=${this.tokenizer.position}`), this.tokenizer.fileInfo.size) {
      const O = this.tokenizer.fileInfo.size - this.tokenizer.position, F = Buffer.alloc(O);
      return await this.tokenizer.readBuffer(F), APEv2Parser.parseTagFooter(this.metadata, F, this.options);
    }
  }
  async parse() {
    const D = await this.tokenizer.readToken(APEv2Token_1.DescriptorParser);
    if (D.ID !== "MAC ")
      throw new Error("Unexpected descriptor ID");
    this.ape.descriptor = D;
    const O = D.descriptorBytes - APEv2Token_1.DescriptorParser.len, F = await (O > 0 ? this.parseDescriptorExpansion(O) : this.parseHeader());
    return await this.tokenizer.ignore(F.forwardBytes), this.tryParseApeHeader();
  }
  async parseTags(D) {
    const O = Buffer.alloc(256);
    let F = D.size - APEv2Token_1.TagFooter.len;
    debug$m(`Parse APE tags at offset=${this.tokenizer.position}, size=${F}`);
    for (let U = 0; U < D.fields; U++) {
      if (F < APEv2Token_1.TagItemHeader.len) {
        this.metadata.addWarning(`APEv2 Tag-header: ${D.fields - U} items remaining, but no more tag data to read.`);
        break;
      }
      const W = await this.tokenizer.readToken(APEv2Token_1.TagItemHeader);
      F -= APEv2Token_1.TagItemHeader.len + W.size, await this.tokenizer.peekBuffer(O, { length: Math.min(O.length, F) });
      let B = util$a.findZero(O, 0, O.length);
      const K = await this.tokenizer.readToken(new token_types_1$2.StringType(B, "ascii"));
      switch (await this.tokenizer.ignore(1), F -= K.length + 1, W.flags.dataType) {
        case APEv2Token_1.DataType.text_utf8: {
          const Y = (await this.tokenizer.readToken(new token_types_1$2.StringType(W.size, "utf8"))).split(/\x00/g);
          for (const Q of Y)
            this.metadata.addTag(tagFormat$1, K, Q);
          break;
        }
        case APEv2Token_1.DataType.binary:
          if (this.options.skipCovers)
            await this.tokenizer.ignore(W.size);
          else {
            const X = Buffer.alloc(W.size);
            await this.tokenizer.readBuffer(X), B = util$a.findZero(X, 0, X.length);
            const Y = X.toString("utf8", 0, B), Q = Buffer.from(X.slice(B + 1));
            this.metadata.addTag(tagFormat$1, K, {
              description: Y,
              data: Q
            });
          }
          break;
        case APEv2Token_1.DataType.external_info:
          debug$m(`Ignore external info ${K}`), await this.tokenizer.ignore(W.size);
          break;
        case APEv2Token_1.DataType.reserved:
          debug$m(`Ignore external info ${K}`), this.metadata.addWarning(`APEv2 header declares a reserved datatype for "${K}"`), await this.tokenizer.ignore(W.size);
          break;
      }
    }
  }
  async parseDescriptorExpansion(D) {
    return await this.tokenizer.ignore(D), this.parseHeader();
  }
  async parseHeader() {
    const D = await this.tokenizer.readToken(APEv2Token_1.Header);
    return this.metadata.setFormat("lossless", !0), this.metadata.setFormat("container", "Monkey's Audio"), this.metadata.setFormat("bitsPerSample", D.bitsPerSample), this.metadata.setFormat("sampleRate", D.sampleRate), this.metadata.setFormat("numberOfChannels", D.channel), this.metadata.setFormat("duration", APEv2Parser.calculateDuration(D)), {
      forwardBytes: this.ape.descriptor.seekTableBytes + this.ape.descriptor.headerDataBytes + this.ape.descriptor.apeFrameDataBytes + this.ape.descriptor.terminatingDataBytes
    };
  }
}
APEv2Parser$1.APEv2Parser = APEv2Parser;
(function(z) {
  Object.defineProperty(z, "__esModule", { value: !0 }), z.hasID3v1Header = z.ID3v1Parser = z.Genres = void 0;
  const D = browserExports, O = lib$1, F = Util, U = BasicParser$1, W = APEv2Parser$1, B = (0, D.default)("music-metadata:parser:ID3v1");
  z.Genres = [
    "Blues",
    "Classic Rock",
    "Country",
    "Dance",
    "Disco",
    "Funk",
    "Grunge",
    "Hip-Hop",
    "Jazz",
    "Metal",
    "New Age",
    "Oldies",
    "Other",
    "Pop",
    "R&B",
    "Rap",
    "Reggae",
    "Rock",
    "Techno",
    "Industrial",
    "Alternative",
    "Ska",
    "Death Metal",
    "Pranks",
    "Soundtrack",
    "Euro-Techno",
    "Ambient",
    "Trip-Hop",
    "Vocal",
    "Jazz+Funk",
    "Fusion",
    "Trance",
    "Classical",
    "Instrumental",
    "Acid",
    "House",
    "Game",
    "Sound Clip",
    "Gospel",
    "Noise",
    "Alt. Rock",
    "Bass",
    "Soul",
    "Punk",
    "Space",
    "Meditative",
    "Instrumental Pop",
    "Instrumental Rock",
    "Ethnic",
    "Gothic",
    "Darkwave",
    "Techno-Industrial",
    "Electronic",
    "Pop-Folk",
    "Eurodance",
    "Dream",
    "Southern Rock",
    "Comedy",
    "Cult",
    "Gangsta Rap",
    "Top 40",
    "Christian Rap",
    "Pop/Funk",
    "Jungle",
    "Native American",
    "Cabaret",
    "New Wave",
    "Psychedelic",
    "Rave",
    "Showtunes",
    "Trailer",
    "Lo-Fi",
    "Tribal",
    "Acid Punk",
    "Acid Jazz",
    "Polka",
    "Retro",
    "Musical",
    "Rock & Roll",
    "Hard Rock",
    "Folk",
    "Folk/Rock",
    "National Folk",
    "Swing",
    "Fast-Fusion",
    "Bebob",
    "Latin",
    "Revival",
    "Celtic",
    "Bluegrass",
    "Avantgarde",
    "Gothic Rock",
    "Progressive Rock",
    "Psychedelic Rock",
    "Symphonic Rock",
    "Slow Rock",
    "Big Band",
    "Chorus",
    "Easy Listening",
    "Acoustic",
    "Humour",
    "Speech",
    "Chanson",
    "Opera",
    "Chamber Music",
    "Sonata",
    "Symphony",
    "Booty Bass",
    "Primus",
    "Porn Groove",
    "Satire",
    "Slow Jam",
    "Club",
    "Tango",
    "Samba",
    "Folklore",
    "Ballad",
    "Power Ballad",
    "Rhythmic Soul",
    "Freestyle",
    "Duet",
    "Punk Rock",
    "Drum Solo",
    "A Cappella",
    "Euro-House",
    "Dance Hall",
    "Goa",
    "Drum & Bass",
    "Club-House",
    "Hardcore",
    "Terror",
    "Indie",
    "BritPop",
    "Negerpunk",
    "Polsk Punk",
    "Beat",
    "Christian Gangsta Rap",
    "Heavy Metal",
    "Black Metal",
    "Crossover",
    "Contemporary Christian",
    "Christian Rock",
    "Merengue",
    "Salsa",
    "Thrash Metal",
    "Anime",
    "JPop",
    "Synthpop",
    "Abstract",
    "Art Rock",
    "Baroque",
    "Bhangra",
    "Big Beat",
    "Breakbeat",
    "Chillout",
    "Downtempo",
    "Dub",
    "EBM",
    "Eclectic",
    "Electro",
    "Electroclash",
    "Emo",
    "Experimental",
    "Garage",
    "Global",
    "IDM",
    "Illbient",
    "Industro-Goth",
    "Jam Band",
    "Krautrock",
    "Leftfield",
    "Lounge",
    "Math Rock",
    "New Romantic",
    "Nu-Breakz",
    "Post-Punk",
    "Post-Rock",
    "Psytrance",
    "Shoegaze",
    "Space Rock",
    "Trop Rock",
    "World Music",
    "Neoclassical",
    "Audiobook",
    "Audio Theatre",
    "Neue Deutsche Welle",
    "Podcast",
    "Indie Rock",
    "G-Funk",
    "Dubstep",
    "Garage Rock",
    "Psybient"
  ];
  const K = {
    len: 128,
    /**
     * @param buf Buffer possibly holding the 128 bytes ID3v1.1 metadata header
     * @param off Offset in buffer in bytes
     * @returns ID3v1.1 header if first 3 bytes equals 'TAG', otherwise null is returned
     */
    get: (J, ee) => {
      const ae = new X(3).get(J, ee);
      return ae === "TAG" ? {
        header: ae,
        title: new X(30).get(J, ee + 3),
        artist: new X(30).get(J, ee + 33),
        album: new X(30).get(J, ee + 63),
        year: new X(4).get(J, ee + 93),
        comment: new X(28).get(J, ee + 97),
        // ID3v1.1 separator for track
        zeroByte: O.UINT8.get(J, ee + 127),
        // track: ID3v1.1 field added by Michael Mutschler
        track: O.UINT8.get(J, ee + 126),
        genre: O.UINT8.get(J, ee + 127)
      } : null;
    }
  };
  class X extends O.StringType {
    constructor(ee) {
      super(ee, "binary");
    }
    get(ee, ae) {
      let re = super.get(ee, ae);
      return re = F.trimRightNull(re), re = re.trim(), re.length > 0 ? re : void 0;
    }
  }
  class Y extends U.BasicParser {
    static getGenre(ee) {
      if (ee < z.Genres.length)
        return z.Genres[ee];
    }
    async parse() {
      if (!this.tokenizer.fileInfo.size) {
        B("Skip checking for ID3v1 because the file-size is unknown");
        return;
      }
      if (this.options.apeHeader) {
        this.tokenizer.ignore(this.options.apeHeader.offset - this.tokenizer.position);
        const re = new W.APEv2Parser();
        re.init(this.metadata, this.tokenizer, this.options), await re.parseTags(this.options.apeHeader.footer);
      }
      const ee = this.tokenizer.fileInfo.size - K.len;
      if (this.tokenizer.position > ee) {
        B("Already consumed the last 128 bytes");
        return;
      }
      const ae = await this.tokenizer.readToken(K, ee);
      if (ae) {
        B("ID3v1 header found at: pos=%s", this.tokenizer.fileInfo.size - K.len);
        for (const ie of ["title", "artist", "album", "comment", "track", "year"])
          ae[ie] && ae[ie] !== "" && this.addTag(ie, ae[ie]);
        const re = Y.getGenre(ae.genre);
        re && this.addTag("genre", re);
      } else
        B("ID3v1 header not found at: pos=%s", this.tokenizer.fileInfo.size - K.len);
    }
    addTag(ee, ae) {
      this.metadata.addTag("ID3v1", ee, ae);
    }
  }
  z.ID3v1Parser = Y;
  async function Q(J) {
    if (J.fileSize >= 128) {
      const ee = Buffer.alloc(3);
      return await J.randomRead(ee, 0, ee.length, J.fileSize - 128), ee.toString("binary") === "TAG";
    }
    return !1;
  }
  z.hasID3v1Header = Q;
})(ID3v1Parser);
Object.defineProperty(FrameParser$1, "__esModule", { value: !0 });
FrameParser$1.FrameParser = FrameParser$1.parseGenre = void 0;
const debug_1$l = browserExports, Token$r = lib$1, util$9 = Util, ID3v2Token_1$3 = ID3v2Token, ID3v1Parser_1$3 = ID3v1Parser, debug$l = (0, debug_1$l.default)("music-metadata:id3v2:frame-parser"), defaultEnc = "latin1";
function parseGenre(z) {
  const D = [];
  let O, F = "";
  for (const U of z)
    if (typeof O == "string")
      if (U === "(" && O === "")
        F += "(", O = void 0;
      else if (U === ")") {
        F !== "" && (D.push(F), F = "");
        const W = parseGenreCode(O);
        W && D.push(W), O = void 0;
      } else
        O += U;
    else
      U === "(" ? O = "" : F += U;
  return F && (D.length === 0 && F.match(/^\d*$/) && (F = ID3v1Parser_1$3.Genres[F]), D.push(F)), D;
}
FrameParser$1.parseGenre = parseGenre;
function parseGenreCode(z) {
  if (z === "RX")
    return "Remix";
  if (z === "CR")
    return "Cover";
  if (z.match(/^\d*$/))
    return ID3v1Parser_1$3.Genres[z];
}
class FrameParser {
  /**
   * Create id3v2 frame parser
   * @param major - Major version, e.g. (4) for  id3v2.4
   * @param warningCollector - Used to collect decode issue
   */
  constructor(D, O) {
    this.major = D, this.warningCollector = O;
  }
  readData(D, O, F) {
    if (D.length === 0) {
      this.warningCollector.addWarning(`id3v2.${this.major} header has empty tag type=${O}`);
      return;
    }
    const { encoding: U, bom: W } = ID3v2Token_1$3.TextEncodingToken.get(D, 0), B = D.length;
    let K = 0, X = [];
    const Y = FrameParser.getNullTerminatorLength(U);
    let Q;
    const J = {};
    switch (debug$l(`Parsing tag type=${O}, encoding=${U}, bom=${W}`), O !== "TXXX" && O[0] === "T" ? "T*" : O) {
      case "T*":
      case "IPLS":
      case "MVIN":
      case "MVNM":
      case "PCS":
      case "PCST":
        let ee;
        try {
          ee = util$9.decodeString(D.slice(1), U).replace(/\x00+$/, "");
        } catch (ie) {
          this.warningCollector.addWarning(`id3v2.${this.major} type=${O} header has invalid string value: ${ie.message}`);
        }
        switch (O) {
          case "TMCL":
          case "TIPL":
          case "IPLS":
            X = this.splitValue(O, ee), X = FrameParser.functionList(X);
            break;
          case "TRK":
          case "TRCK":
          case "TPOS":
            X = ee;
            break;
          case "TCOM":
          case "TEXT":
          case "TOLY":
          case "TOPE":
          case "TPE1":
          case "TSRC":
            X = this.splitValue(O, ee);
            break;
          case "TCO":
          case "TCON":
            X = this.splitValue(O, ee).map((ie) => parseGenre(ie)).reduce((ie, ue) => ie.concat(ue), []);
            break;
          case "PCS":
          case "PCST":
            X = this.major >= 4 ? this.splitValue(O, ee) : [ee], X = Array.isArray(X) && X[0] === "" ? 1 : 0;
            break;
          default:
            X = this.major >= 4 ? this.splitValue(O, ee) : [ee];
        }
        break;
      case "TXXX":
        X = FrameParser.readIdentifierAndData(D, K + 1, B, U), X = {
          description: X.id,
          text: this.splitValue(O, util$9.decodeString(X.data, U).replace(/\x00+$/, ""))
        };
        break;
      case "PIC":
      case "APIC":
        if (F) {
          const ie = {};
          switch (K += 1, this.major) {
            case 2:
              ie.format = util$9.decodeString(D.slice(K, K + 3), "latin1"), K += 3;
              break;
            case 3:
            case 4:
              Q = util$9.findZero(D, K, B, defaultEnc), ie.format = util$9.decodeString(D.slice(K, Q), defaultEnc), K = Q + 1;
              break;
            default:
              throw new Error("Warning: unexpected major versionIndex: " + this.major);
          }
          ie.format = FrameParser.fixPictureMimeType(ie.format), ie.type = ID3v2Token_1$3.AttachedPictureType[D[K]], K += 1, Q = util$9.findZero(D, K, B, U), ie.description = util$9.decodeString(D.slice(K, Q), U), K = Q + Y, ie.data = Buffer.from(D.slice(K, B)), X = ie;
        }
        break;
      case "CNT":
      case "PCNT":
        X = Token$r.UINT32_BE.get(D, 0);
        break;
      case "SYLT":
        for (K += 7, X = []; K < B; ) {
          const ie = D.slice(K, K = util$9.findZero(D, K, B, U));
          K += 5, X.push(util$9.decodeString(ie, U));
        }
        break;
      case "ULT":
      case "USLT":
      case "COM":
      case "COMM":
        K += 1, J.language = util$9.decodeString(D.slice(K, K + 3), defaultEnc), K += 3, Q = util$9.findZero(D, K, B, U), J.description = util$9.decodeString(D.slice(K, Q), U), K = Q + Y, J.text = util$9.decodeString(D.slice(K, B), U).replace(/\x00+$/, ""), X = [J];
        break;
      case "UFID":
        X = FrameParser.readIdentifierAndData(D, K, B, defaultEnc), X = { owner_identifier: X.id, identifier: X.data };
        break;
      case "PRIV":
        X = FrameParser.readIdentifierAndData(D, K, B, defaultEnc), X = { owner_identifier: X.id, data: X.data };
        break;
      case "POPM":
        Q = util$9.findZero(D, K, B, defaultEnc);
        const ae = util$9.decodeString(D.slice(K, Q), defaultEnc);
        K = Q + 1;
        const re = B - K;
        X = {
          email: ae,
          rating: Token$r.UINT8.get(D, K),
          counter: re >= 5 ? Token$r.UINT32_BE.get(D, K + 1) : void 0
        };
        break;
      case "GEOB": {
        Q = util$9.findZero(D, K + 1, B, U);
        const ie = util$9.decodeString(D.slice(K + 1, Q), defaultEnc);
        K = Q + 1, Q = util$9.findZero(D, K, B - K, U);
        const ue = util$9.decodeString(D.slice(K, Q), defaultEnc);
        K = Q + 1, Q = util$9.findZero(D, K, B - K, U);
        const q = util$9.decodeString(D.slice(K, Q), defaultEnc);
        X = {
          type: ie,
          filename: ue,
          description: q,
          data: D.slice(K + 1, B)
        };
        break;
      }
      case "WCOM":
      case "WCOP":
      case "WOAF":
      case "WOAR":
      case "WOAS":
      case "WORS":
      case "WPAY":
      case "WPUB":
        X = util$9.decodeString(D.slice(K, Q), defaultEnc);
        break;
      case "WXXX": {
        Q = util$9.findZero(D, K + 1, B, U);
        const ie = util$9.decodeString(D.slice(K + 1, Q), U);
        K = Q + (U === "utf16le" ? 2 : 1), X = { description: ie, url: util$9.decodeString(D.slice(K, B), defaultEnc) };
        break;
      }
      case "WFD":
      case "WFED":
        X = util$9.decodeString(D.slice(K + 1, util$9.findZero(D, K + 1, B, U)), U);
        break;
      case "MCDI": {
        X = D.slice(0, B);
        break;
      }
      default:
        debug$l("Warning: unsupported id3v2-tag-type: " + O);
        break;
    }
    return X;
  }
  static fixPictureMimeType(D) {
    switch (D = D.toLocaleLowerCase(), D) {
      case "jpg":
        return "image/jpeg";
      case "png":
        return "image/png";
    }
    return D;
  }
  /**
   * Converts TMCL (Musician credits list) or TIPL (Involved people list)
   * @param entries
   */
  static functionList(D) {
    const O = {};
    for (let F = 0; F + 1 < D.length; F += 2) {
      const U = D[F + 1].split(",");
      O[D[F]] = O.hasOwnProperty(D[F]) ? O[D[F]].concat(U) : U;
    }
    return O;
  }
  /**
   * id3v2.4 defines that multiple T* values are separated by 0x00
   * id3v2.3 defines that TCOM, TEXT, TOLY, TOPE & TPE1 values are separated by /
   * @param tag - Tag name
   * @param text - Concatenated tag value
   * @returns Split tag value
   */
  splitValue(D, O) {
    let F;
    return this.major < 4 ? (F = O.split(/\x00/g), F.length > 1 ? this.warningCollector.addWarning(`ID3v2.${this.major} ${D} uses non standard null-separator.`) : F = O.split(/\//g)) : F = O.split(/\x00/g), FrameParser.trimArray(F);
  }
  static trimArray(D) {
    return D.map((O) => O.replace(/\x00+$/, "").trim());
  }
  static readIdentifierAndData(D, O, F, U) {
    const W = util$9.findZero(D, O, F, U), B = util$9.decodeString(D.slice(O, W), U);
    return O = W + FrameParser.getNullTerminatorLength(U), { id: B, data: D.slice(O, F) };
  }
  static getNullTerminatorLength(D) {
    return D === "utf16le" ? 2 : 1;
  }
}
FrameParser$1.FrameParser = FrameParser;
Object.defineProperty(ID3v2Parser$1, "__esModule", { value: !0 });
ID3v2Parser$1.ID3v2Parser = void 0;
const Token$q = lib$1, util$8 = Util, FrameParser_1 = FrameParser$1, ID3v2Token_1$2 = ID3v2Token;
class ID3v2Parser {
  static removeUnsyncBytes(D) {
    let O = 0, F = 0;
    for (; O < D.length - 1; )
      O !== F && (D[F] = D[O]), O += D[O] === 255 && D[O + 1] === 0 ? 2 : 1, F++;
    return O < D.length && (D[F++] = D[O]), D.slice(0, F);
  }
  static getFrameHeaderLength(D) {
    switch (D) {
      case 2:
        return 6;
      case 3:
      case 4:
        return 10;
      default:
        throw new Error("header versionIndex is incorrect");
    }
  }
  static readFrameFlags(D) {
    return {
      status: {
        tag_alter_preservation: util$8.getBit(D, 0, 6),
        file_alter_preservation: util$8.getBit(D, 0, 5),
        read_only: util$8.getBit(D, 0, 4)
      },
      format: {
        grouping_identity: util$8.getBit(D, 1, 7),
        compression: util$8.getBit(D, 1, 3),
        encryption: util$8.getBit(D, 1, 2),
        unsynchronisation: util$8.getBit(D, 1, 1),
        data_length_indicator: util$8.getBit(D, 1, 0)
      }
    };
  }
  static readFrameData(D, O, F, U, W) {
    const B = new FrameParser_1.FrameParser(F, W);
    switch (F) {
      case 2:
        return B.readData(D, O.id, U);
      case 3:
      case 4:
        return O.flags.format.unsynchronisation && (D = ID3v2Parser.removeUnsyncBytes(D)), O.flags.format.data_length_indicator && (D = D.slice(4, D.length)), B.readData(D, O.id, U);
      default:
        throw new Error("Unexpected majorVer: " + F);
    }
  }
  /**
   * Create a combined tag key, of tag & description
   * @param tag e.g.: COM
   * @param description e.g. iTunPGAP
   * @returns string e.g. COM:iTunPGAP
   */
  static makeDescriptionTagName(D, O) {
    return D + (O ? ":" + O : "");
  }
  async parse(D, O, F) {
    this.tokenizer = O, this.metadata = D, this.options = F;
    const U = await this.tokenizer.readToken(ID3v2Token_1$2.ID3v2Header);
    if (U.fileIdentifier !== "ID3")
      throw new Error("expected ID3-header file-identifier 'ID3' was not found");
    return this.id3Header = U, this.headerType = "ID3v2." + U.version.major, U.flags.isExtendedHeader ? this.parseExtendedHeader() : this.parseId3Data(U.size);
  }
  async parseExtendedHeader() {
    const D = await this.tokenizer.readToken(ID3v2Token_1$2.ExtendedHeader), O = D.size - ID3v2Token_1$2.ExtendedHeader.len;
    return O > 0 ? this.parseExtendedHeaderData(O, D.size) : this.parseId3Data(this.id3Header.size - D.size);
  }
  async parseExtendedHeaderData(D, O) {
    return await this.tokenizer.ignore(D), this.parseId3Data(this.id3Header.size - O);
  }
  async parseId3Data(D) {
    const O = await this.tokenizer.readToken(new Token$q.Uint8ArrayType(D));
    for (const F of this.parseMetadata(O))
      if (F.id === "TXXX") {
        if (F.value)
          for (const U of F.value.text)
            this.addTag(ID3v2Parser.makeDescriptionTagName(F.id, F.value.description), U);
      } else if (F.id === "COM")
        for (const U of F.value)
          this.addTag(ID3v2Parser.makeDescriptionTagName(F.id, U.description), U.text);
      else if (F.id === "COMM")
        for (const U of F.value)
          this.addTag(ID3v2Parser.makeDescriptionTagName(F.id, U.description), U);
      else if (Array.isArray(F.value))
        for (const U of F.value)
          this.addTag(F.id, U);
      else
        this.addTag(F.id, F.value);
  }
  addTag(D, O) {
    this.metadata.addTag(this.headerType, D, O);
  }
  parseMetadata(D) {
    let O = 0;
    const F = [];
    for (; O !== D.length; ) {
      const U = ID3v2Parser.getFrameHeaderLength(this.id3Header.version.major);
      if (O + U > D.length) {
        this.metadata.addWarning("Illegal ID3v2 tag length");
        break;
      }
      const W = D.slice(O, O += U), B = this.readFrameHeader(W, this.id3Header.version.major), K = D.slice(O, O += B.length), X = ID3v2Parser.readFrameData(K, B, this.id3Header.version.major, !this.options.skipCovers, this.metadata);
      X && F.push({ id: B.id, value: X });
    }
    return F;
  }
  readFrameHeader(D, O) {
    let F;
    switch (O) {
      case 2:
        F = {
          id: Buffer.from(D.slice(0, 3)).toString("ascii"),
          length: Token$q.UINT24_BE.get(D, 3)
        }, F.id.match(/[A-Z0-9]{3}/g) || this.metadata.addWarning(`Invalid ID3v2.${this.id3Header.version.major} frame-header-ID: ${F.id}`);
        break;
      case 3:
      case 4:
        F = {
          id: Buffer.from(D.slice(0, 4)).toString("ascii"),
          length: (O === 4 ? ID3v2Token_1$2.UINT32SYNCSAFE : Token$q.UINT32_BE).get(D, 4),
          flags: ID3v2Parser.readFrameFlags(D.slice(8, 10))
        }, F.id.match(/[A-Z0-9]{4}/g) || this.metadata.addWarning(`Invalid ID3v2.${this.id3Header.version.major} frame-header-ID: ${F.id}`);
        break;
      default:
        throw new Error("Unexpected majorVer: " + O);
    }
    return F;
  }
}
ID3v2Parser$1.ID3v2Parser = ID3v2Parser;
var AiffToken$1 = {};
Object.defineProperty(AiffToken$1, "__esModule", { value: !0 });
AiffToken$1.Common = void 0;
const Token$p = lib$1, FourCC_1$a = FourCC;
class Common {
  constructor(D, O) {
    this.isAifc = O;
    const F = O ? 22 : 18;
    if (D.chunkSize < F)
      throw new Error(`COMMON CHUNK size should always be at least ${F}`);
    this.len = D.chunkSize;
  }
  get(D, O) {
    const F = D.readUInt16BE(O + 8) - 16398, U = D.readUInt16BE(O + 8 + 2), W = {
      numChannels: D.readUInt16BE(O),
      numSampleFrames: D.readUInt32BE(O + 2),
      sampleSize: D.readUInt16BE(O + 6),
      sampleRate: F < 0 ? U >> Math.abs(F) : U << F
    };
    if (this.isAifc) {
      if (W.compressionType = FourCC_1$a.FourCcToken.get(D, O + 18), this.len > 22) {
        const B = D.readInt8(O + 22);
        if (B > 0) {
          const K = (B + 1) % 2;
          if (23 + B + K === this.len)
            W.compressionName = new Token$p.StringType(B, "binary").get(D, O + 23);
          else
            throw new Error("Illegal pstring length");
        } else
          W.compressionName = void 0;
      }
    } else
      W.compressionName = "PCM";
    return W;
  }
}
AiffToken$1.Common = Common;
var iff$1 = {};
Object.defineProperty(iff$1, "__esModule", { value: !0 });
iff$1.Header = void 0;
const Token$o = lib$1, FourCC_1$9 = FourCC;
iff$1.Header = {
  len: 8,
  get: (z, D) => ({
    // Chunk type ID
    chunkID: FourCC_1$9.FourCcToken.get(z, D),
    // Chunk size
    chunkSize: Number(BigInt(Token$o.UINT32_BE.get(z, D + 4)))
  })
};
Object.defineProperty(AiffParser, "__esModule", { value: !0 });
AiffParser.AIFFParser = void 0;
const Token$n = lib$1, debug_1$k = browserExports, strtok3$3 = core$1, ID3v2Parser_1$4 = ID3v2Parser$1, FourCC_1$8 = FourCC, BasicParser_1$a = BasicParser$1, AiffToken = AiffToken$1, iff = iff$1, debug$k = (0, debug_1$k.default)("music-metadata:parser:aiff"), compressionTypes = {
  NONE: "not compressed	PCM	Apple Computer",
  sowt: "PCM (byte swapped)",
  fl32: "32-bit floating point IEEE 32-bit float",
  fl64: "64-bit floating point IEEE 64-bit float	Apple Computer",
  alaw: "ALaw 2:1	8-bit ITU-T G.711 A-law",
  ulaw: "Law 2:1	8-bit ITU-T G.711 -law	Apple Computer",
  ULAW: "CCITT G.711 u-law 8-bit ITU-T G.711 -law",
  ALAW: "CCITT G.711 A-law 8-bit ITU-T G.711 A-law",
  FL32: "Float 32	IEEE 32-bit float "
};
class AIFFParser extends BasicParser_1$a.BasicParser {
  async parse() {
    if ((await this.tokenizer.readToken(iff.Header)).chunkID !== "FORM")
      throw new Error("Invalid Chunk-ID, expected 'FORM'");
    const O = await this.tokenizer.readToken(FourCC_1$8.FourCcToken);
    switch (O) {
      case "AIFF":
        this.metadata.setFormat("container", O), this.isCompressed = !1;
        break;
      case "AIFC":
        this.metadata.setFormat("container", "AIFF-C"), this.isCompressed = !0;
        break;
      default:
        throw Error("Unsupported AIFF type: " + O);
    }
    this.metadata.setFormat("lossless", !this.isCompressed);
    try {
      for (; !this.tokenizer.fileInfo.size || this.tokenizer.fileInfo.size - this.tokenizer.position >= iff.Header.len; ) {
        debug$k("Reading AIFF chunk at offset=" + this.tokenizer.position);
        const F = await this.tokenizer.readToken(iff.Header), U = 2 * Math.round(F.chunkSize / 2), W = await this.readData(F);
        await this.tokenizer.ignore(U - W);
      }
    } catch (F) {
      if (F instanceof strtok3$3.EndOfStreamError)
        debug$k("End-of-stream");
      else
        throw F;
    }
  }
  async readData(D) {
    var O;
    switch (D.chunkID) {
      case "COMM":
        const F = await this.tokenizer.readToken(new AiffToken.Common(D, this.isCompressed));
        return this.metadata.setFormat("bitsPerSample", F.sampleSize), this.metadata.setFormat("sampleRate", F.sampleRate), this.metadata.setFormat("numberOfChannels", F.numChannels), this.metadata.setFormat("numberOfSamples", F.numSampleFrames), this.metadata.setFormat("duration", F.numSampleFrames / F.sampleRate), this.metadata.setFormat("codec", (O = F.compressionName) !== null && O !== void 0 ? O : compressionTypes[F.compressionType]), D.chunkSize;
      case "ID3 ":
        const U = await this.tokenizer.readToken(new Token$n.Uint8ArrayType(D.chunkSize)), W = strtok3$3.fromBuffer(U);
        return await new ID3v2Parser_1$4.ID3v2Parser().parse(this.metadata, W, this.options), D.chunkSize;
      case "SSND":
        return this.metadata.format.duration && this.metadata.setFormat("bitrate", 8 * D.chunkSize / this.metadata.format.duration), 0;
      case "NAME":
      case "AUTH":
      case "(c) ":
      case "ANNO":
        return this.readTextChunk(D);
      default:
        return debug$k(`Ignore chunk id=${D.chunkID}, size=${D.chunkSize}`), 0;
    }
  }
  async readTextChunk(D) {
    return (await this.tokenizer.readToken(new Token$n.StringType(D.chunkSize, "ascii"))).split("\0").map((F) => F.trim()).filter((F) => F && F.length > 0).forEach((F) => {
      this.metadata.addTag("AIFF", D.chunkID, F.trim());
    }), D.chunkSize;
  }
}
AiffParser.AIFFParser = AIFFParser;
var AsfParser$1 = {}, GUID$1 = {};
Object.defineProperty(GUID$1, "__esModule", { value: !0 });
class GUID {
  static fromBin(D, O = 0) {
    return new GUID(this.decode(D, O));
  }
  /**
   * Decode GUID in format like "B503BF5F-2EA9-CF11-8EE3-00C00C205365"
   * @param objectId Binary GUID
   * @param offset Read offset in bytes, default 0
   * @returns GUID as dashed hexadecimal representation
   */
  static decode(D, O = 0) {
    return (D.readUInt32LE(O).toString(16) + "-" + D.readUInt16LE(O + 4).toString(16) + "-" + D.readUInt16LE(O + 6).toString(16) + "-" + D.readUInt16BE(O + 8).toString(16) + "-" + D.slice(O + 10, O + 16).toString("hex")).toUpperCase();
  }
  /**
   * Decode stream type
   * @param mediaType Media type GUID
   * @returns Media type
   */
  static decodeMediaType(D) {
    switch (D.str) {
      case GUID.AudioMedia.str:
        return "audio";
      case GUID.VideoMedia.str:
        return "video";
      case GUID.CommandMedia.str:
        return "command";
      case GUID.Degradable_JPEG_Media.str:
        return "degradable-jpeg";
      case GUID.FileTransferMedia.str:
        return "file-transfer";
      case GUID.BinaryMedia.str:
        return "binary";
    }
  }
  /**
   * Encode GUID
   * @param guid GUID like: "B503BF5F-2EA9-CF11-8EE3-00C00C205365"
   * @returns Encoded Binary GUID
   */
  static encode(D) {
    const O = Buffer.alloc(16);
    return O.writeUInt32LE(parseInt(D.slice(0, 8), 16), 0), O.writeUInt16LE(parseInt(D.slice(9, 13), 16), 4), O.writeUInt16LE(parseInt(D.slice(14, 18), 16), 6), Buffer.from(D.slice(19, 23), "hex").copy(O, 8), Buffer.from(D.slice(24), "hex").copy(O, 10), O;
  }
  constructor(D) {
    this.str = D;
  }
  equals(D) {
    return this.str === D.str;
  }
  toBin() {
    return GUID.encode(this.str);
  }
}
GUID.HeaderObject = new GUID("75B22630-668E-11CF-A6D9-00AA0062CE6C");
GUID.DataObject = new GUID("75B22636-668E-11CF-A6D9-00AA0062CE6C");
GUID.SimpleIndexObject = new GUID("33000890-E5B1-11CF-89F4-00A0C90349CB");
GUID.IndexObject = new GUID("D6E229D3-35DA-11D1-9034-00A0C90349BE");
GUID.MediaObjectIndexObject = new GUID("FEB103F8-12AD-4C64-840F-2A1D2F7AD48C");
GUID.TimecodeIndexObject = new GUID("3CB73FD0-0C4A-4803-953D-EDF7B6228F0C");
GUID.FilePropertiesObject = new GUID("8CABDCA1-A947-11CF-8EE4-00C00C205365");
GUID.StreamPropertiesObject = new GUID("B7DC0791-A9B7-11CF-8EE6-00C00C205365");
GUID.HeaderExtensionObject = new GUID("5FBF03B5-A92E-11CF-8EE3-00C00C205365");
GUID.CodecListObject = new GUID("86D15240-311D-11D0-A3A4-00A0C90348F6");
GUID.ScriptCommandObject = new GUID("1EFB1A30-0B62-11D0-A39B-00A0C90348F6");
GUID.MarkerObject = new GUID("F487CD01-A951-11CF-8EE6-00C00C205365");
GUID.BitrateMutualExclusionObject = new GUID("D6E229DC-35DA-11D1-9034-00A0C90349BE");
GUID.ErrorCorrectionObject = new GUID("75B22635-668E-11CF-A6D9-00AA0062CE6C");
GUID.ContentDescriptionObject = new GUID("75B22633-668E-11CF-A6D9-00AA0062CE6C");
GUID.ExtendedContentDescriptionObject = new GUID("D2D0A440-E307-11D2-97F0-00A0C95EA850");
GUID.ContentBrandingObject = new GUID("2211B3FA-BD23-11D2-B4B7-00A0C955FC6E");
GUID.StreamBitratePropertiesObject = new GUID("7BF875CE-468D-11D1-8D82-006097C9A2B2");
GUID.ContentEncryptionObject = new GUID("2211B3FB-BD23-11D2-B4B7-00A0C955FC6E");
GUID.ExtendedContentEncryptionObject = new GUID("298AE614-2622-4C17-B935-DAE07EE9289C");
GUID.DigitalSignatureObject = new GUID("2211B3FC-BD23-11D2-B4B7-00A0C955FC6E");
GUID.PaddingObject = new GUID("1806D474-CADF-4509-A4BA-9AABCB96AAE8");
GUID.ExtendedStreamPropertiesObject = new GUID("14E6A5CB-C672-4332-8399-A96952065B5A");
GUID.AdvancedMutualExclusionObject = new GUID("A08649CF-4775-4670-8A16-6E35357566CD");
GUID.GroupMutualExclusionObject = new GUID("D1465A40-5A79-4338-B71B-E36B8FD6C249");
GUID.StreamPrioritizationObject = new GUID("D4FED15B-88D3-454F-81F0-ED5C45999E24");
GUID.BandwidthSharingObject = new GUID("A69609E6-517B-11D2-B6AF-00C04FD908E9");
GUID.LanguageListObject = new GUID("7C4346A9-EFE0-4BFC-B229-393EDE415C85");
GUID.MetadataObject = new GUID("C5F8CBEA-5BAF-4877-8467-AA8C44FA4CCA");
GUID.MetadataLibraryObject = new GUID("44231C94-9498-49D1-A141-1D134E457054");
GUID.IndexParametersObject = new GUID("D6E229DF-35DA-11D1-9034-00A0C90349BE");
GUID.MediaObjectIndexParametersObject = new GUID("6B203BAD-3F11-48E4-ACA8-D7613DE2CFA7");
GUID.TimecodeIndexParametersObject = new GUID("F55E496D-9797-4B5D-8C8B-604DFE9BFB24");
GUID.CompatibilityObject = new GUID("26F18B5D-4584-47EC-9F5F-0E651F0452C9");
GUID.AdvancedContentEncryptionObject = new GUID("43058533-6981-49E6-9B74-AD12CB86D58C");
GUID.AudioMedia = new GUID("F8699E40-5B4D-11CF-A8FD-00805F5C442B");
GUID.VideoMedia = new GUID("BC19EFC0-5B4D-11CF-A8FD-00805F5C442B");
GUID.CommandMedia = new GUID("59DACFC0-59E6-11D0-A3AC-00A0C90348F6");
GUID.JFIF_Media = new GUID("B61BE100-5B4E-11CF-A8FD-00805F5C442B");
GUID.Degradable_JPEG_Media = new GUID("35907DE0-E415-11CF-A917-00805F5C442B");
GUID.FileTransferMedia = new GUID("91BD222C-F21C-497A-8B6D-5AA86BFC0185");
GUID.BinaryMedia = new GUID("3AFB65E2-47EF-40F2-AC2C-70A90D71D343");
GUID.ASF_Index_Placeholder_Object = new GUID("D9AADE20-7C17-4F9C-BC28-8555DD98E2A2");
GUID$1.default = GUID;
var AsfObject$1 = {}, AsfUtil$1 = {};
Object.defineProperty(AsfUtil$1, "__esModule", { value: !0 });
AsfUtil$1.AsfUtil = void 0;
const Token$m = lib$1, util$7 = Util;
class AsfUtil {
  static getParserForAttr(D) {
    return AsfUtil.attributeParsers[D];
  }
  static parseUnicodeAttr(D) {
    return util$7.stripNulls(util$7.decodeString(D, "utf16le"));
  }
  static parseByteArrayAttr(D) {
    return Buffer.from(D);
  }
  static parseBoolAttr(D, O = 0) {
    return AsfUtil.parseWordAttr(D, O) === 1;
  }
  static parseDWordAttr(D, O = 0) {
    return D.readUInt32LE(O);
  }
  static parseQWordAttr(D, O = 0) {
    return Token$m.UINT64_LE.get(D, O);
  }
  static parseWordAttr(D, O = 0) {
    return D.readUInt16LE(O);
  }
}
AsfUtil.attributeParsers = [
  AsfUtil.parseUnicodeAttr,
  AsfUtil.parseByteArrayAttr,
  AsfUtil.parseBoolAttr,
  AsfUtil.parseDWordAttr,
  AsfUtil.parseQWordAttr,
  AsfUtil.parseWordAttr,
  AsfUtil.parseByteArrayAttr
];
AsfUtil$1.AsfUtil = AsfUtil;
(function(z) {
  Object.defineProperty(z, "__esModule", { value: !0 }), z.WmPictureToken = z.MetadataLibraryObjectState = z.MetadataObjectState = z.ExtendedStreamPropertiesObjectState = z.ExtendedContentDescriptionObjectState = z.ContentDescriptionObjectState = z.readCodecEntries = z.HeaderExtensionObject = z.StreamPropertiesObject = z.FilePropertiesObject = z.IgnoreObjectState = z.State = z.HeaderObjectToken = z.TopLevelHeaderObjectToken = z.DataType = void 0;
  const D = Util, O = lib$1, F = GUID$1, U = AsfUtil$1, W = ID3v2Token;
  (function(me) {
    me[me.UnicodeString = 0] = "UnicodeString", me[me.ByteArray = 1] = "ByteArray", me[me.Bool = 2] = "Bool", me[me.DWord = 3] = "DWord", me[me.QWord = 4] = "QWord", me[me.Word = 5] = "Word";
  })(z.DataType || (z.DataType = {})), z.TopLevelHeaderObjectToken = {
    len: 30,
    get: (me, de) => ({
      objectId: F.default.fromBin(new O.BufferType(16).get(me, de)),
      objectSize: Number(O.UINT64_LE.get(me, de + 16)),
      numberOfHeaderObjects: O.UINT32_LE.get(me, de + 24)
      // Reserved: 2 bytes
    })
  }, z.HeaderObjectToken = {
    len: 24,
    get: (me, de) => ({
      objectId: F.default.fromBin(new O.BufferType(16).get(me, de)),
      objectSize: Number(O.UINT64_LE.get(me, de + 16))
    })
  };
  class B {
    constructor(de) {
      this.len = Number(de.objectSize) - z.HeaderObjectToken.len;
    }
    postProcessTag(de, be, _e, Me) {
      if (be === "WM/Picture")
        de.push({ id: be, value: we.fromBuffer(Me) });
      else {
        const Ne = U.AsfUtil.getParserForAttr(_e);
        if (!Ne)
          throw new Error("unexpected value headerType: " + _e);
        de.push({ id: be, value: Ne(Me) });
      }
    }
  }
  z.State = B;
  class K extends B {
    constructor(de) {
      super(de);
    }
    get(de, be) {
      return null;
    }
  }
  z.IgnoreObjectState = K;
  class X extends B {
    constructor(de) {
      super(de);
    }
    get(de, be) {
      return {
        fileId: F.default.fromBin(de, be),
        fileSize: O.UINT64_LE.get(de, be + 16),
        creationDate: O.UINT64_LE.get(de, be + 24),
        dataPacketsCount: O.UINT64_LE.get(de, be + 32),
        playDuration: O.UINT64_LE.get(de, be + 40),
        sendDuration: O.UINT64_LE.get(de, be + 48),
        preroll: O.UINT64_LE.get(de, be + 56),
        flags: {
          broadcast: D.getBit(de, be + 64, 24),
          seekable: D.getBit(de, be + 64, 25)
        },
        // flagsNumeric: Token.UINT32_LE.get(buf, off + 64),
        minimumDataPacketSize: O.UINT32_LE.get(de, be + 68),
        maximumDataPacketSize: O.UINT32_LE.get(de, be + 72),
        maximumBitrate: O.UINT32_LE.get(de, be + 76)
      };
    }
  }
  X.guid = F.default.FilePropertiesObject, z.FilePropertiesObject = X;
  class Y extends B {
    constructor(de) {
      super(de);
    }
    get(de, be) {
      return {
        streamType: F.default.decodeMediaType(F.default.fromBin(de, be)),
        errorCorrectionType: F.default.fromBin(de, be + 8)
        // ToDo
      };
    }
  }
  Y.guid = F.default.StreamPropertiesObject, z.StreamPropertiesObject = Y;
  class Q {
    constructor() {
      this.len = 22;
    }
    get(de, be) {
      return {
        reserved1: F.default.fromBin(de, be),
        reserved2: de.readUInt16LE(be + 16),
        extensionDataSize: de.readUInt32LE(be + 18)
      };
    }
  }
  Q.guid = F.default.HeaderExtensionObject, z.HeaderExtensionObject = Q;
  const J = {
    len: 20,
    get: (me, de) => ({
      entryCount: me.readUInt16LE(de + 16)
    })
  };
  async function ee(me) {
    const de = await me.readNumber(O.UINT16_LE);
    return (await me.readToken(new O.StringType(de * 2, "utf16le"))).replace("\0", "");
  }
  async function ae(me) {
    const de = await me.readToken(J), be = [];
    for (let _e = 0; _e < de.entryCount; ++_e)
      be.push(await ie(me));
    return be;
  }
  z.readCodecEntries = ae;
  async function re(me) {
    const de = await me.readNumber(O.UINT16_LE), be = Buffer.alloc(de);
    return await me.readBuffer(be), be;
  }
  async function ie(me) {
    const de = await me.readNumber(O.UINT16_LE);
    return {
      type: {
        videoCodec: (de & 1) === 1,
        audioCodec: (de & 2) === 2
      },
      codecName: await ee(me),
      description: await ee(me),
      information: await re(me)
    };
  }
  class ue extends B {
    constructor(de) {
      super(de);
    }
    get(de, be) {
      const _e = [];
      let Me = be + 10;
      for (let Ne = 0; Ne < ue.contentDescTags.length; ++Ne) {
        const Ee = de.readUInt16LE(be + Ne * 2);
        if (Ee > 0) {
          const $e = ue.contentDescTags[Ne], De = Me + Ee;
          _e.push({ id: $e, value: U.AsfUtil.parseUnicodeAttr(de.slice(Me, De)) }), Me = De;
        }
      }
      return _e;
    }
  }
  ue.guid = F.default.ContentDescriptionObject, ue.contentDescTags = ["Title", "Author", "Copyright", "Description", "Rating"], z.ContentDescriptionObjectState = ue;
  class q extends B {
    constructor(de) {
      super(de);
    }
    get(de, be) {
      const _e = [], Me = de.readUInt16LE(be);
      let Ne = be + 2;
      for (let Ee = 0; Ee < Me; Ee += 1) {
        const $e = de.readUInt16LE(Ne);
        Ne += 2;
        const De = U.AsfUtil.parseUnicodeAttr(de.slice(Ne, Ne + $e));
        Ne += $e;
        const Fe = de.readUInt16LE(Ne);
        Ne += 2;
        const Be = de.readUInt16LE(Ne);
        Ne += 2;
        const We = de.slice(Ne, Ne + Be);
        Ne += Be, this.postProcessTag(_e, De, Fe, We);
      }
      return _e;
    }
  }
  q.guid = F.default.ExtendedContentDescriptionObject, z.ExtendedContentDescriptionObjectState = q;
  class ne extends B {
    constructor(de) {
      super(de);
    }
    get(de, be) {
      return {
        startTime: O.UINT64_LE.get(de, be),
        endTime: O.UINT64_LE.get(de, be + 8),
        dataBitrate: de.readInt32LE(be + 12),
        bufferSize: de.readInt32LE(be + 16),
        initialBufferFullness: de.readInt32LE(be + 20),
        alternateDataBitrate: de.readInt32LE(be + 24),
        alternateBufferSize: de.readInt32LE(be + 28),
        alternateInitialBufferFullness: de.readInt32LE(be + 32),
        maximumObjectSize: de.readInt32LE(be + 36),
        flags: {
          reliableFlag: D.getBit(de, be + 40, 0),
          seekableFlag: D.getBit(de, be + 40, 1),
          resendLiveCleanpointsFlag: D.getBit(de, be + 40, 2)
        },
        // flagsNumeric: Token.UINT32_LE.get(buf, off + 64),
        streamNumber: de.readInt16LE(be + 42),
        streamLanguageId: de.readInt16LE(be + 44),
        averageTimePerFrame: de.readInt32LE(be + 52),
        streamNameCount: de.readInt32LE(be + 54),
        payloadExtensionSystems: de.readInt32LE(be + 56),
        streamNames: [],
        streamPropertiesObject: null
      };
    }
  }
  ne.guid = F.default.ExtendedStreamPropertiesObject, z.ExtendedStreamPropertiesObjectState = ne;
  class ce extends B {
    constructor(de) {
      super(de);
    }
    get(de, be) {
      const _e = [], Me = Buffer.from(de), Ne = Me.readUInt16LE(be);
      let Ee = be + 2;
      for (let $e = 0; $e < Ne; $e += 1) {
        Ee += 4;
        const De = Me.readUInt16LE(Ee);
        Ee += 2;
        const Fe = Me.readUInt16LE(Ee);
        Ee += 2;
        const Be = Me.readUInt32LE(Ee);
        Ee += 4;
        const We = U.AsfUtil.parseUnicodeAttr(Me.slice(Ee, Ee + De));
        Ee += De;
        const Ve = Me.slice(Ee, Ee + Be);
        Ee += Be, this.postProcessTag(_e, We, Fe, Ve);
      }
      return _e;
    }
  }
  ce.guid = F.default.MetadataObject, z.MetadataObjectState = ce;
  class he extends ce {
    constructor(de) {
      super(de);
    }
  }
  he.guid = F.default.MetadataLibraryObject, z.MetadataLibraryObjectState = he;
  class we {
    static fromBase64(de) {
      return this.fromBuffer(Buffer.from(de, "base64"));
    }
    static fromBuffer(de) {
      return new we(de.length).get(de, 0);
    }
    constructor(de) {
      this.len = de;
    }
    get(de, be) {
      const _e = de.readUInt8(be++), Me = de.readInt32LE(be);
      let Ne = 5;
      for (; de.readUInt16BE(Ne) !== 0; )
        Ne += 2;
      const Ee = de.slice(5, Ne).toString("utf16le");
      for (; de.readUInt16BE(Ne) !== 0; )
        Ne += 2;
      const $e = de.slice(5, Ne).toString("utf16le");
      return {
        type: W.AttachedPictureType[_e],
        format: Ee,
        description: $e,
        size: Me,
        data: de.slice(Ne + 4)
      };
    }
  }
  z.WmPictureToken = we;
})(AsfObject$1);
Object.defineProperty(AsfParser$1, "__esModule", { value: !0 });
AsfParser$1.AsfParser = void 0;
const debug_1$j = browserExports, type_1$1 = type$1, GUID_1 = GUID$1, AsfObject = AsfObject$1, BasicParser_1$9 = BasicParser$1, debug$j = (0, debug_1$j.default)("music-metadata:parser:ASF"), headerType = "asf";
class AsfParser extends BasicParser_1$9.BasicParser {
  async parse() {
    const D = await this.tokenizer.readToken(AsfObject.TopLevelHeaderObjectToken);
    if (!D.objectId.equals(GUID_1.default.HeaderObject))
      throw new Error("expected asf header; but was not found; got: " + D.objectId.str);
    try {
      await this.parseObjectHeader(D.numberOfHeaderObjects);
    } catch (O) {
      debug$j("Error while parsing ASF: %s", O);
    }
  }
  async parseObjectHeader(D) {
    let O;
    do {
      const F = await this.tokenizer.readToken(AsfObject.HeaderObjectToken);
      switch (debug$j("header GUID=%s", F.objectId.str), F.objectId.str) {
        case AsfObject.FilePropertiesObject.guid.str:
          const U = await this.tokenizer.readToken(new AsfObject.FilePropertiesObject(F));
          this.metadata.setFormat("duration", Number(U.playDuration / BigInt(1e3)) / 1e4 - Number(U.preroll) / 1e3), this.metadata.setFormat("bitrate", U.maximumBitrate);
          break;
        case AsfObject.StreamPropertiesObject.guid.str:
          const W = await this.tokenizer.readToken(new AsfObject.StreamPropertiesObject(F));
          this.metadata.setFormat("container", "ASF/" + W.streamType);
          break;
        case AsfObject.HeaderExtensionObject.guid.str:
          const B = await this.tokenizer.readToken(new AsfObject.HeaderExtensionObject());
          await this.parseExtensionObject(B.extensionDataSize);
          break;
        case AsfObject.ContentDescriptionObjectState.guid.str:
          O = await this.tokenizer.readToken(new AsfObject.ContentDescriptionObjectState(F)), this.addTags(O);
          break;
        case AsfObject.ExtendedContentDescriptionObjectState.guid.str:
          O = await this.tokenizer.readToken(new AsfObject.ExtendedContentDescriptionObjectState(F)), this.addTags(O);
          break;
        case GUID_1.default.CodecListObject.str:
          const K = await AsfObject.readCodecEntries(this.tokenizer);
          K.forEach((Y) => {
            this.metadata.addStreamInfo({
              type: Y.type.videoCodec ? type_1$1.TrackType.video : type_1$1.TrackType.audio,
              codecName: Y.codecName
            });
          });
          const X = K.filter((Y) => Y.type.audioCodec).map((Y) => Y.codecName).join("/");
          this.metadata.setFormat("codec", X);
          break;
        case GUID_1.default.StreamBitratePropertiesObject.str:
          await this.tokenizer.ignore(F.objectSize - AsfObject.HeaderObjectToken.len);
          break;
        case GUID_1.default.PaddingObject.str:
          debug$j("Padding: %s bytes", F.objectSize - AsfObject.HeaderObjectToken.len), await this.tokenizer.ignore(F.objectSize - AsfObject.HeaderObjectToken.len);
          break;
        default:
          this.metadata.addWarning("Ignore ASF-Object-GUID: " + F.objectId.str), debug$j("Ignore ASF-Object-GUID: %s", F.objectId.str), await this.tokenizer.readToken(new AsfObject.IgnoreObjectState(F));
      }
    } while (--D);
  }
  addTags(D) {
    D.forEach((O) => {
      this.metadata.addTag(headerType, O.id, O.value);
    });
  }
  async parseExtensionObject(D) {
    do {
      const O = await this.tokenizer.readToken(AsfObject.HeaderObjectToken), F = O.objectSize - AsfObject.HeaderObjectToken.len;
      switch (O.objectId.str) {
        case AsfObject.ExtendedStreamPropertiesObjectState.guid.str:
          await this.tokenizer.readToken(new AsfObject.ExtendedStreamPropertiesObjectState(O));
          break;
        case AsfObject.MetadataObjectState.guid.str:
          const U = await this.tokenizer.readToken(new AsfObject.MetadataObjectState(O));
          this.addTags(U);
          break;
        case AsfObject.MetadataLibraryObjectState.guid.str:
          const W = await this.tokenizer.readToken(new AsfObject.MetadataLibraryObjectState(O));
          this.addTags(W);
          break;
        case GUID_1.default.PaddingObject.str:
          await this.tokenizer.ignore(F);
          break;
        case GUID_1.default.CompatibilityObject.str:
          this.tokenizer.ignore(F);
          break;
        case GUID_1.default.ASF_Index_Placeholder_Object.str:
          await this.tokenizer.ignore(F);
          break;
        default:
          this.metadata.addWarning("Ignore ASF-Object-GUID: " + O.objectId.str), await this.tokenizer.readToken(new AsfObject.IgnoreObjectState(O));
          break;
      }
      D -= O.objectSize;
    } while (D > 0);
  }
}
AsfParser$1.AsfParser = AsfParser;
var FlacParser$1 = {}, Vorbis = {};
Object.defineProperty(Vorbis, "__esModule", { value: !0 });
Vorbis.IdentificationHeader = Vorbis.CommonHeader = Vorbis.VorbisPictureToken = void 0;
const Token$l = lib$1, ID3v2Token_1$1 = ID3v2Token;
class VorbisPictureToken {
  static fromBase64(D) {
    return this.fromBuffer(Buffer.from(D, "base64"));
  }
  static fromBuffer(D) {
    return new VorbisPictureToken(D.length).get(D, 0);
  }
  constructor(D) {
    this.len = D;
  }
  get(D, O) {
    const F = ID3v2Token_1$1.AttachedPictureType[Token$l.UINT32_BE.get(D, O)], U = Token$l.UINT32_BE.get(D, O += 4), W = D.toString("utf-8", O += 4, O + U), B = Token$l.UINT32_BE.get(D, O += U), K = D.toString("utf-8", O += 4, O + B), X = Token$l.UINT32_BE.get(D, O += B), Y = Token$l.UINT32_BE.get(D, O += 4), Q = Token$l.UINT32_BE.get(D, O += 4), J = Token$l.UINT32_BE.get(D, O += 4), ee = Token$l.UINT32_BE.get(D, O += 4), ae = Buffer.from(D.slice(O += 4, O + ee));
    return {
      type: F,
      format: W,
      description: K,
      width: X,
      height: Y,
      colour_depth: Q,
      indexed_color: J,
      data: ae
    };
  }
}
Vorbis.VorbisPictureToken = VorbisPictureToken;
Vorbis.CommonHeader = {
  len: 7,
  get: (z, D) => ({
    packetType: z.readUInt8(D),
    vorbis: new Token$l.StringType(6, "ascii").get(z, D + 1)
  })
};
Vorbis.IdentificationHeader = {
  len: 23,
  get: (z, D) => {
    const O = new DataView(z.buffer, z.byteOffset);
    return {
      version: O.getUint32(D + 0, !0),
      channelMode: O.getUint8(D + 4),
      sampleRate: O.getUint32(D + 5, !0),
      bitrateMax: O.getUint32(D + 9, !0),
      bitrateNominal: O.getUint32(D + 13, !0),
      bitrateMin: O.getUint32(D + 17, !0)
    };
  }
};
var AbstractID3Parser$1 = {};
Object.defineProperty(AbstractID3Parser$1, "__esModule", { value: !0 });
AbstractID3Parser$1.AbstractID3Parser = void 0;
const core_1$2 = core$1, debug_1$i = browserExports, ID3v2Token_1 = ID3v2Token, ID3v2Parser_1$3 = ID3v2Parser$1, ID3v1Parser_1$2 = ID3v1Parser, BasicParser_1$8 = BasicParser$1, debug$i = (0, debug_1$i.default)("music-metadata:parser:ID3");
class AbstractID3Parser extends BasicParser_1$8.BasicParser {
  constructor() {
    super(...arguments), this.id3parser = new ID3v2Parser_1$3.ID3v2Parser();
  }
  static async startsWithID3v2Header(D) {
    return (await D.peekToken(ID3v2Token_1.ID3v2Header)).fileIdentifier === "ID3";
  }
  async parse() {
    try {
      await this.parseID3v2();
    } catch (D) {
      if (D instanceof core_1$2.EndOfStreamError)
        debug$i("End-of-stream");
      else
        throw D;
    }
  }
  finalize() {
  }
  async parseID3v2() {
    await this.tryReadId3v2Headers(), debug$i("End of ID3v2 header, go to MPEG-parser: pos=%s", this.tokenizer.position), await this.postId3v2Parse(), this.options.skipPostHeaders && this.metadata.hasAny() ? this.finalize() : (await new ID3v1Parser_1$2.ID3v1Parser().init(this.metadata, this.tokenizer, this.options).parse(), this.finalize());
  }
  async tryReadId3v2Headers() {
    if ((await this.tokenizer.peekToken(ID3v2Token_1.ID3v2Header)).fileIdentifier === "ID3")
      return debug$i("Found ID3v2 header, pos=%s", this.tokenizer.position), await this.id3parser.parse(this.metadata, this.tokenizer, this.options), this.tryReadId3v2Headers();
  }
}
AbstractID3Parser$1.AbstractID3Parser = AbstractID3Parser;
var VorbisParser$1 = {}, VorbisDecoder$1 = {};
Object.defineProperty(VorbisDecoder$1, "__esModule", { value: !0 });
VorbisDecoder$1.VorbisDecoder = void 0;
const Token$k = lib$1;
class VorbisDecoder {
  constructor(D, O) {
    this.data = D, this.offset = O;
  }
  readInt32() {
    const D = Token$k.UINT32_LE.get(this.data, this.offset);
    return this.offset += 4, D;
  }
  readStringUtf8() {
    const D = this.readInt32(), O = Buffer.from(this.data).toString("utf-8", this.offset, this.offset + D);
    return this.offset += D, O;
  }
  parseUserComment() {
    const D = this.offset, O = this.readStringUtf8(), F = O.indexOf("=");
    return {
      key: O.slice(0, F).toUpperCase(),
      value: O.slice(F + 1),
      len: this.offset - D
    };
  }
}
VorbisDecoder$1.VorbisDecoder = VorbisDecoder;
Object.defineProperty(VorbisParser$1, "__esModule", { value: !0 });
VorbisParser$1.VorbisParser = void 0;
const Token$j = lib$1, debug_1$h = browserExports, VorbisDecoder_1$1 = VorbisDecoder$1, Vorbis_1$1 = Vorbis, debug$h = (0, debug_1$h.default)("music-metadata:parser:ogg:vorbis1");
class VorbisParser {
  constructor(D, O) {
    this.metadata = D, this.options = O, this.pageSegments = [];
  }
  /**
   * Vorbis 1 parser
   * @param header Ogg Page Header
   * @param pageData Page data
   */
  parsePage(D, O) {
    if (D.headerType.firstPage)
      this.parseFirstPage(D, O);
    else {
      if (D.headerType.continued) {
        if (this.pageSegments.length === 0)
          throw new Error("Cannot continue on previous page");
        this.pageSegments.push(O);
      }
      if (D.headerType.lastPage || !D.headerType.continued) {
        if (this.pageSegments.length > 0) {
          const F = Buffer.concat(this.pageSegments);
          this.parseFullPage(F);
        }
        this.pageSegments = D.headerType.lastPage ? [] : [O];
      }
    }
    D.headerType.lastPage && this.calculateDuration(D);
  }
  flush() {
    this.parseFullPage(Buffer.concat(this.pageSegments));
  }
  parseUserComment(D, O) {
    const U = new VorbisDecoder_1$1.VorbisDecoder(D, O).parseUserComment();
    return this.addTag(U.key, U.value), U.len;
  }
  addTag(D, O) {
    if (D === "METADATA_BLOCK_PICTURE" && typeof O == "string") {
      if (this.options.skipCovers) {
        debug$h("Ignore picture");
        return;
      }
      O = Vorbis_1$1.VorbisPictureToken.fromBase64(O), debug$h(`Push picture: id=${D}, format=${O.format}`);
    } else
      debug$h(`Push tag: id=${D}, value=${O}`);
    this.metadata.addTag("vorbis", D, O);
  }
  calculateDuration(D) {
    this.metadata.format.sampleRate && D.absoluteGranulePosition >= 0 && (this.metadata.setFormat("numberOfSamples", D.absoluteGranulePosition), this.metadata.setFormat("duration", this.metadata.format.numberOfSamples / this.metadata.format.sampleRate));
  }
  /**
   * Parse first Ogg/Vorbis page
   * @param {IPageHeader} header
   * @param {Buffer} pageData
   */
  parseFirstPage(D, O) {
    this.metadata.setFormat("codec", "Vorbis I"), debug$h("Parse first page");
    const F = Vorbis_1$1.CommonHeader.get(O, 0);
    if (F.vorbis !== "vorbis")
      throw new Error("Metadata does not look like Vorbis");
    if (F.packetType === 1) {
      const U = Vorbis_1$1.IdentificationHeader.get(O, Vorbis_1$1.CommonHeader.len);
      this.metadata.setFormat("sampleRate", U.sampleRate), this.metadata.setFormat("bitrate", U.bitrateNominal), this.metadata.setFormat("numberOfChannels", U.channelMode), debug$h("sample-rate=%s[hz], bitrate=%s[b/s], channel-mode=%s", U.sampleRate, U.bitrateNominal, U.channelMode);
    } else
      throw new Error("First Ogg page should be type 1: the identification header");
  }
  parseFullPage(D) {
    const O = Vorbis_1$1.CommonHeader.get(D, 0);
    switch (debug$h("Parse full page: type=%s, byteLength=%s", O.packetType, D.byteLength), O.packetType) {
      case 3:
        return this.parseUserCommentList(D, Vorbis_1$1.CommonHeader.len);
    }
  }
  /**
   * Ref: https://xiph.org/vorbis/doc/Vorbis_I_spec.html#x1-840005.2
   */
  parseUserCommentList(D, O) {
    const F = Token$j.UINT32_LE.get(D, O);
    O += 4, O += F;
    let U = Token$j.UINT32_LE.get(D, O);
    for (O += 4; U-- > 0; )
      O += this.parseUserComment(D, O);
  }
}
VorbisParser$1.VorbisParser = VorbisParser;
Object.defineProperty(FlacParser$1, "__esModule", { value: !0 });
FlacParser$1.FlacParser = void 0;
const token_types_1$1 = lib$1, debug_1$g = browserExports, util$6 = Util, Vorbis_1 = Vorbis, AbstractID3Parser_1$3 = AbstractID3Parser$1, FourCC_1$7 = FourCC, VorbisParser_1$3 = VorbisParser$1, VorbisDecoder_1 = VorbisDecoder$1, debug$g = (0, debug_1$g.default)("music-metadata:parser:FLAC");
var BlockType;
(function(z) {
  z[z.STREAMINFO = 0] = "STREAMINFO", z[z.PADDING = 1] = "PADDING", z[z.APPLICATION = 2] = "APPLICATION", z[z.SEEKTABLE = 3] = "SEEKTABLE", z[z.VORBIS_COMMENT = 4] = "VORBIS_COMMENT", z[z.CUESHEET = 5] = "CUESHEET", z[z.PICTURE = 6] = "PICTURE";
})(BlockType || (BlockType = {}));
class FlacParser extends AbstractID3Parser_1$3.AbstractID3Parser {
  constructor() {
    super(...arguments), this.padding = 0;
  }
  /**
   * Initialize parser with output (metadata), input (tokenizer) & parsing options (options).
   * @param {INativeMetadataCollector} metadata Output
   * @param {ITokenizer} tokenizer Input
   * @param {IOptions} options Parsing options
   */
  init(D, O, F) {
    return super.init(D, O, F), this.vorbisParser = new VorbisParser_1$3.VorbisParser(D, F), this;
  }
  async postId3v2Parse() {
    if ((await this.tokenizer.readToken(FourCC_1$7.FourCcToken)).toString() !== "fLaC")
      throw new Error("Invalid FLAC preamble");
    let O;
    do
      O = await this.tokenizer.readToken(Metadata.BlockHeader), await this.parseDataBlock(O);
    while (!O.lastBlock);
    if (this.tokenizer.fileInfo.size && this.metadata.format.duration) {
      const F = this.tokenizer.fileInfo.size - this.tokenizer.position;
      this.metadata.setFormat("bitrate", 8 * F / this.metadata.format.duration);
    }
  }
  parseDataBlock(D) {
    switch (debug$g(`blockHeader type=${D.type}, length=${D.length}`), D.type) {
      case BlockType.STREAMINFO:
        return this.parseBlockStreamInfo(D.length);
      case BlockType.PADDING:
        this.padding += D.length;
        break;
      case BlockType.APPLICATION:
        break;
      case BlockType.SEEKTABLE:
        break;
      case BlockType.VORBIS_COMMENT:
        return this.parseComment(D.length);
      case BlockType.CUESHEET:
        break;
      case BlockType.PICTURE:
        return this.parsePicture(D.length).then();
      default:
        this.metadata.addWarning("Unknown block type: " + D.type);
    }
    return this.tokenizer.ignore(D.length).then();
  }
  /**
   * Parse STREAMINFO
   */
  async parseBlockStreamInfo(D) {
    if (D !== Metadata.BlockStreamInfo.len)
      throw new Error("Unexpected block-stream-info length");
    const O = await this.tokenizer.readToken(Metadata.BlockStreamInfo);
    this.metadata.setFormat("container", "FLAC"), this.metadata.setFormat("codec", "FLAC"), this.metadata.setFormat("lossless", !0), this.metadata.setFormat("numberOfChannels", O.channels), this.metadata.setFormat("bitsPerSample", O.bitsPerSample), this.metadata.setFormat("sampleRate", O.sampleRate), O.totalSamples > 0 && this.metadata.setFormat("duration", O.totalSamples / O.sampleRate);
  }
  /**
   * Parse VORBIS_COMMENT
   * Ref: https://www.xiph.org/vorbis/doc/Vorbis_I_spec.html#x1-640004.2.3
   */
  async parseComment(D) {
    const O = await this.tokenizer.readToken(new token_types_1$1.Uint8ArrayType(D)), F = new VorbisDecoder_1.VorbisDecoder(O, 0);
    F.readStringUtf8();
    const U = F.readInt32();
    for (let W = 0; W < U; W++) {
      const B = F.parseUserComment();
      this.vorbisParser.addTag(B.key, B.value);
    }
  }
  async parsePicture(D) {
    if (this.options.skipCovers)
      return this.tokenizer.ignore(D);
    {
      const O = await this.tokenizer.readToken(new Vorbis_1.VorbisPictureToken(D));
      this.vorbisParser.addTag("METADATA_BLOCK_PICTURE", O);
    }
  }
}
FlacParser$1.FlacParser = FlacParser;
class Metadata {
}
Metadata.BlockHeader = {
  len: 4,
  get: (z, D) => ({
    lastBlock: util$6.getBit(z, D, 7),
    type: util$6.getBitAllignedNumber(z, D, 1, 7),
    length: token_types_1$1.UINT24_BE.get(z, D + 1)
  })
};
Metadata.BlockStreamInfo = {
  len: 34,
  get: (z, D) => ({
    // The minimum block size (in samples) used in the stream.
    minimumBlockSize: token_types_1$1.UINT16_BE.get(z, D),
    // The maximum block size (in samples) used in the stream.
    // (Minimum blocksize == maximum blocksize) implies a fixed-blocksize stream.
    maximumBlockSize: token_types_1$1.UINT16_BE.get(z, D + 2) / 1e3,
    // The minimum frame size (in bytes) used in the stream.
    // May be 0 to imply the value is not known.
    minimumFrameSize: token_types_1$1.UINT24_BE.get(z, D + 4),
    // The maximum frame size (in bytes) used in the stream.
    // May be 0 to imply the value is not known.
    maximumFrameSize: token_types_1$1.UINT24_BE.get(z, D + 7),
    // Sample rate in Hz. Though 20 bits are available,
    // the maximum sample rate is limited by the structure of frame headers to 655350Hz.
    // Also, a value of 0 is invalid.
    sampleRate: token_types_1$1.UINT24_BE.get(z, D + 10) >> 4,
    // probably slower: sampleRate: common.getBitAllignedNumber(buf, off + 10, 0, 20),
    // (number of channels)-1. FLAC supports from 1 to 8 channels
    channels: util$6.getBitAllignedNumber(z, D + 12, 4, 3) + 1,
    // bits per sample)-1.
    // FLAC supports from 4 to 32 bits per sample. Currently the reference encoder and decoders only support up to 24 bits per sample.
    bitsPerSample: util$6.getBitAllignedNumber(z, D + 12, 7, 5) + 1,
    // Total samples in stream.
    // 'Samples' means inter-channel sample, i.e. one second of 44.1Khz audio will have 44100 samples regardless of the number of channels.
    // A value of zero here means the number of total samples is unknown.
    totalSamples: util$6.getBitAllignedNumber(z, D + 13, 4, 36),
    // the MD5 hash of the file (see notes for usage... it's a littly tricky)
    fileMD5: new token_types_1$1.Uint8ArrayType(16).get(z, D + 18)
  })
};
var MP4Parser$1 = {}, Atom$1 = {}, AtomToken$2 = {};
(function(z) {
  Object.defineProperty(z, "__esModule", { value: !0 }), z.ChapterText = z.StcoAtom = z.StszAtom = z.StscAtom = z.SampleToChunkToken = z.SttsAtom = z.TimeToSampleToken = z.SoundSampleDescriptionV0 = z.SoundSampleDescriptionVersion = z.StsdAtom = z.TrackHeaderAtom = z.NameAtom = z.DataAtom = z.MvhdAtom = z.MdhdAtom = z.FixedLengthAtom = z.mhdr = z.tkhd = z.ftyp = z.ExtendedSize = z.Header = void 0;
  const D = lib$1, O = browserExports, F = FourCC, U = (0, O.default)("music-metadata:parser:MP4:atom");
  z.Header = {
    len: 8,
    get: (me, de) => {
      const be = D.UINT32_BE.get(me, de);
      if (be < 0)
        throw new Error("Invalid atom header length");
      return {
        length: BigInt(be),
        name: new D.StringType(4, "binary").get(me, de + 4)
      };
    },
    put: (me, de, be) => (D.UINT32_BE.put(me, de, Number(be.length)), F.FourCcToken.put(me, de + 4, be.name))
  }, z.ExtendedSize = D.UINT64_BE, z.ftyp = {
    len: 4,
    get: (me, de) => ({
      type: new D.StringType(4, "ascii").get(me, de)
    })
  }, z.tkhd = {
    len: 4,
    get: (me, de) => ({
      type: new D.StringType(4, "ascii").get(me, de)
    })
  }, z.mhdr = {
    len: 8,
    get: (me, de) => ({
      version: D.UINT8.get(me, de),
      flags: D.UINT24_BE.get(me, de + 1),
      nextItemID: D.UINT32_BE.get(me, de + 4)
    })
  };
  class W {
    /**
     *
     * @param {number} len Length as specified in the size field
     * @param {number} expLen Total length of sum of specified fields in the standard
     */
    constructor(de, be, _e) {
      if (this.len = de, de < be)
        throw new Error(`Atom ${_e} expected to be ${be}, but specifies ${de} bytes long.`);
      de > be && U(`Warning: atom ${_e} expected to be ${be}, but was actually ${de} bytes long.`);
    }
  }
  z.FixedLengthAtom = W;
  const B = {
    len: 4,
    get: (me, de) => {
      const be = D.UINT32_BE.get(me, de) - 2082844800;
      return new Date(be * 1e3);
    }
  };
  class K extends W {
    constructor(de) {
      super(de, 24, "mdhd"), this.len = de;
    }
    get(de, be) {
      return {
        version: D.UINT8.get(de, be + 0),
        flags: D.UINT24_BE.get(de, be + 1),
        creationTime: B.get(de, be + 4),
        modificationTime: B.get(de, be + 8),
        timeScale: D.UINT32_BE.get(de, be + 12),
        duration: D.UINT32_BE.get(de, be + 16),
        language: D.UINT16_BE.get(de, be + 20),
        quality: D.UINT16_BE.get(de, be + 22)
      };
    }
  }
  z.MdhdAtom = K;
  class X extends W {
    constructor(de) {
      super(de, 100, "mvhd"), this.len = de;
    }
    get(de, be) {
      return {
        version: D.UINT8.get(de, be),
        flags: D.UINT24_BE.get(de, be + 1),
        creationTime: B.get(de, be + 4),
        modificationTime: B.get(de, be + 8),
        timeScale: D.UINT32_BE.get(de, be + 12),
        duration: D.UINT32_BE.get(de, be + 16),
        preferredRate: D.UINT32_BE.get(de, be + 20),
        preferredVolume: D.UINT16_BE.get(de, be + 24),
        // ignore reserver: 10 bytes
        // ignore matrix structure: 36 bytes
        previewTime: D.UINT32_BE.get(de, be + 72),
        previewDuration: D.UINT32_BE.get(de, be + 76),
        posterTime: D.UINT32_BE.get(de, be + 80),
        selectionTime: D.UINT32_BE.get(de, be + 84),
        selectionDuration: D.UINT32_BE.get(de, be + 88),
        currentTime: D.UINT32_BE.get(de, be + 92),
        nextTrackID: D.UINT32_BE.get(de, be + 96)
      };
    }
  }
  z.MvhdAtom = X;
  class Y {
    constructor(de) {
      this.len = de;
    }
    get(de, be) {
      return {
        type: {
          set: D.UINT8.get(de, be + 0),
          type: D.UINT24_BE.get(de, be + 1)
        },
        locale: D.UINT24_BE.get(de, be + 4),
        value: Buffer.from(new D.Uint8ArrayType(this.len - 8).get(de, be + 8))
      };
    }
  }
  z.DataAtom = Y;
  class Q {
    constructor(de) {
      this.len = de;
    }
    get(de, be) {
      return {
        version: D.UINT8.get(de, be),
        flags: D.UINT24_BE.get(de, be + 1),
        name: new D.StringType(this.len - 4, "utf-8").get(de, be + 4)
      };
    }
  }
  z.NameAtom = Q;
  class J {
    constructor(de) {
      this.len = de;
    }
    get(de, be) {
      return {
        version: D.UINT8.get(de, be),
        flags: D.UINT24_BE.get(de, be + 1),
        creationTime: B.get(de, be + 4),
        modificationTime: B.get(de, be + 8),
        trackId: D.UINT32_BE.get(de, be + 12),
        // reserved 4 bytes
        duration: D.UINT32_BE.get(de, be + 20),
        layer: D.UINT16_BE.get(de, be + 24),
        alternateGroup: D.UINT16_BE.get(de, be + 26),
        volume: D.UINT16_BE.get(de, be + 28)
        // ToDo: fixed point
        // ToDo: add remaining fields
      };
    }
  }
  z.TrackHeaderAtom = J;
  const ee = {
    len: 8,
    get: (me, de) => ({
      version: D.UINT8.get(me, de),
      flags: D.UINT24_BE.get(me, de + 1),
      numberOfEntries: D.UINT32_BE.get(me, de + 4)
    })
  };
  class ae {
    constructor(de) {
      this.len = de;
    }
    get(de, be) {
      return {
        dataFormat: F.FourCcToken.get(de, be),
        dataReferenceIndex: D.UINT16_BE.get(de, be + 10),
        description: new D.Uint8ArrayType(this.len - 12).get(de, be + 12)
      };
    }
  }
  class re {
    constructor(de) {
      this.len = de;
    }
    get(de, be) {
      const _e = ee.get(de, be);
      be += ee.len;
      const Me = [];
      for (let Ne = 0; Ne < _e.numberOfEntries; ++Ne) {
        const Ee = D.UINT32_BE.get(de, be);
        be += D.UINT32_BE.len, Me.push(new ae(Ee).get(de, be)), be += Ee;
      }
      return {
        header: _e,
        table: Me
      };
    }
  }
  z.StsdAtom = re, z.SoundSampleDescriptionVersion = {
    len: 8,
    get(me, de) {
      return {
        version: D.INT16_BE.get(me, de),
        revision: D.INT16_BE.get(me, de + 2),
        vendor: D.INT32_BE.get(me, de + 4)
      };
    }
  }, z.SoundSampleDescriptionV0 = {
    len: 12,
    get(me, de) {
      return {
        numAudioChannels: D.INT16_BE.get(me, de + 0),
        sampleSize: D.INT16_BE.get(me, de + 2),
        compressionId: D.INT16_BE.get(me, de + 4),
        packetSize: D.INT16_BE.get(me, de + 6),
        sampleRate: D.UINT16_BE.get(me, de + 8) + D.UINT16_BE.get(me, de + 10) / 1e4
      };
    }
  };
  class ie {
    constructor(de, be) {
      this.len = de, this.token = be;
    }
    get(de, be) {
      const _e = D.INT32_BE.get(de, be + 4);
      return {
        version: D.INT8.get(de, be + 0),
        flags: D.INT24_BE.get(de, be + 1),
        numberOfEntries: _e,
        entries: we(de, this.token, be + 8, this.len - 8, _e)
      };
    }
  }
  z.TimeToSampleToken = {
    len: 8,
    get(me, de) {
      return {
        count: D.INT32_BE.get(me, de + 0),
        duration: D.INT32_BE.get(me, de + 4)
      };
    }
  };
  class ue extends ie {
    constructor(de) {
      super(de, z.TimeToSampleToken), this.len = de;
    }
  }
  z.SttsAtom = ue, z.SampleToChunkToken = {
    len: 12,
    get(me, de) {
      return {
        firstChunk: D.INT32_BE.get(me, de),
        samplesPerChunk: D.INT32_BE.get(me, de + 4),
        sampleDescriptionId: D.INT32_BE.get(me, de + 8)
      };
    }
  };
  class q extends ie {
    constructor(de) {
      super(de, z.SampleToChunkToken), this.len = de;
    }
  }
  z.StscAtom = q;
  class ne {
    constructor(de) {
      this.len = de;
    }
    get(de, be) {
      const _e = D.INT32_BE.get(de, be + 8);
      return {
        version: D.INT8.get(de, be),
        flags: D.INT24_BE.get(de, be + 1),
        sampleSize: D.INT32_BE.get(de, be + 4),
        numberOfEntries: _e,
        entries: we(de, D.INT32_BE, be + 12, this.len - 12, _e)
      };
    }
  }
  z.StszAtom = ne;
  class ce extends ie {
    constructor(de) {
      super(de, D.INT32_BE), this.len = de;
    }
  }
  z.StcoAtom = ce;
  class he {
    constructor(de) {
      this.len = de;
    }
    get(de, be) {
      const _e = D.INT16_BE.get(de, be + 0);
      return new D.StringType(_e, "utf-8").get(de, be + 2);
    }
  }
  z.ChapterText = he;
  function we(me, de, be, _e, Me) {
    if (U(`remainingLen=${_e}, numberOfEntries=${Me} * token-len=${de.len}`), _e === 0)
      return [];
    if (_e !== Me * de.len)
      throw new Error("mismatch number-of-entries with remaining atom-length");
    const Ne = [];
    for (let Ee = 0; Ee < Me; ++Ee)
      Ne.push(de.get(me, be)), be += de.len;
    return Ne;
  }
})(AtomToken$2);
Object.defineProperty(Atom$1, "__esModule", { value: !0 });
Atom$1.Atom = void 0;
const debug_1$f = browserExports, AtomToken$1 = AtomToken$2, debug$f = (0, debug_1$f.default)("music-metadata:parser:MP4:Atom");
class Atom {
  static async readAtom(D, O, F, U) {
    const W = D.position, B = await D.readToken(AtomToken$1.Header);
    B.length === BigInt(1) && (B.length = await D.readToken(AtomToken$1.ExtendedSize));
    const X = new Atom(B, B.length === BigInt(1), F), Y = X.getPayloadLength(U);
    return debug$f(`parse atom name=${X.atomPath}, extended=${X.extended}, offset=${W}, len=${X.header.length}`), await X.readData(D, O, Y), X;
  }
  constructor(D, O, F) {
    this.header = D, this.extended = O, this.parent = F, this.children = [], this.atomPath = (this.parent ? this.parent.atomPath + "." : "") + this.header.name;
  }
  getHeaderLength() {
    return this.extended ? 16 : 8;
  }
  getPayloadLength(D) {
    return (this.header.length === BigInt(0) ? D : Number(this.header.length)) - this.getHeaderLength();
  }
  async readAtoms(D, O, F) {
    for (; F > 0; ) {
      const U = await Atom.readAtom(D, O, this, F);
      this.children.push(U), F -= U.header.length === BigInt(0) ? F : Number(U.header.length);
    }
  }
  async readData(D, O, F) {
    switch (this.header.name) {
      case "moov":
      case "udta":
      case "trak":
      case "mdia":
      case "minf":
      case "stbl":
      case "<id>":
      case "ilst":
      case "tref":
        return this.readAtoms(D, O, this.getPayloadLength(F));
      case "meta":
        const W = (await D.peekToken(AtomToken$1.Header)).name === "hdlr" ? 0 : 4;
        return await D.ignore(W), this.readAtoms(D, O, this.getPayloadLength(F) - W);
      case "mdhd":
      case "mvhd":
      case "tkhd":
      case "stsz":
      case "mdat":
      default:
        return O(this, F);
    }
  }
}
Atom$1.Atom = Atom;
Object.defineProperty(MP4Parser$1, "__esModule", { value: !0 });
MP4Parser$1.MP4Parser = void 0;
const debug_1$e = browserExports, Token$i = lib$1, BasicParser_1$7 = BasicParser$1, ID3v1Parser_1$1 = ID3v1Parser, type_1 = type$1, Atom_1 = Atom$1, AtomToken = AtomToken$2, debug$e = (0, debug_1$e.default)("music-metadata:parser:MP4"), tagFormat = "iTunes", encoderDict = {
  raw: {
    lossy: !1,
    format: "raw"
  },
  MAC3: {
    lossy: !0,
    format: "MACE 3:1"
  },
  MAC6: {
    lossy: !0,
    format: "MACE 6:1"
  },
  ima4: {
    lossy: !0,
    format: "IMA 4:1"
  },
  ulaw: {
    lossy: !0,
    format: "uLaw 2:1"
  },
  alaw: {
    lossy: !0,
    format: "uLaw 2:1"
  },
  Qclp: {
    lossy: !0,
    format: "QUALCOMM PureVoice"
  },
  ".mp3": {
    lossy: !0,
    format: "MPEG-1 layer 3"
  },
  alac: {
    lossy: !1,
    format: "ALAC"
  },
  "ac-3": {
    lossy: !0,
    format: "AC-3"
  },
  mp4a: {
    lossy: !0,
    format: "MPEG-4/AAC"
  },
  mp4s: {
    lossy: !0,
    format: "MP4S"
  },
  // Closed Captioning Media, https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap3/qtff3.html#//apple_ref/doc/uid/TP40000939-CH205-SW87
  c608: {
    lossy: !0,
    format: "CEA-608"
  },
  c708: {
    lossy: !0,
    format: "CEA-708"
  }
};
function distinct(z, D, O) {
  return O.indexOf(z) === D;
}
class MP4Parser extends BasicParser_1$7.BasicParser {
  constructor() {
    super(...arguments), this.atomParsers = {
      /**
       * Parse movie header (mvhd) atom
       * Ref: https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap2/qtff2.html#//apple_ref/doc/uid/TP40000939-CH204-56313
       */
      mvhd: async (D) => {
        const O = await this.tokenizer.readToken(new AtomToken.MvhdAtom(D));
        this.metadata.setFormat("creationTime", O.creationTime), this.metadata.setFormat("modificationTime", O.modificationTime);
      },
      /**
       * Parse media header (mdhd) atom
       * Ref: https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap2/qtff2.html#//apple_ref/doc/uid/TP40000939-CH204-25615
       */
      mdhd: async (D) => {
        const O = await this.tokenizer.readToken(new AtomToken.MdhdAtom(D)), F = this.getTrackDescription();
        F.creationTime = O.creationTime, F.modificationTime = O.modificationTime, F.timeScale = O.timeScale, F.duration = O.duration;
      },
      chap: async (D) => {
        const O = this.getTrackDescription(), F = [];
        for (; D >= Token$i.UINT32_BE.len; )
          F.push(await this.tokenizer.readNumber(Token$i.UINT32_BE)), D -= Token$i.UINT32_BE.len;
        O.chapterList = F;
      },
      tkhd: async (D) => {
        const O = await this.tokenizer.readToken(new AtomToken.TrackHeaderAtom(D));
        this.tracks.push(O);
      },
      /**
       * Parse mdat atom.
       * Will scan for chapters
       */
      mdat: async (D) => {
        if (this.audioLengthInBytes = D, this.calculateBitRate(), this.options.includeChapters) {
          const O = this.tracks.filter((F) => F.chapterList);
          if (O.length === 1) {
            const F = O[0].chapterList, U = this.tracks.filter((W) => F.indexOf(W.trackId) !== -1);
            if (U.length === 1)
              return this.parseChapterTrack(U[0], O[0], D);
          }
        }
        await this.tokenizer.ignore(D);
      },
      ftyp: async (D) => {
        const O = [];
        for (; D > 0; ) {
          const U = await this.tokenizer.readToken(AtomToken.ftyp);
          D -= AtomToken.ftyp.len;
          const W = U.type.replace(/\W/g, "");
          W.length > 0 && O.push(W);
        }
        debug$e(`ftyp: ${O.join("/")}`);
        const F = O.filter(distinct).join("/");
        this.metadata.setFormat("container", F);
      },
      /**
       * Parse sample description atom
       */
      stsd: async (D) => {
        const O = await this.tokenizer.readToken(new AtomToken.StsdAtom(D)), F = this.getTrackDescription();
        F.soundSampleDescription = O.table.map((U) => this.parseSoundSampleDescription(U));
      },
      /**
       * sample-to-Chunk Atoms
       */
      stsc: async (D) => {
        const O = await this.tokenizer.readToken(new AtomToken.StscAtom(D));
        this.getTrackDescription().sampleToChunkTable = O.entries;
      },
      /**
       * time-to-sample table
       */
      stts: async (D) => {
        const O = await this.tokenizer.readToken(new AtomToken.SttsAtom(D));
        this.getTrackDescription().timeToSampleTable = O.entries;
      },
      /**
       * Parse sample-sizes atom ('stsz')
       */
      stsz: async (D) => {
        const O = await this.tokenizer.readToken(new AtomToken.StszAtom(D)), F = this.getTrackDescription();
        F.sampleSize = O.sampleSize, F.sampleSizeTable = O.entries;
      },
      /**
       * Parse chunk-offset atom ('stco')
       */
      stco: async (D) => {
        const O = await this.tokenizer.readToken(new AtomToken.StcoAtom(D));
        this.getTrackDescription().chunkOffsetTable = O.entries;
      },
      date: async (D) => {
        const O = await this.tokenizer.readToken(new Token$i.StringType(D, "utf-8"));
        this.addTag("date", O);
      }
    };
  }
  static read_BE_Integer(D, O) {
    const F = (O ? "INT" : "UINT") + D.length * 8 + (D.length > 1 ? "_BE" : ""), U = Token$i[F];
    if (!U)
      throw new Error('Token for integer type not found: "' + F + '"');
    return Number(U.get(D, 0));
  }
  async parse() {
    this.tracks = [];
    let D = this.tokenizer.fileInfo.size;
    for (; !this.tokenizer.fileInfo.size || D > 0; ) {
      try {
        if ((await this.tokenizer.peekToken(AtomToken.Header)).name === "\0\0\0\0") {
          const B = `Error at offset=${this.tokenizer.position}: box.id=0`;
          debug$e(B), this.addWarning(B);
          break;
        }
      } catch (W) {
        const B = `Error at offset=${this.tokenizer.position}: ${W.message}`;
        debug$e(B), this.addWarning(B);
        break;
      }
      const U = await Atom_1.Atom.readAtom(this.tokenizer, (W, B) => this.handleAtom(W, B), null, D);
      D -= U.header.length === BigInt(0) ? D : Number(U.header.length);
    }
    const O = [];
    this.tracks.forEach((U) => {
      const W = [];
      U.soundSampleDescription.forEach((B) => {
        const K = {}, X = encoderDict[B.dataFormat];
        if (X ? (W.push(X.format), K.codecName = X.format) : K.codecName = `<${B.dataFormat}>`, B.description) {
          const { description: Y } = B;
          Y.sampleRate > 0 && (K.type = type_1.TrackType.audio, K.audio = {
            samplingFrequency: Y.sampleRate,
            bitDepth: Y.sampleSize,
            channels: Y.numAudioChannels
          });
        }
        this.metadata.addStreamInfo(K);
      }), W.length >= 1 && O.push(W.join("/"));
    }), O.length > 0 && this.metadata.setFormat("codec", O.filter(distinct).join("+"));
    const F = this.tracks.filter((U) => U.soundSampleDescription.length >= 1 && U.soundSampleDescription[0].description && U.soundSampleDescription[0].description.numAudioChannels > 0);
    if (F.length >= 1) {
      const U = F[0];
      if (U.timeScale > 0) {
        const K = U.duration / U.timeScale;
        this.metadata.setFormat("duration", K);
      }
      const W = U.soundSampleDescription[0];
      if (W.description && (this.metadata.setFormat("sampleRate", W.description.sampleRate), this.metadata.setFormat("bitsPerSample", W.description.sampleSize), this.metadata.setFormat("numberOfChannels", W.description.numAudioChannels), U.timeScale === 0 && U.timeToSampleTable.length > 0)) {
        const X = U.timeToSampleTable.map((Y) => Y.count * Y.duration).reduce((Y, Q) => Y + Q) / W.description.sampleRate;
        this.metadata.setFormat("duration", X);
      }
      const B = encoderDict[W.dataFormat];
      B && this.metadata.setFormat("lossless", !B.lossy), this.calculateBitRate();
    }
  }
  async handleAtom(D, O) {
    if (D.parent)
      switch (D.parent.header.name) {
        case "ilst":
        case "<id>":
          return this.parseMetadataItemData(D);
      }
    if (this.atomParsers[D.header.name])
      return this.atomParsers[D.header.name](O);
    debug$e(`No parser for atom path=${D.atomPath}, payload-len=${O}, ignoring atom`), await this.tokenizer.ignore(O);
  }
  getTrackDescription() {
    return this.tracks[this.tracks.length - 1];
  }
  calculateBitRate() {
    this.audioLengthInBytes && this.metadata.format.duration && this.metadata.setFormat("bitrate", 8 * this.audioLengthInBytes / this.metadata.format.duration);
  }
  addTag(D, O) {
    this.metadata.addTag(tagFormat, D, O);
  }
  addWarning(D) {
    debug$e("Warning: " + D), this.metadata.addWarning(D);
  }
  /**
   * Parse data of Meta-item-list-atom (item of 'ilst' atom)
   * @param metaAtom
   * Ref: https://developer.apple.com/library/content/documentation/QuickTime/QTFF/Metadata/Metadata.html#//apple_ref/doc/uid/TP40000939-CH1-SW8
   */
  parseMetadataItemData(D) {
    let O = D.header.name;
    return D.readAtoms(this.tokenizer, async (F, U) => {
      const W = F.getPayloadLength(U);
      switch (F.header.name) {
        case "data":
          return this.parseValueAtom(O, F);
        case "name":
        case "mean":
        case "rate":
          const B = await this.tokenizer.readToken(new AtomToken.NameAtom(W));
          O += ":" + B.name;
          break;
        default:
          const K = await this.tokenizer.readToken(new Token$i.BufferType(W));
          this.addWarning("Unsupported meta-item: " + O + "[" + F.header.name + "] => value=" + K.toString("hex") + " ascii=" + K.toString("ascii"));
      }
    }, D.getPayloadLength(0));
  }
  async parseValueAtom(D, O) {
    const F = await this.tokenizer.readToken(new AtomToken.DataAtom(Number(O.header.length) - AtomToken.Header.len));
    if (F.type.set !== 0)
      throw new Error("Unsupported type-set != 0: " + F.type.set);
    switch (F.type.type) {
      case 0:
        switch (D) {
          case "trkn":
          case "disk":
            const U = Token$i.UINT8.get(F.value, 3), W = Token$i.UINT8.get(F.value, 5);
            this.addTag(D, U + "/" + W);
            break;
          case "gnre":
            const B = Token$i.UINT8.get(F.value, 1), K = ID3v1Parser_1$1.Genres[B - 1];
            this.addTag(D, K);
            break;
          case "rate":
            const X = F.value.toString("ascii");
            this.addTag(D, X);
            break;
          default:
            debug$e("unknown proprietary value type for: " + O.atomPath);
        }
        break;
      case 1:
      case 18:
        this.addTag(D, F.value.toString("utf-8"));
        break;
      case 13:
        if (this.options.skipCovers)
          break;
        this.addTag(D, {
          format: "image/jpeg",
          data: Buffer.from(F.value)
        });
        break;
      case 14:
        if (this.options.skipCovers)
          break;
        this.addTag(D, {
          format: "image/png",
          data: Buffer.from(F.value)
        });
        break;
      case 21:
        this.addTag(D, MP4Parser.read_BE_Integer(F.value, !0));
        break;
      case 22:
        this.addTag(D, MP4Parser.read_BE_Integer(F.value, !1));
        break;
      case 65:
        this.addTag(D, F.value.readInt8(0));
        break;
      case 66:
        this.addTag(D, F.value.readInt16BE(0));
        break;
      case 67:
        this.addTag(D, F.value.readInt32BE(0));
        break;
      default:
        this.addWarning(`atom key=${D}, has unknown well-known-type (data-type): ${F.type.type}`);
    }
  }
  /**
   * @param sampleDescription
   * Ref: https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap3/qtff3.html#//apple_ref/doc/uid/TP40000939-CH205-128916
   */
  parseSoundSampleDescription(D) {
    const O = {
      dataFormat: D.dataFormat,
      dataReferenceIndex: D.dataReferenceIndex
    };
    let F = 0;
    const U = AtomToken.SoundSampleDescriptionVersion.get(D.description, F);
    return F += AtomToken.SoundSampleDescriptionVersion.len, U.version === 0 || U.version === 1 ? O.description = AtomToken.SoundSampleDescriptionV0.get(D.description, F) : debug$e(`Warning: sound-sample-description ${U} not implemented`), O;
  }
  async parseChapterTrack(D, O, F) {
    if (!D.sampleSize && D.chunkOffsetTable.length !== D.sampleSizeTable.length)
      throw new Error("Expected equal chunk-offset-table & sample-size-table length.");
    const U = [];
    for (let W = 0; W < D.chunkOffsetTable.length && F > 0; ++W) {
      const K = D.chunkOffsetTable[W] - this.tokenizer.position, X = D.sampleSize > 0 ? D.sampleSize : D.sampleSizeTable[W];
      if (F -= K + X, F < 0)
        throw new Error("Chapter chunk exceeding token length");
      await this.tokenizer.ignore(K);
      const Y = await this.tokenizer.readToken(new AtomToken.ChapterText(X));
      debug$e(`Chapter ${W + 1}: ${Y}`);
      const Q = {
        title: Y,
        sampleOffset: this.findSampleOffset(O, this.tokenizer.position)
      };
      debug$e(`Chapter title=${Q.title}, offset=${Q.sampleOffset}/${this.tracks[0].duration}`), U.push(Q);
    }
    this.metadata.setFormat("chapters", U), await this.tokenizer.ignore(F);
  }
  findSampleOffset(D, O) {
    let F = 0;
    D.timeToSampleTable.forEach((W) => {
      F += W.count * W.duration;
    }), debug$e(`Total duration=${F}`);
    let U = 0;
    for (; U < D.chunkOffsetTable.length && D.chunkOffsetTable[U] < O; )
      ++U;
    return this.getChunkDuration(U + 1, D);
  }
  getChunkDuration(D, O) {
    let F = 0, U = O.timeToSampleTable[F].count, W = O.timeToSampleTable[F].duration, B = 1, K = this.getSamplesPerChunk(B, O.sampleToChunkTable), X = 0;
    for (; B < D; ) {
      const Y = Math.min(U, K);
      X += Y * W, U -= Y, K -= Y, K === 0 ? (++B, K = this.getSamplesPerChunk(B, O.sampleToChunkTable)) : (++F, U = O.timeToSampleTable[F].count, W = O.timeToSampleTable[F].duration);
    }
    return X;
  }
  getSamplesPerChunk(D, O) {
    for (let F = 0; F < O.length - 1; ++F)
      if (D >= O[F].firstChunk && D < O[F + 1].firstChunk)
        return O[F].samplesPerChunk;
    return O[O.length - 1].samplesPerChunk;
  }
}
MP4Parser$1.MP4Parser = MP4Parser;
var MpegParser$1 = {}, XingTag = {}, ExtendedLameHeader = {}, ReplayGainDataFormat = {};
Object.defineProperty(ReplayGainDataFormat, "__esModule", { value: !0 });
ReplayGainDataFormat.ReplayGain = void 0;
const common$2 = Util;
var NameCode;
(function(z) {
  z[z.not_set = 0] = "not_set", z[z.radio = 1] = "radio", z[z.audiophile = 2] = "audiophile";
})(NameCode || (NameCode = {}));
var ReplayGainOriginator;
(function(z) {
  z[z.unspecified = 0] = "unspecified", z[z.engineer = 1] = "engineer", z[z.user = 2] = "user", z[z.automatic = 3] = "automatic", z[z.rms_average = 4] = "rms_average";
})(ReplayGainOriginator || (ReplayGainOriginator = {}));
ReplayGainDataFormat.ReplayGain = {
  len: 2,
  get: (z, D) => {
    const O = common$2.getBitAllignedNumber(z, D, 0, 3), F = common$2.getBitAllignedNumber(z, D, 6, 1), U = common$2.getBitAllignedNumber(z, D, 7, 9) / 10;
    if (O > 0)
      return {
        type: common$2.getBitAllignedNumber(z, D, 0, 3),
        origin: common$2.getBitAllignedNumber(z, D, 3, 3),
        adjustment: F ? -U : U
      };
  }
};
Object.defineProperty(ExtendedLameHeader, "__esModule", { value: !0 });
ExtendedLameHeader.ExtendedLameHeader = void 0;
const Token$h = lib$1, common$1 = Util, ReplayGainDataFormat_1 = ReplayGainDataFormat;
ExtendedLameHeader.ExtendedLameHeader = {
  len: 27,
  get: (z, D) => {
    const O = Token$h.UINT32_BE.get(z, D + 2);
    return {
      revision: common$1.getBitAllignedNumber(z, D, 0, 4),
      vbr_method: common$1.getBitAllignedNumber(z, D, 4, 4),
      lowpass_filter: 100 * Token$h.UINT8.get(z, D + 1),
      track_peak: O === 0 ? void 0 : O / Math.pow(2, 23),
      track_gain: ReplayGainDataFormat_1.ReplayGain.get(z, 6),
      album_gain: ReplayGainDataFormat_1.ReplayGain.get(z, 8),
      music_length: Token$h.UINT32_BE.get(z, D + 20),
      music_crc: Token$h.UINT8.get(z, D + 24),
      header_crc: Token$h.UINT16_BE.get(z, D + 24)
    };
  }
};
(function(z) {
  Object.defineProperty(z, "__esModule", { value: !0 }), z.readXingHeader = z.XingHeaderFlags = z.LameEncoderVersion = z.InfoTagHeaderTag = void 0;
  const D = lib$1, O = Util, F = ExtendedLameHeader;
  z.InfoTagHeaderTag = new D.StringType(4, "ascii"), z.LameEncoderVersion = new D.StringType(6, "ascii"), z.XingHeaderFlags = {
    len: 4,
    get: (W, B) => ({
      frames: O.isBitSet(W, B, 31),
      bytes: O.isBitSet(W, B, 30),
      toc: O.isBitSet(W, B, 29),
      vbrScale: O.isBitSet(W, B, 28)
    })
  };
  async function U(W) {
    const B = await W.readToken(z.XingHeaderFlags), K = {};
    if (B.frames && (K.numFrames = await W.readToken(D.UINT32_BE)), B.bytes && (K.streamSize = await W.readToken(D.UINT32_BE)), B.toc && (K.toc = Buffer.alloc(100), await W.readBuffer(K.toc)), B.vbrScale && (K.vbrScale = await W.readToken(D.UINT32_BE)), await W.peekToken(new D.StringType(4, "ascii")) === "LAME" && (await W.ignore(4), K.lame = {
      version: await W.readToken(new D.StringType(5, "ascii"))
    }, K.lame.version.match(/\d+.\d+/g))) {
      const J = K.lame.version.match(/\d+.\d+/g)[0].split(".").map((ee) => parseInt(ee, 10));
      J[0] >= 3 && J[1] >= 90 && (K.lame.extended = await W.readToken(F.ExtendedLameHeader));
    }
    return K;
  }
  z.readXingHeader = U;
})(XingTag);
Object.defineProperty(MpegParser$1, "__esModule", { value: !0 });
MpegParser$1.MpegParser = void 0;
const Token$g = lib$1, core_1$1 = core$1, debug_1$d = browserExports, common = Util, AbstractID3Parser_1$2 = AbstractID3Parser$1, XingTag_1 = XingTag, debug$d = (0, debug_1$d.default)("music-metadata:parser:mpeg"), maxPeekLen = 1024, MPEG4 = {
  /**
   * Audio Object Types
   */
  AudioObjectTypes: [
    "AAC Main",
    "AAC LC",
    "AAC SSR",
    "AAC LTP"
    // Long Term Prediction
  ],
  /**
   * Sampling Frequencies
   * https://wiki.multimedia.cx/index.php/MPEG-4_Audio#Sampling_Frequencies
   */
  SamplingFrequencies: [
    96e3,
    88200,
    64e3,
    48e3,
    44100,
    32e3,
    24e3,
    22050,
    16e3,
    12e3,
    11025,
    8e3,
    7350,
    void 0,
    void 0,
    -1
  ]
  /**
   * Channel Configurations
   */
}, MPEG4_ChannelConfigurations = [
  void 0,
  ["front-center"],
  ["front-left", "front-right"],
  ["front-center", "front-left", "front-right"],
  ["front-center", "front-left", "front-right", "back-center"],
  ["front-center", "front-left", "front-right", "back-left", "back-right"],
  ["front-center", "front-left", "front-right", "back-left", "back-right", "LFE-channel"],
  ["front-center", "front-left", "front-right", "side-left", "side-right", "back-left", "back-right", "LFE-channel"]
];
class MpegFrameHeader {
  constructor(D, O) {
    this.versionIndex = common.getBitAllignedNumber(D, O + 1, 3, 2), this.layer = MpegFrameHeader.LayerDescription[common.getBitAllignedNumber(D, O + 1, 5, 2)], this.versionIndex > 1 && this.layer === 0 ? this.parseAdtsHeader(D, O) : this.parseMpegHeader(D, O), this.isProtectedByCRC = !common.isBitSet(D, O + 1, 7);
  }
  calcDuration(D) {
    return D * this.calcSamplesPerFrame() / this.samplingRate;
  }
  calcSamplesPerFrame() {
    return MpegFrameHeader.samplesInFrameTable[this.version === 1 ? 0 : 1][this.layer];
  }
  calculateSideInfoLength() {
    if (this.layer !== 3)
      return 2;
    if (this.channelModeIndex === 3) {
      if (this.version === 1)
        return 17;
      if (this.version === 2 || this.version === 2.5)
        return 9;
    } else {
      if (this.version === 1)
        return 32;
      if (this.version === 2 || this.version === 2.5)
        return 17;
    }
  }
  calcSlotSize() {
    return [null, 4, 1, 1][this.layer];
  }
  parseMpegHeader(D, O) {
    this.container = "MPEG", this.bitrateIndex = common.getBitAllignedNumber(D, O + 2, 0, 4), this.sampRateFreqIndex = common.getBitAllignedNumber(D, O + 2, 4, 2), this.padding = common.isBitSet(D, O + 2, 6), this.privateBit = common.isBitSet(D, O + 2, 7), this.channelModeIndex = common.getBitAllignedNumber(D, O + 3, 0, 2), this.modeExtension = common.getBitAllignedNumber(D, O + 3, 2, 2), this.isCopyrighted = common.isBitSet(D, O + 3, 4), this.isOriginalMedia = common.isBitSet(D, O + 3, 5), this.emphasis = common.getBitAllignedNumber(D, O + 3, 7, 2), this.version = MpegFrameHeader.VersionID[this.versionIndex], this.channelMode = MpegFrameHeader.ChannelMode[this.channelModeIndex], this.codec = `MPEG ${this.version} Layer ${this.layer}`;
    const F = this.calcBitrate();
    if (!F)
      throw new Error("Cannot determine bit-rate");
    if (this.bitrate = F * 1e3, this.samplingRate = this.calcSamplingRate(), this.samplingRate == null)
      throw new Error("Cannot determine sampling-rate");
  }
  parseAdtsHeader(D, O) {
    debug$d("layer=0 => ADTS"), this.version = this.versionIndex === 2 ? 4 : 2, this.container = "ADTS/MPEG-" + this.version;
    const F = common.getBitAllignedNumber(D, O + 2, 0, 2);
    this.codec = "AAC", this.codecProfile = MPEG4.AudioObjectTypes[F], debug$d(`MPEG-4 audio-codec=${this.codec}`);
    const U = common.getBitAllignedNumber(D, O + 2, 2, 4);
    this.samplingRate = MPEG4.SamplingFrequencies[U], debug$d(`sampling-rate=${this.samplingRate}`);
    const W = common.getBitAllignedNumber(D, O + 2, 7, 3);
    this.mp4ChannelConfig = MPEG4_ChannelConfigurations[W], debug$d(`channel-config=${this.mp4ChannelConfig.join("+")}`), this.frameLength = common.getBitAllignedNumber(D, O + 3, 6, 2) << 11;
  }
  calcBitrate() {
    if (this.bitrateIndex === 0 || // free
    this.bitrateIndex === 15)
      return;
    const D = `${Math.floor(this.version)}${this.layer}`;
    return MpegFrameHeader.bitrate_index[this.bitrateIndex][D];
  }
  calcSamplingRate() {
    return this.sampRateFreqIndex === 3 ? null : MpegFrameHeader.sampling_rate_freq_index[this.version][this.sampRateFreqIndex];
  }
}
MpegFrameHeader.SyncByte1 = 255;
MpegFrameHeader.SyncByte2 = 224;
MpegFrameHeader.VersionID = [2.5, null, 2, 1];
MpegFrameHeader.LayerDescription = [0, 3, 2, 1];
MpegFrameHeader.ChannelMode = ["stereo", "joint_stereo", "dual_channel", "mono"];
MpegFrameHeader.bitrate_index = {
  1: { 11: 32, 12: 32, 13: 32, 21: 32, 22: 8, 23: 8 },
  2: { 11: 64, 12: 48, 13: 40, 21: 48, 22: 16, 23: 16 },
  3: { 11: 96, 12: 56, 13: 48, 21: 56, 22: 24, 23: 24 },
  4: { 11: 128, 12: 64, 13: 56, 21: 64, 22: 32, 23: 32 },
  5: { 11: 160, 12: 80, 13: 64, 21: 80, 22: 40, 23: 40 },
  6: { 11: 192, 12: 96, 13: 80, 21: 96, 22: 48, 23: 48 },
  7: { 11: 224, 12: 112, 13: 96, 21: 112, 22: 56, 23: 56 },
  8: { 11: 256, 12: 128, 13: 112, 21: 128, 22: 64, 23: 64 },
  9: { 11: 288, 12: 160, 13: 128, 21: 144, 22: 80, 23: 80 },
  10: { 11: 320, 12: 192, 13: 160, 21: 160, 22: 96, 23: 96 },
  11: { 11: 352, 12: 224, 13: 192, 21: 176, 22: 112, 23: 112 },
  12: { 11: 384, 12: 256, 13: 224, 21: 192, 22: 128, 23: 128 },
  13: { 11: 416, 12: 320, 13: 256, 21: 224, 22: 144, 23: 144 },
  14: { 11: 448, 12: 384, 13: 320, 21: 256, 22: 160, 23: 160 }
};
MpegFrameHeader.sampling_rate_freq_index = {
  1: { 0: 44100, 1: 48e3, 2: 32e3 },
  2: { 0: 22050, 1: 24e3, 2: 16e3 },
  2.5: { 0: 11025, 1: 12e3, 2: 8e3 }
};
MpegFrameHeader.samplesInFrameTable = [
  /* Layer   I    II   III */
  [0, 384, 1152, 1152],
  [0, 384, 1152, 576]
  // MPEG-2(.5
];
const FrameHeader = {
  len: 4,
  get: (z, D) => new MpegFrameHeader(z, D)
};
function getVbrCodecProfile(z) {
  return "V" + Math.floor((100 - z) / 10);
}
class MpegParser extends AbstractID3Parser_1$2.AbstractID3Parser {
  constructor() {
    super(...arguments), this.frameCount = 0, this.syncFrameCount = -1, this.countSkipFrameData = 0, this.totalDataLength = 0, this.bitrates = [], this.calculateEofDuration = !1, this.buf_frame_header = Buffer.alloc(4), this.syncPeek = {
      buf: Buffer.alloc(maxPeekLen),
      len: 0
    };
  }
  /**
   * Called after ID3 headers have been parsed
   */
  async postId3v2Parse() {
    this.metadata.setFormat("lossless", !1);
    try {
      let D = !1;
      for (; !D; )
        await this.sync(), D = await this.parseCommonMpegHeader();
    } catch (D) {
      if (D instanceof core_1$1.EndOfStreamError) {
        if (debug$d("End-of-stream"), this.calculateEofDuration) {
          const O = this.frameCount * this.samplesPerFrame;
          this.metadata.setFormat("numberOfSamples", O);
          const F = O / this.metadata.format.sampleRate;
          debug$d(`Calculate duration at EOF: ${F} sec.`, F), this.metadata.setFormat("duration", F);
        }
      } else
        throw D;
    }
  }
  /**
   * Called after file has been fully parsed, this allows, if present, to exclude the ID3v1.1 header length
   */
  finalize() {
    const D = this.metadata.format, O = this.metadata.native.hasOwnProperty("ID3v1");
    if (D.duration && this.tokenizer.fileInfo.size) {
      const F = this.tokenizer.fileInfo.size - this.mpegOffset - (O ? 128 : 0);
      D.codecProfile && D.codecProfile[0] === "V" && this.metadata.setFormat("bitrate", F * 8 / D.duration);
    } else if (this.tokenizer.fileInfo.size && D.codecProfile === "CBR") {
      const F = this.tokenizer.fileInfo.size - this.mpegOffset - (O ? 128 : 0), U = Math.round(F / this.frame_size) * this.samplesPerFrame;
      this.metadata.setFormat("numberOfSamples", U);
      const W = U / D.sampleRate;
      debug$d("Calculate CBR duration based on file size: %s", W), this.metadata.setFormat("duration", W);
    }
  }
  async sync() {
    let D = !1;
    for (; ; ) {
      let O = 0;
      if (this.syncPeek.len = await this.tokenizer.peekBuffer(this.syncPeek.buf, { length: maxPeekLen, mayBeLess: !0 }), this.syncPeek.len <= 163)
        throw new core_1$1.EndOfStreamError();
      for (; ; )
        if (D && (this.syncPeek.buf[O] & 224) === 224) {
          this.buf_frame_header[0] = MpegFrameHeader.SyncByte1, this.buf_frame_header[1] = this.syncPeek.buf[O], await this.tokenizer.ignore(O), debug$d(`Sync at offset=${this.tokenizer.position - 1}, frameCount=${this.frameCount}`), this.syncFrameCount === this.frameCount && (debug$d(`Re-synced MPEG stream, frameCount=${this.frameCount}`), this.frameCount = 0, this.frame_size = 0), this.syncFrameCount = this.frameCount;
          return;
        } else if (D = !1, O = this.syncPeek.buf.indexOf(MpegFrameHeader.SyncByte1, O), O === -1) {
          if (this.syncPeek.len < this.syncPeek.buf.length)
            throw new core_1$1.EndOfStreamError();
          await this.tokenizer.ignore(this.syncPeek.len);
          break;
        } else
          ++O, D = !0;
    }
  }
  /**
   * Combined ADTS & MPEG (MP2 & MP3) header handling
   * @return {Promise<boolean>} true if parser should quit
   */
  async parseCommonMpegHeader() {
    this.frameCount === 0 && (this.mpegOffset = this.tokenizer.position - 1), await this.tokenizer.peekBuffer(this.buf_frame_header, { offset: 1, length: 3 });
    let D;
    try {
      D = FrameHeader.get(this.buf_frame_header, 0);
    } catch (O) {
      return await this.tokenizer.ignore(1), this.metadata.addWarning("Parse error: " + O.message), !1;
    }
    return await this.tokenizer.ignore(3), this.metadata.setFormat("container", D.container), this.metadata.setFormat("codec", D.codec), this.metadata.setFormat("lossless", !1), this.metadata.setFormat("sampleRate", D.samplingRate), this.frameCount++, D.version >= 2 && D.layer === 0 ? this.parseAdts(D) : this.parseAudioFrameHeader(D);
  }
  /**
   * @return {Promise<boolean>} true if parser should quit
   */
  async parseAudioFrameHeader(D) {
    this.metadata.setFormat("numberOfChannels", D.channelMode === "mono" ? 1 : 2), this.metadata.setFormat("bitrate", D.bitrate), this.frameCount < 20 * 1e4 && debug$d("offset=%s MP%s bitrate=%s sample-rate=%s", this.tokenizer.position - 4, D.layer, D.bitrate, D.samplingRate);
    const O = D.calcSlotSize();
    if (O === null)
      throw new Error("invalid slot_size");
    const F = D.calcSamplesPerFrame();
    debug$d(`samples_per_frame=${F}`);
    const W = F / 8 * D.bitrate / D.samplingRate + (D.padding ? O : 0);
    if (this.frame_size = Math.floor(W), this.audioFrameHeader = D, this.bitrates.push(D.bitrate), this.frameCount === 1)
      return this.offset = FrameHeader.len, await this.skipSideInformation(), !1;
    if (this.frameCount === 3) {
      if (this.areAllSame(this.bitrates)) {
        if (this.samplesPerFrame = F, this.metadata.setFormat("codecProfile", "CBR"), this.tokenizer.fileInfo.size)
          return !0;
      } else if (this.metadata.format.duration)
        return !0;
      if (!this.options.duration)
        return !0;
    }
    return this.options.duration && this.frameCount === 4 && (this.samplesPerFrame = F, this.calculateEofDuration = !0), this.offset = 4, D.isProtectedByCRC ? (await this.parseCrc(), !1) : (await this.skipSideInformation(), !1);
  }
  async parseAdts(D) {
    const O = Buffer.alloc(3);
    await this.tokenizer.readBuffer(O), D.frameLength += common.getBitAllignedNumber(O, 0, 0, 11), this.totalDataLength += D.frameLength, this.samplesPerFrame = 1024;
    const F = D.samplingRate / this.samplesPerFrame, W = 8 * (this.frameCount === 0 ? 0 : this.totalDataLength / this.frameCount) * F + 0.5;
    if (this.metadata.setFormat("bitrate", W), debug$d(`frame-count=${this.frameCount}, size=${D.frameLength} bytes, bit-rate=${W}`), await this.tokenizer.ignore(D.frameLength > 7 ? D.frameLength - 7 : 1), this.frameCount === 3)
      if (this.metadata.setFormat("codecProfile", D.codecProfile), D.mp4ChannelConfig && this.metadata.setFormat("numberOfChannels", D.mp4ChannelConfig.length), this.options.duration)
        this.calculateEofDuration = !0;
      else
        return !0;
    return !1;
  }
  async parseCrc() {
    return this.crc = await this.tokenizer.readNumber(Token$g.INT16_BE), this.offset += 2, this.skipSideInformation();
  }
  async skipSideInformation() {
    const D = this.audioFrameHeader.calculateSideInfoLength();
    await this.tokenizer.readToken(new Token$g.Uint8ArrayType(D)), this.offset += D, await this.readXtraInfoHeader();
  }
  async readXtraInfoHeader() {
    const D = await this.tokenizer.readToken(XingTag_1.InfoTagHeaderTag);
    switch (this.offset += XingTag_1.InfoTagHeaderTag.len, D) {
      case "Info":
        return this.metadata.setFormat("codecProfile", "CBR"), this.readXingInfoHeader();
      case "Xing":
        const F = await this.readXingInfoHeader(), U = getVbrCodecProfile(F.vbrScale);
        return this.metadata.setFormat("codecProfile", U), null;
      case "Xtra":
        break;
      case "LAME":
        const W = await this.tokenizer.readToken(XingTag_1.LameEncoderVersion);
        if (this.frame_size >= this.offset + XingTag_1.LameEncoderVersion.len)
          return this.offset += XingTag_1.LameEncoderVersion.len, this.metadata.setFormat("tool", "LAME " + W), await this.skipFrameData(this.frame_size - this.offset), null;
        this.metadata.addWarning("Corrupt LAME header");
        break;
    }
    const O = this.frame_size - this.offset;
    return O < 0 ? this.metadata.addWarning("Frame " + this.frameCount + "corrupt: negative frameDataLeft") : await this.skipFrameData(O), null;
  }
  /**
   * Ref: http://gabriel.mp3-tech.org/mp3infotag.html
   * @returns {Promise<string>}
   */
  async readXingInfoHeader() {
    const D = this.tokenizer.position, O = await (0, XingTag_1.readXingHeader)(this.tokenizer);
    if (this.offset += this.tokenizer.position - D, O.lame && (this.metadata.setFormat("tool", "LAME " + common.stripNulls(O.lame.version)), O.lame.extended && (this.metadata.setFormat("trackPeakLevel", O.lame.extended.track_peak), O.lame.extended.track_gain && this.metadata.setFormat("trackGain", O.lame.extended.track_gain.adjustment), O.lame.extended.album_gain && this.metadata.setFormat("albumGain", O.lame.extended.album_gain.adjustment), this.metadata.setFormat("duration", O.lame.extended.music_length / 1e3))), O.streamSize) {
      const U = this.audioFrameHeader.calcDuration(O.numFrames);
      return this.metadata.setFormat("duration", U), debug$d("Get duration from Xing header: %s", this.metadata.format.duration), O;
    }
    const F = this.frame_size - this.offset;
    return await this.skipFrameData(F), O;
  }
  async skipFrameData(D) {
    if (D < 0)
      throw new Error("frame-data-left cannot be negative");
    await this.tokenizer.ignore(D), this.countSkipFrameData += D;
  }
  areAllSame(D) {
    const O = D[0];
    return D.every((F) => F === O);
  }
}
MpegParser$1.MpegParser = MpegParser;
var musepack = {}, MpcSv8Parser$1 = {}, StreamVersion8 = {};
Object.defineProperty(StreamVersion8, "__esModule", { value: !0 });
StreamVersion8.StreamReader = void 0;
const Token$f = lib$1, debug_1$c = browserExports, util$5 = Util, debug$c = (0, debug_1$c.default)("music-metadata:parser:musepack:sv8"), PacketKey = new Token$f.StringType(2, "binary"), SH_part1 = {
  len: 5,
  get: (z, D) => ({
    crc: Token$f.UINT32_LE.get(z, D),
    streamVersion: Token$f.UINT8.get(z, D + 4)
  })
}, SH_part3 = {
  len: 2,
  get: (z, D) => ({
    sampleFrequency: [44100, 48e3, 37800, 32e3][util$5.getBitAllignedNumber(z, D, 0, 3)],
    maxUsedBands: util$5.getBitAllignedNumber(z, D, 3, 5),
    channelCount: util$5.getBitAllignedNumber(z, D + 1, 0, 4) + 1,
    msUsed: util$5.isBitSet(z, D + 1, 4),
    audioBlockFrames: util$5.getBitAllignedNumber(z, D + 1, 5, 3)
  })
};
class StreamReader {
  constructor(D) {
    this.tokenizer = D;
  }
  async readPacketHeader() {
    const D = await this.tokenizer.readToken(PacketKey), O = await this.readVariableSizeField();
    return {
      key: D,
      payloadLength: O.value - 2 - O.len
    };
  }
  async readStreamHeader(D) {
    const O = {};
    debug$c(`Reading SH at offset=${this.tokenizer.position}`);
    const F = await this.tokenizer.readToken(SH_part1);
    D -= SH_part1.len, Object.assign(O, F), debug$c(`SH.streamVersion = ${F.streamVersion}`);
    const U = await this.readVariableSizeField();
    D -= U.len, O.sampleCount = U.value;
    const W = await this.readVariableSizeField();
    D -= W.len, O.beginningOfSilence = W.value;
    const B = await this.tokenizer.readToken(SH_part3);
    return D -= SH_part3.len, Object.assign(O, B), await this.tokenizer.ignore(D), O;
  }
  async readVariableSizeField(D = 1, O = 0) {
    let F = await this.tokenizer.readNumber(Token$f.UINT8);
    return F & 128 ? (F &= 127, F += O, this.readVariableSizeField(D + 1, F << 7)) : { len: D, value: O + F };
  }
}
StreamVersion8.StreamReader = StreamReader;
Object.defineProperty(MpcSv8Parser$1, "__esModule", { value: !0 });
MpcSv8Parser$1.MpcSv8Parser = void 0;
const debug_1$b = browserExports, BasicParser_1$6 = BasicParser$1, APEv2Parser_1$4 = APEv2Parser$1, FourCC_1$6 = FourCC, SV8 = StreamVersion8, debug$b = (0, debug_1$b.default)("music-metadata:parser:musepack");
class MpcSv8Parser extends BasicParser_1$6.BasicParser {
  constructor() {
    super(...arguments), this.audioLength = 0;
  }
  async parse() {
    if (await this.tokenizer.readToken(FourCC_1$6.FourCcToken) !== "MPCK")
      throw new Error("Invalid Magic number");
    return this.metadata.setFormat("container", "Musepack, SV8"), this.parsePacket();
  }
  async parsePacket() {
    const D = new SV8.StreamReader(this.tokenizer);
    do {
      const O = await D.readPacketHeader();
      switch (debug$b(`packet-header key=${O.key}, payloadLength=${O.payloadLength}`), O.key) {
        case "SH":
          const F = await D.readStreamHeader(O.payloadLength);
          this.metadata.setFormat("numberOfSamples", F.sampleCount), this.metadata.setFormat("sampleRate", F.sampleFrequency), this.metadata.setFormat("duration", F.sampleCount / F.sampleFrequency), this.metadata.setFormat("numberOfChannels", F.channelCount);
          break;
        case "AP":
          this.audioLength += O.payloadLength, await this.tokenizer.ignore(O.payloadLength);
          break;
        case "RG":
        case "EI":
        case "SO":
        case "ST":
        case "CT":
          await this.tokenizer.ignore(O.payloadLength);
          break;
        case "SE":
          return this.metadata.setFormat("bitrate", this.audioLength * 8 / this.metadata.format.duration), APEv2Parser_1$4.APEv2Parser.tryParseApeHeader(this.metadata, this.tokenizer, this.options);
        default:
          throw new Error(`Unexpected header: ${O.key}`);
      }
    } while (!0);
  }
}
MpcSv8Parser$1.MpcSv8Parser = MpcSv8Parser;
var MpcSv7Parser$1 = {}, BitReader$1 = {};
Object.defineProperty(BitReader$1, "__esModule", { value: !0 });
BitReader$1.BitReader = void 0;
const Token$e = lib$1;
class BitReader {
  constructor(D) {
    this.tokenizer = D, this.pos = 0, this.dword = void 0;
  }
  /**
   *
   * @param bits 1..30 bits
   */
  async read(D) {
    for (; this.dword === void 0; )
      this.dword = await this.tokenizer.readToken(Token$e.UINT32_LE);
    let O = this.dword;
    return this.pos += D, this.pos < 32 ? (O >>>= 32 - this.pos, O & (1 << D) - 1) : (this.pos -= 32, this.pos === 0 ? (this.dword = void 0, O & (1 << D) - 1) : (this.dword = await this.tokenizer.readToken(Token$e.UINT32_LE), this.pos && (O <<= this.pos, O |= this.dword >>> 32 - this.pos), O & (1 << D) - 1));
  }
  async ignore(D) {
    if (this.pos > 0) {
      const U = 32 - this.pos;
      this.dword = void 0, D -= U, this.pos = 0;
    }
    const O = D % 32, F = (D - O) / 32;
    return await this.tokenizer.ignore(F * 4), this.read(O);
  }
}
BitReader$1.BitReader = BitReader;
var StreamVersion7 = {};
Object.defineProperty(StreamVersion7, "__esModule", { value: !0 });
StreamVersion7.Header = void 0;
const Token$d = lib$1, util$4 = Util;
StreamVersion7.Header = {
  len: 6 * 4,
  get: (z, D) => {
    const O = {
      // word 0
      signature: Buffer.from(z).toString("latin1", D, D + 3),
      // versionIndex number * 1000 (3.81 = 3810) (remember that 4-byte alignment causes this to take 4-bytes)
      streamMinorVersion: util$4.getBitAllignedNumber(z, D + 3, 0, 4),
      streamMajorVersion: util$4.getBitAllignedNumber(z, D + 3, 4, 4),
      // word 1
      frameCount: Token$d.UINT32_LE.get(z, D + 4),
      // word 2
      maxLevel: Token$d.UINT16_LE.get(z, D + 8),
      sampleFrequency: [44100, 48e3, 37800, 32e3][util$4.getBitAllignedNumber(z, D + 10, 0, 2)],
      link: util$4.getBitAllignedNumber(z, D + 10, 2, 2),
      profile: util$4.getBitAllignedNumber(z, D + 10, 4, 4),
      maxBand: util$4.getBitAllignedNumber(z, D + 11, 0, 6),
      intensityStereo: util$4.isBitSet(z, D + 11, 6),
      midSideStereo: util$4.isBitSet(z, D + 11, 7),
      // word 3
      titlePeak: Token$d.UINT16_LE.get(z, D + 12),
      titleGain: Token$d.UINT16_LE.get(z, D + 14),
      // word 4
      albumPeak: Token$d.UINT16_LE.get(z, D + 16),
      albumGain: Token$d.UINT16_LE.get(z, D + 18),
      // word
      lastFrameLength: Token$d.UINT32_LE.get(z, D + 20) >>> 20 & 2047,
      trueGapless: util$4.isBitSet(z, D + 23, 0)
    };
    return O.lastFrameLength = O.trueGapless ? Token$d.UINT32_LE.get(z, 20) >>> 20 & 2047 : 0, O;
  }
};
Object.defineProperty(MpcSv7Parser$1, "__esModule", { value: !0 });
MpcSv7Parser$1.MpcSv7Parser = void 0;
const debug_1$a = browserExports, BasicParser_1$5 = BasicParser$1, APEv2Parser_1$3 = APEv2Parser$1, BitReader_1 = BitReader$1, SV7 = StreamVersion7, debug$a = (0, debug_1$a.default)("music-metadata:parser:musepack");
class MpcSv7Parser extends BasicParser_1$5.BasicParser {
  constructor() {
    super(...arguments), this.audioLength = 0;
  }
  async parse() {
    const D = await this.tokenizer.readToken(SV7.Header);
    if (D.signature !== "MP+")
      throw new Error("Unexpected magic number");
    debug$a(`stream-version=${D.streamMajorVersion}.${D.streamMinorVersion}`), this.metadata.setFormat("container", "Musepack, SV7"), this.metadata.setFormat("sampleRate", D.sampleFrequency);
    const O = 1152 * (D.frameCount - 1) + D.lastFrameLength;
    this.metadata.setFormat("numberOfSamples", O), this.duration = O / D.sampleFrequency, this.metadata.setFormat("duration", this.duration), this.bitreader = new BitReader_1.BitReader(this.tokenizer), this.metadata.setFormat("numberOfChannels", D.midSideStereo || D.intensityStereo ? 2 : 1);
    const F = await this.bitreader.read(8);
    return this.metadata.setFormat("codec", (F / 100).toFixed(2)), await this.skipAudioData(D.frameCount), debug$a(`End of audio stream, switching to APEv2, offset=${this.tokenizer.position}`), APEv2Parser_1$3.APEv2Parser.tryParseApeHeader(this.metadata, this.tokenizer, this.options);
  }
  async skipAudioData(D) {
    for (; D-- > 0; ) {
      const F = await this.bitreader.read(20);
      this.audioLength += 20 + F, await this.bitreader.ignore(F);
    }
    const O = await this.bitreader.read(11);
    this.audioLength += O, this.metadata.setFormat("bitrate", this.audioLength / this.duration);
  }
}
MpcSv7Parser$1.MpcSv7Parser = MpcSv7Parser;
Object.defineProperty(musepack, "__esModule", { value: !0 });
const debug_1$9 = browserExports, Token$c = lib$1, AbstractID3Parser_1$1 = AbstractID3Parser$1, MpcSv8Parser_1 = MpcSv8Parser$1, MpcSv7Parser_1 = MpcSv7Parser$1, debug$9 = (0, debug_1$9.default)("music-metadata:parser:musepack");
class MusepackParser extends AbstractID3Parser_1$1.AbstractID3Parser {
  async postId3v2Parse() {
    const D = await this.tokenizer.peekToken(new Token$c.StringType(3, "binary"));
    let O;
    switch (D) {
      case "MP+": {
        debug$9("Musepack stream-version 7"), O = new MpcSv7Parser_1.MpcSv7Parser();
        break;
      }
      case "MPC": {
        debug$9("Musepack stream-version 8"), O = new MpcSv8Parser_1.MpcSv8Parser();
        break;
      }
      default:
        throw new Error("Invalid Musepack signature prefix");
    }
    return O.init(this.metadata, this.tokenizer, this.options), O.parse();
  }
}
musepack.default = MusepackParser;
var OggParser$1 = {}, OpusParser$1 = {}, Opus$1 = {};
Object.defineProperty(Opus$1, "__esModule", { value: !0 });
Opus$1.IdHeader = void 0;
const Token$b = lib$1;
class IdHeader {
  constructor(D) {
    if (this.len = D, D < 19)
      throw new Error("ID-header-page 0 should be at least 19 bytes long");
  }
  get(D, O) {
    return {
      magicSignature: new Token$b.StringType(8, "ascii").get(D, O + 0),
      version: D.readUInt8(O + 8),
      channelCount: D.readUInt8(O + 9),
      preSkip: D.readInt16LE(O + 10),
      inputSampleRate: D.readInt32LE(O + 12),
      outputGain: D.readInt16LE(O + 16),
      channelMapping: D.readUInt8(O + 18)
    };
  }
}
Opus$1.IdHeader = IdHeader;
Object.defineProperty(OpusParser$1, "__esModule", { value: !0 });
OpusParser$1.OpusParser = void 0;
const Token$a = lib$1, VorbisParser_1$2 = VorbisParser$1, Opus = Opus$1;
class OpusParser extends VorbisParser_1$2.VorbisParser {
  constructor(D, O, F) {
    super(D, O), this.tokenizer = F, this.lastPos = -1;
  }
  /**
   * Parse first Opus Ogg page
   * @param {IPageHeader} header
   * @param {Buffer} pageData
   */
  parseFirstPage(D, O) {
    if (this.metadata.setFormat("codec", "Opus"), this.idHeader = new Opus.IdHeader(O.length).get(O, 0), this.idHeader.magicSignature !== "OpusHead")
      throw new Error("Illegal ogg/Opus magic-signature");
    this.metadata.setFormat("sampleRate", this.idHeader.inputSampleRate), this.metadata.setFormat("numberOfChannels", this.idHeader.channelCount);
  }
  parseFullPage(D) {
    switch (new Token$a.StringType(8, "ascii").get(D, 0)) {
      case "OpusTags":
        this.parseUserCommentList(D, 8), this.lastPos = this.tokenizer.position - D.length;
        break;
    }
  }
  calculateDuration(D) {
    if (this.metadata.format.sampleRate && D.absoluteGranulePosition >= 0) {
      const O = D.absoluteGranulePosition - this.idHeader.preSkip;
      if (this.metadata.setFormat("numberOfSamples", O), this.metadata.setFormat("duration", O / 48e3), this.lastPos !== -1 && this.tokenizer.fileInfo.size && this.metadata.format.duration) {
        const F = this.tokenizer.fileInfo.size - this.lastPos;
        this.metadata.setFormat("bitrate", 8 * F / this.metadata.format.duration);
      }
    }
  }
}
OpusParser$1.OpusParser = OpusParser;
var SpeexParser$1 = {}, Speex$1 = {};
Object.defineProperty(Speex$1, "__esModule", { value: !0 });
Speex$1.Header = void 0;
const Token$9 = lib$1, util$3 = Util;
Speex$1.Header = {
  len: 80,
  get: (z, D) => ({
    speex: new Token$9.StringType(8, "ascii").get(z, D + 0),
    version: util$3.trimRightNull(new Token$9.StringType(20, "ascii").get(z, D + 8)),
    version_id: z.readInt32LE(D + 28),
    header_size: z.readInt32LE(D + 32),
    rate: z.readInt32LE(D + 36),
    mode: z.readInt32LE(D + 40),
    mode_bitstream_version: z.readInt32LE(D + 44),
    nb_channels: z.readInt32LE(D + 48),
    bitrate: z.readInt32LE(D + 52),
    frame_size: z.readInt32LE(D + 56),
    vbr: z.readInt32LE(D + 60),
    frames_per_packet: z.readInt32LE(D + 64),
    extra_headers: z.readInt32LE(D + 68),
    reserved1: z.readInt32LE(D + 72),
    reserved2: z.readInt32LE(D + 76)
  })
};
Object.defineProperty(SpeexParser$1, "__esModule", { value: !0 });
SpeexParser$1.SpeexParser = void 0;
const debug_1$8 = browserExports, VorbisParser_1$1 = VorbisParser$1, Speex = Speex$1, debug$8 = (0, debug_1$8.default)("music-metadata:parser:ogg:speex");
class SpeexParser extends VorbisParser_1$1.VorbisParser {
  constructor(D, O, F) {
    super(D, O), this.tokenizer = F;
  }
  /**
   * Parse first Speex Ogg page
   * @param {IPageHeader} header
   * @param {Buffer} pageData
   */
  parseFirstPage(D, O) {
    debug$8("First Ogg/Speex page");
    const F = Speex.Header.get(O, 0);
    this.metadata.setFormat("codec", `Speex ${F.version}`), this.metadata.setFormat("numberOfChannels", F.nb_channels), this.metadata.setFormat("sampleRate", F.rate), F.bitrate !== -1 && this.metadata.setFormat("bitrate", F.bitrate);
  }
}
SpeexParser$1.SpeexParser = SpeexParser;
var TheoraParser$1 = {}, Theora = {};
Object.defineProperty(Theora, "__esModule", { value: !0 });
Theora.IdentificationHeader = void 0;
const Token$8 = lib$1;
Theora.IdentificationHeader = {
  len: 42,
  get: (z, D) => ({
    id: new Token$8.StringType(7, "ascii").get(z, D),
    vmaj: z.readUInt8(D + 7),
    vmin: z.readUInt8(D + 8),
    vrev: z.readUInt8(D + 9),
    vmbw: z.readUInt16BE(D + 10),
    vmbh: z.readUInt16BE(D + 17),
    nombr: Token$8.UINT24_BE.get(z, D + 37),
    nqual: z.readUInt8(D + 40)
  })
};
Object.defineProperty(TheoraParser$1, "__esModule", { value: !0 });
TheoraParser$1.TheoraParser = void 0;
const debug_1$7 = browserExports, Theora_1 = Theora, debug$7 = (0, debug_1$7.default)("music-metadata:parser:ogg:theora");
class TheoraParser {
  constructor(D, O, F) {
    this.metadata = D, this.tokenizer = F;
  }
  /**
   * Vorbis 1 parser
   * @param header Ogg Page Header
   * @param pageData Page data
   */
  parsePage(D, O) {
    D.headerType.firstPage && this.parseFirstPage(D, O);
  }
  flush() {
    debug$7("flush");
  }
  calculateDuration(D) {
    debug$7("duration calculation not implemented");
  }
  /**
   * Parse first Theora Ogg page. the initial identification header packet
   * @param {IPageHeader} header
   * @param {Buffer} pageData
   */
  parseFirstPage(D, O) {
    debug$7("First Ogg/Theora page"), this.metadata.setFormat("codec", "Theora");
    const F = Theora_1.IdentificationHeader.get(O, 0);
    this.metadata.setFormat("bitrate", F.nombr);
  }
}
TheoraParser$1.TheoraParser = TheoraParser;
Object.defineProperty(OggParser$1, "__esModule", { value: !0 });
OggParser$1.OggParser = OggParser$1.SegmentTable = void 0;
const Token$7 = lib$1, core_1 = core$1, debug_1$6 = browserExports, util$2 = Util, FourCC_1$5 = FourCC, BasicParser_1$4 = BasicParser$1, VorbisParser_1 = VorbisParser$1, OpusParser_1 = OpusParser$1, SpeexParser_1 = SpeexParser$1, TheoraParser_1 = TheoraParser$1, debug$6 = (0, debug_1$6.default)("music-metadata:parser:ogg");
class SegmentTable {
  static sum(D, O, F) {
    let U = 0;
    for (let W = O; W < O + F; ++W)
      U += D[W];
    return U;
  }
  constructor(D) {
    this.len = D.page_segments;
  }
  get(D, O) {
    return {
      totalPageSize: SegmentTable.sum(D, O, this.len)
    };
  }
}
OggParser$1.SegmentTable = SegmentTable;
class OggParser extends BasicParser_1$4.BasicParser {
  /**
   * Parse page
   * @returns {Promise<void>}
   */
  async parse() {
    debug$6("pos=%s, parsePage()", this.tokenizer.position);
    try {
      let D;
      do {
        if (D = await this.tokenizer.readToken(OggParser.Header), D.capturePattern !== "OggS")
          throw new Error("Invalid Ogg capture pattern");
        this.metadata.setFormat("container", "Ogg"), this.header = D, this.pageNumber = D.pageSequenceNo, debug$6("page#=%s, Ogg.id=%s", D.pageSequenceNo, D.capturePattern);
        const O = await this.tokenizer.readToken(new SegmentTable(D));
        debug$6("totalPageSize=%s", O.totalPageSize);
        const F = await this.tokenizer.readToken(new Token$7.Uint8ArrayType(O.totalPageSize));
        if (debug$6("firstPage=%s, lastPage=%s, continued=%s", D.headerType.firstPage, D.headerType.lastPage, D.headerType.continued), D.headerType.firstPage) {
          const U = new Token$7.StringType(7, "ascii").get(Buffer.from(F), 0);
          switch (U) {
            case "vorbis":
              debug$6("Set page consumer to Ogg/Vorbis"), this.pageConsumer = new VorbisParser_1.VorbisParser(this.metadata, this.options);
              break;
            case "OpusHea":
              debug$6("Set page consumer to Ogg/Opus"), this.pageConsumer = new OpusParser_1.OpusParser(this.metadata, this.options, this.tokenizer);
              break;
            case "Speex  ":
              debug$6("Set page consumer to Ogg/Speex"), this.pageConsumer = new SpeexParser_1.SpeexParser(this.metadata, this.options, this.tokenizer);
              break;
            case "fishead":
            case "\0theora":
              debug$6("Set page consumer to Ogg/Theora"), this.pageConsumer = new TheoraParser_1.TheoraParser(this.metadata, this.options, this.tokenizer);
              break;
            default:
              throw new Error("gg audio-codec not recognized (id=" + U + ")");
          }
        }
        this.pageConsumer.parsePage(D, F);
      } while (!D.headerType.lastPage);
    } catch (D) {
      if (D instanceof core_1.EndOfStreamError)
        this.metadata.addWarning("Last OGG-page is not marked with last-page flag"), debug$6("End-of-stream"), this.metadata.addWarning("Last OGG-page is not marked with last-page flag"), this.header && this.pageConsumer.calculateDuration(this.header);
      else if (D.message.startsWith("FourCC"))
        this.pageNumber > 0 && (this.metadata.addWarning("Invalid FourCC ID, maybe last OGG-page is not marked with last-page flag"), this.pageConsumer.flush());
      else
        throw D;
    }
  }
}
OggParser.Header = {
  len: 27,
  get: (z, D) => ({
    capturePattern: FourCC_1$5.FourCcToken.get(z, D),
    version: Token$7.UINT8.get(z, D + 4),
    headerType: {
      continued: util$2.getBit(z, D + 5, 0),
      firstPage: util$2.getBit(z, D + 5, 1),
      lastPage: util$2.getBit(z, D + 5, 2)
    },
    // packet_flag: buf.readUInt8(off + 5),
    absoluteGranulePosition: Number(Token$7.UINT64_LE.get(z, D + 6)),
    streamSerialNumber: Token$7.UINT32_LE.get(z, D + 14),
    pageSequenceNo: Token$7.UINT32_LE.get(z, D + 18),
    pageChecksum: Token$7.UINT32_LE.get(z, D + 22),
    page_segments: Token$7.UINT8.get(z, D + 26)
  })
};
OggParser$1.OggParser = OggParser;
var WaveParser$1 = {}, RiffChunk = {};
Object.defineProperty(RiffChunk, "__esModule", { value: !0 });
RiffChunk.ListInfoTagValue = RiffChunk.Header = void 0;
const Token$6 = lib$1;
RiffChunk.Header = {
  len: 8,
  get: (z, D) => ({
    // Group-ID
    chunkID: z.toString("binary", D, D + 4),
    // Size
    chunkSize: Token$6.UINT32_LE.get(z, 4)
  })
};
class ListInfoTagValue {
  constructor(D) {
    this.tagHeader = D, this.len = D.chunkSize, this.len += this.len & 1;
  }
  get(D, O) {
    return new Token$6.StringType(this.tagHeader.chunkSize, "ascii").get(D, O);
  }
}
RiffChunk.ListInfoTagValue = ListInfoTagValue;
var WaveChunk$1 = {};
(function(z) {
  Object.defineProperty(z, "__esModule", { value: !0 }), z.FactChunk = z.Format = z.WaveFormat = void 0, function(F) {
    F[F.PCM = 1] = "PCM", F[F.ADPCM = 2] = "ADPCM", F[F.IEEE_FLOAT = 3] = "IEEE_FLOAT", F[F.MPEG_ADTS_AAC = 5632] = "MPEG_ADTS_AAC", F[F.MPEG_LOAS = 5634] = "MPEG_LOAS", F[F.RAW_AAC1 = 255] = "RAW_AAC1", F[F.DOLBY_AC3_SPDIF = 146] = "DOLBY_AC3_SPDIF", F[F.DVM = 8192] = "DVM", F[F.RAW_SPORT = 576] = "RAW_SPORT", F[F.ESST_AC3 = 577] = "ESST_AC3", F[F.DRM = 9] = "DRM", F[F.DTS2 = 8193] = "DTS2", F[F.MPEG = 80] = "MPEG";
  }(z.WaveFormat || (z.WaveFormat = {}));
  class D {
    constructor(U) {
      if (U.chunkSize < 16)
        throw new Error("Invalid chunk size");
      this.len = U.chunkSize;
    }
    get(U, W) {
      return {
        wFormatTag: U.readUInt16LE(W),
        nChannels: U.readUInt16LE(W + 2),
        nSamplesPerSec: U.readUInt32LE(W + 4),
        nAvgBytesPerSec: U.readUInt32LE(W + 8),
        nBlockAlign: U.readUInt16LE(W + 12),
        wBitsPerSample: U.readUInt16LE(W + 14)
      };
    }
  }
  z.Format = D;
  class O {
    constructor(U) {
      if (U.chunkSize < 4)
        throw new Error("Invalid fact chunk size.");
      this.len = U.chunkSize;
    }
    get(U, W) {
      return {
        dwSampleLength: U.readUInt32LE(W)
      };
    }
  }
  z.FactChunk = O;
})(WaveChunk$1);
var BwfChunk = {};
Object.defineProperty(BwfChunk, "__esModule", { value: !0 });
BwfChunk.BroadcastAudioExtensionChunk = void 0;
const Token$5 = lib$1, Util_1 = Util;
BwfChunk.BroadcastAudioExtensionChunk = {
  len: 420,
  get: (z, D) => ({
    description: (0, Util_1.stripNulls)(new Token$5.StringType(256, "ascii").get(z, D)).trim(),
    originator: (0, Util_1.stripNulls)(new Token$5.StringType(32, "ascii").get(z, D + 256)).trim(),
    originatorReference: (0, Util_1.stripNulls)(new Token$5.StringType(32, "ascii").get(z, D + 288)).trim(),
    originationDate: (0, Util_1.stripNulls)(new Token$5.StringType(10, "ascii").get(z, D + 320)).trim(),
    originationTime: (0, Util_1.stripNulls)(new Token$5.StringType(8, "ascii").get(z, D + 330)).trim(),
    timeReferenceLow: Token$5.UINT32_LE.get(z, D + 338),
    timeReferenceHigh: Token$5.UINT32_LE.get(z, D + 342),
    version: Token$5.UINT16_LE.get(z, D + 346),
    umid: new Token$5.Uint8ArrayType(64).get(z, D + 348),
    loudnessValue: Token$5.UINT16_LE.get(z, D + 412),
    maxTruePeakLevel: Token$5.UINT16_LE.get(z, D + 414),
    maxMomentaryLoudness: Token$5.UINT16_LE.get(z, D + 416),
    maxShortTermLoudness: Token$5.UINT16_LE.get(z, D + 418)
  })
};
Object.defineProperty(WaveParser$1, "__esModule", { value: !0 });
WaveParser$1.WaveParser = void 0;
const strtok3$2 = core$1, Token$4 = lib$1, debug_1$5 = browserExports, riff = RiffChunk, WaveChunk = WaveChunk$1, ID3v2Parser_1$2 = ID3v2Parser$1, util$1 = Util, FourCC_1$4 = FourCC, BasicParser_1$3 = BasicParser$1, BwfChunk_1 = BwfChunk, debug$5 = (0, debug_1$5.default)("music-metadata:parser:RIFF");
class WaveParser extends BasicParser_1$3.BasicParser {
  async parse() {
    const D = await this.tokenizer.readToken(riff.Header);
    if (debug$5(`pos=${this.tokenizer.position}, parse: chunkID=${D.chunkID}`), D.chunkID === "RIFF")
      return this.parseRiffChunk(D.chunkSize).catch((O) => {
        if (!(O instanceof strtok3$2.EndOfStreamError))
          throw O;
      });
  }
  async parseRiffChunk(D) {
    const O = await this.tokenizer.readToken(FourCC_1$4.FourCcToken);
    switch (this.metadata.setFormat("container", O), O) {
      case "WAVE":
        return this.readWaveChunk(D - FourCC_1$4.FourCcToken.len);
      default:
        throw new Error(`Unsupported RIFF format: RIFF/${O}`);
    }
  }
  async readWaveChunk(D) {
    for (; D >= riff.Header.len; ) {
      const O = await this.tokenizer.readToken(riff.Header);
      switch (D -= riff.Header.len + O.chunkSize, O.chunkSize > D && this.metadata.addWarning("Data chunk size exceeds file size"), this.header = O, debug$5(`pos=${this.tokenizer.position}, readChunk: chunkID=RIFF/WAVE/${O.chunkID}`), O.chunkID) {
        case "LIST":
          await this.parseListTag(O);
          break;
        case "fact":
          this.metadata.setFormat("lossless", !1), this.fact = await this.tokenizer.readToken(new WaveChunk.FactChunk(O));
          break;
        case "fmt ":
          const F = await this.tokenizer.readToken(new WaveChunk.Format(O));
          let U = WaveChunk.WaveFormat[F.wFormatTag];
          U || (debug$5("WAVE/non-PCM format=" + F.wFormatTag), U = "non-PCM (" + F.wFormatTag + ")"), this.metadata.setFormat("codec", U), this.metadata.setFormat("bitsPerSample", F.wBitsPerSample), this.metadata.setFormat("sampleRate", F.nSamplesPerSec), this.metadata.setFormat("numberOfChannels", F.nChannels), this.metadata.setFormat("bitrate", F.nBlockAlign * F.nSamplesPerSec * 8), this.blockAlign = F.nBlockAlign;
          break;
        case "id3 ":
        case "ID3 ":
          const W = await this.tokenizer.readToken(new Token$4.Uint8ArrayType(O.chunkSize)), B = strtok3$2.fromBuffer(W);
          await new ID3v2Parser_1$2.ID3v2Parser().parse(this.metadata, B, this.options);
          break;
        case "data":
          this.metadata.format.lossless !== !1 && this.metadata.setFormat("lossless", !0);
          let K = O.chunkSize;
          if (this.tokenizer.fileInfo.size) {
            const J = this.tokenizer.fileInfo.size - this.tokenizer.position;
            J < K && (this.metadata.addWarning("data chunk length exceeding file length"), K = J);
          }
          const X = this.fact ? this.fact.dwSampleLength : K === 4294967295 ? void 0 : K / this.blockAlign;
          X && (this.metadata.setFormat("numberOfSamples", X), this.metadata.setFormat("duration", X / this.metadata.format.sampleRate)), this.metadata.format.codec === "ADPCM" ? this.metadata.setFormat("bitrate", 352e3) : this.metadata.setFormat("bitrate", this.blockAlign * this.metadata.format.sampleRate * 8), await this.tokenizer.ignore(O.chunkSize);
          break;
        case "bext":
          const Y = await this.tokenizer.readToken(BwfChunk_1.BroadcastAudioExtensionChunk);
          Object.keys(Y).forEach((J) => {
            this.metadata.addTag("exif", "bext." + J, Y[J]);
          });
          const Q = O.chunkSize - BwfChunk_1.BroadcastAudioExtensionChunk.len;
          await this.tokenizer.ignore(Q);
          break;
        case "\0\0\0\0":
          debug$5(`Ignore padding chunk: RIFF/${O.chunkID} of ${O.chunkSize} bytes`), this.metadata.addWarning("Ignore chunk: RIFF/" + O.chunkID), await this.tokenizer.ignore(O.chunkSize);
          break;
        default:
          debug$5(`Ignore chunk: RIFF/${O.chunkID} of ${O.chunkSize} bytes`), this.metadata.addWarning("Ignore chunk: RIFF/" + O.chunkID), await this.tokenizer.ignore(O.chunkSize);
      }
      this.header.chunkSize % 2 === 1 && (debug$5("Read odd padding byte"), await this.tokenizer.ignore(1));
    }
  }
  async parseListTag(D) {
    const O = await this.tokenizer.readToken(new Token$4.StringType(4, "binary"));
    switch (debug$5("pos=%s, parseListTag: chunkID=RIFF/WAVE/LIST/%s", this.tokenizer.position, O), O) {
      case "INFO":
        return this.parseRiffInfoTags(D.chunkSize - 4);
      case "adtl":
      default:
        return this.metadata.addWarning("Ignore chunk: RIFF/WAVE/LIST/" + O), debug$5("Ignoring chunkID=RIFF/WAVE/LIST/" + O), this.tokenizer.ignore(D.chunkSize - 4).then();
    }
  }
  async parseRiffInfoTags(D) {
    for (; D >= 8; ) {
      const O = await this.tokenizer.readToken(riff.Header), F = new riff.ListInfoTagValue(O), U = await this.tokenizer.readToken(F);
      this.addTag(O.chunkID, util$1.stripNulls(U)), D -= 8 + F.len;
    }
    if (D !== 0)
      throw Error("Illegal remaining size: " + D);
  }
  addTag(D, O) {
    this.metadata.addTag("exif", D, O);
  }
}
WaveParser$1.WaveParser = WaveParser;
var WavPackParser$1 = {}, WavPackToken = {};
Object.defineProperty(WavPackToken, "__esModule", { value: !0 });
WavPackToken.WavPack = void 0;
const Token$3 = lib$1, FourCC_1$3 = FourCC, SampleRates = [
  6e3,
  8e3,
  9600,
  11025,
  12e3,
  16e3,
  22050,
  24e3,
  32e3,
  44100,
  48e3,
  64e3,
  88200,
  96e3,
  192e3,
  -1
];
class WavPack {
  static isBitSet(D, O) {
    return WavPack.getBitAllignedNumber(D, O, 1) === 1;
  }
  static getBitAllignedNumber(D, O, F) {
    return D >>> O & 4294967295 >>> 32 - F;
  }
}
WavPack.BlockHeaderToken = {
  len: 32,
  get: (z, D) => {
    const O = Token$3.UINT32_LE.get(z, D + 24), F = {
      // should equal 'wvpk'
      BlockID: FourCC_1$3.FourCcToken.get(z, D),
      //  0x402 to 0x410 are valid for decode
      blockSize: Token$3.UINT32_LE.get(z, D + 4),
      //  0x402 (1026) to 0x410 are valid for decode
      version: Token$3.UINT16_LE.get(z, D + 8),
      //  40-bit total samples for entire file (if block_index == 0 and a value of -1 indicates an unknown length)
      totalSamples: (
        /* replace with bigint? (Token.UINT8.get(buf, off + 11) << 32) + */
        Token$3.UINT32_LE.get(z, D + 12)
      ),
      // 40-bit block_index
      blockIndex: (
        /* replace with bigint? (Token.UINT8.get(buf, off + 10) << 32) + */
        Token$3.UINT32_LE.get(z, D + 16)
      ),
      // 40-bit total samples for entire file (if block_index == 0 and a value of -1 indicates an unknown length)
      blockSamples: Token$3.UINT32_LE.get(z, D + 20),
      // various flags for id and decoding
      flags: {
        bitsPerSample: (1 + WavPack.getBitAllignedNumber(O, 0, 2)) * 8,
        isMono: WavPack.isBitSet(O, 2),
        isHybrid: WavPack.isBitSet(O, 3),
        isJointStereo: WavPack.isBitSet(O, 4),
        crossChannel: WavPack.isBitSet(O, 5),
        hybridNoiseShaping: WavPack.isBitSet(O, 6),
        floatingPoint: WavPack.isBitSet(O, 7),
        samplingRate: SampleRates[WavPack.getBitAllignedNumber(O, 23, 4)],
        isDSD: WavPack.isBitSet(O, 31)
      },
      // crc for actual decoded data
      crc: new Token$3.Uint8ArrayType(4).get(z, D + 28)
    };
    return F.flags.isDSD && (F.totalSamples *= 8), F;
  }
};
WavPack.MetadataIdToken = {
  len: 1,
  get: (z, D) => ({
    functionId: WavPack.getBitAllignedNumber(z[D], 0, 6),
    isOptional: WavPack.isBitSet(z[D], 5),
    isOddSize: WavPack.isBitSet(z[D], 6),
    largeBlock: WavPack.isBitSet(z[D], 7)
  })
};
WavPackToken.WavPack = WavPack;
Object.defineProperty(WavPackParser$1, "__esModule", { value: !0 });
WavPackParser$1.WavPackParser = void 0;
const Token$2 = lib$1, APEv2Parser_1$2 = APEv2Parser$1, FourCC_1$2 = FourCC, BasicParser_1$2 = BasicParser$1, WavPackToken_1 = WavPackToken, debug_1$4 = browserExports, debug$4 = (0, debug_1$4.default)("music-metadata:parser:WavPack");
class WavPackParser extends BasicParser_1$2.BasicParser {
  async parse() {
    return this.audioDataSize = 0, await this.parseWavPackBlocks(), APEv2Parser_1$2.APEv2Parser.tryParseApeHeader(this.metadata, this.tokenizer, this.options);
  }
  async parseWavPackBlocks() {
    do {
      if (await this.tokenizer.peekToken(FourCC_1$2.FourCcToken) !== "wvpk")
        break;
      const O = await this.tokenizer.readToken(WavPackToken_1.WavPack.BlockHeaderToken);
      if (O.BlockID !== "wvpk")
        throw new Error("Invalid WavPack Block-ID");
      debug$4(`WavPack header blockIndex=${O.blockIndex}, len=${WavPackToken_1.WavPack.BlockHeaderToken.len}`), O.blockIndex === 0 && !this.metadata.format.container && (this.metadata.setFormat("container", "WavPack"), this.metadata.setFormat("lossless", !O.flags.isHybrid), this.metadata.setFormat("bitsPerSample", O.flags.bitsPerSample), O.flags.isDSD || (this.metadata.setFormat("sampleRate", O.flags.samplingRate), this.metadata.setFormat("duration", O.totalSamples / O.flags.samplingRate)), this.metadata.setFormat("numberOfChannels", O.flags.isMono ? 1 : 2), this.metadata.setFormat("numberOfSamples", O.totalSamples), this.metadata.setFormat("codec", O.flags.isDSD ? "DSD" : "PCM"));
      const F = O.blockSize - (WavPackToken_1.WavPack.BlockHeaderToken.len - 8);
      await (O.blockIndex === 0 ? this.parseMetadataSubBlock(O, F) : this.tokenizer.ignore(F)), O.blockSamples > 0 && (this.audioDataSize += O.blockSize);
    } while (!this.tokenizer.fileInfo.size || this.tokenizer.fileInfo.size - this.tokenizer.position >= WavPackToken_1.WavPack.BlockHeaderToken.len);
    this.metadata.setFormat("bitrate", this.audioDataSize * 8 / this.metadata.format.duration);
  }
  /**
   * Ref: http://www.wavpack.com/WavPack5FileFormat.pdf, 3.0 Metadata Sub-blocks
   * @param remainingLength
   */
  async parseMetadataSubBlock(D, O) {
    for (; O > WavPackToken_1.WavPack.MetadataIdToken.len; ) {
      const F = await this.tokenizer.readToken(WavPackToken_1.WavPack.MetadataIdToken), U = await this.tokenizer.readNumber(F.largeBlock ? Token$2.UINT24_LE : Token$2.UINT8), W = Buffer.alloc(U * 2 - (F.isOddSize ? 1 : 0));
      switch (await this.tokenizer.readBuffer(W), debug$4(`Metadata Sub-Blocks functionId=0x${F.functionId.toString(16)}, id.largeBlock=${F.largeBlock},data-size=${W.length}`), F.functionId) {
        case 0:
          break;
        case 14:
          debug$4("ID_DSD_BLOCK");
          const B = 1 << W.readUInt8(0), K = D.flags.samplingRate * B * 8;
          if (!D.flags.isDSD)
            throw new Error("Only expect DSD block if DSD-flag is set");
          this.metadata.setFormat("sampleRate", K), this.metadata.setFormat("duration", D.totalSamples / K);
          break;
        case 36:
          debug$4("ID_ALT_TRAILER: trailer for non-wav files");
          break;
        case 38:
          this.metadata.setFormat("audioMD5", W);
          break;
        case 47:
          debug$4(`ID_BLOCK_CHECKSUM: checksum=${W.toString("hex")}`);
          break;
        default:
          debug$4(`Ignore unsupported meta-sub-block-id functionId=0x${F.functionId.toString(16)}`);
          break;
      }
      O -= WavPackToken_1.WavPack.MetadataIdToken.len + (F.largeBlock ? Token$2.UINT24_LE.len : Token$2.UINT8.len) + U * 2, debug$4(`remainingLength=${O}`), F.isOddSize && this.tokenizer.ignore(1);
    }
    if (O !== 0)
      throw new Error("metadata-sub-block should fit it remaining length");
  }
}
WavPackParser$1.WavPackParser = WavPackParser;
var DsfParser$1 = {}, DsfChunk = {};
(function(z) {
  Object.defineProperty(z, "__esModule", { value: !0 }), z.FormatChunk = z.ChannelType = z.DsdChunk = z.ChunkHeader = void 0;
  const D = lib$1, O = FourCC;
  z.ChunkHeader = {
    len: 12,
    get: (F, U) => ({ id: O.FourCcToken.get(F, U), size: D.UINT64_LE.get(F, U + 4) })
  }, z.DsdChunk = {
    len: 16,
    get: (F, U) => ({
      fileSize: D.INT64_LE.get(F, U),
      metadataPointer: D.INT64_LE.get(F, U + 8)
    })
  }, function(F) {
    F[F.mono = 1] = "mono", F[F.stereo = 2] = "stereo", F[F.channels = 3] = "channels", F[F.quad = 4] = "quad", F[F["4 channels"] = 5] = "4 channels", F[F["5 channels"] = 6] = "5 channels", F[F["5.1 channels"] = 7] = "5.1 channels";
  }(z.ChannelType || (z.ChannelType = {})), z.FormatChunk = {
    len: 40,
    get: (F, U) => ({
      formatVersion: D.INT32_LE.get(F, U),
      formatID: D.INT32_LE.get(F, U + 4),
      channelType: D.INT32_LE.get(F, U + 8),
      channelNum: D.INT32_LE.get(F, U + 12),
      samplingFrequency: D.INT32_LE.get(F, U + 16),
      bitsPerSample: D.INT32_LE.get(F, U + 20),
      sampleCount: D.INT64_LE.get(F, U + 24),
      blockSizePerChannel: D.INT32_LE.get(F, U + 32)
    })
  };
})(DsfChunk);
Object.defineProperty(DsfParser$1, "__esModule", { value: !0 });
DsfParser$1.DsfParser = void 0;
const debug_1$3 = browserExports, AbstractID3Parser_1 = AbstractID3Parser$1, DsfChunk_1 = DsfChunk, ID3v2Parser_1$1 = ID3v2Parser$1, debug$3 = (0, debug_1$3.default)("music-metadata:parser:DSF");
class DsfParser extends AbstractID3Parser_1.AbstractID3Parser {
  async postId3v2Parse() {
    const D = this.tokenizer.position, O = await this.tokenizer.readToken(DsfChunk_1.ChunkHeader);
    if (O.id !== "DSD ")
      throw new Error("Invalid chunk signature");
    this.metadata.setFormat("container", "DSF"), this.metadata.setFormat("lossless", !0);
    const F = await this.tokenizer.readToken(DsfChunk_1.DsdChunk);
    if (F.metadataPointer === BigInt(0))
      debug$3("No ID3v2 tag present");
    else
      return debug$3(`expect ID3v2 at offset=${F.metadataPointer}`), await this.parseChunks(F.fileSize - O.size), await this.tokenizer.ignore(Number(F.metadataPointer) - this.tokenizer.position - D), new ID3v2Parser_1$1.ID3v2Parser().parse(this.metadata, this.tokenizer, this.options);
  }
  async parseChunks(D) {
    for (; D >= DsfChunk_1.ChunkHeader.len; ) {
      const O = await this.tokenizer.readToken(DsfChunk_1.ChunkHeader);
      switch (debug$3(`Parsing chunk name=${O.id} size=${O.size}`), O.id) {
        case "fmt ":
          const F = await this.tokenizer.readToken(DsfChunk_1.FormatChunk);
          this.metadata.setFormat("numberOfChannels", F.channelNum), this.metadata.setFormat("sampleRate", F.samplingFrequency), this.metadata.setFormat("bitsPerSample", F.bitsPerSample), this.metadata.setFormat("numberOfSamples", F.sampleCount), this.metadata.setFormat("duration", Number(F.sampleCount) / F.samplingFrequency);
          const U = F.bitsPerSample * F.samplingFrequency * F.channelNum;
          this.metadata.setFormat("bitrate", U);
          return;
        default:
          this.tokenizer.ignore(Number(O.size) - DsfChunk_1.ChunkHeader.len);
          break;
      }
      D -= O.size;
    }
  }
}
DsfParser$1.DsfParser = DsfParser;
var DsdiffParser$1 = {}, DsdiffToken = {};
Object.defineProperty(DsdiffToken, "__esModule", { value: !0 });
DsdiffToken.ChunkHeader64 = void 0;
const Token$1 = lib$1, FourCC_1$1 = FourCC;
DsdiffToken.ChunkHeader64 = {
  len: 12,
  get: (z, D) => ({
    // Group-ID
    chunkID: FourCC_1$1.FourCcToken.get(z, D),
    // Size
    chunkSize: Token$1.INT64_BE.get(z, D + 4)
  })
};
Object.defineProperty(DsdiffParser$1, "__esModule", { value: !0 });
DsdiffParser$1.DsdiffParser = void 0;
const Token = lib$1, debug_1$2 = browserExports, strtok3$1 = core$1, FourCC_1 = FourCC, BasicParser_1$1 = BasicParser$1, ID3v2Parser_1 = ID3v2Parser$1, DsdiffToken_1 = DsdiffToken, debug$2 = (0, debug_1$2.default)("music-metadata:parser:aiff");
class DsdiffParser extends BasicParser_1$1.BasicParser {
  async parse() {
    const D = await this.tokenizer.readToken(DsdiffToken_1.ChunkHeader64);
    if (D.chunkID !== "FRM8")
      throw new Error("Unexpected chunk-ID");
    const O = (await this.tokenizer.readToken(FourCC_1.FourCcToken)).trim();
    switch (O) {
      case "DSD":
        return this.metadata.setFormat("container", `DSDIFF/${O}`), this.metadata.setFormat("lossless", !0), this.readFmt8Chunks(D.chunkSize - BigInt(FourCC_1.FourCcToken.len));
      default:
        throw Error(`Unsupported DSDIFF type: ${O}`);
    }
  }
  async readFmt8Chunks(D) {
    for (; D >= DsdiffToken_1.ChunkHeader64.len; ) {
      const O = await this.tokenizer.readToken(DsdiffToken_1.ChunkHeader64);
      debug$2(`Chunk id=${O.chunkID}`), await this.readData(O), D -= BigInt(DsdiffToken_1.ChunkHeader64.len) + O.chunkSize;
    }
  }
  async readData(D) {
    debug$2(`Reading data of chunk[ID=${D.chunkID}, size=${D.chunkSize}]`);
    const O = this.tokenizer.position;
    switch (D.chunkID.trim()) {
      case "FVER":
        const U = await this.tokenizer.readToken(Token.UINT32_LE);
        debug$2(`DSDIFF version=${U}`);
        break;
      case "PROP":
        if (await this.tokenizer.readToken(FourCC_1.FourCcToken) !== "SND ")
          throw new Error("Unexpected PROP-chunk ID");
        await this.handleSoundPropertyChunks(D.chunkSize - BigInt(FourCC_1.FourCcToken.len));
        break;
      case "ID3":
        const B = await this.tokenizer.readToken(new Token.Uint8ArrayType(Number(D.chunkSize))), K = strtok3$1.fromBuffer(B);
        await new ID3v2Parser_1.ID3v2Parser().parse(this.metadata, K, this.options);
        break;
      default:
        debug$2(`Ignore chunk[ID=${D.chunkID}, size=${D.chunkSize}]`);
        break;
      case "DSD":
        this.metadata.setFormat("numberOfSamples", Number(D.chunkSize * BigInt(8) / BigInt(this.metadata.format.numberOfChannels))), this.metadata.setFormat("duration", this.metadata.format.numberOfSamples / this.metadata.format.sampleRate);
        break;
    }
    const F = D.chunkSize - BigInt(this.tokenizer.position - O);
    F > 0 && (debug$2(`After Parsing chunk, remaining ${F} bytes`), await this.tokenizer.ignore(Number(F)));
  }
  async handleSoundPropertyChunks(D) {
    for (debug$2(`Parsing sound-property-chunks, remainingSize=${D}`); D > 0; ) {
      const O = await this.tokenizer.readToken(DsdiffToken_1.ChunkHeader64);
      debug$2(`Sound-property-chunk[ID=${O.chunkID}, size=${O.chunkSize}]`);
      const F = this.tokenizer.position;
      switch (O.chunkID.trim()) {
        case "FS":
          const W = await this.tokenizer.readToken(Token.UINT32_BE);
          this.metadata.setFormat("sampleRate", W);
          break;
        case "CHNL":
          const B = await this.tokenizer.readToken(Token.UINT16_BE);
          this.metadata.setFormat("numberOfChannels", B), await this.handleChannelChunks(O.chunkSize - BigInt(Token.UINT16_BE.len));
          break;
        case "CMPR":
          const K = (await this.tokenizer.readToken(FourCC_1.FourCcToken)).trim(), X = await this.tokenizer.readToken(Token.UINT8), Y = await this.tokenizer.readToken(new Token.StringType(X, "ascii"));
          K === "DSD" && (this.metadata.setFormat("lossless", !0), this.metadata.setFormat("bitsPerSample", 1)), this.metadata.setFormat("codec", `${K} (${Y})`);
          break;
        case "ABSS":
          const Q = await this.tokenizer.readToken(Token.UINT16_BE), J = await this.tokenizer.readToken(Token.UINT8), ee = await this.tokenizer.readToken(Token.UINT8), ae = await this.tokenizer.readToken(Token.UINT32_BE);
          debug$2(`ABSS ${Q}:${J}:${ee}.${ae}`);
          break;
        case "LSCO":
          const re = await this.tokenizer.readToken(Token.UINT16_BE);
          debug$2(`LSCO lsConfig=${re}`);
          break;
        case "COMT":
        default:
          debug$2(`Unknown sound-property-chunk[ID=${O.chunkID}, size=${O.chunkSize}]`), await this.tokenizer.ignore(Number(O.chunkSize));
      }
      const U = O.chunkSize - BigInt(this.tokenizer.position - F);
      U > 0 && (debug$2(`After Parsing sound-property-chunk ${O.chunkSize}, remaining ${U} bytes`), await this.tokenizer.ignore(Number(U))), D -= BigInt(DsdiffToken_1.ChunkHeader64.len) + O.chunkSize, debug$2(`Parsing sound-property-chunks, remainingSize=${D}`);
    }
    if (this.metadata.format.lossless && this.metadata.format.sampleRate && this.metadata.format.numberOfChannels && this.metadata.format.bitsPerSample) {
      const O = this.metadata.format.sampleRate * this.metadata.format.numberOfChannels * this.metadata.format.bitsPerSample;
      this.metadata.setFormat("bitrate", O);
    }
  }
  async handleChannelChunks(D) {
    debug$2(`Parsing channel-chunks, remainingSize=${D}`);
    const O = [];
    for (; D >= FourCC_1.FourCcToken.len; ) {
      const F = await this.tokenizer.readToken(FourCC_1.FourCcToken);
      debug$2(`Channel[ID=${F}]`), O.push(F), D -= BigInt(FourCC_1.FourCcToken.len);
    }
    return debug$2(`Channels: ${O.join(", ")}`), O;
  }
}
DsdiffParser$1.DsdiffParser = DsdiffParser;
var MatroskaParser$1 = {}, MatroskaDtd = {};
Object.defineProperty(MatroskaDtd, "__esModule", { value: !0 });
MatroskaDtd.elements = void 0;
const types_1$1 = types$1;
MatroskaDtd.elements = {
  440786851: {
    name: "ebml",
    container: {
      17030: { name: "ebmlVersion", value: types_1$1.DataType.uint },
      17143: { name: "ebmlReadVersion", value: types_1$1.DataType.uint },
      17138: { name: "ebmlMaxIDWidth", value: types_1$1.DataType.uint },
      17139: { name: "ebmlMaxSizeWidth", value: types_1$1.DataType.uint },
      17026: { name: "docType", value: types_1$1.DataType.string },
      17031: { name: "docTypeVersion", value: types_1$1.DataType.uint },
      17029: { name: "docTypeReadVersion", value: types_1$1.DataType.uint }
      // 5.1.7
    }
  },
  // Matroska segments
  408125543: {
    name: "segment",
    container: {
      // Meta Seek Information
      290298740: {
        name: "seekHead",
        container: {
          19899: {
            name: "seek",
            container: {
              21419: { name: "seekId", value: types_1$1.DataType.binary },
              21420: { name: "seekPosition", value: types_1$1.DataType.uint }
            }
          }
        }
      },
      // Segment Information
      357149030: {
        name: "info",
        container: {
          29604: { name: "uid", value: types_1$1.DataType.uid },
          29572: { name: "filename", value: types_1$1.DataType.string },
          3979555: { name: "prevUID", value: types_1$1.DataType.uid },
          3965867: { name: "prevFilename", value: types_1$1.DataType.string },
          4110627: { name: "nextUID", value: types_1$1.DataType.uid },
          4096955: { name: "nextFilename", value: types_1$1.DataType.string },
          2807729: { name: "timecodeScale", value: types_1$1.DataType.uint },
          17545: { name: "duration", value: types_1$1.DataType.float },
          17505: { name: "dateUTC", value: types_1$1.DataType.uint },
          31657: { name: "title", value: types_1$1.DataType.string },
          19840: { name: "muxingApp", value: types_1$1.DataType.string },
          22337: { name: "writingApp", value: types_1$1.DataType.string }
        }
      },
      // Cluster
      524531317: {
        name: "cluster",
        multiple: !0,
        container: {
          231: { name: "timecode", value: types_1$1.DataType.uid },
          163: { name: "unknown", value: types_1$1.DataType.binary },
          167: { name: "position", value: types_1$1.DataType.uid },
          171: { name: "prevSize", value: types_1$1.DataType.uid }
        }
      },
      // Track
      374648427: {
        name: "tracks",
        container: {
          174: {
            name: "entries",
            multiple: !0,
            container: {
              215: { name: "trackNumber", value: types_1$1.DataType.uint },
              29637: { name: "uid", value: types_1$1.DataType.uid },
              131: { name: "trackType", value: types_1$1.DataType.uint },
              185: { name: "flagEnabled", value: types_1$1.DataType.bool },
              136: { name: "flagDefault", value: types_1$1.DataType.bool },
              21930: { name: "flagForced", value: types_1$1.DataType.bool },
              156: { name: "flagLacing", value: types_1$1.DataType.bool },
              28135: { name: "minCache", value: types_1$1.DataType.uint },
              28136: { name: "maxCache", value: types_1$1.DataType.uint },
              2352003: { name: "defaultDuration", value: types_1$1.DataType.uint },
              2306383: { name: "timecodeScale", value: types_1$1.DataType.float },
              21358: { name: "name", value: types_1$1.DataType.string },
              2274716: { name: "language", value: types_1$1.DataType.string },
              134: { name: "codecID", value: types_1$1.DataType.string },
              25506: { name: "codecPrivate", value: types_1$1.DataType.binary },
              2459272: { name: "codecName", value: types_1$1.DataType.string },
              3839639: { name: "codecSettings", value: types_1$1.DataType.string },
              3883072: { name: "codecInfoUrl", value: types_1$1.DataType.string },
              2536e3: { name: "codecDownloadUrl", value: types_1$1.DataType.string },
              170: { name: "codecDecodeAll", value: types_1$1.DataType.bool },
              28587: { name: "trackOverlay", value: types_1$1.DataType.uint },
              // Video
              224: {
                name: "video",
                container: {
                  154: { name: "flagInterlaced", value: types_1$1.DataType.bool },
                  21432: { name: "stereoMode", value: types_1$1.DataType.uint },
                  176: { name: "pixelWidth", value: types_1$1.DataType.uint },
                  186: { name: "pixelHeight", value: types_1$1.DataType.uint },
                  21680: { name: "displayWidth", value: types_1$1.DataType.uint },
                  21690: { name: "displayHeight", value: types_1$1.DataType.uint },
                  21683: { name: "aspectRatioType", value: types_1$1.DataType.uint },
                  3061028: { name: "colourSpace", value: types_1$1.DataType.uint },
                  3126563: { name: "gammaValue", value: types_1$1.DataType.float }
                }
              },
              // Audio
              225: {
                name: "audio",
                container: {
                  181: { name: "samplingFrequency", value: types_1$1.DataType.float },
                  30901: { name: "outputSamplingFrequency", value: types_1$1.DataType.float },
                  159: { name: "channels", value: types_1$1.DataType.uint },
                  148: { name: "channels", value: types_1$1.DataType.uint },
                  32123: { name: "channelPositions", value: types_1$1.DataType.binary },
                  25188: { name: "bitDepth", value: types_1$1.DataType.uint }
                }
              },
              // Content Encoding
              28032: {
                name: "contentEncodings",
                container: {
                  25152: {
                    name: "contentEncoding",
                    container: {
                      20529: { name: "order", value: types_1$1.DataType.uint },
                      20530: { name: "scope", value: types_1$1.DataType.bool },
                      20531: { name: "type", value: types_1$1.DataType.uint },
                      20532: {
                        name: "contentEncoding",
                        container: {
                          16980: { name: "contentCompAlgo", value: types_1$1.DataType.uint },
                          16981: { name: "contentCompSettings", value: types_1$1.DataType.binary }
                        }
                      },
                      20533: {
                        name: "contentEncoding",
                        container: {
                          18401: { name: "contentEncAlgo", value: types_1$1.DataType.uint },
                          18402: { name: "contentEncKeyID", value: types_1$1.DataType.binary },
                          18403: { name: "contentSignature ", value: types_1$1.DataType.binary },
                          18404: { name: "ContentSigKeyID  ", value: types_1$1.DataType.binary },
                          18405: { name: "contentSigAlgo ", value: types_1$1.DataType.uint },
                          18406: { name: "contentSigHashAlgo ", value: types_1$1.DataType.uint }
                        }
                      },
                      25188: { name: "bitDepth", value: types_1$1.DataType.uint }
                    }
                  }
                }
              }
            }
          }
        }
      },
      // Cueing Data
      475249515: {
        name: "cues",
        container: {
          187: {
            name: "cuePoint",
            container: {
              179: { name: "cueTime", value: types_1$1.DataType.uid },
              183: {
                name: "positions",
                container: {
                  247: { name: "track", value: types_1$1.DataType.uint },
                  241: { name: "clusterPosition", value: types_1$1.DataType.uint },
                  21368: { name: "blockNumber", value: types_1$1.DataType.uint },
                  234: { name: "codecState", value: types_1$1.DataType.uint },
                  219: {
                    name: "reference",
                    container: {
                      150: { name: "time", value: types_1$1.DataType.uint },
                      151: { name: "cluster", value: types_1$1.DataType.uint },
                      21343: { name: "number", value: types_1$1.DataType.uint },
                      235: { name: "codecState", value: types_1$1.DataType.uint }
                    }
                  },
                  240: { name: "relativePosition", value: types_1$1.DataType.uint }
                  // extended
                }
              }
            }
          }
        }
      },
      // Attachment
      423732329: {
        name: "attachments",
        container: {
          24999: {
            name: "attachedFiles",
            multiple: !0,
            container: {
              18046: { name: "description", value: types_1$1.DataType.string },
              18030: { name: "name", value: types_1$1.DataType.string },
              18016: { name: "mimeType", value: types_1$1.DataType.string },
              18012: { name: "data", value: types_1$1.DataType.binary },
              18094: { name: "uid", value: types_1$1.DataType.uid }
            }
          }
        }
      },
      // Chapters
      272869232: {
        name: "chapters",
        container: {
          17849: {
            name: "editionEntry",
            container: {
              182: {
                name: "chapterAtom",
                container: {
                  29636: { name: "uid", value: types_1$1.DataType.uid },
                  145: { name: "timeStart", value: types_1$1.DataType.uint },
                  146: { name: "timeEnd", value: types_1$1.DataType.uid },
                  152: { name: "hidden", value: types_1$1.DataType.bool },
                  17816: { name: "enabled", value: types_1$1.DataType.uid },
                  143: {
                    name: "track",
                    container: {
                      137: { name: "trackNumber", value: types_1$1.DataType.uid },
                      128: {
                        name: "display",
                        container: {
                          133: { name: "string", value: types_1$1.DataType.string },
                          17276: { name: "language ", value: types_1$1.DataType.string },
                          17278: { name: "country ", value: types_1$1.DataType.string }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      },
      // Tagging
      307544935: {
        name: "tags",
        container: {
          29555: {
            name: "tag",
            multiple: !0,
            container: {
              25536: {
                name: "target",
                container: {
                  25541: { name: "tagTrackUID", value: types_1$1.DataType.uid },
                  25540: { name: "tagChapterUID", value: types_1$1.DataType.uint },
                  25542: { name: "tagAttachmentUID", value: types_1$1.DataType.uid },
                  25546: { name: "targetType", value: types_1$1.DataType.string },
                  26826: { name: "targetTypeValue", value: types_1$1.DataType.uint },
                  25545: { name: "tagEditionUID", value: types_1$1.DataType.uid }
                  // extended
                }
              },
              26568: {
                name: "simpleTags",
                multiple: !0,
                container: {
                  17827: { name: "name", value: types_1$1.DataType.string },
                  17543: { name: "string", value: types_1$1.DataType.string },
                  17541: { name: "binary", value: types_1$1.DataType.binary },
                  17530: { name: "language", value: types_1$1.DataType.string },
                  17531: { name: "languageIETF", value: types_1$1.DataType.string },
                  17540: { name: "default", value: types_1$1.DataType.bool }
                  // extended
                }
              }
            }
          }
        }
      }
    }
  }
};
Object.defineProperty(MatroskaParser$1, "__esModule", { value: !0 });
MatroskaParser$1.MatroskaParser = void 0;
const token_types_1 = lib$1, debug_1$1 = browserExports, BasicParser_1 = BasicParser$1, types_1 = types$1, matroskaDtd = MatroskaDtd, debug$1 = (0, debug_1$1.default)("music-metadata:parser:matroska");
class MatroskaParser extends BasicParser_1.BasicParser {
  constructor() {
    super(), this.padding = 0, this.parserMap = /* @__PURE__ */ new Map(), this.ebmlMaxIDLength = 4, this.ebmlMaxSizeLength = 8, this.parserMap.set(types_1.DataType.uint, (D) => this.readUint(D)), this.parserMap.set(types_1.DataType.string, (D) => this.readString(D)), this.parserMap.set(types_1.DataType.binary, (D) => this.readBuffer(D)), this.parserMap.set(types_1.DataType.uid, async (D) => await this.readUint(D) === 1), this.parserMap.set(types_1.DataType.bool, (D) => this.readFlag(D)), this.parserMap.set(types_1.DataType.float, (D) => this.readFloat(D));
  }
  /**
   * Initialize parser with output (metadata), input (tokenizer) & parsing options (options).
   * @param {INativeMetadataCollector} metadata Output
   * @param {ITokenizer} tokenizer Input
   * @param {IOptions} options Parsing options
   */
  init(D, O, F) {
    return super.init(D, O, F), this;
  }
  async parse() {
    const D = await this.parseContainer(matroskaDtd.elements, this.tokenizer.fileInfo.size, []);
    if (this.metadata.setFormat("container", `EBML/${D.ebml.docType}`), D.segment) {
      const O = D.segment.info;
      if (O) {
        const U = O.timecodeScale ? O.timecodeScale : 1e6;
        if (typeof O.duration == "number") {
          const W = O.duration * U / 1e9;
          this.addTag("segment:title", O.title), this.metadata.setFormat("duration", W);
        }
      }
      const F = D.segment.tracks;
      if (F && F.entries) {
        F.entries.forEach((W) => {
          const B = {
            codecName: W.codecID.replace("A_", "").replace("V_", ""),
            codecSettings: W.codecSettings,
            flagDefault: W.flagDefault,
            flagLacing: W.flagLacing,
            flagEnabled: W.flagEnabled,
            language: W.language,
            name: W.name,
            type: W.trackType,
            audio: W.audio,
            video: W.video
          };
          this.metadata.addStreamInfo(B);
        });
        const U = F.entries.filter((W) => W.trackType === types_1.TrackType.audio.valueOf()).reduce((W, B) => !W || !W.flagDefault && B.flagDefault || B.trackNumber && B.trackNumber < W.trackNumber ? B : W, null);
        U && (this.metadata.setFormat("codec", U.codecID.replace("A_", "")), this.metadata.setFormat("sampleRate", U.audio.samplingFrequency), this.metadata.setFormat("numberOfChannels", U.audio.channels)), D.segment.tags && D.segment.tags.tag.forEach((W) => {
          const B = W.target, K = B != null && B.targetTypeValue ? types_1.TargetType[B.targetTypeValue] : B != null && B.targetType ? B.targetType : "track";
          W.simpleTags.forEach((X) => {
            const Y = X.string ? X.string : X.binary;
            this.addTag(`${K}:${X.name}`, Y);
          });
        }), D.segment.attachments && D.segment.attachments.attachedFiles.filter((W) => W.mimeType.startsWith("image/")).map((W) => ({
          data: W.data,
          format: W.mimeType,
          description: W.description,
          name: W.name
        })).forEach((W) => {
          this.addTag("picture", W);
        });
      }
    }
  }
  async parseContainer(D, O, F) {
    const U = {};
    for (; this.tokenizer.position < O; ) {
      let W;
      try {
        W = await this.readElement();
      } catch (K) {
        if (K.message === "End-Of-Stream")
          break;
        throw K;
      }
      const B = D[W.id];
      if (B)
        if (debug$1(`Element: name=${B.name}, container=${!!B.container}`), B.container) {
          const K = await this.parseContainer(B.container, W.len >= 0 ? this.tokenizer.position + W.len : -1, F.concat([B.name]));
          B.multiple ? (U[B.name] || (U[B.name] = []), U[B.name].push(K)) : U[B.name] = K;
        } else
          U[B.name] = await this.parserMap.get(B.value)(W);
      else
        switch (W.id) {
          case 236:
            this.padding += W.len, await this.tokenizer.ignore(W.len);
            break;
          default:
            debug$1(`parseEbml: path=${F.join("/")}, unknown element: id=${W.id.toString(16)}`), this.padding += W.len, await this.tokenizer.ignore(W.len);
        }
    }
    return U;
  }
  async readVintData(D) {
    const O = await this.tokenizer.peekNumber(token_types_1.UINT8);
    let F = 128, U = 1;
    for (; !(O & F); ) {
      if (U > D)
        throw new Error("VINT value exceeding maximum size");
      ++U, F >>= 1;
    }
    const W = Buffer.alloc(U);
    return await this.tokenizer.readBuffer(W), W;
  }
  async readElement() {
    const D = await this.readVintData(this.ebmlMaxIDLength), O = await this.readVintData(this.ebmlMaxSizeLength);
    O[0] ^= 128 >> O.length - 1;
    const F = Math.min(6, O.length);
    return {
      id: D.readUIntBE(0, D.length),
      len: O.readUIntBE(O.length - F, F)
    };
  }
  isMaxValue(D) {
    if (D.length === this.ebmlMaxSizeLength) {
      for (let O = 1; O < this.ebmlMaxSizeLength; ++O)
        if (D[O] !== 255)
          return !1;
      return !0;
    }
    return !1;
  }
  async readFloat(D) {
    switch (D.len) {
      case 0:
        return 0;
      case 4:
        return this.tokenizer.readNumber(token_types_1.Float32_BE);
      case 8:
        return this.tokenizer.readNumber(token_types_1.Float64_BE);
      case 10:
        return this.tokenizer.readNumber(token_types_1.Float64_BE);
      default:
        throw new Error(`Invalid IEEE-754 float length: ${D.len}`);
    }
  }
  async readFlag(D) {
    return await this.readUint(D) === 1;
  }
  async readUint(D) {
    const O = await this.readBuffer(D), F = Math.min(6, D.len);
    return O.readUIntBE(D.len - F, F);
  }
  async readString(D) {
    return (await this.tokenizer.readToken(new token_types_1.StringType(D.len, "utf-8"))).replace(/\00.*$/g, "");
  }
  async readBuffer(D) {
    const O = Buffer.alloc(D.len);
    return await this.tokenizer.readBuffer(O), O;
  }
  addTag(D, O) {
    this.metadata.addTag("matroska", D, O);
  }
}
MatroskaParser$1.MatroskaParser = MatroskaParser;
Object.defineProperty(ParserFactory$1, "__esModule", { value: !0 });
ParserFactory$1.ParserFactory = ParserFactory$1.parseHttpContentType = void 0;
const FileType = core, ContentType = contentType, MimeType = mediaTyper, debug_1 = browserExports, MetadataCollector_1 = MetadataCollector$1, AiffParser_1 = AiffParser, APEv2Parser_1$1 = APEv2Parser$1, AsfParser_1 = AsfParser$1, FlacParser_1 = FlacParser$1, MP4Parser_1 = MP4Parser$1, MpegParser_1 = MpegParser$1, musepack_1 = musepack, OggParser_1 = OggParser$1, WaveParser_1 = WaveParser$1, WavPackParser_1 = WavPackParser$1, DsfParser_1 = DsfParser$1, DsdiffParser_1 = DsdiffParser$1, MatroskaParser_1 = MatroskaParser$1, debug = (0, debug_1.default)("music-metadata:parser:factory");
function parseHttpContentType(z) {
  const D = ContentType.parse(z), O = MimeType.parse(D.type);
  return {
    type: O.type,
    subtype: O.subtype,
    suffix: O.suffix,
    parameters: D.parameters
  };
}
ParserFactory$1.parseHttpContentType = parseHttpContentType;
async function parse(z, D, O = {}) {
  const F = await ParserFactory.loadParser(D), U = new MetadataCollector_1.MetadataCollector(O);
  return await F.init(U, z, O).parse(), U.toCommonMetadata();
}
class ParserFactory {
  /**
   * Parse metadata from tokenizer
   * @param tokenizer - Tokenizer
   * @param opts - Options
   * @returns Native metadata
   */
  static async parseOnContentType(D, O) {
    const { mimeType: F, path: U, url: W } = await D.fileInfo, B = ParserFactory.getParserIdForMimeType(F) || ParserFactory.getParserIdForExtension(U) || ParserFactory.getParserIdForExtension(W);
    return B || debug("No parser found for MIME-type / extension: " + F), this.parse(D, B, O);
  }
  static async parse(D, O, F) {
    if (!O) {
      debug("Guess parser on content...");
      const U = Buffer.alloc(4100);
      if (await D.peekBuffer(U, { mayBeLess: !0 }), D.fileInfo.path && (O = this.getParserIdForExtension(D.fileInfo.path)), !O) {
        const W = await FileType.fromBuffer(U);
        if (!W)
          throw new Error("Failed to determine audio format");
        if (debug(`Guessed file type is mime=${W.mime}, extension=${W.ext}`), O = ParserFactory.getParserIdForMimeType(W.mime), !O)
          throw new Error("Guessed MIME-type not supported: " + W.mime);
      }
    }
    return parse(D, O, F);
  }
  /**
   * @param filePath - Path, filename or extension to audio file
   * @return Parser sub-module name
   */
  static getParserIdForExtension(D) {
    if (!D)
      return;
    switch (this.getExtension(D).toLocaleLowerCase() || D) {
      case ".mp2":
      case ".mp3":
      case ".m2a":
      case ".aac":
        return "mpeg";
      case ".ape":
        return "apev2";
      case ".mp4":
      case ".m4a":
      case ".m4b":
      case ".m4pa":
      case ".m4v":
      case ".m4r":
      case ".3gp":
        return "mp4";
      case ".wma":
      case ".wmv":
      case ".asf":
        return "asf";
      case ".flac":
        return "flac";
      case ".ogg":
      case ".ogv":
      case ".oga":
      case ".ogm":
      case ".ogx":
      case ".opus":
      case ".spx":
        return "ogg";
      case ".aif":
      case ".aiff":
      case ".aifc":
        return "aiff";
      case ".wav":
      case ".bwf":
        return "riff";
      case ".wv":
      case ".wvp":
        return "wavpack";
      case ".mpc":
        return "musepack";
      case ".dsf":
        return "dsf";
      case ".dff":
        return "dsdiff";
      case ".mka":
      case ".mkv":
      case ".mk3d":
      case ".mks":
      case ".webm":
        return "matroska";
    }
  }
  static async loadParser(D) {
    switch (D) {
      case "aiff":
        return new AiffParser_1.AIFFParser();
      case "adts":
      case "mpeg":
        return new MpegParser_1.MpegParser();
      case "apev2":
        return new APEv2Parser_1$1.APEv2Parser();
      case "asf":
        return new AsfParser_1.AsfParser();
      case "dsf":
        return new DsfParser_1.DsfParser();
      case "dsdiff":
        return new DsdiffParser_1.DsdiffParser();
      case "flac":
        return new FlacParser_1.FlacParser();
      case "mp4":
        return new MP4Parser_1.MP4Parser();
      case "musepack":
        return new musepack_1.default();
      case "ogg":
        return new OggParser_1.OggParser();
      case "riff":
        return new WaveParser_1.WaveParser();
      case "wavpack":
        return new WavPackParser_1.WavPackParser();
      case "matroska":
        return new MatroskaParser_1.MatroskaParser();
      default:
        throw new Error(`Unknown parser type: ${D}`);
    }
  }
  static getExtension(D) {
    const O = D.lastIndexOf(".");
    return O === -1 ? "" : D.slice(O);
  }
  /**
   * @param httpContentType - HTTP Content-Type, extension, path or filename
   * @returns Parser sub-module name
   */
  static getParserIdForMimeType(D) {
    let O;
    try {
      O = parseHttpContentType(D);
    } catch {
      debug(`Invalid HTTP Content-Type header value: ${D}`);
      return;
    }
    const F = O.subtype.indexOf("x-") === 0 ? O.subtype.substring(2) : O.subtype;
    switch (O.type) {
      case "audio":
        switch (F) {
          case "mp3":
          case "mpeg":
            return "mpeg";
          case "aac":
          case "aacp":
            return "adts";
          case "flac":
            return "flac";
          case "ape":
          case "monkeys-audio":
            return "apev2";
          case "mp4":
          case "m4a":
            return "mp4";
          case "ogg":
          case "opus":
          case "speex":
            return "ogg";
          case "ms-wma":
          case "ms-wmv":
          case "ms-asf":
            return "asf";
          case "aiff":
          case "aif":
          case "aifc":
            return "aiff";
          case "vnd.wave":
          case "wav":
          case "wave":
            return "riff";
          case "wavpack":
            return "wavpack";
          case "musepack":
            return "musepack";
          case "matroska":
          case "webm":
            return "matroska";
          case "dsf":
            return "dsf";
        }
        break;
      case "video":
        switch (F) {
          case "ms-asf":
          case "ms-wmv":
            return "asf";
          case "m4v":
          case "mp4":
            return "mp4";
          case "ogg":
            return "ogg";
          case "matroska":
          case "webm":
            return "matroska";
        }
        break;
      case "application":
        switch (F) {
          case "vnd.ms-asf":
            return "asf";
          case "ogg":
            return "ogg";
        }
        break;
    }
  }
}
ParserFactory$1.ParserFactory = ParserFactory;
var RandomUint8ArrayReader$1 = {};
Object.defineProperty(RandomUint8ArrayReader$1, "__esModule", { value: !0 });
RandomUint8ArrayReader$1.RandomUint8ArrayReader = void 0;
class RandomUint8ArrayReader {
  constructor(D) {
    this.uint8Array = D, this.fileSize = D.length;
  }
  /**
   * Read from a given position of an abstracted file or buffer.
   * @param uint8Array - Uint8Array that the data will be written to.
   * @param offset - Offset in the buffer to start writing at.
   * @param length - Integer specifying the number of bytes to read.
   * @param position - Specifies where to begin reading from in the file.
   * @return Promise providing bytes read
   */
  async randomRead(D, O, F, U) {
    return D.set(this.uint8Array.subarray(U, U + F), O), F;
  }
}
RandomUint8ArrayReader$1.RandomUint8ArrayReader = RandomUint8ArrayReader;
var Lyrics3 = {};
(function(z) {
  Object.defineProperty(z, "__esModule", { value: !0 }), z.getLyricsHeaderLength = z.endTag2 = void 0, z.endTag2 = "LYRICS200";
  async function D(O) {
    if (O.fileSize >= 143) {
      const F = Buffer.alloc(15);
      await O.randomRead(F, 0, F.length, O.fileSize - 143);
      const U = F.toString("binary");
      if (U.substr(6) === z.endTag2)
        return parseInt(U.substr(0, 6), 10) + 15;
    }
    return 0;
  }
  z.getLyricsHeaderLength = D;
})(Lyrics3);
Object.defineProperty(core$2, "__esModule", { value: !0 });
core$2.scanAppendingHeaders = core$2.selectCover = core$2.ratingToStars = core$2.orderTags = core$2.parseFromTokenizer = core$2.parseBuffer = core$2.parseStream = void 0;
const strtok3 = core$1, ParserFactory_1 = ParserFactory$1, RandomUint8ArrayReader_1 = RandomUint8ArrayReader$1, APEv2Parser_1 = APEv2Parser$1, ID3v1Parser_1 = ID3v1Parser, Lyrics3_1 = Lyrics3;
function parseStream(z, D, O = {}) {
  return parseFromTokenizer(strtok3.fromStream(z, typeof D == "string" ? { mimeType: D } : D), O);
}
core$2.parseStream = parseStream;
async function parseBuffer(z, D, O = {}) {
  const F = new RandomUint8ArrayReader_1.RandomUint8ArrayReader(z);
  await scanAppendingHeaders(F, O);
  const U = strtok3.fromBuffer(z, typeof D == "string" ? { mimeType: D } : D);
  return parseFromTokenizer(U, O);
}
core$2.parseBuffer = parseBuffer;
function parseFromTokenizer(z, D) {
  return ParserFactory_1.ParserFactory.parseOnContentType(z, D);
}
core$2.parseFromTokenizer = parseFromTokenizer;
function orderTags(z) {
  const D = {};
  for (const O of z)
    (D[O.id] = D[O.id] || []).push(O.value);
  return D;
}
core$2.orderTags = orderTags;
function ratingToStars(z) {
  return z === void 0 ? 0 : 1 + Math.round(z * 4);
}
core$2.ratingToStars = ratingToStars;
function selectCover(z) {
  return z ? z.reduce((D, O) => O.name && O.name.toLowerCase() in ["front", "cover", "cover (front)"] ? O : D) : null;
}
core$2.selectCover = selectCover;
async function scanAppendingHeaders(z, D = {}) {
  let O = z.fileSize;
  if (await (0, ID3v1Parser_1.hasID3v1Header)(z)) {
    O -= 128;
    const F = await (0, Lyrics3_1.getLyricsHeaderLength)(z);
    O -= F;
  }
  D.apeHeader = await APEv2Parser_1.APEv2Parser.findApeFooterOffset(z, O);
}
core$2.scanAppendingHeaders = scanAppendingHeaders;
var lib = {}, readableBrowser = { exports: {} }, events = { exports: {} }, R = typeof Reflect == "object" ? Reflect : null, ReflectApply = R && typeof R.apply == "function" ? R.apply : function z(D, O, F) {
  return Function.prototype.apply.call(D, O, F);
}, ReflectOwnKeys;
R && typeof R.ownKeys == "function" ? ReflectOwnKeys = R.ownKeys : Object.getOwnPropertySymbols ? ReflectOwnKeys = function(D) {
  return Object.getOwnPropertyNames(D).concat(Object.getOwnPropertySymbols(D));
} : ReflectOwnKeys = function(D) {
  return Object.getOwnPropertyNames(D);
};
function ProcessEmitWarning(z) {
  console && console.warn && console.warn(z);
}
var NumberIsNaN = Number.isNaN || function z(D) {
  return D !== D;
};
function EventEmitter() {
  EventEmitter.init.call(this);
}
events.exports = EventEmitter;
events.exports.once = once$2;
EventEmitter.EventEmitter = EventEmitter;
EventEmitter.prototype._events = void 0;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = void 0;
var defaultMaxListeners = 10;
function checkListener(z) {
  if (typeof z != "function")
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof z);
}
Object.defineProperty(EventEmitter, "defaultMaxListeners", {
  enumerable: !0,
  get: function() {
    return defaultMaxListeners;
  },
  set: function(z) {
    if (typeof z != "number" || z < 0 || NumberIsNaN(z))
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + z + ".");
    defaultMaxListeners = z;
  }
});
EventEmitter.init = function() {
  (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
};
EventEmitter.prototype.setMaxListeners = function z(D) {
  if (typeof D != "number" || D < 0 || NumberIsNaN(D))
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + D + ".");
  return this._maxListeners = D, this;
};
function _getMaxListeners(z) {
  return z._maxListeners === void 0 ? EventEmitter.defaultMaxListeners : z._maxListeners;
}
EventEmitter.prototype.getMaxListeners = function z() {
  return _getMaxListeners(this);
};
EventEmitter.prototype.emit = function z(D) {
  for (var O = [], F = 1; F < arguments.length; F++)
    O.push(arguments[F]);
  var U = D === "error", W = this._events;
  if (W !== void 0)
    U = U && W.error === void 0;
  else if (!U)
    return !1;
  if (U) {
    var B;
    if (O.length > 0 && (B = O[0]), B instanceof Error)
      throw B;
    var K = new Error("Unhandled error." + (B ? " (" + B.message + ")" : ""));
    throw K.context = B, K;
  }
  var X = W[D];
  if (X === void 0)
    return !1;
  if (typeof X == "function")
    ReflectApply(X, this, O);
  else
    for (var Y = X.length, Q = arrayClone(X, Y), F = 0; F < Y; ++F)
      ReflectApply(Q[F], this, O);
  return !0;
};
function _addListener(z, D, O, F) {
  var U, W, B;
  if (checkListener(O), W = z._events, W === void 0 ? (W = z._events = /* @__PURE__ */ Object.create(null), z._eventsCount = 0) : (W.newListener !== void 0 && (z.emit(
    "newListener",
    D,
    O.listener ? O.listener : O
  ), W = z._events), B = W[D]), B === void 0)
    B = W[D] = O, ++z._eventsCount;
  else if (typeof B == "function" ? B = W[D] = F ? [O, B] : [B, O] : F ? B.unshift(O) : B.push(O), U = _getMaxListeners(z), U > 0 && B.length > U && !B.warned) {
    B.warned = !0;
    var K = new Error("Possible EventEmitter memory leak detected. " + B.length + " " + String(D) + " listeners added. Use emitter.setMaxListeners() to increase limit");
    K.name = "MaxListenersExceededWarning", K.emitter = z, K.type = D, K.count = B.length, ProcessEmitWarning(K);
  }
  return z;
}
EventEmitter.prototype.addListener = function z(D, O) {
  return _addListener(this, D, O, !1);
};
EventEmitter.prototype.on = EventEmitter.prototype.addListener;
EventEmitter.prototype.prependListener = function z(D, O) {
  return _addListener(this, D, O, !0);
};
function onceWrapper() {
  if (!this.fired)
    return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
}
function _onceWrap(z, D, O) {
  var F = { fired: !1, wrapFn: void 0, target: z, type: D, listener: O }, U = onceWrapper.bind(F);
  return U.listener = O, F.wrapFn = U, U;
}
EventEmitter.prototype.once = function z(D, O) {
  return checkListener(O), this.on(D, _onceWrap(this, D, O)), this;
};
EventEmitter.prototype.prependOnceListener = function z(D, O) {
  return checkListener(O), this.prependListener(D, _onceWrap(this, D, O)), this;
};
EventEmitter.prototype.removeListener = function z(D, O) {
  var F, U, W, B, K;
  if (checkListener(O), U = this._events, U === void 0)
    return this;
  if (F = U[D], F === void 0)
    return this;
  if (F === O || F.listener === O)
    --this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : (delete U[D], U.removeListener && this.emit("removeListener", D, F.listener || O));
  else if (typeof F != "function") {
    for (W = -1, B = F.length - 1; B >= 0; B--)
      if (F[B] === O || F[B].listener === O) {
        K = F[B].listener, W = B;
        break;
      }
    if (W < 0)
      return this;
    W === 0 ? F.shift() : spliceOne(F, W), F.length === 1 && (U[D] = F[0]), U.removeListener !== void 0 && this.emit("removeListener", D, K || O);
  }
  return this;
};
EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
EventEmitter.prototype.removeAllListeners = function z(D) {
  var O, F, U;
  if (F = this._events, F === void 0)
    return this;
  if (F.removeListener === void 0)
    return arguments.length === 0 ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : F[D] !== void 0 && (--this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : delete F[D]), this;
  if (arguments.length === 0) {
    var W = Object.keys(F), B;
    for (U = 0; U < W.length; ++U)
      B = W[U], B !== "removeListener" && this.removeAllListeners(B);
    return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
  }
  if (O = F[D], typeof O == "function")
    this.removeListener(D, O);
  else if (O !== void 0)
    for (U = O.length - 1; U >= 0; U--)
      this.removeListener(D, O[U]);
  return this;
};
function _listeners(z, D, O) {
  var F = z._events;
  if (F === void 0)
    return [];
  var U = F[D];
  return U === void 0 ? [] : typeof U == "function" ? O ? [U.listener || U] : [U] : O ? unwrapListeners(U) : arrayClone(U, U.length);
}
EventEmitter.prototype.listeners = function z(D) {
  return _listeners(this, D, !0);
};
EventEmitter.prototype.rawListeners = function z(D) {
  return _listeners(this, D, !1);
};
EventEmitter.listenerCount = function(z, D) {
  return typeof z.listenerCount == "function" ? z.listenerCount(D) : listenerCount.call(z, D);
};
EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(z) {
  var D = this._events;
  if (D !== void 0) {
    var O = D[z];
    if (typeof O == "function")
      return 1;
    if (O !== void 0)
      return O.length;
  }
  return 0;
}
EventEmitter.prototype.eventNames = function z() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};
function arrayClone(z, D) {
  for (var O = new Array(D), F = 0; F < D; ++F)
    O[F] = z[F];
  return O;
}
function spliceOne(z, D) {
  for (; D + 1 < z.length; D++)
    z[D] = z[D + 1];
  z.pop();
}
function unwrapListeners(z) {
  for (var D = new Array(z.length), O = 0; O < D.length; ++O)
    D[O] = z[O].listener || z[O];
  return D;
}
function once$2(z, D) {
  return new Promise(function(O, F) {
    function U(B) {
      z.removeListener(D, W), F(B);
    }
    function W() {
      typeof z.removeListener == "function" && z.removeListener("error", U), O([].slice.call(arguments));
    }
    eventTargetAgnosticAddListener(z, D, W, { once: !0 }), D !== "error" && addErrorHandlerIfEventEmitter(z, U, { once: !0 });
  });
}
function addErrorHandlerIfEventEmitter(z, D, O) {
  typeof z.on == "function" && eventTargetAgnosticAddListener(z, "error", D, O);
}
function eventTargetAgnosticAddListener(z, D, O, F) {
  if (typeof z.on == "function")
    F.once ? z.once(D, O) : z.on(D, O);
  else if (typeof z.addEventListener == "function")
    z.addEventListener(D, function U(W) {
      F.once && z.removeEventListener(D, U), O(W);
    });
  else
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof z);
}
var eventsExports = events.exports, streamBrowser = eventsExports.EventEmitter;
const require$$2 = /* @__PURE__ */ getAugmentedNamespace(dist);
var util = {}, types = {}, shams$1 = function z() {
  if (typeof Symbol != "function" || typeof Object.getOwnPropertySymbols != "function")
    return !1;
  if (typeof Symbol.iterator == "symbol")
    return !0;
  var D = {}, O = Symbol("test"), F = Object(O);
  if (typeof O == "string" || Object.prototype.toString.call(O) !== "[object Symbol]" || Object.prototype.toString.call(F) !== "[object Symbol]")
    return !1;
  var U = 42;
  D[O] = U;
  for (O in D)
    return !1;
  if (typeof Object.keys == "function" && Object.keys(D).length !== 0 || typeof Object.getOwnPropertyNames == "function" && Object.getOwnPropertyNames(D).length !== 0)
    return !1;
  var W = Object.getOwnPropertySymbols(D);
  if (W.length !== 1 || W[0] !== O || !Object.prototype.propertyIsEnumerable.call(D, O))
    return !1;
  if (typeof Object.getOwnPropertyDescriptor == "function") {
    var B = Object.getOwnPropertyDescriptor(D, O);
    if (B.value !== U || B.enumerable !== !0)
      return !1;
  }
  return !0;
}, hasSymbols$2 = shams$1, shams = function z() {
  return hasSymbols$2() && !!Symbol.toStringTag;
}, esErrors = Error, _eval = EvalError, range = RangeError, ref = ReferenceError, syntax = SyntaxError, type = TypeError, uri = URIError, origSymbol = typeof Symbol < "u" && Symbol, hasSymbolSham = shams$1, hasSymbols$1 = function z() {
  return typeof origSymbol != "function" || typeof Symbol != "function" || typeof origSymbol("foo") != "symbol" || typeof Symbol("bar") != "symbol" ? !1 : hasSymbolSham();
}, test = {
  __proto__: null,
  foo: {}
}, $Object = Object, hasProto$1 = function z() {
  return { __proto__: test }.foo === test.foo && !(test instanceof $Object);
}, ERROR_MESSAGE = "Function.prototype.bind called on incompatible ", toStr$3 = Object.prototype.toString, max$1 = Math.max, funcType = "[object Function]", concatty = function z(D, O) {
  for (var F = [], U = 0; U < D.length; U += 1)
    F[U] = D[U];
  for (var W = 0; W < O.length; W += 1)
    F[W + D.length] = O[W];
  return F;
}, slicy = function z(D, O) {
  for (var F = [], U = O, W = 0; U < D.length; U += 1, W += 1)
    F[W] = D[U];
  return F;
}, joiny = function(z, D) {
  for (var O = "", F = 0; F < z.length; F += 1)
    O += z[F], F + 1 < z.length && (O += D);
  return O;
}, implementation$1 = function z(D) {
  var O = this;
  if (typeof O != "function" || toStr$3.apply(O) !== funcType)
    throw new TypeError(ERROR_MESSAGE + O);
  for (var F = slicy(arguments, 1), U, W = function() {
    if (this instanceof U) {
      var Q = O.apply(
        this,
        concatty(F, arguments)
      );
      return Object(Q) === Q ? Q : this;
    }
    return O.apply(
      D,
      concatty(F, arguments)
    );
  }, B = max$1(0, O.length - F.length), K = [], X = 0; X < B; X++)
    K[X] = "$" + X;
  if (U = Function("binder", "return function (" + joiny(K, ",") + "){ return binder.apply(this,arguments); }")(W), O.prototype) {
    var Y = function() {
    };
    Y.prototype = O.prototype, U.prototype = new Y(), Y.prototype = null;
  }
  return U;
}, implementation = implementation$1, functionBind = Function.prototype.bind || implementation, call$1 = Function.prototype.call, $hasOwn = Object.prototype.hasOwnProperty, bind$1 = functionBind, hasown = bind$1.call(call$1, $hasOwn), undefined$1, $Error = esErrors, $EvalError = _eval, $RangeError = range, $ReferenceError = ref, $SyntaxError$1 = syntax, $TypeError$2 = type, $URIError = uri, $Function = Function, getEvalledConstructor = function(z) {
  try {
    return $Function('"use strict"; return (' + z + ").constructor;")();
  } catch {
  }
}, $gOPD$1 = Object.getOwnPropertyDescriptor;
if ($gOPD$1)
  try {
    $gOPD$1({}, "");
  } catch {
    $gOPD$1 = null;
  }
var throwTypeError = function() {
  throw new $TypeError$2();
}, ThrowTypeError = $gOPD$1 ? function() {
  try {
    return arguments.callee, throwTypeError;
  } catch {
    try {
      return $gOPD$1(arguments, "callee").get;
    } catch {
      return throwTypeError;
    }
  }
}() : throwTypeError, hasSymbols = hasSymbols$1(), hasProto = hasProto$1(), getProto$1 = Object.getPrototypeOf || (hasProto ? function(z) {
  return z.__proto__;
} : null), needsEval = {}, TypedArray = typeof Uint8Array > "u" || !getProto$1 ? undefined$1 : getProto$1(Uint8Array), INTRINSICS = {
  __proto__: null,
  "%AggregateError%": typeof AggregateError > "u" ? undefined$1 : AggregateError,
  "%Array%": Array,
  "%ArrayBuffer%": typeof ArrayBuffer > "u" ? undefined$1 : ArrayBuffer,
  "%ArrayIteratorPrototype%": hasSymbols && getProto$1 ? getProto$1([][Symbol.iterator]()) : undefined$1,
  "%AsyncFromSyncIteratorPrototype%": undefined$1,
  "%AsyncFunction%": needsEval,
  "%AsyncGenerator%": needsEval,
  "%AsyncGeneratorFunction%": needsEval,
  "%AsyncIteratorPrototype%": needsEval,
  "%Atomics%": typeof Atomics > "u" ? undefined$1 : Atomics,
  "%BigInt%": typeof BigInt > "u" ? undefined$1 : BigInt,
  "%BigInt64Array%": typeof BigInt64Array > "u" ? undefined$1 : BigInt64Array,
  "%BigUint64Array%": typeof BigUint64Array > "u" ? undefined$1 : BigUint64Array,
  "%Boolean%": Boolean,
  "%DataView%": typeof DataView > "u" ? undefined$1 : DataView,
  "%Date%": Date,
  "%decodeURI%": decodeURI,
  "%decodeURIComponent%": decodeURIComponent,
  "%encodeURI%": encodeURI,
  "%encodeURIComponent%": encodeURIComponent,
  "%Error%": $Error,
  "%eval%": eval,
  // eslint-disable-line no-eval
  "%EvalError%": $EvalError,
  "%Float32Array%": typeof Float32Array > "u" ? undefined$1 : Float32Array,
  "%Float64Array%": typeof Float64Array > "u" ? undefined$1 : Float64Array,
  "%FinalizationRegistry%": typeof FinalizationRegistry > "u" ? undefined$1 : FinalizationRegistry,
  "%Function%": $Function,
  "%GeneratorFunction%": needsEval,
  "%Int8Array%": typeof Int8Array > "u" ? undefined$1 : Int8Array,
  "%Int16Array%": typeof Int16Array > "u" ? undefined$1 : Int16Array,
  "%Int32Array%": typeof Int32Array > "u" ? undefined$1 : Int32Array,
  "%isFinite%": isFinite,
  "%isNaN%": isNaN,
  "%IteratorPrototype%": hasSymbols && getProto$1 ? getProto$1(getProto$1([][Symbol.iterator]())) : undefined$1,
  "%JSON%": typeof JSON == "object" ? JSON : undefined$1,
  "%Map%": typeof Map > "u" ? undefined$1 : Map,
  "%MapIteratorPrototype%": typeof Map > "u" || !hasSymbols || !getProto$1 ? undefined$1 : getProto$1((/* @__PURE__ */ new Map())[Symbol.iterator]()),
  "%Math%": Math,
  "%Number%": Number,
  "%Object%": Object,
  "%parseFloat%": parseFloat,
  "%parseInt%": parseInt,
  "%Promise%": typeof Promise > "u" ? undefined$1 : Promise,
  "%Proxy%": typeof Proxy > "u" ? undefined$1 : Proxy,
  "%RangeError%": $RangeError,
  "%ReferenceError%": $ReferenceError,
  "%Reflect%": typeof Reflect > "u" ? undefined$1 : Reflect,
  "%RegExp%": RegExp,
  "%Set%": typeof Set > "u" ? undefined$1 : Set,
  "%SetIteratorPrototype%": typeof Set > "u" || !hasSymbols || !getProto$1 ? undefined$1 : getProto$1((/* @__PURE__ */ new Set())[Symbol.iterator]()),
  "%SharedArrayBuffer%": typeof SharedArrayBuffer > "u" ? undefined$1 : SharedArrayBuffer,
  "%String%": String,
  "%StringIteratorPrototype%": hasSymbols && getProto$1 ? getProto$1(""[Symbol.iterator]()) : undefined$1,
  "%Symbol%": hasSymbols ? Symbol : undefined$1,
  "%SyntaxError%": $SyntaxError$1,
  "%ThrowTypeError%": ThrowTypeError,
  "%TypedArray%": TypedArray,
  "%TypeError%": $TypeError$2,
  "%Uint8Array%": typeof Uint8Array > "u" ? undefined$1 : Uint8Array,
  "%Uint8ClampedArray%": typeof Uint8ClampedArray > "u" ? undefined$1 : Uint8ClampedArray,
  "%Uint16Array%": typeof Uint16Array > "u" ? undefined$1 : Uint16Array,
  "%Uint32Array%": typeof Uint32Array > "u" ? undefined$1 : Uint32Array,
  "%URIError%": $URIError,
  "%WeakMap%": typeof WeakMap > "u" ? undefined$1 : WeakMap,
  "%WeakRef%": typeof WeakRef > "u" ? undefined$1 : WeakRef,
  "%WeakSet%": typeof WeakSet > "u" ? undefined$1 : WeakSet
};
if (getProto$1)
  try {
    null.error;
  } catch (z) {
    var errorProto = getProto$1(getProto$1(z));
    INTRINSICS["%Error.prototype%"] = errorProto;
  }
var doEval = function z(D) {
  var O;
  if (D === "%AsyncFunction%")
    O = getEvalledConstructor("async function () {}");
  else if (D === "%GeneratorFunction%")
    O = getEvalledConstructor("function* () {}");
  else if (D === "%AsyncGeneratorFunction%")
    O = getEvalledConstructor("async function* () {}");
  else if (D === "%AsyncGenerator%") {
    var F = z("%AsyncGeneratorFunction%");
    F && (O = F.prototype);
  } else if (D === "%AsyncIteratorPrototype%") {
    var U = z("%AsyncGenerator%");
    U && getProto$1 && (O = getProto$1(U.prototype));
  }
  return INTRINSICS[D] = O, O;
}, LEGACY_ALIASES = {
  __proto__: null,
  "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
  "%ArrayPrototype%": ["Array", "prototype"],
  "%ArrayProto_entries%": ["Array", "prototype", "entries"],
  "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
  "%ArrayProto_keys%": ["Array", "prototype", "keys"],
  "%ArrayProto_values%": ["Array", "prototype", "values"],
  "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
  "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
  "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
  "%BooleanPrototype%": ["Boolean", "prototype"],
  "%DataViewPrototype%": ["DataView", "prototype"],
  "%DatePrototype%": ["Date", "prototype"],
  "%ErrorPrototype%": ["Error", "prototype"],
  "%EvalErrorPrototype%": ["EvalError", "prototype"],
  "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
  "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
  "%FunctionPrototype%": ["Function", "prototype"],
  "%Generator%": ["GeneratorFunction", "prototype"],
  "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
  "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
  "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
  "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
  "%JSONParse%": ["JSON", "parse"],
  "%JSONStringify%": ["JSON", "stringify"],
  "%MapPrototype%": ["Map", "prototype"],
  "%NumberPrototype%": ["Number", "prototype"],
  "%ObjectPrototype%": ["Object", "prototype"],
  "%ObjProto_toString%": ["Object", "prototype", "toString"],
  "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
  "%PromisePrototype%": ["Promise", "prototype"],
  "%PromiseProto_then%": ["Promise", "prototype", "then"],
  "%Promise_all%": ["Promise", "all"],
  "%Promise_reject%": ["Promise", "reject"],
  "%Promise_resolve%": ["Promise", "resolve"],
  "%RangeErrorPrototype%": ["RangeError", "prototype"],
  "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
  "%RegExpPrototype%": ["RegExp", "prototype"],
  "%SetPrototype%": ["Set", "prototype"],
  "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
  "%StringPrototype%": ["String", "prototype"],
  "%SymbolPrototype%": ["Symbol", "prototype"],
  "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
  "%TypedArrayPrototype%": ["TypedArray", "prototype"],
  "%TypeErrorPrototype%": ["TypeError", "prototype"],
  "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
  "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
  "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
  "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
  "%URIErrorPrototype%": ["URIError", "prototype"],
  "%WeakMapPrototype%": ["WeakMap", "prototype"],
  "%WeakSetPrototype%": ["WeakSet", "prototype"]
}, bind = functionBind, hasOwn = hasown, $concat = bind.call(Function.call, Array.prototype.concat), $spliceApply = bind.call(Function.apply, Array.prototype.splice), $replace = bind.call(Function.call, String.prototype.replace), $strSlice = bind.call(Function.call, String.prototype.slice), $exec = bind.call(Function.call, RegExp.prototype.exec), rePropName$1 = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g, reEscapeChar = /\\(\\)?/g, stringToPath = function z(D) {
  var O = $strSlice(D, 0, 1), F = $strSlice(D, -1);
  if (O === "%" && F !== "%")
    throw new $SyntaxError$1("invalid intrinsic syntax, expected closing `%`");
  if (F === "%" && O !== "%")
    throw new $SyntaxError$1("invalid intrinsic syntax, expected opening `%`");
  var U = [];
  return $replace(D, rePropName$1, function(W, B, K, X) {
    U[U.length] = K ? $replace(X, reEscapeChar, "$1") : B || W;
  }), U;
}, getBaseIntrinsic = function z(D, O) {
  var F = D, U;
  if (hasOwn(LEGACY_ALIASES, F) && (U = LEGACY_ALIASES[F], F = "%" + U[0] + "%"), hasOwn(INTRINSICS, F)) {
    var W = INTRINSICS[F];
    if (W === needsEval && (W = doEval(F)), typeof W > "u" && !O)
      throw new $TypeError$2("intrinsic " + D + " exists, but is not available. Please file an issue!");
    return {
      alias: U,
      name: F,
      value: W
    };
  }
  throw new $SyntaxError$1("intrinsic " + D + " does not exist!");
}, getIntrinsic = function z(D, O) {
  if (typeof D != "string" || D.length === 0)
    throw new $TypeError$2("intrinsic name must be a non-empty string");
  if (arguments.length > 1 && typeof O != "boolean")
    throw new $TypeError$2('"allowMissing" argument must be a boolean');
  if ($exec(/^%?[^%]*%?$/, D) === null)
    throw new $SyntaxError$1("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
  var F = stringToPath(D), U = F.length > 0 ? F[0] : "", W = getBaseIntrinsic("%" + U + "%", O), B = W.name, K = W.value, X = !1, Y = W.alias;
  Y && (U = Y[0], $spliceApply(F, $concat([0, 1], Y)));
  for (var Q = 1, J = !0; Q < F.length; Q += 1) {
    var ee = F[Q], ae = $strSlice(ee, 0, 1), re = $strSlice(ee, -1);
    if ((ae === '"' || ae === "'" || ae === "`" || re === '"' || re === "'" || re === "`") && ae !== re)
      throw new $SyntaxError$1("property names with quotes must have matching quotes");
    if ((ee === "constructor" || !J) && (X = !0), U += "." + ee, B = "%" + U + "%", hasOwn(INTRINSICS, B))
      K = INTRINSICS[B];
    else if (K != null) {
      if (!(ee in K)) {
        if (!O)
          throw new $TypeError$2("base intrinsic for " + D + " exists, but the property is not available.");
        return;
      }
      if ($gOPD$1 && Q + 1 >= F.length) {
        var ie = $gOPD$1(K, ee);
        J = !!ie, J && "get" in ie && !("originalValue" in ie.get) ? K = ie.get : K = K[ee];
      } else
        J = hasOwn(K, ee), K = K[ee];
      J && !X && (INTRINSICS[B] = K);
    }
  }
  return K;
}, callBind$2 = { exports: {} }, esDefineProperty, hasRequiredEsDefineProperty;
function requireEsDefineProperty() {
  if (hasRequiredEsDefineProperty)
    return esDefineProperty;
  hasRequiredEsDefineProperty = 1;
  var z = getIntrinsic, D = z("%Object.defineProperty%", !0) || !1;
  if (D)
    try {
      D({}, "a", { value: 1 });
    } catch {
      D = !1;
    }
  return esDefineProperty = D, esDefineProperty;
}
var GetIntrinsic$2 = getIntrinsic, $gOPD = GetIntrinsic$2("%Object.getOwnPropertyDescriptor%", !0);
if ($gOPD)
  try {
    $gOPD([], "length");
  } catch {
    $gOPD = null;
  }
var gopd$1 = $gOPD, $defineProperty$1 = requireEsDefineProperty(), $SyntaxError = syntax, $TypeError$1 = type, gopd = gopd$1, defineDataProperty = function z(D, O, F) {
  if (!D || typeof D != "object" && typeof D != "function")
    throw new $TypeError$1("`obj` must be an object or a function`");
  if (typeof O != "string" && typeof O != "symbol")
    throw new $TypeError$1("`property` must be a string or a symbol`");
  if (arguments.length > 3 && typeof arguments[3] != "boolean" && arguments[3] !== null)
    throw new $TypeError$1("`nonEnumerable`, if provided, must be a boolean or null");
  if (arguments.length > 4 && typeof arguments[4] != "boolean" && arguments[4] !== null)
    throw new $TypeError$1("`nonWritable`, if provided, must be a boolean or null");
  if (arguments.length > 5 && typeof arguments[5] != "boolean" && arguments[5] !== null)
    throw new $TypeError$1("`nonConfigurable`, if provided, must be a boolean or null");
  if (arguments.length > 6 && typeof arguments[6] != "boolean")
    throw new $TypeError$1("`loose`, if provided, must be a boolean");
  var U = arguments.length > 3 ? arguments[3] : null, W = arguments.length > 4 ? arguments[4] : null, B = arguments.length > 5 ? arguments[5] : null, K = arguments.length > 6 ? arguments[6] : !1, X = !!gopd && gopd(D, O);
  if ($defineProperty$1)
    $defineProperty$1(D, O, {
      configurable: B === null && X ? X.configurable : !B,
      enumerable: U === null && X ? X.enumerable : !U,
      value: F,
      writable: W === null && X ? X.writable : !W
    });
  else if (K || !U && !W && !B)
    D[O] = F;
  else
    throw new $SyntaxError("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.");
}, $defineProperty = requireEsDefineProperty(), hasPropertyDescriptors = function z() {
  return !!$defineProperty;
};
hasPropertyDescriptors.hasArrayLengthDefineBug = function z() {
  if (!$defineProperty)
    return null;
  try {
    return $defineProperty([], "length", { value: 1 }).length !== 1;
  } catch {
    return !0;
  }
};
var hasPropertyDescriptors_1 = hasPropertyDescriptors, GetIntrinsic$1 = getIntrinsic, define = defineDataProperty, hasDescriptors = hasPropertyDescriptors_1(), gOPD$1 = gopd$1, $TypeError = type, $floor = GetIntrinsic$1("%Math.floor%"), setFunctionLength = function z(D, O) {
  if (typeof D != "function")
    throw new $TypeError("`fn` is not a function");
  if (typeof O != "number" || O < 0 || O > 4294967295 || $floor(O) !== O)
    throw new $TypeError("`length` must be a positive 32-bit integer");
  var F = arguments.length > 2 && !!arguments[2], U = !0, W = !0;
  if ("length" in D && gOPD$1) {
    var B = gOPD$1(D, "length");
    B && !B.configurable && (U = !1), B && !B.writable && (W = !1);
  }
  return (U || W || !F) && (hasDescriptors ? define(
    /** @type {Parameters<define>[0]} */
    D,
    "length",
    O,
    !0,
    !0
  ) : define(
    /** @type {Parameters<define>[0]} */
    D,
    "length",
    O
  )), D;
};
(function(z) {
  var D = functionBind, O = getIntrinsic, F = setFunctionLength, U = type, W = O("%Function.prototype.apply%"), B = O("%Function.prototype.call%"), K = O("%Reflect.apply%", !0) || D.call(B, W), X = requireEsDefineProperty(), Y = O("%Math.max%");
  z.exports = function(ee) {
    if (typeof ee != "function")
      throw new U("a function is required");
    var ae = K(D, B, arguments);
    return F(
      ae,
      1 + Y(0, ee.length - (arguments.length - 1)),
      !0
    );
  };
  var Q = function() {
    return K(D, W, arguments);
  };
  X ? X(z.exports, "apply", { value: Q }) : z.exports.apply = Q;
})(callBind$2);
var callBindExports = callBind$2.exports, GetIntrinsic = getIntrinsic, callBind$1 = callBindExports, $indexOf$1 = callBind$1(GetIntrinsic("String.prototype.indexOf")), callBound$2 = function z(D, O) {
  var F = GetIntrinsic(D, !!O);
  return typeof F == "function" && $indexOf$1(D, ".prototype.") > -1 ? callBind$1(F) : F;
}, hasToStringTag$3 = shams(), callBound$1 = callBound$2, $toString$1 = callBound$1("Object.prototype.toString"), isStandardArguments = function z(D) {
  return hasToStringTag$3 && D && typeof D == "object" && Symbol.toStringTag in D ? !1 : $toString$1(D) === "[object Arguments]";
}, isLegacyArguments = function z(D) {
  return isStandardArguments(D) ? !0 : D !== null && typeof D == "object" && typeof D.length == "number" && D.length >= 0 && $toString$1(D) !== "[object Array]" && $toString$1(D.callee) === "[object Function]";
}, supportsStandardArguments = function() {
  return isStandardArguments(arguments);
}();
isStandardArguments.isLegacyArguments = isLegacyArguments;
var isArguments = supportsStandardArguments ? isStandardArguments : isLegacyArguments, toStr$2 = Object.prototype.toString, fnToStr$1 = Function.prototype.toString, isFnRegex = /^\s*(?:function)?\*/, hasToStringTag$2 = shams(), getProto = Object.getPrototypeOf, getGeneratorFunc = function() {
  if (!hasToStringTag$2)
    return !1;
  try {
    return Function("return function*() {}")();
  } catch {
  }
}, GeneratorFunction, isGeneratorFunction = function z(D) {
  if (typeof D != "function")
    return !1;
  if (isFnRegex.test(fnToStr$1.call(D)))
    return !0;
  if (!hasToStringTag$2) {
    var O = toStr$2.call(D);
    return O === "[object GeneratorFunction]";
  }
  if (!getProto)
    return !1;
  if (typeof GeneratorFunction > "u") {
    var F = getGeneratorFunc();
    GeneratorFunction = F ? getProto(F) : !1;
  }
  return getProto(D) === GeneratorFunction;
}, fnToStr = Function.prototype.toString, reflectApply = typeof Reflect == "object" && Reflect !== null && Reflect.apply, badArrayLike, isCallableMarker;
if (typeof reflectApply == "function" && typeof Object.defineProperty == "function")
  try {
    badArrayLike = Object.defineProperty({}, "length", {
      get: function() {
        throw isCallableMarker;
      }
    }), isCallableMarker = {}, reflectApply(function() {
      throw 42;
    }, null, badArrayLike);
  } catch (z) {
    z !== isCallableMarker && (reflectApply = null);
  }
else
  reflectApply = null;
var constructorRegex = /^\s*class\b/, isES6ClassFn = function z(D) {
  try {
    var O = fnToStr.call(D);
    return constructorRegex.test(O);
  } catch {
    return !1;
  }
}, tryFunctionObject = function z(D) {
  try {
    return isES6ClassFn(D) ? !1 : (fnToStr.call(D), !0);
  } catch {
    return !1;
  }
}, toStr$1 = Object.prototype.toString, objectClass = "[object Object]", fnClass = "[object Function]", genClass = "[object GeneratorFunction]", ddaClass = "[object HTMLAllCollection]", ddaClass2 = "[object HTML document.all class]", ddaClass3 = "[object HTMLCollection]", hasToStringTag$1 = typeof Symbol == "function" && !!Symbol.toStringTag, isIE68 = !(0 in [,]), isDDA = function z() {
  return !1;
};
if (typeof document == "object") {
  var all = document.all;
  toStr$1.call(all) === toStr$1.call(document.all) && (isDDA = function(D) {
    if ((isIE68 || !D) && (typeof D > "u" || typeof D == "object"))
      try {
        var O = toStr$1.call(D);
        return (O === ddaClass || O === ddaClass2 || O === ddaClass3 || O === objectClass) && D("") == null;
      } catch {
      }
    return !1;
  });
}
var isCallable$1 = reflectApply ? function z(D) {
  if (isDDA(D))
    return !0;
  if (!D || typeof D != "function" && typeof D != "object")
    return !1;
  try {
    reflectApply(D, null, badArrayLike);
  } catch (O) {
    if (O !== isCallableMarker)
      return !1;
  }
  return !isES6ClassFn(D) && tryFunctionObject(D);
} : function z(D) {
  if (isDDA(D))
    return !0;
  if (!D || typeof D != "function" && typeof D != "object")
    return !1;
  if (hasToStringTag$1)
    return tryFunctionObject(D);
  if (isES6ClassFn(D))
    return !1;
  var O = toStr$1.call(D);
  return O !== fnClass && O !== genClass && !/^\[object HTML/.test(O) ? !1 : tryFunctionObject(D);
}, isCallable = isCallable$1, toStr = Object.prototype.toString, hasOwnProperty = Object.prototype.hasOwnProperty, forEachArray = function z(D, O, F) {
  for (var U = 0, W = D.length; U < W; U++)
    hasOwnProperty.call(D, U) && (F == null ? O(D[U], U, D) : O.call(F, D[U], U, D));
}, forEachString = function z(D, O, F) {
  for (var U = 0, W = D.length; U < W; U++)
    F == null ? O(D.charAt(U), U, D) : O.call(F, D.charAt(U), U, D);
}, forEachObject = function z(D, O, F) {
  for (var U in D)
    hasOwnProperty.call(D, U) && (F == null ? O(D[U], U, D) : O.call(F, D[U], U, D));
}, forEach$1 = function z(D, O, F) {
  if (!isCallable(O))
    throw new TypeError("iterator must be a function");
  var U;
  arguments.length >= 3 && (U = F), toStr.call(D) === "[object Array]" ? forEachArray(D, O, U) : typeof D == "string" ? forEachString(D, O, U) : forEachObject(D, O, U);
}, forEach_1 = forEach$1, possibleTypedArrayNames = [
  "Float32Array",
  "Float64Array",
  "Int8Array",
  "Int16Array",
  "Int32Array",
  "Uint8Array",
  "Uint8ClampedArray",
  "Uint16Array",
  "Uint32Array",
  "BigInt64Array",
  "BigUint64Array"
], possibleNames = possibleTypedArrayNames, g$1 = typeof globalThis > "u" ? commonjsGlobal : globalThis, availableTypedArrays$1 = function z() {
  for (var D = [], O = 0; O < possibleNames.length; O++)
    typeof g$1[possibleNames[O]] == "function" && (D[D.length] = possibleNames[O]);
  return D;
}, forEach = forEach_1, availableTypedArrays = availableTypedArrays$1, callBind = callBindExports, callBound = callBound$2, gOPD = gopd$1, $toString = callBound("Object.prototype.toString"), hasToStringTag = shams(), g = typeof globalThis > "u" ? commonjsGlobal : globalThis, typedArrays = availableTypedArrays(), $slice = callBound("String.prototype.slice"), getPrototypeOf = Object.getPrototypeOf, $indexOf = callBound("Array.prototype.indexOf", !0) || function z(D, O) {
  for (var F = 0; F < D.length; F += 1)
    if (D[F] === O)
      return F;
  return -1;
}, cache = { __proto__: null };
hasToStringTag && gOPD && getPrototypeOf ? forEach(typedArrays, function(z) {
  var D = new g[z]();
  if (Symbol.toStringTag in D) {
    var O = getPrototypeOf(D), F = gOPD(O, Symbol.toStringTag);
    if (!F) {
      var U = getPrototypeOf(O);
      F = gOPD(U, Symbol.toStringTag);
    }
    cache["$" + z] = callBind(F.get);
  }
}) : forEach(typedArrays, function(z) {
  var D = new g[z](), O = D.slice || D.set;
  O && (cache["$" + z] = callBind(O));
});
var tryTypedArrays = function z(D) {
  var O = !1;
  return forEach(
    // eslint-disable-next-line no-extra-parens
    /** @type {Record<`\$${TypedArrayName}`, Getter>} */
    /** @type {any} */
    cache,
    /** @type {(getter: Getter, name: `\$${import('.').TypedArrayName}`) => void} */
    function(F, U) {
      if (!O)
        try {
          "$" + F(D) === U && (O = $slice(U, 1));
        } catch {
        }
    }
  ), O;
}, trySlices = function z(D) {
  var O = !1;
  return forEach(
    // eslint-disable-next-line no-extra-parens
    /** @type {Record<`\$${TypedArrayName}`, Getter>} */
    /** @type {any} */
    cache,
    /** @type {(getter: typeof cache, name: `\$${import('.').TypedArrayName}`) => void} */
    function(F, U) {
      if (!O)
        try {
          F(D), O = $slice(U, 1);
        } catch {
        }
    }
  ), O;
}, whichTypedArray$1 = function z(D) {
  if (!D || typeof D != "object")
    return !1;
  if (!hasToStringTag) {
    var O = $slice($toString(D), 8, -1);
    return $indexOf(typedArrays, O) > -1 ? O : O !== "Object" ? !1 : trySlices(D);
  }
  return gOPD ? tryTypedArrays(D) : null;
}, whichTypedArray = whichTypedArray$1, isTypedArray = function z(D) {
  return !!whichTypedArray(D);
};
(function(z) {
  var D = isArguments, O = isGeneratorFunction, F = whichTypedArray$1, U = isTypedArray;
  function W(Xe) {
    return Xe.call.bind(Xe);
  }
  var B = typeof BigInt < "u", K = typeof Symbol < "u", X = W(Object.prototype.toString), Y = W(Number.prototype.valueOf), Q = W(String.prototype.valueOf), J = W(Boolean.prototype.valueOf);
  if (B)
    var ee = W(BigInt.prototype.valueOf);
  if (K)
    var ae = W(Symbol.prototype.valueOf);
  function re(Xe, at) {
    if (typeof Xe != "object")
      return !1;
    try {
      return at(Xe), !0;
    } catch {
      return !1;
    }
  }
  z.isArgumentsObject = D, z.isGeneratorFunction = O, z.isTypedArray = U;
  function ie(Xe) {
    return typeof Promise < "u" && Xe instanceof Promise || Xe !== null && typeof Xe == "object" && typeof Xe.then == "function" && typeof Xe.catch == "function";
  }
  z.isPromise = ie;
  function ue(Xe) {
    return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? ArrayBuffer.isView(Xe) : U(Xe) || ve(Xe);
  }
  z.isArrayBufferView = ue;
  function q(Xe) {
    return F(Xe) === "Uint8Array";
  }
  z.isUint8Array = q;
  function ne(Xe) {
    return F(Xe) === "Uint8ClampedArray";
  }
  z.isUint8ClampedArray = ne;
  function ce(Xe) {
    return F(Xe) === "Uint16Array";
  }
  z.isUint16Array = ce;
  function he(Xe) {
    return F(Xe) === "Uint32Array";
  }
  z.isUint32Array = he;
  function we(Xe) {
    return F(Xe) === "Int8Array";
  }
  z.isInt8Array = we;
  function me(Xe) {
    return F(Xe) === "Int16Array";
  }
  z.isInt16Array = me;
  function de(Xe) {
    return F(Xe) === "Int32Array";
  }
  z.isInt32Array = de;
  function be(Xe) {
    return F(Xe) === "Float32Array";
  }
  z.isFloat32Array = be;
  function _e(Xe) {
    return F(Xe) === "Float64Array";
  }
  z.isFloat64Array = _e;
  function Me(Xe) {
    return F(Xe) === "BigInt64Array";
  }
  z.isBigInt64Array = Me;
  function Ne(Xe) {
    return F(Xe) === "BigUint64Array";
  }
  z.isBigUint64Array = Ne;
  function Ee(Xe) {
    return X(Xe) === "[object Map]";
  }
  Ee.working = typeof Map < "u" && Ee(/* @__PURE__ */ new Map());
  function $e(Xe) {
    return typeof Map > "u" ? !1 : Ee.working ? Ee(Xe) : Xe instanceof Map;
  }
  z.isMap = $e;
  function De(Xe) {
    return X(Xe) === "[object Set]";
  }
  De.working = typeof Set < "u" && De(/* @__PURE__ */ new Set());
  function Fe(Xe) {
    return typeof Set > "u" ? !1 : De.working ? De(Xe) : Xe instanceof Set;
  }
  z.isSet = Fe;
  function Be(Xe) {
    return X(Xe) === "[object WeakMap]";
  }
  Be.working = typeof WeakMap < "u" && Be(/* @__PURE__ */ new WeakMap());
  function We(Xe) {
    return typeof WeakMap > "u" ? !1 : Be.working ? Be(Xe) : Xe instanceof WeakMap;
  }
  z.isWeakMap = We;
  function Ve(Xe) {
    return X(Xe) === "[object WeakSet]";
  }
  Ve.working = typeof WeakSet < "u" && Ve(/* @__PURE__ */ new WeakSet());
  function ze(Xe) {
    return Ve(Xe);
  }
  z.isWeakSet = ze;
  function ke(Xe) {
    return X(Xe) === "[object ArrayBuffer]";
  }
  ke.working = typeof ArrayBuffer < "u" && ke(new ArrayBuffer());
  function je(Xe) {
    return typeof ArrayBuffer > "u" ? !1 : ke.working ? ke(Xe) : Xe instanceof ArrayBuffer;
  }
  z.isArrayBuffer = je;
  function Ie(Xe) {
    return X(Xe) === "[object DataView]";
  }
  Ie.working = typeof ArrayBuffer < "u" && typeof DataView < "u" && Ie(new DataView(new ArrayBuffer(1), 0, 1));
  function ve(Xe) {
    return typeof DataView > "u" ? !1 : Ie.working ? Ie(Xe) : Xe instanceof DataView;
  }
  z.isDataView = ve;
  var xe = typeof SharedArrayBuffer < "u" ? SharedArrayBuffer : void 0;
  function Oe(Xe) {
    return X(Xe) === "[object SharedArrayBuffer]";
  }
  function Te(Xe) {
    return typeof xe > "u" ? !1 : (typeof Oe.working > "u" && (Oe.working = Oe(new xe())), Oe.working ? Oe(Xe) : Xe instanceof xe);
  }
  z.isSharedArrayBuffer = Te;
  function Ce(Xe) {
    return X(Xe) === "[object AsyncFunction]";
  }
  z.isAsyncFunction = Ce;
  function te(Xe) {
    return X(Xe) === "[object Map Iterator]";
  }
  z.isMapIterator = te;
  function le(Xe) {
    return X(Xe) === "[object Set Iterator]";
  }
  z.isSetIterator = le;
  function ge(Xe) {
    return X(Xe) === "[object Generator]";
  }
  z.isGeneratorObject = ge;
  function pe(Xe) {
    return X(Xe) === "[object WebAssembly.Module]";
  }
  z.isWebAssemblyCompiledModule = pe;
  function fe(Xe) {
    return re(Xe, Y);
  }
  z.isNumberObject = fe;
  function Se(Xe) {
    return re(Xe, Q);
  }
  z.isStringObject = Se;
  function Pe(Xe) {
    return re(Xe, J);
  }
  z.isBooleanObject = Pe;
  function Ge(Xe) {
    return B && re(Xe, ee);
  }
  z.isBigIntObject = Ge;
  function Qe(Xe) {
    return K && re(Xe, ae);
  }
  z.isSymbolObject = Qe;
  function et(Xe) {
    return fe(Xe) || Se(Xe) || Pe(Xe) || Ge(Xe) || Qe(Xe);
  }
  z.isBoxedPrimitive = et;
  function rt(Xe) {
    return typeof Uint8Array < "u" && (je(Xe) || Te(Xe));
  }
  z.isAnyArrayBuffer = rt, ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach(function(Xe) {
    Object.defineProperty(z, Xe, {
      enumerable: !1,
      value: function() {
        throw new Error(Xe + " is not supported in userland");
      }
    });
  });
})(types);
var isBufferBrowser = function z(D) {
  return D && typeof D == "object" && typeof D.copy == "function" && typeof D.fill == "function" && typeof D.readUInt8 == "function";
}, inherits_browser = { exports: {} };
typeof Object.create == "function" ? inherits_browser.exports = function(D, O) {
  O && (D.super_ = O, D.prototype = Object.create(O.prototype, {
    constructor: {
      value: D,
      enumerable: !1,
      writable: !0,
      configurable: !0
    }
  }));
} : inherits_browser.exports = function(D, O) {
  if (O) {
    D.super_ = O;
    var F = function() {
    };
    F.prototype = O.prototype, D.prototype = new F(), D.prototype.constructor = D;
  }
};
var inherits_browserExports = inherits_browser.exports;
(function(z) {
  var D = Object.getOwnPropertyDescriptors || function(ve) {
    for (var xe = Object.keys(ve), Oe = {}, Te = 0; Te < xe.length; Te++)
      Oe[xe[Te]] = Object.getOwnPropertyDescriptor(ve, xe[Te]);
    return Oe;
  }, O = /%[sdj%]/g;
  z.format = function(Ie) {
    if (!we(Ie)) {
      for (var ve = [], xe = 0; xe < arguments.length; xe++)
        ve.push(B(arguments[xe]));
      return ve.join(" ");
    }
    for (var xe = 1, Oe = arguments, Te = Oe.length, Ce = String(Ie).replace(O, function(le) {
      if (le === "%%")
        return "%";
      if (xe >= Te)
        return le;
      switch (le) {
        case "%s":
          return String(Oe[xe++]);
        case "%d":
          return Number(Oe[xe++]);
        case "%j":
          try {
            return JSON.stringify(Oe[xe++]);
          } catch {
            return "[Circular]";
          }
        default:
          return le;
      }
    }), te = Oe[xe]; xe < Te; te = Oe[++xe])
      ne(te) || !_e(te) ? Ce += " " + te : Ce += " " + B(te);
    return Ce;
  }, z.deprecate = function(Ie, ve) {
    if (typeof process$1 < "u" && process$1.noDeprecation === !0)
      return Ie;
    if (typeof process$1 > "u")
      return function() {
        return z.deprecate(Ie, ve).apply(this, arguments);
      };
    var xe = !1;
    function Oe() {
      if (!xe) {
        if (process$1.throwDeprecation)
          throw new Error(ve);
        process$1.traceDeprecation ? console.trace(ve) : console.error(ve), xe = !0;
      }
      return Ie.apply(this, arguments);
    }
    return Oe;
  };
  var F = {}, U = /^$/;
  if (process$1.env.NODE_DEBUG) {
    var W = process$1.env.NODE_DEBUG;
    W = W.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase(), U = new RegExp("^" + W + "$", "i");
  }
  z.debuglog = function(Ie) {
    if (Ie = Ie.toUpperCase(), !F[Ie])
      if (U.test(Ie)) {
        var ve = process$1.pid;
        F[Ie] = function() {
          var xe = z.format.apply(z, arguments);
          console.error("%s %d: %s", Ie, ve, xe);
        };
      } else
        F[Ie] = function() {
        };
    return F[Ie];
  };
  function B(Ie, ve) {
    var xe = {
      seen: [],
      stylize: X
    };
    return arguments.length >= 3 && (xe.depth = arguments[2]), arguments.length >= 4 && (xe.colors = arguments[3]), q(ve) ? xe.showHidden = ve : ve && z._extend(xe, ve), de(xe.showHidden) && (xe.showHidden = !1), de(xe.depth) && (xe.depth = 2), de(xe.colors) && (xe.colors = !1), de(xe.customInspect) && (xe.customInspect = !0), xe.colors && (xe.stylize = K), Q(xe, Ie, xe.depth);
  }
  z.inspect = B, B.colors = {
    bold: [1, 22],
    italic: [3, 23],
    underline: [4, 24],
    inverse: [7, 27],
    white: [37, 39],
    grey: [90, 39],
    black: [30, 39],
    blue: [34, 39],
    cyan: [36, 39],
    green: [32, 39],
    magenta: [35, 39],
    red: [31, 39],
    yellow: [33, 39]
  }, B.styles = {
    special: "cyan",
    number: "yellow",
    boolean: "yellow",
    undefined: "grey",
    null: "bold",
    string: "green",
    date: "magenta",
    // "name": intentionally not styling
    regexp: "red"
  };
  function K(Ie, ve) {
    var xe = B.styles[ve];
    return xe ? "\x1B[" + B.colors[xe][0] + "m" + Ie + "\x1B[" + B.colors[xe][1] + "m" : Ie;
  }
  function X(Ie, ve) {
    return Ie;
  }
  function Y(Ie) {
    var ve = {};
    return Ie.forEach(function(xe, Oe) {
      ve[xe] = !0;
    }), ve;
  }
  function Q(Ie, ve, xe) {
    if (Ie.customInspect && ve && Ee(ve.inspect) && // Filter out the util module, it's inspect function is special
    ve.inspect !== z.inspect && // Also filter out any prototype objects using the circular check.
    !(ve.constructor && ve.constructor.prototype === ve)) {
      var Oe = ve.inspect(xe, Ie);
      return we(Oe) || (Oe = Q(Ie, Oe, xe)), Oe;
    }
    var Te = J(Ie, ve);
    if (Te)
      return Te;
    var Ce = Object.keys(ve), te = Y(Ce);
    if (Ie.showHidden && (Ce = Object.getOwnPropertyNames(ve)), Ne(ve) && (Ce.indexOf("message") >= 0 || Ce.indexOf("description") >= 0))
      return ee(ve);
    if (Ce.length === 0) {
      if (Ee(ve)) {
        var le = ve.name ? ": " + ve.name : "";
        return Ie.stylize("[Function" + le + "]", "special");
      }
      if (be(ve))
        return Ie.stylize(RegExp.prototype.toString.call(ve), "regexp");
      if (Me(ve))
        return Ie.stylize(Date.prototype.toString.call(ve), "date");
      if (Ne(ve))
        return ee(ve);
    }
    var ge = "", pe = !1, fe = ["{", "}"];
    if (ue(ve) && (pe = !0, fe = ["[", "]"]), Ee(ve)) {
      var Se = ve.name ? ": " + ve.name : "";
      ge = " [Function" + Se + "]";
    }
    if (be(ve) && (ge = " " + RegExp.prototype.toString.call(ve)), Me(ve) && (ge = " " + Date.prototype.toUTCString.call(ve)), Ne(ve) && (ge = " " + ee(ve)), Ce.length === 0 && (!pe || ve.length == 0))
      return fe[0] + ge + fe[1];
    if (xe < 0)
      return be(ve) ? Ie.stylize(RegExp.prototype.toString.call(ve), "regexp") : Ie.stylize("[Object]", "special");
    Ie.seen.push(ve);
    var Pe;
    return pe ? Pe = ae(Ie, ve, xe, te, Ce) : Pe = Ce.map(function(Ge) {
      return re(Ie, ve, xe, te, Ge, pe);
    }), Ie.seen.pop(), ie(Pe, ge, fe);
  }
  function J(Ie, ve) {
    if (de(ve))
      return Ie.stylize("undefined", "undefined");
    if (we(ve)) {
      var xe = "'" + JSON.stringify(ve).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
      return Ie.stylize(xe, "string");
    }
    if (he(ve))
      return Ie.stylize("" + ve, "number");
    if (q(ve))
      return Ie.stylize("" + ve, "boolean");
    if (ne(ve))
      return Ie.stylize("null", "null");
  }
  function ee(Ie) {
    return "[" + Error.prototype.toString.call(Ie) + "]";
  }
  function ae(Ie, ve, xe, Oe, Te) {
    for (var Ce = [], te = 0, le = ve.length; te < le; ++te)
      Ve(ve, String(te)) ? Ce.push(re(
        Ie,
        ve,
        xe,
        Oe,
        String(te),
        !0
      )) : Ce.push("");
    return Te.forEach(function(ge) {
      ge.match(/^\d+$/) || Ce.push(re(
        Ie,
        ve,
        xe,
        Oe,
        ge,
        !0
      ));
    }), Ce;
  }
  function re(Ie, ve, xe, Oe, Te, Ce) {
    var te, le, ge;
    if (ge = Object.getOwnPropertyDescriptor(ve, Te) || { value: ve[Te] }, ge.get ? ge.set ? le = Ie.stylize("[Getter/Setter]", "special") : le = Ie.stylize("[Getter]", "special") : ge.set && (le = Ie.stylize("[Setter]", "special")), Ve(Oe, Te) || (te = "[" + Te + "]"), le || (Ie.seen.indexOf(ge.value) < 0 ? (ne(xe) ? le = Q(Ie, ge.value, null) : le = Q(Ie, ge.value, xe - 1), le.indexOf(`
`) > -1 && (Ce ? le = le.split(`
`).map(function(pe) {
      return "  " + pe;
    }).join(`
`).slice(2) : le = `
` + le.split(`
`).map(function(pe) {
      return "   " + pe;
    }).join(`
`))) : le = Ie.stylize("[Circular]", "special")), de(te)) {
      if (Ce && Te.match(/^\d+$/))
        return le;
      te = JSON.stringify("" + Te), te.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (te = te.slice(1, -1), te = Ie.stylize(te, "name")) : (te = te.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), te = Ie.stylize(te, "string"));
    }
    return te + ": " + le;
  }
  function ie(Ie, ve, xe) {
    var Oe = Ie.reduce(function(Te, Ce) {
      return Ce.indexOf(`
`) >= 0, Te + Ce.replace(/\u001b\[\d\d?m/g, "").length + 1;
    }, 0);
    return Oe > 60 ? xe[0] + (ve === "" ? "" : ve + `
 `) + " " + Ie.join(`,
  `) + " " + xe[1] : xe[0] + ve + " " + Ie.join(", ") + " " + xe[1];
  }
  z.types = types;
  function ue(Ie) {
    return Array.isArray(Ie);
  }
  z.isArray = ue;
  function q(Ie) {
    return typeof Ie == "boolean";
  }
  z.isBoolean = q;
  function ne(Ie) {
    return Ie === null;
  }
  z.isNull = ne;
  function ce(Ie) {
    return Ie == null;
  }
  z.isNullOrUndefined = ce;
  function he(Ie) {
    return typeof Ie == "number";
  }
  z.isNumber = he;
  function we(Ie) {
    return typeof Ie == "string";
  }
  z.isString = we;
  function me(Ie) {
    return typeof Ie == "symbol";
  }
  z.isSymbol = me;
  function de(Ie) {
    return Ie === void 0;
  }
  z.isUndefined = de;
  function be(Ie) {
    return _e(Ie) && De(Ie) === "[object RegExp]";
  }
  z.isRegExp = be, z.types.isRegExp = be;
  function _e(Ie) {
    return typeof Ie == "object" && Ie !== null;
  }
  z.isObject = _e;
  function Me(Ie) {
    return _e(Ie) && De(Ie) === "[object Date]";
  }
  z.isDate = Me, z.types.isDate = Me;
  function Ne(Ie) {
    return _e(Ie) && (De(Ie) === "[object Error]" || Ie instanceof Error);
  }
  z.isError = Ne, z.types.isNativeError = Ne;
  function Ee(Ie) {
    return typeof Ie == "function";
  }
  z.isFunction = Ee;
  function $e(Ie) {
    return Ie === null || typeof Ie == "boolean" || typeof Ie == "number" || typeof Ie == "string" || typeof Ie == "symbol" || // ES6 symbol
    typeof Ie > "u";
  }
  z.isPrimitive = $e, z.isBuffer = isBufferBrowser;
  function De(Ie) {
    return Object.prototype.toString.call(Ie);
  }
  function Fe(Ie) {
    return Ie < 10 ? "0" + Ie.toString(10) : Ie.toString(10);
  }
  var Be = [
    "Jan",
    "Feb",
    "Mar",
    "Apr",
    "May",
    "Jun",
    "Jul",
    "Aug",
    "Sep",
    "Oct",
    "Nov",
    "Dec"
  ];
  function We() {
    var Ie = /* @__PURE__ */ new Date(), ve = [
      Fe(Ie.getHours()),
      Fe(Ie.getMinutes()),
      Fe(Ie.getSeconds())
    ].join(":");
    return [Ie.getDate(), Be[Ie.getMonth()], ve].join(" ");
  }
  z.log = function() {
    console.log("%s - %s", We(), z.format.apply(z, arguments));
  }, z.inherits = inherits_browserExports, z._extend = function(Ie, ve) {
    if (!ve || !_e(ve))
      return Ie;
    for (var xe = Object.keys(ve), Oe = xe.length; Oe--; )
      Ie[xe[Oe]] = ve[xe[Oe]];
    return Ie;
  };
  function Ve(Ie, ve) {
    return Object.prototype.hasOwnProperty.call(Ie, ve);
  }
  var ze = typeof Symbol < "u" ? Symbol("util.promisify.custom") : void 0;
  z.promisify = function(ve) {
    if (typeof ve != "function")
      throw new TypeError('The "original" argument must be of type Function');
    if (ze && ve[ze]) {
      var xe = ve[ze];
      if (typeof xe != "function")
        throw new TypeError('The "util.promisify.custom" argument must be of type Function');
      return Object.defineProperty(xe, ze, {
        value: xe,
        enumerable: !1,
        writable: !1,
        configurable: !0
      }), xe;
    }
    function xe() {
      for (var Oe, Te, Ce = new Promise(function(ge, pe) {
        Oe = ge, Te = pe;
      }), te = [], le = 0; le < arguments.length; le++)
        te.push(arguments[le]);
      te.push(function(ge, pe) {
        ge ? Te(ge) : Oe(pe);
      });
      try {
        ve.apply(this, te);
      } catch (ge) {
        Te(ge);
      }
      return Ce;
    }
    return Object.setPrototypeOf(xe, Object.getPrototypeOf(ve)), ze && Object.defineProperty(xe, ze, {
      value: xe,
      enumerable: !1,
      writable: !1,
      configurable: !0
    }), Object.defineProperties(
      xe,
      D(ve)
    );
  }, z.promisify.custom = ze;
  function ke(Ie, ve) {
    if (!Ie) {
      var xe = new Error("Promise was rejected with a falsy value");
      xe.reason = Ie, Ie = xe;
    }
    return ve(Ie);
  }
  function je(Ie) {
    if (typeof Ie != "function")
      throw new TypeError('The "original" argument must be of type Function');
    function ve() {
      for (var xe = [], Oe = 0; Oe < arguments.length; Oe++)
        xe.push(arguments[Oe]);
      var Te = xe.pop();
      if (typeof Te != "function")
        throw new TypeError("The last argument must be of type Function");
      var Ce = this, te = function() {
        return Te.apply(Ce, arguments);
      };
      Ie.apply(this, xe).then(
        function(le) {
          process$1.nextTick(te.bind(null, null, le));
        },
        function(le) {
          process$1.nextTick(ke.bind(null, le, te));
        }
      );
    }
    return Object.setPrototypeOf(ve, Object.getPrototypeOf(Ie)), Object.defineProperties(
      ve,
      D(Ie)
    ), ve;
  }
  z.callbackify = je;
})(util);
var buffer_list, hasRequiredBuffer_list;
function requireBuffer_list() {
  if (hasRequiredBuffer_list)
    return buffer_list;
  hasRequiredBuffer_list = 1;
  function z(re, ie) {
    var ue = Object.keys(re);
    if (Object.getOwnPropertySymbols) {
      var q = Object.getOwnPropertySymbols(re);
      ie && (q = q.filter(function(ne) {
        return Object.getOwnPropertyDescriptor(re, ne).enumerable;
      })), ue.push.apply(ue, q);
    }
    return ue;
  }
  function D(re) {
    for (var ie = 1; ie < arguments.length; ie++) {
      var ue = arguments[ie] != null ? arguments[ie] : {};
      ie % 2 ? z(Object(ue), !0).forEach(function(q) {
        O(re, q, ue[q]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(re, Object.getOwnPropertyDescriptors(ue)) : z(Object(ue)).forEach(function(q) {
        Object.defineProperty(re, q, Object.getOwnPropertyDescriptor(ue, q));
      });
    }
    return re;
  }
  function O(re, ie, ue) {
    return ie = B(ie), ie in re ? Object.defineProperty(re, ie, { value: ue, enumerable: !0, configurable: !0, writable: !0 }) : re[ie] = ue, re;
  }
  function F(re, ie) {
    if (!(re instanceof ie))
      throw new TypeError("Cannot call a class as a function");
  }
  function U(re, ie) {
    for (var ue = 0; ue < ie.length; ue++) {
      var q = ie[ue];
      q.enumerable = q.enumerable || !1, q.configurable = !0, "value" in q && (q.writable = !0), Object.defineProperty(re, B(q.key), q);
    }
  }
  function W(re, ie, ue) {
    return ie && U(re.prototype, ie), Object.defineProperty(re, "prototype", { writable: !1 }), re;
  }
  function B(re) {
    var ie = K(re, "string");
    return typeof ie == "symbol" ? ie : String(ie);
  }
  function K(re, ie) {
    if (typeof re != "object" || re === null)
      return re;
    var ue = re[Symbol.toPrimitive];
    if (ue !== void 0) {
      var q = ue.call(re, ie || "default");
      if (typeof q != "object")
        return q;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (ie === "string" ? String : Number)(re);
  }
  var X = require$$2, Y = X.Buffer, Q = util, J = Q.inspect, ee = J && J.custom || "inspect";
  function ae(re, ie, ue) {
    Y.prototype.copy.call(re, ie, ue);
  }
  return buffer_list = /* @__PURE__ */ function() {
    function re() {
      F(this, re), this.head = null, this.tail = null, this.length = 0;
    }
    return W(re, [{
      key: "push",
      value: function(ue) {
        var q = {
          data: ue,
          next: null
        };
        this.length > 0 ? this.tail.next = q : this.head = q, this.tail = q, ++this.length;
      }
    }, {
      key: "unshift",
      value: function(ue) {
        var q = {
          data: ue,
          next: this.head
        };
        this.length === 0 && (this.tail = q), this.head = q, ++this.length;
      }
    }, {
      key: "shift",
      value: function() {
        if (this.length !== 0) {
          var ue = this.head.data;
          return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, ue;
        }
      }
    }, {
      key: "clear",
      value: function() {
        this.head = this.tail = null, this.length = 0;
      }
    }, {
      key: "join",
      value: function(ue) {
        if (this.length === 0)
          return "";
        for (var q = this.head, ne = "" + q.data; q = q.next; )
          ne += ue + q.data;
        return ne;
      }
    }, {
      key: "concat",
      value: function(ue) {
        if (this.length === 0)
          return Y.alloc(0);
        for (var q = Y.allocUnsafe(ue >>> 0), ne = this.head, ce = 0; ne; )
          ae(ne.data, q, ce), ce += ne.data.length, ne = ne.next;
        return q;
      }
      // Consumes a specified amount of bytes or characters from the buffered data.
    }, {
      key: "consume",
      value: function(ue, q) {
        var ne;
        return ue < this.head.data.length ? (ne = this.head.data.slice(0, ue), this.head.data = this.head.data.slice(ue)) : ue === this.head.data.length ? ne = this.shift() : ne = q ? this._getString(ue) : this._getBuffer(ue), ne;
      }
    }, {
      key: "first",
      value: function() {
        return this.head.data;
      }
      // Consumes a specified amount of characters from the buffered data.
    }, {
      key: "_getString",
      value: function(ue) {
        var q = this.head, ne = 1, ce = q.data;
        for (ue -= ce.length; q = q.next; ) {
          var he = q.data, we = ue > he.length ? he.length : ue;
          if (we === he.length ? ce += he : ce += he.slice(0, ue), ue -= we, ue === 0) {
            we === he.length ? (++ne, q.next ? this.head = q.next : this.head = this.tail = null) : (this.head = q, q.data = he.slice(we));
            break;
          }
          ++ne;
        }
        return this.length -= ne, ce;
      }
      // Consumes a specified amount of bytes from the buffered data.
    }, {
      key: "_getBuffer",
      value: function(ue) {
        var q = Y.allocUnsafe(ue), ne = this.head, ce = 1;
        for (ne.data.copy(q), ue -= ne.data.length; ne = ne.next; ) {
          var he = ne.data, we = ue > he.length ? he.length : ue;
          if (he.copy(q, q.length - ue, 0, we), ue -= we, ue === 0) {
            we === he.length ? (++ce, ne.next ? this.head = ne.next : this.head = this.tail = null) : (this.head = ne, ne.data = he.slice(we));
            break;
          }
          ++ce;
        }
        return this.length -= ce, q;
      }
      // Make sure the linked list only shows the minimal necessary information.
    }, {
      key: ee,
      value: function(ue, q) {
        return J(this, D(D({}, q), {}, {
          // Only inspect one level.
          depth: 0,
          // It should not recurse.
          customInspect: !1
        }));
      }
    }]), re;
  }(), buffer_list;
}
function destroy(z, D) {
  var O = this, F = this._readableState && this._readableState.destroyed, U = this._writableState && this._writableState.destroyed;
  return F || U ? (D ? D(z) : z && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = !0, process$1.nextTick(emitErrorNT, this, z)) : process$1.nextTick(emitErrorNT, this, z)), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this._writableState.destroyed = !0), this._destroy(z || null, function(W) {
    !D && W ? O._writableState ? O._writableState.errorEmitted ? process$1.nextTick(emitCloseNT, O) : (O._writableState.errorEmitted = !0, process$1.nextTick(emitErrorAndCloseNT, O, W)) : process$1.nextTick(emitErrorAndCloseNT, O, W) : D ? (process$1.nextTick(emitCloseNT, O), D(W)) : process$1.nextTick(emitCloseNT, O);
  }), this);
}
function emitErrorAndCloseNT(z, D) {
  emitErrorNT(z, D), emitCloseNT(z);
}
function emitCloseNT(z) {
  z._writableState && !z._writableState.emitClose || z._readableState && !z._readableState.emitClose || z.emit("close");
}
function undestroy() {
  this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending = !1, this._writableState.finalCalled = !1, this._writableState.prefinished = !1, this._writableState.finished = !1, this._writableState.errorEmitted = !1);
}
function emitErrorNT(z, D) {
  z.emit("error", D);
}
function errorOrDestroy(z, D) {
  var O = z._readableState, F = z._writableState;
  O && O.autoDestroy || F && F.autoDestroy ? z.destroy(D) : z.emit("error", D);
}
var destroy_1 = {
  destroy,
  undestroy,
  errorOrDestroy
}, errorsBrowser = {};
function _inheritsLoose(z, D) {
  z.prototype = Object.create(D.prototype), z.prototype.constructor = z, z.__proto__ = D;
}
var codes = {};
function createErrorType(z, D, O) {
  O || (O = Error);
  function F(W, B, K) {
    return typeof D == "string" ? D : D(W, B, K);
  }
  var U = /* @__PURE__ */ function(W) {
    _inheritsLoose(B, W);
    function B(K, X, Y) {
      return W.call(this, F(K, X, Y)) || this;
    }
    return B;
  }(O);
  U.prototype.name = O.name, U.prototype.code = z, codes[z] = U;
}
function oneOf(z, D) {
  if (Array.isArray(z)) {
    var O = z.length;
    return z = z.map(function(F) {
      return String(F);
    }), O > 2 ? "one of ".concat(D, " ").concat(z.slice(0, O - 1).join(", "), ", or ") + z[O - 1] : O === 2 ? "one of ".concat(D, " ").concat(z[0], " or ").concat(z[1]) : "of ".concat(D, " ").concat(z[0]);
  } else
    return "of ".concat(D, " ").concat(String(z));
}
function startsWith(z, D, O) {
  return z.substr(0, D.length) === D;
}
function endsWith(z, D, O) {
  return (O === void 0 || O > z.length) && (O = z.length), z.substring(O - D.length, O) === D;
}
function includes(z, D, O) {
  return typeof O != "number" && (O = 0), O + D.length > z.length ? !1 : z.indexOf(D, O) !== -1;
}
createErrorType("ERR_INVALID_OPT_VALUE", function(z, D) {
  return 'The value "' + D + '" is invalid for option "' + z + '"';
}, TypeError);
createErrorType("ERR_INVALID_ARG_TYPE", function(z, D, O) {
  var F;
  typeof D == "string" && startsWith(D, "not ") ? (F = "must not be", D = D.replace(/^not /, "")) : F = "must be";
  var U;
  if (endsWith(z, " argument"))
    U = "The ".concat(z, " ").concat(F, " ").concat(oneOf(D, "type"));
  else {
    var W = includes(z, ".") ? "property" : "argument";
    U = 'The "'.concat(z, '" ').concat(W, " ").concat(F, " ").concat(oneOf(D, "type"));
  }
  return U += ". Received type ".concat(typeof O), U;
}, TypeError);
createErrorType("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
createErrorType("ERR_METHOD_NOT_IMPLEMENTED", function(z) {
  return "The " + z + " method is not implemented";
});
createErrorType("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
createErrorType("ERR_STREAM_DESTROYED", function(z) {
  return "Cannot call " + z + " after a stream was destroyed";
});
createErrorType("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
createErrorType("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
createErrorType("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
createErrorType("ERR_UNKNOWN_ENCODING", function(z) {
  return "Unknown encoding: " + z;
}, TypeError);
createErrorType("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
errorsBrowser.codes = codes;
var ERR_INVALID_OPT_VALUE = errorsBrowser.codes.ERR_INVALID_OPT_VALUE;
function highWaterMarkFrom(z, D, O) {
  return z.highWaterMark != null ? z.highWaterMark : D ? z[O] : null;
}
function getHighWaterMark(z, D, O, F) {
  var U = highWaterMarkFrom(D, F, O);
  if (U != null) {
    if (!(isFinite(U) && Math.floor(U) === U) || U < 0) {
      var W = F ? O : "highWaterMark";
      throw new ERR_INVALID_OPT_VALUE(W, U);
    }
    return Math.floor(U);
  }
  return z.objectMode ? 16 : 16 * 1024;
}
var state = {
  getHighWaterMark
}, browser$1 = deprecate;
function deprecate(z, D) {
  if (config("noDeprecation"))
    return z;
  var O = !1;
  function F() {
    if (!O) {
      if (config("throwDeprecation"))
        throw new Error(D);
      config("traceDeprecation") ? console.trace(D) : console.warn(D), O = !0;
    }
    return z.apply(this, arguments);
  }
  return F;
}
function config(z) {
  try {
    if (!commonjsGlobal.localStorage)
      return !1;
  } catch {
    return !1;
  }
  var D = commonjsGlobal.localStorage[z];
  return D == null ? !1 : String(D).toLowerCase() === "true";
}
var _stream_writable, hasRequired_stream_writable;
function require_stream_writable() {
  if (hasRequired_stream_writable)
    return _stream_writable;
  hasRequired_stream_writable = 1, _stream_writable = be;
  function z(Te) {
    var Ce = this;
    this.next = null, this.entry = null, this.finish = function() {
      Oe(Ce, Te);
    };
  }
  var D;
  be.WritableState = me;
  var O = {
    deprecate: browser$1
  }, F = streamBrowser, U = require$$2.Buffer, W = (typeof commonjsGlobal < "u" ? commonjsGlobal : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function B(Te) {
    return U.from(Te);
  }
  function K(Te) {
    return U.isBuffer(Te) || Te instanceof W;
  }
  var X = destroy_1, Y = state, Q = Y.getHighWaterMark, J = errorsBrowser.codes, ee = J.ERR_INVALID_ARG_TYPE, ae = J.ERR_METHOD_NOT_IMPLEMENTED, re = J.ERR_MULTIPLE_CALLBACK, ie = J.ERR_STREAM_CANNOT_PIPE, ue = J.ERR_STREAM_DESTROYED, q = J.ERR_STREAM_NULL_VALUES, ne = J.ERR_STREAM_WRITE_AFTER_END, ce = J.ERR_UNKNOWN_ENCODING, he = X.errorOrDestroy;
  inherits_browserExports(be, F);
  function we() {
  }
  function me(Te, Ce, te) {
    D = D || require_stream_duplex(), Te = Te || {}, typeof te != "boolean" && (te = Ce instanceof D), this.objectMode = !!Te.objectMode, te && (this.objectMode = this.objectMode || !!Te.writableObjectMode), this.highWaterMark = Q(this, Te, "writableHighWaterMark", te), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
    var le = Te.decodeStrings === !1;
    this.decodeStrings = !le, this.defaultEncoding = Te.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function(ge) {
      Be(Ce, ge);
    }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.emitClose = Te.emitClose !== !1, this.autoDestroy = !!Te.autoDestroy, this.bufferedRequestCount = 0, this.corkedRequestsFree = new z(this);
  }
  me.prototype.getBuffer = function() {
    for (var Ce = this.bufferedRequest, te = []; Ce; )
      te.push(Ce), Ce = Ce.next;
    return te;
  }, function() {
    try {
      Object.defineProperty(me.prototype, "buffer", {
        get: O.deprecate(function() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
      });
    } catch {
    }
  }();
  var de;
  typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (de = Function.prototype[Symbol.hasInstance], Object.defineProperty(be, Symbol.hasInstance, {
    value: function(Ce) {
      return de.call(this, Ce) ? !0 : this !== be ? !1 : Ce && Ce._writableState instanceof me;
    }
  })) : de = function(Ce) {
    return Ce instanceof this;
  };
  function be(Te) {
    D = D || require_stream_duplex();
    var Ce = this instanceof D;
    if (!Ce && !de.call(be, this))
      return new be(Te);
    this._writableState = new me(Te, this, Ce), this.writable = !0, Te && (typeof Te.write == "function" && (this._write = Te.write), typeof Te.writev == "function" && (this._writev = Te.writev), typeof Te.destroy == "function" && (this._destroy = Te.destroy), typeof Te.final == "function" && (this._final = Te.final)), F.call(this);
  }
  be.prototype.pipe = function() {
    he(this, new ie());
  };
  function _e(Te, Ce) {
    var te = new ne();
    he(Te, te), process$1.nextTick(Ce, te);
  }
  function Me(Te, Ce, te, le) {
    var ge;
    return te === null ? ge = new q() : typeof te != "string" && !Ce.objectMode && (ge = new ee("chunk", ["string", "Buffer"], te)), ge ? (he(Te, ge), process$1.nextTick(le, ge), !1) : !0;
  }
  be.prototype.write = function(Te, Ce, te) {
    var le = this._writableState, ge = !1, pe = !le.objectMode && K(Te);
    return pe && !U.isBuffer(Te) && (Te = B(Te)), typeof Ce == "function" && (te = Ce, Ce = null), pe ? Ce = "buffer" : Ce || (Ce = le.defaultEncoding), typeof te != "function" && (te = we), le.ending ? _e(this, te) : (pe || Me(this, le, Te, te)) && (le.pendingcb++, ge = Ee(this, le, pe, Te, Ce, te)), ge;
  }, be.prototype.cork = function() {
    this._writableState.corked++;
  }, be.prototype.uncork = function() {
    var Te = this._writableState;
    Te.corked && (Te.corked--, !Te.writing && !Te.corked && !Te.bufferProcessing && Te.bufferedRequest && ze(this, Te));
  }, be.prototype.setDefaultEncoding = function(Ce) {
    if (typeof Ce == "string" && (Ce = Ce.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((Ce + "").toLowerCase()) > -1))
      throw new ce(Ce);
    return this._writableState.defaultEncoding = Ce, this;
  }, Object.defineProperty(be.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState && this._writableState.getBuffer();
    }
  });
  function Ne(Te, Ce, te) {
    return !Te.objectMode && Te.decodeStrings !== !1 && typeof Ce == "string" && (Ce = U.from(Ce, te)), Ce;
  }
  Object.defineProperty(be.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function Ee(Te, Ce, te, le, ge, pe) {
    if (!te) {
      var fe = Ne(Ce, le, ge);
      le !== fe && (te = !0, ge = "buffer", le = fe);
    }
    var Se = Ce.objectMode ? 1 : le.length;
    Ce.length += Se;
    var Pe = Ce.length < Ce.highWaterMark;
    if (Pe || (Ce.needDrain = !0), Ce.writing || Ce.corked) {
      var Ge = Ce.lastBufferedRequest;
      Ce.lastBufferedRequest = {
        chunk: le,
        encoding: ge,
        isBuf: te,
        callback: pe,
        next: null
      }, Ge ? Ge.next = Ce.lastBufferedRequest : Ce.bufferedRequest = Ce.lastBufferedRequest, Ce.bufferedRequestCount += 1;
    } else
      $e(Te, Ce, !1, Se, le, ge, pe);
    return Pe;
  }
  function $e(Te, Ce, te, le, ge, pe, fe) {
    Ce.writelen = le, Ce.writecb = fe, Ce.writing = !0, Ce.sync = !0, Ce.destroyed ? Ce.onwrite(new ue("write")) : te ? Te._writev(ge, Ce.onwrite) : Te._write(ge, pe, Ce.onwrite), Ce.sync = !1;
  }
  function De(Te, Ce, te, le, ge) {
    --Ce.pendingcb, te ? (process$1.nextTick(ge, le), process$1.nextTick(ve, Te, Ce), Te._writableState.errorEmitted = !0, he(Te, le)) : (ge(le), Te._writableState.errorEmitted = !0, he(Te, le), ve(Te, Ce));
  }
  function Fe(Te) {
    Te.writing = !1, Te.writecb = null, Te.length -= Te.writelen, Te.writelen = 0;
  }
  function Be(Te, Ce) {
    var te = Te._writableState, le = te.sync, ge = te.writecb;
    if (typeof ge != "function")
      throw new re();
    if (Fe(te), Ce)
      De(Te, te, le, Ce, ge);
    else {
      var pe = ke(te) || Te.destroyed;
      !pe && !te.corked && !te.bufferProcessing && te.bufferedRequest && ze(Te, te), le ? process$1.nextTick(We, Te, te, pe, ge) : We(Te, te, pe, ge);
    }
  }
  function We(Te, Ce, te, le) {
    te || Ve(Te, Ce), Ce.pendingcb--, le(), ve(Te, Ce);
  }
  function Ve(Te, Ce) {
    Ce.length === 0 && Ce.needDrain && (Ce.needDrain = !1, Te.emit("drain"));
  }
  function ze(Te, Ce) {
    Ce.bufferProcessing = !0;
    var te = Ce.bufferedRequest;
    if (Te._writev && te && te.next) {
      var le = Ce.bufferedRequestCount, ge = new Array(le), pe = Ce.corkedRequestsFree;
      pe.entry = te;
      for (var fe = 0, Se = !0; te; )
        ge[fe] = te, te.isBuf || (Se = !1), te = te.next, fe += 1;
      ge.allBuffers = Se, $e(Te, Ce, !0, Ce.length, ge, "", pe.finish), Ce.pendingcb++, Ce.lastBufferedRequest = null, pe.next ? (Ce.corkedRequestsFree = pe.next, pe.next = null) : Ce.corkedRequestsFree = new z(Ce), Ce.bufferedRequestCount = 0;
    } else {
      for (; te; ) {
        var Pe = te.chunk, Ge = te.encoding, Qe = te.callback, et = Ce.objectMode ? 1 : Pe.length;
        if ($e(Te, Ce, !1, et, Pe, Ge, Qe), te = te.next, Ce.bufferedRequestCount--, Ce.writing)
          break;
      }
      te === null && (Ce.lastBufferedRequest = null);
    }
    Ce.bufferedRequest = te, Ce.bufferProcessing = !1;
  }
  be.prototype._write = function(Te, Ce, te) {
    te(new ae("_write()"));
  }, be.prototype._writev = null, be.prototype.end = function(Te, Ce, te) {
    var le = this._writableState;
    return typeof Te == "function" ? (te = Te, Te = null, Ce = null) : typeof Ce == "function" && (te = Ce, Ce = null), Te != null && this.write(Te, Ce), le.corked && (le.corked = 1, this.uncork()), le.ending || xe(this, le, te), this;
  }, Object.defineProperty(be.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.length;
    }
  });
  function ke(Te) {
    return Te.ending && Te.length === 0 && Te.bufferedRequest === null && !Te.finished && !Te.writing;
  }
  function je(Te, Ce) {
    Te._final(function(te) {
      Ce.pendingcb--, te && he(Te, te), Ce.prefinished = !0, Te.emit("prefinish"), ve(Te, Ce);
    });
  }
  function Ie(Te, Ce) {
    !Ce.prefinished && !Ce.finalCalled && (typeof Te._final == "function" && !Ce.destroyed ? (Ce.pendingcb++, Ce.finalCalled = !0, process$1.nextTick(je, Te, Ce)) : (Ce.prefinished = !0, Te.emit("prefinish")));
  }
  function ve(Te, Ce) {
    var te = ke(Ce);
    if (te && (Ie(Te, Ce), Ce.pendingcb === 0 && (Ce.finished = !0, Te.emit("finish"), Ce.autoDestroy))) {
      var le = Te._readableState;
      (!le || le.autoDestroy && le.endEmitted) && Te.destroy();
    }
    return te;
  }
  function xe(Te, Ce, te) {
    Ce.ending = !0, ve(Te, Ce), te && (Ce.finished ? process$1.nextTick(te) : Te.once("finish", te)), Ce.ended = !0, Te.writable = !1;
  }
  function Oe(Te, Ce, te) {
    var le = Te.entry;
    for (Te.entry = null; le; ) {
      var ge = le.callback;
      Ce.pendingcb--, ge(te), le = le.next;
    }
    Ce.corkedRequestsFree.next = Te;
  }
  return Object.defineProperty(be.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState === void 0 ? !1 : this._writableState.destroyed;
    },
    set: function(Ce) {
      this._writableState && (this._writableState.destroyed = Ce);
    }
  }), be.prototype.destroy = X.destroy, be.prototype._undestroy = X.undestroy, be.prototype._destroy = function(Te, Ce) {
    Ce(Te);
  }, _stream_writable;
}
var _stream_duplex, hasRequired_stream_duplex;
function require_stream_duplex() {
  if (hasRequired_stream_duplex)
    return _stream_duplex;
  hasRequired_stream_duplex = 1;
  var z = Object.keys || function(Y) {
    var Q = [];
    for (var J in Y)
      Q.push(J);
    return Q;
  };
  _stream_duplex = B;
  var D = require_stream_readable(), O = require_stream_writable();
  inherits_browserExports(B, D);
  for (var F = z(O.prototype), U = 0; U < F.length; U++) {
    var W = F[U];
    B.prototype[W] || (B.prototype[W] = O.prototype[W]);
  }
  function B(Y) {
    if (!(this instanceof B))
      return new B(Y);
    D.call(this, Y), O.call(this, Y), this.allowHalfOpen = !0, Y && (Y.readable === !1 && (this.readable = !1), Y.writable === !1 && (this.writable = !1), Y.allowHalfOpen === !1 && (this.allowHalfOpen = !1, this.once("end", K)));
  }
  Object.defineProperty(B.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  }), Object.defineProperty(B.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState && this._writableState.getBuffer();
    }
  }), Object.defineProperty(B.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.length;
    }
  });
  function K() {
    this._writableState.ended || process$1.nextTick(X, this);
  }
  function X(Y) {
    Y.end();
  }
  return Object.defineProperty(B.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState === void 0 || this._writableState === void 0 ? !1 : this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function(Q) {
      this._readableState === void 0 || this._writableState === void 0 || (this._readableState.destroyed = Q, this._writableState.destroyed = Q);
    }
  }), _stream_duplex;
}
var string_decoder = {}, safeBuffer = { exports: {} };
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
var hasRequiredSafeBuffer;
function requireSafeBuffer() {
  return hasRequiredSafeBuffer || (hasRequiredSafeBuffer = 1, function(z, D) {
    var O = require$$2, F = O.Buffer;
    function U(B, K) {
      for (var X in B)
        K[X] = B[X];
    }
    F.from && F.alloc && F.allocUnsafe && F.allocUnsafeSlow ? z.exports = O : (U(O, D), D.Buffer = W);
    function W(B, K, X) {
      return F(B, K, X);
    }
    W.prototype = Object.create(F.prototype), U(F, W), W.from = function(B, K, X) {
      if (typeof B == "number")
        throw new TypeError("Argument must not be a number");
      return F(B, K, X);
    }, W.alloc = function(B, K, X) {
      if (typeof B != "number")
        throw new TypeError("Argument must be a number");
      var Y = F(B);
      return K !== void 0 ? typeof X == "string" ? Y.fill(K, X) : Y.fill(K) : Y.fill(0), Y;
    }, W.allocUnsafe = function(B) {
      if (typeof B != "number")
        throw new TypeError("Argument must be a number");
      return F(B);
    }, W.allocUnsafeSlow = function(B) {
      if (typeof B != "number")
        throw new TypeError("Argument must be a number");
      return O.SlowBuffer(B);
    };
  }(safeBuffer, safeBuffer.exports)), safeBuffer.exports;
}
var hasRequiredString_decoder;
function requireString_decoder() {
  if (hasRequiredString_decoder)
    return string_decoder;
  hasRequiredString_decoder = 1;
  var z = requireSafeBuffer().Buffer, D = z.isEncoding || function(q) {
    switch (q = "" + q, q && q.toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
      case "raw":
        return !0;
      default:
        return !1;
    }
  };
  function O(q) {
    if (!q)
      return "utf8";
    for (var ne; ; )
      switch (q) {
        case "utf8":
        case "utf-8":
          return "utf8";
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return "utf16le";
        case "latin1":
        case "binary":
          return "latin1";
        case "base64":
        case "ascii":
        case "hex":
          return q;
        default:
          if (ne)
            return;
          q = ("" + q).toLowerCase(), ne = !0;
      }
  }
  function F(q) {
    var ne = O(q);
    if (typeof ne != "string" && (z.isEncoding === D || !D(q)))
      throw new Error("Unknown encoding: " + q);
    return ne || q;
  }
  string_decoder.StringDecoder = U;
  function U(q) {
    this.encoding = F(q);
    var ne;
    switch (this.encoding) {
      case "utf16le":
        this.text = J, this.end = ee, ne = 4;
        break;
      case "utf8":
        this.fillLast = X, ne = 4;
        break;
      case "base64":
        this.text = ae, this.end = re, ne = 3;
        break;
      default:
        this.write = ie, this.end = ue;
        return;
    }
    this.lastNeed = 0, this.lastTotal = 0, this.lastChar = z.allocUnsafe(ne);
  }
  U.prototype.write = function(q) {
    if (q.length === 0)
      return "";
    var ne, ce;
    if (this.lastNeed) {
      if (ne = this.fillLast(q), ne === void 0)
        return "";
      ce = this.lastNeed, this.lastNeed = 0;
    } else
      ce = 0;
    return ce < q.length ? ne ? ne + this.text(q, ce) : this.text(q, ce) : ne || "";
  }, U.prototype.end = Q, U.prototype.text = Y, U.prototype.fillLast = function(q) {
    if (this.lastNeed <= q.length)
      return q.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
    q.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, q.length), this.lastNeed -= q.length;
  };
  function W(q) {
    return q <= 127 ? 0 : q >> 5 === 6 ? 2 : q >> 4 === 14 ? 3 : q >> 3 === 30 ? 4 : q >> 6 === 2 ? -1 : -2;
  }
  function B(q, ne, ce) {
    var he = ne.length - 1;
    if (he < ce)
      return 0;
    var we = W(ne[he]);
    return we >= 0 ? (we > 0 && (q.lastNeed = we - 1), we) : --he < ce || we === -2 ? 0 : (we = W(ne[he]), we >= 0 ? (we > 0 && (q.lastNeed = we - 2), we) : --he < ce || we === -2 ? 0 : (we = W(ne[he]), we >= 0 ? (we > 0 && (we === 2 ? we = 0 : q.lastNeed = we - 3), we) : 0));
  }
  function K(q, ne, ce) {
    if ((ne[0] & 192) !== 128)
      return q.lastNeed = 0, "";
    if (q.lastNeed > 1 && ne.length > 1) {
      if ((ne[1] & 192) !== 128)
        return q.lastNeed = 1, "";
      if (q.lastNeed > 2 && ne.length > 2 && (ne[2] & 192) !== 128)
        return q.lastNeed = 2, "";
    }
  }
  function X(q) {
    var ne = this.lastTotal - this.lastNeed, ce = K(this, q);
    if (ce !== void 0)
      return ce;
    if (this.lastNeed <= q.length)
      return q.copy(this.lastChar, ne, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
    q.copy(this.lastChar, ne, 0, q.length), this.lastNeed -= q.length;
  }
  function Y(q, ne) {
    var ce = B(this, q, ne);
    if (!this.lastNeed)
      return q.toString("utf8", ne);
    this.lastTotal = ce;
    var he = q.length - (ce - this.lastNeed);
    return q.copy(this.lastChar, 0, he), q.toString("utf8", ne, he);
  }
  function Q(q) {
    var ne = q && q.length ? this.write(q) : "";
    return this.lastNeed ? ne + "" : ne;
  }
  function J(q, ne) {
    if ((q.length - ne) % 2 === 0) {
      var ce = q.toString("utf16le", ne);
      if (ce) {
        var he = ce.charCodeAt(ce.length - 1);
        if (he >= 55296 && he <= 56319)
          return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = q[q.length - 2], this.lastChar[1] = q[q.length - 1], ce.slice(0, -1);
      }
      return ce;
    }
    return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = q[q.length - 1], q.toString("utf16le", ne, q.length - 1);
  }
  function ee(q) {
    var ne = q && q.length ? this.write(q) : "";
    if (this.lastNeed) {
      var ce = this.lastTotal - this.lastNeed;
      return ne + this.lastChar.toString("utf16le", 0, ce);
    }
    return ne;
  }
  function ae(q, ne) {
    var ce = (q.length - ne) % 3;
    return ce === 0 ? q.toString("base64", ne) : (this.lastNeed = 3 - ce, this.lastTotal = 3, ce === 1 ? this.lastChar[0] = q[q.length - 1] : (this.lastChar[0] = q[q.length - 2], this.lastChar[1] = q[q.length - 1]), q.toString("base64", ne, q.length - ce));
  }
  function re(q) {
    var ne = q && q.length ? this.write(q) : "";
    return this.lastNeed ? ne + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : ne;
  }
  function ie(q) {
    return q.toString(this.encoding);
  }
  function ue(q) {
    return q && q.length ? this.write(q) : "";
  }
  return string_decoder;
}
var ERR_STREAM_PREMATURE_CLOSE = errorsBrowser.codes.ERR_STREAM_PREMATURE_CLOSE;
function once$1(z) {
  var D = !1;
  return function() {
    if (!D) {
      D = !0;
      for (var O = arguments.length, F = new Array(O), U = 0; U < O; U++)
        F[U] = arguments[U];
      z.apply(this, F);
    }
  };
}
function noop$1() {
}
function isRequest$1(z) {
  return z.setHeader && typeof z.abort == "function";
}
function eos$1(z, D, O) {
  if (typeof D == "function")
    return eos$1(z, null, D);
  D || (D = {}), O = once$1(O || noop$1);
  var F = D.readable || D.readable !== !1 && z.readable, U = D.writable || D.writable !== !1 && z.writable, W = function() {
    z.writable || K();
  }, B = z._writableState && z._writableState.finished, K = function() {
    U = !1, B = !0, F || O.call(z);
  }, X = z._readableState && z._readableState.endEmitted, Y = function() {
    F = !1, X = !0, U || O.call(z);
  }, Q = function(re) {
    O.call(z, re);
  }, J = function() {
    var re;
    if (F && !X)
      return (!z._readableState || !z._readableState.ended) && (re = new ERR_STREAM_PREMATURE_CLOSE()), O.call(z, re);
    if (U && !B)
      return (!z._writableState || !z._writableState.ended) && (re = new ERR_STREAM_PREMATURE_CLOSE()), O.call(z, re);
  }, ee = function() {
    z.req.on("finish", K);
  };
  return isRequest$1(z) ? (z.on("complete", K), z.on("abort", J), z.req ? ee() : z.on("request", ee)) : U && !z._writableState && (z.on("end", W), z.on("close", W)), z.on("end", Y), z.on("finish", K), D.error !== !1 && z.on("error", Q), z.on("close", J), function() {
    z.removeListener("complete", K), z.removeListener("abort", J), z.removeListener("request", ee), z.req && z.req.removeListener("finish", K), z.removeListener("end", W), z.removeListener("close", W), z.removeListener("finish", K), z.removeListener("end", Y), z.removeListener("error", Q), z.removeListener("close", J);
  };
}
var endOfStream = eos$1, async_iterator, hasRequiredAsync_iterator;
function requireAsync_iterator() {
  if (hasRequiredAsync_iterator)
    return async_iterator;
  hasRequiredAsync_iterator = 1;
  var z;
  function D(ce, he, we) {
    return he = O(he), he in ce ? Object.defineProperty(ce, he, { value: we, enumerable: !0, configurable: !0, writable: !0 }) : ce[he] = we, ce;
  }
  function O(ce) {
    var he = F(ce, "string");
    return typeof he == "symbol" ? he : String(he);
  }
  function F(ce, he) {
    if (typeof ce != "object" || ce === null)
      return ce;
    var we = ce[Symbol.toPrimitive];
    if (we !== void 0) {
      var me = we.call(ce, he || "default");
      if (typeof me != "object")
        return me;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (he === "string" ? String : Number)(ce);
  }
  var U = endOfStream, W = Symbol("lastResolve"), B = Symbol("lastReject"), K = Symbol("error"), X = Symbol("ended"), Y = Symbol("lastPromise"), Q = Symbol("handlePromise"), J = Symbol("stream");
  function ee(ce, he) {
    return {
      value: ce,
      done: he
    };
  }
  function ae(ce) {
    var he = ce[W];
    if (he !== null) {
      var we = ce[J].read();
      we !== null && (ce[Y] = null, ce[W] = null, ce[B] = null, he(ee(we, !1)));
    }
  }
  function re(ce) {
    process$1.nextTick(ae, ce);
  }
  function ie(ce, he) {
    return function(we, me) {
      ce.then(function() {
        if (he[X]) {
          we(ee(void 0, !0));
          return;
        }
        he[Q](we, me);
      }, me);
    };
  }
  var ue = Object.getPrototypeOf(function() {
  }), q = Object.setPrototypeOf((z = {
    get stream() {
      return this[J];
    },
    next: function() {
      var he = this, we = this[K];
      if (we !== null)
        return Promise.reject(we);
      if (this[X])
        return Promise.resolve(ee(void 0, !0));
      if (this[J].destroyed)
        return new Promise(function(_e, Me) {
          process$1.nextTick(function() {
            he[K] ? Me(he[K]) : _e(ee(void 0, !0));
          });
        });
      var me = this[Y], de;
      if (me)
        de = new Promise(ie(me, this));
      else {
        var be = this[J].read();
        if (be !== null)
          return Promise.resolve(ee(be, !1));
        de = new Promise(this[Q]);
      }
      return this[Y] = de, de;
    }
  }, D(z, Symbol.asyncIterator, function() {
    return this;
  }), D(z, "return", function() {
    var he = this;
    return new Promise(function(we, me) {
      he[J].destroy(null, function(de) {
        if (de) {
          me(de);
          return;
        }
        we(ee(void 0, !0));
      });
    });
  }), z), ue), ne = function(he) {
    var we, me = Object.create(q, (we = {}, D(we, J, {
      value: he,
      writable: !0
    }), D(we, W, {
      value: null,
      writable: !0
    }), D(we, B, {
      value: null,
      writable: !0
    }), D(we, K, {
      value: null,
      writable: !0
    }), D(we, X, {
      value: he._readableState.endEmitted,
      writable: !0
    }), D(we, Q, {
      value: function(be, _e) {
        var Me = me[J].read();
        Me ? (me[Y] = null, me[W] = null, me[B] = null, be(ee(Me, !1))) : (me[W] = be, me[B] = _e);
      },
      writable: !0
    }), we));
    return me[Y] = null, U(he, function(de) {
      if (de && de.code !== "ERR_STREAM_PREMATURE_CLOSE") {
        var be = me[B];
        be !== null && (me[Y] = null, me[W] = null, me[B] = null, be(de)), me[K] = de;
        return;
      }
      var _e = me[W];
      _e !== null && (me[Y] = null, me[W] = null, me[B] = null, _e(ee(void 0, !0))), me[X] = !0;
    }), he.on("readable", re.bind(null, me)), me;
  };
  return async_iterator = ne, async_iterator;
}
var fromBrowser, hasRequiredFromBrowser;
function requireFromBrowser() {
  return hasRequiredFromBrowser || (hasRequiredFromBrowser = 1, fromBrowser = function() {
    throw new Error("Readable.from is not available in the browser");
  }), fromBrowser;
}
var _stream_readable, hasRequired_stream_readable;
function require_stream_readable() {
  if (hasRequired_stream_readable)
    return _stream_readable;
  hasRequired_stream_readable = 1, _stream_readable = _e;
  var z;
  _e.ReadableState = be, eventsExports.EventEmitter;
  var D = function(fe, Se) {
    return fe.listeners(Se).length;
  }, O = streamBrowser, F = require$$2.Buffer, U = (typeof commonjsGlobal < "u" ? commonjsGlobal : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function W(pe) {
    return F.from(pe);
  }
  function B(pe) {
    return F.isBuffer(pe) || pe instanceof U;
  }
  var K = util, X;
  K && K.debuglog ? X = K.debuglog("stream") : X = function() {
  };
  var Y = requireBuffer_list(), Q = destroy_1, J = state, ee = J.getHighWaterMark, ae = errorsBrowser.codes, re = ae.ERR_INVALID_ARG_TYPE, ie = ae.ERR_STREAM_PUSH_AFTER_EOF, ue = ae.ERR_METHOD_NOT_IMPLEMENTED, q = ae.ERR_STREAM_UNSHIFT_AFTER_END_EVENT, ne, ce, he;
  inherits_browserExports(_e, O);
  var we = Q.errorOrDestroy, me = ["error", "close", "destroy", "pause", "resume"];
  function de(pe, fe, Se) {
    if (typeof pe.prependListener == "function")
      return pe.prependListener(fe, Se);
    !pe._events || !pe._events[fe] ? pe.on(fe, Se) : Array.isArray(pe._events[fe]) ? pe._events[fe].unshift(Se) : pe._events[fe] = [Se, pe._events[fe]];
  }
  function be(pe, fe, Se) {
    z = z || require_stream_duplex(), pe = pe || {}, typeof Se != "boolean" && (Se = fe instanceof z), this.objectMode = !!pe.objectMode, Se && (this.objectMode = this.objectMode || !!pe.readableObjectMode), this.highWaterMark = ee(this, pe, "readableHighWaterMark", Se), this.buffer = new Y(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.paused = !0, this.emitClose = pe.emitClose !== !1, this.autoDestroy = !!pe.autoDestroy, this.destroyed = !1, this.defaultEncoding = pe.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, pe.encoding && (ne || (ne = requireString_decoder().StringDecoder), this.decoder = new ne(pe.encoding), this.encoding = pe.encoding);
  }
  function _e(pe) {
    if (z = z || require_stream_duplex(), !(this instanceof _e))
      return new _e(pe);
    var fe = this instanceof z;
    this._readableState = new be(pe, this, fe), this.readable = !0, pe && (typeof pe.read == "function" && (this._read = pe.read), typeof pe.destroy == "function" && (this._destroy = pe.destroy)), O.call(this);
  }
  Object.defineProperty(_e.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState === void 0 ? !1 : this._readableState.destroyed;
    },
    set: function(fe) {
      this._readableState && (this._readableState.destroyed = fe);
    }
  }), _e.prototype.destroy = Q.destroy, _e.prototype._undestroy = Q.undestroy, _e.prototype._destroy = function(pe, fe) {
    fe(pe);
  }, _e.prototype.push = function(pe, fe) {
    var Se = this._readableState, Pe;
    return Se.objectMode ? Pe = !0 : typeof pe == "string" && (fe = fe || Se.defaultEncoding, fe !== Se.encoding && (pe = F.from(pe, fe), fe = ""), Pe = !0), Me(this, pe, fe, !1, Pe);
  }, _e.prototype.unshift = function(pe) {
    return Me(this, pe, null, !0, !1);
  };
  function Me(pe, fe, Se, Pe, Ge) {
    X("readableAddChunk", fe);
    var Qe = pe._readableState;
    if (fe === null)
      Qe.reading = !1, Be(pe, Qe);
    else {
      var et;
      if (Ge || (et = Ee(Qe, fe)), et)
        we(pe, et);
      else if (Qe.objectMode || fe && fe.length > 0)
        if (typeof fe != "string" && !Qe.objectMode && Object.getPrototypeOf(fe) !== F.prototype && (fe = W(fe)), Pe)
          Qe.endEmitted ? we(pe, new q()) : Ne(pe, Qe, fe, !0);
        else if (Qe.ended)
          we(pe, new ie());
        else {
          if (Qe.destroyed)
            return !1;
          Qe.reading = !1, Qe.decoder && !Se ? (fe = Qe.decoder.write(fe), Qe.objectMode || fe.length !== 0 ? Ne(pe, Qe, fe, !1) : ze(pe, Qe)) : Ne(pe, Qe, fe, !1);
        }
      else
        Pe || (Qe.reading = !1, ze(pe, Qe));
    }
    return !Qe.ended && (Qe.length < Qe.highWaterMark || Qe.length === 0);
  }
  function Ne(pe, fe, Se, Pe) {
    fe.flowing && fe.length === 0 && !fe.sync ? (fe.awaitDrain = 0, pe.emit("data", Se)) : (fe.length += fe.objectMode ? 1 : Se.length, Pe ? fe.buffer.unshift(Se) : fe.buffer.push(Se), fe.needReadable && We(pe)), ze(pe, fe);
  }
  function Ee(pe, fe) {
    var Se;
    return !B(fe) && typeof fe != "string" && fe !== void 0 && !pe.objectMode && (Se = new re("chunk", ["string", "Buffer", "Uint8Array"], fe)), Se;
  }
  _e.prototype.isPaused = function() {
    return this._readableState.flowing === !1;
  }, _e.prototype.setEncoding = function(pe) {
    ne || (ne = requireString_decoder().StringDecoder);
    var fe = new ne(pe);
    this._readableState.decoder = fe, this._readableState.encoding = this._readableState.decoder.encoding;
    for (var Se = this._readableState.buffer.head, Pe = ""; Se !== null; )
      Pe += fe.write(Se.data), Se = Se.next;
    return this._readableState.buffer.clear(), Pe !== "" && this._readableState.buffer.push(Pe), this._readableState.length = Pe.length, this;
  };
  var $e = 1073741824;
  function De(pe) {
    return pe >= $e ? pe = $e : (pe--, pe |= pe >>> 1, pe |= pe >>> 2, pe |= pe >>> 4, pe |= pe >>> 8, pe |= pe >>> 16, pe++), pe;
  }
  function Fe(pe, fe) {
    return pe <= 0 || fe.length === 0 && fe.ended ? 0 : fe.objectMode ? 1 : pe !== pe ? fe.flowing && fe.length ? fe.buffer.head.data.length : fe.length : (pe > fe.highWaterMark && (fe.highWaterMark = De(pe)), pe <= fe.length ? pe : fe.ended ? fe.length : (fe.needReadable = !0, 0));
  }
  _e.prototype.read = function(pe) {
    X("read", pe), pe = parseInt(pe, 10);
    var fe = this._readableState, Se = pe;
    if (pe !== 0 && (fe.emittedReadable = !1), pe === 0 && fe.needReadable && ((fe.highWaterMark !== 0 ? fe.length >= fe.highWaterMark : fe.length > 0) || fe.ended))
      return X("read: emitReadable", fe.length, fe.ended), fe.length === 0 && fe.ended ? te(this) : We(this), null;
    if (pe = Fe(pe, fe), pe === 0 && fe.ended)
      return fe.length === 0 && te(this), null;
    var Pe = fe.needReadable;
    X("need readable", Pe), (fe.length === 0 || fe.length - pe < fe.highWaterMark) && (Pe = !0, X("length less than watermark", Pe)), fe.ended || fe.reading ? (Pe = !1, X("reading or ended", Pe)) : Pe && (X("do read"), fe.reading = !0, fe.sync = !0, fe.length === 0 && (fe.needReadable = !0), this._read(fe.highWaterMark), fe.sync = !1, fe.reading || (pe = Fe(Se, fe)));
    var Ge;
    return pe > 0 ? Ge = Ce(pe, fe) : Ge = null, Ge === null ? (fe.needReadable = fe.length <= fe.highWaterMark, pe = 0) : (fe.length -= pe, fe.awaitDrain = 0), fe.length === 0 && (fe.ended || (fe.needReadable = !0), Se !== pe && fe.ended && te(this)), Ge !== null && this.emit("data", Ge), Ge;
  };
  function Be(pe, fe) {
    if (X("onEofChunk"), !fe.ended) {
      if (fe.decoder) {
        var Se = fe.decoder.end();
        Se && Se.length && (fe.buffer.push(Se), fe.length += fe.objectMode ? 1 : Se.length);
      }
      fe.ended = !0, fe.sync ? We(pe) : (fe.needReadable = !1, fe.emittedReadable || (fe.emittedReadable = !0, Ve(pe)));
    }
  }
  function We(pe) {
    var fe = pe._readableState;
    X("emitReadable", fe.needReadable, fe.emittedReadable), fe.needReadable = !1, fe.emittedReadable || (X("emitReadable", fe.flowing), fe.emittedReadable = !0, process$1.nextTick(Ve, pe));
  }
  function Ve(pe) {
    var fe = pe._readableState;
    X("emitReadable_", fe.destroyed, fe.length, fe.ended), !fe.destroyed && (fe.length || fe.ended) && (pe.emit("readable"), fe.emittedReadable = !1), fe.needReadable = !fe.flowing && !fe.ended && fe.length <= fe.highWaterMark, Te(pe);
  }
  function ze(pe, fe) {
    fe.readingMore || (fe.readingMore = !0, process$1.nextTick(ke, pe, fe));
  }
  function ke(pe, fe) {
    for (; !fe.reading && !fe.ended && (fe.length < fe.highWaterMark || fe.flowing && fe.length === 0); ) {
      var Se = fe.length;
      if (X("maybeReadMore read 0"), pe.read(0), Se === fe.length)
        break;
    }
    fe.readingMore = !1;
  }
  _e.prototype._read = function(pe) {
    we(this, new ue("_read()"));
  }, _e.prototype.pipe = function(pe, fe) {
    var Se = this, Pe = this._readableState;
    switch (Pe.pipesCount) {
      case 0:
        Pe.pipes = pe;
        break;
      case 1:
        Pe.pipes = [Pe.pipes, pe];
        break;
      default:
        Pe.pipes.push(pe);
        break;
    }
    Pe.pipesCount += 1, X("pipe count=%d opts=%j", Pe.pipesCount, fe);
    var Ge = (!fe || fe.end !== !1) && pe !== process$1.stdout && pe !== process$1.stderr, Qe = Ge ? rt : Ke;
    Pe.endEmitted ? process$1.nextTick(Qe) : Se.once("end", Qe), pe.on("unpipe", et);
    function et(tt, Je) {
      X("onunpipe"), tt === Se && Je && Je.hasUnpiped === !1 && (Je.hasUnpiped = !0, dt());
    }
    function rt() {
      X("onend"), pe.end();
    }
    var Xe = je(Se);
    pe.on("drain", Xe);
    var at = !1;
    function dt() {
      X("cleanup"), pe.removeListener("close", Ye), pe.removeListener("finish", He), pe.removeListener("drain", Xe), pe.removeListener("error", Ue), pe.removeListener("unpipe", et), Se.removeListener("end", rt), Se.removeListener("end", Ke), Se.removeListener("data", st), at = !0, Pe.awaitDrain && (!pe._writableState || pe._writableState.needDrain) && Xe();
    }
    Se.on("data", st);
    function st(tt) {
      X("ondata");
      var Je = pe.write(tt);
      X("dest.write", Je), Je === !1 && ((Pe.pipesCount === 1 && Pe.pipes === pe || Pe.pipesCount > 1 && ge(Pe.pipes, pe) !== -1) && !at && (X("false write response, pause", Pe.awaitDrain), Pe.awaitDrain++), Se.pause());
    }
    function Ue(tt) {
      X("onerror", tt), Ke(), pe.removeListener("error", Ue), D(pe, "error") === 0 && we(pe, tt);
    }
    de(pe, "error", Ue);
    function Ye() {
      pe.removeListener("finish", He), Ke();
    }
    pe.once("close", Ye);
    function He() {
      X("onfinish"), pe.removeListener("close", Ye), Ke();
    }
    pe.once("finish", He);
    function Ke() {
      X("unpipe"), Se.unpipe(pe);
    }
    return pe.emit("pipe", Se), Pe.flowing || (X("pipe resume"), Se.resume()), pe;
  };
  function je(pe) {
    return function() {
      var Se = pe._readableState;
      X("pipeOnDrain", Se.awaitDrain), Se.awaitDrain && Se.awaitDrain--, Se.awaitDrain === 0 && D(pe, "data") && (Se.flowing = !0, Te(pe));
    };
  }
  _e.prototype.unpipe = function(pe) {
    var fe = this._readableState, Se = {
      hasUnpiped: !1
    };
    if (fe.pipesCount === 0)
      return this;
    if (fe.pipesCount === 1)
      return pe && pe !== fe.pipes ? this : (pe || (pe = fe.pipes), fe.pipes = null, fe.pipesCount = 0, fe.flowing = !1, pe && pe.emit("unpipe", this, Se), this);
    if (!pe) {
      var Pe = fe.pipes, Ge = fe.pipesCount;
      fe.pipes = null, fe.pipesCount = 0, fe.flowing = !1;
      for (var Qe = 0; Qe < Ge; Qe++)
        Pe[Qe].emit("unpipe", this, {
          hasUnpiped: !1
        });
      return this;
    }
    var et = ge(fe.pipes, pe);
    return et === -1 ? this : (fe.pipes.splice(et, 1), fe.pipesCount -= 1, fe.pipesCount === 1 && (fe.pipes = fe.pipes[0]), pe.emit("unpipe", this, Se), this);
  }, _e.prototype.on = function(pe, fe) {
    var Se = O.prototype.on.call(this, pe, fe), Pe = this._readableState;
    return pe === "data" ? (Pe.readableListening = this.listenerCount("readable") > 0, Pe.flowing !== !1 && this.resume()) : pe === "readable" && !Pe.endEmitted && !Pe.readableListening && (Pe.readableListening = Pe.needReadable = !0, Pe.flowing = !1, Pe.emittedReadable = !1, X("on readable", Pe.length, Pe.reading), Pe.length ? We(this) : Pe.reading || process$1.nextTick(ve, this)), Se;
  }, _e.prototype.addListener = _e.prototype.on, _e.prototype.removeListener = function(pe, fe) {
    var Se = O.prototype.removeListener.call(this, pe, fe);
    return pe === "readable" && process$1.nextTick(Ie, this), Se;
  }, _e.prototype.removeAllListeners = function(pe) {
    var fe = O.prototype.removeAllListeners.apply(this, arguments);
    return (pe === "readable" || pe === void 0) && process$1.nextTick(Ie, this), fe;
  };
  function Ie(pe) {
    var fe = pe._readableState;
    fe.readableListening = pe.listenerCount("readable") > 0, fe.resumeScheduled && !fe.paused ? fe.flowing = !0 : pe.listenerCount("data") > 0 && pe.resume();
  }
  function ve(pe) {
    X("readable nexttick read 0"), pe.read(0);
  }
  _e.prototype.resume = function() {
    var pe = this._readableState;
    return pe.flowing || (X("resume"), pe.flowing = !pe.readableListening, xe(this, pe)), pe.paused = !1, this;
  };
  function xe(pe, fe) {
    fe.resumeScheduled || (fe.resumeScheduled = !0, process$1.nextTick(Oe, pe, fe));
  }
  function Oe(pe, fe) {
    X("resume", fe.reading), fe.reading || pe.read(0), fe.resumeScheduled = !1, pe.emit("resume"), Te(pe), fe.flowing && !fe.reading && pe.read(0);
  }
  _e.prototype.pause = function() {
    return X("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1 && (X("pause"), this._readableState.flowing = !1, this.emit("pause")), this._readableState.paused = !0, this;
  };
  function Te(pe) {
    var fe = pe._readableState;
    for (X("flow", fe.flowing); fe.flowing && pe.read() !== null; )
      ;
  }
  _e.prototype.wrap = function(pe) {
    var fe = this, Se = this._readableState, Pe = !1;
    pe.on("end", function() {
      if (X("wrapped end"), Se.decoder && !Se.ended) {
        var et = Se.decoder.end();
        et && et.length && fe.push(et);
      }
      fe.push(null);
    }), pe.on("data", function(et) {
      if (X("wrapped data"), Se.decoder && (et = Se.decoder.write(et)), !(Se.objectMode && et == null) && !(!Se.objectMode && (!et || !et.length))) {
        var rt = fe.push(et);
        rt || (Pe = !0, pe.pause());
      }
    });
    for (var Ge in pe)
      this[Ge] === void 0 && typeof pe[Ge] == "function" && (this[Ge] = /* @__PURE__ */ function(rt) {
        return function() {
          return pe[rt].apply(pe, arguments);
        };
      }(Ge));
    for (var Qe = 0; Qe < me.length; Qe++)
      pe.on(me[Qe], this.emit.bind(this, me[Qe]));
    return this._read = function(et) {
      X("wrapped _read", et), Pe && (Pe = !1, pe.resume());
    }, this;
  }, typeof Symbol == "function" && (_e.prototype[Symbol.asyncIterator] = function() {
    return ce === void 0 && (ce = requireAsync_iterator()), ce(this);
  }), Object.defineProperty(_e.prototype, "readableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.highWaterMark;
    }
  }), Object.defineProperty(_e.prototype, "readableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState && this._readableState.buffer;
    }
  }), Object.defineProperty(_e.prototype, "readableFlowing", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.flowing;
    },
    set: function(fe) {
      this._readableState && (this._readableState.flowing = fe);
    }
  }), _e._fromList = Ce, Object.defineProperty(_e.prototype, "readableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.length;
    }
  });
  function Ce(pe, fe) {
    if (fe.length === 0)
      return null;
    var Se;
    return fe.objectMode ? Se = fe.buffer.shift() : !pe || pe >= fe.length ? (fe.decoder ? Se = fe.buffer.join("") : fe.buffer.length === 1 ? Se = fe.buffer.first() : Se = fe.buffer.concat(fe.length), fe.buffer.clear()) : Se = fe.buffer.consume(pe, fe.decoder), Se;
  }
  function te(pe) {
    var fe = pe._readableState;
    X("endReadable", fe.endEmitted), fe.endEmitted || (fe.ended = !0, process$1.nextTick(le, fe, pe));
  }
  function le(pe, fe) {
    if (X("endReadableNT", pe.endEmitted, pe.length), !pe.endEmitted && pe.length === 0 && (pe.endEmitted = !0, fe.readable = !1, fe.emit("end"), pe.autoDestroy)) {
      var Se = fe._writableState;
      (!Se || Se.autoDestroy && Se.finished) && fe.destroy();
    }
  }
  typeof Symbol == "function" && (_e.from = function(pe, fe) {
    return he === void 0 && (he = requireFromBrowser()), he(_e, pe, fe);
  });
  function ge(pe, fe) {
    for (var Se = 0, Pe = pe.length; Se < Pe; Se++)
      if (pe[Se] === fe)
        return Se;
    return -1;
  }
  return _stream_readable;
}
var _stream_transform = Transform$1, _require$codes$1 = errorsBrowser.codes, ERR_METHOD_NOT_IMPLEMENTED = _require$codes$1.ERR_METHOD_NOT_IMPLEMENTED, ERR_MULTIPLE_CALLBACK = _require$codes$1.ERR_MULTIPLE_CALLBACK, ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes$1.ERR_TRANSFORM_ALREADY_TRANSFORMING, ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes$1.ERR_TRANSFORM_WITH_LENGTH_0, Duplex = require_stream_duplex();
inherits_browserExports(Transform$1, Duplex);
function afterTransform(z, D) {
  var O = this._transformState;
  O.transforming = !1;
  var F = O.writecb;
  if (F === null)
    return this.emit("error", new ERR_MULTIPLE_CALLBACK());
  O.writechunk = null, O.writecb = null, D != null && this.push(D), F(z);
  var U = this._readableState;
  U.reading = !1, (U.needReadable || U.length < U.highWaterMark) && this._read(U.highWaterMark);
}
function Transform$1(z) {
  if (!(this instanceof Transform$1))
    return new Transform$1(z);
  Duplex.call(this, z), this._transformState = {
    afterTransform: afterTransform.bind(this),
    needTransform: !1,
    transforming: !1,
    writecb: null,
    writechunk: null,
    writeencoding: null
  }, this._readableState.needReadable = !0, this._readableState.sync = !1, z && (typeof z.transform == "function" && (this._transform = z.transform), typeof z.flush == "function" && (this._flush = z.flush)), this.on("prefinish", prefinish);
}
function prefinish() {
  var z = this;
  typeof this._flush == "function" && !this._readableState.destroyed ? this._flush(function(D, O) {
    done(z, D, O);
  }) : done(this, null, null);
}
Transform$1.prototype.push = function(z, D) {
  return this._transformState.needTransform = !1, Duplex.prototype.push.call(this, z, D);
};
Transform$1.prototype._transform = function(z, D, O) {
  O(new ERR_METHOD_NOT_IMPLEMENTED("_transform()"));
};
Transform$1.prototype._write = function(z, D, O) {
  var F = this._transformState;
  if (F.writecb = O, F.writechunk = z, F.writeencoding = D, !F.transforming) {
    var U = this._readableState;
    (F.needTransform || U.needReadable || U.length < U.highWaterMark) && this._read(U.highWaterMark);
  }
};
Transform$1.prototype._read = function(z) {
  var D = this._transformState;
  D.writechunk !== null && !D.transforming ? (D.transforming = !0, this._transform(D.writechunk, D.writeencoding, D.afterTransform)) : D.needTransform = !0;
};
Transform$1.prototype._destroy = function(z, D) {
  Duplex.prototype._destroy.call(this, z, function(O) {
    D(O);
  });
};
function done(z, D, O) {
  if (D)
    return z.emit("error", D);
  if (O != null && z.push(O), z._writableState.length)
    throw new ERR_TRANSFORM_WITH_LENGTH_0();
  if (z._transformState.transforming)
    throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
  return z.push(null);
}
var _stream_passthrough = PassThrough, Transform = _stream_transform;
inherits_browserExports(PassThrough, Transform);
function PassThrough(z) {
  if (!(this instanceof PassThrough))
    return new PassThrough(z);
  Transform.call(this, z);
}
PassThrough.prototype._transform = function(z, D, O) {
  O(null, z);
};
var eos;
function once(z) {
  var D = !1;
  return function() {
    D || (D = !0, z.apply(void 0, arguments));
  };
}
var _require$codes = errorsBrowser.codes, ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS, ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
function noop(z) {
  if (z)
    throw z;
}
function isRequest(z) {
  return z.setHeader && typeof z.abort == "function";
}
function destroyer(z, D, O, F) {
  F = once(F);
  var U = !1;
  z.on("close", function() {
    U = !0;
  }), eos === void 0 && (eos = endOfStream), eos(z, {
    readable: D,
    writable: O
  }, function(B) {
    if (B)
      return F(B);
    U = !0, F();
  });
  var W = !1;
  return function(B) {
    if (!U && !W) {
      if (W = !0, isRequest(z))
        return z.abort();
      if (typeof z.destroy == "function")
        return z.destroy();
      F(B || new ERR_STREAM_DESTROYED("pipe"));
    }
  };
}
function call(z) {
  z();
}
function pipe(z, D) {
  return z.pipe(D);
}
function popCallback(z) {
  return !z.length || typeof z[z.length - 1] != "function" ? noop : z.pop();
}
function pipeline() {
  for (var z = arguments.length, D = new Array(z), O = 0; O < z; O++)
    D[O] = arguments[O];
  var F = popCallback(D);
  if (Array.isArray(D[0]) && (D = D[0]), D.length < 2)
    throw new ERR_MISSING_ARGS("streams");
  var U, W = D.map(function(B, K) {
    var X = K < D.length - 1, Y = K > 0;
    return destroyer(B, X, Y, function(Q) {
      U || (U = Q), Q && W.forEach(call), !X && (W.forEach(call), F(U));
    });
  });
  return D.reduce(pipe);
}
var pipeline_1 = pipeline;
(function(z, D) {
  D = z.exports = require_stream_readable(), D.Stream = D, D.Readable = D, D.Writable = require_stream_writable(), D.Duplex = require_stream_duplex(), D.Transform = _stream_transform, D.PassThrough = _stream_passthrough, D.finished = endOfStream, D.pipeline = pipeline_1;
})(readableBrowser, readableBrowser.exports);
var readableBrowserExports = readableBrowser.exports;
Object.defineProperty(lib, "__esModule", { value: !0 });
lib.ReadableWebToNodeStream = void 0;
const readable_stream_1 = readableBrowserExports;
class ReadableWebToNodeStream extends readable_stream_1.Readable {
  /**
   *
   * @param stream ReadableStream: https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream
   */
  constructor(D) {
    super(), this.bytesRead = 0, this.released = !1, this.reader = D.getReader();
  }
  /**
   * Implementation of readable._read(size).
   * When readable._read() is called, if data is available from the resource,
   * the implementation should begin pushing that data into the read queue
   * https://nodejs.org/api/stream.html#stream_readable_read_size_1
   */
  async _read() {
    if (this.released) {
      this.push(null);
      return;
    }
    this.pendingRead = this.reader.read();
    const D = await this.pendingRead;
    delete this.pendingRead, D.done || this.released ? this.push(null) : (this.bytesRead += D.value.length, this.push(D.value));
  }
  /**
   * If there is no unresolved read call to Web-API ReadableStream immediately returns;
   * otherwise will wait until the read is resolved.
   */
  async waitForReadToComplete() {
    this.pendingRead && await this.pendingRead;
  }
  /**
   * Close wrapper
   */
  async close() {
    await this.syncAndRelease();
  }
  async syncAndRelease() {
    this.released = !0, await this.waitForReadToComplete(), await this.reader.releaseLock();
  }
}
lib.ReadableWebToNodeStream = ReadableWebToNodeStream;
(function(z) {
  Object.defineProperty(z, "__esModule", { value: !0 }), z.fetchFromUrl = z.parseBlob = z.parseReadableStream = z.parseNodeStream = z.selectCover = z.ratingToStars = z.orderTags = z.parseFromTokenizer = z.parseBuffer = void 0;
  const D = browserExports, O = core$2, F = lib, U = D("music-metadata-browser:main");
  var W = core$2;
  Object.defineProperty(z, "parseBuffer", { enumerable: !0, get: function() {
    return W.parseBuffer;
  } }), Object.defineProperty(z, "parseFromTokenizer", { enumerable: !0, get: function() {
    return W.parseFromTokenizer;
  } }), Object.defineProperty(z, "orderTags", { enumerable: !0, get: function() {
    return W.orderTags;
  } }), Object.defineProperty(z, "ratingToStars", { enumerable: !0, get: function() {
    return W.ratingToStars;
  } }), Object.defineProperty(z, "selectCover", { enumerable: !0, get: function() {
    return W.selectCover;
  } }), z.parseNodeStream = O.parseStream;
  async function B(Q, J, ee) {
    const ae = new F.ReadableWebToNodeStream(Q), re = await (0, z.parseNodeStream)(ae, typeof J == "string" ? { mimeType: J } : J, ee);
    return await ae.close(), re;
  }
  z.parseReadableStream = B;
  async function K(Q, J) {
    Q.type, Q.size, Q instanceof File && Q.name;
    const ee = Q.stream ? Q.stream() : X(Q);
    return B(ee, { mimeType: Q.type, size: Q.size }, J);
  }
  z.parseBlob = K;
  function X(Q) {
    const J = new FileReader();
    return new ReadableStream({
      start(ee) {
        J.onloadend = (ae) => {
          let re = ae.target.result;
          re instanceof ArrayBuffer && (re = new Uint8Array(re)), ee.enqueue(re), ee.close();
        }, J.onerror = (ae) => {
          ee.close();
        }, J.onabort = (ae) => {
          ee.close();
        }, J.readAsArrayBuffer(Q);
      }
    });
  }
  async function Y(Q, J) {
    const ee = await fetch(Q), ae = {
      size: parseInt(ee.headers.get("Content-Length"), 10),
      mimeType: ee.headers.get("Content-Type")
    };
    if (ee.ok)
      if (ee.body) {
        const re = await B(ee.body, ae, J);
        return U("Closing HTTP-readable-stream..."), ee.body.locked || await ee.body.cancel(), U("HTTP-readable-stream closed."), re;
      } else
        return K(await ee.blob(), J);
    else
      throw new Error(`HTTP error status=${ee.status}: ${ee.statusText}`);
  }
  z.fetchFromUrl = Y;
})(lib$3);
const bufferBuilderProcessorPath = "" + new URL("assets/buffer-builder-processor-DRMeOSV8.js", import.meta.url).href, encodedJs = "dmFyIGVlPSh0MCxhMCxzMCk9PntpZighYTAuaGFzKHQwKSl0aHJvdyBUeXBlRXJyb3IoIkNhbm5vdCAiK3MwKX07dmFyIHRlPSh0MCxhMCxzMCk9PihlZSh0MCxhMCwicmVhZCBmcm9tIHByaXZhdGUgZmllbGQiKSxzMD9zMC5jYWxsKHQwKTphMC5nZXQodDApKSxhZT0odDAsYTAsczApPT57aWYoYTAuaGFzKHQwKSl0aHJvdyBUeXBlRXJyb3IoIkNhbm5vdCBhZGQgdGhlIHNhbWUgcHJpdmF0ZSBtZW1iZXIgbW9yZSB0aGFuIG9uY2UiKTthMCBpbnN0YW5jZW9mIFdlYWtTZXQ/YTAuYWRkKHQwKTphMC5zZXQodDAsczApfSxuZT0odDAsYTAsczAsQzEpPT4oZWUodDAsYTAsIndyaXRlIHRvIHByaXZhdGUgZmllbGQiKSxDMT9DMS5jYWxsKHQwLHMwKTphMC5zZXQodDAsczApLHMwKTsoZnVuY3Rpb24oKXsidXNlIHN0cmljdCI7dmFyIGQxO3ZhciB0MD10eXBlb2YgZ2xvYmFsVGhpczwidSI/Z2xvYmFsVGhpczp0eXBlb2Ygd2luZG93PCJ1Ij93aW5kb3c6dHlwZW9mIGdsb2JhbDwidSI/Z2xvYmFsOnR5cGVvZiBzZWxmPCJ1Ij9zZWxmOnt9O2Z1bmN0aW9uIGEwKGwpe3JldHVybiBsJiZsLl9fZXNNb2R1bGUmJk9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChsLCJkZWZhdWx0Iik/bC5kZWZhdWx0Omx9dmFyIHMwPXtleHBvcnRzOnt9fTsvKioKICogY2hyb21hLmpzIC0gSmF2YVNjcmlwdCBsaWJyYXJ5IGZvciBjb2xvciBjb252ZXJzaW9ucwogKgogKiBDb3B5cmlnaHQgKGMpIDIwMTEtMjAxOSwgR3JlZ29yIEFpc2NoCiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuCiAqCiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dAogKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDoKICoKICogMS4gUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLCB0aGlzCiAqIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLgogKgogKiAyLiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsCiAqIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlIGRvY3VtZW50YXRpb24KICogYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uCiAqCiAqIDMuIFRoZSBuYW1lIEdyZWdvciBBaXNjaCBtYXkgbm90IGJlIHVzZWQgdG8gZW5kb3JzZSBvciBwcm9tb3RlIHByb2R1Y3RzCiAqIGRlcml2ZWQgZnJvbSB0aGlzIHNvZnR3YXJlIHdpdGhvdXQgc3BlY2lmaWMgcHJpb3Igd3JpdHRlbiBwZXJtaXNzaW9uLgogKgogKiBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTICJBUyBJUyIKICogQU5EIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRQogKiBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkUKICogRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgR1JFR09SIEFJU0NIIE9SIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsCiAqIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLAogKiBCVVQgTk9UIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLAogKiBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTlkgVEhFT1JZCiAqIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVCAoSU5DTFVESU5HCiAqIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJUyBTT0ZUV0FSRSwKICogRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS4KICoKICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQogKgogKiBjaHJvbWEuanMgaW5jbHVkZXMgY29sb3JzIGZyb20gY29sb3JicmV3ZXIyLm9yZywgd2hpY2ggYXJlIHJlbGVhc2VkIHVuZGVyCiAqIHRoZSBmb2xsb3dpbmcgbGljZW5zZToKICoKICogQ29weXJpZ2h0IChjKSAyMDAyIEN5bnRoaWEgQnJld2VyLCBNYXJrIEhhcnJvd2VyLAogKiBhbmQgVGhlIFBlbm5zeWx2YW5pYSBTdGF0ZSBVbml2ZXJzaXR5LgogKgogKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgIkxpY2Vuc2UiKTsKICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLgogKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXQKICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wCiAqCiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywKICogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4KICogIkFTIElTIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsCiAqIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljCiAqIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuCiAqCiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQogKgogKiBOYW1lZCBjb2xvcnMgYXJlIHRha2VuIGZyb20gWDExIENvbG9yIE5hbWVzLgogKiBodHRwOi8vd3d3LnczLm9yZy9UUi9jc3MzLWNvbG9yLyNzdmctY29sb3IKICoKICogQHByZXNlcnZlCiAqLyhmdW5jdGlvbihsLG4peyhmdW5jdGlvbih1LGIpe2wuZXhwb3J0cz1iKCl9KSh0MCxmdW5jdGlvbigpe2Zvcih2YXIgdT1mdW5jdGlvbihyLGUsdCl7cmV0dXJuIGU9PT12b2lkIDAmJihlPTApLHQ9PT12b2lkIDAmJih0PTEpLHI8ZT9lOnI+dD90OnJ9LGI9dSxnPWZ1bmN0aW9uKHIpe3IuX2NsaXBwZWQ9ITEsci5fdW5jbGlwcGVkPXIuc2xpY2UoMCk7Zm9yKHZhciBlPTA7ZTw9MztlKyspZTwzPygocltlXTwwfHxyW2VdPjI1NSkmJihyLl9jbGlwcGVkPSEwKSxyW2VdPWIocltlXSwwLDI1NSkpOmU9PT0zJiYocltlXT1iKHJbZV0sMCwxKSk7cmV0dXJuIHJ9LCQ9e30sTT0wLHo9WyJCb29sZWFuIiwiTnVtYmVyIiwiU3RyaW5nIiwiRnVuY3Rpb24iLCJBcnJheSIsIkRhdGUiLCJSZWdFeHAiLCJVbmRlZmluZWQiLCJOdWxsIl07TTx6Lmxlbmd0aDtNKz0xKXt2YXIgaz16W01dOyRbIltvYmplY3QgIitrKyJdIl09ay50b0xvd2VyQ2FzZSgpfXZhciB4PWZ1bmN0aW9uKHIpe3JldHVybiAkW09iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChyKV18fCJvYmplY3QifSxBPXgsUj1mdW5jdGlvbihyLGUpe3JldHVybiBlPT09dm9pZCAwJiYoZT1udWxsKSxyLmxlbmd0aD49Mz9BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChyKTpBKHJbMF0pPT0ib2JqZWN0IiYmZT9lLnNwbGl0KCIiKS5maWx0ZXIoZnVuY3Rpb24odCl7cmV0dXJuIHJbMF1bdF0hPT12b2lkIDB9KS5tYXAoZnVuY3Rpb24odCl7cmV0dXJuIHJbMF1bdF19KTpyWzBdfSxVPXgscjA9ZnVuY3Rpb24ocil7aWYoci5sZW5ndGg8MilyZXR1cm4gbnVsbDt2YXIgZT1yLmxlbmd0aC0xO3JldHVybiBVKHJbZV0pPT0ic3RyaW5nIj9yW2VdLnRvTG93ZXJDYXNlKCk6bnVsbH0sTz1NYXRoLlBJLG09e2NsaXBfcmdiOmcsbGltaXQ6dSx0eXBlOngsdW5wYWNrOlIsbGFzdDpyMCxQSTpPLFRXT1BJOk8qMixQSVRISVJEOk8vMyxERUcyUkFEOk8vMTgwLFJBRDJERUc6MTgwL099LEU9e2Zvcm1hdDp7fSxhdXRvZGV0ZWN0OltdfSxWPW0ubGFzdCxRPW0uY2xpcF9yZ2IsdjA9bS50eXBlLGUwPUUsaDA9ZnVuY3Rpb24oKXtmb3IodmFyIGU9W10sdD1hcmd1bWVudHMubGVuZ3RoO3QtLTspZVt0XT1hcmd1bWVudHNbdF07dmFyIGE9dGhpcztpZih2MChlWzBdKT09PSJvYmplY3QiJiZlWzBdLmNvbnN0cnVjdG9yJiZlWzBdLmNvbnN0cnVjdG9yPT09dGhpcy5jb25zdHJ1Y3RvcilyZXR1cm4gZVswXTt2YXIgcz1WKGUpLGk9ITE7aWYoIXMpe2k9ITAsZTAuc29ydGVkfHwoZTAuYXV0b2RldGVjdD1lMC5hdXRvZGV0ZWN0LnNvcnQoZnVuY3Rpb24oaCx3KXtyZXR1cm4gdy5wLWgucH0pLGUwLnNvcnRlZD0hMCk7Zm9yKHZhciBvPTAsYz1lMC5hdXRvZGV0ZWN0O288Yy5sZW5ndGg7bys9MSl7dmFyIGY9Y1tvXTtpZihzPWYudGVzdC5hcHBseShmLGUpLHMpYnJlYWt9fWlmKGUwLmZvcm1hdFtzXSl7dmFyIHY9ZTAuZm9ybWF0W3NdLmFwcGx5KG51bGwsaT9lOmUuc2xpY2UoMCwtMSkpO2EuX3JnYj1RKHYpfWVsc2UgdGhyb3cgbmV3IEVycm9yKCJ1bmtub3duIGZvcm1hdDogIitlKTthLl9yZ2IubGVuZ3RoPT09MyYmYS5fcmdiLnB1c2goMSl9O2gwLnByb3RvdHlwZS50b1N0cmluZz1mdW5jdGlvbigpe3JldHVybiB2MCh0aGlzLmhleCk9PSJmdW5jdGlvbiI/dGhpcy5oZXgoKToiWyIrdGhpcy5fcmdiLmpvaW4oIiwiKSsiXSJ9O3ZhciBDPWgwLGMwPWZ1bmN0aW9uKCl7Zm9yKHZhciByPVtdLGU9YXJndW1lbnRzLmxlbmd0aDtlLS07KXJbZV09YXJndW1lbnRzW2VdO3JldHVybiBuZXcoRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQuYXBwbHkoYzAuQ29sb3IsW251bGxdLmNvbmNhdChyKSkpfTtjMC5Db2xvcj1DLGMwLnZlcnNpb249IjIuNC4yIjt2YXIgVz1jMCxtMD1tLnVucGFjayxwMD1NYXRoLm1heCx3MD1mdW5jdGlvbigpe2Zvcih2YXIgcj1bXSxlPWFyZ3VtZW50cy5sZW5ndGg7ZS0tOylyW2VdPWFyZ3VtZW50c1tlXTt2YXIgdD1tMChyLCJyZ2IiKSxhPXRbMF0scz10WzFdLGk9dFsyXTthPWEvMjU1LHM9cy8yNTUsaT1pLzI1NTt2YXIgbz0xLXAwKGEscDAocyxpKSksYz1vPDE/MS8oMS1vKTowLGY9KDEtYS1vKSpjLHY9KDEtcy1vKSpjLGg9KDEtaS1vKSpjO3JldHVybltmLHYsaCxvXX0seTA9dzAsXzA9bS51bnBhY2ssazA9ZnVuY3Rpb24oKXtmb3IodmFyIHI9W10sZT1hcmd1bWVudHMubGVuZ3RoO2UtLTspcltlXT1hcmd1bWVudHNbZV07cj1fMChyLCJjbXlrIik7dmFyIHQ9clswXSxhPXJbMV0scz1yWzJdLGk9clszXSxvPXIubGVuZ3RoPjQ/cls0XToxO3JldHVybiBpPT09MT9bMCwwLDAsb106W3Q+PTE/MDoyNTUqKDEtdCkqKDEtaSksYT49MT8wOjI1NSooMS1hKSooMS1pKSxzPj0xPzA6MjU1KigxLXMpKigxLWkpLG9dfSwkMD1rMCxNMD1XLFMwPUMsSTA9RSxxMD1tLnVucGFjayxXMD1tLnR5cGUsSDA9eTA7UzAucHJvdG90eXBlLmNteWs9ZnVuY3Rpb24oKXtyZXR1cm4gSDAodGhpcy5fcmdiKX0sTTAuY215az1mdW5jdGlvbigpe2Zvcih2YXIgcj1bXSxlPWFyZ3VtZW50cy5sZW5ndGg7ZS0tOylyW2VdPWFyZ3VtZW50c1tlXTtyZXR1cm4gbmV3KEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kLmFwcGx5KFMwLFtudWxsXS5jb25jYXQocixbImNteWsiXSkpKX0sSTAuZm9ybWF0LmNteWs9JDAsSTAuYXV0b2RldGVjdC5wdXNoKHtwOjIsdGVzdDpmdW5jdGlvbigpe2Zvcih2YXIgcj1bXSxlPWFyZ3VtZW50cy5sZW5ndGg7ZS0tOylyW2VdPWFyZ3VtZW50c1tlXTtpZihyPXEwKHIsImNteWsiKSxXMChyKT09PSJhcnJheSImJnIubGVuZ3RoPT09NClyZXR1cm4iY215ayJ9fSk7dmFyIE8wPW0udW5wYWNrLFkwPW0ubGFzdCxDMD1mdW5jdGlvbihyKXtyZXR1cm4gTWF0aC5yb3VuZChyKjEwMCkvMTAwfSxVMD1mdW5jdGlvbigpe2Zvcih2YXIgcj1bXSxlPWFyZ3VtZW50cy5sZW5ndGg7ZS0tOylyW2VdPWFyZ3VtZW50c1tlXTt2YXIgdD1PMChyLCJoc2xhIiksYT1ZMChyKXx8ImxzYSI7cmV0dXJuIHRbMF09QzAodFswXXx8MCksdFsxXT1DMCh0WzFdKjEwMCkrIiUiLHRbMl09QzAodFsyXSoxMDApKyIlIixhPT09ImhzbGEifHx0Lmxlbmd0aD4zJiZ0WzNdPDE/KHRbM109dC5sZW5ndGg+Mz90WzNdOjEsYT0iaHNsYSIpOnQubGVuZ3RoPTMsYSsiKCIrdC5qb2luKCIsIikrIikifSxSMD1VMCxUMD1tLnVucGFjayxYMD1mdW5jdGlvbigpe2Zvcih2YXIgcj1bXSxlPWFyZ3VtZW50cy5sZW5ndGg7ZS0tOylyW2VdPWFyZ3VtZW50c1tlXTtyPVQwKHIsInJnYmEiKTt2YXIgdD1yWzBdLGE9clsxXSxzPXJbMl07dC89MjU1LGEvPTI1NSxzLz0yNTU7dmFyIGk9TWF0aC5taW4odCxhLHMpLG89TWF0aC5tYXgodCxhLHMpLGM9KG8raSkvMixmLHY7cmV0dXJuIG89PT1pPyhmPTAsdj1OdW1iZXIuTmFOKTpmPWM8LjU/KG8taSkvKG8raSk6KG8taSkvKDItby1pKSx0PT1vP3Y9KGEtcykvKG8taSk6YT09bz92PTIrKHMtdCkvKG8taSk6cz09byYmKHY9NCsodC1hKS8oby1pKSksdio9NjAsdjwwJiYodis9MzYwKSxyLmxlbmd0aD4zJiZyWzNdIT09dm9pZCAwP1t2LGYsYyxyWzNdXTpbdixmLGNdfSxQMD1YMCx6MD1tLnVucGFjayxFMD1tLmxhc3QsVjA9UjAsdDE9UDAsajA9TWF0aC5yb3VuZCxwMT1mdW5jdGlvbigpe2Zvcih2YXIgcj1bXSxlPWFyZ3VtZW50cy5sZW5ndGg7ZS0tOylyW2VdPWFyZ3VtZW50c1tlXTt2YXIgdD16MChyLCJyZ2JhIiksYT1FMChyKXx8InJnYiI7cmV0dXJuIGEuc3Vic3RyKDAsMyk9PSJoc2wiP1YwKHQxKHQpLGEpOih0WzBdPWowKHRbMF0pLHRbMV09ajAodFsxXSksdFsyXT1qMCh0WzJdKSwoYT09PSJyZ2JhInx8dC5sZW5ndGg+MyYmdFszXTwxKSYmKHRbM109dC5sZW5ndGg+Mz90WzNdOjEsYT0icmdiYSIpLGErIigiK3Quc2xpY2UoMCxhPT09InJnYiI/Mzo0KS5qb2luKCIsIikrIikiKX0sbTE9cDEsdzE9bS51bnBhY2ssWjA9TWF0aC5yb3VuZCx5MT1mdW5jdGlvbigpe2Zvcih2YXIgcixlPVtdLHQ9YXJndW1lbnRzLmxlbmd0aDt0LS07KWVbdF09YXJndW1lbnRzW3RdO2U9dzEoZSwiaHNsIik7dmFyIGE9ZVswXSxzPWVbMV0saT1lWzJdLG8sYyxmO2lmKHM9PT0wKW89Yz1mPWkqMjU1O2Vsc2V7dmFyIHY9WzAsMCwwXSxoPVswLDAsMF0sdz1pPC41P2kqKDErcyk6aStzLWkqcyxkPTIqaS13LF89YS8zNjA7dlswXT1fKzEvMyx2WzFdPV8sdlsyXT1fLTEvMztmb3IodmFyIHk9MDt5PDM7eSsrKXZbeV08MCYmKHZbeV0rPTEpLHZbeV0+MSYmKHZbeV0tPTEpLDYqdlt5XTwxP2hbeV09ZCsody1kKSo2KnZbeV06Mip2W3ldPDE/aFt5XT13OjMqdlt5XTwyP2hbeV09ZCsody1kKSooMi8zLXZbeV0pKjY6aFt5XT1kO3I9W1owKGhbMF0qMjU1KSxaMChoWzFdKjI1NSksWjAoaFsyXSoyNTUpXSxvPXJbMF0sYz1yWzFdLGY9clsyXX1yZXR1cm4gZS5sZW5ndGg+Mz9bbyxjLGYsZVszXV06W28sYyxmLDFdfSxhMT15MSxBMT1hMSx4MT1FLFMxPS9ecmdiXChccyooLT9cZCspLFxzKigtP1xkKylccyosXHMqKC0/XGQrKVxzKlwpJC8sSTE9L15yZ2JhXChccyooLT9cZCspLFxzKigtP1xkKylccyosXHMqKC0/XGQrKVxzKixccyooWzAxXXxbMDFdP1wuXGQrKVwpJC8sUjE9L15yZ2JcKFxzKigtP1xkKyg/OlwuXGQrKT8pJSxccyooLT9cZCsoPzpcLlxkKyk/KSVccyosXHMqKC0/XGQrKD86XC5cZCspPyklXHMqXCkkLyxUMT0vXnJnYmFcKFxzKigtP1xkKyg/OlwuXGQrKT8pJSxccyooLT9cZCsoPzpcLlxkKyk/KSVccyosXHMqKC0/XGQrKD86XC5cZCspPyklXHMqLFxzKihbMDFdfFswMV0/XC5cZCspXCkkLyxQMT0vXmhzbFwoXHMqKC0/XGQrKD86XC5cZCspPyksXHMqKC0/XGQrKD86XC5cZCspPyklXHMqLFxzKigtP1xkKyg/OlwuXGQrKT8pJVxzKlwpJC8sejE9L15oc2xhXChccyooLT9cZCsoPzpcLlxkKyk/KSxccyooLT9cZCsoPzpcLlxkKyk/KSVccyosXHMqKC0/XGQrKD86XC5cZCspPyklXHMqLFxzKihbMDFdfFswMV0/XC5cZCspXCkkLyxFMT1NYXRoLnJvdW5kLF8xPWZ1bmN0aW9uKHIpe3I9ci50b0xvd2VyQ2FzZSgpLnRyaW0oKTt2YXIgZTtpZih4MS5mb3JtYXQubmFtZWQpdHJ5e3JldHVybiB4MS5mb3JtYXQubmFtZWQocil9Y2F0Y2h7fWlmKGU9ci5tYXRjaChTMSkpe2Zvcih2YXIgdD1lLnNsaWNlKDEsNCksYT0wO2E8MzthKyspdFthXT0rdFthXTtyZXR1cm4gdFszXT0xLHR9aWYoZT1yLm1hdGNoKEkxKSl7Zm9yKHZhciBzPWUuc2xpY2UoMSw1KSxpPTA7aTw0O2krKylzW2ldPStzW2ldO3JldHVybiBzfWlmKGU9ci5tYXRjaChSMSkpe2Zvcih2YXIgbz1lLnNsaWNlKDEsNCksYz0wO2M8MztjKyspb1tjXT1FMShvW2NdKjIuNTUpO3JldHVybiBvWzNdPTEsb31pZihlPXIubWF0Y2goVDEpKXtmb3IodmFyIGY9ZS5zbGljZSgxLDUpLHY9MDt2PDM7disrKWZbdl09RTEoZlt2XSoyLjU1KTtyZXR1cm4gZlszXT0rZlszXSxmfWlmKGU9ci5tYXRjaChQMSkpe3ZhciBoPWUuc2xpY2UoMSw0KTtoWzFdKj0uMDEsaFsyXSo9LjAxO3ZhciB3PUExKGgpO3JldHVybiB3WzNdPTEsd31pZihlPXIubWF0Y2goejEpKXt2YXIgZD1lLnNsaWNlKDEsNCk7ZFsxXSo9LjAxLGRbMl0qPS4wMTt2YXIgXz1BMShkKTtyZXR1cm4gX1szXT0rZVs0XSxffX07XzEudGVzdD1mdW5jdGlvbihyKXtyZXR1cm4gUzEudGVzdChyKXx8STEudGVzdChyKXx8UjEudGVzdChyKXx8VDEudGVzdChyKXx8UDEudGVzdChyKXx8ejEudGVzdChyKX07dmFyIE4xPV8xLEsxPVcsQjE9QyxHMj1FLFFlPW0udHlwZSxKZT1tMSxxMj1OMTtCMS5wcm90b3R5cGUuY3NzPWZ1bmN0aW9uKHIpe3JldHVybiBKZSh0aGlzLl9yZ2Iscil9LEsxLmNzcz1mdW5jdGlvbigpe2Zvcih2YXIgcj1bXSxlPWFyZ3VtZW50cy5sZW5ndGg7ZS0tOylyW2VdPWFyZ3VtZW50c1tlXTtyZXR1cm4gbmV3KEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kLmFwcGx5KEIxLFtudWxsXS5jb25jYXQocixbImNzcyJdKSkpfSxHMi5mb3JtYXQuY3NzPXEyLEcyLmF1dG9kZXRlY3QucHVzaCh7cDo1LHRlc3Q6ZnVuY3Rpb24ocil7Zm9yKHZhciBlPVtdLHQ9YXJndW1lbnRzLmxlbmd0aC0xO3QtLSA+MDspZVt0XT1hcmd1bWVudHNbdCsxXTtpZighZS5sZW5ndGgmJlFlKHIpPT09InN0cmluZyImJnEyLnRlc3QocikpcmV0dXJuImNzcyJ9fSk7dmFyIFcyPUMsS2U9VyxyNj1FLGU2PW0udW5wYWNrO3I2LmZvcm1hdC5nbD1mdW5jdGlvbigpe2Zvcih2YXIgcj1bXSxlPWFyZ3VtZW50cy5sZW5ndGg7ZS0tOylyW2VdPWFyZ3VtZW50c1tlXTt2YXIgdD1lNihyLCJyZ2JhIik7cmV0dXJuIHRbMF0qPTI1NSx0WzFdKj0yNTUsdFsyXSo9MjU1LHR9LEtlLmdsPWZ1bmN0aW9uKCl7Zm9yKHZhciByPVtdLGU9YXJndW1lbnRzLmxlbmd0aDtlLS07KXJbZV09YXJndW1lbnRzW2VdO3JldHVybiBuZXcoRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQuYXBwbHkoVzIsW251bGxdLmNvbmNhdChyLFsiZ2wiXSkpKX0sVzIucHJvdG90eXBlLmdsPWZ1bmN0aW9uKCl7dmFyIHI9dGhpcy5fcmdiO3JldHVybltyWzBdLzI1NSxyWzFdLzI1NSxyWzJdLzI1NSxyWzNdXX07dmFyIHQ2PW0udW5wYWNrLGE2PWZ1bmN0aW9uKCl7Zm9yKHZhciByPVtdLGU9YXJndW1lbnRzLmxlbmd0aDtlLS07KXJbZV09YXJndW1lbnRzW2VdO3ZhciB0PXQ2KHIsInJnYiIpLGE9dFswXSxzPXRbMV0saT10WzJdLG89TWF0aC5taW4oYSxzLGkpLGM9TWF0aC5tYXgoYSxzLGkpLGY9Yy1vLHY9ZioxMDAvMjU1LGg9by8oMjU1LWYpKjEwMCx3O3JldHVybiBmPT09MD93PU51bWJlci5OYU46KGE9PT1jJiYodz0ocy1pKS9mKSxzPT09YyYmKHc9MisoaS1hKS9mKSxpPT09YyYmKHc9NCsoYS1zKS9mKSx3Kj02MCx3PDAmJih3Kz0zNjApKSxbdyx2LGhdfSxuNj1hNixvNj1tLnVucGFjayxzNj1NYXRoLmZsb29yLGk2PWZ1bmN0aW9uKCl7Zm9yKHZhciByLGUsdCxhLHMsaSxvPVtdLGM9YXJndW1lbnRzLmxlbmd0aDtjLS07KW9bY109YXJndW1lbnRzW2NdO289bzYobywiaGNnIik7dmFyIGY9b1swXSx2PW9bMV0saD1vWzJdLHcsZCxfO2g9aCoyNTU7dmFyIHk9dioyNTU7aWYodj09PTApdz1kPV89aDtlbHNle2Y9PT0zNjAmJihmPTApLGY+MzYwJiYoZi09MzYwKSxmPDAmJihmKz0zNjApLGYvPTYwO3ZhciBTPXM2KGYpLFA9Zi1TLEI9aCooMS12KSxMPUIreSooMS1QKSxKPUIreSpQLFo9Qit5O3N3aXRjaChTKXtjYXNlIDA6cj1bWixKLEJdLHc9clswXSxkPXJbMV0sXz1yWzJdO2JyZWFrO2Nhc2UgMTplPVtMLFosQl0sdz1lWzBdLGQ9ZVsxXSxfPWVbMl07YnJlYWs7Y2FzZSAyOnQ9W0IsWixKXSx3PXRbMF0sZD10WzFdLF89dFsyXTticmVhaztjYXNlIDM6YT1bQixMLFpdLHc9YVswXSxkPWFbMV0sXz1hWzJdO2JyZWFrO2Nhc2UgNDpzPVtKLEIsWl0sdz1zWzBdLGQ9c1sxXSxfPXNbMl07YnJlYWs7Y2FzZSA1Omk9W1osQixMXSx3PWlbMF0sZD1pWzFdLF89aVsyXTticmVha319cmV0dXJuW3csZCxfLG8ubGVuZ3RoPjM/b1szXToxXX0sYzY9aTYsbDY9bS51bnBhY2ssZjY9bS50eXBlLHU2PVcsSDI9QyxPMj1FLHY2PW42O0gyLnByb3RvdHlwZS5oY2c9ZnVuY3Rpb24oKXtyZXR1cm4gdjYodGhpcy5fcmdiKX0sdTYuaGNnPWZ1bmN0aW9uKCl7Zm9yKHZhciByPVtdLGU9YXJndW1lbnRzLmxlbmd0aDtlLS07KXJbZV09YXJndW1lbnRzW2VdO3JldHVybiBuZXcoRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQuYXBwbHkoSDIsW251bGxdLmNvbmNhdChyLFsiaGNnIl0pKSl9LE8yLmZvcm1hdC5oY2c9YzYsTzIuYXV0b2RldGVjdC5wdXNoKHtwOjEsdGVzdDpmdW5jdGlvbigpe2Zvcih2YXIgcj1bXSxlPWFyZ3VtZW50cy5sZW5ndGg7ZS0tOylyW2VdPWFyZ3VtZW50c1tlXTtpZihyPWw2KHIsImhjZyIpLGY2KHIpPT09ImFycmF5IiYmci5sZW5ndGg9PT0zKXJldHVybiJoY2cifX0pO3ZhciBoNj1tLnVucGFjayxnNj1tLmxhc3QsRDE9TWF0aC5yb3VuZCxiNj1mdW5jdGlvbigpe2Zvcih2YXIgcj1bXSxlPWFyZ3VtZW50cy5sZW5ndGg7ZS0tOylyW2VdPWFyZ3VtZW50c1tlXTt2YXIgdD1oNihyLCJyZ2JhIiksYT10WzBdLHM9dFsxXSxpPXRbMl0sbz10WzNdLGM9ZzYocil8fCJhdXRvIjtvPT09dm9pZCAwJiYobz0xKSxjPT09ImF1dG8iJiYoYz1vPDE/InJnYmEiOiJyZ2IiKSxhPUQxKGEpLHM9RDEocyksaT1EMShpKTt2YXIgZj1hPDwxNnxzPDw4fGksdj0iMDAwMDAwIitmLnRvU3RyaW5nKDE2KTt2PXYuc3Vic3RyKHYubGVuZ3RoLTYpO3ZhciBoPSIwIitEMShvKjI1NSkudG9TdHJpbmcoMTYpO3N3aXRjaChoPWguc3Vic3RyKGgubGVuZ3RoLTIpLGMudG9Mb3dlckNhc2UoKSl7Y2FzZSJyZ2JhIjpyZXR1cm4iIyIrditoO2Nhc2UiYXJnYiI6cmV0dXJuIiMiK2grdjtkZWZhdWx0OnJldHVybiIjIit2fX0sWTI9YjYsZDY9L14jPyhbQS1GYS1mMC05XXs2fXxbQS1GYS1mMC05XXszfSkkLyxwNj0vXiM/KFtBLUZhLWYwLTldezh9fFtBLUZhLWYwLTldezR9KSQvLG02PWZ1bmN0aW9uKHIpe2lmKHIubWF0Y2goZDYpKXsoci5sZW5ndGg9PT00fHxyLmxlbmd0aD09PTcpJiYocj1yLnN1YnN0cigxKSksci5sZW5ndGg9PT0zJiYocj1yLnNwbGl0KCIiKSxyPXJbMF0rclswXStyWzFdK3JbMV0rclsyXStyWzJdKTt2YXIgZT1wYXJzZUludChyLDE2KSx0PWU+PjE2LGE9ZT4+OCYyNTUscz1lJjI1NTtyZXR1cm5bdCxhLHMsMV19aWYoci5tYXRjaChwNikpeyhyLmxlbmd0aD09PTV8fHIubGVuZ3RoPT09OSkmJihyPXIuc3Vic3RyKDEpKSxyLmxlbmd0aD09PTQmJihyPXIuc3BsaXQoIiIpLHI9clswXStyWzBdK3JbMV0rclsxXStyWzJdK3JbMl0rclszXStyWzNdKTt2YXIgaT1wYXJzZUludChyLDE2KSxvPWk+PjI0JjI1NSxjPWk+PjE2JjI1NSxmPWk+PjgmMjU1LHY9TWF0aC5yb3VuZCgoaSYyNTUpLzI1NSoxMDApLzEwMDtyZXR1cm5bbyxjLGYsdl19dGhyb3cgbmV3IEVycm9yKCJ1bmtub3duIGhleCBjb2xvcjogIityKX0sVTI9bTYsdzY9VyxYMj1DLHk2PW0udHlwZSxWMj1FLF82PVkyO1gyLnByb3RvdHlwZS5oZXg9ZnVuY3Rpb24ocil7cmV0dXJuIF82KHRoaXMuX3JnYixyKX0sdzYuaGV4PWZ1bmN0aW9uKCl7Zm9yKHZhciByPVtdLGU9YXJndW1lbnRzLmxlbmd0aDtlLS07KXJbZV09YXJndW1lbnRzW2VdO3JldHVybiBuZXcoRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQuYXBwbHkoWDIsW251bGxdLmNvbmNhdChyLFsiaGV4Il0pKSl9LFYyLmZvcm1hdC5oZXg9VTIsVjIuYXV0b2RldGVjdC5wdXNoKHtwOjQsdGVzdDpmdW5jdGlvbihyKXtmb3IodmFyIGU9W10sdD1hcmd1bWVudHMubGVuZ3RoLTE7dC0tID4wOyllW3RdPWFyZ3VtZW50c1t0KzFdO2lmKCFlLmxlbmd0aCYmeTYocik9PT0ic3RyaW5nIiYmWzMsNCw1LDYsNyw4LDldLmluZGV4T2Yoci5sZW5ndGgpPj0wKXJldHVybiJoZXgifX0pO3ZhciBrNj1tLnVucGFjayxqMj1tLlRXT1BJLCQ2PU1hdGgubWluLE02PU1hdGguc3FydCxDNj1NYXRoLmFjb3MsRjY9ZnVuY3Rpb24oKXtmb3IodmFyIHI9W10sZT1hcmd1bWVudHMubGVuZ3RoO2UtLTspcltlXT1hcmd1bWVudHNbZV07dmFyIHQ9azYociwicmdiIiksYT10WzBdLHM9dFsxXSxpPXRbMl07YS89MjU1LHMvPTI1NSxpLz0yNTU7dmFyIG8sYz0kNihhLHMsaSksZj0oYStzK2kpLzMsdj1mPjA/MS1jL2Y6MDtyZXR1cm4gdj09PTA/bz1OYU46KG89KGEtcysoYS1pKSkvMixvLz1NNigoYS1zKSooYS1zKSsoYS1pKSoocy1pKSksbz1DNihvKSxpPnMmJihvPWoyLW8pLG8vPWoyKSxbbyozNjAsdixmXX0sQTY9RjYseDY9bS51bnBhY2sscjI9bS5saW1pdCxuMT1tLlRXT1BJLGUyPW0uUElUSElSRCxvMT1NYXRoLmNvcyxTNj1mdW5jdGlvbigpe2Zvcih2YXIgcj1bXSxlPWFyZ3VtZW50cy5sZW5ndGg7ZS0tOylyW2VdPWFyZ3VtZW50c1tlXTtyPXg2KHIsImhzaSIpO3ZhciB0PXJbMF0sYT1yWzFdLHM9clsyXSxpLG8sYztyZXR1cm4gaXNOYU4odCkmJih0PTApLGlzTmFOKGEpJiYoYT0wKSx0PjM2MCYmKHQtPTM2MCksdDwwJiYodCs9MzYwKSx0Lz0zNjAsdDwxLzM/KGM9KDEtYSkvMyxpPSgxK2EqbzEobjEqdCkvbzEoZTItbjEqdCkpLzMsbz0xLShjK2kpKTp0PDIvMz8odC09MS8zLGk9KDEtYSkvMyxvPSgxK2EqbzEobjEqdCkvbzEoZTItbjEqdCkpLzMsYz0xLShpK28pKToodC09Mi8zLG89KDEtYSkvMyxjPSgxK2EqbzEobjEqdCkvbzEoZTItbjEqdCkpLzMsaT0xLShvK2MpKSxpPXIyKHMqaSozKSxvPXIyKHMqbyozKSxjPXIyKHMqYyozKSxbaSoyNTUsbyoyNTUsYyoyNTUsci5sZW5ndGg+Mz9yWzNdOjFdfSxJNj1TNixSNj1tLnVucGFjayxUNj1tLnR5cGUsUDY9VyxaMj1DLFEyPUUsejY9QTY7WjIucHJvdG90eXBlLmhzaT1mdW5jdGlvbigpe3JldHVybiB6Nih0aGlzLl9yZ2IpfSxQNi5oc2k9ZnVuY3Rpb24oKXtmb3IodmFyIHI9W10sZT1hcmd1bWVudHMubGVuZ3RoO2UtLTspcltlXT1hcmd1bWVudHNbZV07cmV0dXJuIG5ldyhGdW5jdGlvbi5wcm90b3R5cGUuYmluZC5hcHBseShaMixbbnVsbF0uY29uY2F0KHIsWyJoc2kiXSkpKX0sUTIuZm9ybWF0LmhzaT1JNixRMi5hdXRvZGV0ZWN0LnB1c2goe3A6Mix0ZXN0OmZ1bmN0aW9uKCl7Zm9yKHZhciByPVtdLGU9YXJndW1lbnRzLmxlbmd0aDtlLS07KXJbZV09YXJndW1lbnRzW2VdO2lmKHI9UjYociwiaHNpIiksVDYocik9PT0iYXJyYXkiJiZyLmxlbmd0aD09PTMpcmV0dXJuImhzaSJ9fSk7dmFyIEU2PW0udW5wYWNrLE42PW0udHlwZSxCNj1XLEoyPUMsSzI9RSxENj1QMDtKMi5wcm90b3R5cGUuaHNsPWZ1bmN0aW9uKCl7cmV0dXJuIEQ2KHRoaXMuX3JnYil9LEI2LmhzbD1mdW5jdGlvbigpe2Zvcih2YXIgcj1bXSxlPWFyZ3VtZW50cy5sZW5ndGg7ZS0tOylyW2VdPWFyZ3VtZW50c1tlXTtyZXR1cm4gbmV3KEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kLmFwcGx5KEoyLFtudWxsXS5jb25jYXQocixbImhzbCJdKSkpfSxLMi5mb3JtYXQuaHNsPWExLEsyLmF1dG9kZXRlY3QucHVzaCh7cDoyLHRlc3Q6ZnVuY3Rpb24oKXtmb3IodmFyIHI9W10sZT1hcmd1bWVudHMubGVuZ3RoO2UtLTspcltlXT1hcmd1bWVudHNbZV07aWYocj1FNihyLCJoc2wiKSxONihyKT09PSJhcnJheSImJnIubGVuZ3RoPT09MylyZXR1cm4iaHNsIn19KTt2YXIgTDY9bS51bnBhY2ssRzY9TWF0aC5taW4scTY9TWF0aC5tYXgsVzY9ZnVuY3Rpb24oKXtmb3IodmFyIHI9W10sZT1hcmd1bWVudHMubGVuZ3RoO2UtLTspcltlXT1hcmd1bWVudHNbZV07cj1MNihyLCJyZ2IiKTt2YXIgdD1yWzBdLGE9clsxXSxzPXJbMl0saT1HNih0LGEscyksbz1xNih0LGEscyksYz1vLWksZix2LGg7cmV0dXJuIGg9by8yNTUsbz09PTA/KGY9TnVtYmVyLk5hTix2PTApOih2PWMvbyx0PT09byYmKGY9KGEtcykvYyksYT09PW8mJihmPTIrKHMtdCkvYykscz09PW8mJihmPTQrKHQtYSkvYyksZio9NjAsZjwwJiYoZis9MzYwKSksW2YsdixoXX0sSDY9VzYsTzY9bS51bnBhY2ssWTY9TWF0aC5mbG9vcixVNj1mdW5jdGlvbigpe2Zvcih2YXIgcixlLHQsYSxzLGksbz1bXSxjPWFyZ3VtZW50cy5sZW5ndGg7Yy0tOylvW2NdPWFyZ3VtZW50c1tjXTtvPU82KG8sImhzdiIpO3ZhciBmPW9bMF0sdj1vWzFdLGg9b1syXSx3LGQsXztpZihoKj0yNTUsdj09PTApdz1kPV89aDtlbHNle2Y9PT0zNjAmJihmPTApLGY+MzYwJiYoZi09MzYwKSxmPDAmJihmKz0zNjApLGYvPTYwO3ZhciB5PVk2KGYpLFM9Zi15LFA9aCooMS12KSxCPWgqKDEtdipTKSxMPWgqKDEtdiooMS1TKSk7c3dpdGNoKHkpe2Nhc2UgMDpyPVtoLEwsUF0sdz1yWzBdLGQ9clsxXSxfPXJbMl07YnJlYWs7Y2FzZSAxOmU9W0IsaCxQXSx3PWVbMF0sZD1lWzFdLF89ZVsyXTticmVhaztjYXNlIDI6dD1bUCxoLExdLHc9dFswXSxkPXRbMV0sXz10WzJdO2JyZWFrO2Nhc2UgMzphPVtQLEIsaF0sdz1hWzBdLGQ9YVsxXSxfPWFbMl07YnJlYWs7Y2FzZSA0OnM9W0wsUCxoXSx3PXNbMF0sZD1zWzFdLF89c1syXTticmVhaztjYXNlIDU6aT1baCxQLEJdLHc9aVswXSxkPWlbMV0sXz1pWzJdO2JyZWFrfX1yZXR1cm5bdyxkLF8sby5sZW5ndGg+Mz9vWzNdOjFdfSxYNj1VNixWNj1tLnVucGFjayxqNj1tLnR5cGUsWjY9Vyxycj1DLGVyPUUsUTY9SDY7cnIucHJvdG90eXBlLmhzdj1mdW5jdGlvbigpe3JldHVybiBRNih0aGlzLl9yZ2IpfSxaNi5oc3Y9ZnVuY3Rpb24oKXtmb3IodmFyIHI9W10sZT1hcmd1bWVudHMubGVuZ3RoO2UtLTspcltlXT1hcmd1bWVudHNbZV07cmV0dXJuIG5ldyhGdW5jdGlvbi5wcm90b3R5cGUuYmluZC5hcHBseShycixbbnVsbF0uY29uY2F0KHIsWyJoc3YiXSkpKX0sZXIuZm9ybWF0Lmhzdj1YNixlci5hdXRvZGV0ZWN0LnB1c2goe3A6Mix0ZXN0OmZ1bmN0aW9uKCl7Zm9yKHZhciByPVtdLGU9YXJndW1lbnRzLmxlbmd0aDtlLS07KXJbZV09YXJndW1lbnRzW2VdO2lmKHI9VjYociwiaHN2IiksajYocik9PT0iYXJyYXkiJiZyLmxlbmd0aD09PTMpcmV0dXJuImhzdiJ9fSk7dmFyIEwxPXtLbjoxOCxYbjouOTUwNDcsWW46MSxabjoxLjA4ODgzLHQwOi4xMzc5MzEwMzQsdDE6LjIwNjg5NjU1Mix0MjouMTI4NDE4NTUsdDM6LjAwODg1NjQ1Mn0sczE9TDEsSjY9bS51bnBhY2ssdHI9TWF0aC5wb3csSzY9ZnVuY3Rpb24oKXtmb3IodmFyIHI9W10sZT1hcmd1bWVudHMubGVuZ3RoO2UtLTspcltlXT1hcmd1bWVudHNbZV07dmFyIHQ9SjYociwicmdiIiksYT10WzBdLHM9dFsxXSxpPXRbMl0sbz1yMyhhLHMsaSksYz1vWzBdLGY9b1sxXSx2PW9bMl0saD0xMTYqZi0xNjtyZXR1cm5baDwwPzA6aCw1MDAqKGMtZiksMjAwKihmLXYpXX0sdDI9ZnVuY3Rpb24ocil7cmV0dXJuKHIvPTI1NSk8PS4wNDA0NT9yLzEyLjkyOnRyKChyKy4wNTUpLzEuMDU1LDIuNCl9LGEyPWZ1bmN0aW9uKHIpe3JldHVybiByPnMxLnQzP3RyKHIsMS8zKTpyL3MxLnQyK3MxLnQwfSxyMz1mdW5jdGlvbihyLGUsdCl7cj10MihyKSxlPXQyKGUpLHQ9dDIodCk7dmFyIGE9YTIoKC40MTI0NTY0KnIrLjM1NzU3NjEqZSsuMTgwNDM3NSp0KS9zMS5Ybikscz1hMigoLjIxMjY3MjkqcisuNzE1MTUyMiplKy4wNzIxNzUqdCkvczEuWW4pLGk9YTIoKC4wMTkzMzM5KnIrLjExOTE5MiplKy45NTAzMDQxKnQpL3MxLlpuKTtyZXR1cm5bYSxzLGldfSxhcj1LNixpMT1MMSxlMz1tLnVucGFjayx0Mz1NYXRoLnBvdyxhMz1mdW5jdGlvbigpe2Zvcih2YXIgcj1bXSxlPWFyZ3VtZW50cy5sZW5ndGg7ZS0tOylyW2VdPWFyZ3VtZW50c1tlXTtyPWUzKHIsImxhYiIpO3ZhciB0PXJbMF0sYT1yWzFdLHM9clsyXSxpLG8sYyxmLHYsaDtyZXR1cm4gbz0odCsxNikvMTE2LGk9aXNOYU4oYSk/bzpvK2EvNTAwLGM9aXNOYU4ocyk/bzpvLXMvMjAwLG89aTEuWW4qbzIobyksaT1pMS5YbipvMihpKSxjPWkxLlpuKm8yKGMpLGY9bjIoMy4yNDA0NTQyKmktMS41MzcxMzg1Km8tLjQ5ODUzMTQqYyksdj1uMigtLjk2OTI2NippKzEuODc2MDEwOCpvKy4wNDE1NTYqYyksaD1uMiguMDU1NjQzNCppLS4yMDQwMjU5Km8rMS4wNTcyMjUyKmMpLFtmLHYsaCxyLmxlbmd0aD4zP3JbM106MV19LG4yPWZ1bmN0aW9uKHIpe3JldHVybiAyNTUqKHI8PS4wMDMwND8xMi45MipyOjEuMDU1KnQzKHIsMS8yLjQpLS4wNTUpfSxvMj1mdW5jdGlvbihyKXtyZXR1cm4gcj5pMS50MT9yKnIqcjppMS50Miooci1pMS50MCl9LG5yPWEzLG4zPW0udW5wYWNrLG8zPW0udHlwZSxzMz1XLG9yPUMsc3I9RSxpMz1hcjtvci5wcm90b3R5cGUubGFiPWZ1bmN0aW9uKCl7cmV0dXJuIGkzKHRoaXMuX3JnYil9LHMzLmxhYj1mdW5jdGlvbigpe2Zvcih2YXIgcj1bXSxlPWFyZ3VtZW50cy5sZW5ndGg7ZS0tOylyW2VdPWFyZ3VtZW50c1tlXTtyZXR1cm4gbmV3KEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kLmFwcGx5KG9yLFtudWxsXS5jb25jYXQocixbImxhYiJdKSkpfSxzci5mb3JtYXQubGFiPW5yLHNyLmF1dG9kZXRlY3QucHVzaCh7cDoyLHRlc3Q6ZnVuY3Rpb24oKXtmb3IodmFyIHI9W10sZT1hcmd1bWVudHMubGVuZ3RoO2UtLTspcltlXT1hcmd1bWVudHNbZV07aWYocj1uMyhyLCJsYWIiKSxvMyhyKT09PSJhcnJheSImJnIubGVuZ3RoPT09MylyZXR1cm4ibGFiIn19KTt2YXIgYzM9bS51bnBhY2ssbDM9bS5SQUQyREVHLGYzPU1hdGguc3FydCx1Mz1NYXRoLmF0YW4yLHYzPU1hdGgucm91bmQsaDM9ZnVuY3Rpb24oKXtmb3IodmFyIHI9W10sZT1hcmd1bWVudHMubGVuZ3RoO2UtLTspcltlXT1hcmd1bWVudHNbZV07dmFyIHQ9YzMociwibGFiIiksYT10WzBdLHM9dFsxXSxpPXRbMl0sbz1mMyhzKnMraSppKSxjPSh1MyhpLHMpKmwzKzM2MCklMzYwO3JldHVybiB2MyhvKjFlNCk9PT0wJiYoYz1OdW1iZXIuTmFOKSxbYSxvLGNdfSxpcj1oMyxnMz1tLnVucGFjayxiMz1hcixkMz1pcixwMz1mdW5jdGlvbigpe2Zvcih2YXIgcj1bXSxlPWFyZ3VtZW50cy5sZW5ndGg7ZS0tOylyW2VdPWFyZ3VtZW50c1tlXTt2YXIgdD1nMyhyLCJyZ2IiKSxhPXRbMF0scz10WzFdLGk9dFsyXSxvPWIzKGEscyxpKSxjPW9bMF0sZj1vWzFdLHY9b1syXTtyZXR1cm4gZDMoYyxmLHYpfSxtMz1wMyx3Mz1tLnVucGFjayx5Mz1tLkRFRzJSQUQsXzM9TWF0aC5zaW4sazM9TWF0aC5jb3MsJDM9ZnVuY3Rpb24oKXtmb3IodmFyIHI9W10sZT1hcmd1bWVudHMubGVuZ3RoO2UtLTspcltlXT1hcmd1bWVudHNbZV07dmFyIHQ9dzMociwibGNoIiksYT10WzBdLHM9dFsxXSxpPXRbMl07cmV0dXJuIGlzTmFOKGkpJiYoaT0wKSxpPWkqeTMsW2EsazMoaSkqcyxfMyhpKSpzXX0sY3I9JDMsTTM9bS51bnBhY2ssQzM9Y3IsRjM9bnIsQTM9ZnVuY3Rpb24oKXtmb3IodmFyIHI9W10sZT1hcmd1bWVudHMubGVuZ3RoO2UtLTspcltlXT1hcmd1bWVudHNbZV07cj1NMyhyLCJsY2giKTt2YXIgdD1yWzBdLGE9clsxXSxzPXJbMl0saT1DMyh0LGEscyksbz1pWzBdLGM9aVsxXSxmPWlbMl0sdj1GMyhvLGMsZiksaD12WzBdLHc9dlsxXSxkPXZbMl07cmV0dXJuW2gsdyxkLHIubGVuZ3RoPjM/clszXToxXX0sbHI9QTMseDM9bS51bnBhY2ssUzM9bHIsSTM9ZnVuY3Rpb24oKXtmb3IodmFyIHI9W10sZT1hcmd1bWVudHMubGVuZ3RoO2UtLTspcltlXT1hcmd1bWVudHNbZV07dmFyIHQ9eDMociwiaGNsIikucmV2ZXJzZSgpO3JldHVybiBTMy5hcHBseSh2b2lkIDAsdCl9LFIzPUkzLFQzPW0udW5wYWNrLFAzPW0udHlwZSxmcj1XLEcxPUMsczI9RSx1cj1tMztHMS5wcm90b3R5cGUubGNoPWZ1bmN0aW9uKCl7cmV0dXJuIHVyKHRoaXMuX3JnYil9LEcxLnByb3RvdHlwZS5oY2w9ZnVuY3Rpb24oKXtyZXR1cm4gdXIodGhpcy5fcmdiKS5yZXZlcnNlKCl9LGZyLmxjaD1mdW5jdGlvbigpe2Zvcih2YXIgcj1bXSxlPWFyZ3VtZW50cy5sZW5ndGg7ZS0tOylyW2VdPWFyZ3VtZW50c1tlXTtyZXR1cm4gbmV3KEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kLmFwcGx5KEcxLFtudWxsXS5jb25jYXQocixbImxjaCJdKSkpfSxmci5oY2w9ZnVuY3Rpb24oKXtmb3IodmFyIHI9W10sZT1hcmd1bWVudHMubGVuZ3RoO2UtLTspcltlXT1hcmd1bWVudHNbZV07cmV0dXJuIG5ldyhGdW5jdGlvbi5wcm90b3R5cGUuYmluZC5hcHBseShHMSxbbnVsbF0uY29uY2F0KHIsWyJoY2wiXSkpKX0sczIuZm9ybWF0LmxjaD1scixzMi5mb3JtYXQuaGNsPVIzLFsibGNoIiwiaGNsIl0uZm9yRWFjaChmdW5jdGlvbihyKXtyZXR1cm4gczIuYXV0b2RldGVjdC5wdXNoKHtwOjIsdGVzdDpmdW5jdGlvbigpe2Zvcih2YXIgZT1bXSx0PWFyZ3VtZW50cy5sZW5ndGg7dC0tOyllW3RdPWFyZ3VtZW50c1t0XTtpZihlPVQzKGUsciksUDMoZSk9PT0iYXJyYXkiJiZlLmxlbmd0aD09PTMpcmV0dXJuIHJ9fSl9KTt2YXIgejM9e2FsaWNlYmx1ZToiI2YwZjhmZiIsYW50aXF1ZXdoaXRlOiIjZmFlYmQ3IixhcXVhOiIjMDBmZmZmIixhcXVhbWFyaW5lOiIjN2ZmZmQ0IixhenVyZToiI2YwZmZmZiIsYmVpZ2U6IiNmNWY1ZGMiLGJpc3F1ZToiI2ZmZTRjNCIsYmxhY2s6IiMwMDAwMDAiLGJsYW5jaGVkYWxtb25kOiIjZmZlYmNkIixibHVlOiIjMDAwMGZmIixibHVldmlvbGV0OiIjOGEyYmUyIixicm93bjoiI2E1MmEyYSIsYnVybHl3b29kOiIjZGViODg3IixjYWRldGJsdWU6IiM1ZjllYTAiLGNoYXJ0cmV1c2U6IiM3ZmZmMDAiLGNob2NvbGF0ZToiI2QyNjkxZSIsY29yYWw6IiNmZjdmNTAiLGNvcm5mbG93ZXI6IiM2NDk1ZWQiLGNvcm5mbG93ZXJibHVlOiIjNjQ5NWVkIixjb3Juc2lsazoiI2ZmZjhkYyIsY3JpbXNvbjoiI2RjMTQzYyIsY3lhbjoiIzAwZmZmZiIsZGFya2JsdWU6IiMwMDAwOGIiLGRhcmtjeWFuOiIjMDA4YjhiIixkYXJrZ29sZGVucm9kOiIjYjg4NjBiIixkYXJrZ3JheToiI2E5YTlhOSIsZGFya2dyZWVuOiIjMDA2NDAwIixkYXJrZ3JleToiI2E5YTlhOSIsZGFya2toYWtpOiIjYmRiNzZiIixkYXJrbWFnZW50YToiIzhiMDA4YiIsZGFya29saXZlZ3JlZW46IiM1NTZiMmYiLGRhcmtvcmFuZ2U6IiNmZjhjMDAiLGRhcmtvcmNoaWQ6IiM5OTMyY2MiLGRhcmtyZWQ6IiM4YjAwMDAiLGRhcmtzYWxtb246IiNlOTk2N2EiLGRhcmtzZWFncmVlbjoiIzhmYmM4ZiIsZGFya3NsYXRlYmx1ZToiIzQ4M2Q4YiIsZGFya3NsYXRlZ3JheToiIzJmNGY0ZiIsZGFya3NsYXRlZ3JleToiIzJmNGY0ZiIsZGFya3R1cnF1b2lzZToiIzAwY2VkMSIsZGFya3Zpb2xldDoiIzk0MDBkMyIsZGVlcHBpbms6IiNmZjE0OTMiLGRlZXBza3libHVlOiIjMDBiZmZmIixkaW1ncmF5OiIjNjk2OTY5IixkaW1ncmV5OiIjNjk2OTY5Iixkb2RnZXJibHVlOiIjMWU5MGZmIixmaXJlYnJpY2s6IiNiMjIyMjIiLGZsb3JhbHdoaXRlOiIjZmZmYWYwIixmb3Jlc3RncmVlbjoiIzIyOGIyMiIsZnVjaHNpYToiI2ZmMDBmZiIsZ2FpbnNib3JvOiIjZGNkY2RjIixnaG9zdHdoaXRlOiIjZjhmOGZmIixnb2xkOiIjZmZkNzAwIixnb2xkZW5yb2Q6IiNkYWE1MjAiLGdyYXk6IiM4MDgwODAiLGdyZWVuOiIjMDA4MDAwIixncmVlbnllbGxvdzoiI2FkZmYyZiIsZ3JleToiIzgwODA4MCIsaG9uZXlkZXc6IiNmMGZmZjAiLGhvdHBpbms6IiNmZjY5YjQiLGluZGlhbnJlZDoiI2NkNWM1YyIsaW5kaWdvOiIjNGIwMDgyIixpdm9yeToiI2ZmZmZmMCIsa2hha2k6IiNmMGU2OGMiLGxhc2VybGVtb246IiNmZmZmNTQiLGxhdmVuZGVyOiIjZTZlNmZhIixsYXZlbmRlcmJsdXNoOiIjZmZmMGY1IixsYXduZ3JlZW46IiM3Y2ZjMDAiLGxlbW9uY2hpZmZvbjoiI2ZmZmFjZCIsbGlnaHRibHVlOiIjYWRkOGU2IixsaWdodGNvcmFsOiIjZjA4MDgwIixsaWdodGN5YW46IiNlMGZmZmYiLGxpZ2h0Z29sZGVucm9kOiIjZmFmYWQyIixsaWdodGdvbGRlbnJvZHllbGxvdzoiI2ZhZmFkMiIsbGlnaHRncmF5OiIjZDNkM2QzIixsaWdodGdyZWVuOiIjOTBlZTkwIixsaWdodGdyZXk6IiNkM2QzZDMiLGxpZ2h0cGluazoiI2ZmYjZjMSIsbGlnaHRzYWxtb246IiNmZmEwN2EiLGxpZ2h0c2VhZ3JlZW46IiMyMGIyYWEiLGxpZ2h0c2t5Ymx1ZToiIzg3Y2VmYSIsbGlnaHRzbGF0ZWdyYXk6IiM3Nzg4OTkiLGxpZ2h0c2xhdGVncmV5OiIjNzc4ODk5IixsaWdodHN0ZWVsYmx1ZToiI2IwYzRkZSIsbGlnaHR5ZWxsb3c6IiNmZmZmZTAiLGxpbWU6IiMwMGZmMDAiLGxpbWVncmVlbjoiIzMyY2QzMiIsbGluZW46IiNmYWYwZTYiLG1hZ2VudGE6IiNmZjAwZmYiLG1hcm9vbjoiIzgwMDAwMCIsbWFyb29uMjoiIzdmMDAwMCIsbWFyb29uMzoiI2IwMzA2MCIsbWVkaXVtYXF1YW1hcmluZToiIzY2Y2RhYSIsbWVkaXVtYmx1ZToiIzAwMDBjZCIsbWVkaXVtb3JjaGlkOiIjYmE1NWQzIixtZWRpdW1wdXJwbGU6IiM5MzcwZGIiLG1lZGl1bXNlYWdyZWVuOiIjM2NiMzcxIixtZWRpdW1zbGF0ZWJsdWU6IiM3YjY4ZWUiLG1lZGl1bXNwcmluZ2dyZWVuOiIjMDBmYTlhIixtZWRpdW10dXJxdW9pc2U6IiM0OGQxY2MiLG1lZGl1bXZpb2xldHJlZDoiI2M3MTU4NSIsbWlkbmlnaHRibHVlOiIjMTkxOTcwIixtaW50Y3JlYW06IiNmNWZmZmEiLG1pc3R5cm9zZToiI2ZmZTRlMSIsbW9jY2FzaW46IiNmZmU0YjUiLG5hdmFqb3doaXRlOiIjZmZkZWFkIixuYXZ5OiIjMDAwMDgwIixvbGRsYWNlOiIjZmRmNWU2IixvbGl2ZToiIzgwODAwMCIsb2xpdmVkcmFiOiIjNmI4ZTIzIixvcmFuZ2U6IiNmZmE1MDAiLG9yYW5nZXJlZDoiI2ZmNDUwMCIsb3JjaGlkOiIjZGE3MGQ2IixwYWxlZ29sZGVucm9kOiIjZWVlOGFhIixwYWxlZ3JlZW46IiM5OGZiOTgiLHBhbGV0dXJxdW9pc2U6IiNhZmVlZWUiLHBhbGV2aW9sZXRyZWQ6IiNkYjcwOTMiLHBhcGF5YXdoaXA6IiNmZmVmZDUiLHBlYWNocHVmZjoiI2ZmZGFiOSIscGVydToiI2NkODUzZiIscGluazoiI2ZmYzBjYiIscGx1bToiI2RkYTBkZCIscG93ZGVyYmx1ZToiI2IwZTBlNiIscHVycGxlOiIjODAwMDgwIixwdXJwbGUyOiIjN2YwMDdmIixwdXJwbGUzOiIjYTAyMGYwIixyZWJlY2NhcHVycGxlOiIjNjYzMzk5IixyZWQ6IiNmZjAwMDAiLHJvc3licm93bjoiI2JjOGY4ZiIscm95YWxibHVlOiIjNDE2OWUxIixzYWRkbGVicm93bjoiIzhiNDUxMyIsc2FsbW9uOiIjZmE4MDcyIixzYW5keWJyb3duOiIjZjRhNDYwIixzZWFncmVlbjoiIzJlOGI1NyIsc2Vhc2hlbGw6IiNmZmY1ZWUiLHNpZW5uYToiI2EwNTIyZCIsc2lsdmVyOiIjYzBjMGMwIixza3libHVlOiIjODdjZWViIixzbGF0ZWJsdWU6IiM2YTVhY2QiLHNsYXRlZ3JheToiIzcwODA5MCIsc2xhdGVncmV5OiIjNzA4MDkwIixzbm93OiIjZmZmYWZhIixzcHJpbmdncmVlbjoiIzAwZmY3ZiIsc3RlZWxibHVlOiIjNDY4MmI0Iix0YW46IiNkMmI0OGMiLHRlYWw6IiMwMDgwODAiLHRoaXN0bGU6IiNkOGJmZDgiLHRvbWF0bzoiI2ZmNjM0NyIsdHVycXVvaXNlOiIjNDBlMGQwIix2aW9sZXQ6IiNlZTgyZWUiLHdoZWF0OiIjZjVkZWIzIix3aGl0ZToiI2ZmZmZmZiIsd2hpdGVzbW9rZToiI2Y1ZjVmNSIseWVsbG93OiIjZmZmZjAwIix5ZWxsb3dncmVlbjoiIzlhY2QzMiJ9LHZyPXozLEUzPUMsaHI9RSxOMz1tLnR5cGUsazE9dnIsQjM9VTIsRDM9WTI7RTMucHJvdG90eXBlLm5hbWU9ZnVuY3Rpb24oKXtmb3IodmFyIHI9RDModGhpcy5fcmdiLCJyZ2IiKSxlPTAsdD1PYmplY3Qua2V5cyhrMSk7ZTx0Lmxlbmd0aDtlKz0xKXt2YXIgYT10W2VdO2lmKGsxW2FdPT09cilyZXR1cm4gYS50b0xvd2VyQ2FzZSgpfXJldHVybiByfSxoci5mb3JtYXQubmFtZWQ9ZnVuY3Rpb24ocil7aWYocj1yLnRvTG93ZXJDYXNlKCksazFbcl0pcmV0dXJuIEIzKGsxW3JdKTt0aHJvdyBuZXcgRXJyb3IoInVua25vd24gY29sb3IgbmFtZTogIityKX0saHIuYXV0b2RldGVjdC5wdXNoKHtwOjUsdGVzdDpmdW5jdGlvbihyKXtmb3IodmFyIGU9W10sdD1hcmd1bWVudHMubGVuZ3RoLTE7dC0tID4wOyllW3RdPWFyZ3VtZW50c1t0KzFdO2lmKCFlLmxlbmd0aCYmTjMocik9PT0ic3RyaW5nIiYmazFbci50b0xvd2VyQ2FzZSgpXSlyZXR1cm4ibmFtZWQifX0pO3ZhciBMMz1tLnVucGFjayxHMz1mdW5jdGlvbigpe2Zvcih2YXIgcj1bXSxlPWFyZ3VtZW50cy5sZW5ndGg7ZS0tOylyW2VdPWFyZ3VtZW50c1tlXTt2YXIgdD1MMyhyLCJyZ2IiKSxhPXRbMF0scz10WzFdLGk9dFsyXTtyZXR1cm4oYTw8MTYpKyhzPDw4KStpfSxxMz1HMyxXMz1tLnR5cGUsSDM9ZnVuY3Rpb24ocil7aWYoVzMocik9PSJudW1iZXIiJiZyPj0wJiZyPD0xNjc3NzIxNSl7dmFyIGU9cj4+MTYsdD1yPj44JjI1NSxhPXImMjU1O3JldHVybltlLHQsYSwxXX10aHJvdyBuZXcgRXJyb3IoInVua25vd24gbnVtIGNvbG9yOiAiK3IpfSxPMz1IMyxZMz1XLGdyPUMsYnI9RSxVMz1tLnR5cGUsWDM9cTM7Z3IucHJvdG90eXBlLm51bT1mdW5jdGlvbigpe3JldHVybiBYMyh0aGlzLl9yZ2IpfSxZMy5udW09ZnVuY3Rpb24oKXtmb3IodmFyIHI9W10sZT1hcmd1bWVudHMubGVuZ3RoO2UtLTspcltlXT1hcmd1bWVudHNbZV07cmV0dXJuIG5ldyhGdW5jdGlvbi5wcm90b3R5cGUuYmluZC5hcHBseShncixbbnVsbF0uY29uY2F0KHIsWyJudW0iXSkpKX0sYnIuZm9ybWF0Lm51bT1PMyxici5hdXRvZGV0ZWN0LnB1c2goe3A6NSx0ZXN0OmZ1bmN0aW9uKCl7Zm9yKHZhciByPVtdLGU9YXJndW1lbnRzLmxlbmd0aDtlLS07KXJbZV09YXJndW1lbnRzW2VdO2lmKHIubGVuZ3RoPT09MSYmVTMoclswXSk9PT0ibnVtYmVyIiYmclswXT49MCYmclswXTw9MTY3NzcyMTUpcmV0dXJuIm51bSJ9fSk7dmFyIFYzPVcsaTI9Qyxkcj1FLHByPW0udW5wYWNrLG1yPW0udHlwZSx3cj1NYXRoLnJvdW5kO2kyLnByb3RvdHlwZS5yZ2I9ZnVuY3Rpb24ocil7cmV0dXJuIHI9PT12b2lkIDAmJihyPSEwKSxyPT09ITE/dGhpcy5fcmdiLnNsaWNlKDAsMyk6dGhpcy5fcmdiLnNsaWNlKDAsMykubWFwKHdyKX0saTIucHJvdG90eXBlLnJnYmE9ZnVuY3Rpb24ocil7cmV0dXJuIHI9PT12b2lkIDAmJihyPSEwKSx0aGlzLl9yZ2Iuc2xpY2UoMCw0KS5tYXAoZnVuY3Rpb24oZSx0KXtyZXR1cm4gdDwzP3I9PT0hMT9lOndyKGUpOmV9KX0sVjMucmdiPWZ1bmN0aW9uKCl7Zm9yKHZhciByPVtdLGU9YXJndW1lbnRzLmxlbmd0aDtlLS07KXJbZV09YXJndW1lbnRzW2VdO3JldHVybiBuZXcoRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQuYXBwbHkoaTIsW251bGxdLmNvbmNhdChyLFsicmdiIl0pKSl9LGRyLmZvcm1hdC5yZ2I9ZnVuY3Rpb24oKXtmb3IodmFyIHI9W10sZT1hcmd1bWVudHMubGVuZ3RoO2UtLTspcltlXT1hcmd1bWVudHNbZV07dmFyIHQ9cHIociwicmdiYSIpO3JldHVybiB0WzNdPT09dm9pZCAwJiYodFszXT0xKSx0fSxkci5hdXRvZGV0ZWN0LnB1c2goe3A6Myx0ZXN0OmZ1bmN0aW9uKCl7Zm9yKHZhciByPVtdLGU9YXJndW1lbnRzLmxlbmd0aDtlLS07KXJbZV09YXJndW1lbnRzW2VdO2lmKHI9cHIociwicmdiYSIpLG1yKHIpPT09ImFycmF5IiYmKHIubGVuZ3RoPT09M3x8ci5sZW5ndGg9PT00JiZtcihyWzNdKT09Im51bWJlciImJnJbM10+PTAmJnJbM108PTEpKXJldHVybiJyZ2IifX0pO3ZhciBxMT1NYXRoLmxvZyxqMz1mdW5jdGlvbihyKXt2YXIgZT1yLzEwMCx0LGEscztyZXR1cm4gZTw2Nj8odD0yNTUsYT1lPDY/MDotMTU1LjI1NDg1NTYyNzA5MTc5LS40NDU5Njk1MDQ2OTU3OTEzMyooYT1lLTIpKzEwNC40OTIxNjE5OTM5Mzg4OCpxMShhKSxzPWU8MjA/MDotMjU0Ljc2OTM1MTg0MTIwOTAyKy44Mjc0MDk2MDY0MDA3Mzk1KihzPWUtMTApKzExNS42Nzk5NDQwMTA2NjE0NypxMShzKSk6KHQ9MzUxLjk3NjkwNTY2ODA1NjkzKy4xMTQyMDY0NTM3ODQxNjUqKHQ9ZS01NSktNDAuMjUzNjYzMDkzMzIxMjcqcTEodCksYT0zMjUuNDQ5NDEyNTcxMTk3NCsuMDc5NDM0NTY1MzY2NjIzNDIqKGE9ZS01MCktMjguMDg1Mjk2MzUwNzk1NypxMShhKSxzPTI1NSksW3QsYSxzLDFdfSx5cj1qMyxaMz15cixRMz1tLnVucGFjayxKMz1NYXRoLnJvdW5kLEszPWZ1bmN0aW9uKCl7Zm9yKHZhciByPVtdLGU9YXJndW1lbnRzLmxlbmd0aDtlLS07KXJbZV09YXJndW1lbnRzW2VdO2Zvcih2YXIgdD1RMyhyLCJyZ2IiKSxhPXRbMF0scz10WzJdLGk9MWUzLG89NGU0LGM9LjQsZjtvLWk+Yzspe2Y9KG8raSkqLjU7dmFyIHY9WjMoZik7dlsyXS92WzBdPj1zL2E/bz1mOmk9Zn1yZXR1cm4gSjMoZil9LHI5PUszLGMyPVcsVzE9QyxsMj1FLGU5PXI5O1cxLnByb3RvdHlwZS50ZW1wPVcxLnByb3RvdHlwZS5rZWx2aW49VzEucHJvdG90eXBlLnRlbXBlcmF0dXJlPWZ1bmN0aW9uKCl7cmV0dXJuIGU5KHRoaXMuX3JnYil9LGMyLnRlbXA9YzIua2VsdmluPWMyLnRlbXBlcmF0dXJlPWZ1bmN0aW9uKCl7Zm9yKHZhciByPVtdLGU9YXJndW1lbnRzLmxlbmd0aDtlLS07KXJbZV09YXJndW1lbnRzW2VdO3JldHVybiBuZXcoRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQuYXBwbHkoVzEsW251bGxdLmNvbmNhdChyLFsidGVtcCJdKSkpfSxsMi5mb3JtYXQudGVtcD1sMi5mb3JtYXQua2VsdmluPWwyLmZvcm1hdC50ZW1wZXJhdHVyZT15cjt2YXIgdDk9bS51bnBhY2ssZjI9TWF0aC5jYnJ0LGE5PU1hdGgucG93LG45PU1hdGguc2lnbixvOT1mdW5jdGlvbigpe2Zvcih2YXIgcj1bXSxlPWFyZ3VtZW50cy5sZW5ndGg7ZS0tOylyW2VdPWFyZ3VtZW50c1tlXTt2YXIgdD10OShyLCJyZ2IiKSxhPXRbMF0scz10WzFdLGk9dFsyXSxvPVt1MihhLzI1NSksdTIocy8yNTUpLHUyKGkvMjU1KV0sYz1vWzBdLGY9b1sxXSx2PW9bMl0saD1mMiguNDEyMjIxNDcwOCpjKy41MzYzMzI1MzYzKmYrLjA1MTQ0NTk5Mjkqdiksdz1mMiguMjExOTAzNDk4MipjKy42ODA2OTk1NDUxKmYrLjEwNzM5Njk1NjYqdiksZD1mMiguMDg4MzAyNDYxOSpjKy4yODE3MTg4Mzc2KmYrLjYyOTk3ODcwMDUqdik7cmV0dXJuWy4yMTA0NTQyNTUzKmgrLjc5MzYxNzc4NSp3LS4wMDQwNzIwNDY4KmQsMS45Nzc5OTg0OTUxKmgtMi40Mjg1OTIyMDUqdysuNDUwNTkzNzA5OSpkLC4wMjU5MDQwMzcxKmgrLjc4Mjc3MTc2NjIqdy0uODA4Njc1NzY2KmRdfSxfcj1vOTtmdW5jdGlvbiB1MihyKXt2YXIgZT1NYXRoLmFicyhyKTtyZXR1cm4gZTwuMDQwNDU/ci8xMi45Mjoobjkocil8fDEpKmE5KChlKy4wNTUpLzEuMDU1LDIuNCl9dmFyIHM5PW0udW5wYWNrLEgxPU1hdGgucG93LGk5PU1hdGguc2lnbixjOT1mdW5jdGlvbigpe2Zvcih2YXIgcj1bXSxlPWFyZ3VtZW50cy5sZW5ndGg7ZS0tOylyW2VdPWFyZ3VtZW50c1tlXTtyPXM5KHIsImxhYiIpO3ZhciB0PXJbMF0sYT1yWzFdLHM9clsyXSxpPUgxKHQrLjM5NjMzNzc3NzQqYSsuMjE1ODAzNzU3MypzLDMpLG89SDEodC0uMTA1NTYxMzQ1OCphLS4wNjM4NTQxNzI4KnMsMyksYz1IMSh0LS4wODk0ODQxNzc1KmEtMS4yOTE0ODU1NDgqcywzKTtyZXR1cm5bMjU1KnYyKDQuMDc2NzQxNjYyMSppLTMuMzA3NzExNTkxMypvKy4yMzA5Njk5MjkyKmMpLDI1NSp2MigtMS4yNjg0MzgwMDQ2KmkrMi42MDk3NTc0MDExKm8tLjM0MTMxOTM5NjUqYyksMjU1KnYyKC0uMDA0MTk2MDg2MyppLS43MDM0MTg2MTQ3Km8rMS43MDc2MTQ3MDEqYyksci5sZW5ndGg+Mz9yWzNdOjFdfSxrcj1jOTtmdW5jdGlvbiB2MihyKXt2YXIgZT1NYXRoLmFicyhyKTtyZXR1cm4gZT4uMDAzMTMwOD8oaTkocil8fDEpKigxLjA1NSpIMShlLDEvMi40KS0uMDU1KTpyKjEyLjkyfXZhciBsOT1tLnVucGFjayxmOT1tLnR5cGUsdTk9Vywkcj1DLE1yPUUsdjk9X3I7JHIucHJvdG90eXBlLm9rbGFiPWZ1bmN0aW9uKCl7cmV0dXJuIHY5KHRoaXMuX3JnYil9LHU5Lm9rbGFiPWZ1bmN0aW9uKCl7Zm9yKHZhciByPVtdLGU9YXJndW1lbnRzLmxlbmd0aDtlLS07KXJbZV09YXJndW1lbnRzW2VdO3JldHVybiBuZXcoRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQuYXBwbHkoJHIsW251bGxdLmNvbmNhdChyLFsib2tsYWIiXSkpKX0sTXIuZm9ybWF0Lm9rbGFiPWtyLE1yLmF1dG9kZXRlY3QucHVzaCh7cDozLHRlc3Q6ZnVuY3Rpb24oKXtmb3IodmFyIHI9W10sZT1hcmd1bWVudHMubGVuZ3RoO2UtLTspcltlXT1hcmd1bWVudHNbZV07aWYocj1sOShyLCJva2xhYiIpLGY5KHIpPT09ImFycmF5IiYmci5sZW5ndGg9PT0zKXJldHVybiJva2xhYiJ9fSk7dmFyIGg5PW0udW5wYWNrLGc5PV9yLGI5PWlyLGQ5PWZ1bmN0aW9uKCl7Zm9yKHZhciByPVtdLGU9YXJndW1lbnRzLmxlbmd0aDtlLS07KXJbZV09YXJndW1lbnRzW2VdO3ZhciB0PWg5KHIsInJnYiIpLGE9dFswXSxzPXRbMV0saT10WzJdLG89ZzkoYSxzLGkpLGM9b1swXSxmPW9bMV0sdj1vWzJdO3JldHVybiBiOShjLGYsdil9LHA5PWQ5LG05PW0udW5wYWNrLHc5PWNyLHk5PWtyLF85PWZ1bmN0aW9uKCl7Zm9yKHZhciByPVtdLGU9YXJndW1lbnRzLmxlbmd0aDtlLS07KXJbZV09YXJndW1lbnRzW2VdO3I9bTkociwibGNoIik7dmFyIHQ9clswXSxhPXJbMV0scz1yWzJdLGk9dzkodCxhLHMpLG89aVswXSxjPWlbMV0sZj1pWzJdLHY9eTkobyxjLGYpLGg9dlswXSx3PXZbMV0sZD12WzJdO3JldHVybltoLHcsZCxyLmxlbmd0aD4zP3JbM106MV19LGs5PV85LCQ5PW0udW5wYWNrLE05PW0udHlwZSxDOT1XLENyPUMsRnI9RSxGOT1wOTtDci5wcm90b3R5cGUub2tsY2g9ZnVuY3Rpb24oKXtyZXR1cm4gRjkodGhpcy5fcmdiKX0sQzkub2tsY2g9ZnVuY3Rpb24oKXtmb3IodmFyIHI9W10sZT1hcmd1bWVudHMubGVuZ3RoO2UtLTspcltlXT1hcmd1bWVudHNbZV07cmV0dXJuIG5ldyhGdW5jdGlvbi5wcm90b3R5cGUuYmluZC5hcHBseShDcixbbnVsbF0uY29uY2F0KHIsWyJva2xjaCJdKSkpfSxGci5mb3JtYXQub2tsY2g9azksRnIuYXV0b2RldGVjdC5wdXNoKHtwOjMsdGVzdDpmdW5jdGlvbigpe2Zvcih2YXIgcj1bXSxlPWFyZ3VtZW50cy5sZW5ndGg7ZS0tOylyW2VdPWFyZ3VtZW50c1tlXTtpZihyPSQ5KHIsIm9rbGNoIiksTTkocik9PT0iYXJyYXkiJiZyLmxlbmd0aD09PTMpcmV0dXJuIm9rbGNoIn19KTt2YXIgQXI9QyxBOT1tLnR5cGU7QXIucHJvdG90eXBlLmFscGhhPWZ1bmN0aW9uKHIsZSl7cmV0dXJuIGU9PT12b2lkIDAmJihlPSExKSxyIT09dm9pZCAwJiZBOShyKT09PSJudW1iZXIiP2U/KHRoaXMuX3JnYlszXT1yLHRoaXMpOm5ldyBBcihbdGhpcy5fcmdiWzBdLHRoaXMuX3JnYlsxXSx0aGlzLl9yZ2JbMl0scl0sInJnYiIpOnRoaXMuX3JnYlszXX07dmFyIHg5PUM7eDkucHJvdG90eXBlLmNsaXBwZWQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fcmdiLl9jbGlwcGVkfHwhMX07dmFyIFEwPUMsUzk9TDE7UTAucHJvdG90eXBlLmRhcmtlbj1mdW5jdGlvbihyKXtyPT09dm9pZCAwJiYocj0xKTt2YXIgZT10aGlzLHQ9ZS5sYWIoKTtyZXR1cm4gdFswXS09UzkuS24qcixuZXcgUTAodCwibGFiIikuYWxwaGEoZS5hbHBoYSgpLCEwKX0sUTAucHJvdG90eXBlLmJyaWdodGVuPWZ1bmN0aW9uKHIpe3JldHVybiByPT09dm9pZCAwJiYocj0xKSx0aGlzLmRhcmtlbigtcil9LFEwLnByb3RvdHlwZS5kYXJrZXI9UTAucHJvdG90eXBlLmRhcmtlbixRMC5wcm90b3R5cGUuYnJpZ2h0ZXI9UTAucHJvdG90eXBlLmJyaWdodGVuO3ZhciBJOT1DO0k5LnByb3RvdHlwZS5nZXQ9ZnVuY3Rpb24ocil7dmFyIGU9ci5zcGxpdCgiLiIpLHQ9ZVswXSxhPWVbMV0scz10aGlzW3RdKCk7aWYoYSl7dmFyIGk9dC5pbmRleE9mKGEpLSh0LnN1YnN0cigwLDIpPT09Im9rIj8yOjApO2lmKGk+LTEpcmV0dXJuIHNbaV07dGhyb3cgbmV3IEVycm9yKCJ1bmtub3duIGNoYW5uZWwgIithKyIgaW4gbW9kZSAiK3QpfWVsc2UgcmV0dXJuIHN9O3ZhciBjMT1DLFI5PW0udHlwZSxUOT1NYXRoLnBvdyxQOT0xZS03LHo5PTIwO2MxLnByb3RvdHlwZS5sdW1pbmFuY2U9ZnVuY3Rpb24ocil7aWYociE9PXZvaWQgMCYmUjkocik9PT0ibnVtYmVyIil7aWYocj09PTApcmV0dXJuIG5ldyBjMShbMCwwLDAsdGhpcy5fcmdiWzNdXSwicmdiIik7aWYocj09PTEpcmV0dXJuIG5ldyBjMShbMjU1LDI1NSwyNTUsdGhpcy5fcmdiWzNdXSwicmdiIik7dmFyIGU9dGhpcy5sdW1pbmFuY2UoKSx0PSJyZ2IiLGE9ejkscz1mdW5jdGlvbihvLGMpe3ZhciBmPW8uaW50ZXJwb2xhdGUoYywuNSx0KSx2PWYubHVtaW5hbmNlKCk7cmV0dXJuIE1hdGguYWJzKHItdik8UDl8fCFhLS0/Zjp2PnI/cyhvLGYpOnMoZixjKX0saT0oZT5yP3MobmV3IGMxKFswLDAsMF0pLHRoaXMpOnModGhpcyxuZXcgYzEoWzI1NSwyNTUsMjU1XSkpKS5yZ2IoKTtyZXR1cm4gbmV3IGMxKGkuY29uY2F0KFt0aGlzLl9yZ2JbM11dKSl9cmV0dXJuIEU5LmFwcGx5KHZvaWQgMCx0aGlzLl9yZ2Iuc2xpY2UoMCwzKSl9O3ZhciBFOT1mdW5jdGlvbihyLGUsdCl7cmV0dXJuIHI9aDIociksZT1oMihlKSx0PWgyKHQpLC4yMTI2KnIrLjcxNTIqZSsuMDcyMip0fSxoMj1mdW5jdGlvbihyKXtyZXR1cm4gci89MjU1LHI8PS4wMzkyOD9yLzEyLjkyOlQ5KChyKy4wNTUpLzEuMDU1LDIuNCl9LGwwPXt9LHhyPUMsU3I9bS50eXBlLE8xPWwwLElyPWZ1bmN0aW9uKHIsZSx0KXt0PT09dm9pZCAwJiYodD0uNSk7Zm9yKHZhciBhPVtdLHM9YXJndW1lbnRzLmxlbmd0aC0zO3MtLSA+MDspYVtzXT1hcmd1bWVudHNbcyszXTt2YXIgaT1hWzBdfHwibHJnYiI7aWYoIU8xW2ldJiYhYS5sZW5ndGgmJihpPU9iamVjdC5rZXlzKE8xKVswXSksIU8xW2ldKXRocm93IG5ldyBFcnJvcigiaW50ZXJwb2xhdGlvbiBtb2RlICIraSsiIGlzIG5vdCBkZWZpbmVkIik7cmV0dXJuIFNyKHIpIT09Im9iamVjdCImJihyPW5ldyB4cihyKSksU3IoZSkhPT0ib2JqZWN0IiYmKGU9bmV3IHhyKGUpKSxPMVtpXShyLGUsdCkuYWxwaGEoci5hbHBoYSgpK3QqKGUuYWxwaGEoKS1yLmFscGhhKCkpKX0sUnI9QyxOOT1JcjtSci5wcm90b3R5cGUubWl4PVJyLnByb3RvdHlwZS5pbnRlcnBvbGF0ZT1mdW5jdGlvbihyLGUpe2U9PT12b2lkIDAmJihlPS41KTtmb3IodmFyIHQ9W10sYT1hcmd1bWVudHMubGVuZ3RoLTI7YS0tID4wOyl0W2FdPWFyZ3VtZW50c1thKzJdO3JldHVybiBOOS5hcHBseSh2b2lkIDAsW3RoaXMscixlXS5jb25jYXQodCkpfTt2YXIgVHI9QztUci5wcm90b3R5cGUucHJlbXVsdGlwbHk9ZnVuY3Rpb24ocil7cj09PXZvaWQgMCYmKHI9ITEpO3ZhciBlPXRoaXMuX3JnYix0PWVbM107cmV0dXJuIHI/KHRoaXMuX3JnYj1bZVswXSp0LGVbMV0qdCxlWzJdKnQsdF0sdGhpcyk6bmV3IFRyKFtlWzBdKnQsZVsxXSp0LGVbMl0qdCx0XSwicmdiIil9O3ZhciBnMj1DLEI5PUwxO2cyLnByb3RvdHlwZS5zYXR1cmF0ZT1mdW5jdGlvbihyKXtyPT09dm9pZCAwJiYocj0xKTt2YXIgZT10aGlzLHQ9ZS5sY2goKTtyZXR1cm4gdFsxXSs9QjkuS24qcix0WzFdPDAmJih0WzFdPTApLG5ldyBnMih0LCJsY2giKS5hbHBoYShlLmFscGhhKCksITApfSxnMi5wcm90b3R5cGUuZGVzYXR1cmF0ZT1mdW5jdGlvbihyKXtyZXR1cm4gcj09PXZvaWQgMCYmKHI9MSksdGhpcy5zYXR1cmF0ZSgtcil9O3ZhciBQcj1DLHpyPW0udHlwZTtQci5wcm90b3R5cGUuc2V0PWZ1bmN0aW9uKHIsZSx0KXt0PT09dm9pZCAwJiYodD0hMSk7dmFyIGE9ci5zcGxpdCgiLiIpLHM9YVswXSxpPWFbMV0sbz10aGlzW3NdKCk7aWYoaSl7dmFyIGM9cy5pbmRleE9mKGkpLShzLnN1YnN0cigwLDIpPT09Im9rIj8yOjApO2lmKGM+LTEpe2lmKHpyKGUpPT0ic3RyaW5nIilzd2l0Y2goZS5jaGFyQXQoMCkpe2Nhc2UiKyI6b1tjXSs9K2U7YnJlYWs7Y2FzZSItIjpvW2NdKz0rZTticmVhaztjYXNlIioiOm9bY10qPStlLnN1YnN0cigxKTticmVhaztjYXNlIi8iOm9bY10vPStlLnN1YnN0cigxKTticmVhaztkZWZhdWx0Om9bY109K2V9ZWxzZSBpZih6cihlKT09PSJudW1iZXIiKW9bY109ZTtlbHNlIHRocm93IG5ldyBFcnJvcigidW5zdXBwb3J0ZWQgdmFsdWUgZm9yIENvbG9yLnNldCIpO3ZhciBmPW5ldyBQcihvLHMpO3JldHVybiB0Pyh0aGlzLl9yZ2I9Zi5fcmdiLHRoaXMpOmZ9dGhyb3cgbmV3IEVycm9yKCJ1bmtub3duIGNoYW5uZWwgIitpKyIgaW4gbW9kZSAiK3MpfWVsc2UgcmV0dXJuIG99O3ZhciBEOT1DLEw5PWZ1bmN0aW9uKHIsZSx0KXt2YXIgYT1yLl9yZ2Iscz1lLl9yZ2I7cmV0dXJuIG5ldyBEOShhWzBdK3QqKHNbMF0tYVswXSksYVsxXSt0KihzWzFdLWFbMV0pLGFbMl0rdCooc1syXS1hWzJdKSwicmdiIil9O2wwLnJnYj1MOTt2YXIgRzk9QyxiMj1NYXRoLnNxcnQsbDE9TWF0aC5wb3cscTk9ZnVuY3Rpb24ocixlLHQpe3ZhciBhPXIuX3JnYixzPWFbMF0saT1hWzFdLG89YVsyXSxjPWUuX3JnYixmPWNbMF0sdj1jWzFdLGg9Y1syXTtyZXR1cm4gbmV3IEc5KGIyKGwxKHMsMikqKDEtdCkrbDEoZiwyKSp0KSxiMihsMShpLDIpKigxLXQpK2wxKHYsMikqdCksYjIobDEobywyKSooMS10KStsMShoLDIpKnQpLCJyZ2IiKX07bDAubHJnYj1xOTt2YXIgVzk9QyxIOT1mdW5jdGlvbihyLGUsdCl7dmFyIGE9ci5sYWIoKSxzPWUubGFiKCk7cmV0dXJuIG5ldyBXOShhWzBdK3QqKHNbMF0tYVswXSksYVsxXSt0KihzWzFdLWFbMV0pLGFbMl0rdCooc1syXS1hWzJdKSwibGFiIil9O2wwLmxhYj1IOTt2YXIgRXI9QyxmMT1mdW5jdGlvbihyLGUsdCxhKXt2YXIgcyxpLG8sYzthPT09ImhzbCI/KG89ci5oc2woKSxjPWUuaHNsKCkpOmE9PT0iaHN2Ij8obz1yLmhzdigpLGM9ZS5oc3YoKSk6YT09PSJoY2ciPyhvPXIuaGNnKCksYz1lLmhjZygpKTphPT09ImhzaSI/KG89ci5oc2koKSxjPWUuaHNpKCkpOmE9PT0ibGNoInx8YT09PSJoY2wiPyhhPSJoY2wiLG89ci5oY2woKSxjPWUuaGNsKCkpOmE9PT0ib2tsY2giJiYobz1yLm9rbGNoKCkucmV2ZXJzZSgpLGM9ZS5va2xjaCgpLnJldmVyc2UoKSk7dmFyIGYsdixoLHcsZCxfOyhhLnN1YnN0cigwLDEpPT09ImgifHxhPT09Im9rbGNoIikmJihzPW8sZj1zWzBdLGg9c1sxXSxkPXNbMl0saT1jLHY9aVswXSx3PWlbMV0sXz1pWzJdKTt2YXIgeSxTLFAsQjtyZXR1cm4haXNOYU4oZikmJiFpc05hTih2KT8odj5mJiZ2LWY+MTgwP0I9di0oZiszNjApOnY8ZiYmZi12PjE4MD9CPXYrMzYwLWY6Qj12LWYsUz1mK3QqQik6aXNOYU4oZik/aXNOYU4odik/Uz1OdW1iZXIuTmFOOihTPXYsKGQ9PTF8fGQ9PTApJiZhIT0iaHN2IiYmKHk9dykpOihTPWYsKF89PTF8fF89PTApJiZhIT0iaHN2IiYmKHk9aCkpLHk9PT12b2lkIDAmJih5PWgrdCoody1oKSksUD1kK3QqKF8tZCksYT09PSJva2xjaCI/bmV3IEVyKFtQLHksU10sYSk6bmV3IEVyKFtTLHksUF0sYSl9LE85PWYxLE5yPWZ1bmN0aW9uKHIsZSx0KXtyZXR1cm4gTzkocixlLHQsImxjaCIpfTtsMC5sY2g9TnIsbDAuaGNsPU5yO3ZhciBZOT1DLFU5PWZ1bmN0aW9uKHIsZSx0KXt2YXIgYT1yLm51bSgpLHM9ZS5udW0oKTtyZXR1cm4gbmV3IFk5KGErdCoocy1hKSwibnVtIil9O2wwLm51bT1VOTt2YXIgWDk9ZjEsVjk9ZnVuY3Rpb24ocixlLHQpe3JldHVybiBYOShyLGUsdCwiaGNnIil9O2wwLmhjZz1WOTt2YXIgajk9ZjEsWjk9ZnVuY3Rpb24ocixlLHQpe3JldHVybiBqOShyLGUsdCwiaHNpIil9O2wwLmhzaT1aOTt2YXIgUTk9ZjEsSjk9ZnVuY3Rpb24ocixlLHQpe3JldHVybiBROShyLGUsdCwiaHNsIil9O2wwLmhzbD1KOTt2YXIgSzk9ZjEscjU9ZnVuY3Rpb24ocixlLHQpe3JldHVybiBLOShyLGUsdCwiaHN2Iil9O2wwLmhzdj1yNTt2YXIgZTU9Qyx0NT1mdW5jdGlvbihyLGUsdCl7dmFyIGE9ci5va2xhYigpLHM9ZS5va2xhYigpO3JldHVybiBuZXcgZTUoYVswXSt0KihzWzBdLWFbMF0pLGFbMV0rdCooc1sxXS1hWzFdKSxhWzJdK3QqKHNbMl0tYVsyXSksIm9rbGFiIil9O2wwLm9rbGFiPXQ1O3ZhciBhNT1mMSxuNT1mdW5jdGlvbihyLGUsdCl7cmV0dXJuIGE1KHIsZSx0LCJva2xjaCIpfTtsMC5va2xjaD1uNTt2YXIgZDI9QyxvNT1tLmNsaXBfcmdiLHAyPU1hdGgucG93LG0yPU1hdGguc3FydCx3Mj1NYXRoLlBJLEJyPU1hdGguY29zLERyPU1hdGguc2luLHM1PU1hdGguYXRhbjIsaTU9ZnVuY3Rpb24ocixlLHQpe2U9PT12b2lkIDAmJihlPSJscmdiIiksdD09PXZvaWQgMCYmKHQ9bnVsbCk7dmFyIGE9ci5sZW5ndGg7dHx8KHQ9QXJyYXkuZnJvbShuZXcgQXJyYXkoYSkpLm1hcChmdW5jdGlvbigpe3JldHVybiAxfSkpO3ZhciBzPWEvdC5yZWR1Y2UoZnVuY3Rpb24oUyxQKXtyZXR1cm4gUytQfSk7aWYodC5mb3JFYWNoKGZ1bmN0aW9uKFMsUCl7dFtQXSo9c30pLHI9ci5tYXAoZnVuY3Rpb24oUyl7cmV0dXJuIG5ldyBkMihTKX0pLGU9PT0ibHJnYiIpcmV0dXJuIGM1KHIsdCk7Zm9yKHZhciBpPXIuc2hpZnQoKSxvPWkuZ2V0KGUpLGM9W10sZj0wLHY9MCxoPTA7aDxvLmxlbmd0aDtoKyspaWYob1toXT0ob1toXXx8MCkqdFswXSxjLnB1c2goaXNOYU4ob1toXSk/MDp0WzBdKSxlLmNoYXJBdChoKT09PSJoIiYmIWlzTmFOKG9baF0pKXt2YXIgdz1vW2hdLzE4MCp3MjtmKz1Ccih3KSp0WzBdLHYrPURyKHcpKnRbMF19dmFyIGQ9aS5hbHBoYSgpKnRbMF07ci5mb3JFYWNoKGZ1bmN0aW9uKFMsUCl7dmFyIEI9Uy5nZXQoZSk7ZCs9Uy5hbHBoYSgpKnRbUCsxXTtmb3IodmFyIEw9MDtMPG8ubGVuZ3RoO0wrKylpZighaXNOYU4oQltMXSkpaWYoY1tMXSs9dFtQKzFdLGUuY2hhckF0KEwpPT09ImgiKXt2YXIgSj1CW0xdLzE4MCp3MjtmKz1CcihKKSp0W1ArMV0sdis9RHIoSikqdFtQKzFdfWVsc2Ugb1tMXSs9QltMXSp0W1ArMV19KTtmb3IodmFyIF89MDtfPG8ubGVuZ3RoO18rKylpZihlLmNoYXJBdChfKT09PSJoIil7Zm9yKHZhciB5PXM1KHYvY1tfXSxmL2NbX10pL3cyKjE4MDt5PDA7KXkrPTM2MDtmb3IoO3k+PTM2MDspeS09MzYwO29bX109eX1lbHNlIG9bX109b1tfXS9jW19dO3JldHVybiBkLz1hLG5ldyBkMihvLGUpLmFscGhhKGQ+Ljk5OTk5PzE6ZCwhMCl9LGM1PWZ1bmN0aW9uKHIsZSl7Zm9yKHZhciB0PXIubGVuZ3RoLGE9WzAsMCwwLDBdLHM9MDtzPHIubGVuZ3RoO3MrKyl7dmFyIGk9cltzXSxvPWVbc10vdCxjPWkuX3JnYjthWzBdKz1wMihjWzBdLDIpKm8sYVsxXSs9cDIoY1sxXSwyKSpvLGFbMl0rPXAyKGNbMl0sMikqbyxhWzNdKz1jWzNdKm99cmV0dXJuIGFbMF09bTIoYVswXSksYVsxXT1tMihhWzFdKSxhWzJdPW0yKGFbMl0pLGFbM10+Ljk5OTk5OTkmJihhWzNdPTEpLG5ldyBkMihvNShhKSl9LGcwPVcsdTE9bS50eXBlLGw1PU1hdGgucG93LHkyPWZ1bmN0aW9uKHIpe3ZhciBlPSJyZ2IiLHQ9ZzAoIiNjY2MiKSxhPTAscz1bMCwxXSxpPVtdLG89WzAsMF0sYz0hMSxmPVtdLHY9ITEsaD0wLHc9MSxkPSExLF89e30seT0hMCxTPTEsUD1mdW5jdGlvbihwKXtpZihwPXB8fFsiI2ZmZiIsIiMwMDAiXSxwJiZ1MShwKT09PSJzdHJpbmciJiZnMC5icmV3ZXImJmcwLmJyZXdlcltwLnRvTG93ZXJDYXNlKCldJiYocD1nMC5icmV3ZXJbcC50b0xvd2VyQ2FzZSgpXSksdTEocCk9PT0iYXJyYXkiKXtwLmxlbmd0aD09PTEmJihwPVtwWzBdLHBbMF1dKSxwPXAuc2xpY2UoMCk7Zm9yKHZhciBGPTA7RjxwLmxlbmd0aDtGKyspcFtGXT1nMChwW0ZdKTtpLmxlbmd0aD0wO2Zvcih2YXIgVD0wO1Q8cC5sZW5ndGg7VCsrKWkucHVzaChULyhwLmxlbmd0aC0xKSl9cmV0dXJuIG8wKCksZj1wfSxCPWZ1bmN0aW9uKHApe2lmKGMhPW51bGwpe2Zvcih2YXIgRj1jLmxlbmd0aC0xLFQ9MDtUPEYmJnA+PWNbVF07KVQrKztyZXR1cm4gVC0xfXJldHVybiAwfSxMPWZ1bmN0aW9uKHApe3JldHVybiBwfSxKPWZ1bmN0aW9uKHApe3JldHVybiBwfSxaPWZ1bmN0aW9uKHAsRil7dmFyIFQsSTtpZihGPT1udWxsJiYoRj0hMSksaXNOYU4ocCl8fHA9PT1udWxsKXJldHVybiB0O2lmKEYpST1wO2Vsc2UgaWYoYyYmYy5sZW5ndGg+Mil7dmFyIEs9QihwKTtJPUsvKGMubGVuZ3RoLTIpfWVsc2UgdyE9PWg/ST0ocC1oKS8ody1oKTpJPTE7ST1KKEkpLEZ8fChJPUwoSSkpLFMhPT0xJiYoST1sNShJLFMpKSxJPW9bMF0rSSooMS1vWzBdLW9bMV0pLEk9TWF0aC5taW4oMSxNYXRoLm1heCgwLEkpKTt2YXIgWT1NYXRoLmZsb29yKEkqMWU0KTtpZih5JiZfW1ldKVQ9X1tZXTtlbHNle2lmKHUxKGYpPT09ImFycmF5Iilmb3IodmFyIEQ9MDtEPGkubGVuZ3RoO0QrKyl7dmFyIEc9aVtEXTtpZihJPD1HKXtUPWZbRF07YnJlYWt9aWYoST49RyYmRD09PWkubGVuZ3RoLTEpe1Q9ZltEXTticmVha31pZihJPkcmJkk8aVtEKzFdKXtJPShJLUcpLyhpW0QrMV0tRyksVD1nMC5pbnRlcnBvbGF0ZShmW0RdLGZbRCsxXSxJLGUpO2JyZWFrfX1lbHNlIHUxKGYpPT09ImZ1bmN0aW9uIiYmKFQ9ZihJKSk7eSYmKF9bWV09VCl9cmV0dXJuIFR9LG8wPWZ1bmN0aW9uKCl7cmV0dXJuIF89e319O1Aocik7dmFyIE49ZnVuY3Rpb24ocCl7dmFyIEY9ZzAoWihwKSk7cmV0dXJuIHYmJkZbdl0/Rlt2XSgpOkZ9O3JldHVybiBOLmNsYXNzZXM9ZnVuY3Rpb24ocCl7aWYocCE9bnVsbCl7aWYodTEocCk9PT0iYXJyYXkiKWM9cCxzPVtwWzBdLHBbcC5sZW5ndGgtMV1dO2Vsc2V7dmFyIEY9ZzAuYW5hbHl6ZShzKTtwPT09MD9jPVtGLm1pbixGLm1heF06Yz1nMC5saW1pdHMoRiwiZSIscCl9cmV0dXJuIE59cmV0dXJuIGN9LE4uZG9tYWluPWZ1bmN0aW9uKHApe2lmKCFhcmd1bWVudHMubGVuZ3RoKXJldHVybiBzO2g9cFswXSx3PXBbcC5sZW5ndGgtMV0saT1bXTt2YXIgRj1mLmxlbmd0aDtpZihwLmxlbmd0aD09PUYmJmghPT13KWZvcih2YXIgVD0wLEk9QXJyYXkuZnJvbShwKTtUPEkubGVuZ3RoO1QrPTEpe3ZhciBLPUlbVF07aS5wdXNoKChLLWgpLyh3LWgpKX1lbHNle2Zvcih2YXIgWT0wO1k8RjtZKyspaS5wdXNoKFkvKEYtMSkpO2lmKHAubGVuZ3RoPjIpe3ZhciBEPXAubWFwKGZ1bmN0aW9uKHEsSCl7cmV0dXJuIEgvKHAubGVuZ3RoLTEpfSksRz1wLm1hcChmdW5jdGlvbihxKXtyZXR1cm4ocS1oKS8ody1oKX0pO0cuZXZlcnkoZnVuY3Rpb24ocSxIKXtyZXR1cm4gRFtIXT09PXF9KXx8KEo9ZnVuY3Rpb24ocSl7aWYocTw9MHx8cT49MSlyZXR1cm4gcTtmb3IodmFyIEg9MDtxPj1HW0grMV07KUgrKzt2YXIgZDA9KHEtR1tIXSkvKEdbSCsxXS1HW0hdKSxEMD1EW0hdK2QwKihEW0grMV0tRFtIXSk7cmV0dXJuIEQwfSl9fXJldHVybiBzPVtoLHddLE59LE4ubW9kZT1mdW5jdGlvbihwKXtyZXR1cm4gYXJndW1lbnRzLmxlbmd0aD8oZT1wLG8wKCksTik6ZX0sTi5yYW5nZT1mdW5jdGlvbihwLEYpe3JldHVybiBQKHApLE59LE4ub3V0PWZ1bmN0aW9uKHApe3JldHVybiB2PXAsTn0sTi5zcHJlYWQ9ZnVuY3Rpb24ocCl7cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGg/KGE9cCxOKTphfSxOLmNvcnJlY3RMaWdodG5lc3M9ZnVuY3Rpb24ocCl7cmV0dXJuIHA9PW51bGwmJihwPSEwKSxkPXAsbzAoKSxkP0w9ZnVuY3Rpb24oRil7Zm9yKHZhciBUPVooMCwhMCkubGFiKClbMF0sST1aKDEsITApLmxhYigpWzBdLEs9VD5JLFk9WihGLCEwKS5sYWIoKVswXSxEPVQrKEktVCkqRixHPVktRCxxPTAsSD0xLGQwPTIwO01hdGguYWJzKEcpPi4wMSYmZDAtLSA+MDspKGZ1bmN0aW9uKCl7cmV0dXJuIEsmJihHKj0tMSksRzwwPyhxPUYsRis9KEgtRikqLjUpOihIPUYsRis9KHEtRikqLjUpLFk9WihGLCEwKS5sYWIoKVswXSxHPVktRH0pKCk7cmV0dXJuIEZ9Okw9ZnVuY3Rpb24oRil7cmV0dXJuIEZ9LE59LE4ucGFkZGluZz1mdW5jdGlvbihwKXtyZXR1cm4gcCE9bnVsbD8odTEocCk9PT0ibnVtYmVyIiYmKHA9W3AscF0pLG89cCxOKTpvfSxOLmNvbG9ycz1mdW5jdGlvbihwLEYpe2FyZ3VtZW50cy5sZW5ndGg8MiYmKEY9ImhleCIpO3ZhciBUPVtdO2lmKGFyZ3VtZW50cy5sZW5ndGg9PT0wKVQ9Zi5zbGljZSgwKTtlbHNlIGlmKHA9PT0xKVQ9W04oLjUpXTtlbHNlIGlmKHA+MSl7dmFyIEk9c1swXSxLPXNbMV0tSTtUPWY1KDAscCkubWFwKGZ1bmN0aW9uKEgpe3JldHVybiBOKEkrSC8ocC0xKSpLKX0pfWVsc2V7cj1bXTt2YXIgWT1bXTtpZihjJiZjLmxlbmd0aD4yKWZvcih2YXIgRD0xLEc9Yy5sZW5ndGgscT0xPD1HO3E/RDxHOkQ+RztxP0QrKzpELS0pWS5wdXNoKChjW0QtMV0rY1tEXSkqLjUpO2Vsc2UgWT1zO1Q9WS5tYXAoZnVuY3Rpb24oSCl7cmV0dXJuIE4oSCl9KX1yZXR1cm4gZzBbRl0mJihUPVQubWFwKGZ1bmN0aW9uKEgpe3JldHVybiBIW0ZdKCl9KSksVH0sTi5jYWNoZT1mdW5jdGlvbihwKXtyZXR1cm4gcCE9bnVsbD8oeT1wLE4pOnl9LE4uZ2FtbWE9ZnVuY3Rpb24ocCl7cmV0dXJuIHAhPW51bGw/KFM9cCxOKTpTfSxOLm5vZGF0YT1mdW5jdGlvbihwKXtyZXR1cm4gcCE9bnVsbD8odD1nMChwKSxOKTp0fSxOfTtmdW5jdGlvbiBmNShyLGUsdCl7Zm9yKHZhciBhPVtdLHM9cjxlLGk9ZSxvPXI7cz9vPGk6bz5pO3M/bysrOm8tLSlhLnB1c2gobyk7cmV0dXJuIGF9dmFyICQxPUMsdTU9eTIsdjU9ZnVuY3Rpb24ocil7Zm9yKHZhciBlPVsxLDFdLHQ9MTt0PHI7dCsrKXtmb3IodmFyIGE9WzFdLHM9MTtzPD1lLmxlbmd0aDtzKyspYVtzXT0oZVtzXXx8MCkrZVtzLTFdO2U9YX1yZXR1cm4gZX0saDU9ZnVuY3Rpb24ocil7dmFyIGUsdCxhLHMsaSxvLGM7aWYocj1yLm1hcChmdW5jdGlvbihkKXtyZXR1cm4gbmV3ICQxKGQpfSksci5sZW5ndGg9PT0yKWU9ci5tYXAoZnVuY3Rpb24oZCl7cmV0dXJuIGQubGFiKCl9KSxpPWVbMF0sbz1lWzFdLHM9ZnVuY3Rpb24oZCl7dmFyIF89WzAsMSwyXS5tYXAoZnVuY3Rpb24oeSl7cmV0dXJuIGlbeV0rZCoob1t5XS1pW3ldKX0pO3JldHVybiBuZXcgJDEoXywibGFiIil9O2Vsc2UgaWYoci5sZW5ndGg9PT0zKXQ9ci5tYXAoZnVuY3Rpb24oZCl7cmV0dXJuIGQubGFiKCl9KSxpPXRbMF0sbz10WzFdLGM9dFsyXSxzPWZ1bmN0aW9uKGQpe3ZhciBfPVswLDEsMl0ubWFwKGZ1bmN0aW9uKHkpe3JldHVybigxLWQpKigxLWQpKmlbeV0rMiooMS1kKSpkKm9beV0rZCpkKmNbeV19KTtyZXR1cm4gbmV3ICQxKF8sImxhYiIpfTtlbHNlIGlmKHIubGVuZ3RoPT09NCl7dmFyIGY7YT1yLm1hcChmdW5jdGlvbihkKXtyZXR1cm4gZC5sYWIoKX0pLGk9YVswXSxvPWFbMV0sYz1hWzJdLGY9YVszXSxzPWZ1bmN0aW9uKGQpe3ZhciBfPVswLDEsMl0ubWFwKGZ1bmN0aW9uKHkpe3JldHVybigxLWQpKigxLWQpKigxLWQpKmlbeV0rMyooMS1kKSooMS1kKSpkKm9beV0rMyooMS1kKSpkKmQqY1t5XStkKmQqZCpmW3ldfSk7cmV0dXJuIG5ldyAkMShfLCJsYWIiKX19ZWxzZSBpZihyLmxlbmd0aD49NSl7dmFyIHYsaCx3O3Y9ci5tYXAoZnVuY3Rpb24oZCl7cmV0dXJuIGQubGFiKCl9KSx3PXIubGVuZ3RoLTEsaD12NSh3KSxzPWZ1bmN0aW9uKGQpe3ZhciBfPTEtZCx5PVswLDEsMl0ubWFwKGZ1bmN0aW9uKFMpe3JldHVybiB2LnJlZHVjZShmdW5jdGlvbihQLEIsTCl7cmV0dXJuIFAraFtMXSpNYXRoLnBvdyhfLHctTCkqTWF0aC5wb3coZCxMKSpCW1NdfSwwKX0pO3JldHVybiBuZXcgJDEoeSwibGFiIil9fWVsc2UgdGhyb3cgbmV3IFJhbmdlRXJyb3IoIk5vIHBvaW50IGluIHJ1bm5pbmcgYmV6aWVyIHdpdGggb25seSBvbmUgY29sb3IuIik7cmV0dXJuIHN9LGc1PWZ1bmN0aW9uKHIpe3ZhciBlPWg1KHIpO3JldHVybiBlLnNjYWxlPWZ1bmN0aW9uKCl7cmV0dXJuIHU1KGUpfSxlfSxfMj1XLGIwPWZ1bmN0aW9uKHIsZSx0KXtpZighYjBbdF0pdGhyb3cgbmV3IEVycm9yKCJ1bmtub3duIGJsZW5kIG1vZGUgIit0KTtyZXR1cm4gYjBbdF0ocixlKX0sTjA9ZnVuY3Rpb24ocil7cmV0dXJuIGZ1bmN0aW9uKGUsdCl7dmFyIGE9XzIodCkucmdiKCkscz1fMihlKS5yZ2IoKTtyZXR1cm4gXzIucmdiKHIoYSxzKSl9fSxCMD1mdW5jdGlvbihyKXtyZXR1cm4gZnVuY3Rpb24oZSx0KXt2YXIgYT1bXTtyZXR1cm4gYVswXT1yKGVbMF0sdFswXSksYVsxXT1yKGVbMV0sdFsxXSksYVsyXT1yKGVbMl0sdFsyXSksYX19LGI1PWZ1bmN0aW9uKHIpe3JldHVybiByfSxkNT1mdW5jdGlvbihyLGUpe3JldHVybiByKmUvMjU1fSxwNT1mdW5jdGlvbihyLGUpe3JldHVybiByPmU/ZTpyfSxtNT1mdW5jdGlvbihyLGUpe3JldHVybiByPmU/cjplfSx3NT1mdW5jdGlvbihyLGUpe3JldHVybiAyNTUqKDEtKDEtci8yNTUpKigxLWUvMjU1KSl9LHk1PWZ1bmN0aW9uKHIsZSl7cmV0dXJuIGU8MTI4PzIqciplLzI1NToyNTUqKDEtMiooMS1yLzI1NSkqKDEtZS8yNTUpKX0sXzU9ZnVuY3Rpb24ocixlKXtyZXR1cm4gMjU1KigxLSgxLWUvMjU1KS8oci8yNTUpKX0sazU9ZnVuY3Rpb24ocixlKXtyZXR1cm4gcj09PTI1NT8yNTU6KHI9MjU1KihlLzI1NSkvKDEtci8yNTUpLHI+MjU1PzI1NTpyKX07YjAubm9ybWFsPU4wKEIwKGI1KSksYjAubXVsdGlwbHk9TjAoQjAoZDUpKSxiMC5zY3JlZW49TjAoQjAodzUpKSxiMC5vdmVybGF5PU4wKEIwKHk1KSksYjAuZGFya2VuPU4wKEIwKHA1KSksYjAubGlnaHRlbj1OMChCMChtNSkpLGIwLmRvZGdlPU4wKEIwKGs1KSksYjAuYnVybj1OMChCMChfNSkpO2Zvcih2YXIgJDU9YjAsazI9bS50eXBlLE01PW0uY2xpcF9yZ2IsQzU9bS5UV09QSSxGNT1NYXRoLnBvdyxBNT1NYXRoLnNpbix4NT1NYXRoLmNvcyxMcj1XLFM1PWZ1bmN0aW9uKHIsZSx0LGEscyl7cj09PXZvaWQgMCYmKHI9MzAwKSxlPT09dm9pZCAwJiYoZT0tMS41KSx0PT09dm9pZCAwJiYodD0xKSxhPT09dm9pZCAwJiYoYT0xKSxzPT09dm9pZCAwJiYocz1bMCwxXSk7dmFyIGk9MCxvO2syKHMpPT09ImFycmF5Ij9vPXNbMV0tc1swXToobz0wLHM9W3Msc10pO3ZhciBjPWZ1bmN0aW9uKGYpe3ZhciB2PUM1KigocisxMjApLzM2MCtlKmYpLGg9RjUoc1swXStvKmYsYSksdz1pIT09MD90WzBdK2YqaTp0LGQ9dypoKigxLWgpLzIsXz14NSh2KSx5PUE1KHYpLFM9aCtkKigtLjE0ODYxKl8rMS43ODI3Nyp5KSxQPWgrZCooLS4yOTIyNypfLS45MDY0OSp5KSxCPWgrZCooMS45NzI5NCpfKTtyZXR1cm4gTHIoTTUoW1MqMjU1LFAqMjU1LEIqMjU1LDFdKSl9O3JldHVybiBjLnN0YXJ0PWZ1bmN0aW9uKGYpe3JldHVybiBmPT1udWxsP3I6KHI9ZixjKX0sYy5yb3RhdGlvbnM9ZnVuY3Rpb24oZil7cmV0dXJuIGY9PW51bGw/ZTooZT1mLGMpfSxjLmdhbW1hPWZ1bmN0aW9uKGYpe3JldHVybiBmPT1udWxsP2E6KGE9ZixjKX0sYy5odWU9ZnVuY3Rpb24oZil7cmV0dXJuIGY9PW51bGw/dDoodD1mLGsyKHQpPT09ImFycmF5Ij8oaT10WzFdLXRbMF0saT09PTAmJih0PXRbMV0pKTppPTAsYyl9LGMubGlnaHRuZXNzPWZ1bmN0aW9uKGYpe3JldHVybiBmPT1udWxsP3M6KGsyKGYpPT09ImFycmF5Ij8ocz1mLG89ZlsxXS1mWzBdKToocz1bZixmXSxvPTApLGMpfSxjLnNjYWxlPWZ1bmN0aW9uKCl7cmV0dXJuIExyLnNjYWxlKGMpfSxjLmh1ZSh0KSxjfSxJNT1DLFI1PSIwMTIzNDU2Nzg5YWJjZGVmIixUNT1NYXRoLmZsb29yLFA1PU1hdGgucmFuZG9tLHo1PWZ1bmN0aW9uKCl7Zm9yKHZhciByPSIjIixlPTA7ZTw2O2UrKylyKz1SNS5jaGFyQXQoVDUoUDUoKSoxNikpO3JldHVybiBuZXcgSTUociwiaGV4Iil9LCQyPXgsR3I9TWF0aC5sb2csRTU9TWF0aC5wb3csTjU9TWF0aC5mbG9vcixCNT1NYXRoLmFicyxxcj1mdW5jdGlvbihyLGUpe2U9PT12b2lkIDAmJihlPW51bGwpO3ZhciB0PXttaW46TnVtYmVyLk1BWF9WQUxVRSxtYXg6TnVtYmVyLk1BWF9WQUxVRSotMSxzdW06MCx2YWx1ZXM6W10sY291bnQ6MH07cmV0dXJuICQyKHIpPT09Im9iamVjdCImJihyPU9iamVjdC52YWx1ZXMocikpLHIuZm9yRWFjaChmdW5jdGlvbihhKXtlJiYkMihhKT09PSJvYmplY3QiJiYoYT1hW2VdKSxhIT1udWxsJiYhaXNOYU4oYSkmJih0LnZhbHVlcy5wdXNoKGEpLHQuc3VtKz1hLGE8dC5taW4mJih0Lm1pbj1hKSxhPnQubWF4JiYodC5tYXg9YSksdC5jb3VudCs9MSl9KSx0LmRvbWFpbj1bdC5taW4sdC5tYXhdLHQubGltaXRzPWZ1bmN0aW9uKGEscyl7cmV0dXJuIFdyKHQsYSxzKX0sdH0sV3I9ZnVuY3Rpb24ocixlLHQpe2U9PT12b2lkIDAmJihlPSJlcXVhbCIpLHQ9PT12b2lkIDAmJih0PTcpLCQyKHIpPT0iYXJyYXkiJiYocj1xcihyKSk7dmFyIGE9ci5taW4scz1yLm1heCxpPXIudmFsdWVzLnNvcnQoZnVuY3Rpb24oQzIsRjIpe3JldHVybiBDMi1GMn0pO2lmKHQ9PT0xKXJldHVyblthLHNdO3ZhciBvPVtdO2lmKGUuc3Vic3RyKDAsMSk9PT0iYyImJihvLnB1c2goYSksby5wdXNoKHMpKSxlLnN1YnN0cigwLDEpPT09ImUiKXtvLnB1c2goYSk7Zm9yKHZhciBjPTE7Yzx0O2MrKylvLnB1c2goYStjL3QqKHMtYSkpO28ucHVzaChzKX1lbHNlIGlmKGUuc3Vic3RyKDAsMSk9PT0ibCIpe2lmKGE8PTApdGhyb3cgbmV3IEVycm9yKCJMb2dhcml0aG1pYyBzY2FsZXMgYXJlIG9ubHkgcG9zc2libGUgZm9yIHZhbHVlcyA+IDAiKTt2YXIgZj1NYXRoLkxPRzEwRSpHcihhKSx2PU1hdGguTE9HMTBFKkdyKHMpO28ucHVzaChhKTtmb3IodmFyIGg9MTtoPHQ7aCsrKW8ucHVzaChFNSgxMCxmK2gvdCoodi1mKSkpO28ucHVzaChzKX1lbHNlIGlmKGUuc3Vic3RyKDAsMSk9PT0icSIpe28ucHVzaChhKTtmb3IodmFyIHc9MTt3PHQ7dysrKXt2YXIgZD0oaS5sZW5ndGgtMSkqdy90LF89TjUoZCk7aWYoXz09PWQpby5wdXNoKGlbX10pO2Vsc2V7dmFyIHk9ZC1fO28ucHVzaChpW19dKigxLXkpK2lbXysxXSp5KX19by5wdXNoKHMpfWVsc2UgaWYoZS5zdWJzdHIoMCwxKT09PSJrIil7dmFyIFMsUD1pLmxlbmd0aCxCPW5ldyBBcnJheShQKSxMPW5ldyBBcnJheSh0KSxKPSEwLFo9MCxvMD1udWxsO28wPVtdLG8wLnB1c2goYSk7Zm9yKHZhciBOPTE7Tjx0O04rKylvMC5wdXNoKGErTi90KihzLWEpKTtmb3IobzAucHVzaChzKTtKOyl7Zm9yKHZhciBwPTA7cDx0O3ArKylMW3BdPTA7Zm9yKHZhciBGPTA7RjxQO0YrKylmb3IodmFyIFQ9aVtGXSxJPU51bWJlci5NQVhfVkFMVUUsSz12b2lkIDAsWT0wO1k8dDtZKyspe3ZhciBEPUI1KG8wW1ldLVQpO0Q8SSYmKEk9RCxLPVkpLExbS10rKyxCW0ZdPUt9Zm9yKHZhciBHPW5ldyBBcnJheSh0KSxxPTA7cTx0O3ErKylHW3FdPW51bGw7Zm9yKHZhciBIPTA7SDxQO0grKylTPUJbSF0sR1tTXT09PW51bGw/R1tTXT1pW0hdOkdbU10rPWlbSF07Zm9yKHZhciBkMD0wO2QwPHQ7ZDArKylHW2QwXSo9MS9MW2QwXTtKPSExO2Zvcih2YXIgRDA9MDtEMDx0O0QwKyspaWYoR1tEMF0hPT1vMFtEMF0pe0o9ITA7YnJlYWt9bzA9RyxaKyssWj4yMDAmJihKPSExKX1mb3IodmFyIEwwPXt9LHYxPTA7djE8dDt2MSsrKUwwW3YxXT1bXTtmb3IodmFyIGgxPTA7aDE8UDtoMSsrKVM9QltoMV0sTDBbU10ucHVzaChpW2gxXSk7Zm9yKHZhciBBMD1bXSxKMD0wO0owPHQ7SjArKylBMC5wdXNoKEwwW0owXVswXSksQTAucHVzaChMMFtKMF1bTDBbSjBdLmxlbmd0aC0xXSk7QTA9QTAuc29ydChmdW5jdGlvbihDMixGMil7cmV0dXJuIEMyLUYyfSksby5wdXNoKEEwWzBdKTtmb3IodmFyIE0xPTE7TTE8QTAubGVuZ3RoO00xKz0yKXt2YXIgSzA9QTBbTTFdOyFpc05hTihLMCkmJm8uaW5kZXhPZihLMCk9PT0tMSYmby5wdXNoKEswKX19cmV0dXJuIG99LEhyPXthbmFseXplOnFyLGxpbWl0czpXcn0sT3I9QyxENT1mdW5jdGlvbihyLGUpe3I9bmV3IE9yKHIpLGU9bmV3IE9yKGUpO3ZhciB0PXIubHVtaW5hbmNlKCksYT1lLmx1bWluYW5jZSgpO3JldHVybiB0PmE/KHQrLjA1KS8oYSsuMDUpOihhKy4wNSkvKHQrLjA1KX0sWXI9QyxGMD1NYXRoLnNxcnQsWD1NYXRoLnBvdyxMNT1NYXRoLm1pbixHNT1NYXRoLm1heCxVcj1NYXRoLmF0YW4yLFhyPU1hdGguYWJzLFkxPU1hdGguY29zLFZyPU1hdGguc2luLHE1PU1hdGguZXhwLGpyPU1hdGguUEksVzU9ZnVuY3Rpb24ocixlLHQsYSxzKXt0PT09dm9pZCAwJiYodD0xKSxhPT09dm9pZCAwJiYoYT0xKSxzPT09dm9pZCAwJiYocz0xKTt2YXIgaT1mdW5jdGlvbihLMCl7cmV0dXJuIDM2MCpLMC8oMipqcil9LG89ZnVuY3Rpb24oSzApe3JldHVybiAyKmpyKkswLzM2MH07cj1uZXcgWXIociksZT1uZXcgWXIoZSk7dmFyIGM9QXJyYXkuZnJvbShyLmxhYigpKSxmPWNbMF0sdj1jWzFdLGg9Y1syXSx3PUFycmF5LmZyb20oZS5sYWIoKSksZD13WzBdLF89d1sxXSx5PXdbMl0sUz0oZitkKS8yLFA9RjAoWCh2LDIpK1goaCwyKSksQj1GMChYKF8sMikrWCh5LDIpKSxMPShQK0IpLzIsSj0uNSooMS1GMChYKEwsNykvKFgoTCw3KStYKDI1LDcpKSkpLFo9diooMStKKSxvMD1fKigxK0opLE49RjAoWChaLDIpK1goaCwyKSkscD1GMChYKG8wLDIpK1goeSwyKSksRj0oTitwKS8yLFQ9aShVcihoLFopKSxJPWkoVXIoeSxvMCkpLEs9VD49MD9UOlQrMzYwLFk9ST49MD9JOkkrMzYwLEQ9WHIoSy1ZKT4xODA/KEsrWSszNjApLzI6KEsrWSkvMixHPTEtLjE3KlkxKG8oRC0zMCkpKy4yNCpZMShvKDIqRCkpKy4zMipZMShvKDMqRCs2KSktLjIqWTEobyg0KkQtNjMpKSxxPVktSztxPVhyKHEpPD0xODA/cTpZPD1LP3ErMzYwOnEtMzYwLHE9MipGMChOKnApKlZyKG8ocSkvMik7dmFyIEg9ZC1mLGQwPXAtTixEMD0xKy4wMTUqWChTLTUwLDIpL0YwKDIwK1goUy01MCwyKSksTDA9MSsuMDQ1KkYsdjE9MSsuMDE1KkYqRyxoMT0zMCpxNSgtWCgoRC0yNzUpLzI1LDIpKSxBMD0yKkYwKFgoRiw3KS8oWChGLDcpK1goMjUsNykpKSxKMD0tQTAqVnIoMipvKGgxKSksTTE9RjAoWChILyh0KkQwKSwyKStYKGQwLyhhKkwwKSwyKStYKHEvKHMqdjEpLDIpK0owKihkMC8oYSpMMCkpKihxLyhzKnYxKSkpO3JldHVybiBHNSgwLEw1KDEwMCxNMSkpfSxacj1DLEg1PWZ1bmN0aW9uKHIsZSx0KXt0PT09dm9pZCAwJiYodD0ibGFiIikscj1uZXcgWnIociksZT1uZXcgWnIoZSk7dmFyIGE9ci5nZXQodCkscz1lLmdldCh0KSxpPTA7Zm9yKHZhciBvIGluIGEpe3ZhciBjPShhW29dfHwwKS0oc1tvXXx8MCk7aSs9YypjfXJldHVybiBNYXRoLnNxcnQoaSl9LE81PUMsWTU9ZnVuY3Rpb24oKXtmb3IodmFyIHI9W10sZT1hcmd1bWVudHMubGVuZ3RoO2UtLTspcltlXT1hcmd1bWVudHNbZV07dHJ5e3JldHVybiBuZXcoRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQuYXBwbHkoTzUsW251bGxdLmNvbmNhdChyKSkpLCEwfWNhdGNoe3JldHVybiExfX0sUXI9VyxKcj15MixVNT17Y29vbDpmdW5jdGlvbigpe3JldHVybiBKcihbUXIuaHNsKDE4MCwxLC45KSxRci5oc2woMjUwLC43LC40KV0pfSxob3Q6ZnVuY3Rpb24oKXtyZXR1cm4gSnIoWyIjMDAwIiwiI2YwMCIsIiNmZjAiLCIjZmZmIl0pLm1vZGUoInJnYiIpfX0sVTE9e09yUmQ6WyIjZmZmN2VjIiwiI2ZlZThjOCIsIiNmZGQ0OWUiLCIjZmRiYjg0IiwiI2ZjOGQ1OSIsIiNlZjY1NDgiLCIjZDczMDFmIiwiI2IzMDAwMCIsIiM3ZjAwMDAiXSxQdUJ1OlsiI2ZmZjdmYiIsIiNlY2U3ZjIiLCIjZDBkMWU2IiwiI2E2YmRkYiIsIiM3NGE5Y2YiLCIjMzY5MGMwIiwiIzA1NzBiMCIsIiMwNDVhOGQiLCIjMDIzODU4Il0sQnVQdTpbIiNmN2ZjZmQiLCIjZTBlY2Y0IiwiI2JmZDNlNiIsIiM5ZWJjZGEiLCIjOGM5NmM2IiwiIzhjNmJiMSIsIiM4ODQxOWQiLCIjODEwZjdjIiwiIzRkMDA0YiJdLE9yYW5nZXM6WyIjZmZmNWViIiwiI2ZlZTZjZSIsIiNmZGQwYTIiLCIjZmRhZTZiIiwiI2ZkOGQzYyIsIiNmMTY5MTMiLCIjZDk0ODAxIiwiI2E2MzYwMyIsIiM3ZjI3MDQiXSxCdUduOlsiI2Y3ZmNmZCIsIiNlNWY1ZjkiLCIjY2NlY2U2IiwiIzk5ZDhjOSIsIiM2NmMyYTQiLCIjNDFhZTc2IiwiIzIzOGI0NSIsIiMwMDZkMmMiLCIjMDA0NDFiIl0sWWxPckJyOlsiI2ZmZmZlNSIsIiNmZmY3YmMiLCIjZmVlMzkxIiwiI2ZlYzQ0ZiIsIiNmZTk5MjkiLCIjZWM3MDE0IiwiI2NjNGMwMiIsIiM5OTM0MDQiLCIjNjYyNTA2Il0sWWxHbjpbIiNmZmZmZTUiLCIjZjdmY2I5IiwiI2Q5ZjBhMyIsIiNhZGRkOGUiLCIjNzhjNjc5IiwiIzQxYWI1ZCIsIiMyMzg0NDMiLCIjMDA2ODM3IiwiIzAwNDUyOSJdLFJlZHM6WyIjZmZmNWYwIiwiI2ZlZTBkMiIsIiNmY2JiYTEiLCIjZmM5MjcyIiwiI2ZiNmE0YSIsIiNlZjNiMmMiLCIjY2IxODFkIiwiI2E1MGYxNSIsIiM2NzAwMGQiXSxSZFB1OlsiI2ZmZjdmMyIsIiNmZGUwZGQiLCIjZmNjNWMwIiwiI2ZhOWZiNSIsIiNmNzY4YTEiLCIjZGQzNDk3IiwiI2FlMDE3ZSIsIiM3YTAxNzciLCIjNDkwMDZhIl0sR3JlZW5zOlsiI2Y3ZmNmNSIsIiNlNWY1ZTAiLCIjYzdlOWMwIiwiI2ExZDk5YiIsIiM3NGM0NzYiLCIjNDFhYjVkIiwiIzIzOGI0NSIsIiMwMDZkMmMiLCIjMDA0NDFiIl0sWWxHbkJ1OlsiI2ZmZmZkOSIsIiNlZGY4YjEiLCIjYzdlOWI0IiwiIzdmY2RiYiIsIiM0MWI2YzQiLCIjMWQ5MWMwIiwiIzIyNWVhOCIsIiMyNTM0OTQiLCIjMDgxZDU4Il0sUHVycGxlczpbIiNmY2ZiZmQiLCIjZWZlZGY1IiwiI2RhZGFlYiIsIiNiY2JkZGMiLCIjOWU5YWM4IiwiIzgwN2RiYSIsIiM2YTUxYTMiLCIjNTQyNzhmIiwiIzNmMDA3ZCJdLEduQnU6WyIjZjdmY2YwIiwiI2UwZjNkYiIsIiNjY2ViYzUiLCIjYThkZGI1IiwiIzdiY2NjNCIsIiM0ZWIzZDMiLCIjMmI4Y2JlIiwiIzA4NjhhYyIsIiMwODQwODEiXSxHcmV5czpbIiNmZmZmZmYiLCIjZjBmMGYwIiwiI2Q5ZDlkOSIsIiNiZGJkYmQiLCIjOTY5Njk2IiwiIzczNzM3MyIsIiM1MjUyNTIiLCIjMjUyNTI1IiwiIzAwMDAwMCJdLFlsT3JSZDpbIiNmZmZmY2MiLCIjZmZlZGEwIiwiI2ZlZDk3NiIsIiNmZWIyNGMiLCIjZmQ4ZDNjIiwiI2ZjNGUyYSIsIiNlMzFhMWMiLCIjYmQwMDI2IiwiIzgwMDAyNiJdLFB1UmQ6WyIjZjdmNGY5IiwiI2U3ZTFlZiIsIiNkNGI5ZGEiLCIjYzk5NGM3IiwiI2RmNjViMCIsIiNlNzI5OGEiLCIjY2UxMjU2IiwiIzk4MDA0MyIsIiM2NzAwMWYiXSxCbHVlczpbIiNmN2ZiZmYiLCIjZGVlYmY3IiwiI2M2ZGJlZiIsIiM5ZWNhZTEiLCIjNmJhZWQ2IiwiIzQyOTJjNiIsIiMyMTcxYjUiLCIjMDg1MTljIiwiIzA4MzA2YiJdLFB1QnVHbjpbIiNmZmY3ZmIiLCIjZWNlMmYwIiwiI2QwZDFlNiIsIiNhNmJkZGIiLCIjNjdhOWNmIiwiIzM2OTBjMCIsIiMwMjgxOGEiLCIjMDE2YzU5IiwiIzAxNDYzNiJdLFZpcmlkaXM6WyIjNDQwMTU0IiwiIzQ4Mjc3NyIsIiMzZjRhOGEiLCIjMzE2NzhlIiwiIzI2ODM4ZiIsIiMxZjlkOGEiLCIjNmNjZTVhIiwiI2I2ZGUyYiIsIiNmZWU4MjUiXSxTcGVjdHJhbDpbIiM5ZTAxNDIiLCIjZDUzZTRmIiwiI2Y0NmQ0MyIsIiNmZGFlNjEiLCIjZmVlMDhiIiwiI2ZmZmZiZiIsIiNlNmY1OTgiLCIjYWJkZGE0IiwiIzY2YzJhNSIsIiMzMjg4YmQiLCIjNWU0ZmEyIl0sUmRZbEduOlsiI2E1MDAyNiIsIiNkNzMwMjciLCIjZjQ2ZDQzIiwiI2ZkYWU2MSIsIiNmZWUwOGIiLCIjZmZmZmJmIiwiI2Q5ZWY4YiIsIiNhNmQ5NmEiLCIjNjZiZDYzIiwiIzFhOTg1MCIsIiMwMDY4MzciXSxSZEJ1OlsiIzY3MDAxZiIsIiNiMjE4MmIiLCIjZDY2MDRkIiwiI2Y0YTU4MiIsIiNmZGRiYzciLCIjZjdmN2Y3IiwiI2QxZTVmMCIsIiM5MmM1ZGUiLCIjNDM5M2MzIiwiIzIxNjZhYyIsIiMwNTMwNjEiXSxQaVlHOlsiIzhlMDE1MiIsIiNjNTFiN2QiLCIjZGU3N2FlIiwiI2YxYjZkYSIsIiNmZGUwZWYiLCIjZjdmN2Y3IiwiI2U2ZjVkMCIsIiNiOGUxODYiLCIjN2ZiYzQxIiwiIzRkOTIyMSIsIiMyNzY0MTkiXSxQUkduOlsiIzQwMDA0YiIsIiM3NjJhODMiLCIjOTk3MGFiIiwiI2MyYTVjZiIsIiNlN2Q0ZTgiLCIjZjdmN2Y3IiwiI2Q5ZjBkMyIsIiNhNmRiYTAiLCIjNWFhZTYxIiwiIzFiNzgzNyIsIiMwMDQ0MWIiXSxSZFlsQnU6WyIjYTUwMDI2IiwiI2Q3MzAyNyIsIiNmNDZkNDMiLCIjZmRhZTYxIiwiI2ZlZTA5MCIsIiNmZmZmYmYiLCIjZTBmM2Y4IiwiI2FiZDllOSIsIiM3NGFkZDEiLCIjNDU3NWI0IiwiIzMxMzY5NSJdLEJyQkc6WyIjNTQzMDA1IiwiIzhjNTEwYSIsIiNiZjgxMmQiLCIjZGZjMjdkIiwiI2Y2ZThjMyIsIiNmNWY1ZjUiLCIjYzdlYWU1IiwiIzgwY2RjMSIsIiMzNTk3OGYiLCIjMDE2NjVlIiwiIzAwM2MzMCJdLFJkR3k6WyIjNjcwMDFmIiwiI2IyMTgyYiIsIiNkNjYwNGQiLCIjZjRhNTgyIiwiI2ZkZGJjNyIsIiNmZmZmZmYiLCIjZTBlMGUwIiwiI2JhYmFiYSIsIiM4Nzg3ODciLCIjNGQ0ZDRkIiwiIzFhMWExYSJdLFB1T3I6WyIjN2YzYjA4IiwiI2IzNTgwNiIsIiNlMDgyMTQiLCIjZmRiODYzIiwiI2ZlZTBiNiIsIiNmN2Y3ZjciLCIjZDhkYWViIiwiI2IyYWJkMiIsIiM4MDczYWMiLCIjNTQyNzg4IiwiIzJkMDA0YiJdLFNldDI6WyIjNjZjMmE1IiwiI2ZjOGQ2MiIsIiM4ZGEwY2IiLCIjZTc4YWMzIiwiI2E2ZDg1NCIsIiNmZmQ5MmYiLCIjZTVjNDk0IiwiI2IzYjNiMyJdLEFjY2VudDpbIiM3ZmM5N2YiLCIjYmVhZWQ0IiwiI2ZkYzA4NiIsIiNmZmZmOTkiLCIjMzg2Y2IwIiwiI2YwMDI3ZiIsIiNiZjViMTciLCIjNjY2NjY2Il0sU2V0MTpbIiNlNDFhMWMiLCIjMzc3ZWI4IiwiIzRkYWY0YSIsIiM5ODRlYTMiLCIjZmY3ZjAwIiwiI2ZmZmYzMyIsIiNhNjU2MjgiLCIjZjc4MWJmIiwiIzk5OTk5OSJdLFNldDM6WyIjOGRkM2M3IiwiI2ZmZmZiMyIsIiNiZWJhZGEiLCIjZmI4MDcyIiwiIzgwYjFkMyIsIiNmZGI0NjIiLCIjYjNkZTY5IiwiI2ZjY2RlNSIsIiNkOWQ5ZDkiLCIjYmM4MGJkIiwiI2NjZWJjNSIsIiNmZmVkNmYiXSxEYXJrMjpbIiMxYjllNzciLCIjZDk1ZjAyIiwiIzc1NzBiMyIsIiNlNzI5OGEiLCIjNjZhNjFlIiwiI2U2YWIwMiIsIiNhNjc2MWQiLCIjNjY2NjY2Il0sUGFpcmVkOlsiI2E2Y2VlMyIsIiMxZjc4YjQiLCIjYjJkZjhhIiwiIzMzYTAyYyIsIiNmYjlhOTkiLCIjZTMxYTFjIiwiI2ZkYmY2ZiIsIiNmZjdmMDAiLCIjY2FiMmQ2IiwiIzZhM2Q5YSIsIiNmZmZmOTkiLCIjYjE1OTI4Il0sUGFzdGVsMjpbIiNiM2UyY2QiLCIjZmRjZGFjIiwiI2NiZDVlOCIsIiNmNGNhZTQiLCIjZTZmNWM5IiwiI2ZmZjJhZSIsIiNmMWUyY2MiLCIjY2NjY2NjIl0sUGFzdGVsMTpbIiNmYmI0YWUiLCIjYjNjZGUzIiwiI2NjZWJjNSIsIiNkZWNiZTQiLCIjZmVkOWE2IiwiI2ZmZmZjYyIsIiNlNWQ4YmQiLCIjZmRkYWVjIiwiI2YyZjJmMiJdfSxNMj0wLEtyPU9iamVjdC5rZXlzKFUxKTtNMjxLci5sZW5ndGg7TTIrPTEpe3ZhciByZT1LcltNMl07VTFbcmUudG9Mb3dlckNhc2UoKV09VTFbcmVdfXZhciBYNT1VMSxqPVc7ai5hdmVyYWdlPWk1LGouYmV6aWVyPWc1LGouYmxlbmQ9JDUsai5jdWJlaGVsaXg9UzUsai5taXg9ai5pbnRlcnBvbGF0ZT1JcixqLnJhbmRvbT16NSxqLnNjYWxlPXkyLGouYW5hbHl6ZT1Ici5hbmFseXplLGouY29udHJhc3Q9RDUsai5kZWx0YUU9VzUsai5kaXN0YW5jZT1INSxqLmxpbWl0cz1Ici5saW1pdHMsai52YWxpZD1ZNSxqLnNjYWxlcz1VNSxqLmNvbG9ycz12cixqLmJyZXdlcj1YNTt2YXIgVjU9ajtyZXR1cm4gVjV9KX0pKHMwKTt2YXIgQzE9czAuZXhwb3J0cyxyMT1hMChDMSk7Y29uc3Qgb2U9W1suMDA0NTI4LC4wMDQzNDEsLjAwNDMwN10sWy4wMDU2MjUsLjAwNjE1NiwuMDA2MDFdLFsuMDA2NjI4LC4wMDgyOTMsLjAwODE2MV0sWy4wMDc1NTEsLjAxMDczOCwuMDEwNzldLFsuMDA4MzgyLC4wMTM0ODIsLjAxMzk0MV0sWy4wMDkxMTEsLjAxNjUyLC4wMTc2NjJdLFsuMDA5NzI3LC4wMTk4NDYsLjAyMjAwOV0sWy4wMTAyMjMsLjAyMzQ1MiwuMDI3MDM1XSxbLjAxMDU5MywuMDI3MzMxLC4wMzI3OTldLFsuMDEwODMzLC4wMzE0NzUsLjAzOTM2MV0sWy4wMTA5NDEsLjAzNTg3NSwuMDQ2NDE1XSxbLjAxMDkxOCwuMDQwNTIsLjA1MzU5N10sWy4wMTA3NjgsLjA0NTE1OCwuMDYwOTE0XSxbLjAxMDQ5MiwuMDQ5NzA4LC4wNjgzNjddLFsuMDEwMDk4LC4wNTQxNzEsLjA3NTk1NF0sWy4wMDk1OTQsLjA1ODU0OSwuMDgzNjcyXSxbLjAwODk4OSwuMDYyODQsLjA5MTUyMV0sWy4wMDgyOTcsLjA2NzA0NiwuMDk5NDk5XSxbLjAwNzUzLC4wNzExNjUsLjEwNzYwM10sWy4wMDY3MDQsLjA3NTE5NiwuMTE1ODNdLFsuMDA1ODM4LC4wNzkxNCwuMTI0MTc4XSxbLjAwNDk0OSwuMDgyOTk0LC4xMzI2NDNdLFsuMDA0MDYyLC4wODY3NTgsLjE0MTIyM10sWy4wMDMxOTgsLjA5MDQzLC4xNDk5MTNdLFsuMDAyMzgyLC4wOTQwMSwuMTU4NzExXSxbLjAwMTY0MywuMDk3NDk0LC4xNjc2MTJdLFsuMDAxMDA5LC4xMDA4ODMsLjE3NjYxMl0sWzUxNGUtNiwuMTA0MTc0LC4xODU3MDRdLFsxODdlLTYsLjEwNzM2NiwuMTk0ODg2XSxbNjZlLTYsLjExMDQ1NywuMjA0MTUxXSxbMTg2ZS02LC4xMTM0NDUsLjIxMzQ5Nl0sWzU4N2UtNiwuMTE2MzI5LC4yMjI5MTRdLFsuMDAxMzA5LC4xMTkxMDYsLjIzMjM5N10sWy4wMDIzOTQsLjEyMTc3NiwuMjQxOTQyXSxbLjAwMzg4NiwuMTI0MzM2LC4yNTE1NDJdLFsuMDA1ODMxLC4xMjY3ODQsLjI2MTE4OV0sWy4wMDgyNzYsLjEyOTEyLC4yNzA4NzZdLFsuMDExMjY4LC4xMzEzNDIsLjI4MDU5OF0sWy4wMTQ4NTksLjEzMzQ0NywuMjkwMzQ1XSxbLjAxOTEsLjEzNTQzNSwuMzAwMTExXSxbLjAyNDA0MywuMTM3MzA1LC4zMDk4ODhdLFsuMDI5NzQyLC4xMzkwNTQsLjMxOTY2OV0sWy4wMzYyNTIsLjE0MDY4MywuMzI5NDQxXSxbLjA0MzUwNywuMTQyMTg5LC4zMzkyMDNdLFsuMDUwOTIyLC4xNDM1NzEsLjM0ODk0Ml0sWy4wNTg0MzIsLjE0NDgzMSwuMzU4NjQ5XSxbLjA2NjA0MSwuMTQ1OTY1LC4zNjgzMTldLFsuMDczNzQ0LC4xNDY5NzQsLjM3NzkzOF0sWy4wODE1NDEsLjE0Nzg1OCwuMzg3NTAxXSxbLjA4OTQzMSwuMTQ4NjE2LC4zOTY5OThdLFsuMDk3NDExLC4xNDkyNDgsLjQwNjQxOV0sWy4xMDU0NzksLjE0OTc1NCwuNDE1NzU1XSxbLjExMzYzNCwuMTUwMTM0LC40MjQ5OThdLFsuMTIxODczLC4xNTAzODksLjQzNDEzOV0sWy4xMzAxOTIsLjE1MDUyMSwuNDQzMTY3XSxbLjEzODU5MSwuMTUwNTI4LC40NTIwNzVdLFsuMTQ3MDY1LC4xNTA0MTMsLjQ2MDg1Ml0sWy4xNTU2MTQsLjE1MDE3NSwuNDY5NDkzXSxbLjE2NDIzMiwuMTQ5ODE4LC40Nzc5ODVdLFsuMTcyOTE3LC4xNDkzNDMsLjQ4NjMyMl0sWy4xODE2NjYsLjE0ODc1MSwuNDk0NDk0XSxbLjE5MDQ3NiwuMTQ4MDQ2LC41MDI0OTNdLFsuMTk5MzQ0LC4xNDcyMjksLjUxMDMxM10sWy4yMDgyNjcsLjE0NjMwMiwuNTE3OTQ0XSxbLjIxNzI0MiwuMTQ1MjY3LC41MjUzOF0sWy4yMjYyNjQsLjE0NDEzMSwuNTMyNjEzXSxbLjIzNTMzMSwuMTQyODk0LC41Mzk2MzVdLFsuMjQ0NDQsLjE0MTU1OSwuNTQ2NDQyXSxbLjI1MzU4NywuMTQwMTMxLC41NTMwMjZdLFsuMjYyNzY5LC4xMzg2MTUsLjU1OTM4MV0sWy4yNzE5ODEsLjEzNzAxNiwuNTY1NV0sWy4yODEyMjIsLjEzNTMzNSwuNTcxMzgxXSxbLjI5MDQ4NywuMTMzNTgxLC41NzcwMTddLFsuMjk5Nzc0LC4xMzE3NTcsLjU4MjQwNF0sWy4zMDkwOCwuMTI5ODY3LC41ODc1MzhdLFsuMzE4Mzk5LC4xMjc5MiwuNTkyNDE1XSxbLjMyNzczLC4xMjU5MjEsLjU5NzAzMl0sWy4zMzcwNjksLjEyMzg3NywuNjAxMzg1XSxbLjM0NjQxMywuMTIxNzkzLC42MDU0NzRdLFsuMzU1NzU4LC4xMTk2NzgsLjYwOTI5NV0sWy4zNjUxMDIsLjExNzU0LC42MTI4NDZdLFsuMzc0NDQzLC4xMTUzODYsLjYxNjEyN10sWy4zODM3NzQsLjExMzIyNiwuNjE5MTM4XSxbLjM5MzA5NiwuMTExMDY2LC42MjE4NzZdLFsuNDAyNDA0LC4xMDg5MTgsLjYyNDM0M10sWy40MTE2OTQsLjEwNjc5NCwuNjI2NTRdLFsuNDIwOTY3LC4xMDQ2OTgsLjYyODQ2Nl0sWy40MzAyMTcsLjEwMjY0NSwuNjMwMTIzXSxbLjQzOTQ0MiwuMTAwNjQ3LC42MzE1MTNdLFsuNDQ4NjM3LC4wOTg3MTcsLjYzMjYzOF0sWy40NTc4MDUsLjA5Njg2MSwuNjMzNDk5XSxbLjQ2Njk0LC4wOTUwOTUsLjYzNDFdLFsuNDc2MDQsLjA5MzQzMywuNjM0NDQzXSxbLjQ4NTEwMiwuMDkxODg1LC42MzQ1MzJdLFsuNDk0MTI1LC4wOTA0NjYsLjYzNDM3XSxbLjUwMzEwNCwuMDg5MTksLjYzMzk2Ml0sWy41MTIwNDEsLjA4ODA2NywuNjMzMzExXSxbLjUyMDkzMSwuMDg3MTA4LC42MzI0Ml0sWy41Mjk3NzMsLjA4NjMyOSwuNjMxMjk3XSxbLjUzODU2NCwuMDg1NzM4LC42Mjk5NDRdLFsuNTQ3MzAyLC4wODUzNDYsLjYyODM2N10sWy41NTU5ODYsLjA4NTE2MiwuNjI2NTcyXSxbLjU2NDYxNSwuMDg1MTksLjYyNDU2M10sWy41NzMxODcsLjA4NTQzOSwuNjIyMzQ1XSxbLjU4MTY5OCwuMDg1OTEzLC42MTk5MjZdLFsuNTkwMTQ5LC4wODY2MTUsLjYxNzMxMV0sWy41OTg1MzgsLjA4NzU0MywuNjE0NTAzXSxbLjYwNjg2MiwuMDg4NywuNjExNTExXSxbLjYxNTEyLC4wOTAwODQsLjYwODM0M10sWy42MjMzMTIsLjA5MTY5LC42MDUwMDFdLFsuNjMxNDM4LC4wOTM1MTEsLjYwMTQ4OV0sWy42Mzk0OTIsLjA5NTU0NiwuNTk3ODIxXSxbLjY0NzQ3NiwuMDk3Nzg3LC41OTM5OTldLFsuNjU1Mzg5LC4xMDAyMjYsLjU5MDAyOF0sWy42NjMyMywuMTAyODU2LC41ODU5MTRdLFsuNjcwOTk1LC4xMDU2NjksLjU4MTY2N10sWy42Nzg2ODYsLjEwODY1OCwuNTc3MjkxXSxbLjY4NjMwMiwuMTExODEzLC41NzI3OV0sWy42OTM4NCwuMTE1MTI5LC41NjgxNzVdLFsuNzAxMywuMTE4NTk3LC41NjM0NDldLFsuNzA4NjgyLC4xMjIyMDksLjU1ODYxNl0sWy43MTU5ODQsLjEyNTk1OSwuNTUzNjg3XSxbLjcyMzIwNiwuMTI5ODQsLjU0ODY2Nl0sWy43MzAzNDYsLjEzMzg0NiwuNTQzNTU4XSxbLjczNzQwNiwuMTM3OTcsLjUzODM2Nl0sWy43NDQzODIsLjE0MjIwOSwuNTMzMTAxXSxbLjc1MTI3NCwuMTQ2NTU2LC41Mjc3NjddLFsuNzU4MDgyLC4xNTEwMDgsLjUyMjM2OV0sWy43NjQ4MDUsLjE1NTU1OSwuNTE2OTEyXSxbLjc3MTQ0MywuMTYwMjA2LC41MTE0MDJdLFsuNzc3OTk1LC4xNjQ5NDYsLjUwNTg0NV0sWy43ODQ0NTksLjE2OTc3NCwuNTAwMjQ2XSxbLjc5MDgzNiwuMTc0Njg5LC40OTQ2MDddLFsuNzk3MTI1LC4xNzk2ODgsLjQ4ODkzNV0sWy44MDMzMjUsLjE4NDc2NywuNDgzMjM4XSxbLjgwOTQzNSwuMTg5OTI1LC40Nzc1MThdLFsuODE1NDU1LC4xOTUxNiwuNDcxNzgxXSxbLjgyMTM4NCwuMjAwNDcxLC40NjYwMjhdLFsuODI3MjIyLC4yMDU4NTQsLjQ2MDI2N10sWy44MzI5NjgsLjIxMTMwOCwuNDU0NTA1XSxbLjgzODYyMSwuMjE2ODM0LC40NDg3MzhdLFsuODQ0MTgxLC4yMjI0MjgsLjQ0Mjk3OV0sWy44NDk2NDcsLjIyODA5LC40MzcyM10sWy44NTUwMTksLjIzMzgxOSwuNDMxNDkxXSxbLjg2MDI5NSwuMjM5NjEzLC40MjU3NzFdLFsuODY1NDc1LC4yNDU0NzEsLjQyMDA3NF0sWy44NzA1NTgsLjI1MTM5MywuNDE0NDAzXSxbLjg3NTU0NSwuMjU3MzgsLjQwODc1OV0sWy44ODA0MzMsLjI2MzQyNywuNDAzMTUyXSxbLjg4NTIyMywuMjY5NTM1LC4zOTc1ODVdLFsuODg5OTEzLC4yNzU3MDUsLjM5MjA1OF0sWy44OTQ1MDMsLjI4MTkzNCwuMzg2NTc4XSxbLjg5ODk5MywuMjg4MjIyLC4zODExNTJdLFsuOTAzMzgxLC4yOTQ1NjksLjM3NTc4MV0sWy45MDc2NjcsLjMwMDk3NCwuMzcwNDY5XSxbLjkxMTg0OSwuMzA3NDM1LC4zNjUyMjNdLFsuOTE1OTI4LC4zMTM5NTMsLjM2MDA0OF0sWy45MTk5MDIsLjMyMDUyNywuMzU0OTQ4XSxbLjkyMzc3MSwuMzI3MTU1LC4zNDk5MjhdLFsuOTI3NTMzLC4zMzM4MzgsLjM0NDk5NF0sWy45MzExODgsLjM0MDU3NiwuMzQwMTQ5XSxbLjkzNDczNiwuMzQ3MzY2LC4zMzU0MDNdLFsuOTM4MTc1LC4zNTQyMDcsLjMzMDc2Ml0sWy45NDE1MDQsLjM2MTEwMSwuMzI2MjI5XSxbLjk0NDcyMywuMzY4MDQ1LC4zMjE4MTRdLFsuOTQ3ODMxLC4zNzUwMzksLjMxNzUyM10sWy45NTA4MjYsLjM4MjA4MywuMzEzMzY0XSxbLjk1MzcwOSwuMzg5MTc1LC4zMDkzNDVdLFsuOTU2NDc4LC4zOTYzMTQsLjMwNTQ3N10sWy45NTkxMzMsLjQwMzQ5OSwuMzAxNzY2XSxbLjk2MTY3MSwuNDEwNzMxLC4yOTgyMjFdLFsuOTY0MDkzLC40MTgwMDgsLjI5NDg1M10sWy45NjYzOTksLjQyNTMyNywuMjkxNjc2XSxbLjk2ODU4NiwuNDMyNjksLjI4ODY5Nl0sWy45NzA2NTQsLjQ0MDA5NSwuMjg1OTI2XSxbLjk3MjYwMywuNDQ3NTQsLjI4MzM4XSxbLjk3NDQzMSwuNDU1MDI1LC4yODEwNjddLFsuOTc2MTM5LC40NjI1NDcsLjI3OTAwM10sWy45Nzc3MjUsLjQ3MDEwNywuMjc3MTk4XSxbLjk3OTE4OCwuNDc3NzAzLC4yNzU2NjZdLFsuOTgwNTI5LC40ODUzMzIsLjI3NDQyMl0sWy45ODE3NDcsLjQ5Mjk5NSwuMjczNDc2XSxbLjk4Mjg0LC41MDA2OSwuMjcyODQyXSxbLjk4MzgwOCwuNTA4NDE1LC4yNzI1MzJdLFsuOTg0NjUzLC41MTYxNjgsLjI3MjU2XSxbLjk4NTM3MywuNTIzOTQ4LC4yNzI5MzddLFsuOTg1OTY2LC41MzE3NTQsLjI3MzY3M10sWy45ODY0MzYsLjUzOTU4MiwuMjc0Nzc5XSxbLjk4Njc4LC41NDc0MzQsLjI3NjI2NF0sWy45ODY5OTgsLjU1NTMwNSwuMjc4MTM1XSxbLjk4NzA5MSwuNTYzMTk1LC4yODA0MDFdLFsuOTg3MDYxLC41NzExLC4yODMwNjZdLFsuOTg2OTA3LC41NzkwMTksLjI4NjEzN10sWy45ODY2MjksLjU4Njk1LC4yODk2MTVdLFsuOTg2MjI5LC41OTQ4OTEsLjI5MzUwM10sWy45ODU3MDksLjYwMjgzOSwuMjk3ODAyXSxbLjk4NTA2OSwuNjEwNzkyLC4zMDI1MTJdLFsuOTg0MzEsLjYxODc0OCwuMzA3NjMyXSxbLjk4MzQzNSwuNjI2NzA0LC4zMTMxNTldLFsuOTgyNDQ1LC42MzQ2NTcsLjMxOTA4OV0sWy45ODEzNDEsLjY0MjYwNiwuMzI1NDJdLFsuOTgwMTMsLjY1MDU0NiwuMzMyMTQ0XSxbLjk3ODgxMiwuNjU4NDc1LC4zMzkyNTddLFsuOTc3MzkyLC42NjYzOTEsLjM0Njc1M10sWy45NzU4NywuNjc0MjksLjM1NDYyNV0sWy45NzQyNTIsLjY4MjE3LC4zNjI4NjVdLFsuOTcyNTQ1LC42OTAwMjYsLjM3MTQ2Nl0sWy45NzA3NSwuNjk3ODU2LC4zODA0MTldLFsuOTY4ODczLC43MDU2NTgsLjM4OTcxOF0sWy45NjY5MjEsLjcxMzQyNiwuMzk5MzUzXSxbLjk2NDkwMSwuNzIxMTU3LC40MDkzMTNdLFsuOTYyODE1LC43Mjg4NTEsLjQxOTU5NF0sWy45NjA2NzcsLjczNjUsLjQzMDE4MV0sWy45NTg0OSwuNzQ0MTAzLC40NDEwN10sWy45NTYyNjMsLjc1MTY1NiwuNDUyMjQ4XSxbLjk1NDAwOSwuNzU5MTUzLC40NjM3MDJdLFsuOTUxNzMyLC43NjY1OTUsLjQ3NTQyOV0sWy45NDk0NDUsLjc3Mzk3NCwuNDg3NDE0XSxbLjk0NzE1OCwuNzgxMjg5LC40OTk2NDddLFsuOTQ0ODg1LC43ODg1MzUsLjUxMjExNl0sWy45NDI2MzQsLjc5NTcwOSwuNTI0ODExXSxbLjk0MDQyMywuODAyODA3LC41Mzc3MTddLFsuOTM4MjYxLC44MDk4MjUsLjU1MDgyNV0sWy45MzYxNjMsLjgxNjc2LC41NjQxMjFdLFsuOTM0MTQ2LC44MjM2MDgsLjU3NzU5MV0sWy45MzIyMjQsLjgzMDM2NiwuNTkxMjJdLFsuOTMwNDEyLC44MzcwMzEsLjYwNDk5N10sWy45Mjg3MjcsLjg0MzU5OSwuNjE4OTA0XSxbLjkyNzE4NywuODUwMDY2LC42MzI5MjZdLFsuOTI1ODA5LC44NTY0MzIsLjY0NzA0N10sWy45MjQ2MSwuODYyNjkxLC42NjEyNDldLFsuOTIzNjA3LC44Njg4NDMsLjY3NTUxN10sWy45MjI4MiwuODc0ODg0LC42ODk4MzJdLFsuOTIyMjY1LC44ODA4MTIsLjcwNDE3NF0sWy45MjE5NjIsLjg4NjYyNiwuNzE4NTIzXSxbLjkyMTkzLC44OTIzMjMsLjczMjg1OV0sWy45MjIxODMsLjg5NzkwMywuNzQ3MTYzXSxbLjkyMjc0MSwuOTAzMzY0LC43NjE0MV0sWy45MjM2MiwuOTA4NzA2LC43NzU1OF0sWy45MjQ4MzcsLjkxMzkyOCwuNzg5NjQ4XSxbLjkyNjQwNSwuOTE5MDMxLC44MDM1OV0sWy45MjgzNCwuOTI0MDE1LC44MTczODFdLFsuOTMwNjU1LC45Mjg4ODEsLjgzMDk5NV0sWy45MzMzNiwuOTMzNjMxLC44NDQ0MDVdLFsuOTM2NDY2LC45MzgyNjcsLjg1NzU4M10sWy45Mzk5ODIsLjk0Mjc5MSwuODcwNDk5XSxbLjk0MzkxNCwuOTQ3MjA3LC44ODMxMjJdLFsuOTQ4MjY3LC45NTE1MTksLjg5NTQyMV0sWy45NTMwNDQsLjk1NTczMiwuOTA3MzU5XSxbLjk1ODI0NiwuOTU5ODUyLC45MTg5MDFdLFsuOTYzODY5LC45NjM4ODcsLjkzMDAwNF0sWy45Njk5MDksLjk2Nzg0NSwuOTQwNjIzXSxbLjk3NjM1NSwuOTcxNzM3LC45NTA3MDRdLFsuOTgzMTk1LC45NzU1OCwuOTYwMTgxXSxbLjk5MDQwMiwuOTc5Mzk1LC45Njg5NjZdLFsuOTk3OTMsLjk4MzIxNywuOTc2OTJdXSxzZT1bWzExM2UtNiwzNmUtNiwuMDAxMDczXSxbMTc1ZS02LDFlLTQsLjAwMTQxOV0sWzI1NGUtNiwxNzhlLTYsLjAwMTgzNV0sWzM0OWUtNiwyN2UtNSwuMDAyMzE5XSxbNDYxZS02LDM3NWUtNiwuMDAyODc0XSxbNTg3ZS02LDQ5MmUtNiwuMDAzNDk5XSxbNzNlLTUsNjIxZS02LC4wMDQxOTddLFs4ODdlLTYsNzYxZS02LC4wMDQ5NzNdLFsuMDAxMDYxLDkxMWUtNiwuMDA1ODI5XSxbLjAwMTI1LC4wMDEwNzEsLjAwNjc2OF0sWy4wMDE0NTYsLjAwMTI0LC4wMDc3OTVdLFsuMDAxNjc5LC4wMDE0MTgsLjAwODkxNF0sWy4wMDE5MTksLjAwMTYwMywuMDEwMTI4XSxbLjAwMjE3NywuMDAxNzk2LC4wMTE0NDFdLFsuMDAyNDUzLC4wMDE5OTQsLjAxMjg2XSxbLjAwMjc0OSwuMDAyMTk4LC4wMTQzOV0sWy4wMDMwNjYsLjAwMjQwNiwuMDE2MDMzXSxbLjAwMzQwNCwuMDAyNjE4LC4wMTc3OTVdLFsuMDAzNzY0LC4wMDI4MzMsLjAxOTY4Ml0sWy4wMDQxNDgsLjAwMzA1LC4wMjE2OThdLFsuMDA0NTU4LC4wMDMyNjcsLjAyMzg1Ml0sWy4wMDQ5OTQsLjAwMzQ4NCwuMDI2MTQ4XSxbLjAwNTQ1OSwuMDAzNjk5LC4wMjg1OTFdLFsuMDA1OTU0LC4wMDM5MTEsLjAzMTE4Nl0sWy4wMDY0ODIsLjAwNDEyLC4wMzM5NF0sWy4wMDcwNDQsLjAwNDMyMywuMDM2ODU3XSxbLjAwNzY0MywuMDA0NTE5LC4wMzk5NDRdLFsuMDA4MjgyLC4wMDQ3MDgsLjA0MzIwNV0sWy4wMDg5NjMsLjAwNDg4NywuMDQ2NjQ1XSxbLjAwOTY5LC4wMDUwNTQsLjA1MDI2OF0sWy4wMTA0NjUsLjAwNTIxLC4wNTQwNzddLFsuMDExMjkzLC4wMDUzNTEsLjA1ODA3NF0sWy4wMTIxNzYsLjAwNTQ3NiwuMDYyMjY1XSxbLjAxMzEyLC4wMDU1ODUsLjA2NjY0OF0sWy4wMTQxMjgsLjAwNTY3NSwuMDcxMjE1XSxbLjAxNTIwMiwuMDA1NzQ3LC4wNzU5NjNdLFsuMDE2MzQ5LC4wMDU3OTgsLjA4MDg4N10sWy4wMTc1NzMsLjAwNTgyOCwuMDg1OTgyXSxbLjAxODg3NywuMDA1ODM3LC4wOTEyMjNdLFsuMDIwMjY1LC4wMDU4MjYsLjA5NjU5OV0sWy4wMjE3NDEsLjAwNTc5NCwuMTAyMDldLFsuMDIzMzA2LC4wMDU3NDQsLjEwNzY2Ml0sWy4wMjQ5NjUsLjAwNTY3NiwuMTEzMjk3XSxbLjAyNjcxOCwuMDA1NTk1LC4xMTg5NDldLFsuMDI4NTY1LC4wMDU1MDMsLjEyNDU5NV0sWy4wMzA1MDYsLjAwNTQwMywuMTMwMTg3XSxbLjAzMjU0LC4wMDUzLC4xMzU2OTVdLFsuMDM0NjYzLC4wMDUxOTksLjE0MTA4MV0sWy4wMzY4NzQsLjAwNTEwMiwuMTQ2MzE0XSxbLjAzOTE2OSwuMDA1MDE1LC4xNTEzNjRdLFsuMDQxNTQzLC4wMDQ5NDIsLjE1NjIxMV0sWy4wNDM5OTQsLjAwNDg4NSwuMTYwODM1XSxbLjA0NjUxNywuMDA0ODQ3LC4xNjUyMjddLFsuMDQ5MTEsLjAwNDgzLC4xNjkzNzldLFsuMDUxNzY5LC4wMDQ4MzcsLjE3MzI5MV0sWy4wNTQ0OTQsLjAwNDg2NiwuMTc2OTY1XSxbLjA1NzI4MSwuMDA0OTIxLC4xODA0MDVdLFsuMDYwMTMsLjAwNDk5OCwuMTgzNjIyXSxbLjA2MzAzOCwuMDA1MTAxLC4xODY2MjRdLFsuMDY2MDA3LC4wMDUyMjYsLjE4OTQyMl0sWy4wNjkwMzYsLjAwNTM3NSwuMTkyMDI4XSxbLjA3MjEyNSwuMDA1NTQ1LC4xOTQ0NTNdLFsuMDc1Mjc2LC4wMDU3MzUsLjE5NjcwOV0sWy4wNzg0ODUsLjAwNTk0NywuMTk4ODA3XSxbLjA4MTc1NywuMDA2MTc3LC4yMDA3NThdLFsuMDg1MDkzLC4wMDY0MjUsLjIwMjU3MV0sWy4wODg0OTEsLjAwNjY5LC4yMDQyNTldLFsuMDkxOTU0LC4wMDY5NzEsLjIwNTgyN10sWy4wOTU0ODQsLjAwNzI2NywuMjA3Mjg0XSxbLjA5OTA4LC4wMDc1NzcsLjIwODY0XSxbLjEwMjc0MywuMDA3OTAxLC4yMDk5MDFdLFsuMTA2NDc2LC4wMDgyMzcsLjIxMTA3MV0sWy4xMTAyODEsLjAwODU4NSwuMjEyMTU4XSxbLjExNDE1NywuMDA4OTQ0LC4yMTMxNjZdLFsuMTE4MTA2LC4wMDkzMTQsLjIxNDEwM10sWy4xMjIxMjksLjAwOTY5MywuMjE0OTddLFsuMTI2MjI4LC4wMTAwODIsLjIxNTc3XSxbLjEzMDQwNiwuMDEwNDc5LC4yMTY1MV0sWy4xMzQ2NjEsLjAxMDg4NSwuMjE3MTg5XSxbLjEzODk5NiwuMDExMjk4LC4yMTc4MTFdLFsuMTQzNDExLC4wMTE3MTksLjIxODM4Ml0sWy4xNDc5MDgsLjAxMjE0NiwuMjE4OV0sWy4xNTI0OSwuMDEyNTgsLjIxOTM2OF0sWy4xNTcxNTYsLjAxMzAyMSwuMjE5Nzg3XSxbLjE2MTkwOCwuMDEzNDY3LC4yMjAxNTldLFsuMTY2NzQ4LC4wMTM5MTgsLjIyMDQ4NF0sWy4xNzE2NzcsLjAxNDM3NSwuMjIwNzY0XSxbLjE3NjY5NiwuMDE0ODM3LC4yMjFdLFsuMTgxODA2LC4wMTUzMDQsLjIyMTE5Ml0sWy4xODcwMDksLjAxNTc3NSwuMjIxMzRdLFsuMTkyMzA0LC4wMTYyNTEsLjIyMTQ0Nl0sWy4xOTc2OTQsLjAxNjczMSwuMjIxNTFdLFsuMjAzMTgxLC4wMTcyMTUsLjIyMTUzMV0sWy4yMDg3NjUsLjAxNzcwNCwuMjIxNTA5XSxbLjIxNDQ0NywuMDE4MTk2LC4yMjE0NDVdLFsuMjIwMjI4LC4wMTg2OTIsLjIyMTMzN10sWy4yMjYxMSwuMDE5MTkxLC4yMjExODhdLFsuMjMyMDk0LC4wMTk2OTUsLjIyMDk5NV0sWy4yMzgxODEsLjAyMDIwMiwuMjIwNzU4XSxbLjI0NDM3MSwuMDIwNzEyLC4yMjA0NzldLFsuMjUwNjY2LC4wMjEyMjcsLjIyMDE1NV0sWy4yNTcwNjYsLjAyMTc0NCwuMjE5Nzg2XSxbLjI2MzU3MywuMDIyMjY2LC4yMTkzNzNdLFsuMjcwMTg4LC4wMjI3OTIsLjIxODkxNF0sWy4yNzY5MTEsLjAyMzMyMSwuMjE4NDFdLFsuMjgzNzQyLC4wMjM4NTUsLjIxNzg2XSxbLjI5MDY4NCwuMDI0MzkyLC4yMTcyNjNdLFsuMjk3NzM3LC4wMjQ5MzQsLjIxNjYyXSxbLjMwNDg5OSwuMDI1NDgxLC4yMTU5M10sWy4zMTIxNzQsLjAyNjAzMiwuMjE1MTkyXSxbLjMxOTU2MSwuMDI2NTg5LC4yMTQ0MDZdLFsuMzI3MDYsLjAyNzE1LC4yMTM1NzFdLFsuMzM0NjcyLC4wMjc3MTgsLjIxMjY4OV0sWy4zNDIzOTgsLjAyODI5MSwuMjExNzU2XSxbLjM1MDIzNiwuMDI4ODcxLC4yMTA3NzVdLFsuMzU4MTg4LC4wMjk0NTcsLjIwOTc0Nl0sWy4zNjYyNTMsLjAzMDA1MSwuMjA4NjY2XSxbLjM3NDQzMSwuMDMwNjUyLC4yMDc1MzddLFsuMzgyNzIyLC4wMzEyNjIsLjIwNjM1OF0sWy4zOTExMjQsLjAzMTg4LC4yMDUxM10sWy4zOTk2NCwuMDMyNTA4LC4yMDM4NTNdLFsuNDA4MjY2LC4wMzMxNDYsLjIwMjUyNl0sWy40MTcwMDMsLjAzMzc5NSwuMjAxMTQ5XSxbLjQyNTg1LC4wMzQ0NTYsLjE5OTcyNF0sWy40MzQ4MDQsLjAzNTEyOSwuMTk4MjUxXSxbLjQ0Mzg2NywuMDM1ODE2LC4xOTY3MjldLFsuNDUzMDM1LC4wMzY1MTcsLjE5NTE1OV0sWy40NjIzMDYsLjAzNzIzMywuMTkzNTQyXSxbLjQ3MTY4LC4wMzc5NjYsLjE5MTg3OF0sWy40ODExNTQsLjAzODcxNywuMTkwMTY5XSxbLjQ5MDcyNywuMDM5NDg3LC4xODg0MTRdLFsuNTAwMzkzLC4wNDAyNzgsLjE4NjYxNV0sWy41MTAxNTIsLjA0MTA5LC4xODQ3NzNdLFsuNTE5OTk4LC4wNDE5MjYsLjE4Mjg5XSxbLjUyOTkzMSwuMDQyNzg4LC4xODA5NjZdLFsuNTM5OTQ0LC4wNDM2NzcsLjE3OTAwM10sWy41NTAwMzYsLjA0NDU5NSwuMTc3MDAyXSxbLjU2MDE5OCwuMDQ1NTQ0LC4xNzQ5NjZdLFsuNTcwNDI5LC4wNDY1MjYsLjE3Mjg5Nl0sWy41ODA3MjEsLjA0NzU0NSwuMTcwNzk0XSxbLjU5MTA3MSwuMDQ4NjAxLC4xNjg2NTldLFsuNjAxNDcxLC4wNDk2OTksLjE2NjQ5N10sWy42MTE5MTMsLjA1MDg0LC4xNjQzMV0sWy42MjIzOSwuMDUyMDI5LC4xNjIxXSxbLjYzMjg5NCwuMDUzMjY4LC4xNTk4N10sWy42NDM0MTgsLjA1NDU2MSwuMTU3NjI1XSxbLjY1Mzk1MSwuMDU1OTEsLjE1NTM2Nl0sWy42NjQ0ODUsLjA1NzMyMSwuMTUzMDk0XSxbLjY3NTAwOSwuMDU4Nzk2LC4xNTA4MTZdLFsuNjg1NTExLC4wNjAzNDEsLjE0ODUzNl0sWy42OTU5NzksLjA2MTk2MSwuMTQ2MjU5XSxbLjcwNjQwNCwuMDYzNjU5LC4xNDM5ODldLFsuNzE2NzcsLjA2NTQzOSwuMTQxNzI3XSxbLjcyNzA2NSwuMDY3MzA5LC4xMzk0ODJdLFsuNzM3Mjc1LC4wNjkyNzMsLjEzNzI1OV0sWy43NDczODUsLjA3MTMzNSwuMTM1MDY0XSxbLjc1NzM4LC4wNzM1MDIsLjEzMjkwMV0sWy43NjcyNDQsLjA3NTc3OSwuMTMwNzc3XSxbLjc3Njk2NSwuMDc4MTcxLC4xMjg2OTldLFsuNzg2NTI2LC4wODA2ODYsLjEyNjY3M10sWy43OTU5MSwuMDgzMzI3LC4xMjQ3MDVdLFsuODA1MTA3LC4wODYxLC4xMjI4MDNdLFsuODE0MDk3LC4wODkwMSwuMTIwOTc0XSxbLjgyMjg3MSwuMDkyMDYzLC4xMTkyMjRdLFsuODMxNDE0LC4wOTUyNjIsLjExNzU2MV0sWy44Mzk3MTcsLjA5ODYxMywuMTE1OTldLFsuODQ3NzY4LC4xMDIxMTcsLjExNDUxOF0sWy44NTU1NTksLjEwNTc3OSwuMTEzMTVdLFsuODYzMDg2LC4xMDk2MDEsLjExMTg5NF0sWy44NzAzNCwuMTEzNTg2LC4xMTA3NTNdLFsuODc3MzE5LC4xMTc3MzUsLjEwOTczMV0sWy44ODQwMjMsLjEyMjA0OCwuMTA4ODM0XSxbLjg5MDQ1MiwuMTI2NTI1LC4xMDgwNjZdLFsuODk2NjA2LC4xMzExNjcsLjEwNzQyN10sWy45MDI0ODcsLjEzNTk3MywuMTA2OTIxXSxbLjkwODEwMSwuMTQwOTQzLC4xMDY1NDhdLFsuOTEzNDU0LC4xNDYwNzQsLjEwNjMxMV0sWy45MTg1NTcsLjE1MTM2MywuMTA2MjEyXSxbLjkyMzQxMSwuMTU2ODEsLjEwNjI0OV0sWy45MjgwMjYsLjE2MjQxMywuMTA2NDIyXSxbLjkzMjQwOCwuMTY4MTcxLC4xMDY3MzFdLFsuOTM2NTY3LC4xNzQwNzksLjEwNzE3NV0sWy45NDA1MTEsLjE4MDEzNywuMTA3NzU0XSxbLjk0NDI0OSwuMTg2MzQzLC4xMDg0NjZdLFsuOTQ3NzksLjE5MjY5MiwuMTA5MzEyXSxbLjk1MTE0NSwuMTk5MTg1LC4xMTAyODldLFsuOTU0MzE4LC4yMDU4MTgsLjExMTM5OF0sWy45NTczMjEsLjIxMjU4OSwuMTEyNjM1XSxbLjk2MDE2LC4yMTk0OTcsLjExNDAwMl0sWy45NjI4NDEsLjIyNjUzOSwuMTE1NDk3XSxbLjk2NTM3MywuMjMzNzE2LC4xMTcxMTldLFsuOTY3NzYxLC4yNDEwMjYsLjExODg2N10sWy45NzAwMTEsLjI0ODQ2NiwuMTIwNzRdLFsuOTcyMTI2LC4yNTYwMzcsLjEyMjczOF0sWy45NzQxMTIsLjI2MzczOSwuMTI0ODU5XSxbLjk3NTk3MywuMjcxNTcxLC4xMjcxMDZdLFsuOTc3NzEyLC4yNzk1MzIsLjEyOTQ3NV0sWy45NzkzNTgsLjI4NzYxMywuMTMxOTY5XSxbLjk4MDkwMywuMjk1ODE5LC4xMzQ1ODVdLFsuOTgyMzM5LC4zMDQxNTQsLjEzNzMyNl0sWy45ODM2NjUsLjMxMjYxNiwuMTQwMTg5XSxbLjk4NDg4NSwuMzIxMjA5LC4xNDMxNzhdLFsuOTg2MDMsLjMyOTkxOSwuMTQ2Mjg5XSxbLjk4NzEwMiwuMzM4NzQ5LC4xNDk1MjRdLFsuOTg4MDcxLC4zNDc3MTEsLjE1Mjg4NV0sWy45ODg5MzksLjM1NjgwMywuMTU2MzcyXSxbLjk4OTc0OCwuMzY2MDE0LC4xNTk5ODRdLFsuOTkwNDk1LC4zNzUzNDMsLjE2MzcyM10sWy45OTExNDIsLjM4NDgwOCwuMTY3NTldLFsuOTkxNjk2LC4zOTQ0MDMsLjE3MTU4N10sWy45OTIyMzcsLjQwNDEwNiwuMTc1NzFdLFsuOTkyNjc5LC40MTM5NDMsLjE3OTk2NV0sWy45OTMwMTksLjQyMzkyMiwuMTg0MzU2XSxbLjk5MzM2MywuNDM0MDAyLC4xODg4NzFdLFsuOTkzNjEsLjQ0NDIyMiwuMTkzNTI2XSxbLjk5Mzc2NCwuNDU0NTgzLC4xOTgzMTldLFsuOTkzOTI1LC40NjUwNDcsLjIwMzI0XSxbLjk5Mzk4NCwuNDc1NjU1LC4yMDgzMDZdLFsuOTkzOTg0LC40ODYzOTUsLjIxMzUxMl0sWy45OTM5NjIsLjQ5NzI1MywuMjE4ODU1XSxbLjk5MzgzNSwuNTA4MjYxLC4yMjQzNDhdLFsuOTkzNzA1LC41MTkzODIsLjIyOTk3OV0sWy45OTM1MDIsLjUzMDY0MywuMjM1NzZdLFsuOTkzMjMyLC41NDIwNDQsLjI0MTY5NF0sWy45OTI5NTgsLjU1MzU2MiwuMjQ3NzddLFsuOTkyNTcsLjU2NTI0LC4yNTQwMTFdLFsuOTkyMjE3LC41NzcwMjQsLjI2MDM5M10sWy45OTE3NiwuNTg4OTY0LC4yNjY5NDJdLFsuOTkxMjkxLC42MDEwMzEsLjI3MzY0Nl0sWy45OTA3NzEsLjYxMzIzOCwuMjgwNTEzXSxbLjk5MDIsLjYyNTU4OCwuMjg3NTQ2XSxbLjk4OTYyMiwuNjM4MDY0LC4yOTQ3NF0sWy45ODg5NTksLjY1MDY5OSwuMzAyMTExXSxbLjk4ODMyNiwuNjYzNDUsLjMwOTY0MV0sWy45ODc1ODgsLjY3NjM2OCwuMzE3MzYxXSxbLjk4NjkwNiwuNjg5Mzk0LC4zMjUyMzZdLFsuOTg2MTAzLC43MDI1OTksLjMzMzMxMV0sWy45ODUzNzksLjcxNTkwNywuMzQxNTM5XSxbLjk4NDUzMywuNzI5MzkzLC4zNDk5NzRdLFsuOTgzNzY5LC43NDI5ODUsLjM1ODU2OF0sWy45ODI4ODgsLjc1Njc1OSwuMzY3MzcyXSxbLjk4MjA5OCwuNzcwNjM4LC4zNzYzMzZdLFsuOTgxMTk1LC43ODQ2OTgsLjM4NTUxNl0sWy45ODAzOTUsLjc5ODg2NCwuMzk0ODUzXSxbLjk3OTQ5MSwuODEzMjExLC40MDQ0MDddLFsuOTc4NjgyLC44Mjc2NzEsLjQxNDEyNl0sWy45Nzc3OTUsLjg0MjMwNiwuNDI0MDU4XSxbLjk3Njk4NywuODU3MDYxLC40MzQxNTZdLFsuOTc2MTMyLC44NzE5ODMsLjQ0NDQ2M10sWy45NzUzMzEsLjg4NzA0MSwuNDU0OTQ1XSxbLjk3NDUyNCwuOTAyMjU4LC40NjU2Ml0sWy45NzM3NCwuOTE3NjIyLC40NzY0ODFdLFsuOTcyOTkyLC45MzMxMzMsLjQ4NzUyMV0sWy45NzIyMjcsLjk0ODgxMywuNDk4NzU0XSxbLjk3MTU0NywuOTY0NjI5LC41MTAxNDldLFsuOTcwOCwuOTgwNjMzLC41MjE3NDldXSxpZT1bWzExM2UtNiwzNmUtNiwuMDAxMDczXSxbMTc1ZS02LDk4ZS02LC4wMDE0MzddLFsyNTVlLTYsMTc0ZS02LC4wMDE4NzZdLFszNTJlLTYsMjYzZS02LC4wMDIzOTJdLFs0NjVlLTYsMzYzZS02LC4wMDI5ODRdLFs1OTRlLTYsNDc1ZS02LC4wMDM2NTddLFs3NGUtNSw1OTdlLTYsLjAwNDQxNV0sWzkwM2UtNiw3MjllLTYsLjAwNTI1N10sWy4wMDEwODMsODY5ZS02LC4wMDYxOTddLFsuMDAxMjgyLC4wMDEwMTcsLjAwNzIzMV0sWy4wMDE0OTksLjAwMTE3MSwuMDA4MzY3XSxbLjAwMTczNywuMDAxMzMxLC4wMDk2MTNdLFsuMDAxOTk2LC4wMDE0OTYsLjAxMDk2OF0sWy4wMDIyNzgsLjAwMTY2NCwuMDEyNDQ0XSxbLjAwMjU4NCwuMDAxODM1LC4wMTQwNDVdLFsuMDAyOTE1LC4wMDIwMDYsLjAxNTc3M10sWy4wMDMyNzUsLjAwMjE3OCwuMDE3NjM0XSxbLjAwMzY2NCwuMDAyMzQ3LC4wMTk2NDRdLFsuMDA0MDg1LC4wMDI1MTMsLjAyMTc5OF0sWy4wMDQ1NDEsLjAwMjY3NiwuMDI0MTAyXSxbLjAwNTAzNCwuMDAyODMyLC4wMjY1NjFdLFsuMDA1NTY4LC4wMDI5OCwuMDI5MTg3XSxbLjAwNjE0NiwuMDAzMTE5LC4wMzE5OF0sWy4wMDY3NzIsLjAwMzI0NywuMDM0OTRdLFsuMDA3NDQ4LC4wMDMzNjIsLjAzODA3XSxbLjAwODE3OSwuMDAzNDY0LC4wNDEzNjldLFsuMDA4OTY5LC4wMDM1NSwuMDQ0ODM3XSxbLjAwOTgyMywuMDAzNjIsLjA0ODQ3XSxbLjAxMDc0NCwuMDAzNjcyLC4wNTIyNl0sWy4wMTE3MzYsLjAwMzcwNiwuMDU2MTk5XSxbLjAxMjgwNSwuMDAzNzIxLC4wNjAyNzRdLFsuMDEzOTUzLC4wMDM3MTgsLjA2NDQ2OF0sWy4wMTUxODMsLjAwMzY5NywuMDY4NzZdLFsuMDE2NDk5LC4wMDM2NTksLjA3MzEyOF0sWy4wMTc5MDIsLjAwMzYwNiwuMDc3NTQ2XSxbLjAxOTM5NSwuMDAzNTQsLjA4MTk4NV0sWy4wMjA5NzYsLjAwMzQ2NCwuMDg2NDE3XSxbLjAyMjY0NywuMDAzMzgxLC4wOTA4MV0sWy4wMjQ0MDQsLjAwMzI5NCwuMDk1MTMzXSxbLjAyNjI0NywuMDAzMjA2LC4wOTkzNl0sWy4wMjgxNzQsLjAwMzEyMSwuMTAzNDY3XSxbLjAzMDE4MiwuMDAzMDQyLC4xMDc0MzNdLFsuMDMyMjY5LC4wMDI5NzIsLjExMTI0MV0sWy4wMzQ0MzEsLjAwMjkxMywuMTE0ODc4XSxbLjAzNjY2OCwuMDAyODY2LC4xMTgzMzddLFsuMDM4OTc1LC4wMDI4MzQsLjEyMTYxMV0sWy4wNDEzNTEsLjAwMjgxOCwuMTI0N10sWy4wNDM3OTYsLjAwMjgxOCwuMTI3NjA0XSxbLjA0NjMwNywuMDAyODM0LC4xMzAzMjddLFsuMDQ4ODg0LC4wMDI4NjgsLjEzMjg3M10sWy4wNTE1MjcsLjAwMjkxOCwuMTM1MjQ4XSxbLjA1NDIzNSwuMDAyOTg1LC4xMzc0NTldLFsuMDU3MDA4LC4wMDMwNjksLjEzOTUxMl0sWy4wNTk4NDUsLjAwMzE2OCwuMTQxNDE3XSxbLjA2Mjc0NywuMDAzMjgzLC4xNDMxNzldLFsuMDY1NzE0LC4wMDM0MTIsLjE0NDgwN10sWy4wNjg3NDgsLjAwMzU1NSwuMTQ2MzA2XSxbLjA3MTg0OSwuMDAzNzEyLC4xNDc2ODVdLFsuMDc1MDE4LC4wMDM4ODIsLjE0ODk0OF0sWy4wNzgyNTUsLjAwNDA2NCwuMTUwMTA0XSxbLjA4MTU2MSwuMDA0MjU3LC4xNTExNTZdLFsuMDg0OTM3LC4wMDQ0NjIsLjE1MjExXSxbLjA4ODM4NCwuMDA0Njc3LC4xNTI5NzJdLFsuMDkxOTAzLC4wMDQ5MDIsLjE1Mzc0NF0sWy4wOTU0OTQsLjAwNTEzNywuMTU0NDMyXSxbLjA5OTE1OSwuMDA1MzgxLC4xNTUwMzldLFsuMTAyODk5LC4wMDU2MzQsLjE1NTU2OF0sWy4xMDY3MTQsLjAwNTg5NSwuMTU2MDIyXSxbLjExMDYwNiwuMDA2MTY0LC4xNTY0MDVdLFsuMTE0NTc2LC4wMDY0NDEsLjE1NjcxOF0sWy4xMTg2MjQsLjAwNjcyNCwuMTU2OTY0XSxbLjEyMjc1LC4wMDcwMTYsLjE1NzE0N10sWy4xMjY5NTcsLjAwNzMxNCwuMTU3MjY2XSxbLjEzMTI0NCwuMDA3NjE4LC4xNTczMjNdLFsuMTM1NjE0LC4wMDc5MjksLjE1NzMyXSxbLjE0MDA2NywuMDA4MjQ2LC4xNTcyNTddLFsuMTQ0NjAzLC4wMDg1NjksLjE1NzEzN10sWy4xNDkyMjMsLjAwODg5OCwuMTU2OTYxXSxbLjE1MzkzLC4wMDkyMzMsLjE1NjcyN10sWy4xNTg3MjIsLjAwOTU3NCwuMTU2NDRdLFsuMTYzNjAxLC4wMDk5MiwuMTU2MDk3XSxbLjE2ODU2NiwuMDEwMjcyLC4xNTU3MDFdLFsuMTczNjIxLC4wMTA2MywuMTU1MjU0XSxbLjE3ODc2MywuMDEwOTk0LC4xNTQ3NTRdLFsuMTgzOTk0LC4wMTEzNjMsLjE1NDIwM10sWy4xODkzMTYsLjAxMTczOCwuMTUzNTk5XSxbLjE5NDcyOSwuMDEyMTE5LC4xNTI5NDRdLFsuMjAwMjMxLC4wMTI1MDYsLjE1MjI0XSxbLjIwNTgyNSwuMDEyODk5LC4xNTE0ODVdLFsuMjExNTExLC4wMTMyOTgsLjE1MDY4Ml0sWy4yMTcyODgsLjAxMzcwMywuMTQ5ODI5XSxbLjIyMzE1OCwuMDE0MTE1LC4xNDg5MjldLFsuMjI5MTE5LC4wMTQ1MzQsLjE0Nzk4XSxbLjIzNTE3MywuMDE0OTYsLjE0Njk4M10sWy4yNDEzMTksLjAxNTM5MywuMTQ1OTRdLFsuMjQ3NTU5LC4wMTU4MzQsLjE0NDg1XSxbLjI1Mzg5LC4wMTYyODIsLjE0MzcxNV0sWy4yNjAzMTQsLjAxNjczOSwuMTQyNTM1XSxbLjI2NjgzLC4wMTcyMDQsLjE0MTMxXSxbLjI3MzQzNywuMDE3Njc5LC4xNDAwNDFdLFsuMjgwMTM2LC4wMTgxNjIsLjEzODczXSxbLjI4NjkyNywuMDE4NjU2LC4xMzczNzZdLFsuMjkzODA4LC4wMTkxNiwuMTM1OTgxXSxbLjMwMDc3OCwuMDE5Njc0LC4xMzQ1NDZdLFsuMzA3ODM4LC4wMjAyLC4xMzMwNzJdLFsuMzE0OTg3LC4wMjA3MzgsLjEzMTU1OF0sWy4zMjIyMjMsLjAyMTI4OCwuMTMwMDA3XSxbLjMyOTU0NSwuMDIxODUyLC4xMjg0MTldLFsuMzM2OTU1LC4wMjI0MjksLjEyNjc5N10sWy4zNDQ0NDcsLjAyMzAyMiwuMTI1MTQxXSxbLjM1MjAyMiwuMDIzNjI5LC4xMjM0NTJdLFsuMzU5NjgxLC4wMjQyNTIsLjEyMTczMl0sWy4zNjc0MTgsLjAyNDg5MywuMTE5OTgyXSxbLjM3NTIzNSwuMDI1NTUxLC4xMTgyMDNdLFsuMzgzMTI5LC4wMjYyMjgsLjExNjM5Nl0sWy4zOTEwOTgsLjAyNjkyNCwuMTE0NTYzXSxbLjM5OTE0MSwuMDI3NjQxLC4xMTI3MDddLFsuNDA3MjU1LC4wMjgzOCwuMTEwODI3XSxbLjQxNTQzNywuMDI5MTQyLC4xMDg5MjZdLFsuNDIzNjg1LC4wMjk5MjcsLjEwNzAwNl0sWy40MzE5OTksLjAzMDczOCwuMTA1MDY4XSxbLjQ0MDM3NSwuMDMxNTc1LC4xMDMxMTRdLFsuNDQ4ODA5LC4wMzI0MzksLjEwMTE0NV0sWy40NTczMDEsLjAzMzMzMiwuMDk5MTYzXSxbLjQ2NTg0NCwuMDM0MjU1LC4wOTcxNjldLFsuNDc0NDM5LC4wMzUyMSwuMDk1MTY2XSxbLjQ4MzA4MywuMDM2MTk4LC4wOTMxNTVdLFsuNDkxNzY4LC4wMzcyMiwuMDkxMTM4XSxbLjUwMDQ5NSwuMDM4Mjc5LC4wODkxMTddLFsuNTA5MjYsLjAzOTM3NSwuMDg3MDk0XSxbLjUxODA1NywuMDQwNTEsLjA4NTA3XSxbLjUyNjg4NSwuMDQxNjg3LC4wODMwNDddLFsuNTM1NzM4LC4wNDI5MDYsLjA4MTAyN10sWy41NDQ2MTMsLjA0NDE2OSwuMDc5MDFdLFsuNTUzNTA2LC4wNDU0NzksLjA3N10sWy41NjI0MTMsLjA0NjgzNywuMDc0OTk3XSxbLjU3MTMzLC4wNDgyNDUsLjA3MzAwM10sWy41ODAyNTIsLjA0OTcwNSwuMDcxMDE5XSxbLjU4OTE3NSwuMDUxMjE5LC4wNjkwNDhdLFsuNTk4MDkyLC4wNTI3ODksLjA2NzA5XSxbLjYwNzAwMywuMDU0NDE4LC4wNjUxNDhdLFsuNjE1OTAxLC4wNTYxMDYsLjA2MzIyMl0sWy42MjQ3OCwuMDU3ODU3LC4wNjEzMTRdLFsuNjMzNjM4LC4wNTk2NzIsLjA1OTQyNF0sWy42NDI0NjgsLjA2MTU1MywuMDU3NTU1XSxbLjY1MTI2NiwuMDYzNTA0LC4wNTU3MDhdLFsuNjYwMDI4LC4wNjU1MjUsLjA1Mzg4Ml0sWy42Njg3NDgsLjA2NzYxOSwuMDUyMDgxXSxbLjY3NzQyMywuMDY5Nzg4LC4wNTAzMDNdLFsuNjg2MDQ2LC4wNzIwMzYsLjA0ODU1MV0sWy42OTQ2MTQsLjA3NDM2MywuMDQ2ODI1XSxbLjcwMzExOSwuMDc2NzcyLC4wNDUxMjZdLFsuNzExNTYsLjA3OTI2NiwuMDQzNDU1XSxbLjcxOTkzMiwuMDgxODQ2LC4wNDE4MTFdLFsuNzI4MjI5LC4wODQ1MTUsLjA0MDE5N10sWy43MzY0NDYsLjA4NzI3NSwuMDM4NjEyXSxbLjc0NDU4LC4wOTAxMjgsLjAzNzA1N10sWy43NTI2MjQsLjA5MzA3NywuMDM1NTMxXSxbLjc2MDU3OCwuMDk2MTIzLC4wMzQwMzddLFsuNzY4NDM0LC4wOTkyNjksLjAzMjU3M10sWy43NzYxOSwuMTAyNTE3LC4wMzExNDFdLFsuNzgzODM5LC4xMDU4NjksLjAyOTczOV0sWy43OTEzODIsLjEwOTMyOCwuMDI4MzddLFsuNzk4ODA5LC4xMTI4OTQsLjAyNzAzMV0sWy44MDYxMjIsLjExNjU3MSwuMDI1NzI1XSxbLjgxMzMxNCwuMTIwMzYsLjAyNDQ1MV0sWy44MjAzODIsLjEyNDI2MywuMDIzMjA5XSxbLjgyNzMyNCwuMTI4MjgyLC4wMjE5OThdLFsuODM0MTM1LC4xMzI0MTksLjAyMDgyXSxbLjg0MDgxMiwuMTM2Njc3LC4wMTk2NzRdLFsuODQ3MzUzLC4xNDEwNTYsLjAxODU2XSxbLjg1Mzc1NSwuMTQ1NTU5LC4wMTc0NzhdLFsuODYwMDEyLC4xNTAxODcsLjAxNjQyOV0sWy44NjYxMjUsLjE1NDk0MiwuMDE1NDEyXSxbLjg3MjA5MSwuMTU5ODI3LC4wMTQ0MjhdLFsuODc3OTA3LC4xNjQ4NDIsLjAxMzQ3N10sWy44ODM1NjgsLjE2OTk5LC4wMTI1NThdLFsuODg5MDc1LC4xNzUyNzEsLjAxMTY3M10sWy44OTQ0MjIsLjE4MDY4OCwuMDEwODIxXSxbLjg5OTYxMiwuMTg2MjQzLC4wMTAwMDNdLFsuOTA0NjM4LC4xOTE5MzYsLjAwOTIxOV0sWy45MDk0OTksLjE5Nzc3LC4wMDg0N10sWy45MTQxOTYsLjIwMzc0NSwuMDA3NzU1XSxbLjkxODcyNCwuMjA5ODY1LC4wMDcwNzZdLFsuOTIzMDgxLC4yMTYxMjksLjAwNjQzNF0sWy45MjcyNjYsLjIyMjU0LC4wMDU4MjhdLFsuOTMxMjc5LC4yMjkwOTgsLjAwNTI2XSxbLjkzNTExNiwuMjM1ODA2LC4wMDQ3MzFdLFsuOTM4Nzc2LC4yNDI2NjYsLjAwNDI0Ml0sWy45NDIyNTcsLjI0OTY3NywuMDAzNzkzXSxbLjk0NTU1OCwuMjU2ODQzLC4wMDMzODZdLFsuOTQ4Njc3LC4yNjQxNjIsLjAwMzAyMl0sWy45NTE2MTMsLjI3MTYzOSwuMDAyNzA0XSxbLjk1NDM2NSwuMjc5Mjc0LC4wMDI0MzFdLFsuOTU2OTMsLjI4NzA2NywuMDAyMjA3XSxbLjk1OTMwNywuMjk1MDIxLC4wMDIwMzJdLFsuOTYxNDk4LC4zMDMxMzcsLjAwMTkwOV0sWy45NjM0OTUsLjMxMTQxNCwuMDAxODRdLFsuOTY1MzA0LC4zMTk4NTgsLjAwMTgyN10sWy45NjY5MTgsLjMyODQ2NSwuMDAxODczXSxbLjk2ODM0LC4zMzcyNDEsLjAwMTk4MV0sWy45Njk1NjgsLjM0NjE4NCwuMDAyMTUzXSxbLjk3MDYwMSwuMzU1Mjk1LC4wMDIzOTJdLFsuOTcxNDM1LC4zNjQ1NzYsLjAwMjcwMl0sWy45NzIwNzIsLjM3NDAyOSwuMDAzMDg3XSxbLjk3MjUxMywuMzgzNjU0LC4wMDM1NV0sWy45NzI3NTMsLjM5MzQ1MywuMDA0MDk1XSxbLjk3Mjc5NSwuNDAzNDI1LC4wMDQ3MjddLFsuOTcyNjM2LC40MTM1NzEsLjAwNTQ1MV0sWy45NzIyNzgsLjQyMzg5NCwuMDA2MjcxXSxbLjk3MTcxOSwuNDM0MzkxLC4wMDcxOTNdLFsuOTcwOTU5LC40NDUwNjYsLjAwODIyM10sWy45Njk5OTcsLjQ1NTkxOCwuMDA5MzY4XSxbLjk2ODgzOCwuNDY2OTQ4LC4wMTA2MzNdLFsuOTY3NDc4LC40NzgxNTYsLjAxMjAyN10sWy45NjU5MTUsLjQ4OTU0MywuMDEzNTU3XSxbLjk2NDE1NCwuNTAxMTA5LC4wMTUyMzFdLFsuOTYyMTk4LC41MTI4NSwuMDE3MDZdLFsuOTYwMDQ2LC41MjQ3NzEsLjAxOTA1Ml0sWy45NTc3MDQsLjUzNjg2NSwuMDIxMjE5XSxbLjk1NTE3NiwuNTQ5MTM2LC4wMjM1NzJdLFsuOTUyNDYyLC41NjE1NzgsLjAyNjEyM10sWy45NDk1NywuNTc0MTkxLC4wMjg4ODddLFsuOTQ2NTA4LC41ODY5NzMsLjAzMTg3OF0sWy45NDMyNzIsLjU5OTkyMywuMDM1MTEyXSxbLjkzOTg2OCwuNjEzMDM2LC4wMzg2MDldLFsuOTM2MzE3LC42MjYzMDgsLjA0MjM4Nl0sWy45MzI2MzMsLjYzOTcyOCwuMDQ2NDY0XSxbLjkyODgzMiwuNjUzMjkyLC4wNTA4NjVdLFsuOTI0OTE5LC42NjY5OTcsLjA1NTYxNl0sWy45MjA5MDUsLjY4MDgzNCwuMDYwNzQ4XSxbLjkxNjg0MSwuNjk0NzgzLC4wNjYyODVdLFsuOTEyNzU3LC43MDg4MzMsLjA3MjI1N10sWy45MDg2NTIsLjcyMjk3NSwuMDc4NzExXSxbLjkwNDU5OSwuNzM3MTg1LC4wODU2NzZdLFsuOTAwNjYzLC43NTE0MzIsLjA5MzE4NF0sWy44OTY4NTQsLjc2NTcwNywuMTAxMjk5XSxbLjg5MzI5NSwuNzc5OTY1LC4xMTAwMzldLFsuODkwMDQ0LC43OTQxNzUsLjExOTQ1OV0sWy44ODcyMDksLjgwODI5NiwuMTI5NTkxXSxbLjg4NDksLjgyMjI4MiwuMTQwNDY2XSxbLjg4MzIzOCwuODM2MDg3LC4xNTIxMDddLFsuODgyMzU2LC44NDk2NjIsLjE2NDUyXSxbLjg4MjM3OSwuODYyOTU3LC4xNzc2OTZdLFsuODgzNDM3LC44NzU5MzMsLjE5MTYwMV0sWy44ODU2MjcsLjg4ODU1NiwuMjA2MTkxXSxbLjg4OTAzOSwuOTAwODA0LC4yMjEzODhdLFsuODkzNzA4LC45MTI2NzMsLjIzNzEzMV0sWy44OTk2NjIsLjkyNDE2NSwuMjUzMzE5XSxbLjkwNjg4LC45MzUzLC4yNjk4NzVdLFsuOTE1MzE3LC45NDYxMDIsLjI4Njc1NV0sWy45MjQ5MzIsLjk1NjYwNywuMzAzODE3XSxbLjkzNTY0OCwuOTY2ODQ1LC4zMjEwNjddLFsuOTQ3Mzk1LC45NzY4NDcsLjMzODQ2XSxbLjk2MDExMSwuOTg2NjUxLC4zNTU5NTddLFsuOTczNzI5LC45OTYyODIsLjM3MzUyMl1dLGNlPVtbLjAwMzk3LC4wMDIzMDcsLjI0MDg1NF0sWy4wMDUyNjUsLjAwMjIsLjI0NTk5MV0sWy4wMDY2MTQsLjAwMjEwNiwuMjUwOTIxXSxbLjAwODAxNiwuMDAyMDIyLC4yNTU2N10sWy4wMDk0NywuMDAxOTQ4LC4yNjAyNThdLFsuMDEwOTc2LC4wMDE4ODIsLjI2NDcwNF0sWy4wMTI1MzIsLjAwMTgyMywuMjY5MDJdLFsuMDE0MTQxLC4wMDE3NzEsLjI3MzIyMl0sWy4wMTU4MDMsLjAwMTcyMywuMjc3MzI0XSxbLjAxNzUxOCwuMDAxNjc5LC4yODEzMzRdLFsuMDE5Mjg4LC4wMDE2MzcsLjI4NTI2MV0sWy4wMjExMTMsLjAwMTU5OCwuMjg5MTFdLFsuMDIyOTkzLC4wMDE1NjEsLjI5Mjg4OV0sWy4wMjQ5MjksLjAwMTUyNSwuMjk2NjAxXSxbLjAyNjkyMSwuMDAxNDksLjMwMDI1MV0sWy4wMjg5NywuMDAxNDU1LC4zMDM4NDJdLFsuMDMxMDc4LC4wMDE0MjEsLjMwNzM3Nl0sWy4wMzMyNDQsLjAwMTM4NiwuMzEwODU2XSxbLjAzNTQ2OSwuMDAxMzUsLjMxNDI4M10sWy4wMzc3NTMsLjAwMTMxNCwuMzE3NjU5XSxbLjA0MDA5OCwuMDAxMjc3LC4zMjA5ODNdLFsuMDQyNTAzLC4wMDEyMzksLjMyNDI1N10sWy4wNDQ5NywuMDAxMiwuMzI3NDhdLFsuMDQ3NDk5LC4wMDExNTksLjMzMDY1M10sWy4wNTAwOTIsLjAwMTExOCwuMzMzNzczXSxbLjA1Mjc0OCwuMDAxMDc0LC4zMzY4NDFdLFsuMDU1NDY5LC4wMDEwMywuMzM5ODU0XSxbLjA1ODI1Myw5ODRlLTYsLjM0MjgxM10sWy4wNjExMDQsOTM3ZS02LC4zNDU3MTVdLFsuMDY0MDIsODg5ZS02LC4zNDg1NTddLFsuMDY3MDAyLDg0ZS01LC4zNTEzNF0sWy4wNzAwNTEsNzllLTUsLjM1NDA1OV0sWy4wNzMxNjcsNzRlLTUsLjM1NjcxNF0sWy4wNzYzNTEsNjg5ZS02LC4zNTkzXSxbLjA3OTYwNCw2MzhlLTYsLjM2MTgxN10sWy4wODI5MjUsNTg2ZS02LC4zNjQyNjFdLFsuMDg2MzE1LDUzNWUtNiwuMzY2NjI4XSxbLjA4OTc3NSw0ODVlLTYsLjM2ODkxOF0sWy4wOTMzMDMsNDM1ZS02LC4zNzExMjVdLFsuMDk2OTAyLDM4NmUtNiwuMzczMjQ4XSxbLjEwMDU3MSwzMzllLTYsLjM3NTI4NF0sWy4xMDQzMSwyOTRlLTYsLjM3NzIyOV0sWy4xMDgxMTksMjUxZS02LC4zNzkwOF0sWy4xMTE5OTksMjExZS02LC4zODA4MzRdLFsuMTE1OTQ5LDE3NGUtNiwuMzgyNDg4XSxbLjExOTk3LDE0ZS01LC4zODQwMzhdLFsuMTI0MDYyLDExMWUtNiwuMzg1NDgzXSxbLjEyODIyNCw4NmUtNiwuMzg2ODE4XSxbLjEzMjQ1Niw2NmUtNiwuMzg4MDRdLFsuMTM2NzU4LDUyZS02LC4zODkxNDZdLFsuMTQxMTI5LDQ1ZS02LC4zOTAxMzRdLFsuMTQ1NTcsNDRlLTYsLjM5MTAwMl0sWy4xNTAwOCw1ZS01LC4zOTE3NDddLFsuMTU0NjU3LDY0ZS02LC4zOTIzNjVdLFsuMTU5MzAzLDg3ZS02LC4zOTI4NTVdLFsuMTY0MDE2LDExOWUtNiwuMzkzMjE0XSxbLjE2ODc5NywxNjFlLTYsLjM5MzQ0XSxbLjE3MzY0MiwyMTNlLTYsLjM5MzUzMl0sWy4xNzg1NTMsMjc3ZS02LC4zOTM0ODldLFsuMTgzNTI5LDM1MmUtNiwuMzkzMzA3XSxbLjE4ODU2Nyw0MzllLTYsLjM5Mjk4N10sWy4xOTM2NjcsNTRlLTUsLjM5MjUyOF0sWy4xOTg4MjgsNjU1ZS02LC4zOTE5M10sWy4yMDQwNSw3ODRlLTYsLjM5MTE5MV0sWy4yMDkzMyw5MjhlLTYsLjM5MDMxMl0sWy4yMTQ2NjksLjAwMTA4OCwuMzg5MjkxXSxbLjIyMDA2NCwuMDAxMjY0LC4zODgxM10sWy4yMjU1MTMsLjAwMTQ1OCwuMzg2ODMxXSxbLjIzMTAxNywuMDAxNjY5LC4zODUzOTRdLFsuMjM2NTcxLC4wMDE4OTksLjM4MzgyXSxbLjI0MjE3NiwuMDAyMTQ4LC4zODIxMTFdLFsuMjQ3ODMsLjAwMjQxNiwuMzgwMjddLFsuMjUzNTMyLC4wMDI3MDUsLjM3ODI5OV0sWy4yNTkyNzgsLjAwMzAxNSwuMzc2MTk5XSxbLjI2NTA2OCwuMDAzMzQ2LC4zNzM5NzRdLFsuMjcwOTAxLC4wMDM3LC4zNzE2MjhdLFsuMjc2NzczLC4wMDQwNzYsLjM2OTE2M10sWy4yODI2ODQsLjAwNDQ3NiwuMzY2NTg0XSxbLjI4ODYzMywuMDA0ODk5LC4zNjM4OTNdLFsuMjk0NjE2LC4wMDUzNDcsLjM2MTA5Nl0sWy4zMDA2MzEsLjAwNTgxOSwuMzU4MTk3XSxbLjMwNjY3OCwuMDA2MzE3LC4zNTUxOTldLFsuMzEyNzU1LC4wMDY4NCwuMzUyMTA5XSxbLjMxODg1NywuMDA3MzksLjM0ODkzMV0sWy4zMjQ5ODYsLjAwNzk2NiwuMzQ1NjcxXSxbLjMzMTEzOSwuMDA4NTY5LC4zNDIzMzJdLFsuMzM3MzE1LC4wMDkyLC4zMzg5Ml0sWy4zNDM1MTEsLjAwOTg1OCwuMzM1NDQyXSxbLjM0OTcyNSwuMDEwNTQ1LC4zMzE5MDJdLFsuMzU1OTU3LC4wMTEyNTksLjMyODMwNV0sWy4zNjIyMDQsLjAxMjAwMywuMzI0NjU2XSxbLjM2ODQ2NCwuMDEyNzc2LC4zMjA5NjJdLFsuMzc0NzM3LC4wMTM1NzgsLjMxNzIyNl0sWy4zODEwMjIsLjAxNDQwOSwuMzEzNDU1XSxbLjM4NzMxNiwuMDE1MjcxLC4zMDk2NTNdLFsuMzkzNjE3LC4wMTYxNjIsLjMwNTgyNV0sWy4zOTk5MjUsLjAxNzA4NCwuMzAxOTc3XSxbLjQwNjI0LC4wMTgwMzYsLjI5ODExM10sWy40MTI1NTksLjAxOTAxOSwuMjk0MjM2XSxbLjQxODg4MiwuMDIwMDM0LC4yOTAzNTFdLFsuNDI1MjA2LC4wMjEwNzksLjI4NjQ2NF0sWy40MzE1MzIsLjAyMjE1NSwuMjgyNTc4XSxbLjQzNzg2LC4wMjMyNjQsLjI3ODY5Nl0sWy40NDQxODcsLjAyNDQwMywuMjc0ODIxXSxbLjQ1MDUxMiwuMDI1NTc1LC4yNzA5NThdLFsuNDU2ODM3LC4wMjY3NzksLjI2NzEwOV0sWy40NjMxNTgsLjAyODAxNiwuMjYzMjc4XSxbLjQ2OTQ3NiwuMDI5Mjg1LC4yNTk0NjVdLFsuNDc1NzkxLC4wMzA1ODYsLjI1NTY3Nl0sWy40ODIxMDMsLjAzMTkyLC4yNTE5MTJdLFsuNDg4NDA4LC4wMzMyODgsLjI0ODE3NF0sWy40OTQ3MSwuMDM0Njg4LC4yNDQ0NjVdLFsuNTAxMDA2LC4wMzYxMjIsLjI0MDc4OF0sWy41MDcyOTcsLjAzNzU5LC4yMzcxNDRdLFsuNTEzNTgxLC4wMzkwOTIsLjIzMzUzMl0sWy41MTk4NiwuMDQwNjI3LC4yMjk5NTVdLFsuNTI2MTMsLjA0MjE5NywuMjI2NDE0XSxbLjUzMjM5NiwuMDQzODAyLC4yMjI5MDldLFsuNTM4NjU0LC4wNDU0NDEsLjIxOTQ0M10sWy41NDQ5MDUsLjA0NzExNiwuMjE2MDE0XSxbLjU1MTE0NywuMDQ4ODI2LC4yMTI2MjNdLFsuNTU3Mzg0LC4wNTA1NzEsLjIwOTI3MV0sWy41NjM2MTMsLjA1MjM1MywuMjA1OTZdLFsuNTY5ODMyLC4wNTQxNywuMjAyNjg4XSxbLjU3NjA0NCwuMDU2MDI1LC4xOTk0NTddLFsuNTgyMjQ4LC4wNTc5MTYsLjE5NjI2NF0sWy41ODg0NDMsLjA1OTg0NCwuMTkzMTFdLFsuNTk0NjI5LC4wNjE4MSwuMTg5OTk3XSxbLjYwMDgwOCwuMDYzODE0LC4xODY5MjFdLFsuNjA2OTc2LC4wNjU4NTYsLjE4Mzg4NV0sWy42MTMxMzUsLjA2NzkzNywuMTgwODg3XSxbLjYxOTI4NCwuMDcwMDU3LC4xNzc5MjddLFsuNjI1NDI1LC4wNzIyMTcsLjE3NTAwNl0sWy42MzE1NTMsLjA3NDQxNywuMTcyMTIxXSxbLjYzNzY3MiwuMDc2NjU3LC4xNjkyNzRdLFsuNjQzNzgsLjA3ODkzOSwuMTY2NDYzXSxbLjY0OTg3OCwuMDgxMjYyLC4xNjM2ODddLFsuNjU1OTYzLC4wODM2MjcsLjE2MDk0Nl0sWy42NjIwMzQsLjA4NjAzNSwuMTU4MjRdLFsuNjY4MDkzLC4wODg0ODYsLjE1NTU2N10sWy42NzQxNCwuMDkwOTgsLjE1MjkyOV0sWy42ODAxNzIsLjA5MzUxOSwuMTUwMzI0XSxbLjY4NjE5MSwuMDk2MTAzLC4xNDc3NV0sWy42OTIxOTIsLjA5ODczMywuMTQ1MjA5XSxbLjY5ODE3OCwuMTAxNDA5LC4xNDI2OThdLFsuNzA0MTQ4LC4xMDQxMzEsLjE0MDIxOF0sWy43MTAxMDEsLjEwNjkwMiwuMTM3NzY4XSxbLjcxNjAzNCwuMTA5NzIsLjEzNTM0OF0sWy43MjE5NDcsLjExMjU4OCwuMTMyOTU3XSxbLjcyNzg0LC4xMTU1MDcsLjEzMDU5NF0sWy43MzM3MTMsLjExODQ3NSwuMTI4MjU5XSxbLjczOTU2MiwuMTIxNDk1LC4xMjU5NTFdLFsuNzQ1Mzg4LC4xMjQ1NjcsLjEyMzY3XSxbLjc1MTE4OSwuMTI3NjkyLC4xMjE0MTZdLFsuNzU2OTY0LC4xMzA4NzIsLjExOTE4OF0sWy43NjI3MTMsLjEzNDEwNywuMTE2OTg2XSxbLjc2ODQzMiwuMTM3Mzk3LC4xMTQ4MDldLFsuNzc0MTIxLC4xNDA3NDMsLjExMjY1N10sWy43Nzk3NzgsLjE0NDE0NywuMTEwNTNdLFsuNzg1NDAzLC4xNDc2MTEsLjEwODQyNl0sWy43OTA5OTMsLjE1MTEzNCwuMTA2MzQ3XSxbLjc5NjU0OCwuMTU0NzE3LC4xMDQyOTFdLFsuODAyMDY1LC4xNTgzNjIsLjEwMjI1OV0sWy44MDc1NDMsLjE2MjA3MSwuMTAwMjQ5XSxbLjgxMjk3OSwuMTY1ODQzLC4wOTgyNjRdLFsuODE4Mzc1LC4xNjk2NzksLjA5NjNdLFsuODIzNzI0LC4xNzM1ODEsLjA5NDM1OV0sWy44MjkwMjYsLjE3NzU1MSwuMDkyNDRdLFsuODM0MjgyLC4xODE1ODksLjA5MDU0M10sWy44Mzk0ODcsLjE4NTY5NiwuMDg4NjY4XSxbLjg0NDYzOSwuMTg5ODc0LC4wODY4MTZdLFsuODQ5NzM4LC4xOTQxMjQsLjA4NDk4NF0sWy44NTQ3ODIsLjE5ODQ0NywuMDgzMTc1XSxbLjg1OTc2OSwuMjAyODQzLC4wODEzODddLFsuODY0NjkzLC4yMDczMTYsLjA3OTYyXSxbLjg2OTU1NSwuMjExODY1LC4wNzc4NzZdLFsuODc0MzU0LC4yMTY0OTIsLjA3NjE1Ml0sWy44NzkwODYsLjIyMTE5OCwuMDc0NDQ5XSxbLjg4Mzc1LC4yMjU5ODQsLjA3Mjc2OV0sWy44ODgzNDIsLjIzMDg1MiwuMDcxMTA5XSxbLjg5Mjg2NCwuMjM1ODA0LC4wNjk0NzJdLFsuODk3MzA5LC4yNDA4MzksLjA2Nzg1NV0sWy45MDE2NzYsLjI0NTk2LC4wNjYyNTldLFsuOTA1OTYyLC4yNTExNjgsLjA2NDY4NV0sWy45MTAxNjcsLjI1NjQ2NSwuMDYzMTMyXSxbLjkxNDI4OSwuMjYxODUxLC4wNjE2MDFdLFsuOTE4MzI1LC4yNjczMjgsLjA2MDA5Ml0sWy45MjIyNzIsLjI3Mjg5NywuMDU4NjA1XSxbLjkyNjEyNiwuMjc4NTYsLjA1NzE0XSxbLjkyOTg4OSwuMjg0MzE5LC4wNTU2OTVdLFsuOTMzNTU1LC4yOTAxNzMsLjA1NDI3M10sWy45MzcxMjEsLjI5NjEyNywuMDUyODczXSxbLjk0MDU4NywuMzAyMTc5LC4wNTE0OTVdLFsuOTQzOTUxLC4zMDgzMzIsLjA1MDEzOV0sWy45NDcyMTMsLjMxNDU4NywuMDQ4ODA2XSxbLjk1MDM2MywuMzIwOTQ2LC4wNDc0OTZdLFsuOTUzNDA3LC4zMjc0MDksLjA0NjIwOV0sWy45NTYzMzYsLjMzMzk3OCwuMDQ0OTQ0XSxbLjk1OTE1NCwuMzQwNjU2LC4wNDM3MDRdLFsuOTYxODUzLC4zNDc0NDIsLjA0MjQ4Nl0sWy45NjQ0MzEsLjM1NDM0MiwuMDQxMjkyXSxbLjk2Njg4NywuMzYxMzUyLC4wNDAxMjFdLFsuOTY5MjE3LC4zNjg0NzYsLjAzODk3NV0sWy45NzE0MjMsLjM3NTcxNSwuMDM3ODU0XSxbLjk3MzUsLjM4MzA3MSwuMDM2NzU3XSxbLjk3NTQ0NiwuMzkwNTQ2LC4wMzU2ODVdLFsuOTc3MjU2LC4zOTgxMzksLjAzNDYzOV0sWy45Nzg5MzEsLjQwNTg1NCwuMDMzNjE5XSxbLjk4MDQ2OSwuNDEzNjkxLC4wMzI2MjVdLFsuOTgxODY0LC40MjE2NTIsLjAzMTY1OF0sWy45ODMxMTYsLjQyOTc0LC4wMzA3MTddLFsuOTg0MjIyLC40Mzc5NTQsLjAyOTgwNV0sWy45ODUxNzgsLjQ0NjI5NiwuMDI4OTIxXSxbLjk4NTk4NSwuNDU0NzcsLjAyODA2NV0sWy45ODY2MzcsLjQ2MzM3NCwuMDI3MjM5XSxbLjk4NzEzNiwuNDcyMTEyLC4wMjY0NDJdLFsuOTg3NDc1LC40ODA5ODQsLjAyNTY3Nl0sWy45ODc2NTMsLjQ4OTk5NCwuMDI0OTQxXSxbLjk4NzY3MiwuNDk5MTQxLC4wMjQyMzhdLFsuOTg3NTIyLC41MDg0MjcsLjAyMzU2OF0sWy45ODcyMDYsLjUxNzg1MiwuMDIyOTNdLFsuOTg2NzIzLC41Mjc0MjIsLjAyMjMyN10sWy45ODYwNjksLjUzNzEzMywuMDIxNzU5XSxbLjk4NTIzNiwuNTQ2OTkzLC4wMjEyMjZdLFsuOTg0MjI0LC41NTY5OTksLjAyMDcyOF0sWy45ODMwMzQsLjU2NzE1NCwuMDIwMjY4XSxbLjk4MTY2NSwuNTc3NDU3LC4wMTk4NDddLFsuOTgwMTE4LC41ODc5MTIsLjAxOTQ2NF0sWy45NzgzODgsLjU5ODUxNywuMDE5MTIxXSxbLjk3NjQ3NSwuNjA5Mjc0LC4wMTg4MTldLFsuOTc0MzcsLjYyMDE5MSwuMDE4NTU4XSxbLjk3MjA3LC42MzEyNjQsLjAxODMzOF0sWy45Njk1ODQsLjY0MjQ5NSwuMDE4MTZdLFsuOTY2OTE2LC42NTM4OCwuMDE4MDI2XSxbLjk2NDA1NywuNjY1NDI1LC4wMTc5MzVdLFsuOTYwOTkxLC42NzcxMzksLjAxNzg4Nl0sWy45NTc3NDIsLjY4OTAwOCwuMDE3ODgxXSxbLjk1NDMxNiwuNzAxMDM1LC4wMTc5MTldLFsuOTUwNjcsLjcxMzIzOCwuMDE3OTk2XSxbLjk0Njg1MywuNzI1NTk4LC4wMTgxMTVdLFsuOTQyODQ0LC43MzgxMjQsLjAxODI3MV0sWy45Mzg2NDQsLjc1MDgxOCwuMDE4NDYxXSxbLjkzNDI3MiwuNzYzNjczLC4wMTg2ODNdLFsuOTI5NzA5LC43NzY2OTgsLjAxODkyOF0sWy45MjQ5OCwuNzg5ODg2LC4wMTkxOTFdLFsuOTIwMDk3LC44MDMyMzYsLjAxOTQ2Ml0sWy45MTUwMzQsLjgxNjc1OSwuMDE5NzI2XSxbLjkwOTg0OCwuODMwNDQsLjAxOTk2OF0sWy45MDQ1NDMsLjg0NDI3NSwuMDIwMTY0XSxbLjg5OTE0NCwuODU4MjY2LC4wMjAyODRdLFsuODkzNjc4LC44NzI0MDYsLjAyMDI4NV0sWy44ODgyMDIsLjg4NjY4MywuMDIwMTFdLFsuODgyOCwuOTAxMDc2LC4wMTk2ODJdLFsuODc3NjI3LC45MTU1NDIsLjAxODg5NF0sWy44NzI4NzgsLjkzMDAyOSwuMDE3NTk0XSxbLjg2ODkzMSwuOTQ0NDE2LC4wMTU1OV1dLGxlPVtbLjE4OTk1LC4wNzE3NiwuMjMyMTddLFsuMTk0ODMsLjA4MzM5LC4yNjE0OV0sWy4xOTk1NiwuMDk0OTgsLjI5MDI0XSxbLjIwNDE1LC4xMDY1MiwuMzE4NDRdLFsuMjA4NiwuMTE4MDIsLjM0NjA3XSxbLjIxMjkxLC4xMjk0NywuMzczMTRdLFsuMjE3MDgsLjE0MDg3LC4zOTk2NF0sWy4yMjExMSwuMTUyMjMsLjQyNTU4XSxbLjIyNSwuMTYzNTQsLjQ1MDk2XSxbLjIyODc1LC4xNzQ4MSwuNDc1NzhdLFsuMjMyMzYsLjE4NjAzLC41MDAwNF0sWy4yMzU4MiwuMTk3MiwuNTIzNzNdLFsuMjM5MTUsLjIwODMzLC41NDY4Nl0sWy4yNDIzNCwuMjE5NDEsLjU2OTQyXSxbLjI0NTM5LC4yMzA0NCwuNTkxNDJdLFsuMjQ4MywuMjQxNDMsLjYxMjg2XSxbLjI1MTA3LC4yNTIzNywuNjMzNzRdLFsuMjUzNjksLjI2MzI3LC42NTQwNl0sWy4yNTYxOCwuMjc0MTIsLjY3MzgxXSxbLjI1ODUzLC4yODQ5MiwuNjkzXSxbLjI2MDc0LC4yOTU2OCwuNzExNjJdLFsuMjYyOCwuMzA2MzksLjcyOTY4XSxbLjI2NDczLC4zMTcwNiwuNzQ3MThdLFsuMjY2NTIsLjMyNzY4LC43NjQxMl0sWy4yNjgxNiwuMzM4MjUsLjc4MDVdLFsuMjY5NjcsLjM0ODc4LC43OTYzMV0sWy4yNzEwMywuMzU5MjYsLjgxMTU2XSxbLjI3MjI2LC4zNjk3LC44MjYyNF0sWy4yNzMzNCwuMzgwMDgsLjg0MDM3XSxbLjI3NDI5LC4zOTA0MywuODUzOTNdLFsuMjc1MDksLjQwMDcyLC44NjY5Ml0sWy4yNzU3NiwuNDEwOTcsLjg3OTM2XSxbLjI3NjI4LC40MjExOCwuODkxMjNdLFsuMjc2NjcsLjQzMTM0LC45MDI1NF0sWy4yNzY5MSwuNDQxNDUsLjkxMzI4XSxbLjI3NzAxLC40NTE1MiwuOTIzNDddLFsuMjc2OTgsLjQ2MTUzLC45MzMwOV0sWy4yNzY4LC40NzE1MSwuOTQyMTRdLFsuMjc2NDgsLjQ4MTQ0LC45NTA2NF0sWy4yNzYwMywuNDkxMzIsLjk1ODU3XSxbLjI3NTQzLC41MDExNSwuOTY1OTRdLFsuMjc0NjksLjUxMDk0LC45NzI3NV0sWy4yNzM4MSwuNTIwNjksLjk3ODk5XSxbLjI3MjczLC41MzA0LC45ODQ2MV0sWy4yNzEwNiwuNTQwMTUsLjk4OTNdLFsuMjY4NzgsLjU0OTk1LC45OTMwM10sWy4yNjU5MiwuNTU5NzksLjk5NTgzXSxbLjI2MjUyLC41Njk2NywuOTk3NzNdLFsuMjU4NjIsLjU3OTU4LC45OTg3Nl0sWy4yNTQyNSwuNTg5NSwuOTk4OTZdLFsuMjQ5NDYsLjU5OTQzLC45OTgzNV0sWy4yNDQyNywuNjA5MzcsLjk5Njk3XSxbLjIzODc0LC42MTkzMSwuOTk0ODVdLFsuMjMyODgsLjYyOTIzLC45OTIwMl0sWy4yMjY3NiwuNjM5MTMsLjk4ODUxXSxbLjIyMDM5LC42NDkwMSwuOTg0MzZdLFsuMjEzODIsLjY1ODg2LC45Nzk1OV0sWy4yMDcwOCwuNjY4NjYsLjk3NDIzXSxbLjIwMDIxLC42Nzg0MiwuOTY4MzNdLFsuMTkzMjYsLjY4ODEyLC45NjE5XSxbLjE4NjI1LC42OTc3NSwuOTU0OThdLFsuMTc5MjMsLjcwNzMyLC45NDc2MV0sWy4xNzIyMywuNzE2OCwuOTM5ODFdLFsuMTY1MjksLjcyNjIsLjkzMTYxXSxbLjE1ODQ0LC43MzU1MSwuOTIzMDVdLFsuMTUxNzMsLjc0NDcyLC45MTQxNl0sWy4xNDUxOSwuNzUzODEsLjkwNDk2XSxbLjEzODg2LC43NjI3OSwuODk1NV0sWy4xMzI3OCwuNzcxNjUsLjg4NThdLFsuMTI2OTgsLjc4MDM3LC44NzU5XSxbLjEyMTUxLC43ODg5NiwuODY1ODFdLFsuMTE2MzksLjc5NzQsLjg1NTU5XSxbLjExMTY3LC44MDU2OSwuODQ1MjVdLFsuMTA3MzgsLjgxMzgxLC44MzQ4NF0sWy4xMDM1NywuODIxNzcsLjgyNDM3XSxbLjEwMDI2LC44Mjk1NSwuODEzODldLFsuMDk3NSwuODM3MTQsLjgwMzQyXSxbLjA5NTMyLC44NDQ1NSwuNzkyOTldLFsuMDkzNzcsLjg1MTc1LC43ODI2NF0sWy4wOTI4NywuODU4NzUsLjc3MjRdLFsuMDkyNjcsLjg2NTU0LC43NjIzXSxbLjA5MzIsLjg3MjExLC43NTIzN10sWy4wOTQ1MSwuODc4NDQsLjc0MjY1XSxbLjA5NjYyLC44ODQ1NCwuNzMzMTZdLFsuMDk5NTgsLjg5MDQsLjcyMzkzXSxbLjEwMzQyLC44OTYsLjcxNV0sWy4xMDgxNSwuOTAxNDIsLjcwNTk5XSxbLjExMzc0LC45MDY3MywuNjk2NTFdLFsuMTIwMTQsLjkxMTkzLC42ODY2XSxbLjEyNzMzLC45MTcwMSwuNjc2MjddLFsuMTM1MjYsLjkyMTk3LC42NjU1Nl0sWy4xNDM5MSwuOTI2OCwuNjU0NDhdLFsuMTUzMjMsLjkzMTUxLC42NDMwOF0sWy4xNjMxOSwuOTM2MDksLjYzMTM3XSxbLjE3Mzc3LC45NDA1MywuNjE5MzhdLFsuMTg0OTEsLjk0NDg0LC42MDcxM10sWy4xOTY1OSwuOTQ5MDEsLjU5NDY2XSxbLjIwODc3LC45NTMwNCwuNTgxOTldLFsuMjIxNDIsLjk1NjkyLC41NjkxNF0sWy4yMzQ0OSwuOTYwNjUsLjU1NjE0XSxbLjI0Nzk3LC45NjQyMywuNTQzMDNdLFsuMjYxOCwuOTY3NjUsLjUyOTgxXSxbLjI3NTk3LC45NzA5MiwuNTE2NTNdLFsuMjkwNDIsLjk3NDAzLC41MDMyMV0sWy4zMDUxMywuOTc2OTcsLjQ4OTg3XSxbLjMyMDA2LC45Nzk3NCwuNDc2NTRdLFsuMzM1MTcsLjk4MjM0LC40NjMyNV0sWy4zNTA0MywuOTg0NzcsLjQ1MDAyXSxbLjM2NTgxLC45ODcwMiwuNDM2ODhdLFsuMzgxMjcsLjk4OTA5LC40MjM4Nl0sWy4zOTY3OCwuOTkwOTgsLjQxMDk4XSxbLjQxMjI5LC45OTI2OCwuMzk4MjZdLFsuNDI3NzgsLjk5NDE5LC4zODU3NV0sWy40NDMyMSwuOTk1NTEsLjM3MzQ1XSxbLjQ1ODU0LC45OTY2MywuMzYxNF0sWy40NzM3NSwuOTk3NTUsLjM0OTYzXSxbLjQ4ODc5LC45OTgyOCwuMzM4MTZdLFsuNTAzNjIsLjk5ODc5LC4zMjcwMV0sWy41MTgyMiwuOTk5MSwuMzE2MjJdLFsuNTMyNTUsLjk5OTE5LC4zMDU4MV0sWy41NDY1OCwuOTk5MDcsLjI5NTgxXSxbLjU2MDI2LC45OTg3MywuMjg2MjNdLFsuNTczNTcsLjk5ODE3LC4yNzcxMl0sWy41ODY0NiwuOTk3MzksLjI2ODQ5XSxbLjU5ODkxLC45OTYzOCwuMjYwMzhdLFsuNjEwODgsLjk5NTE0LC4yNTI4XSxbLjYyMjMzLC45OTM2NiwuMjQ1NzldLFsuNjMzMjMsLjk5MTk1LC4yMzkzN10sWy42NDM2MiwuOTg5OTksLjIzMzU2XSxbLjY1Mzk0LC45ODc3NSwuMjI4MzVdLFsuNjY0MjgsLjk4NTI0LC4yMjM3XSxbLjY3NDYyLC45ODI0NiwuMjE5Nl0sWy42ODQ5NCwuOTc5NDEsLjIxNjAyXSxbLjY5NTI1LC45NzYxLC4yMTI5NF0sWy43MDU1MywuOTcyNTUsLjIxMDMyXSxbLjcxNTc3LC45Njg3NSwuMjA4MTVdLFsuNzI1OTYsLjk2NDcsLjIwNjRdLFsuNzM2MSwuOTYwNDMsLjIwNTA0XSxbLjc0NjE3LC45NTU5MywuMjA0MDZdLFsuNzU2MTcsLjk1MTIxLC4yMDM0M10sWy43NjYwOCwuOTQ2MjcsLjIwMzExXSxbLjc3NTkxLC45NDExMywuMjAzMV0sWy43ODU2MywuOTM1NzksLjIwMzM2XSxbLjc5NTI0LC45MzAyNSwuMjAzODZdLFsuODA0NzMsLjkyNDUyLC4yMDQ1OV0sWy44MTQxLC45MTg2MSwuMjA1NTJdLFsuODIzMzMsLjkxMjUzLC4yMDY2M10sWy44MzI0MSwuOTA2MjcsLjIwNzg4XSxbLjg0MTMzLC44OTk4NiwuMjA5MjZdLFsuODUwMSwuODkzMjgsLjIxMDc0XSxbLjg1ODY4LC44ODY1NSwuMjEyM10sWy44NjcwOSwuODc5NjgsLjIxMzkxXSxbLjg3NTMsLjg3MjY3LC4yMTU1NV0sWy44ODMzMSwuODY1NTMsLjIxNzE5XSxbLjg5MTEyLC44NTgyNiwuMjE4OF0sWy44OTg3LC44NTA4NywuMjIwMzhdLFsuOTA2MDUsLjg0MzM3LC4yMjE4OF0sWy45MTMxNywuODM1NzYsLjIyMzI4XSxbLjkyMDA0LC44MjgwNiwuMjI0NTZdLFsuOTI2NjYsLjgyMDI1LC4yMjU3XSxbLjkzMzAxLC44MTIzNiwuMjI2NjddLFsuOTM5MDksLjgwNDM5LC4yMjc0NF0sWy45NDQ4OSwuNzk2MzQsLjIyOF0sWy45NTAzOSwuNzg4MjMsLjIyODMxXSxbLjk1NTYsLjc4MDA1LC4yMjgzNl0sWy45NjA0OSwuNzcxODEsLjIyODExXSxbLjk2NTA3LC43NjM1MiwuMjI3NTRdLFsuOTY5MzEsLjc1NTE5LC4yMjY2M10sWy45NzMyMywuNzQ2ODIsLjIyNTM2XSxbLjk3Njc5LC43Mzg0MiwuMjIzNjldLFsuOTgsLjczLC4yMjE2MV0sWy45ODI4OSwuNzIxNCwuMjE5MThdLFsuOTg1NDksLjcxMjUsLjIxNjVdLFsuOTg3ODEsLjcwMzMsLjIxMzU4XSxbLjk4OTg2LC42OTM4MiwuMjEwNDNdLFsuOTkxNjMsLjY4NDA4LC4yMDcwNl0sWy45OTMxNCwuNjc0MDgsLjIwMzQ4XSxbLjk5NDM4LC42NjM4NiwuMTk5NzFdLFsuOTk1MzUsLjY1MzQxLC4xOTU3N10sWy45OTYwNywuNjQyNzcsLjE5MTY1XSxbLjk5NjU0LC42MzE5MywuMTg3MzhdLFsuOTk2NzUsLjYyMDkzLC4xODI5N10sWy45OTY3MiwuNjA5NzcsLjE3ODQyXSxbLjk5NjQ0LC41OTg0NiwuMTczNzZdLFsuOTk1OTMsLjU4NzAzLC4xNjg5OV0sWy45OTUxNywuNTc1NDksLjE2NDEyXSxbLjk5NDE5LC41NjM4NiwuMTU5MThdLFsuOTkyOTcsLjU1MjE0LC4xNTQxN10sWy45OTE1MywuNTQwMzYsLjE0OTFdLFsuOTg5ODcsLjUyODU0LC4xNDM5OF0sWy45ODc5OSwuNTE2NjcsLjEzODgzXSxbLjk4NTksLjUwNDc5LC4xMzM2N10sWy45ODM2LC40OTI5MSwuMTI4NDldLFsuOTgxMDgsLjQ4MTA0LC4xMjMzMl0sWy45NzgzNywuNDY5MiwuMTE4MTddLFsuOTc1NDUsLjQ1NzQsLjExMzA1XSxbLjk3MjM0LC40NDU2NSwuMTA3OTddLFsuOTY5MDQsLjQzMzk5LC4xMDI5NF0sWy45NjU1NSwuNDIyNDEsLjA5Nzk4XSxbLjk2MTg3LC40MTA5MywuMDkzMV0sWy45NTgwMSwuMzk5NTgsLjA4ODMxXSxbLjk1Mzk4LC4zODgzNiwuMDgzNjJdLFsuOTQ5NzcsLjM3NzI5LC4wNzkwNV0sWy45NDUzOCwuMzY2MzgsLjA3NDYxXSxbLjk0MDg0LC4zNTU2NiwuMDcwMzFdLFsuOTM2MTIsLjM0NTEzLC4wNjYxNl0sWy45MzEyNSwuMzM0ODIsLjA2MjE4XSxbLjkyNjIzLC4zMjQ3MywuMDU4MzddLFsuOTIxMDUsLjMxNDg5LC4wNTQ3NV0sWy45MTU3MiwuMzA1MywuMDUxMzRdLFsuOTEwMjQsLjI5NTk5LC4wNDgxNF0sWy45MDQ2MywuMjg2OTYsLjA0NTE2XSxbLjg5ODg4LC4yNzgyNCwuMDQyNDNdLFsuODkyOTgsLjI2OTgxLC4wMzk5M10sWy44ODY5MSwuMjYxNTIsLjAzNzUzXSxbLjg4MDY2LC4yNTMzNCwuMDM1MjFdLFsuODc0MjIsLjI0NTI2LC4wMzI5N10sWy44Njc2LC4yMzczLC4wMzA4Ml0sWy44NjA3OSwuMjI5NDUsLjAyODc1XSxbLjg1MzgsLjIyMTcsLjAyNjc3XSxbLjg0NjYyLC4yMTQwNywuMDI0ODddLFsuODM5MjYsLjIwNjU0LC4wMjMwNV0sWy44MzE3MiwuMTk5MTIsLjAyMTMxXSxbLjgyMzk5LC4xOTE4MiwuMDE5NjZdLFsuODE2MDgsLjE4NDYyLC4wMTgwOV0sWy44MDc5OSwuMTc3NTMsLjAxNjZdLFsuNzk5NzEsLjE3MDU1LC4wMTUyXSxbLjc5MTI1LC4xNjM2OCwuMDEzODddLFsuNzgyNiwuMTU2OTMsLjAxMjY0XSxbLjc3Mzc3LC4xNTAyOCwuMDExNDhdLFsuNzY0NzYsLjE0Mzc0LC4wMTA0MV0sWy43NTU1NiwuMTM3MzEsLjAwOTQyXSxbLjc0NjE3LC4xMzA5OCwuMDA4NTFdLFsuNzM2NjEsLjEyNDc3LC4wMDc2OV0sWy43MjY4NiwuMTE4NjcsLjAwNjk1XSxbLjcxNjkyLC4xMTI2OCwuMDA2MjldLFsuNzA2OCwuMTA2OCwuMDA1NzFdLFsuNjk2NSwuMTAxMDIsLjAwNTIyXSxbLjY4NjAyLC4wOTUzNiwuMDA0ODFdLFsuNjc1MzUsLjA4OTgsLjAwNDQ5XSxbLjY2NDQ5LC4wODQzNiwuMDA0MjRdLFsuNjUzNDUsLjA3OTAyLC4wMDQwOF0sWy42NDIyMywuMDczOCwuMDA0MDFdLFsuNjMwODIsLjA2ODY4LC4wMDQwMV0sWy42MTkyMywuMDYzNjcsLjAwNDFdLFsuNjA3NDYsLjA1ODc4LC4wMDQyN10sWy41OTU1LC4wNTM5OSwuMDA0NTNdLFsuNTgzMzYsLjA0OTMxLC4wMDQ4Nl0sWy41NzEwMywuMDQ0NzQsLjAwNTI5XSxbLjU1ODUyLC4wNDAyOCwuMDA1NzldLFsuNTQ1ODMsLjAzNTkzLC4wMDYzOF0sWy41MzI5NSwuMDMxNjksLjAwNzA1XSxbLjUxOTg5LC4wMjc1NiwuMDA3OF0sWy41MDY2NCwuMDIzNTQsLjAwODYzXSxbLjQ5MzIxLC4wMTk2MywuMDA5NTVdLFsuNDc5NiwuMDE1ODMsLjAxMDVdXSxmZT1bWy4wNTc5NTEsMzc3ZS02LC4wODg2NTddLFsuMDU4NjA0LDc0M2UtNiwuMDkyMDIyXSxbLjA1OTIyOSwuMDAxMTMyLC4wOTU0MjRdLFsuMDU5ODI2LC4wMDE1NDMsLjA5ODg2M10sWy4wNjAzOTUsLjAwMTk3OSwuMTAyMzMzXSxbLjA2MDkzNCwuMDAyNDM4LC4xMDU4MzRdLFsuMDYxNDQzLC4wMDI5MjIsLjEwOTM2XSxbLjA2MTkyMywuMDAzNDMxLC4xMTI5MDldLFsuMDYyMzcxLC4wMDM5NjcsLjExNjQ4XSxbLjA2Mjc4OCwuMDA0NTI5LC4xMjAwNjVdLFsuMDYzMTczLC4wMDUxMTgsLjEyMzY2NF0sWy4wNjM1MjYsLjAwNTczNiwuMTI3Mjc0XSxbLjA2Mzg0NiwuMDA2MzgxLC4xMzA4ODldLFsuMDY0MTMzLC4wMDcwNTUsLjEzNDUwNl0sWy4wNjQzODYsLjAwNzc1OSwuMTM4MTI0XSxbLjA2NDYwNiwuMDA4NDkzLC4xNDE3MzZdLFsuMDY0NzkxLC4wMDkyNTgsLjE0NTM0XSxbLjA2NDk0MywuMDEwMDUzLC4xNDg5MzJdLFsuMDY1MDYsLjAxMDg4LC4xNTI1MDldLFsuMDY1MTQ0LC4wMTE3MzksLjE1NjA2Nl0sWy4wNjUxOTMsLjAxMjYzMSwuMTU5Nl0sWy4wNjUyMDgsLjAxMzU1NSwuMTYzMTA4XSxbLjA2NTE4OCwuMDE0NTEzLC4xNjY1ODZdLFsuMDY1MTM1LC4wMTU1MDQsLjE3MDAzXSxbLjA2NTA0OCwuMDE2NTI5LC4xNzM0MzddLFsuMDY0OTI4LC4wMTc1ODgsLjE3NjgwNV0sWy4wNjQ3NzQsLjAxODY4MSwuMTgwMTI5XSxbLjA2NDU4OSwuMDE5ODA5LC4xODM0MDZdLFsuMDY0MzcsLjAyMDk3MywuMTg2NjMzXSxbLjA2NDEyMSwuMDIyMTcxLC4xODk4MDldLFsuMDYzODQsLjAyMzQwNCwuMTkyOTI5XSxbLjA2MzUyOSwuMDI0NjcyLC4xOTU5OTJdLFsuMDYzMTg5LC4wMjU5NzUsLjE5ODk5NF0sWy4wNjI4MiwuMDI3MzE0LC4yMDE5MzRdLFsuMDYyNDIzLC4wMjg2ODcsLjIwNDgxXSxbLjA2MiwuMDMwMDk2LC4yMDc2Ml0sWy4wNjE1NSwuMDMxNTM5LC4yMTAzNjJdLFsuMDYxMDc2LC4wMzMwMTgsLjIxMzAzNF0sWy4wNjA1NzcsLjAzNDUzMSwuMjE1NjM4XSxbLjA2MDA1NywuMDM2MDc4LC4yMTgxNjhdLFsuMDU5NTE0LC4wMzc2NTksLjIyMDYyN10sWy4wNTg5NTEsLjAzOTI3NCwuMjIzMDEzXSxbLjA1ODM2OCwuMDQwOTIyLC4yMjUzMjRdLFsuMDU3NzY4LC4wNDI2MDQsLjIyNzU2M10sWy4wNTcxNTEsLjA0NDMxOCwuMjI5NzI4XSxbLjA1NjUxOCwuMDQ2MDY0LC4yMzE4Ml0sWy4wNTU4NzEsLjA0Nzg0MiwuMjMzODM3XSxbLjA1NTIxMSwuMDQ5NjUzLC4yMzU3ODJdLFsuMDU0NTM5LC4wNTE0OTQsLjIzNzY1NV0sWy4wNTM4NTcsLjA1MzM2NSwuMjM5NDU2XSxbLjA1MzE2NSwuMDU1MjY3LC4yNDExODhdLFsuMDUyNDY2LC4wNTcxOTgsLjI0Mjg1XSxbLjA1MTc1OSwuMDU5MTU5LC4yNDQ0NDNdLFsuMDUxMDQ2LC4wNjExNDgsLjI0NTk3XSxbLjA1MDMyOSwuMDYzMTY2LC4yNDc0MzFdLFsuMDQ5NjA5LC4wNjUyMTIsLjI0ODgyOF0sWy4wNDg4ODYsLjA2NzI4NCwuMjUwMTYzXSxbLjA0ODE2MiwuMDY5Mzg0LC4yNTE0MzldLFsuMDQ3NDM4LC4wNzE1MTEsLjI1MjY1M10sWy4wNDY3MTUsLjA3MzY2MywuMjUzODEyXSxbLjA0NTk5MiwuMDc1ODQxLC4yNTQ5MTVdLFsuMDQ1MjczLC4wNzgwNDUsLjI1NTk2NF0sWy4wNDQ1NTcsLjA4MDI3MywuMjU2OTYyXSxbLjA0Mzg0NiwuMDgyNTI2LC4yNTc5MV0sWy4wNDMxMzksLjA4NDgwMywuMjU4ODExXSxbLjA0MjQzOCwuMDg3MTA0LC4yNTk2NjZdLFsuMDQxNzQzLC4wODk0MjksLjI2MDQ3N10sWy4wNDEwNTUsLjA5MTc3NywuMjYxMjQ1XSxbLjA0MDM3NCwuMDk0MTQ4LC4yNjE5NzJdLFsuMDM5NzAyLC4wOTY1NDIsLjI2MjY2MV0sWy4wMzkwMzcsLjA5ODk1OSwuMjYzMzEzXSxbLjAzODM4MiwuMTAxMzk4LC4yNjM5MjldLFsuMDM3NzM2LC4xMDM4NiwuMjY0NTEyXSxbLjAzNzA5OSwuMTA2MzQ0LC4yNjUwNjNdLFsuMDM2NDcyLC4xMDg4NSwuMjY1NTgzXSxbLjAzNTg1NSwuMTExMzc4LC4yNjYwNzZdLFsuMDM1MjQ5LC4xMTM5MjgsLjI2NjU0XSxbLjAzNDY1MywuMTE2NSwuMjY2OTc4XSxbLjAzNDA2NywuMTE5MDkzLC4yNjczOTFdLFsuMDMzNDkyLC4xMjE3MSwuMjY3NzhdLFsuMDMyOTI3LC4xMjQzNDgsLjI2ODE0N10sWy4wMzIzNzMsLjEyNzAwOCwuMjY4NDkzXSxbLjAzMTgyOSwuMTI5NjksLjI2ODgxN10sWy4wMzEyOTYsLjEzMjM5NCwuMjY5MTIzXSxbLjAzMDc3MywuMTM1MTIxLC4yNjk0MV0sWy4wMzAyNiwuMTM3ODcxLC4yNjk2NzhdLFsuMDI5NzU4LC4xNDA2NDMsLjI2OTkyOV0sWy4wMjkyNjUsLjE0MzQzOCwuMjcwMTYzXSxbLjAyODc4MSwuMTQ2MjU3LC4yNzAzODFdLFsuMDI4MzA4LC4xNDkwOTksLjI3MDU4NF0sWy4wMjc4NDMsLjE1MTk2NCwuMjcwNzcxXSxbLjAyNzM4NywuMTU0ODUzLC4yNzA5NDNdLFsuMDI2OTQsLjE1Nzc2NywuMjcxMV0sWy4wMjY1MDEsLjE2MDcwNCwuMjcxMjQzXSxbLjAyNjA3LC4xNjM2NjYsLjI3MTM3MV0sWy4wMjU2NDgsLjE2NjY1MywuMjcxNDg1XSxbLjAyNTIzMiwuMTY5NjY2LC4yNzE1ODRdLFsuMDI0ODI0LC4xNzI3MDQsLjI3MTY2OV0sWy4wMjQ0MjMsLjE3NTc2NywuMjcxNzM4XSxbLjAyNDAyOCwuMTc4ODU3LC4yNzE3OTNdLFsuMDIzNjQsLjE4MTk3NCwuMjcxODMzXSxbLjAyMzI1NywuMTg1MTE3LC4yNzE4NTZdLFsuMDIyODgxLC4xODgyODgsLjI3MTg2M10sWy4wMjI1MSwuMTkxNDg2LC4yNzE4NTVdLFsuMDIyMTQ0LC4xOTQ3MTMsLjI3MTgyOF0sWy4wMjE3ODQsLjE5Nzk2NywuMjcxNzg0XSxbLjAyMTQyOCwuMjAxMjUsLjI3MTcyXSxbLjAyMTA3NywuMjA0NTYzLC4yNzE2MzhdLFsuMDIwNzMsLjIwNzkwNCwuMjcxNTM2XSxbLjAyMDM4OCwuMjExMjc1LC4yNzE0MTJdLFsuMDIwMDUsLjIxNDY3NiwuMjcxMjY3XSxbLjAxOTcxNiwuMjE4MTA3LC4yNzExXSxbLjAxOTM4NywuMjIxNTY5LC4yNzA5MDldLFsuMDE5MDYyLC4yMjUwNjIsLjI3MDY5NV0sWy4wMTg3NDEsLjIyODU4NSwuMjcwNDU2XSxbLjAxODQyNSwuMjMyMTQxLC4yNzAxODldLFsuMDE4MTEzLC4yMzU3MjgsLjI2OTg5Nl0sWy4wMTc4MDYsLjIzOTM0OCwuMjY5NTc0XSxbLjAxNzUwNCwuMjQyOTk4LC4yNjkyMjJdLFsuMDE3MjA3LC4yNDY2ODIsLjI2ODg0MV0sWy4wMTY5MTYsLjI1MDM5OSwuMjY4NDI2XSxbLjAxNjYzLC4yNTQxNDgsLjI2Nzk4XSxbLjAxNjM1MiwuMjU3OTMsLjI2NzUwMV0sWy4wMTYwOCwuMjYxNzQ2LC4yNjY5ODddLFsuMDE1ODE2LC4yNjU1OTQsLjI2NjQzNl0sWy4wMTU1NTksLjI2OTQ3NiwuMjY1ODQ5XSxbLjAxNTMxMiwuMjczMzkyLC4yNjUyMjRdLFsuMDE1MDc0LC4yNzczNCwuMjY0NTU5XSxbLjAxNDg0NiwuMjgxMzIzLC4yNjM4NTRdLFsuMDE0NjI5LC4yODUzMzksLjI2MzEwN10sWy4wMTQ0MjUsLjI4OTM4OSwuMjYyMzJdLFsuMDE0MjM0LC4yOTM0NzIsLjI2MTQ4OF0sWy4wMTQwNTgsLjI5NzU4OSwuMjYwNjEzXSxbLjAxMzg5NiwuMzAxNzM4LC4yNTk2OTJdLFsuMDEzNzUxLC4zMDU5MjEsLjI1ODcyNV0sWy4wMTM2MjQsLjMxMDEzNywuMjU3NzExXSxbLjAxMzUxNiwuMzE0Mzg3LC4yNTY2NV0sWy4wMTM0MjksLjMxODY2OCwuMjU1NTM5XSxbLjAxMzM2NCwuMzIyOTgyLC4yNTQzODFdLFsuMDEzMzIyLC4zMjczMjgsLjI1MzE3M10sWy4wMTMzMDYsLjMzMTcwNiwuMjUxOTEzXSxbLjAxMzMxNywuMzM2MTE2LC4yNTA2MDJdLFsuMDEzMzU2LC4zNDA1NTYsLjI0OTIzOV0sWy4wMTM0MjcsLjM0NTAyOCwuMjQ3ODI0XSxbLjAxMzUyOSwuMzQ5NTMsLjI0NjM1N10sWy4wMTM2NjcsLjM1NDA2MSwuMjQ0ODM3XSxbLjAxMzg0MSwuMzU4NjIzLC4yNDMyNjRdLFsuMDE0MDU0LC4zNjMyMTMsLjI0MTYzNl0sWy4wMTQzMDgsLjM2NzgzMSwuMjM5OTU2XSxbLjAxNDYwNSwuMzcyNDc2LC4yMzgyMjFdLFsuMDE0OTQ4LC4zNzcxNSwuMjM2NDMyXSxbLjAxNTMzOSwuMzgxODQ5LC4yMzQ1ODldLFsuMDE1NzgsLjM4NjU3NiwuMjMyNjkyXSxbLjAxNjI3NSwuMzkxMzI2LC4yMzA3NDJdLFsuMDE2ODI1LC4zOTYxMDEsLjIyODczOF0sWy4wMTc0MzQsLjQwMDg5OSwuMjI2NjhdLFsuMDE4MTA0LC40MDU3MjEsLjIyNDU2OV0sWy4wMTg4MzksLjQxMDU2NCwuMjIyNDA2XSxbLjAxOTY0MSwuNDE1NDI3LC4yMjAxOTFdLFsuMDIwNTEyLC40MjAzMTIsLjIxNzkyM10sWy4wMjE0NTcsLjQyNTIxNiwuMjE1NjA1XSxbLjAyMjQ3OSwuNDMwMTM3LC4yMTMyMzZdLFsuMDIzNTgsLjQzNTA3NywuMjEwODE4XSxbLjAyNDc2NCwuNDQwMDMyLC4yMDgzNV0sWy4wMjYwMzQsLjQ0NTAwNCwuMjA1ODM1XSxbLjAyNzM5NCwuNDQ5OTg4LC4yMDMyNzFdLFsuMDI4ODQ3LC40NTQ5ODUsLjIwMDY2Ml0sWy4wMzAzOTYsLjQ1OTk5NSwuMTk4MDA4XSxbLjAzMjA0NiwuNDY1MDE2LC4xOTUzMV0sWy4wMzM4LC40NzAwNDYsLjE5MjU2OV0sWy4wMzU2NjIsLjQ3NTA4MywuMTg5Nzg2XSxbLjAzNzYzNiwuNDgwMTI4LC4xODY5NjRdLFsuMDM5NzI1LC40ODUxNzgsLjE4NDEwMV0sWy4wNDE5MzMsLjQ5MDIzNCwuMTgxMjAxXSxbLjA0NDI2NiwuNDk1MjkxLC4xNzgyNjVdLFsuMDQ2NzI1LC41MDAzNTEsLjE3NTI5NF0sWy4wNDkzMTcsLjUwNTQxMiwuMTcyMjkxXSxbLjA1MjA0NCwuNTEwNDcsLjE2OTI1N10sWy4wNTQ5MTIsLjUxNTUyNiwuMTY2MTkyXSxbLjA1NzkyNCwuNTIwNTc4LC4xNjMwOTldLFsuMDYxMDg1LC41MjU2MjQsLjE1OTk4XSxbLjA2NDQsLjUzMDY2NCwuMTU2ODM1XSxbLjA2Nzg3MywuNTM1NjkzLC4xNTM2NjldLFsuMDcxNTA4LC41NDA3MTMsLjE1MDQ4Ml0sWy4wNzUzMSwuNTQ1NzIxLC4xNDcyNzddLFsuMDc5MjgzLC41NTA3MTcsLjE0NDA1NV0sWy4wODM0MzMsLjU1NTY5NywuMTQwODE5XSxbLjA4Nzc2NCwuNTYwNjYsLjEzNzU3XSxbLjA5MjI4MSwuNTY1NjA0LC4xMzQzMDldLFsuMDk2OTg5LC41NzA1MjksLjEzMTA0XSxbLjEwMTg5MywuNTc1NDMxLC4xMjc3NjZdLFsuMTA2OTk2LC41ODAzMSwuMTI0NDg3XSxbLjExMjMwNSwuNTg1MTY0LC4xMjEyMDddLFsuMTE3ODI0LC41ODk5OSwuMTE3OTI4XSxbLjEyMzU1OCwuNTk0Nzg5LC4xMTQ2NTJdLFsuMTI5NTExLC41OTk1NTYsLjExMTM4MV0sWy4xMzU2OSwuNjA0Mjk0LC4xMDgxMThdLFsuMTQyMDk5LC42MDg5OTQsLjEwNDg2NF0sWy4xNDg3NDMsLjYxMzY2LC4xMDE2MjNdLFsuMTU1NjI3LC42MTgyODgsLjA5ODM5Nl0sWy4xNjI3NTUsLjYyMjg3OCwuMDk1MTg3XSxbLjE3MDEzMywuNjI3NDI3LC4wOTE5OTddLFsuMTc3NzY0LC42MzE5MzQsLjA4ODgzXSxbLjE4NTY1NCwuNjM2Mzk2LC4wODU2ODldLFsuMTkzODA3LC42NDA4MTQsLjA4MjU3M10sWy4yMDIyMjgsLjY0NTE4MywuMDc5NDg4XSxbLjIxMDkyMSwuNjQ5NTAzLC4wNzY0MzZdLFsuMjE5ODkxLC42NTM3NzMsLjA3MzQxOF0sWy4yMjkxNDMsLjY1Nzk5MiwuMDcwNDM4XSxbLjIzODY3OSwuNjYyMTU4LC4wNjc0OTddLFsuMjQ4NTA1LC42NjYyNjgsLjA2NDU5OF0sWy4yNTg2MjMsLjY3MDMyMSwuMDYxNzQ1XSxbLjI2OTAzNywuNjc0MzE5LC4wNTg5MzldLFsuMjc5NzUxLC42NzgyNTksLjA1NjE4NF0sWy4yOTA3NjUsLjY4MjE0LC4wNTM0ODJdLFsuMzAyMDg1LC42ODU5NTksLjA1MDgzNV0sWy4zMTM3MTIsLjY4OTcxOSwuMDQ4MjQ2XSxbLjMyNTY0OCwuNjkzNDE3LC4wNDU3MThdLFsuMzM3ODk2LC42OTcwNTMsLjA0MzI1M10sWy4zNTA0NTUsLjcwMDYyNywuMDQwODUzXSxbLjM2MzMzLC43MDQxMzksLjAzODUyMV0sWy4zNzY1MTcsLjcwNzU4OCwuMDM2MjYxXSxbLjM5MDAxOSwuNzEwOTc1LC4wMzQwNzNdLFsuNDAzODM1LC43MTQyOTgsLjAzMTk2MV0sWy40MTc5NjQsLjcxNzU2MSwuMDI5OTI4XSxbLjQzMjQwNSwuNzIwNzYzLC4wMjc5NzVdLFsuNDQ3MTU2LC43MjM5MDMsLjAyNjEwNV0sWy40NjIyMTMsLjcyNjk4NiwuMDI0MzIxXSxbLjQ3NzU3NywuNzMwMDEsLjAyMjYyNV0sWy40OTMyNDMsLjczMjk3OCwuMDIxMDE5XSxbLjUwOTIwNiwuNzM1ODkxLC4wMTk1MDZdLFsuNTI1NDYxLC43Mzg3NTEsLjAxODA4OF0sWy41NDIwMDQsLjc0MTU2MywuMDE2NzY3XSxbLjU1ODgzMSwuNzQ0MzI1LC4wMTU1NDddLFsuNTc1OTMyLC43NDcwNDEsLjAxNDQyN10sWy41OTMzMDUsLjc0OTcxNywuMDEzNDEzXSxbLjYxMDk0LC43NTIzNTEsLjAxMjUwNF0sWy42Mjg4MjgsLjc1NDk0OSwuMDExNzA0XSxbLjY0Njk2NiwuNzU3NTE0LC4wMTEwMTVdLFsuNjY1MzQ0LC43NjAwNDksLjAxMDQzOF0sWy42ODM5NTIsLjc2MjU1NywuMDA5OTc3XSxbLjcwMjc4MiwuNzY1MDQ0LC4wMDk2MzJdLFsuNzIxODI1LC43Njc1MTEsLjAwOTQwNl0sWy43NDEwNzQsLjc2OTk2NCwuMDA5MzAxXSxbLjc2MDUxOCwuNzcyNDA2LC4wMDkzMl0sWy43ODAxNSwuNzc0ODM5LC4wMDk0NjNdLFsuNzk5OTU4LC43NzcyNywuMDA5NzM0XSxbLjgxOTkzNiwuNzc5Njk5LC4wMTAxMzRdLFsuODQwMDY0LC43ODIxMzksLjAxMDY2Nl0sWy44NjAzNCwuNzg0NTg2LC4wMTEzMzFdLFsuODgwNzU4LC43ODcwNDYsLjAxMjEzMl0sWy45MDEzMTEsLjc4OTUyMSwuMDEzMDddLFsuOTIxOTksLjc5MjAxNywuMDE0MTQ4XSxbLjk0Mjc4NiwuNzk0NTM1LC4wMTUzNjhdLFsuOTYzNjkzLC43OTcwNzgsLjAxNjczMl0sWy45ODQ3MDgsLjc5OTY1MSwuMDE4MjQzXV0sdWU9W1sxMDIsMjU1LDUxXSxbMjU1LDkwLDBdLFsyNTUsMjU1LDBdXSx2ZT1bWzAsMCwuMjE0MDQxXSxbMCwwLDFdLFswLC4yMTQwNDEsMV0sWzAsMSwxXSxbLjIxNDA0MSwxLC4yMTQwNDFdLFsxLDEsMF0sWzEsLjIxNDA0MSwwXSxbMSwwLDBdLFsuMjE0MDQxLDAsMF1dLGcxPTI1NTtmdW5jdGlvbiBoZShsKXtyZXR1cm4gbDwwPzA6bD4xP2cxOk51bWJlci5pc05hTihsKT8wOk1hdGgucm91bmQobCpnMSl9ZnVuY3Rpb24gZTEobCxuKXtjb25zdCB1PWhlKG4pLGI9bFt1XTtyZXR1cm5bYlswXSpnMSxiWzFdKmcxLGJbMl0qZzFdfWZ1bmN0aW9uIEYxKGwpe3JldHVybiBuPT5sKG4pLnJnYigpfWNvbnN0IEEyPWUxLmJpbmQobnVsbCxvZSksZ2U9ZTEuYmluZChudWxsLGZlKSxiZT1lMS5iaW5kKG51bGwsbGUpLGRlPWUxLmJpbmQobnVsbCxjZSkscGU9ZTEuYmluZChudWxsLGllKSxtZT1lMS5iaW5kKG51bGwsc2UpLHdlPUYxKHIxLmN1YmVoZWxpeCgpLnNjYWxlKCkpLHllPUYxKHIxLnNjYWxlKHVlLm1hcChsPT5yMS5yZ2IobFswXSxsWzFdLGxbMl0pKSkubW9kZSgibGFiIikpLHgyPUYxKHIxLnNjYWxlKHZlLm1hcChsPT5yMS5yZ2IobFswXSoyNTUsbFsxXSoyNTUsbFsyXSoyNTUpKSkubW9kZSgibHJnYiIpKSxTMj17Z3JheXNjYWxlOiJHcmV5cyIsYmx1ZToiQmx1ZXMiLGdyZWVuOiJHcmVlbnMiLG9yYW5nZToiT3JhbmdlcyIscHVycGxlOiJQdXJwbGVzIixyZWQ6IlJlZHMiLGF1ZGFjaXR5OkEyLHJvc2V1czpBMix2aXJpZGlzOmdlLHR1cmJvOmJlLHBsYXNtYTpkZSxpbmZlcm5vOnBlLG1hZ21hOm1lLGN1YmVIZWxpeDp3ZSxnYW1tYUlJOnllLGpldDp4MixyYXZlbjp4Mn07ZnVuY3Rpb24gX2UobCl7bGV0IG49UzJbbF07cmV0dXJuIG49PT12b2lkIDAmJihjb25zb2xlLndhcm4oIkNvdWxkIG5vdCBmaW5kIGNvbG9yIHNjYWxlIixsKSxuPVMyLmdyYXlzY2FsZSksdHlwZW9mIG49PSJzdHJpbmciP0YxKHIxLnNjYWxlKG4pKTpufWZ1bmN0aW9uIGtlKGwpe3JldHVybiA3MDAqKE1hdGguZXhwKGwvMTEyNyktMSl9ZnVuY3Rpb24gSTIobCl7cmV0dXJuIDExMjcqTWF0aC5sb2coMStsLzcwMCl9ZnVuY3Rpb24gJGUobCl7Y29uc3Qgbj1bXSx1PVtdLGI9W10sZz1JMihsLmxvd0ZyZXF1ZW5jeSksJD1JMihsLmhpZ2hGcmVxdWVuY3kpLE09KCQtZykvKGwuYmFua0NvdW50KzEpO2ZvcihsZXQgaz0wO2s8bC5iYW5rQ291bnQ7aysrKXVba109a2UoZytrKk0pLG5ba109TWF0aC5mbG9vcigobC5mZnRTaXplKzEpKnVba10vKGwuc2FtcGxlUmF0ZS8yKSk7Zm9yKGxldCBrPTA7azxuLmxlbmd0aDtrKyspe2Jba109W107Y29uc3QgeD1rPT09bi5sZW5ndGgtMT9uW2tdLW5bay0xXTpuW2srMV0tbltrXTtmb3IobGV0IEE9MDtBPGwuZmZ0U2l6ZTtBKyspQT5uW2tdK3g/YltrXVtBXT0wOkE+bltrXT9iW2tdW0FdPTEtKEEtbltrXSkveDpBPT09bltrXT9iW2tdW0FdPTE6QT49bltrXS14P2Jba11bQV09MS0obltrXS1BKS94OmJba11bQV09MH1jb25zdCB6PWs9Pntjb25zdCB4PW5ldyBGbG9hdDMyQXJyYXkoYi5sZW5ndGgpO2ZvcihsZXQgQT0wO0E8Yi5sZW5ndGg7QSsrKXtsZXQgUj0wO2ZvcihsZXQgVT0wO1U8ay5sZW5ndGg7VSsrKVIrPWtbVV0qYltBXVtVXTt4W0FdPVJ9cmV0dXJuIHh9O3JldHVybntmaWx0ZXJzOmIsbG93TWVsOmcsaGlnaE1lbDokLGRlbHRhTWVsOk0sbG93RnJlcTpsLmxvd0ZyZXF1ZW5jeSxoaWdoRnJlcTpsLmhpZ2hGcmVxdWVuY3ksZmlsdGVyOnp9fWZ1bmN0aW9uIE1lKGwpe2NvbnN0IG49JGUobCk7cmV0dXJuIHU9PntpZih1Lmxlbmd0aCE9PWwuZmZ0U2l6ZSl7Y29uc3QgYj1gUGFzc2VkIGluIEZGVCBiaW5zIHdlcmUgaW5jb3JyZWN0IHNpemUuIEV4cGVjdGVkICR7bC5mZnRTaXplfSBidXQgd2FzICR7dS5sZW5ndGh9YDt0aHJvdyBuZXcgRXJyb3IoYil9cmV0dXJuIG4uZmlsdGVyKHUpfX1jb25zdCBDZT1sPT5NYXRoLnNpbihNYXRoLlBJKmwpLyhNYXRoLlBJKmwpLFIyPWw9Pntjb25zdCBuPU1hdGguYWJzKGwpO2lmKG48My43NSl7Y29uc3QgdT1sLzMuNzUqKGwvMy43NSk7cmV0dXJuIDErdSooMy41MTU2MjI5K3UqKDMuMDg5OTQyNCt1KigxLjIwNjc0OTIrdSooLjI2NTk3MzIrdSooLjAzNjA3NjgrdSouMDA0NTgxMykpKSkpfWVsc2V7Y29uc3QgdT0zLjc1L247cmV0dXJuIE1hdGguZXhwKG4pL01hdGguc3FydChuKSooLjM5ODk0MjI4K3UqKC4wMTMyODU5Mit1KiguMDAyMjUzMTkrdSooLS4wMDE1NzU2NSt1KiguMDA5MTYyODErdSooLS4wMjA1NzcwNit1KiguMDI2MzU1MzcrdSooLS4wMTY0NzYzMyt1Ki4wMDM5MjM3NykpKSkpKSkpfX0sRmU9e2hhbm46KGwsbik9Pi41LS41Kk1hdGguY29zKDIqTWF0aC5QSSpsLyhuLTEpKSxoYW1taW5nOihsLG4pPT4uNTQtLjQ2Kk1hdGguY29zKDIqTWF0aC5QSSpsLyhuLTEpKSxjb3NpbmU6KGwsbik9Pk1hdGguc2luKE1hdGguUEkqbC8obi0xKSksbGFuY3pvczoobCxuKT0+Q2UoMipsLyhuLTEpLTEpLGdhdXNzaWFuOihsLG4sdT0uNCk9Pk1hdGgucG93KE1hdGguRSwtLjUqTWF0aC5wb3coKGwtKG4tMSkvMikvKHUqKG4tMSkvMiksMikpLHR1a2V5OihsLG4sdT0uNSk9Pmw8LjUqdSoobi0xKT8uNSooMStNYXRoLmNvcyhNYXRoLlBJKigyKmwvKHUqKG4tMSkpLTEpKSk6bDwoMS0uNSp1KSoobi0xKT8xOi41KigxK01hdGguY29zKE1hdGguUEkqKDIqbC8odSoobi0xKSkrMS0yL3UpKSksYmxhY2ttYW46KGwsbik9Pi40Mi0uNSpNYXRoLmNvcygyKk1hdGguUEkqbC8obi0xKSkrLjA4Kk1hdGguY29zKDQqTWF0aC5QSSpsLyhuLTEpKSxleGFjdF9ibGFja21hbjoobCxuKT0+LjQyNDM4MDEtLjQ5NzM0MDYqTWF0aC5jb3MoMipNYXRoLlBJKmwvKG4tMSkpKy4wNzgyNzkzKk1hdGguY29zKDQqTWF0aC5QSSpsLyhuLTEpKSxrYWlzZXI6KGwsbix1PTMpPT5SMihNYXRoLlBJKnUqTWF0aC5zcXJ0KDEtTWF0aC5wb3coMipsLyhuLTEpLTEsMikpKS9SMihNYXRoLlBJKnUpLG51dHRhbGw6KGwsbik9Pi4zNTU3NjgtLjQ4NzM5NipNYXRoLmNvcygyKk1hdGguUEkqbC8obi0xKSkrLjE0NDIzMipNYXRoLmNvcyg0Kk1hdGguUEkqbC8obi0xKSktLjAxMjYwNCpNYXRoLmNvcyg2Kk1hdGguUEkqbC8obi0xKSksYmxhY2ttYW5faGFycmlzOihsLG4pPT4uMzU4NzUtLjQ4ODI5Kk1hdGguY29zKDIqTWF0aC5QSSpsLyhuLTEpKSsuMTQxMjgqTWF0aC5jb3MoNCpNYXRoLlBJKmwvKG4tMSkpLS4wMTE2OCpNYXRoLmNvcyg2Kk1hdGguUEkqbC8obi0xKSksYmxhY2ttYW5fbnV0dGFsbDoobCxuKT0+LjM2MzU4MTktLjM2MzU4MTkqTWF0aC5jb3MoMipNYXRoLlBJKmwvKG4tMSkpKy4xMzY1OTk1Kk1hdGguY29zKDQqTWF0aC5QSSpsLyhuLTEpKS0uMDEwNjQxMSpNYXRoLmNvcyg2Kk1hdGguUEkqbC8obi0xKSksZmxhdF90b3A6KGwsbik9PjEtMS45MypNYXRoLmNvcygyKk1hdGguUEkqbC8obi0xKSkrMS4yOSpNYXRoLmNvcyg0Kk1hdGguUEkqbC8obi0xKSktLjM4OCpNYXRoLmNvcyg2Kk1hdGguUEkqbC8obi0xKSkrLjAzMipNYXRoLmNvcyg4Kk1hdGguUEkqbC8obi0xKSl9LEFlPShsLG4sdSk9Pntjb25zdCBiPWwubGVuZ3RoO2ZvcihsZXQgZz0wO2c8YjsrK2cpbFtnXSo9bihnLGIsdSk7cmV0dXJuIGx9LGkwPWw9PihuLHUpPT5BZShuLEZlW2xdLHUpLFgxPWkwKCJoYW5uIikseGU9aTAoImhhbW1pbmciKSxTZT1pMCgiY29zaW5lIiksSWU9aTAoImxhbmN6b3MiKSxSZT1pMCgiZ2F1c3NpYW4iKSxUZT1pMCgidHVrZXkiKSxQZT1pMCgiYmxhY2ttYW4iKSx6ZT1pMCgiZXhhY3RfYmxhY2ttYW4iKSxFZT1pMCgia2Fpc2VyIiksTmU9aTAoIm51dHRhbGwiKSxCZT1pMCgiYmxhY2ttYW5faGFycmlzIiksRGU9aTAoImJsYWNrbWFuX251dHRhbGwiKSxMZT1pMCgiZmxhdF90b3AiKSxUMj1uZXcgTWFwKFtbImhhbm4iLFgxXSxbImhhbW1pbmciLHhlXSxbImNvc2luZSIsU2VdLFsibGFuY3pvcyIsSWVdLFsiZ2F1c3NpYW4iLFJlXSxbInR1a2V5IixUZV0sWyJibGFja21hbiIsUGVdLFsiZXhhY3RfYmxhY2ttYW4iLHplXSxbImthaXNlciIsRWVdLFsibnV0dGFsbCIsTmVdLFsiYmxhY2ttYW5faGFycmlzIixCZV0sWyJibGFja21hbl9udXR0YWxsIixEZV0sWyJmbGF0X3RvcCIsTGVdXSk7ZnVuY3Rpb24gR2UobD0iaGFubiIpe2NvbnN0IG49VDIuZ2V0KGwpPz9YMTtyZXR1cm4gdT0+bih1KX1mdW5jdGlvbiBxZShsPSJoYW5uIixuKXtjb25zdCBiPShUMi5nZXQobCk/P1gxKShuZXcgQXJyYXkobikuZmlsbCgxKSk7cmV0dXJuIGIucmVkdWNlKCgkLE0pPT4kK00sMCkvYi5sZW5ndGh9ZnVuY3Rpb24gbjAobCl7aWYodGhpcy5zaXplPWx8MCx0aGlzLnNpemU8PTF8fHRoaXMuc2l6ZSZ0aGlzLnNpemUtMSl0aHJvdyBuZXcgRXJyb3IoIkZGVCBzaXplIG11c3QgYmUgYSBwb3dlciBvZiB0d28gYW5kIGJpZ2dlciB0aGFuIDEiKTt0aGlzLl9jc2l6ZT1sPDwxO2NvbnN0IG49bmV3IEFycmF5KHRoaXMuc2l6ZSoyKTtmb3IobGV0IGI9MDtiPG4ubGVuZ3RoO2IrPTIpe2NvbnN0IGc9TWF0aC5QSSpiL3RoaXMuc2l6ZTtuW2JdPU1hdGguY29zKGcpLG5bYisxXT0tTWF0aC5zaW4oZyl9dGhpcy50YWJsZT1uO2xldCB1PTA7Zm9yKGxldCBiPTE7dGhpcy5zaXplPmI7Yjw8PTEpdSsrO3RoaXMuX3dpZHRoPXUlMj09PTA/dS0xOnUsdGhpcy5fYml0cmV2PW5ldyBBcnJheSgxPDx0aGlzLl93aWR0aCk7Zm9yKGxldCBiPTA7Yjx0aGlzLl9iaXRyZXYubGVuZ3RoO2IrKyl7dGhpcy5fYml0cmV2W2JdPTA7Zm9yKGxldCBnPTA7Zzx0aGlzLl93aWR0aDtnKz0yKXtjb25zdCAkPXRoaXMuX3dpZHRoLWctMjt0aGlzLl9iaXRyZXZbYl18PShiPj4+ZyYzKTw8JH19dGhpcy5fb3V0PW51bGwsdGhpcy5fZGF0YT1udWxsLHRoaXMuX2ludj0wfW4wLnByb3RvdHlwZS5mcm9tQ29tcGxleEFycmF5PWZ1bmN0aW9uKG4sdSl7Y29uc3QgYj11fHxuZXcgRmxvYXQzMkFycmF5KG4ubGVuZ3RoPj4+MSk7Zm9yKGxldCBnPTA7ZzxuLmxlbmd0aDtnKz0yKWJbZz4+PjFdPW5bZ107cmV0dXJuIGJ9LG4wLnByb3RvdHlwZS5jcmVhdGVDb21wbGV4QXJyYXk9ZnVuY3Rpb24oKXtjb25zdCBuPW5ldyBGbG9hdDMyQXJyYXkodGhpcy5fY3NpemUpO2ZvcihsZXQgdT0wO3U8bi5sZW5ndGg7dSsrKW5bdV09MDtyZXR1cm4gbn0sbjAucHJvdG90eXBlLnRvQ29tcGxleEFycmF5PWZ1bmN0aW9uKG4sdSl7Y29uc3QgYj11fHx0aGlzLmNyZWF0ZUNvbXBsZXhBcnJheSgpO2ZvcihsZXQgZz0wO2c8Yi5sZW5ndGg7Zys9MiliW2ddPW5bZz4+PjFdLGJbZysxXT0wO3JldHVybiBifSxuMC5wcm90b3R5cGUuY29tcGxldGVTcGVjdHJ1bT1mdW5jdGlvbihuKXtjb25zdCB1PXRoaXMuX2NzaXplLGI9dT4+PjE7Zm9yKGxldCBnPTI7ZzxiO2crPTIpblt1LWddPW5bZ10sblt1LWcrMV09LW5bZysxXX0sbjAucHJvdG90eXBlLnRyYW5zZm9ybT1mdW5jdGlvbihuLHUpe2lmKG49PT11KXRocm93IG5ldyBFcnJvcigiSW5wdXQgYW5kIG91dHB1dCBidWZmZXJzIG11c3QgYmUgZGlmZmVyZW50Iik7dGhpcy5fb3V0PW4sdGhpcy5fZGF0YT11LHRoaXMuX2ludj0wLHRoaXMuX3RyYW5zZm9ybTQoKSx0aGlzLl9vdXQ9bnVsbCx0aGlzLl9kYXRhPW51bGx9LG4wLnByb3RvdHlwZS5yZWFsVHJhbnNmb3JtPWZ1bmN0aW9uKG4sdSl7aWYobj09PXUpdGhyb3cgbmV3IEVycm9yKCJJbnB1dCBhbmQgb3V0cHV0IGJ1ZmZlcnMgbXVzdCBiZSBkaWZmZXJlbnQiKTt0aGlzLl9vdXQ9bix0aGlzLl9kYXRhPXUsdGhpcy5faW52PTAsdGhpcy5fcmVhbFRyYW5zZm9ybTQoKSx0aGlzLl9vdXQ9bnVsbCx0aGlzLl9kYXRhPW51bGx9LG4wLnByb3RvdHlwZS5pbnZlcnNlVHJhbnNmb3JtPWZ1bmN0aW9uKG4sdSl7aWYobj09PXUpdGhyb3cgbmV3IEVycm9yKCJJbnB1dCBhbmQgb3V0cHV0IGJ1ZmZlcnMgbXVzdCBiZSBkaWZmZXJlbnQiKTt0aGlzLl9vdXQ9bix0aGlzLl9kYXRhPXUsdGhpcy5faW52PTEsdGhpcy5fdHJhbnNmb3JtNCgpO2ZvcihsZXQgYj0wO2I8bi5sZW5ndGg7YisrKW5bYl0vPXRoaXMuc2l6ZTt0aGlzLl9vdXQ9bnVsbCx0aGlzLl9kYXRhPW51bGx9LG4wLnByb3RvdHlwZS5fdHJhbnNmb3JtND1mdW5jdGlvbigpe2NvbnN0IG49dGhpcy5fb3V0LHU9dGhpcy5fY3NpemU7bGV0IGc9MTw8dGhpcy5fd2lkdGgsJD11L2c8PDEsTSx6O2NvbnN0IGs9dGhpcy5fYml0cmV2O2lmKCQ9PT00KWZvcihNPTAsej0wO008dTtNKz0kLHorKyl7Y29uc3QgUj1rW3pdO3RoaXMuX3NpbmdsZVRyYW5zZm9ybTIoTSxSLGcpfWVsc2UgZm9yKE09MCx6PTA7TTx1O00rPSQseisrKXtjb25zdCBSPWtbel07dGhpcy5fc2luZ2xlVHJhbnNmb3JtNChNLFIsZyl9Y29uc3QgeD10aGlzLl9pbnY/LTE6MSxBPXRoaXMudGFibGU7Zm9yKGc+Pj0yO2c+PTI7Zz4+PTIpeyQ9dS9nPDwxO2NvbnN0IFI9JD4+PjI7Zm9yKE09MDtNPHU7TSs9JCl7Y29uc3QgVT1NK1I7Zm9yKGxldCByMD1NLE89MDtyMDxVO3IwKz0yLE8rPWcpe2NvbnN0IG09cjAsRT1tK1IsVj1FK1IsUT1WK1IsdjA9blttXSxlMD1uW20rMV0saDA9bltFXSxDPW5bRSsxXSxjMD1uW1ZdLFc9bltWKzFdLG0wPW5bUV0scDA9bltRKzFdLHcwPXYwLHkwPWUwLF8wPUFbT10sazA9eCpBW08rMV0sJDA9aDAqXzAtQyprMCxNMD1oMCprMCtDKl8wLFMwPUFbMipPXSxJMD14KkFbMipPKzFdLHEwPWMwKlMwLVcqSTAsVzA9YzAqSTArVypTMCxIMD1BWzMqT10sTzA9eCpBWzMqTysxXSxZMD1tMCpIMC1wMCpPMCxDMD1tMCpPMCtwMCpIMCxVMD13MCtxMCxSMD15MCtXMCxUMD13MC1xMCxYMD15MC1XMCxQMD0kMCtZMCx6MD1NMCtDMCxFMD14KigkMC1ZMCksVjA9eCooTTAtQzApLHQxPVUwK1AwLGowPVIwK3owLHAxPVUwLVAwLG0xPVIwLXowLHcxPVQwK1YwLFowPVgwLUUwLHkxPVQwLVYwLGExPVgwK0UwO25bbV09dDEsblttKzFdPWowLG5bRV09dzEsbltFKzFdPVowLG5bVl09cDEsbltWKzFdPW0xLG5bUV09eTEsbltRKzFdPWExfX19fSxuMC5wcm90b3R5cGUuX3NpbmdsZVRyYW5zZm9ybTI9ZnVuY3Rpb24obix1LGIpe2NvbnN0IGc9dGhpcy5fb3V0LCQ9dGhpcy5fZGF0YSxNPSRbdV0sej0kW3UrMV0saz0kW3UrYl0seD0kW3UrYisxXSxBPU0rayxSPXoreCxVPU0tayxyMD16LXg7Z1tuXT1BLGdbbisxXT1SLGdbbisyXT1VLGdbbiszXT1yMH0sbjAucHJvdG90eXBlLl9zaW5nbGVUcmFuc2Zvcm00PWZ1bmN0aW9uKG4sdSxiKXtjb25zdCBnPXRoaXMuX291dCwkPXRoaXMuX2RhdGEsTT10aGlzLl9pbnY/LTE6MSx6PWIqMixrPWIqMyx4PSRbdV0sQT0kW3UrMV0sUj0kW3UrYl0sVT0kW3UrYisxXSxyMD0kW3Urel0sTz0kW3UreisxXSxtPSRbdStrXSxFPSRbdStrKzFdLFY9eCtyMCxRPUErTyx2MD14LXIwLGUwPUEtTyxoMD1SK20sQz1VK0UsYzA9TSooUi1tKSxXPU0qKFUtRSksbTA9VitoMCxwMD1RK0MsdzA9djArVyx5MD1lMC1jMCxfMD1WLWgwLGswPVEtQywkMD12MC1XLE0wPWUwK2MwO2dbbl09bTAsZ1tuKzFdPXAwLGdbbisyXT13MCxnW24rM109eTAsZ1tuKzRdPV8wLGdbbis1XT1rMCxnW24rNl09JDAsZ1tuKzddPU0wfSxuMC5wcm90b3R5cGUuX3JlYWxUcmFuc2Zvcm00PWZ1bmN0aW9uKCl7Y29uc3Qgbj10aGlzLl9vdXQsdT10aGlzLl9jc2l6ZTtsZXQgZz0xPDx0aGlzLl93aWR0aCwkPXUvZzw8MSxNLHo7Y29uc3Qgaz10aGlzLl9iaXRyZXY7aWYoJD09PTQpZm9yKE09MCx6PTA7TTx1O00rPSQseisrKXtjb25zdCBSPWtbel07dGhpcy5fc2luZ2xlUmVhbFRyYW5zZm9ybTIoTSxSPj4+MSxnPj4+MSl9ZWxzZSBmb3IoTT0wLHo9MDtNPHU7TSs9JCx6Kyspe2NvbnN0IFI9a1t6XTt0aGlzLl9zaW5nbGVSZWFsVHJhbnNmb3JtNChNLFI+Pj4xLGc+Pj4xKX1jb25zdCB4PXRoaXMuX2ludj8tMToxLEE9dGhpcy50YWJsZTtmb3IoZz4+PTI7Zz49MjtnPj49Mil7JD11L2c8PDE7Y29uc3QgUj0kPj4+MSxVPVI+Pj4xLHIwPVU+Pj4xO2ZvcihNPTA7TTx1O00rPSQpZm9yKGxldCBPPTAsbT0wO088PXIwO08rPTIsbSs9Zyl7Y29uc3QgRT1NK08sVj1FK1UsUT1WK1UsdjA9UStVLGUwPW5bRV0saDA9bltFKzFdLEM9bltWXSxjMD1uW1YrMV0sVz1uW1FdLG0wPW5bUSsxXSxwMD1uW3YwXSx3MD1uW3YwKzFdLHkwPWUwLF8wPWgwLGswPUFbbV0sJDA9eCpBW20rMV0sTTA9QyprMC1jMCokMCxTMD1DKiQwK2MwKmswLEkwPUFbMiptXSxxMD14KkFbMiptKzFdLFcwPVcqSTAtbTAqcTAsSDA9VypxMCttMCpJMCxPMD1BWzMqbV0sWTA9eCpBWzMqbSsxXSxDMD1wMCpPMC13MCpZMCxVMD1wMCpZMCt3MCpPMCxSMD15MCtXMCxUMD1fMCtIMCxYMD15MC1XMCxQMD1fMC1IMCx6MD1NMCtDMCxFMD1TMCtVMCxWMD14KihNMC1DMCksdDE9eCooUzAtVTApLGowPVIwK3owLHAxPVQwK0UwLG0xPVgwK3QxLHcxPVAwLVYwO2lmKG5bRV09ajAsbltFKzFdPXAxLG5bVl09bTEsbltWKzFdPXcxLE89PT0wKXtjb25zdCBLMT1SMC16MCxCMT1UMC1FMDtuW1FdPUsxLG5bUSsxXT1CMTtjb250aW51ZX1pZihPPT09cjApY29udGludWU7Y29uc3QgWjA9WDAseTE9LVAwLGExPVIwLEExPS1UMCx4MT0teCp0MSxTMT0teCpWMCxJMT0teCpFMCxSMT0teCp6MCxUMT1aMCt4MSxQMT15MStTMSx6MT1hMStSMSxFMT1BMS1JMSxfMT1NK1UtTyxOMT1NK1ItTztuW18xXT1UMSxuW18xKzFdPVAxLG5bTjFdPXoxLG5bTjErMV09RTF9fX0sbjAucHJvdG90eXBlLl9zaW5nbGVSZWFsVHJhbnNmb3JtMj1mdW5jdGlvbihuLHUsYil7Y29uc3QgZz10aGlzLl9vdXQsJD10aGlzLl9kYXRhLE09JFt1XSx6PSRbdStiXSxrPU0reix4PU0tejtnW25dPWssZ1tuKzFdPTAsZ1tuKzJdPXgsZ1tuKzNdPTB9LG4wLnByb3RvdHlwZS5fc2luZ2xlUmVhbFRyYW5zZm9ybTQ9ZnVuY3Rpb24obix1LGIpe2NvbnN0IGc9dGhpcy5fb3V0LCQ9dGhpcy5fZGF0YSxNPXRoaXMuX2ludj8tMToxLHo9YioyLGs9YiozLHg9JFt1XSxBPSRbdStiXSxSPSRbdSt6XSxVPSRbdStrXSxyMD14K1IsTz14LVIsbT1BK1UsRT1NKihBLVUpLFY9cjArbSxRPU8sdjA9LUUsZTA9cjAtbSxoMD1PLEM9RTtnW25dPVYsZ1tuKzFdPTAsZ1tuKzJdPVEsZ1tuKzNdPXYwLGdbbis0XT1lMCxnW24rNV09MCxnW24rNl09aDAsZ1tuKzddPUN9O2NvbnN0IFAyPTQsVjE9bmV3IE1hcDtjbGFzcyBXZXtjb25zdHJ1Y3RvcihuLHUpe2FlKHRoaXMsZDEsdm9pZCAwKTt0aGlzLm1lbFNjYWxlPW51bGwsdGhpcy5sYXN0RnJhbWVJbmRleD0wLHRoaXMuYXVkaW89bix0aGlzLm9wdGlvbnM9dSx0aGlzLmxhc3RGcmFtZUluZGV4PTAsVjEuaGFzKHUud2luZG93U2l6ZSk/dGhpcy5mZnQ9VjEuZ2V0KHUud2luZG93U2l6ZSk6KHRoaXMuZmZ0PW5ldyBuMCh1LndpbmRvd1NpemUpLFYxLnNldCh1LndpbmRvd1NpemUsdGhpcy5mZnQpKSxuZSh0aGlzLGQxLG4uZW5kU2FtcGxlLW4uc3RhcnRTYW1wbGUpO2NvbnN0IGI9TWF0aC5jZWlsKHRoaXMudG90YWxTYW1wbGVzL3RoaXMuc3RlcCksZz11LndpbmRvd1NpemUvMjt0aGlzLmNvbG9yU2NhbGU9X2UodS5jb2xvck1hcCksdGhpcy5zbW9vdGg9R2UodS53aW5kb3dGdW5jdGlvbiksdS5tZWxTY2FsZSYmKHRoaXMubWVsU2NhbGU9TWUoe2ZmdFNpemU6ZyxiYW5rQ291bnQ6Zyxsb3dGcmVxdWVuY3k6MCxoaWdoRnJlcXVlbmN5OnRoaXMubnlxdWlzdCxzYW1wbGVSYXRlOm4uc2FtcGxlUmF0ZX0pKSx0aGlzLmZmdFdpZHRoPWIsdGhpcy5mZnRIZWlnaHQ9Zyx0aGlzLmltYWdlQnVmZmVyPW5ldyBVaW50OENsYW1wZWRBcnJheSh0aGlzLmZmdFdpZHRoKnRoaXMuZmZ0SGVpZ2h0KlAyKSx0aGlzLmltYWdlQnVmZmVyLmZpbGwoMjU1KSx0aGlzLmNvbXBsZXhJbnB1dD1uZXcgRmxvYXQzMkFycmF5KHRoaXMuc2l6ZSoyKSx0aGlzLmZmdE91dHB1dD1uZXcgRmxvYXQzMkFycmF5KHRoaXMuc2l6ZSoyKSx0aGlzLndpbmRvdz1uZXcgRmxvYXQzMkFycmF5KHRoaXMuc2l6ZSksdGhpcy5zcGVjdHJ1bT1uZXcgRmxvYXQzMkFycmF5KHRoaXMuc2l6ZS8yKSx0aGlzLmVzdGltYXRlZFdpbmRvd0xvc3M9cWUodS53aW5kb3dGdW5jdGlvbix1LndpbmRvd1NpemUpLHRoaXMuYW1wbGlmaWNhdGlvbkZhY3Rvcj0xL3RoaXMuZXN0aW1hdGVkV2luZG93TG9zc31nZXQgbnlxdWlzdCgpe3JldHVybiB0aGlzLmF1ZGlvLnNhbXBsZVJhdGUvMn1nZXQgc3RlcCgpe3JldHVybiB0aGlzLm9wdGlvbnMud2luZG93U2l6ZS10aGlzLm9wdGlvbnMud2luZG93T3ZlcmxhcH1nZXQgc2l6ZSgpe3JldHVybiB0aGlzLm9wdGlvbnMud2luZG93U2l6ZX1nZXQgb3V0cHV0QnVmZmVyKCl7cmV0dXJuIHRoaXMuaW1hZ2VCdWZmZXJ9Z2V0IHdpZHRoKCl7cmV0dXJuIHRoaXMuZmZ0V2lkdGh9Z2V0IGhlaWdodCgpe3JldHVybiB0aGlzLmZmdEhlaWdodH1nZXQgdG90YWxTYW1wbGVzKCl7cmV0dXJuIHRlKHRoaXMsZDEpfXBhcnRpYWxHZW5lcmF0ZShuLHUsYil7bGV0IGc9MDtmb3IoZz0wO2c8dSYmdGhpcy5leHRyYWN0V2luZG93KG4sZyx1LHRoaXMuc2l6ZSxiKTtnKz10aGlzLnN0ZXApe2lmKHRoaXMuc21vb3RoKHRoaXMud2luZG93KSx0aGlzLmludGVybGVhdmVSZWFscygpLHRoaXMuZmZ0LnRyYW5zZm9ybSh0aGlzLmZmdE91dHB1dCx0aGlzLmNvbXBsZXhJbnB1dCksdGhpcy5leHRyYWN0TWFnbml0dWRlQW5kU2NhbGUodGhpcy5mZnRPdXRwdXQpLHRoaXMubWVsU2NhbGUpe2NvbnN0ICQ9dGhpcy5tZWxTY2FsZSh0aGlzLnNwZWN0cnVtKTt0aGlzLnNwZWN0cnVtLnNldCgkKX10aGlzLnBhaW50U3BlY3RydW1JbnRvUGl4ZWxCdWZmZXIoKSx0aGlzLmxhc3RGcmFtZUluZGV4Kyt9cmV0dXJuIGd9ZXh0cmFjdFdpbmRvdyhuLHUsYixnLCQpe2NvbnN0IE09dStnO2lmKE08PWIpdGhpcy53aW5kb3cuc2V0KG4uc3ViYXJyYXkodSxNKSk7ZWxzZXtpZighJClyZXR1cm4hMTt0aGlzLndpbmRvdy5zZXQobi5zdWJhcnJheShiLWcsYikpfXJldHVybiEwfWludGVybGVhdmVSZWFscygpe2NvbnN0IG49dGhpcy53aW5kb3csdT10aGlzLmNvbXBsZXhJbnB1dDtmb3IobGV0IGI9MDtiPG4ubGVuZ3RoO2IrKyl1W2IqMl09bltiXX1leHRyYWN0TWFnbml0dWRlQW5kU2NhbGUobil7Y29uc3QgdT10aGlzLnNwZWN0cnVtLGI9dS5sZW5ndGgsZz10aGlzLnNpemUsJD10aGlzLmFtcGxpZmljYXRpb25GYWN0b3IsTT0yO2ZvcihsZXQgej0wO3o8Yjt6Kyspe2NvbnN0IGs9TSt6KjIseD1uW2tdL2csQT1uW2srMV0vZztsZXQgUj1NYXRoLnNxcnQoeCp4K0EqQSk7Uj1SKjIsUj1SKiQsdVt6XT1SfX1wYWludFNwZWN0cnVtSW50b1BpeGVsQnVmZmVyKCl7Zm9yKGxldCBuPTA7bjx0aGlzLnNwZWN0cnVtLmxlbmd0aDtuKyspe2NvbnN0IHU9dGhpcy5zcGVjdHJ1bVtuXTtsZXQgYj0yMCpNYXRoLmxvZzEwKHUpO2IrPTIwO2NvbnN0ICQ9LTg2LHo9LTYtJDtsZXQgaz0oYi0kKS96O2srPXRoaXMub3B0aW9ucy5icmlnaHRuZXNzLGsqPXRoaXMub3B0aW9ucy5jb250cmFzdDtjb25zdCB4PXRoaXMubGFzdEZyYW1lSW5kZXgsQT10aGlzLmZmdEhlaWdodC0xLW4sUj1QMiooeCtBKnRoaXMuZmZ0V2lkdGgpO1I+dGhpcy5pbWFnZUJ1ZmZlci5sZW5ndGgtNCYmY29uc29sZS5lcnJvcigib3ZlcmZsb3cgY29vcmRpbmF0ZXMiLHgsQSxSLHRoaXMuaW1hZ2VCdWZmZXIubGVuZ3RoLHRoaXMuZmZ0V2lkdGgsdGhpcy5mZnRIZWlnaHQpO2NvbnN0IFU9dGhpcy5jb2xvclNjYWxlKGspO3RoaXMuaW1hZ2VCdWZmZXIuc2V0KFUsUil9fX1kMT1uZXcgV2Vha01hcDtmdW5jdGlvbiBqMShsKXtyZXR1cm4gbmV3IFByb21pc2Uobj0+c2V0VGltZW91dChuLGwpKX12YXIgejI9KGw9PihsW2wuQlVGRkVSX0FWQUlMQUJMRT0wXT0iQlVGRkVSX0FWQUlMQUJMRSIsbFtsLkJVRkZFUl9XUklURV9IRUFEPTFdPSJCVUZGRVJfV1JJVEVfSEVBRCIsbFtsLldPUktFUl9TVEFURT0yXT0iV09SS0VSX1NUQVRFIixsW2wuR0VORVJBVElPTj0zXT0iR0VORVJBVElPTiIsbFtsLlBST0NFU1NPUl9SRUFEWT00XT0iUFJPQ0VTU09SX1JFQURZIixsW2wuUFJPQ0VTU09SX0NPTVBMRVRFPTVdPSJQUk9DRVNTT1JfQ09NUExFVEUiLGwpKSh6Mnx8e30pO2NvbnN0IEUyPS0xO2NsYXNzIFoxe3N0YXRpYyBjcmVhdGVTdGF0ZSgpe2NvbnN0IG49bmV3IFNoYXJlZEFycmF5QnVmZmVyKE9iamVjdC5rZXlzKHoyKS5sZW5ndGgvMipJbnQzMkFycmF5LkJZVEVTX1BFUl9FTEVNRU5UKSx1PW5ldyBaMShuKTtyZXR1cm4gdS5wcm9jZXNzb3JSZWFkeUdlbmVyYXRpb249RTIsdS5wcm9jZXNzb3JDb21wbGV0ZUdlbmVyYXRpb249RTIsdX1jb25zdHJ1Y3RvcihuKXt0aGlzLnN0YXRlPW5ldyBJbnQzMkFycmF5KG4pfWdldCBzdGF0ZUJ1ZmZlcigpe3JldHVybiB0aGlzLnN0YXRlLmJ1ZmZlcn1nZXQgYnVmZmVyQXZhaWxhYmxlKCl7cmV0dXJuIEF0b21pY3MubG9hZCh0aGlzLnN0YXRlLDApPT09MX1zZXQgYnVmZmVyQXZhaWxhYmxlKG4pe0F0b21pY3Muc3RvcmUodGhpcy5zdGF0ZSwwLG4pLEF0b21pY3Mubm90aWZ5KHRoaXMuc3RhdGUsMCxuKX1nZXQgYnVmZmVyV3JpdGVIZWFkKCl7cmV0dXJuIEF0b21pY3MubG9hZCh0aGlzLnN0YXRlLDEpfXNldCBidWZmZXJXcml0ZUhlYWQobil7QXRvbWljcy5zdG9yZSh0aGlzLnN0YXRlLDEsbil9Z2V0IHdvcmtlck5ldygpe3JldHVybiBBdG9taWNzLmxvYWQodGhpcy5zdGF0ZSwyKT09PTB9Z2V0IHdvcmtlcklkbGUoKXtyZXR1cm4gQXRvbWljcy5sb2FkKHRoaXMuc3RhdGUsMik9PT0xfWdldCB3b3JrZXJQcm9jZXNzaW5nKCl7cmV0dXJuIEF0b21pY3MubG9hZCh0aGlzLnN0YXRlLDIpPT09Mn1zZXQgd29ya2VyUHJvY2Vzc2luZyhuKXtBdG9taWNzLnN0b3JlKHRoaXMuc3RhdGUsMixuKSxBdG9taWNzLm5vdGlmeSh0aGlzLnN0YXRlLDIsbil9Z2V0IGdlbmVyYXRpb24oKXtyZXR1cm4gQXRvbWljcy5sb2FkKHRoaXMuc3RhdGUsMyl9Z2V0IHByb2Nlc3NvclJlYWR5R2VuZXJhdGlvbigpe3JldHVybiBBdG9taWNzLmxvYWQodGhpcy5zdGF0ZSw0KX1zZXQgcHJvY2Vzc29yUmVhZHlHZW5lcmF0aW9uKG4pe0F0b21pY3Muc3RvcmUodGhpcy5zdGF0ZSw0LG4pfWdldCBwcm9jZXNzb3JDb21wbGV0ZUdlbmVyYXRpb24oKXtyZXR1cm4gQXRvbWljcy5sb2FkKHRoaXMuc3RhdGUsNSl9c2V0IHByb2Nlc3NvckNvbXBsZXRlR2VuZXJhdGlvbihuKXtBdG9taWNzLnN0b3JlKHRoaXMuc3RhdGUsNSxuKX1pc1Byb2Nlc3NvclJlYWR5KG4pe3JldHVybiBBdG9taWNzLmxvYWQodGhpcy5zdGF0ZSw0KT09PW59aXNQcm9jZXNzb3JDb21wbGV0ZShuKXtyZXR1cm4gQXRvbWljcy5sb2FkKHRoaXMuc3RhdGUsNSk9PT1ufXByb2Nlc3NvckNvbXBsZXRlKG4pe2NvbnN0IHU9dGhpcy5wcm9jZXNzb3JDb21wbGV0ZUdlbmVyYXRpb247bj51JiYodGhpcy5wcm9jZXNzb3JDb21wbGV0ZUdlbmVyYXRpb249biksbj09PXUrMSYmKHRoaXMuYnVmZmVyQXZhaWxhYmxlPTEpfXJlc2V0KCl7Y29uc3QgdT1BdG9taWNzLmFkZCh0aGlzLnN0YXRlLDMsMSkrMTtyZXR1cm4gdGhpcy5idWZmZXJXcml0ZUhlYWQ9MCx0aGlzLmJ1ZmZlckF2YWlsYWJsZT0wLHV9bWF0Y2hlc0N1cnJlbnRHZW5lcmF0aW9uKG4pe3JldHVybiBBdG9taWNzLmxvYWQodGhpcy5zdGF0ZSwzKT09PW59YXN5bmMgd2FpdEZvclByb2Nlc3NvclJlYWR5KG4pe2Zvcig7dGhpcy5wcm9jZXNzb3JSZWFkeUdlbmVyYXRpb248bjspYXdhaXQgajEoMCk7cmV0dXJuIHRoaXMubWF0Y2hlc0N1cnJlbnRHZW5lcmF0aW9uKG4pfWFzeW5jIHdhaXRGb3JXb3JrZXJSZWFkeSgpe2Zvcig7dGhpcy53b3JrZXJOZXc7KWF3YWl0IGoxKDApfWFzeW5jIHdhaXRGb3JXb3JrZXJJZGxlKCl7Zm9yKDshdGhpcy53b3JrZXJJZGxlOylhd2FpdCBqMSgwKX19Y2xhc3MgSGUgZXh0ZW5kcyBaMXtjb25zdHJ1Y3Rvcigpe3N1cGVyKC4uLmFyZ3VtZW50cyksdGhpcy5USU1FT1VUPTF9cHJvY2Vzc29yQ2FuR2VuZXJhdGUobil7cmV0dXJuIHRoaXMuaXNQcm9jZXNzb3JSZWFkeShuKSYmIXRoaXMuaXNQcm9jZXNzb3JDb21wbGV0ZShuKX13YWl0Rm9yQnVmZmVyKCl7cmV0dXJuIEF0b21pY3Mud2FpdCh0aGlzLnN0YXRlLDAsMCx0aGlzLlRJTUVPVVQpPT09Im5vdC1lcXVhbCJ9YnVmZmVyUHJvY2Vzc2VkKG4sdSl7aWYodTx0aGlzLmJ1ZmZlcldyaXRlSGVhZCl7Y29uc3QgYj10aGlzLmJ1ZmZlcldyaXRlSGVhZC11O24uY29weVdpdGhpbigwLHUsdGhpcy5idWZmZXJXcml0ZUhlYWQpLHRoaXMuYnVmZmVyV3JpdGVIZWFkPWJ9ZWxzZSB0aGlzLmJ1ZmZlcldyaXRlSGVhZD0wO3RoaXMuYnVmZmVyQXZhaWxhYmxlPTB9d29ya2VyQnVzeSgpe3RoaXMud29ya2VyUHJvY2Vzc2luZz0yfXdvcmtlclJlYWR5KCl7dGhpcy53b3JrZXJQcm9jZXNzaW5nPTF9fWxldCB4MCxHMCxiMSxOMixmMCxRMSx1MCxKMSxCMjtmdW5jdGlvbiBEMihsKXtjb25zdCBuPWYwLnBhcnRpYWxHZW5lcmF0ZShKMSx1MC5idWZmZXJXcml0ZUhlYWQsdTAuaXNQcm9jZXNzb3JDb21wbGV0ZShsKSk7dTAuYnVmZmVyUHJvY2Vzc2VkKEoxLG4pfWZ1bmN0aW9uIE9lKGwpe2NvbnN0IHU9YCR7YHdvcmtlciAoJHtsfSk6YH0gcmVuZGVyYDtjb25zb2xlLnRpbWUodSksdTAud29ya2VyQnVzeSgpO2xldCBiPSExO2Zvcig7dTAucHJvY2Vzc29yQ2FuR2VuZXJhdGUobCk7KXtpZighdTAud2FpdEZvckJ1ZmZlcigpKXtpZih1MC5tYXRjaGVzQ3VycmVudEdlbmVyYXRpb24obCkpY29udGludWU7Yj0hMDticmVha31EMihsKX1ifHwodTAuYnVmZmVyV3JpdGVIZWFkPjAmJkQyKGwpLFllKGYwLm91dHB1dEJ1ZmZlcikpLGNvbnNvbGUudGltZUVuZCh1KSx1MC53b3JrZXJSZWFkeSgpfWZ1bmN0aW9uIFllKGwsbil7Y29uc3QgdT1uZXcgSW1hZ2VEYXRhKGwsZjAud2lkdGgsZjAuaGVpZ2h0KTtOMi5wdXRJbWFnZURhdGEodSwwLDApLEwyKCl9ZnVuY3Rpb24gTDIobCl7RzAuZHJhd0ltYWdlKGIxLDAsMCx4MC53aWR0aCx4MC5oZWlnaHQpLEcwLmNvbW1pdCYmRzAuY29tbWl0KCl9ZnVuY3Rpb24gVWUobCl7dTA9bmV3IEhlKGwuc3RhdGUpLEoxPW5ldyBGbG9hdDMyQXJyYXkobC5zYW1wbGVCdWZmZXIpLHgwPWwuY2FudmFzLGIxPW5ldyBPZmZzY3JlZW5DYW52YXMoNTEyLDUxMiksTjI9YjEuZ2V0Q29udGV4dCgiMmQiKSxHMD14MC5nZXRDb250ZXh0KCIyZCIpLEcwLmltYWdlU21vb3RoaW5nRW5hYmxlZD0hMCxHMC5pbWFnZVNtb290aGluZ1F1YWxpdHk9ImhpZ2giLHUwLndvcmtlclJlYWR5KCl9ZnVuY3Rpb24gWGUobCl7KHtvcHRpb25zOlExLGF1ZGlvSW5mb3JtYXRpb246QjJ9PWwpLGYwPW5ldyBXZShCMixRMSksY29uc29sZS5sb2coYHdvcmtlciAoJHtsLmdlbmVyYXRpb259KTogcmVnZW5lcmF0ZWAse3NhbXBsZXM6ZjAudG90YWxTYW1wbGVzLG5hdHVyYWxXaWR0aDpmMC53aWR0aCxuYXR1cmFsSGVpZ2h0OmYwLmhlaWdodCx3aW5kb3dTaXplOmYwLnNpemUsd2luZG93U3RlcDpmMC5zdGVwfSxRMSksYjEud2lkdGg9ZjAud2lkdGgsYjEuaGVpZ2h0PWYwLmhlaWdodCxPZShsLmdlbmVyYXRpb24pfWZ1bmN0aW9uIFZlKCl7RzAuY2xlYXJSZWN0KDAsMCx4MC53aWR0aCx4MC5oZWlnaHQpfWZ1bmN0aW9uIGplKGwpe3gwLndpZHRoPWwud2lkdGgseDAuaGVpZ2h0PWwuaGVpZ2h0LEwyKHUwLmdlbmVyYXRpb24pfWZ1bmN0aW9uIFplKGwpe3N3aXRjaChsLmRhdGFbMF0pe2Nhc2Uic2V0dXAiOlVlKGwuZGF0YVsxXSk7YnJlYWs7Y2FzZSJyZXNpemUtY2FudmFzIjpqZShsLmRhdGFbMV0pO2JyZWFrO2Nhc2UicmVnZW5lcmF0ZS1zcGVjdHJvZ3JhbSI6WGUobC5kYXRhWzFdKTticmVhaztjYXNlImNsZWFyLWNhbnZhcyI6VmUoKTticmVhaztkZWZhdWx0OnRocm93IG5ldyBFcnJvcigidW5rbm93biBtZXNzYWdlOiAiK2wuZGF0YVswXSl9fW9ubWVzc2FnZT1aZX0pKCk7Cg==", decodeBase64 = (z) => Uint8Array.from(atob(z), (D) => D.charCodeAt(0)), blob = typeof window < "u" && window.Blob && new Blob([decodeBase64(encodedJs)], { type: "text/javascript;charset=utf-8" });
function WorkerWrapper(z) {
  let D;
  try {
    if (D = blob && (window.URL || window.webkitURL).createObjectURL(blob), !D)
      throw "";
    const O = new Worker(D, {
      name: z == null ? void 0 : z.name
    });
    return O.addEventListener("error", () => {
      (window.URL || window.webkitURL).revokeObjectURL(D);
    }), O;
  } catch {
    return new Worker(
      "data:text/javascript;base64," + encodedJs,
      {
        name: z == null ? void 0 : z.name
      }
    );
  } finally {
    D && (window.URL || window.webkitURL).revokeObjectURL(D);
  }
}
const BUFFER_PROCESSOR_NAME = "buffer-builder-processor";
class AudioHelper {
  constructor() {
    this.spectrogramWorker = null, this.cachedResponse = null, this.cachedAudioInformation = null, this.offscreenCanvas = null, this.generationData = /* @__PURE__ */ new Map(), this.segmentSize = 44100, this.generation = 0, this.spectrogramWorker = new WorkerWrapper(), this.state = State.createState(), this.sampleBuffer = new SharedArrayBuffer(Float32Array.BYTES_PER_ELEMENT * this.segmentSize);
  }
  get canvasTransferred() {
    return !!this.offscreenCanvas;
  }
  async connect(D, O, F) {
    if (this.offscreenCanvas)
      throw new Error("Connect can only be called once. Use regenerateSpectrogram to update the spectrogram.");
    const U = performance.now();
    this.offscreenCanvas = O.transferControlToOffscreen(), this.setupWorker();
    const W = await this.render(F, this.generation, D);
    return console.log("audio: connect complete", performance.now() - U), W;
  }
  async changeSource(D, O) {
    if (console.log("audio: change source"), !this.spectrogramWorker)
      throw new Error("Worker is not initialized. Call connect() first.");
    if (!this.cachedResponse)
      throw new Error("No source to regenerate spectrogram");
    const F = await this.abort();
    return this.clearCanvas(), await this.render(O, F, D);
  }
  async regenerateSpectrogram(D) {
    const O = performance.now();
    if (!this.spectrogramWorker)
      throw new Error("Worker is not initialized. Call connect() first.");
    const F = await this.abort();
    if (!this.cachedResponse)
      throw new Error("No spectrogram options to regenerate");
    await this.render(D, F), console.log("audio: regenerate complete", performance.now() - O);
  }
  resizeCanvas(D) {
    if (!this.spectrogramWorker)
      throw new Error("Worker is not initialized");
    const O = ["resize-canvas", D];
    this.spectrogramWorker.postMessage(O);
  }
  async abort() {
    const D = this.generation, O = this.generationData.get(D);
    O && (O.disconnect(), this.generationData.delete(D));
    const F = this.state.reset();
    return this.generation = F, await this.state.waitForWorkerIdle(), F;
  }
  /**
   * Internal render function. Does not check if we need to abort.
   * @param options the spectrogram options
   * @param generation the generation number
   * @param src  if provided fetches the audio at the supplied source, otherwise clones a buffer of the last response
   */
  async render(D, O, F = null) {
    const U = F ? await this.fetchAudio(F) : await this.cachedBuffer(), W = this.cachedAudioInformation;
    return await this.createAudioContext(W, U, O), this.regenerateWorker(D, W, O), W;
  }
  createAudioInformation(D) {
    if (!D.format.duration || !D.format.sampleRate || !D.format.numberOfChannels)
      throw new Error("Could not determine all audio metadata");
    return Object.freeze({
      startSample: 0,
      endSample: D.format.duration * D.format.sampleRate,
      sampleRate: D.format.sampleRate,
      channels: D.format.numberOfChannels,
      duration: D.format.duration
    });
  }
  async fetchAudio(D) {
    const O = `audio (${this.generation}): fetch and decode audio`;
    console.time(O);
    const F = await fetch(D), U = F.clone(), W = await F.arrayBuffer(), B = await lib$3.parseBlob(new Blob([W])), K = this.createAudioInformation(B);
    return this.cachedResponse = U, this.cachedAudioInformation = K, console.timeEnd(O), W;
  }
  async cachedBuffer() {
    if (!this.cachedResponse)
      throw new Error("No cached file");
    const D = this.cachedResponse.clone(), O = await this.cachedResponse.arrayBuffer();
    return this.cachedResponse = D, O;
  }
  async createAudioContext(D, O, F) {
    const U = D.duration * D.sampleRate * D.channels;
    //! creates a buffer the size of the entire audio file
    const W = new OfflineAudioContext({
      numberOfChannels: D.channels,
      sampleRate: D.sampleRate,
      length: U
    }), B = await W.decodeAudioData(O), K = new AudioBufferSourceNode(W, { buffer: B }), X = new URL(bufferBuilderProcessorPath, import.meta.url);
    await W.audioWorklet.addModule(X);
    const Y = new AudioWorkletNode(W, BUFFER_PROCESSOR_NAME);
    K.connect(Y).connect(W.destination), W.addEventListener("complete", () => {
      this.state.processorComplete(F);
    }), await this.setupProcessor(Y, F) && (this.generationData.set(F, K), K.start(), W.startRendering());
  }
  // messages
  async setupWorker() {
    const D = [
      "setup",
      {
        state: this.state.stateBuffer,
        sampleBuffer: this.sampleBuffer,
        canvas: this.offscreenCanvas
      }
    ];
    this.spectrogramWorker.postMessage(D, [this.offscreenCanvas]), await this.state.waitForWorkerReady();
  }
  // very specifically not using instance value of this.generation
  // we want that value closed over so it can't change
  async setupProcessor(D, O) {
    const F = [
      "setup",
      { state: this.state.stateBuffer, sampleBuffer: this.sampleBuffer, generation: O }
    ];
    return D.port.postMessage(F), await this.state.waitForProcessorReady(O);
  }
  clearCanvas() {
    var D;
    (D = this.spectrogramWorker) == null || D.postMessage(["clear-canvas"]);
  }
  regenerateWorker(D, O, F) {
    const U = [
      "regenerate-spectrogram",
      {
        options: D,
        audioInformation: O,
        generation: F
      }
    ];
    this.spectrogramWorker.postMessage(U);
  }
}
class SpectrogramOptions {
  constructor(D, O, F, U, W, B, K) {
    this.windowSize = D, this.windowOverlap = O, this.windowFunction = F, this.melScale = U, this.brightness = W, this.contrast = B, this.colorMap = K;
  }
  get windowStep() {
    return this.windowSize - this.windowOverlap;
  }
}
var __defProp$8 = Object.defineProperty, __getOwnPropDesc$8 = Object.getOwnPropertyDescriptor, __decorateClass$8 = (z, D, O, F) => {
  for (var U = F > 1 ? void 0 : F ? __getOwnPropDesc$8(D, O) : D, W = z.length - 1, B; W >= 0; W--)
    (B = z[W]) && (U = (F ? B(D, O, U) : B(U)) || U);
  return F && U && __defProp$8(D, O, U), U;
};
const defaultAudioModel = new AudioModel({
  duration: 0,
  sampleRate: 0,
  originalAudioRecording: {
    startOffset: 0,
    duration: 0
  }
});
let Spectrogram = class extends e$4(AbstractComponent(s$7)) {
  constructor() {
    super(...arguments), this.paused = !0, this.scaling = "stretch", this.windowSize = 512, this.windowFunction = "hann", this.windowOverlap = 0, this.melScale = !1, this.colorMap = "", this.offset = 0, this.src = "", this.brightness = 0, this.contrast = 1, this.audio = d(defaultAudioModel), this.currentTime = d(this.offset), this.renderCanvasSize = d({ width: 0, height: 0 }), this.renderWindow = w(() => this.parseRenderWindow()), this.useMelScale = d(this.melScale), this.audioHelper = new AudioHelper(), this.doneFirstRender = !1, this.nextRequestId = null, this.playStartedAt = null;
  }
  get spectrogramOptions() {
    return new SpectrogramOptions(
      this.windowSize,
      this.windowOverlap,
      this.windowFunction,
      this.melScale,
      this.brightness,
      this.contrast,
      this.colorMap
    );
  }
  set spectrogramOptions(z) {
    this.windowSize = z.windowSize, this.windowOverlap = z.windowOverlap, this.windowFunction = z.windowFunction, this.melScale = z.melScale, this.brightness = z.brightness, this.contrast = z.contrast, this.colorMap = z.colorMap;
  }
  get renderedSource() {
    if (this.src)
      return this.src;
    const z = this.slotElements[0];
    return z instanceof HTMLSourceElement ? z.src : "";
  }
  hasSource() {
    return !!this.src || this.slotElements.length > 0;
  }
  // todo: this should be part of a mixin
  disconnectedCallback() {
    OeResizeObserver.instance.unobserve(this.canvas), super.disconnectedCallback();
  }
  firstUpdated() {
    OeResizeObserver.observe(this.canvas, (z) => this.handleResize(z)), this.resizeCanvas(this.canvas), this.hasSource() && this.renderSpectrogram(), this.useMelScale.value = this.melScale, this.unitConverters = new UnitConverter(this.renderWindow, this.renderCanvasSize, this.audio, this.useMelScale);
  }
  updated(z) {
    this.doneFirstRender ? this.invalidateSpectrogramOptions(z) ? (this.regenerateSpectrogramOptions(), this.useMelScale.value = this.melScale) : this.invalidateSpectrogramSource(z) && (this.pause(), this.regenerateSpectrogram(), this.updateCurrentTime()) : this.invalidateSpectrogramSource(z) && this.hasSource() && this.renderSpectrogram(), this.resizeCanvas(this.canvas);
  }
  renderSpectrogram() {
    this.dispatchEvent(
      new CustomEvent("loading", {
        bubbles: !0
      })
    ), this.audioHelper.connect(this.renderedSource, this.canvas, this.spectrogramOptions).then((z) => {
      const D = { duration: z.duration, startOffset: this.offset };
      this.audio.value = new AudioModel({
        duration: z.duration,
        sampleRate: z.sampleRate,
        originalAudioRecording: D
      }), this.dispatchEvent(
        new CustomEvent("loaded", {
          bubbles: !0
        })
      ), this.doneFirstRender = !0;
    });
  }
  regenerateSpectrogram() {
    !this.doneFirstRender || !this.renderedSource || (console.log("regenerating spectrogram"), this.dispatchEvent(
      new CustomEvent("loading", {
        bubbles: !0
      })
    ), this.audioHelper.changeSource(this.renderedSource, this.spectrogramOptions).then((z) => {
      const D = { duration: z.duration, startOffset: this.offset };
      this.audio.value = new AudioModel({
        duration: z.duration,
        sampleRate: z.sampleRate,
        originalAudioRecording: D
      }), this.dispatchEvent(
        new CustomEvent("loaded", {
          bubbles: !0
        })
      );
    }));
  }
  regenerateSpectrogramOptions() {
    !this.doneFirstRender || !this.renderedSource || this.audioHelper.regenerateSpectrogram(this.spectrogramOptions).then(() => {
      this.dispatchEvent(
        new CustomEvent("loaded", {
          bubbles: !0
        })
      );
    });
  }
  // TODO: finish this method
  resetSettings() {
  }
  play() {
    this.paused = !1, this.setPlaying();
  }
  pause() {
    this.paused = !0, this.setPlaying();
  }
  handleSlotChange() {
    this.hasSource() && this.renderSpectrogram();
  }
  originalFftSize() {
    const z = this.spectrogramOptions, D = z.windowSize - z.windowOverlap, O = this.audio.value.duration, F = this.audio.value.sampleRate, U = O * F, W = Math.ceil(U / D), B = z.windowSize / 2;
    return { width: W, height: B };
  }
  naturalSize(z, D) {
    const O = Math.min(D.clientWidth / z.width, D.clientHeight / z.height);
    return {
      width: z.width * O,
      height: z.height * O
    };
  }
  stretchSize(z) {
    return { width: z.clientWidth, height: z.clientHeight };
  }
  // TODO: parents should not contribute to the size of the canvas
  handleResize(z) {
    if (z.length === 0)
      return;
    const D = z[0].target;
    this.resizeCanvas(D);
  }
  // TODO: refactor this procedure
  resizeCanvas(z) {
    let D;
    if (this.scaling === "original")
      D = this.originalFftSize();
    else if (this.scaling === "natural") {
      const O = this.originalFftSize();
      D = this.naturalSize(O, z);
    } else
      D = this.stretchSize(z);
    this.renderCanvasSize.value = D, this.audioHelper.canvasTransferred ? this.audioHelper.resizeCanvas(D) : (this.canvas.width = D.width, this.canvas.height = D.height), this.scaling === "original" && (this.style.height = `${D.height}px`, this.style.width = `${D.width}px`), this.scaling === "stretch" ? this.canvas.style.width = "100%" : this.canvas.style.width = "auto";
  }
  /**
   * Specifies if the spectrogram is invalidated with the new parameters
   * This method can be used to check if the spectrogram needs to be re-rendered
   */
  invalidateSpectrogramOptions(z) {
    return [
      "domRenderWindow",
      "brightness",
      "contrast",
      "windowSize",
      "windowFunction",
      "windowOverlap",
      "melScale",
      "colorMap",
      "offset"
    ].some((O) => z.has(O));
  }
  invalidateSpectrogramSource(z) {
    return ["src", "slotElements"].some((O) => z.has(O));
  }
  updateCurrentTime(z = !1) {
    if (z) {
      this.nextRequestId && (window.cancelAnimationFrame(this.nextRequestId), this.nextRequestId = null), this.nextRequestId = requestAnimationFrame(() => this.pollUpdateHighFreqCurrentTime());
      return;
    }
    this.currentTime.value = this.mediaElement.currentTime;
  }
  // we used to set lastHighResSync to performance.now(), but this caused some
  // visual artifacts when the audio was paused and then played again
  // this was because the time between calling function and fetching the highResTime
  // later on led to a time difference of a couple of milliseconds
  pollUpdateHighFreqCurrentTime(z = null, D = null) {
    if (!this.paused) {
      const O = this.mediaElement.currentTime;
      let F = 0;
      const U = performance.now();
      O === D && z !== null ? F = (U - z) / 1e3 : this.playStartedAt !== null && (z = U);
      const W = O + F;
      if (W >= this.audio.value.duration) {
        this.currentTime.value = this.audio.value.duration, this.pause();
        return;
      }
      console.log("high res delta", F, O, W), this.currentTime.value = O + F, this.nextRequestId = requestAnimationFrame(
        () => this.pollUpdateHighFreqCurrentTime(z, O)
      );
    }
  }
  setPlaying() {
    var z, D, O;
    this.paused != ((z = this.mediaElement) == null ? void 0 : z.paused) && (this.paused ? (this.nextRequestId && (window.cancelAnimationFrame(this.nextRequestId), this.nextRequestId = null), (D = this.mediaElement) == null || D.pause()) : ((O = this.mediaElement) == null || O.play(), this.updateCurrentTime(!0)), this.dispatchEvent(new CustomEvent("play", { detail: !this.paused })));
  }
  // creates a render window from an audio segment
  parseRenderWindow() {
    var U;
    if (!this.domRenderWindow)
      return new RenderWindow({
        startOffset: this.offset,
        endOffset: this.offset + this.audio.value.duration,
        lowFrequency: 0,
        highFrequency: ((U = this.unitConverters) == null ? void 0 : U.nyquist.value) ?? 0
      });
    const [z, D, O, F] = this.domRenderWindow.split(",").map(parseFloat);
    return new RenderWindow({
      startOffset: z,
      endOffset: O,
      lowFrequency: D,
      highFrequency: F
    });
  }
  render() {
    return x`
      <div id="spectrogram-container">
        <canvas></canvas>
      </div>
      <audio
        id="media-element"
        src="${this.src}"
        @ended="${this.pause}"
        @play="${() => this.playStartedAt = performance.now()}"
        preload="metadata"
        crossorigin="use-credentials"
      >
        <slot @slotchange="${this.handleSlotChange}"></slot>
      </audio>
    `;
  }
};
Spectrogram.styles = spectrogramStyles;
__decorateClass$8([
  n$6({ type: String, attribute: "window", reflect: !0 })
], Spectrogram.prototype, "domRenderWindow", 2);
__decorateClass$8([
  n$6({ type: Boolean, reflect: !0 })
], Spectrogram.prototype, "paused", 2);
__decorateClass$8([
  n$6({ type: String, reflect: !0 })
], Spectrogram.prototype, "scaling", 2);
__decorateClass$8([
  n$6({ type: Number, attribute: "window-size" })
], Spectrogram.prototype, "windowSize", 2);
__decorateClass$8([
  n$6({ type: String, attribute: "window-function" })
], Spectrogram.prototype, "windowFunction", 2);
__decorateClass$8([
  n$6({ type: Number, attribute: "window-overlap" })
], Spectrogram.prototype, "windowOverlap", 2);
__decorateClass$8([
  n$6({ type: Boolean, attribute: "mel-scale", converter: booleanConverter })
], Spectrogram.prototype, "melScale", 2);
__decorateClass$8([
  n$6({ type: String, attribute: "color-map" })
], Spectrogram.prototype, "colorMap", 2);
__decorateClass$8([
  n$6({ type: Number })
], Spectrogram.prototype, "offset", 2);
__decorateClass$8([
  n$6({ type: String })
], Spectrogram.prototype, "src", 2);
__decorateClass$8([
  n$6({ type: Number })
], Spectrogram.prototype, "brightness", 2);
__decorateClass$8([
  n$6({ type: Number })
], Spectrogram.prototype, "contrast", 2);
__decorateClass$8([
  o$b()
], Spectrogram.prototype, "slotElements", 2);
__decorateClass$8([
  e$b("#media-element")
], Spectrogram.prototype, "mediaElement", 2);
__decorateClass$8([
  e$b("canvas")
], Spectrogram.prototype, "canvas", 2);
Spectrogram = __decorateClass$8([
  t$5("oe-spectrogram")
], Spectrogram);
const indicatorStyles = i$7`
  :host {
    position: relative;
    display: inline-block !important;
    width: 100%;

    /*
      By setting the color on the host element, it means that users can customize
      the color with plain css

      eg.
        oe-indicator { color: blue; } or <oe-indicator style="color: blue"></oe-indicator>
    */
    color: red;
    stroke-width: 2;
  }

  #wrapped-element {
    position: relative;
  }

  #indicator-svg {
    position: absolute;
    width: 100%;
    height: 100%;
    z-index: 1;
    overflow: visible;
  }

  /* This element can be targeted through CSS parts */
  #indicator-line {
    stroke: currentColor;
    shape-rendering: crispEdges;
    will-change: transform;
  }

  #seek-icon {
    stroke: gray;
    fill: white;
  }
`;
var __defProp$7 = Object.defineProperty, __getOwnPropDesc$7 = Object.getOwnPropertyDescriptor, __decorateClass$7 = (z, D, O, F) => {
  for (var U = F > 1 ? void 0 : F ? __getOwnPropDesc$7(D, O) : D, W = z.length - 1, B; W >= 0; W--)
    (B = z[W]) && (U = (F ? B(D, O, U) : B(U)) || U);
  return F && U && __defProp$7(D, O, U), U;
};
let Indicator = class extends AbstractComponent(s$7) {
  constructor() {
    super(...arguments), this.xPos = 0, this.computedTimePx = w(() => 0);
  }
  handleSlotChange() {
    this.spectrogram && (this.unitConverter = this.spectrogram.unitConverters, this.computedTimePx = w(() => {
      const z = this.spectrogram.currentTime, D = this.unitConverter.scaleX.value;
      return console.log("new time", z.value), D(z.value);
    }));
  }
  render() {
    return x`
      <div id="wrapped-element">
        <svg id="indicator-svg">
          <g id="indicator-line" style="transform: translateX(${s$1(this.computedTimePx)}px)">
            <line part="indicator-line" y1="0" y2="100%"></line>
            <circle id="seek-icon" part="seek-icon" cy="100%" r="5" />
          </g>
        </svg>
        <slot @slotchange="${this.handleSlotChange}"></slot>
      </div>
    `;
  }
};
Indicator.styles = indicatorStyles;
__decorateClass$7([
  queryDeeplyAssignedElement({ selector: "oe-spectrogram" })
], Indicator.prototype, "spectrogram", 2);
Indicator = __decorateClass$7([
  t$5("oe-indicator")
], Indicator);
const verificationGridStyles = i$7`
  #highlight-box {
    position: absolute;
    display: none;
    top: 0px;
    left: 0px;
    width: 0px;
    height: 0px;
    background-color: var(--oe-selected-color);
    border: solid 2px var(--oe-border-color);
    border-radius: 1rem;
    opacity: 0.3;
    z-index: 5;
  }

  .keyboard-shortcuts {
    display: grid;
    position: relative;
    grid-template-columns: 1fr 1fr;
    gap: var(--oe-spacing);
    width: 100%;
    margin-top: 0.5rem;
    margin-bottom: 0.5rem;
  }

  /* TODO: fix placement */
  .statistics-section {
    position: relative;
    display: inline-block;
    width: fit-content;
    padding: var(--oe-spacing);
  }

  .verification-container {
    background-color: var(--oe-background-color);
    height: 100%;
  }

  .verification-grid {
    user-select: none;
  }

  .verification-grid {
    display: flex;
    flex-wrap: wrap;
    justify-content: center;
    align-items: stretch;
    gap: var(--oe-spacing);
  }

  .no-items-message {
    font-size: 1.2rem;
  }

  .verification-controls-title {
    text-align: center;
    font-family: sans-serif;
    font-weight: normal;
    font-size: 1.4rem;
    letter-spacing: 0em;
    color: var(--oe-font-color);
  }

  .verification-controls {
    display: flex;
    flex-wrap: wrap;
    justify-content: space-around;
    align-items: end;
    padding: var(--oe-spacing);
    gap: var(--oe-spacing);
    color: var(--oe-font-color);
  }

  .decision-controls {
    h2 {
      display: block;
    }

    .decision-control-actions {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
    }
  }

  .decision-controls-left,
  .decision-controls-right {
    display: flex;
  }

  /*
    We apply styles to the <template> elements here because we can access them
    through light dom selectors.
    We cannot target the template elements inside the verification-grid-tile
    because they are reflected into the shadow dom, but not actually rendered
    in the tile dom (meaning that we can't style them in the tile component).
  */
  oe-spectrogram {
    @media (max-width: 600px) {
      /* TODO: do this better. This is a hacky solution for now */
      height: 380px;
    }
  }
`;
class Verification {
  constructor(D) {
    this.subject = D.subject, this.url = D.url, this.tag = D.tag, this.confirmed = D.confirmed, this.additionalTags = D.additionalTags;
  }
  // other metadata e.g. verificationDate
}
function defaultFormatter(z) {
  return z == null ? "" : `${z}`;
}
function numberFormatter(z = {}) {
  const { separator: D, decimals: O } = z;
  return D ? O ? (F) => F.toFixed(O).replace(".", D) : (F) => `${F}`.replace(".", D) : O ? (F) => F.toFixed(O) : (F) => `${F}`;
}
function stringFormatter(z = {}) {
  const D = typeof z.quote == "string" ? z.quote : '"', O = typeof z.escapedQuote == "string" ? z.escapedQuote : `${D}${D}`;
  if (!D || D === O)
    return (U) => U;
  const F = new RegExp(D, "g");
  return (U) => (U.includes(D) && (U = U.replace(F, O)), `${D}${U}${D}`);
}
function symbolFormatter(z = { stringFormatter: stringFormatter() }) {
  return (D) => z.stringFormatter(D.toString().slice(7, -1));
}
function objectFormatter(z = { stringFormatter: stringFormatter() }) {
  return (D) => {
    if (D === null)
      return "";
    let O = JSON.stringify(D);
    return O === void 0 ? "" : (O[0] === '"' && (O = O.replace(/^"(.+)"$/, "$1")), z.stringFormatter(O));
  };
}
const rePropName = RegExp(
  // Match anything that isn't a dot or bracket.
  `[^.[\\]]+|\\[(?:([^"'][^[]*)|(["'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))`,
  "g"
);
function castPath(z) {
  var D, O, F;
  const U = [];
  let W;
  for (; W = rePropName.exec(z); )
    U.push((F = (D = W[3]) !== null && D !== void 0 ? D : (O = W[1]) === null || O === void 0 ? void 0 : O.trim()) !== null && F !== void 0 ? F : W[0]);
  return U;
}
function getProp(z, D, O) {
  if (D in z) {
    const W = z[D];
    return W === void 0 ? O : W;
  }
  const F = Array.isArray(D) ? D : castPath(D);
  let U = z;
  for (const W of F)
    if (U = U == null ? void 0 : U[W], U === void 0)
      return O;
  return U;
}
function flattenReducer(z, D) {
  try {
    return Array.isArray(D) ? z.push(...D) : z.push(D), z;
  } catch {
    return z.concat(D);
  }
}
function fastJoin(z, D) {
  let O = !0;
  return z.reduce((F, U) => (U == null && (U = ""), O ? (O = !1, `${U}`) : `${F}${D}${U}`), "");
}
var FormatterTypes;
(function(z) {
  z.header = "header", z.undefined = "undefined", z.boolean = "boolean", z.number = "number", z.bigint = "bigint", z.string = "string", z.symbol = "symbol", z.function = "function", z.object = "object";
})(FormatterTypes || (FormatterTypes = {}));
class JSON2CSVBase {
  constructor(D) {
    this.opts = this.preprocessOpts(D);
  }
  /**
   * Check passing opts and set defaults.
   *
   * @param {Json2CsvOptions} opts Options object containing fields,
   * delimiter, default value, header, etc.
   */
  preprocessOpts(D) {
    const O = Object.assign({}, D);
    O.fields && (O.fields = this.preprocessFieldsInfo(O.fields, O.defaultValue)), O.transforms = O.transforms || [];
    const F = O.formatters && O.formatters.string || stringFormatter(), U = objectFormatter({ stringFormatter: F }), W = {
      header: F,
      undefined: defaultFormatter,
      boolean: defaultFormatter,
      number: numberFormatter(),
      bigint: defaultFormatter,
      string: F,
      symbol: symbolFormatter({ stringFormatter: F }),
      function: U,
      object: U
    };
    return O.formatters = Object.assign(Object.assign({}, W), O.formatters), O.delimiter = O.delimiter || ",", O.eol = O.eol || `
`, O.header = O.header !== !1, O.includeEmptyRows = O.includeEmptyRows || !1, O.withBOM = O.withBOM || !1, O;
  }
  /**
   * Check and normalize the fields configuration.
   *
   * @param {(string|object)[]} fields Fields configuration provided by the user
   * or inferred from the data
   * @returns {object[]} preprocessed FieldsInfo array
   */
  preprocessFieldsInfo(D, O) {
    return D.map((F) => {
      if (typeof F == "string")
        return {
          label: F,
          value: (U) => getProp(U, F, O)
        };
      if (typeof F == "object") {
        const U = "default" in F ? F.default : O;
        if (typeof F.value == "string") {
          const W = F.value;
          return {
            label: F.label || F.value,
            value: (B) => getProp(B, W, U)
          };
        }
        if (typeof F.value == "function") {
          const W = F.label || F.value.name || "", B = { label: W, default: U }, K = F.value;
          return {
            label: W,
            value(X) {
              const Y = K(X, B);
              return Y === void 0 ? U : Y;
            }
          };
        }
      }
      throw new Error("Invalid field info option. " + JSON.stringify(F));
    });
  }
  /**
   * Create the title row with all the provided fields as column headings
   *
   * @returns {String} titles as a string
   */
  getHeader() {
    return fastJoin(this.opts.fields.map((D) => this.opts.formatters.header(D.label)), this.opts.delimiter);
  }
  /**
   * Preprocess each object according to the given transforms (unwind, flatten, etc.).
   * @param {Object} row JSON object to be converted in a CSV row
   */
  preprocessRow(D) {
    return this.opts.transforms.reduce((O, F) => O.map((U) => F(U)).reduce(flattenReducer, []), [D]);
  }
  /**
   * Create the content of a specific CSV row
   *
   * @param {Object} row JSON object to be converted in a CSV row
   * @returns {String} CSV string (row)
   */
  processRow(D) {
    if (!D)
      return;
    const O = this.opts.fields.map((F) => this.processCell(D, F));
    if (!(!this.opts.includeEmptyRows && O.every((F) => F === "")))
      return fastJoin(O, this.opts.delimiter);
  }
  /**
   * Create the content of a specfic CSV row cell
   *
   * @param {Object} row JSON object representing the  CSV row that the cell belongs to
   * @param {FieldInfo} fieldInfo Details of the field to process to be a CSV cell
   * @returns {String} CSV string (cell)
   */
  processCell(D, O) {
    return this.processValue(O.value(D));
  }
  /**
   * Create the content of a specfic CSV row cell
   *
   * @param {T} value Value to be included in a CSV cell
   * @returns {String} Value stringified and processed
   */
  processValue(D) {
    const O = this.opts.formatters[typeof D];
    return O(D);
  }
}
class JSON2CSVParser extends JSON2CSVBase {
  constructor(D) {
    super(D);
  }
  /**
   * Main function that converts json to csv.
   *
   * @param {Array|Object} data Array of JSON objects to be converted to CSV
   * @returns {String} The CSV formated data as a string
   */
  parse(D) {
    const O = this.preprocessData(D);
    this.opts.fields = this.opts.fields || this.preprocessFieldsInfo(O.reduce((B, K) => (Object.keys(K).forEach((X) => {
      B.includes(X) || B.push(X);
    }), B), []), this.opts.defaultValue);
    const F = this.opts.header ? this.getHeader() : "", U = this.processData(O);
    return (this.opts.withBOM ? "\uFEFF" : "") + F + (F && U ? this.opts.eol : "") + U;
  }
  /**
   * Preprocess the data according to the give opts (unwind, flatten, etc.)
    and calculate the fields and field names if they are not provided.
   *
   * @param {Array|Object} data Array or object to be converted to CSV
   */
  preprocessData(D) {
    const O = Array.isArray(D) ? D : [D];
    if (!this.opts.fields) {
      if (D == null || O.length === 0)
        throw new Error('Data should not be empty or the "fields" option should be included');
      if (typeof O[0] != "object")
        throw new Error('Data items should be objects or the "fields" option should be included');
    }
    return this.opts.transforms.length === 0 ? O : O.map((F) => this.preprocessRow(F)).reduce(flattenReducer, []);
  }
  /**
   * Create the content row by row below the header
   *
   * @param {Array} data Array of JSON objects to be converted to CSV
   * @returns {String} CSV string (body)
   */
  processData(D) {
    return fastJoin(
      D.map((O) => this.processRow(O)).filter((O) => O),
      // Filter empty rows
      this.opts.eol
    );
  }
}
var charset;
(function(z) {
  z[z.BACKSPACE = 8] = "BACKSPACE", z[z.FORM_FEED = 12] = "FORM_FEED", z[z.NEWLINE = 10] = "NEWLINE", z[z.CARRIAGE_RETURN = 13] = "CARRIAGE_RETURN", z[z.TAB = 9] = "TAB", z[z.SPACE = 32] = "SPACE", z[z.EXCLAMATION_MARK = 33] = "EXCLAMATION_MARK", z[z.QUOTATION_MARK = 34] = "QUOTATION_MARK", z[z.NUMBER_SIGN = 35] = "NUMBER_SIGN", z[z.DOLLAR_SIGN = 36] = "DOLLAR_SIGN", z[z.PERCENT_SIGN = 37] = "PERCENT_SIGN", z[z.AMPERSAND = 38] = "AMPERSAND", z[z.APOSTROPHE = 39] = "APOSTROPHE", z[z.LEFT_PARENTHESIS = 40] = "LEFT_PARENTHESIS", z[z.RIGHT_PARENTHESIS = 41] = "RIGHT_PARENTHESIS", z[z.ASTERISK = 42] = "ASTERISK", z[z.PLUS_SIGN = 43] = "PLUS_SIGN", z[z.COMMA = 44] = "COMMA", z[z.HYPHEN_MINUS = 45] = "HYPHEN_MINUS", z[z.FULL_STOP = 46] = "FULL_STOP", z[z.SOLIDUS = 47] = "SOLIDUS", z[z.DIGIT_ZERO = 48] = "DIGIT_ZERO", z[z.DIGIT_ONE = 49] = "DIGIT_ONE", z[z.DIGIT_TWO = 50] = "DIGIT_TWO", z[z.DIGIT_THREE = 51] = "DIGIT_THREE", z[z.DIGIT_FOUR = 52] = "DIGIT_FOUR", z[z.DIGIT_FIVE = 53] = "DIGIT_FIVE", z[z.DIGIT_SIX = 54] = "DIGIT_SIX", z[z.DIGIT_SEVEN = 55] = "DIGIT_SEVEN", z[z.DIGIT_EIGHT = 56] = "DIGIT_EIGHT", z[z.DIGIT_NINE = 57] = "DIGIT_NINE", z[z.COLON = 58] = "COLON", z[z.SEMICOLON = 59] = "SEMICOLON", z[z.LESS_THAN_SIGN = 60] = "LESS_THAN_SIGN", z[z.EQUALS_SIGN = 61] = "EQUALS_SIGN", z[z.GREATER_THAN_SIGN = 62] = "GREATER_THAN_SIGN", z[z.QUESTION_MARK = 63] = "QUESTION_MARK", z[z.COMMERCIAL_AT = 64] = "COMMERCIAL_AT", z[z.LATIN_CAPITAL_LETTER_A = 65] = "LATIN_CAPITAL_LETTER_A", z[z.LATIN_CAPITAL_LETTER_B = 66] = "LATIN_CAPITAL_LETTER_B", z[z.LATIN_CAPITAL_LETTER_C = 67] = "LATIN_CAPITAL_LETTER_C", z[z.LATIN_CAPITAL_LETTER_D = 68] = "LATIN_CAPITAL_LETTER_D", z[z.LATIN_CAPITAL_LETTER_E = 69] = "LATIN_CAPITAL_LETTER_E", z[z.LATIN_CAPITAL_LETTER_F = 70] = "LATIN_CAPITAL_LETTER_F", z[z.LATIN_CAPITAL_LETTER_G = 71] = "LATIN_CAPITAL_LETTER_G", z[z.LATIN_CAPITAL_LETTER_H = 72] = "LATIN_CAPITAL_LETTER_H", z[z.LATIN_CAPITAL_LETTER_I = 73] = "LATIN_CAPITAL_LETTER_I", z[z.LATIN_CAPITAL_LETTER_J = 74] = "LATIN_CAPITAL_LETTER_J", z[z.LATIN_CAPITAL_LETTER_K = 75] = "LATIN_CAPITAL_LETTER_K", z[z.LATIN_CAPITAL_LETTER_L = 76] = "LATIN_CAPITAL_LETTER_L", z[z.LATIN_CAPITAL_LETTER_M = 77] = "LATIN_CAPITAL_LETTER_M", z[z.LATIN_CAPITAL_LETTER_N = 78] = "LATIN_CAPITAL_LETTER_N", z[z.LATIN_CAPITAL_LETTER_O = 79] = "LATIN_CAPITAL_LETTER_O", z[z.LATIN_CAPITAL_LETTER_P = 80] = "LATIN_CAPITAL_LETTER_P", z[z.LATIN_CAPITAL_LETTER_Q = 81] = "LATIN_CAPITAL_LETTER_Q", z[z.LATIN_CAPITAL_LETTER_R = 82] = "LATIN_CAPITAL_LETTER_R", z[z.LATIN_CAPITAL_LETTER_S = 83] = "LATIN_CAPITAL_LETTER_S", z[z.LATIN_CAPITAL_LETTER_T = 84] = "LATIN_CAPITAL_LETTER_T", z[z.LATIN_CAPITAL_LETTER_U = 85] = "LATIN_CAPITAL_LETTER_U", z[z.LATIN_CAPITAL_LETTER_V = 86] = "LATIN_CAPITAL_LETTER_V", z[z.LATIN_CAPITAL_LETTER_W = 87] = "LATIN_CAPITAL_LETTER_W", z[z.LATIN_CAPITAL_LETTER_X = 88] = "LATIN_CAPITAL_LETTER_X", z[z.LATIN_CAPITAL_LETTER_Y = 89] = "LATIN_CAPITAL_LETTER_Y", z[z.LATIN_CAPITAL_LETTER_Z = 90] = "LATIN_CAPITAL_LETTER_Z", z[z.LEFT_SQUARE_BRACKET = 91] = "LEFT_SQUARE_BRACKET", z[z.REVERSE_SOLIDUS = 92] = "REVERSE_SOLIDUS", z[z.RIGHT_SQUARE_BRACKET = 93] = "RIGHT_SQUARE_BRACKET", z[z.CIRCUMFLEX_ACCENT = 94] = "CIRCUMFLEX_ACCENT", z[z.LOW_LINE = 95] = "LOW_LINE", z[z.GRAVE_ACCENT = 96] = "GRAVE_ACCENT", z[z.LATIN_SMALL_LETTER_A = 97] = "LATIN_SMALL_LETTER_A", z[z.LATIN_SMALL_LETTER_B = 98] = "LATIN_SMALL_LETTER_B", z[z.LATIN_SMALL_LETTER_C = 99] = "LATIN_SMALL_LETTER_C", z[z.LATIN_SMALL_LETTER_D = 100] = "LATIN_SMALL_LETTER_D", z[z.LATIN_SMALL_LETTER_E = 101] = "LATIN_SMALL_LETTER_E", z[z.LATIN_SMALL_LETTER_F = 102] = "LATIN_SMALL_LETTER_F", z[z.LATIN_SMALL_LETTER_G = 103] = "LATIN_SMALL_LETTER_G", z[z.LATIN_SMALL_LETTER_H = 104] = "LATIN_SMALL_LETTER_H", z[z.LATIN_SMALL_LETTER_I = 105] = "LATIN_SMALL_LETTER_I", z[z.LATIN_SMALL_LETTER_J = 106] = "LATIN_SMALL_LETTER_J", z[z.LATIN_SMALL_LETTER_K = 107] = "LATIN_SMALL_LETTER_K", z[z.LATIN_SMALL_LETTER_L = 108] = "LATIN_SMALL_LETTER_L", z[z.LATIN_SMALL_LETTER_M = 109] = "LATIN_SMALL_LETTER_M", z[z.LATIN_SMALL_LETTER_N = 110] = "LATIN_SMALL_LETTER_N", z[z.LATIN_SMALL_LETTER_O = 111] = "LATIN_SMALL_LETTER_O", z[z.LATIN_SMALL_LETTER_P = 112] = "LATIN_SMALL_LETTER_P", z[z.LATIN_SMALL_LETTER_Q = 113] = "LATIN_SMALL_LETTER_Q", z[z.LATIN_SMALL_LETTER_R = 114] = "LATIN_SMALL_LETTER_R", z[z.LATIN_SMALL_LETTER_S = 115] = "LATIN_SMALL_LETTER_S", z[z.LATIN_SMALL_LETTER_T = 116] = "LATIN_SMALL_LETTER_T", z[z.LATIN_SMALL_LETTER_U = 117] = "LATIN_SMALL_LETTER_U", z[z.LATIN_SMALL_LETTER_V = 118] = "LATIN_SMALL_LETTER_V", z[z.LATIN_SMALL_LETTER_W = 119] = "LATIN_SMALL_LETTER_W", z[z.LATIN_SMALL_LETTER_X = 120] = "LATIN_SMALL_LETTER_X", z[z.LATIN_SMALL_LETTER_Y = 121] = "LATIN_SMALL_LETTER_Y", z[z.LATIN_SMALL_LETTER_Z = 122] = "LATIN_SMALL_LETTER_Z", z[z.LEFT_CURLY_BRACKET = 123] = "LEFT_CURLY_BRACKET", z[z.VERTICAL_LINE = 124] = "VERTICAL_LINE", z[z.RIGHT_CURLY_BRACKET = 125] = "RIGHT_CURLY_BRACKET", z[z.TILDE = 126] = "TILDE";
})(charset || (charset = {}));
charset.QUOTATION_MARK + "", charset.QUOTATION_MARK, charset.REVERSE_SOLIDUS + "", charset.REVERSE_SOLIDUS, charset.SOLIDUS + "", charset.SOLIDUS, charset.LATIN_SMALL_LETTER_B + "", charset.BACKSPACE, charset.LATIN_SMALL_LETTER_F + "", charset.FORM_FEED, charset.LATIN_SMALL_LETTER_N + "", charset.NEWLINE, charset.LATIN_SMALL_LETTER_R + "", charset.CARRIAGE_RETURN, charset.LATIN_SMALL_LETTER_T + "", charset.TAB;
var TokenType;
(function(z) {
  z[z.LEFT_BRACE = 0] = "LEFT_BRACE", z[z.RIGHT_BRACE = 1] = "RIGHT_BRACE", z[z.LEFT_BRACKET = 2] = "LEFT_BRACKET", z[z.RIGHT_BRACKET = 3] = "RIGHT_BRACKET", z[z.COLON = 4] = "COLON", z[z.COMMA = 5] = "COMMA", z[z.TRUE = 6] = "TRUE", z[z.FALSE = 7] = "FALSE", z[z.NULL = 8] = "NULL", z[z.STRING = 9] = "STRING", z[z.NUMBER = 10] = "NUMBER", z[z.SEPARATOR = 11] = "SEPARATOR";
})(TokenType || (TokenType = {}));
var TokenizerStates;
(function(z) {
  z[z.START = 0] = "START", z[z.ENDED = 1] = "ENDED", z[z.ERROR = 2] = "ERROR", z[z.TRUE1 = 3] = "TRUE1", z[z.TRUE2 = 4] = "TRUE2", z[z.TRUE3 = 5] = "TRUE3", z[z.FALSE1 = 6] = "FALSE1", z[z.FALSE2 = 7] = "FALSE2", z[z.FALSE3 = 8] = "FALSE3", z[z.FALSE4 = 9] = "FALSE4", z[z.NULL1 = 10] = "NULL1", z[z.NULL2 = 11] = "NULL2", z[z.NULL3 = 12] = "NULL3", z[z.STRING_DEFAULT = 13] = "STRING_DEFAULT", z[z.STRING_AFTER_BACKSLASH = 14] = "STRING_AFTER_BACKSLASH", z[z.STRING_UNICODE_DIGIT_1 = 15] = "STRING_UNICODE_DIGIT_1", z[z.STRING_UNICODE_DIGIT_2 = 16] = "STRING_UNICODE_DIGIT_2", z[z.STRING_UNICODE_DIGIT_3 = 17] = "STRING_UNICODE_DIGIT_3", z[z.STRING_UNICODE_DIGIT_4 = 18] = "STRING_UNICODE_DIGIT_4", z[z.STRING_INCOMPLETE_CHAR = 19] = "STRING_INCOMPLETE_CHAR", z[z.NUMBER_AFTER_INITIAL_MINUS = 20] = "NUMBER_AFTER_INITIAL_MINUS", z[z.NUMBER_AFTER_INITIAL_ZERO = 21] = "NUMBER_AFTER_INITIAL_ZERO", z[z.NUMBER_AFTER_INITIAL_NON_ZERO = 22] = "NUMBER_AFTER_INITIAL_NON_ZERO", z[z.NUMBER_AFTER_FULL_STOP = 23] = "NUMBER_AFTER_FULL_STOP", z[z.NUMBER_AFTER_DECIMAL = 24] = "NUMBER_AFTER_DECIMAL", z[z.NUMBER_AFTER_E = 25] = "NUMBER_AFTER_E", z[z.NUMBER_AFTER_E_AND_SIGN = 26] = "NUMBER_AFTER_E_AND_SIGN", z[z.NUMBER_AFTER_E_AND_DIGIT = 27] = "NUMBER_AFTER_E_AND_DIGIT", z[z.SEPARATOR = 28] = "SEPARATOR", z[z.BOM_OR_START = 29] = "BOM_OR_START", z[z.BOM = 30] = "BOM";
})(TokenizerStates || (TokenizerStates = {}));
var TokenParserMode;
(function(z) {
  z[z.OBJECT = 0] = "OBJECT", z[z.ARRAY = 1] = "ARRAY";
})(TokenParserMode || (TokenParserMode = {}));
var TokenParserState;
(function(z) {
  z[z.VALUE = 0] = "VALUE", z[z.KEY = 1] = "KEY", z[z.COLON = 2] = "COLON", z[z.COMMA = 3] = "COMMA", z[z.ENDED = 4] = "ENDED", z[z.ERROR = 5] = "ERROR", z[z.SEPARATOR = 6] = "SEPARATOR";
})(TokenParserState || (TokenParserState = {}));
const SPLIT_LOWER_UPPER_RE = new RegExp("([\\p{Ll}\\d])(\\p{Lu})", "gu"), SPLIT_UPPER_UPPER_RE = new RegExp("(\\p{Lu})([\\p{Lu}][\\p{Ll}])", "gu"), SPLIT_SEPARATE_NUMBER_RE = new RegExp("(\\d)\\p{Ll}|(\\p{L})\\d", "u"), DEFAULT_STRIP_REGEXP = /[^\p{L}\d]+/giu, SPLIT_REPLACE_VALUE = "$1\0$2", DEFAULT_PREFIX_SUFFIX_CHARACTERS = "";
function split(z) {
  let D = z.trim();
  D = D.replace(SPLIT_LOWER_UPPER_RE, SPLIT_REPLACE_VALUE).replace(SPLIT_UPPER_UPPER_RE, SPLIT_REPLACE_VALUE), D = D.replace(DEFAULT_STRIP_REGEXP, "\0");
  let O = 0, F = D.length;
  for (; D.charAt(O) === "\0"; )
    O++;
  if (O === F)
    return [];
  for (; D.charAt(F - 1) === "\0"; )
    F--;
  return D.slice(O, F).split(/\0/g);
}
function splitSeparateNumbers(z) {
  const D = split(z);
  for (let O = 0; O < D.length; O++) {
    const F = D[O], U = SPLIT_SEPARATE_NUMBER_RE.exec(F);
    if (U) {
      const W = U.index + (U[1] ?? U[2]).length;
      D.splice(O, 1, F.slice(0, W), F.slice(W));
    }
  }
  return D;
}
function noCase(z, D) {
  const [O, F, U] = splitPrefixSuffix(z, D);
  return O + F.map(lowerFactory(D == null ? void 0 : D.locale)).join((D == null ? void 0 : D.delimiter) ?? " ") + U;
}
function camelCase(z, D) {
  const [O, F, U] = splitPrefixSuffix(z, D), W = lowerFactory(D == null ? void 0 : D.locale), B = upperFactory(D == null ? void 0 : D.locale), K = D != null && D.mergeAmbiguousCharacters ? capitalCaseTransformFactory(W, B) : pascalCaseTransformFactory(W, B);
  return O + F.map((X, Y) => Y === 0 ? W(X) : K(X, Y)).join((D == null ? void 0 : D.delimiter) ?? "") + U;
}
function pascalCase(z, D) {
  const [O, F, U] = splitPrefixSuffix(z, D), W = lowerFactory(D == null ? void 0 : D.locale), B = upperFactory(D == null ? void 0 : D.locale), K = D != null && D.mergeAmbiguousCharacters ? capitalCaseTransformFactory(W, B) : pascalCaseTransformFactory(W, B);
  return O + F.map(K).join((D == null ? void 0 : D.delimiter) ?? "") + U;
}
function dotCase(z, D) {
  return noCase(z, { delimiter: ".", ...D });
}
function snakeCase(z, D) {
  return noCase(z, { delimiter: "_", ...D });
}
function lowerFactory(z) {
  return z === !1 ? (D) => D.toLowerCase() : (D) => D.toLocaleLowerCase(z);
}
function upperFactory(z) {
  return z === !1 ? (D) => D.toUpperCase() : (D) => D.toLocaleUpperCase(z);
}
function capitalCaseTransformFactory(z, D) {
  return (O) => `${D(O[0])}${z(O.slice(1))}`;
}
function pascalCaseTransformFactory(z, D) {
  return (O, F) => {
    const U = O[0];
    return (F > 0 && U >= "0" && U <= "9" ? "_" + U : D(U)) + z(O.slice(1));
  };
}
function splitPrefixSuffix(z, D = {}) {
  const O = D.split ?? (D.separateNumbers ? splitSeparateNumbers : split), F = D.prefixCharacters ?? DEFAULT_PREFIX_SUFFIX_CHARACTERS, U = D.suffixCharacters ?? DEFAULT_PREFIX_SUFFIX_CHARACTERS;
  let W = 0, B = z.length;
  for (; W < z.length; ) {
    const K = z.charAt(W);
    if (!F.includes(K))
      break;
    W++;
  }
  for (; B > W; ) {
    const K = B - 1, X = z.charAt(K);
    if (!U.includes(X))
      break;
    B = K;
  }
  return [
    z.slice(0, W),
    O(z.slice(W, B)),
    z.slice(B)
  ];
}
class ModelParser {
  constructor() {
  }
  // this function takes a model and a transformer
  // it searches through the values in the transformer and checks to see if the key exists in the model
  // if it does, then the models key is updated with the key from the transformer
  static deriveModel(D, O) {
    const F = {};
    for (const [U, W] of Object.entries(O))
      for (const B of W)
        D[B] && (F[U] = D[B]);
    return F;
  }
  static getKeyPermutations(D) {
    return [camelCase, snakeCase, dotCase, pascalCase].map((F) => F(D));
  }
  static keyTransformer(D) {
    return D.flatMap(ModelParser.getKeyPermutations);
  }
}
class VerificationParser extends ModelParser {
  static parse(D) {
    const O = {
      url: VerificationParser.keyTransformer(["src", "url", "AudioLink"]),
      tag: VerificationParser.keyTransformer(["tags", "tag", "label", "classification"])
    }, F = VerificationParser.deriveModel(D, O);
    return new Verification({
      subject: D,
      confirmed: !1,
      additionalTags: [],
      ...F
    });
  }
}
const lucideCircleHelp = `<!-- @license lucide-static v0.363.0 - ISC -->
<svg
  class="lucide lucide-circle-help"
  xmlns="http://www.w3.org/2000/svg"
  width="24"
  height="24"
  viewBox="0 0 24 24"
  fill="none"
  stroke="currentColor"
  stroke-width="2"
  stroke-linecap="round"
  stroke-linejoin="round"
>
  <circle cx="12" cy="12" r="10" />
  <path d="M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3" />
  <path d="M12 17h.01" />
</svg>
`;
var index = {
  schemeGroups: {
    sequential: ["BuGn", "BuPu", "GnBu", "OrRd", "PuBu", "PuBuGn", "PuRd", "RdPu", "YlGn", "YlGnBu", "YlOrBr", "YlOrRd"],
    singlehue: ["Blues", "Greens", "Greys", "Oranges", "Purples", "Reds"],
    diverging: ["BrBG", "PiYG", "PRGn", "PuOr", "RdBu", "RdGy", "RdYlBu", "RdYlGn", "Spectral"],
    qualitative: ["Accent", "Dark2", "Paired", "Pastel1", "Pastel2", "Set1", "Set2", "Set3"]
  },
  YlGn: {
    3: ["#f7fcb9", "#addd8e", "#31a354"],
    4: ["#ffffcc", "#c2e699", "#78c679", "#238443"],
    5: ["#ffffcc", "#c2e699", "#78c679", "#31a354", "#006837"],
    6: ["#ffffcc", "#d9f0a3", "#addd8e", "#78c679", "#31a354", "#006837"],
    7: ["#ffffcc", "#d9f0a3", "#addd8e", "#78c679", "#41ab5d", "#238443", "#005a32"],
    8: ["#ffffe5", "#f7fcb9", "#d9f0a3", "#addd8e", "#78c679", "#41ab5d", "#238443", "#005a32"],
    9: ["#ffffe5", "#f7fcb9", "#d9f0a3", "#addd8e", "#78c679", "#41ab5d", "#238443", "#006837", "#004529"]
  },
  YlGnBu: {
    3: ["#edf8b1", "#7fcdbb", "#2c7fb8"],
    4: ["#ffffcc", "#a1dab4", "#41b6c4", "#225ea8"],
    5: ["#ffffcc", "#a1dab4", "#41b6c4", "#2c7fb8", "#253494"],
    6: ["#ffffcc", "#c7e9b4", "#7fcdbb", "#41b6c4", "#2c7fb8", "#253494"],
    7: ["#ffffcc", "#c7e9b4", "#7fcdbb", "#41b6c4", "#1d91c0", "#225ea8", "#0c2c84"],
    8: ["#ffffd9", "#edf8b1", "#c7e9b4", "#7fcdbb", "#41b6c4", "#1d91c0", "#225ea8", "#0c2c84"],
    9: ["#ffffd9", "#edf8b1", "#c7e9b4", "#7fcdbb", "#41b6c4", "#1d91c0", "#225ea8", "#253494", "#081d58"]
  },
  GnBu: {
    3: ["#e0f3db", "#a8ddb5", "#43a2ca"],
    4: ["#f0f9e8", "#bae4bc", "#7bccc4", "#2b8cbe"],
    5: ["#f0f9e8", "#bae4bc", "#7bccc4", "#43a2ca", "#0868ac"],
    6: ["#f0f9e8", "#ccebc5", "#a8ddb5", "#7bccc4", "#43a2ca", "#0868ac"],
    7: ["#f0f9e8", "#ccebc5", "#a8ddb5", "#7bccc4", "#4eb3d3", "#2b8cbe", "#08589e"],
    8: ["#f7fcf0", "#e0f3db", "#ccebc5", "#a8ddb5", "#7bccc4", "#4eb3d3", "#2b8cbe", "#08589e"],
    9: ["#f7fcf0", "#e0f3db", "#ccebc5", "#a8ddb5", "#7bccc4", "#4eb3d3", "#2b8cbe", "#0868ac", "#084081"]
  },
  BuGn: {
    3: ["#e5f5f9", "#99d8c9", "#2ca25f"],
    4: ["#edf8fb", "#b2e2e2", "#66c2a4", "#238b45"],
    5: ["#edf8fb", "#b2e2e2", "#66c2a4", "#2ca25f", "#006d2c"],
    6: ["#edf8fb", "#ccece6", "#99d8c9", "#66c2a4", "#2ca25f", "#006d2c"],
    7: ["#edf8fb", "#ccece6", "#99d8c9", "#66c2a4", "#41ae76", "#238b45", "#005824"],
    8: ["#f7fcfd", "#e5f5f9", "#ccece6", "#99d8c9", "#66c2a4", "#41ae76", "#238b45", "#005824"],
    9: ["#f7fcfd", "#e5f5f9", "#ccece6", "#99d8c9", "#66c2a4", "#41ae76", "#238b45", "#006d2c", "#00441b"]
  },
  PuBuGn: {
    3: ["#ece2f0", "#a6bddb", "#1c9099"],
    4: ["#f6eff7", "#bdc9e1", "#67a9cf", "#02818a"],
    5: ["#f6eff7", "#bdc9e1", "#67a9cf", "#1c9099", "#016c59"],
    6: ["#f6eff7", "#d0d1e6", "#a6bddb", "#67a9cf", "#1c9099", "#016c59"],
    7: ["#f6eff7", "#d0d1e6", "#a6bddb", "#67a9cf", "#3690c0", "#02818a", "#016450"],
    8: ["#fff7fb", "#ece2f0", "#d0d1e6", "#a6bddb", "#67a9cf", "#3690c0", "#02818a", "#016450"],
    9: ["#fff7fb", "#ece2f0", "#d0d1e6", "#a6bddb", "#67a9cf", "#3690c0", "#02818a", "#016c59", "#014636"]
  },
  PuBu: {
    3: ["#ece7f2", "#a6bddb", "#2b8cbe"],
    4: ["#f1eef6", "#bdc9e1", "#74a9cf", "#0570b0"],
    5: ["#f1eef6", "#bdc9e1", "#74a9cf", "#2b8cbe", "#045a8d"],
    6: ["#f1eef6", "#d0d1e6", "#a6bddb", "#74a9cf", "#2b8cbe", "#045a8d"],
    7: ["#f1eef6", "#d0d1e6", "#a6bddb", "#74a9cf", "#3690c0", "#0570b0", "#034e7b"],
    8: ["#fff7fb", "#ece7f2", "#d0d1e6", "#a6bddb", "#74a9cf", "#3690c0", "#0570b0", "#034e7b"],
    9: ["#fff7fb", "#ece7f2", "#d0d1e6", "#a6bddb", "#74a9cf", "#3690c0", "#0570b0", "#045a8d", "#023858"]
  },
  BuPu: {
    3: ["#e0ecf4", "#9ebcda", "#8856a7"],
    4: ["#edf8fb", "#b3cde3", "#8c96c6", "#88419d"],
    5: ["#edf8fb", "#b3cde3", "#8c96c6", "#8856a7", "#810f7c"],
    6: ["#edf8fb", "#bfd3e6", "#9ebcda", "#8c96c6", "#8856a7", "#810f7c"],
    7: ["#edf8fb", "#bfd3e6", "#9ebcda", "#8c96c6", "#8c6bb1", "#88419d", "#6e016b"],
    8: ["#f7fcfd", "#e0ecf4", "#bfd3e6", "#9ebcda", "#8c96c6", "#8c6bb1", "#88419d", "#6e016b"],
    9: ["#f7fcfd", "#e0ecf4", "#bfd3e6", "#9ebcda", "#8c96c6", "#8c6bb1", "#88419d", "#810f7c", "#4d004b"]
  },
  RdPu: {
    3: ["#fde0dd", "#fa9fb5", "#c51b8a"],
    4: ["#feebe2", "#fbb4b9", "#f768a1", "#ae017e"],
    5: ["#feebe2", "#fbb4b9", "#f768a1", "#c51b8a", "#7a0177"],
    6: ["#feebe2", "#fcc5c0", "#fa9fb5", "#f768a1", "#c51b8a", "#7a0177"],
    7: ["#feebe2", "#fcc5c0", "#fa9fb5", "#f768a1", "#dd3497", "#ae017e", "#7a0177"],
    8: ["#fff7f3", "#fde0dd", "#fcc5c0", "#fa9fb5", "#f768a1", "#dd3497", "#ae017e", "#7a0177"],
    9: ["#fff7f3", "#fde0dd", "#fcc5c0", "#fa9fb5", "#f768a1", "#dd3497", "#ae017e", "#7a0177", "#49006a"]
  },
  PuRd: {
    3: ["#e7e1ef", "#c994c7", "#dd1c77"],
    4: ["#f1eef6", "#d7b5d8", "#df65b0", "#ce1256"],
    5: ["#f1eef6", "#d7b5d8", "#df65b0", "#dd1c77", "#980043"],
    6: ["#f1eef6", "#d4b9da", "#c994c7", "#df65b0", "#dd1c77", "#980043"],
    7: ["#f1eef6", "#d4b9da", "#c994c7", "#df65b0", "#e7298a", "#ce1256", "#91003f"],
    8: ["#f7f4f9", "#e7e1ef", "#d4b9da", "#c994c7", "#df65b0", "#e7298a", "#ce1256", "#91003f"],
    9: ["#f7f4f9", "#e7e1ef", "#d4b9da", "#c994c7", "#df65b0", "#e7298a", "#ce1256", "#980043", "#67001f"]
  },
  OrRd: {
    3: ["#fee8c8", "#fdbb84", "#e34a33"],
    4: ["#fef0d9", "#fdcc8a", "#fc8d59", "#d7301f"],
    5: ["#fef0d9", "#fdcc8a", "#fc8d59", "#e34a33", "#b30000"],
    6: ["#fef0d9", "#fdd49e", "#fdbb84", "#fc8d59", "#e34a33", "#b30000"],
    7: ["#fef0d9", "#fdd49e", "#fdbb84", "#fc8d59", "#ef6548", "#d7301f", "#990000"],
    8: ["#fff7ec", "#fee8c8", "#fdd49e", "#fdbb84", "#fc8d59", "#ef6548", "#d7301f", "#990000"],
    9: ["#fff7ec", "#fee8c8", "#fdd49e", "#fdbb84", "#fc8d59", "#ef6548", "#d7301f", "#b30000", "#7f0000"]
  },
  YlOrRd: {
    3: ["#ffeda0", "#feb24c", "#f03b20"],
    4: ["#ffffb2", "#fecc5c", "#fd8d3c", "#e31a1c"],
    5: ["#ffffb2", "#fecc5c", "#fd8d3c", "#f03b20", "#bd0026"],
    6: ["#ffffb2", "#fed976", "#feb24c", "#fd8d3c", "#f03b20", "#bd0026"],
    7: ["#ffffb2", "#fed976", "#feb24c", "#fd8d3c", "#fc4e2a", "#e31a1c", "#b10026"],
    8: ["#ffffcc", "#ffeda0", "#fed976", "#feb24c", "#fd8d3c", "#fc4e2a", "#e31a1c", "#b10026"],
    9: ["#ffffcc", "#ffeda0", "#fed976", "#feb24c", "#fd8d3c", "#fc4e2a", "#e31a1c", "#bd0026", "#800026"]
  },
  YlOrBr: {
    3: ["#fff7bc", "#fec44f", "#d95f0e"],
    4: ["#ffffd4", "#fed98e", "#fe9929", "#cc4c02"],
    5: ["#ffffd4", "#fed98e", "#fe9929", "#d95f0e", "#993404"],
    6: ["#ffffd4", "#fee391", "#fec44f", "#fe9929", "#d95f0e", "#993404"],
    7: ["#ffffd4", "#fee391", "#fec44f", "#fe9929", "#ec7014", "#cc4c02", "#8c2d04"],
    8: ["#ffffe5", "#fff7bc", "#fee391", "#fec44f", "#fe9929", "#ec7014", "#cc4c02", "#8c2d04"],
    9: ["#ffffe5", "#fff7bc", "#fee391", "#fec44f", "#fe9929", "#ec7014", "#cc4c02", "#993404", "#662506"]
  },
  Purples: {
    3: ["#efedf5", "#bcbddc", "#756bb1"],
    4: ["#f2f0f7", "#cbc9e2", "#9e9ac8", "#6a51a3"],
    5: ["#f2f0f7", "#cbc9e2", "#9e9ac8", "#756bb1", "#54278f"],
    6: ["#f2f0f7", "#dadaeb", "#bcbddc", "#9e9ac8", "#756bb1", "#54278f"],
    7: ["#f2f0f7", "#dadaeb", "#bcbddc", "#9e9ac8", "#807dba", "#6a51a3", "#4a1486"],
    8: ["#fcfbfd", "#efedf5", "#dadaeb", "#bcbddc", "#9e9ac8", "#807dba", "#6a51a3", "#4a1486"],
    9: ["#fcfbfd", "#efedf5", "#dadaeb", "#bcbddc", "#9e9ac8", "#807dba", "#6a51a3", "#54278f", "#3f007d"]
  },
  Blues: {
    3: ["#deebf7", "#9ecae1", "#3182bd"],
    4: ["#eff3ff", "#bdd7e7", "#6baed6", "#2171b5"],
    5: ["#eff3ff", "#bdd7e7", "#6baed6", "#3182bd", "#08519c"],
    6: ["#eff3ff", "#c6dbef", "#9ecae1", "#6baed6", "#3182bd", "#08519c"],
    7: ["#eff3ff", "#c6dbef", "#9ecae1", "#6baed6", "#4292c6", "#2171b5", "#084594"],
    8: ["#f7fbff", "#deebf7", "#c6dbef", "#9ecae1", "#6baed6", "#4292c6", "#2171b5", "#084594"],
    9: ["#f7fbff", "#deebf7", "#c6dbef", "#9ecae1", "#6baed6", "#4292c6", "#2171b5", "#08519c", "#08306b"]
  },
  Greens: {
    3: ["#e5f5e0", "#a1d99b", "#31a354"],
    4: ["#edf8e9", "#bae4b3", "#74c476", "#238b45"],
    5: ["#edf8e9", "#bae4b3", "#74c476", "#31a354", "#006d2c"],
    6: ["#edf8e9", "#c7e9c0", "#a1d99b", "#74c476", "#31a354", "#006d2c"],
    7: ["#edf8e9", "#c7e9c0", "#a1d99b", "#74c476", "#41ab5d", "#238b45", "#005a32"],
    8: ["#f7fcf5", "#e5f5e0", "#c7e9c0", "#a1d99b", "#74c476", "#41ab5d", "#238b45", "#005a32"],
    9: ["#f7fcf5", "#e5f5e0", "#c7e9c0", "#a1d99b", "#74c476", "#41ab5d", "#238b45", "#006d2c", "#00441b"]
  },
  Oranges: {
    3: ["#fee6ce", "#fdae6b", "#e6550d"],
    4: ["#feedde", "#fdbe85", "#fd8d3c", "#d94701"],
    5: ["#feedde", "#fdbe85", "#fd8d3c", "#e6550d", "#a63603"],
    6: ["#feedde", "#fdd0a2", "#fdae6b", "#fd8d3c", "#e6550d", "#a63603"],
    7: ["#feedde", "#fdd0a2", "#fdae6b", "#fd8d3c", "#f16913", "#d94801", "#8c2d04"],
    8: ["#fff5eb", "#fee6ce", "#fdd0a2", "#fdae6b", "#fd8d3c", "#f16913", "#d94801", "#8c2d04"],
    9: ["#fff5eb", "#fee6ce", "#fdd0a2", "#fdae6b", "#fd8d3c", "#f16913", "#d94801", "#a63603", "#7f2704"]
  },
  Reds: {
    3: ["#fee0d2", "#fc9272", "#de2d26"],
    4: ["#fee5d9", "#fcae91", "#fb6a4a", "#cb181d"],
    5: ["#fee5d9", "#fcae91", "#fb6a4a", "#de2d26", "#a50f15"],
    6: ["#fee5d9", "#fcbba1", "#fc9272", "#fb6a4a", "#de2d26", "#a50f15"],
    7: ["#fee5d9", "#fcbba1", "#fc9272", "#fb6a4a", "#ef3b2c", "#cb181d", "#99000d"],
    8: ["#fff5f0", "#fee0d2", "#fcbba1", "#fc9272", "#fb6a4a", "#ef3b2c", "#cb181d", "#99000d"],
    9: ["#fff5f0", "#fee0d2", "#fcbba1", "#fc9272", "#fb6a4a", "#ef3b2c", "#cb181d", "#a50f15", "#67000d"]
  },
  Greys: {
    3: ["#f0f0f0", "#bdbdbd", "#636363"],
    4: ["#f7f7f7", "#cccccc", "#969696", "#525252"],
    5: ["#f7f7f7", "#cccccc", "#969696", "#636363", "#252525"],
    6: ["#f7f7f7", "#d9d9d9", "#bdbdbd", "#969696", "#636363", "#252525"],
    7: ["#f7f7f7", "#d9d9d9", "#bdbdbd", "#969696", "#737373", "#525252", "#252525"],
    8: ["#ffffff", "#f0f0f0", "#d9d9d9", "#bdbdbd", "#969696", "#737373", "#525252", "#252525"],
    9: ["#ffffff", "#f0f0f0", "#d9d9d9", "#bdbdbd", "#969696", "#737373", "#525252", "#252525", "#000000"]
  },
  PuOr: {
    3: ["#f1a340", "#f7f7f7", "#998ec3"],
    4: ["#e66101", "#fdb863", "#b2abd2", "#5e3c99"],
    5: ["#e66101", "#fdb863", "#f7f7f7", "#b2abd2", "#5e3c99"],
    6: ["#b35806", "#f1a340", "#fee0b6", "#d8daeb", "#998ec3", "#542788"],
    7: ["#b35806", "#f1a340", "#fee0b6", "#f7f7f7", "#d8daeb", "#998ec3", "#542788"],
    8: ["#b35806", "#e08214", "#fdb863", "#fee0b6", "#d8daeb", "#b2abd2", "#8073ac", "#542788"],
    9: ["#b35806", "#e08214", "#fdb863", "#fee0b6", "#f7f7f7", "#d8daeb", "#b2abd2", "#8073ac", "#542788"],
    10: ["#7f3b08", "#b35806", "#e08214", "#fdb863", "#fee0b6", "#d8daeb", "#b2abd2", "#8073ac", "#542788", "#2d004b"],
    11: ["#7f3b08", "#b35806", "#e08214", "#fdb863", "#fee0b6", "#f7f7f7", "#d8daeb", "#b2abd2", "#8073ac", "#542788", "#2d004b"]
  },
  BrBG: {
    3: ["#d8b365", "#f5f5f5", "#5ab4ac"],
    4: ["#a6611a", "#dfc27d", "#80cdc1", "#018571"],
    5: ["#a6611a", "#dfc27d", "#f5f5f5", "#80cdc1", "#018571"],
    6: ["#8c510a", "#d8b365", "#f6e8c3", "#c7eae5", "#5ab4ac", "#01665e"],
    7: ["#8c510a", "#d8b365", "#f6e8c3", "#f5f5f5", "#c7eae5", "#5ab4ac", "#01665e"],
    8: ["#8c510a", "#bf812d", "#dfc27d", "#f6e8c3", "#c7eae5", "#80cdc1", "#35978f", "#01665e"],
    9: ["#8c510a", "#bf812d", "#dfc27d", "#f6e8c3", "#f5f5f5", "#c7eae5", "#80cdc1", "#35978f", "#01665e"],
    10: ["#543005", "#8c510a", "#bf812d", "#dfc27d", "#f6e8c3", "#c7eae5", "#80cdc1", "#35978f", "#01665e", "#003c30"],
    11: ["#543005", "#8c510a", "#bf812d", "#dfc27d", "#f6e8c3", "#f5f5f5", "#c7eae5", "#80cdc1", "#35978f", "#01665e", "#003c30"]
  },
  PRGn: {
    3: ["#af8dc3", "#f7f7f7", "#7fbf7b"],
    4: ["#7b3294", "#c2a5cf", "#a6dba0", "#008837"],
    5: ["#7b3294", "#c2a5cf", "#f7f7f7", "#a6dba0", "#008837"],
    6: ["#762a83", "#af8dc3", "#e7d4e8", "#d9f0d3", "#7fbf7b", "#1b7837"],
    7: ["#762a83", "#af8dc3", "#e7d4e8", "#f7f7f7", "#d9f0d3", "#7fbf7b", "#1b7837"],
    8: ["#762a83", "#9970ab", "#c2a5cf", "#e7d4e8", "#d9f0d3", "#a6dba0", "#5aae61", "#1b7837"],
    9: ["#762a83", "#9970ab", "#c2a5cf", "#e7d4e8", "#f7f7f7", "#d9f0d3", "#a6dba0", "#5aae61", "#1b7837"],
    10: ["#40004b", "#762a83", "#9970ab", "#c2a5cf", "#e7d4e8", "#d9f0d3", "#a6dba0", "#5aae61", "#1b7837", "#00441b"],
    11: ["#40004b", "#762a83", "#9970ab", "#c2a5cf", "#e7d4e8", "#f7f7f7", "#d9f0d3", "#a6dba0", "#5aae61", "#1b7837", "#00441b"]
  },
  PiYG: {
    3: ["#e9a3c9", "#f7f7f7", "#a1d76a"],
    4: ["#d01c8b", "#f1b6da", "#b8e186", "#4dac26"],
    5: ["#d01c8b", "#f1b6da", "#f7f7f7", "#b8e186", "#4dac26"],
    6: ["#c51b7d", "#e9a3c9", "#fde0ef", "#e6f5d0", "#a1d76a", "#4d9221"],
    7: ["#c51b7d", "#e9a3c9", "#fde0ef", "#f7f7f7", "#e6f5d0", "#a1d76a", "#4d9221"],
    8: ["#c51b7d", "#de77ae", "#f1b6da", "#fde0ef", "#e6f5d0", "#b8e186", "#7fbc41", "#4d9221"],
    9: ["#c51b7d", "#de77ae", "#f1b6da", "#fde0ef", "#f7f7f7", "#e6f5d0", "#b8e186", "#7fbc41", "#4d9221"],
    10: ["#8e0152", "#c51b7d", "#de77ae", "#f1b6da", "#fde0ef", "#e6f5d0", "#b8e186", "#7fbc41", "#4d9221", "#276419"],
    11: ["#8e0152", "#c51b7d", "#de77ae", "#f1b6da", "#fde0ef", "#f7f7f7", "#e6f5d0", "#b8e186", "#7fbc41", "#4d9221", "#276419"]
  },
  RdBu: {
    3: ["#ef8a62", "#f7f7f7", "#67a9cf"],
    4: ["#ca0020", "#f4a582", "#92c5de", "#0571b0"],
    5: ["#ca0020", "#f4a582", "#f7f7f7", "#92c5de", "#0571b0"],
    6: ["#b2182b", "#ef8a62", "#fddbc7", "#d1e5f0", "#67a9cf", "#2166ac"],
    7: ["#b2182b", "#ef8a62", "#fddbc7", "#f7f7f7", "#d1e5f0", "#67a9cf", "#2166ac"],
    8: ["#b2182b", "#d6604d", "#f4a582", "#fddbc7", "#d1e5f0", "#92c5de", "#4393c3", "#2166ac"],
    9: ["#b2182b", "#d6604d", "#f4a582", "#fddbc7", "#f7f7f7", "#d1e5f0", "#92c5de", "#4393c3", "#2166ac"],
    10: ["#67001f", "#b2182b", "#d6604d", "#f4a582", "#fddbc7", "#d1e5f0", "#92c5de", "#4393c3", "#2166ac", "#053061"],
    11: ["#67001f", "#b2182b", "#d6604d", "#f4a582", "#fddbc7", "#f7f7f7", "#d1e5f0", "#92c5de", "#4393c3", "#2166ac", "#053061"]
  },
  RdGy: {
    3: ["#ef8a62", "#ffffff", "#999999"],
    4: ["#ca0020", "#f4a582", "#bababa", "#404040"],
    5: ["#ca0020", "#f4a582", "#ffffff", "#bababa", "#404040"],
    6: ["#b2182b", "#ef8a62", "#fddbc7", "#e0e0e0", "#999999", "#4d4d4d"],
    7: ["#b2182b", "#ef8a62", "#fddbc7", "#ffffff", "#e0e0e0", "#999999", "#4d4d4d"],
    8: ["#b2182b", "#d6604d", "#f4a582", "#fddbc7", "#e0e0e0", "#bababa", "#878787", "#4d4d4d"],
    9: ["#b2182b", "#d6604d", "#f4a582", "#fddbc7", "#ffffff", "#e0e0e0", "#bababa", "#878787", "#4d4d4d"],
    10: ["#67001f", "#b2182b", "#d6604d", "#f4a582", "#fddbc7", "#e0e0e0", "#bababa", "#878787", "#4d4d4d", "#1a1a1a"],
    11: ["#67001f", "#b2182b", "#d6604d", "#f4a582", "#fddbc7", "#ffffff", "#e0e0e0", "#bababa", "#878787", "#4d4d4d", "#1a1a1a"]
  },
  RdYlBu: {
    3: ["#fc8d59", "#ffffbf", "#91bfdb"],
    4: ["#d7191c", "#fdae61", "#abd9e9", "#2c7bb6"],
    5: ["#d7191c", "#fdae61", "#ffffbf", "#abd9e9", "#2c7bb6"],
    6: ["#d73027", "#fc8d59", "#fee090", "#e0f3f8", "#91bfdb", "#4575b4"],
    7: ["#d73027", "#fc8d59", "#fee090", "#ffffbf", "#e0f3f8", "#91bfdb", "#4575b4"],
    8: ["#d73027", "#f46d43", "#fdae61", "#fee090", "#e0f3f8", "#abd9e9", "#74add1", "#4575b4"],
    9: ["#d73027", "#f46d43", "#fdae61", "#fee090", "#ffffbf", "#e0f3f8", "#abd9e9", "#74add1", "#4575b4"],
    10: ["#a50026", "#d73027", "#f46d43", "#fdae61", "#fee090", "#e0f3f8", "#abd9e9", "#74add1", "#4575b4", "#313695"],
    11: ["#a50026", "#d73027", "#f46d43", "#fdae61", "#fee090", "#ffffbf", "#e0f3f8", "#abd9e9", "#74add1", "#4575b4", "#313695"]
  },
  Spectral: {
    3: ["#fc8d59", "#ffffbf", "#99d594"],
    4: ["#d7191c", "#fdae61", "#abdda4", "#2b83ba"],
    5: ["#d7191c", "#fdae61", "#ffffbf", "#abdda4", "#2b83ba"],
    6: ["#d53e4f", "#fc8d59", "#fee08b", "#e6f598", "#99d594", "#3288bd"],
    7: ["#d53e4f", "#fc8d59", "#fee08b", "#ffffbf", "#e6f598", "#99d594", "#3288bd"],
    8: ["#d53e4f", "#f46d43", "#fdae61", "#fee08b", "#e6f598", "#abdda4", "#66c2a5", "#3288bd"],
    9: ["#d53e4f", "#f46d43", "#fdae61", "#fee08b", "#ffffbf", "#e6f598", "#abdda4", "#66c2a5", "#3288bd"],
    10: ["#9e0142", "#d53e4f", "#f46d43", "#fdae61", "#fee08b", "#e6f598", "#abdda4", "#66c2a5", "#3288bd", "#5e4fa2"],
    11: ["#9e0142", "#d53e4f", "#f46d43", "#fdae61", "#fee08b", "#ffffbf", "#e6f598", "#abdda4", "#66c2a5", "#3288bd", "#5e4fa2"]
  },
  RdYlGn: {
    3: ["#fc8d59", "#ffffbf", "#91cf60"],
    4: ["#d7191c", "#fdae61", "#a6d96a", "#1a9641"],
    5: ["#d7191c", "#fdae61", "#ffffbf", "#a6d96a", "#1a9641"],
    6: ["#d73027", "#fc8d59", "#fee08b", "#d9ef8b", "#91cf60", "#1a9850"],
    7: ["#d73027", "#fc8d59", "#fee08b", "#ffffbf", "#d9ef8b", "#91cf60", "#1a9850"],
    8: ["#d73027", "#f46d43", "#fdae61", "#fee08b", "#d9ef8b", "#a6d96a", "#66bd63", "#1a9850"],
    9: ["#d73027", "#f46d43", "#fdae61", "#fee08b", "#ffffbf", "#d9ef8b", "#a6d96a", "#66bd63", "#1a9850"],
    10: ["#a50026", "#d73027", "#f46d43", "#fdae61", "#fee08b", "#d9ef8b", "#a6d96a", "#66bd63", "#1a9850", "#006837"],
    11: ["#a50026", "#d73027", "#f46d43", "#fdae61", "#fee08b", "#ffffbf", "#d9ef8b", "#a6d96a", "#66bd63", "#1a9850", "#006837"]
  },
  Accent: {
    3: ["#7fc97f", "#beaed4", "#fdc086"],
    4: ["#7fc97f", "#beaed4", "#fdc086", "#ffff99"],
    5: ["#7fc97f", "#beaed4", "#fdc086", "#ffff99", "#386cb0"],
    6: ["#7fc97f", "#beaed4", "#fdc086", "#ffff99", "#386cb0", "#f0027f"],
    7: ["#7fc97f", "#beaed4", "#fdc086", "#ffff99", "#386cb0", "#f0027f", "#bf5b17"],
    8: ["#7fc97f", "#beaed4", "#fdc086", "#ffff99", "#386cb0", "#f0027f", "#bf5b17", "#666666"]
  },
  Dark2: {
    3: ["#1b9e77", "#d95f02", "#7570b3"],
    4: ["#1b9e77", "#d95f02", "#7570b3", "#e7298a"],
    5: ["#1b9e77", "#d95f02", "#7570b3", "#e7298a", "#66a61e"],
    6: ["#1b9e77", "#d95f02", "#7570b3", "#e7298a", "#66a61e", "#e6ab02"],
    7: ["#1b9e77", "#d95f02", "#7570b3", "#e7298a", "#66a61e", "#e6ab02", "#a6761d"],
    8: ["#1b9e77", "#d95f02", "#7570b3", "#e7298a", "#66a61e", "#e6ab02", "#a6761d", "#666666"]
  },
  Paired: {
    3: ["#a6cee3", "#1f78b4", "#b2df8a"],
    4: ["#a6cee3", "#1f78b4", "#b2df8a", "#33a02c"],
    5: ["#a6cee3", "#1f78b4", "#b2df8a", "#33a02c", "#fb9a99"],
    6: ["#a6cee3", "#1f78b4", "#b2df8a", "#33a02c", "#fb9a99", "#e31a1c"],
    7: ["#a6cee3", "#1f78b4", "#b2df8a", "#33a02c", "#fb9a99", "#e31a1c", "#fdbf6f"],
    8: ["#a6cee3", "#1f78b4", "#b2df8a", "#33a02c", "#fb9a99", "#e31a1c", "#fdbf6f", "#ff7f00"],
    9: ["#a6cee3", "#1f78b4", "#b2df8a", "#33a02c", "#fb9a99", "#e31a1c", "#fdbf6f", "#ff7f00", "#cab2d6"],
    10: ["#a6cee3", "#1f78b4", "#b2df8a", "#33a02c", "#fb9a99", "#e31a1c", "#fdbf6f", "#ff7f00", "#cab2d6", "#6a3d9a"],
    11: ["#a6cee3", "#1f78b4", "#b2df8a", "#33a02c", "#fb9a99", "#e31a1c", "#fdbf6f", "#ff7f00", "#cab2d6", "#6a3d9a", "#ffff99"],
    12: ["#a6cee3", "#1f78b4", "#b2df8a", "#33a02c", "#fb9a99", "#e31a1c", "#fdbf6f", "#ff7f00", "#cab2d6", "#6a3d9a", "#ffff99", "#b15928"]
  },
  Pastel1: {
    3: ["#fbb4ae", "#b3cde3", "#ccebc5"],
    4: ["#fbb4ae", "#b3cde3", "#ccebc5", "#decbe4"],
    5: ["#fbb4ae", "#b3cde3", "#ccebc5", "#decbe4", "#fed9a6"],
    6: ["#fbb4ae", "#b3cde3", "#ccebc5", "#decbe4", "#fed9a6", "#ffffcc"],
    7: ["#fbb4ae", "#b3cde3", "#ccebc5", "#decbe4", "#fed9a6", "#ffffcc", "#e5d8bd"],
    8: ["#fbb4ae", "#b3cde3", "#ccebc5", "#decbe4", "#fed9a6", "#ffffcc", "#e5d8bd", "#fddaec"],
    9: ["#fbb4ae", "#b3cde3", "#ccebc5", "#decbe4", "#fed9a6", "#ffffcc", "#e5d8bd", "#fddaec", "#f2f2f2"]
  },
  Pastel2: {
    3: ["#b3e2cd", "#fdcdac", "#cbd5e8"],
    4: ["#b3e2cd", "#fdcdac", "#cbd5e8", "#f4cae4"],
    5: ["#b3e2cd", "#fdcdac", "#cbd5e8", "#f4cae4", "#e6f5c9"],
    6: ["#b3e2cd", "#fdcdac", "#cbd5e8", "#f4cae4", "#e6f5c9", "#fff2ae"],
    7: ["#b3e2cd", "#fdcdac", "#cbd5e8", "#f4cae4", "#e6f5c9", "#fff2ae", "#f1e2cc"],
    8: ["#b3e2cd", "#fdcdac", "#cbd5e8", "#f4cae4", "#e6f5c9", "#fff2ae", "#f1e2cc", "#cccccc"]
  },
  Set1: {
    3: ["#e41a1c", "#377eb8", "#4daf4a"],
    4: ["#e41a1c", "#377eb8", "#4daf4a", "#984ea3"],
    5: ["#e41a1c", "#377eb8", "#4daf4a", "#984ea3", "#ff7f00"],
    6: ["#e41a1c", "#377eb8", "#4daf4a", "#984ea3", "#ff7f00", "#ffff33"],
    7: ["#e41a1c", "#377eb8", "#4daf4a", "#984ea3", "#ff7f00", "#ffff33", "#a65628"],
    8: ["#e41a1c", "#377eb8", "#4daf4a", "#984ea3", "#ff7f00", "#ffff33", "#a65628", "#f781bf"],
    9: ["#e41a1c", "#377eb8", "#4daf4a", "#984ea3", "#ff7f00", "#ffff33", "#a65628", "#f781bf", "#999999"]
  },
  Set2: {
    3: ["#66c2a5", "#fc8d62", "#8da0cb"],
    4: ["#66c2a5", "#fc8d62", "#8da0cb", "#e78ac3"],
    5: ["#66c2a5", "#fc8d62", "#8da0cb", "#e78ac3", "#a6d854"],
    6: ["#66c2a5", "#fc8d62", "#8da0cb", "#e78ac3", "#a6d854", "#ffd92f"],
    7: ["#66c2a5", "#fc8d62", "#8da0cb", "#e78ac3", "#a6d854", "#ffd92f", "#e5c494"],
    8: ["#66c2a5", "#fc8d62", "#8da0cb", "#e78ac3", "#a6d854", "#ffd92f", "#e5c494", "#b3b3b3"]
  },
  Set3: {
    3: ["#8dd3c7", "#ffffb3", "#bebada"],
    4: ["#8dd3c7", "#ffffb3", "#bebada", "#fb8072"],
    5: ["#8dd3c7", "#ffffb3", "#bebada", "#fb8072", "#80b1d3"],
    6: ["#8dd3c7", "#ffffb3", "#bebada", "#fb8072", "#80b1d3", "#fdb462"],
    7: ["#8dd3c7", "#ffffb3", "#bebada", "#fb8072", "#80b1d3", "#fdb462", "#b3de69"],
    8: ["#8dd3c7", "#ffffb3", "#bebada", "#fb8072", "#80b1d3", "#fdb462", "#b3de69", "#fccde5"],
    9: ["#8dd3c7", "#ffffb3", "#bebada", "#fb8072", "#80b1d3", "#fdb462", "#b3de69", "#fccde5", "#d9d9d9"],
    10: ["#8dd3c7", "#ffffb3", "#bebada", "#fb8072", "#80b1d3", "#fdb462", "#b3de69", "#fccde5", "#d9d9d9", "#bc80bd"],
    11: ["#8dd3c7", "#ffffb3", "#bebada", "#fb8072", "#80b1d3", "#fdb462", "#b3de69", "#fccde5", "#d9d9d9", "#bc80bd", "#ccebc5"],
    12: ["#8dd3c7", "#ffffb3", "#bebada", "#fb8072", "#80b1d3", "#fdb462", "#b3de69", "#fccde5", "#d9d9d9", "#bc80bd", "#ccebc5", "#ffed6f"]
  }
};
/**
 * @license
 * Copyright 2018 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const e$2 = e$7(class extends i$3 {
  constructor(z) {
    var D;
    if (super(z), z.type !== t$3.ATTRIBUTE || z.name !== "class" || ((D = z.strings) == null ? void 0 : D.length) > 2)
      throw Error("`classMap()` can only be used in the `class` attribute and must be the only part in the attribute.");
  }
  render(z) {
    return " " + Object.keys(z).filter((D) => z[D]).join(" ") + " ";
  }
  update(z, [D]) {
    var F, U;
    if (this.st === void 0) {
      this.st = /* @__PURE__ */ new Set(), z.strings !== void 0 && (this.nt = new Set(z.strings.join(" ").split(/\s/).filter((W) => W !== "")));
      for (const W in D)
        D[W] && !((F = this.nt) != null && F.has(W)) && this.st.add(W);
      return this.render(D);
    }
    const O = z.element.classList;
    for (const W of this.st)
      W in D || (O.remove(W), this.st.delete(W));
    for (const W in D) {
      const B = !!D[W];
      B === this.st.has(W) || (U = this.nt) != null && U.has(W) || (B ? (O.add(W), this.st.add(W)) : (O.remove(W), this.st.delete(W)));
    }
    return w$1;
  }
});
var __defProp$6 = Object.defineProperty, __getOwnPropDesc$6 = Object.getOwnPropertyDescriptor, __decorateClass$6 = (z, D, O, F) => {
  for (var U = F > 1 ? void 0 : F ? __getOwnPropDesc$6(D, O) : D, W = z.length - 1, B; W >= 0; W--)
    (B = z[W]) && (U = (F ? B(D, O, U) : B(U)) || U);
  return F && U && __defProp$6(D, O, U), U;
};
let VerificationGrid = class extends AbstractComponent(s$7) {
  constructor() {
    super(...arguments), this.gridSize = 8, this.pagedItems = 0, this.selectionBehavior = "default", this.autoPage = !0, this.historyHead = 0, this.decisions = [], this.undecidedTiles = [], this.hiddenTiles = 0, this.showingSelectionShortcuts = !1, this.keydownHandler = this.handleKeyDown.bind(this), this.keyupHandler = this.handleKeyUp.bind(this), this.blurHandler = this.handleWindowBlur.bind(this), this.intersectionHandler = this.handleIntersection.bind(this), this.intersectionObserver = new IntersectionObserver(this.intersectionHandler), this.multiSelectHead = null, this.serverCacheHead = this.gridSize, this.serverCacheExhausted = !1, this.highlighting = !1, this.highlight = {
      start: { x: 0, y: 0 },
      current: { x: 0, y: 0 },
      highlighting: !1,
      elements: []
    }, this.doneRenderBoxInit = !1;
  }
  connectedCallback() {
    super.connectedCallback(), document.addEventListener("keydown", this.keydownHandler), document.addEventListener("keyup", this.keyupHandler), window.addEventListener("blur", this.blurHandler);
  }
  disconnectedCallback() {
    this.intersectionObserver.disconnect(), document.removeEventListener("keydown", this.keydownHandler), document.removeEventListener("keyup", this.keyupHandler), window.removeEventListener("blur", this.blurHandler), super.disconnectedCallback();
  }
  firstUpdated() {
    this.helpDialog.decisionElements = this.decisionElements;
  }
  async updated(z) {
    var W;
    const D = ["gridSize", "audioKey", "dataSource"], O = this.gridTiles, F = ["getPage"];
    if (z.has("selectionBehavior")) {
      this.multiSelectHead = null;
      let B = this.selectionBehavior;
      B === "default" && (B = this.isTouchDevice() ? "tablet" : "desktop"), this.decisionElements.forEach((K) => {
        K.selectionMode = B;
      }), this.helpDialog.selectionBehavior = B;
    }
    const U = index.Dark2[8];
    if (this.decisionElements.forEach((B, K) => {
      const X = U[K];
      B.color = X;
    }), F.some((B) => z.has(B)) && (this.pagedItems = 0, this.decisions = [], this.verificationView(), (W = this.gridTiles) != null && W.length && await this.renderCurrentPage()), !O)
      throw new Error("Fatal error: No grid tiles found");
    for (const B of O)
      this.intersectionObserver.observe(B);
    D.some((B) => z.has(B)) && this.createSpectrogramElements(), z.has("pagedItems") && this.handlePagination();
  }
  handleKeyDown(z) {
    if (this.canSubSelect()) {
      if (!this.showingSelectionShortcuts && z.altKey) {
        this.showSelectionShortcuts();
        return;
      }
      if (z.ctrlKey && z.key === "a") {
        this.subSelectAll();
        return;
      }
      z.key === "Escape" && (this.removeSubSelection(), this.isViewingHistory() || this.removeDecisionButtonHighlight()), z.key === "ArrowLeft" && (z.preventDefault(), this.previousPage()), z.key === "ArrowRight" && (z.preventDefault(), this.pageForwardHistory());
    }
  }
  handleKeyUp(z) {
    z.preventDefault(), z.altKey || this.hideSelectionShortcuts();
  }
  // some keys add additional information to the screen
  // e.g. pressing Alt will show the selection keyboard shortcuts
  //
  // however, the alt key can also be used to switch virtual desktops in Windows
  // because of this, if the user switches virtual desktops, we never receive
  // the keyup event that is usually used to hide the additional information
  // therefore, we listen for the window blur event so that when the window
  // loses focus, we hide the additional information
  handleWindowBlur() {
    this.hideSelectionShortcuts(), this.isViewingHistory() || this.removeDecisionButtonHighlight();
  }
  /** A non-idempotent method that re-renders the current virtual page */
  async renderCurrentPage() {
    const D = (await this.getPage(this.pagedItems)).map(VerificationParser.parse);
    this.renderVirtualPage(D);
  }
  showSelectionShortcuts() {
    const z = this.gridTiles;
    for (const D of z)
      D.showKeyboardShortcuts = !0;
    this.showingSelectionShortcuts = !0;
  }
  hideSelectionShortcuts() {
    const z = this.gridTiles;
    for (const D of z)
      D.showKeyboardShortcuts = !1;
    this.showingSelectionShortcuts = !1;
  }
  handleIntersection(z) {
    for (const D of z)
      D.intersectionRatio < 1 && this.hiddenTiles + 1 < this.gridSize;
  }
  // we could improve the performance here by creating a "selectionHandler" component property
  // which is set to handleDesktopSelection.bind(this) or handleTabletSelection.bind(this)
  // when the selection-behavior attribute is updated
  // (meaning that we don't have to evaluate the switch statement every selection event)
  // however, I deemed that it hurt readability and the perf hit is negligible
  selectionHandler(z) {
    if (this.canSubSelect()) {
      switch (this.selectionBehavior) {
        case "default":
          this.handleDefaultSelection(z);
          break;
        case "desktop":
          this.handleDesktopSelection(z);
          break;
        case "tablet":
          this.handleTabletSelection(z);
          break;
        default:
          console.error(`could not find selection behavior ${this.selectionBehavior}`), this.handleDesktopSelection(z);
          break;
      }
      this.requestUpdate();
    }
  }
  canSubSelect() {
    return this.gridSize > 1;
  }
  /** @returns - True if the device is a touch device */
  isTouchDevice() {
    if (navigator.userAgentData)
      return navigator.userAgentData.mobile;
    throw new Error("Could not determine if the device is a touch device");
  }
  /**
   * @description
   * The default selection handler will infer the device type and
   * the selection behavior will be set to "tablet", otherwise it will be set
   * to "desktop"
   */
  handleDefaultSelection(z) {
    if (this.isTouchDevice()) {
      this.handleTabletSelection(z);
      return;
    }
    this.handleDesktopSelection(z);
  }
  /**
   * @description
   * Click                  Select a single tile (de-selecting any other items)
   * Shift + click          Select a range of tiles (de-selecting any other items)
   * Ctrl + click           Toggles the selection state of a single tile (not effecting other tiles)
   * Ctrl + Shift + click   Select a range of tiles (not effecting other tiles)
   */
  handleDesktopSelection(z) {
    const D = z.detail.index;
    if (z.detail.ctrlKey || this.removeSubSelection(), z.detail.shiftKey) {
      this.multiSelectHead ?? (this.multiSelectHead = D);
      const O = D;
      this.addSubSelectionRange(this.multiSelectHead, O);
      return;
    }
    this.toggleSubSelection(D), this.multiSelectHead = D;
  }
  /**
   * @description
   * _Click_ Toggle the selection of a single tile (not effecting other tiles)
   */
  handleTabletSelection(z) {
    this.toggleSubSelection(z.detail.index);
  }
  toggleSubSelection(z) {
    const D = Array.from(this.gridTiles);
    D[z].selected = !D[z].selected;
  }
  addSubSelectionRange(z, D) {
    const O = Array.from(this.gridTiles);
    D < z && ([z, D] = [D, z]);
    for (let F = z; F <= D; F++)
      O[F].selected = !0;
  }
  subSelectAll() {
    const z = this.gridTiles;
    for (const D of z)
      D.selected = !0;
  }
  removeSubSelection() {
    const z = this.gridTiles;
    for (const D of z)
      D.selected = !1;
  }
  isViewingHistory() {
    return this.historyHead !== 0;
  }
  canNavigatePrevious() {
    const z = this.decisions.length > 0, D = this.historyHead < this.decisions.length;
    return z && D;
  }
  canNavigateNext() {
    const z = !(this.hiddenTiles >= this.gridSize) && !this.autoPage, D = this.isViewingHistory() && this.historyHead > this.gridSize;
    return z || D;
  }
  previousPage() {
    this.canNavigatePrevious() && (this.historyHead += this.gridSize, this.renderHistory(this.historyHead));
  }
  pageForwardHistory() {
    this.canNavigateNext() && (this.historyHead -= this.gridSize, this.renderHistory(this.historyHead));
  }
  renderHistory(z) {
    const D = Math.max(0, this.decisions.length - z), O = Math.min(this.decisions.length, D + this.gridSize), F = this.decisions.slice(D, O);
    this.renderVirtualPage(F), F.forEach((U, W) => {
      const B = this.decisionColor(U);
      this.gridTiles[W].color = B;
    }), this.historyView();
  }
  // changes the verification grid to the "history mode" layout
  historyView() {
    this.showDecisionButtonHighlight();
  }
  // changes the verification grid to the "normal mode" layout
  verificationView() {
    this.historyHead = 0, this.removeSubSelection(), this.removeDecisionHighlight(), this.removeDecisionButtonHighlight();
  }
  /** Returns the user from viewing/verifying history back to seeing new results */
  resumeVerification() {
    this.renderCurrentPage(), this.verificationView();
  }
  async nextPage(z = this.gridSize) {
    this.removeSubSelection(), this.removeDecisionHighlight(), this.resetSpectrogramSettings(), this.pagedItems += z;
    const D = (await this.getPage(this.pagedItems)).map(VerificationParser.parse), O = this.undecidedTiles.map((B) => B.url), F = this.decisions.map((B) => B.url), U = D.filter(
      (B) => !O.includes(B.url) && !F.includes(B.url)
    ), W = [...this.undecidedTiles, ...U];
    this.renderVirtualPage(W);
  }
  async catchDecision(z) {
    const D = z.detail.value, O = z.detail.tag === "*" ? this.decisionElements.map((Q) => Q.tag).filter((Q) => Q !== "*") : [z.detail.tag], F = z.detail.additionalTags, U = Array.from(this.gridTiles), W = U.filter((Q) => Q.selected), B = W.length > 0, K = B ? W : U, X = K.map((Q) => Q.model), Y = [];
    for (const Q of O)
      for (const J of X)
        Y.push(
          new Verification({
            ...J,
            tag: { id: void 0, text: Q },
            confirmed: D,
            additionalTags: F ?? []
          })
        );
    if (this.undecidedTiles = [], B && (this.undecidedTiles = U.filter((Q) => !W.includes(Q)).map((Q) => Q.model)), this.isViewingHistory()) {
      this.decisions.filter(
        (J) => X.some((ee) => ee.url === J.url)
      ).forEach((J) => {
        J.confirmed = D, J.additionalTags = F, J.tag = { id: void 0, text: O[0] };
      }), this.createDecisionHighlight(K, z.detail.color);
      return;
    }
    this.decisions.push(...Y), this.dispatchEvent(new CustomEvent("decision-made", { detail: Y })), this.autoPage && (this.showDecisionButtonHighlight([z.target]), this.createDecisionHighlight(K, z.detail.color), await sleep(300), this.removeDecisionHighlight(K), this.nextPage(Y.length));
  }
  handlePagination() {
    this.decisions.length >= this.pagedItems;
  }
  handleNextPageClick() {
    if (this.isViewingHistory()) {
      this.pageForwardHistory();
      return;
    }
    if (this.autoPage) {
      this.nextPage();
      return;
    }
    throw new Error("Could not determine pagination strategy");
  }
  decisionColor(z) {
    const D = z.tag.text, O = z.additionalTags.toString(), F = z.confirmed, U = this.decisionElements.find((W) => {
      const B = W.tag === D, K = W.verified === F;
      if (O === "")
        return B && K;
      const X = W.additionalTags === O;
      return B && X && K;
    });
    if (!U)
      throw new Error("Could not find color to match decision");
    return U.color;
  }
  createDecisionHighlight(z, D) {
    z.forEach((O, F) => {
      const U = Array.isArray(D) ? D[F] : D;
      O.color = U;
    });
  }
  removeDecisionHighlight(z = Array.from(this.gridTiles)) {
    z.forEach((D) => {
      D.color = "var(--oe-panel-color)";
    }), this.removeDecisionButtonHighlight();
  }
  showDecisionButtonHighlight(z = this.decisionElements) {
    for (const D of z)
      D.showDecisionColor = !0;
  }
  removeDecisionButtonHighlight() {
    for (const z of this.decisionElements)
      z.showDecisionColor = !1;
  }
  resetSpectrogramSettings() {
    var z;
    for (const D of this.gridTiles)
      (z = D.spectrogram) == null || z.resetSettings();
  }
  async renderVirtualPage(z) {
    const D = this.gridTiles;
    if (D === void 0 || D.length === 0)
      throw new Error("Could not find instantiated spectrogram elements");
    z.length === 0 && (this.spectrogramElements = this.noItemsTemplate(), this.setDecisionDisabled(!0)), z.forEach((F, U) => {
      const W = D[U];
      W.model = F, W.index = U;
    });
    const O = D.length - z.length;
    O > 0 ? this.hideGridItems(O) : (this.showAllGridItems(), this.hiddenTiles = 0), this.cacheNext();
  }
  hideGridItems(z) {
    Array.from(this.gridTiles).slice(-z).forEach((O) => {
      O.style.position = "absolute", O.style.opacity = "0";
    }), this.hiddenTiles = z;
  }
  showAllGridItems() {
    for (const z of this.gridTiles)
      z.style.position = "inherit", z.style.opacity = "1";
  }
  async cacheClient(z) {
    const D = await this.getPage(z);
    if (D.length === 0)
      return;
    const O = D.map(VerificationParser.parse);
    await Promise.all(O.map((F) => fetch(F.url, { method: "GET" })));
  }
  async cacheServer(z) {
    for (; this.serverCacheHead < z; ) {
      const D = await this.getPage(this.serverCacheHead);
      if (D.length === 0) {
        this.serverCacheExhausted = !0;
        return;
      }
      const O = D.map(VerificationParser.parse);
      Promise.all(O.map((F) => fetch(F.url, { method: "HEAD" }))), this.serverCacheHead += D.length;
    }
  }
  cacheNext() {
    const z = this.pagedItems + this.gridSize, O = z + this.gridSize * 10;
    this.cacheClient(z), this.serverCacheExhausted || this.cacheServer(O);
  }
  areSpectrogramsLoaded() {
    return !Array.from(this.gridTiles).some((D) => !D.loaded);
  }
  handleSpectrogramLoaded() {
    const z = this.decisionElements[0].disabled, D = !this.areSpectrogramsLoaded();
    z !== D && this.setDecisionDisabled(D);
  }
  setDecisionDisabled(z) {
    this.decisionElements.forEach((D) => {
      D.disabled = z;
    });
  }
  createSpectrogramElements() {
    const z = [];
    for (let D = 0; D < this.gridSize; D++) {
      const O = this.gridItemTemplate.content.cloneNode(!0);
      z.push(
        x`<oe-verification-grid-tile @loaded="${this.handleSpectrogramLoaded}">
          ${O}
        </oe-verification-grid-tile>`
      );
    }
    this.spectrogramElements = z;
  }
  renderHighlightBox(z) {
    if (this.canSubSelect() && z.isPrimary) {
      this.highlighting = !0;
      const D = this.shadowRoot.getElementById("highlight-box");
      if (!D)
        return;
      this.doneRenderBoxInit || (this.gridTiles.forEach((O) => {
        this.highlight.elements.push({
          position: O.getBoundingClientRect(),
          element: O
        });
      }), this.doneRenderBoxInit = !0), D.style.display = "block", D.style.left = `${z.pageX}px`, D.style.top = `${z.pageY}px`, this.highlight.start = { x: z.pageX, y: z.pageY };
    }
  }
  resizeHighlightBox(z) {
    if (!this.highlighting)
      return;
    const D = this.shadowRoot.getElementById("highlight-box");
    if (!D)
      return;
    const { pageX: O, pageY: F } = z;
    this.highlight.current = { x: O, y: F };
    const U = this.highlight.current.x - this.highlight.start.x, W = this.highlight.current.y - this.highlight.start.y;
    D.style.width = `${Math.abs(U)}px`, D.style.height = `${Math.abs(W)}px`, U < 0 && (D.style.left = `${O}px`), W < 0 && (D.style.top = `${F}px`), this.calculateHighlightIntersection();
  }
  calculateHighlightIntersection() {
    const z = Math.min(this.highlight.start.x, this.highlight.current.x), D = Math.max(this.highlight.start.x, this.highlight.current.x), O = Math.min(this.highlight.start.y, this.highlight.current.y), F = Math.max(this.highlight.start.y, this.highlight.current.y);
    for (const U of this.highlight.elements) {
      const { top: W, bottom: B, left: K, right: X } = U.position, Y = U.element;
      K <= D && X >= z && W <= F && B >= O ? Y.selected = !0 : Y.selected = !1;
    }
    this.requestUpdate();
  }
  hideHighlightBox() {
    this.highlighting = !1;
    const z = this.shadowRoot.getElementById("highlight-box");
    z && (console.log("stop highlight"), z.style.width = "0px", z.style.height = "0px", z.style.top = "0px", z.style.left = "0px", z.style.display = "none");
  }
  canDownloadResults() {
    return this.decisions.length > 0;
  }
  // TODO: clean up this function
  // TODO: there is a "null" in additional tags (if none)
  downloadResults() {
    var X, Y;
    if (!((X = this.dataSource) != null && X.fileName))
      throw new Error("No input data source found");
    const z = "oe";
    let D = "";
    const O = ((Y = this.dataSource) == null ? void 0 : Y.fileType) ?? "json", F = this.decisions.map((Q) => {
      var ie;
      const J = Q.subject, ee = ((ie = Q.tag) == null ? void 0 : ie.text) ?? "", ae = Q.confirmed, re = Q.additionalTags;
      return {
        ...J,
        [`${z}-tag`]: ee,
        [`${z}-confirmed`]: ae,
        [`${z}-additional-tags`]: re
      };
    });
    O === "json" ? D = JSON.stringify(F) : O === "csv" && (D = new JSON2CSVParser().parse(F));
    const U = O === "json" ? "application/json" : "text/csv", W = new Blob([D], { type: U }), B = URL.createObjectURL(W), K = document.createElement("a");
    K.href = B, K.download = `verified-${this.dataSource.fileName}`, K.click(), URL.revokeObjectURL(B);
  }
  currentSubSelection() {
    return Array.from(this.gridTiles).filter((D) => D.selected).map((D) => D.model);
  }
  decisionPrompt() {
    const D = this.currentSubSelection().length, O = this.gridSize > 1;
    return D > 0 ? x`<p>Are all of the selected ${D} a</p>` : x`<p>${O ? "Are all of these a" : "Is the shown spectrogram a"}</p>`;
  }
  statisticsTemplate() {
    return x`
      <div class="statistics-section">
        <h2>Statistics</h2>
        <p><span>Validated Items</span>: ${this.pagedItems}</p>
      </div>
    `;
  }
  noItemsTemplate() {
    return x`
      <div class="no-items-message">
        <p>
          <strong>No un-validated results found</strong>
        </p>
        <p>All ${this.pagedItems} annotations are validated</p>
      </div>
    `;
  }
  render() {
    return x`
      <oe-verification-help-dialog></oe-verification-help-dialog>
      <div id="highlight-box" @mouseup="${this.hideHighlightBox}" @mousemove="${this.resizeHighlightBox}"></div>

      <div class="verification-container">
        <div
          @selected="${this.selectionHandler}"
          @pointerdown="${this.renderHighlightBox}"
          @pointerup="${this.hideHighlightBox}"
          @pointermove="${this.resizeHighlightBox}"
          class="verification-grid"
        >
          ${this.spectrogramElements}
        </div>

        <div class="verification-controls">
          <span class="decision-controls-left">
            <button @click="${() => this.helpDialog.showModal(!1)}" class="oe-btn-info" rel="help">
              ${o$9(lucideCircleHelp)}
            </button>

            <button
              class="oe-btn oe-btn-secondary"
              ?disabled="${!this.canNavigatePrevious()}"
              @click="${() => this.previousPage()}"
            >
              ${this.gridSize > 1 ? "Previous Page" : "Previous"}
            </button>

            <button
              class="oe-btn-secondary ${e$2({ hidden: this.autoPage && !this.isViewingHistory() })}"
              ?disabled="${!this.canNavigateNext()}"
              @click="${() => this.handleNextPageClick()}"
            >
              ${this.gridSize > 1 ? "Next Page" : "Next"}
            </button>

            <button
              class="oe-btn-secondary ${e$2({ hidden: !this.isViewingHistory() })}"
              ?disabled="${!this.isViewingHistory()}"
              @click="${() => this.resumeVerification()}"
            >
              Continue Verifying
            </button>
          </span>

          <span class="decision-controls">
            <h2 class="verification-controls-title">${this.decisionPrompt()}</h2>
            <div class="decision-control-actions">
              <slot @decision="${this.catchDecision}"></slot>
            </div>
          </span>

          <span class="decision-controls-right">
            <slot name="data-source"></slot>
            <button @click="${this.downloadResults}" ?disabled="${!this.canDownloadResults()}" class="oe-btn-secondary">
              Download Results
            </button>
          </span>
        </div>
      </div>

      <div>${this.statisticsTemplate()}</div>
    `;
  }
};
VerificationGrid.styles = verificationGridStyles;
__decorateClass$6([
  n$6({ attribute: "grid-size", type: Number, reflect: !0 })
], VerificationGrid.prototype, "gridSize", 2);
__decorateClass$6([
  n$6({ attribute: "paged-items", type: Number, reflect: !0 })
], VerificationGrid.prototype, "pagedItems", 2);
__decorateClass$6([
  n$6({ attribute: "selection-behavior", type: String, reflect: !0 })
], VerificationGrid.prototype, "selectionBehavior", 2);
__decorateClass$6([
  n$6({ type: String })
], VerificationGrid.prototype, "audioKey", 2);
__decorateClass$6([
  n$6({ attribute: "auto-page", type: Boolean, converter: booleanConverter })
], VerificationGrid.prototype, "autoPage", 2);
__decorateClass$6([
  n$6({ attribute: "get-page", type: String })
], VerificationGrid.prototype, "getPage", 2);
__decorateClass$6([
  queryDeeplyAssignedElement({ selector: "template" })
], VerificationGrid.prototype, "gridItemTemplate", 2);
__decorateClass$6([
  queryAllDeeplyAssignedElements({ selector: "oe-decision" })
], VerificationGrid.prototype, "decisionElements", 2);
__decorateClass$6([
  r$3("oe-verification-grid-tile")
], VerificationGrid.prototype, "gridTiles", 2);
__decorateClass$6([
  e$b("oe-verification-help-dialog")
], VerificationGrid.prototype, "helpDialog", 2);
__decorateClass$6([
  r$4()
], VerificationGrid.prototype, "spectrogramElements", 2);
__decorateClass$6([
  r$4()
], VerificationGrid.prototype, "historyHead", 2);
__decorateClass$6([
  r$4()
], VerificationGrid.prototype, "dataSource", 2);
VerificationGrid = __decorateClass$6([
  t$5("oe-verification-grid")
], VerificationGrid);
const decisionStyles = i$7`
  #decision-button {
    --decision-color: var(--oe-primary-color);

    position: relative;
    height: 100%;

    > div {
      display: block;

      /*
        We set min-height to 1 relative character height so that if there are
        no additional tags or keyboard shortcuts, the button still has the
        whitespace where they would be
        We do this so that if you look horizontally across the decision buttons
        all the tags are aligned horizontally, all the additional tags are
        aligned horizontally, and all the keyboard shortcuts are aligned
      */
      min-height: 1em;
    }

    .additional-tags {
      font-size: var(--oe-font-size);
    }

    :focus,
    :active {
      outline: none;
      border: none;
    }
  }

  .show-decision-color,
  :active {
    &:not(.disabled, :disabled) {
      border: var(--oe-border-width) solid var(--decision-color);
      --background-color: var(--decision-color);
    }
  }
`;
var __defProp$5 = Object.defineProperty, __getOwnPropDesc$5 = Object.getOwnPropertyDescriptor, __decorateClass$5 = (z, D, O, F) => {
  for (var U = F > 1 ? void 0 : F ? __getOwnPropDesc$5(D, O) : D, W = z.length - 1, B; W >= 0; W--)
    (B = z[W]) && (U = (F ? B(D, O, U) : B(U)) || U);
  return F && U && __defProp$5(D, O, U), U;
};
let Decision = class extends AbstractComponent(s$7) {
  constructor() {
    super(...arguments), this.color = "var(--oe-primary-color)", this.showDecisionColor = !1, this.disabled = !1, this.selectionMode = "desktop", this.keyUpHandler = this.handleKeyUp.bind(this), this.keyDownHandler = this.handleKeyDown.bind(this), this.shouldEmitNext = !0;
  }
  connectedCallback() {
    super.connectedCallback(), document.addEventListener("keydown", this.keyDownHandler), document.addEventListener("keyup", this.keyUpHandler);
  }
  disconnectedCallback() {
    document.removeEventListener("keydown", this.keyDownHandler), document.removeEventListener("keyup", this.keyUpHandler), super.disconnectedCallback();
  }
  handleKeyUp(z) {
    z.key.toLocaleLowerCase() !== "escape" && this.isShortcutKey(z) && this.emitDecision();
  }
  handleKeyDown(z) {
    this.isShortcutKey(z) && (this.showDecisionColor = !0), z.key.toLocaleLowerCase() === "escape" && (this.shouldEmitNext = !1);
  }
  isShortcutKey(z) {
    return this.shortcut === void 0 ? !1 : z.key.toLowerCase() === this.shortcut.toLowerCase();
  }
  emitDecision() {
    var D;
    if (this.disabled || !this.shouldEmitNext) {
      this.shouldEmitNext = !0;
      return;
    }
    this.shouldEmitNext = !0;
    const z = ((D = this.additionalTags) == null ? void 0 : D.split(",").map((O) => O.trim())) ?? [];
    this.decisionButton.focus(), this.dispatchEvent(
      new CustomEvent("decision", {
        detail: {
          value: this.verified,
          tag: this.tag,
          additionalTags: z,
          color: this.color,
          target: this
        },
        bubbles: !0
      })
    );
  }
  render() {
    const z = this.additionalTags ? x`(${this.additionalTags})` : T, D = this.shortcut && this.selectionMode !== "tablet" ? x`<kbd>${this.shortcut.toUpperCase()}</kbd>` : T;
    return x`
      <button
        id="decision-button"
        class="
          oe-btn-primary
          ${e$2({ disabled: !!this.disabled, "show-decision-color": this.showDecisionColor })}
        "
        style="--decision-color: ${this.color}"
        part="decision-button"
        title="Shortcut: ${this.shortcut}"
        aria-disabled="${this.disabled}"
        @click="${this.emitDecision}"
      >
        <div class="tag-text"><slot></slot></div>
        <div class="additional-tags">${z}</div>
        ${this.selectionMode !== "tablet" ? x`<div class="keyboard-legend">${D}</div>` : T}
      </button>
    `;
  }
};
Decision.styles = decisionStyles;
__decorateClass$5([
  n$6({ type: Boolean, reflect: !0, converter: booleanConverter })
], Decision.prototype, "verified", 2);
__decorateClass$5([
  n$6({ type: String, reflect: !0 })
], Decision.prototype, "tag", 2);
__decorateClass$5([
  n$6({ type: String, reflect: !0 })
], Decision.prototype, "shortcut", 2);
__decorateClass$5([
  n$6({ type: String })
], Decision.prototype, "color", 2);
__decorateClass$5([
  n$6({ type: Boolean })
], Decision.prototype, "showDecisionColor", 2);
__decorateClass$5([
  n$6({ attribute: "additional-tags", type: String, reflect: !0 })
], Decision.prototype, "additionalTags", 2);
__decorateClass$5([
  n$6({ attribute: "disabled", type: Boolean, converter: booleanConverter, reflect: !0 })
], Decision.prototype, "disabled", 2);
__decorateClass$5([
  n$6({ type: Boolean, converter: booleanConverter })
], Decision.prototype, "all", 2);
__decorateClass$5([
  n$6({ type: Boolean, converter: booleanConverter })
], Decision.prototype, "skip", 2);
__decorateClass$5([
  e$b("#decision-button")
], Decision.prototype, "decisionButton", 2);
__decorateClass$5([
  r$4()
], Decision.prototype, "selectionMode", 2);
Decision = __decorateClass$5([
  t$5("oe-decision")
], Decision);
const verificationGridTileStyles = i$7`
  :host {
    --selected-border-size: 3px;
  }

  #highlight-box {
    position: absolute;
    pointer-events: none;
  }

  .tile-container {
    --decision-color: var(--oe-panel-color);

    position: relative;
    border-radius: var(--oe-border-rounding);
    background-color: var(--oe-panel-color);
    box-shadow: 4px 4px 8px var(--oe-panel-color);
    padding: var(--oe-spacing);
    cursor: pointer;
    margin: var(--oe-spacing);
    margin-bottom: 0;
    min-width: 350px;

    border: var(--selected-border-size) solid var(--decision-color);
    transition: border-color var(--oe-animation-time) ease-out, border-size var(--oe-animation-time) ease-out;

    &:hover {
      box-shadow: 0 2px 4px #e8e2e6;
    }
  }

  /* TODO: maybe add a border here */
  .selected {
    background-color: var(--oe-selected-color);
  }

  .keyboard-hint {
    position: absolute;
    left: 50%;
    top: 50%;
    transform: translate(0%, calc(-50% - 1rem));
    z-index: 2;
    font-size: 2rem;
  }

  .overlay-text {
    position: absolute;
    left: 50%;
    top: 50%;
    transform: translate(-50%, -50%);
    z-index: 2;
    font-size: 4em;

    background-color: var(--oe-panel-color);
    border-radius: var(--oe-border-rounding);
  }

  ::slotted(oe-media-controls) {
    display: flex;
    justify-content: center;
  }

  @media (max-width: 600px) {
    .tile-container {
      width: 100%;
      max-width: 93vw;
      margin: 0;
    }

    ::slotted(oe-spectrogram, oe-axes, oe-indicator) {
      position: relative;
      height: 460px;
    }
  }
`;
var __defProp$4 = Object.defineProperty, __getOwnPropDesc$4 = Object.getOwnPropertyDescriptor, __decorateClass$4 = (z, D, O, F) => {
  for (var U = F > 1 ? void 0 : F ? __getOwnPropDesc$4(D, O) : D, W = z.length - 1, B; W >= 0; W--)
    (B = z[W]) && (U = (F ? B(D, O, U) : B(U)) || U);
  return F && U && __defProp$4(D, O, U), U;
};
const shortcutOrder = "1234567890qwertyuiopasdfghjklzxcvbnm", shortcutTranslation = {
  1: "!",
  2: "@",
  3: "#",
  4: "$",
  5: "%",
  6: "^",
  7: "&",
  8: "*",
  9: "(",
  0: ")"
}, gridTileContext = "grid-tile-context";
let VerificationGridTile = class extends AbstractComponent(s$7) {
  constructor() {
    super(...arguments), this.color = "var(--oe-panel-color)", this.selected = !1, this.index = 0, this.showKeyboardShortcuts = !1, this.loaded = !1, this.shortcuts = [], this.keyDownHandler = this.handleKeyDown.bind(this), this.keyUpHandler = this.handleKeyUp.bind(this), this.loadingHandler = this.handleLoading.bind(this), this.loadedHandler = this.handleLoaded.bind(this);
  }
  connectedCallback() {
    super.connectedCallback(), document.addEventListener("keydown", this.keyDownHandler), document.addEventListener("keyup", this.keyUpHandler);
  }
  disconnectedCallback() {
    document.removeEventListener("keydown", this.keyDownHandler), document.removeEventListener("keyup", this.keyUpHandler), this.spectrogram && (this.spectrogram.removeEventListener("loading", this.loadingHandler), this.spectrogram.removeEventListener("loaded", this.loadedHandler)), super.disconnectedCallback();
  }
  firstUpdated() {
    if (!this.spectrogram)
      throw new Error("Could not find spectrogram component");
    this.spectrogram.addEventListener("loading", this.loadingHandler), this.spectrogram.addEventListener("loaded", this.loadedHandler);
  }
  willUpdate() {
    var D;
    this.spectrogram && ((D = this.model) != null && D.url) && (this.spectrogram.src = this.model.url);
    const z = shortcutOrder[this.index];
    this.shortcuts = [z, shortcutTranslation[z] ?? ""];
  }
  // this method is called when the spectrogram starts rendering
  handleLoading() {
    this.loaded = !1;
  }
  // this method is called when the spectrogram finishes rendering
  handleLoaded() {
    this.loaded = !0, this.dispatchEvent(new CustomEvent("loaded", { bubbles: !0 }));
  }
  handleKeyDown(z) {
    z.key === " " && z.preventDefault(), z.altKey && this.shortcuts.includes(z.key.toLowerCase()) && this.dispatchEvent(
      new CustomEvent("selected", {
        bubbles: !0,
        detail: {
          index: this.index,
          shiftKey: z.shiftKey,
          ctrlKey: z.ctrlKey
        }
      })
    );
  }
  handleKeyUp(z) {
    if (!this.spectrogram)
      throw new Error("Could not find spectrogram element");
    if (z.key === " " && this.selected) {
      const O = this.spectrogram;
      O.paused ? O.play() : O.pause();
    }
  }
  handleClick(z) {
    const D = ["oe-media-controls", "button", "oe-info-card", "a"], O = z.target.tagName;
    D.includes(O.toLocaleLowerCase()) || this.dispatchEvent(
      new CustomEvent("selected", {
        bubbles: !0,
        detail: {
          index: this.index,
          shiftKey: z.shiftKey,
          ctrlKey: z.ctrlKey
        }
      })
    );
  }
  keyboardShortcutTemplate() {
    return x`
      <div class="keyboard-hint ${e$2({ hidden: !this.showKeyboardShortcuts })}">
        <kbd>${this.shortcuts.at(0)}</kbd>
      </div>
    `;
  }
  render() {
    return x`
      <div
        @click="${this.handleClick}"
        class="tile-container ${e$2({ selected: this.selected })}"
        style="--decision-color: ${this.color}"
      >
        ${this.keyboardShortcutTemplate()}
        <slot></slot>
      </div>
    `;
  }
};
VerificationGridTile.styles = verificationGridTileStyles;
__decorateClass$4([
  e$8({ context: gridTileContext }),
  n$6({ attribute: !1 })
], VerificationGridTile.prototype, "model", 2);
__decorateClass$4([
  n$6({ type: String })
], VerificationGridTile.prototype, "color", 2);
__decorateClass$4([
  r$4()
], VerificationGridTile.prototype, "selected", 2);
__decorateClass$4([
  r$4()
], VerificationGridTile.prototype, "index", 2);
__decorateClass$4([
  r$4()
], VerificationGridTile.prototype, "showKeyboardShortcuts", 2);
__decorateClass$4([
  queryDeeplyAssignedElement({ selector: "oe-spectrogram" })
], VerificationGridTile.prototype, "spectrogram", 2);
VerificationGridTile = __decorateClass$4([
  t$5("oe-verification-grid-tile")
], VerificationGridTile);
const infoCardStyle = i$7`
  .card-container {
    position: relative;
    padding: var(--oe-spacing);
    color: var(--oe-font-color);
    background-color: var(--oe-background-color);
    border-radius: var(--oe-border-rounding);
    font-size: var(--oe-font-size);

    /*
      We multiply the spacing by two here because the spacing
      is applied to both padding left and right
    */
    width: calc(100% - calc(var(--oe-spacing) * 2));
  }

  .subject-row {
    display: grid;
    grid-template-columns: 1fr 2fr;
    gap: 0.5rem;

    .subject-key {
      font-weight: bold;
    }

    .subject-value {
      overflow-wrap: break-word;
      word-break: break-word;
    }
  }

  .static-actions {
    display: flex;
    justify-content: space-between;
  }
`;
var __defProp$3 = Object.defineProperty, __getOwnPropDesc$3 = Object.getOwnPropertyDescriptor, __decorateClass$3 = (z, D, O, F) => {
  for (var U = F > 1 ? void 0 : F ? __getOwnPropDesc$3(D, O) : D, W = z.length - 1, B; W >= 0; W--)
    (B = z[W]) && (U = (F ? B(D, O, U) : B(U)) || U);
  return F && U && __defProp$3(D, O, U), U;
};
let InfoCard = class extends AbstractComponent(s$7) {
  constructor() {
    super(...arguments), this.showExpanded = !1, this.shortLength = 3, this.numberTemplate = (z) => Number(z).toLocaleString(), this.identityTemplate = (z) => z;
  }
  // because urls can be unreasonably long, we want to truncate them
  // we do this by using the format https://.../last-path?first-parameter...
  urlTemplate(z) {
    var K;
    const D = "", O = z.split(":/")[0], F = ((K = z.split("/").at(-1)) == null ? void 0 : K.split("&")[0]) ?? "", W = z.split("&").length > 1 ? D : "", B = O + D + F + W;
    return x`<a href="${z}" target="_blank">${B}</a>`;
  }
  subjectRowTemplate(z) {
    const [D, O] = z;
    let F = this.identityTemplate;
    return typeof O == "string" && O.includes(":/") ? F = this.urlTemplate : (typeof O == "number" || !isNaN(Number(O))) && (F = this.numberTemplate), x`
      <div class="subject-row">
        <div class="subject-key">${D}</div>
        <div class="subject-value">${F(O)}</div>
      </div>
    `;
  }
  subjectTemplate(z) {
    if (z === void 0)
      return T;
    const D = Object.entries(z);
    return this.showExpanded || D.splice(this.shortLength), D.map((O) => this.subjectRowTemplate(O));
  }
  render() {
    var z, D;
    return x`
      <div class="card-container">
        ${this.subjectTemplate((z = this.model) == null ? void 0 : z.subject)}

        <hr />

        <div class="static-actions">
          <a href="${((D = this.model) == null ? void 0 : D.url) ?? ""}" target="_blank" download>Download Recording</a>
          <a @click="${() => this.showExpanded = !this.showExpanded}">
            ${this.showExpanded ? "Show Less" : "Show More"}
          </a>
        </div>
      </div>
    `;
  }
};
InfoCard.styles = infoCardStyle;
__decorateClass$3([
  c$2({ context: gridTileContext, subscribe: !0 }),
  n$6({ attribute: !1 })
], InfoCard.prototype, "model", 2);
__decorateClass$3([
  r$4()
], InfoCard.prototype, "showExpanded", 2);
InfoCard = __decorateClass$3([
  t$5("oe-info-card")
], InfoCard);
const dataSourceStyles = i$7``;
var browser = function(z) {
  var D = {};
  function O(F) {
    if (D[F])
      return D[F].exports;
    var U = D[F] = { i: F, l: !1, exports: {} };
    return z[F].call(U.exports, U, U.exports, O), U.l = !0, U.exports;
  }
  return O.m = z, O.c = D, O.d = function(F, U, W) {
    O.o(F, U) || Object.defineProperty(F, U, { enumerable: !0, get: W });
  }, O.r = function(F) {
    typeof Symbol < "u" && Symbol.toStringTag && Object.defineProperty(F, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(F, "__esModule", { value: !0 });
  }, O.t = function(F, U) {
    if (1 & U && (F = O(F)), 8 & U || 4 & U && typeof F == "object" && F && F.__esModule)
      return F;
    var W = /* @__PURE__ */ Object.create(null);
    if (O.r(W), Object.defineProperty(W, "default", { enumerable: !0, value: F }), 2 & U && typeof F != "string")
      for (var B in F)
        O.d(W, B, (function(K) {
          return F[K];
        }).bind(null, B));
    return W;
  }, O.n = function(F) {
    var U = F && F.__esModule ? function() {
      return F.default;
    } : function() {
      return F;
    };
    return O.d(U, "a", U), U;
  }, O.o = function(F, U) {
    return Object.prototype.hasOwnProperty.call(F, U);
  }, O.p = "", O(O.s = 32);
}([function(z, D) {
  var O;
  O = /* @__PURE__ */ function() {
    return this;
  }();
  try {
    O = O || Function("return this")() || (0, eval)("this");
  } catch {
    typeof window == "object" && (O = window);
  }
  z.exports = O;
}, function(z, D, O) {
  var F = O(6), U = Object.keys || function(re) {
    var ie = [];
    for (var ue in re)
      ie.push(ue);
    return ie;
  };
  z.exports = J;
  var W = O(5);
  W.inherits = O(2);
  var B = O(23), K = O(14);
  W.inherits(J, B);
  for (var X = U(K.prototype), Y = 0; Y < X.length; Y++) {
    var Q = X[Y];
    J.prototype[Q] || (J.prototype[Q] = K.prototype[Q]);
  }
  function J(re) {
    if (!(this instanceof J))
      return new J(re);
    B.call(this, re), K.call(this, re), re && re.readable === !1 && (this.readable = !1), re && re.writable === !1 && (this.writable = !1), this.allowHalfOpen = !0, re && re.allowHalfOpen === !1 && (this.allowHalfOpen = !1), this.once("end", ee);
  }
  function ee() {
    this.allowHalfOpen || this._writableState.ended || F.nextTick(ae, this);
  }
  function ae(re) {
    re.end();
  }
  Object.defineProperty(J.prototype, "writableHighWaterMark", { enumerable: !1, get: function() {
    return this._writableState.highWaterMark;
  } }), Object.defineProperty(J.prototype, "destroyed", { get: function() {
    return this._readableState !== void 0 && this._writableState !== void 0 && this._readableState.destroyed && this._writableState.destroyed;
  }, set: function(re) {
    this._readableState !== void 0 && this._writableState !== void 0 && (this._readableState.destroyed = re, this._writableState.destroyed = re);
  } }), J.prototype._destroy = function(re, ie) {
    this.push(null), this.end(), F.nextTick(ie, re);
  };
}, function(z, D) {
  typeof Object.create == "function" ? z.exports = function(O, F) {
    O.super_ = F, O.prototype = Object.create(F.prototype, { constructor: { value: O, enumerable: !1, writable: !0, configurable: !0 } });
  } : z.exports = function(O, F) {
    O.super_ = F;
    var U = function() {
    };
    U.prototype = F.prototype, O.prototype = new U(), O.prototype.constructor = O;
  };
}, function(z, D, O) {
  (function(F) {
    /*!
     * The buffer module from node.js, for the browser.
     *
     * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
     * @license  MIT
     */
    var U = O(38), W = O(39), B = O(40);
    function K() {
      return Y.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823;
    }
    function X(te, le) {
      if (K() < le)
        throw new RangeError("Invalid typed array length");
      return Y.TYPED_ARRAY_SUPPORT ? (te = new Uint8Array(le)).__proto__ = Y.prototype : (te === null && (te = new Y(le)), te.length = le), te;
    }
    function Y(te, le, ge) {
      if (!(Y.TYPED_ARRAY_SUPPORT || this instanceof Y))
        return new Y(te, le, ge);
      if (typeof te == "number") {
        if (typeof le == "string")
          throw new Error("If encoding is specified then the first argument must be a string");
        return ee(this, te);
      }
      return Q(this, te, le, ge);
    }
    function Q(te, le, ge, pe) {
      if (typeof le == "number")
        throw new TypeError('"value" argument must not be a number');
      return typeof ArrayBuffer < "u" && le instanceof ArrayBuffer ? function(fe, Se, Pe, Ge) {
        if (Se.byteLength, Pe < 0 || Se.byteLength < Pe)
          throw new RangeError("'offset' is out of bounds");
        if (Se.byteLength < Pe + (Ge || 0))
          throw new RangeError("'length' is out of bounds");
        return Se = Pe === void 0 && Ge === void 0 ? new Uint8Array(Se) : Ge === void 0 ? new Uint8Array(Se, Pe) : new Uint8Array(Se, Pe, Ge), Y.TYPED_ARRAY_SUPPORT ? (fe = Se).__proto__ = Y.prototype : fe = ae(fe, Se), fe;
      }(te, le, ge, pe) : typeof le == "string" ? function(fe, Se, Pe) {
        if (typeof Pe == "string" && Pe !== "" || (Pe = "utf8"), !Y.isEncoding(Pe))
          throw new TypeError('"encoding" must be a valid string encoding');
        var Ge = 0 | ie(Se, Pe), Qe = (fe = X(fe, Ge)).write(Se, Pe);
        return Qe !== Ge && (fe = fe.slice(0, Qe)), fe;
      }(te, le, ge) : function(fe, Se) {
        if (Y.isBuffer(Se)) {
          var Pe = 0 | re(Se.length);
          return (fe = X(fe, Pe)).length === 0 || Se.copy(fe, 0, 0, Pe), fe;
        }
        if (Se) {
          if (typeof ArrayBuffer < "u" && Se.buffer instanceof ArrayBuffer || "length" in Se)
            return typeof Se.length != "number" || function(Ge) {
              return Ge != Ge;
            }(Se.length) ? X(fe, 0) : ae(fe, Se);
          if (Se.type === "Buffer" && B(Se.data))
            return ae(fe, Se.data);
        }
        throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.");
      }(te, le);
    }
    function J(te) {
      if (typeof te != "number")
        throw new TypeError('"size" argument must be a number');
      if (te < 0)
        throw new RangeError('"size" argument must not be negative');
    }
    function ee(te, le) {
      if (J(le), te = X(te, le < 0 ? 0 : 0 | re(le)), !Y.TYPED_ARRAY_SUPPORT)
        for (var ge = 0; ge < le; ++ge)
          te[ge] = 0;
      return te;
    }
    function ae(te, le) {
      var ge = le.length < 0 ? 0 : 0 | re(le.length);
      te = X(te, ge);
      for (var pe = 0; pe < ge; pe += 1)
        te[pe] = 255 & le[pe];
      return te;
    }
    function re(te) {
      if (te >= K())
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K().toString(16) + " bytes");
      return 0 | te;
    }
    function ie(te, le) {
      if (Y.isBuffer(te))
        return te.length;
      if (typeof ArrayBuffer < "u" && typeof ArrayBuffer.isView == "function" && (ArrayBuffer.isView(te) || te instanceof ArrayBuffer))
        return te.byteLength;
      typeof te != "string" && (te = "" + te);
      var ge = te.length;
      if (ge === 0)
        return 0;
      for (var pe = !1; ; )
        switch (le) {
          case "ascii":
          case "latin1":
          case "binary":
            return ge;
          case "utf8":
          case "utf-8":
          case void 0:
            return Oe(te).length;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return 2 * ge;
          case "hex":
            return ge >>> 1;
          case "base64":
            return Te(te).length;
          default:
            if (pe)
              return Oe(te).length;
            le = ("" + le).toLowerCase(), pe = !0;
        }
    }
    function ue(te, le, ge) {
      var pe = te[le];
      te[le] = te[ge], te[ge] = pe;
    }
    function q(te, le, ge, pe, fe) {
      if (te.length === 0)
        return -1;
      if (typeof ge == "string" ? (pe = ge, ge = 0) : ge > 2147483647 ? ge = 2147483647 : ge < -2147483648 && (ge = -2147483648), ge = +ge, isNaN(ge) && (ge = fe ? 0 : te.length - 1), ge < 0 && (ge = te.length + ge), ge >= te.length) {
        if (fe)
          return -1;
        ge = te.length - 1;
      } else if (ge < 0) {
        if (!fe)
          return -1;
        ge = 0;
      }
      if (typeof le == "string" && (le = Y.from(le, pe)), Y.isBuffer(le))
        return le.length === 0 ? -1 : ne(te, le, ge, pe, fe);
      if (typeof le == "number")
        return le &= 255, Y.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf == "function" ? fe ? Uint8Array.prototype.indexOf.call(te, le, ge) : Uint8Array.prototype.lastIndexOf.call(te, le, ge) : ne(te, [le], ge, pe, fe);
      throw new TypeError("val must be string, number or Buffer");
    }
    function ne(te, le, ge, pe, fe) {
      var Se, Pe = 1, Ge = te.length, Qe = le.length;
      if (pe !== void 0 && ((pe = String(pe).toLowerCase()) === "ucs2" || pe === "ucs-2" || pe === "utf16le" || pe === "utf-16le")) {
        if (te.length < 2 || le.length < 2)
          return -1;
        Pe = 2, Ge /= 2, Qe /= 2, ge /= 2;
      }
      function et(dt, st) {
        return Pe === 1 ? dt[st] : dt.readUInt16BE(st * Pe);
      }
      if (fe) {
        var rt = -1;
        for (Se = ge; Se < Ge; Se++)
          if (et(te, Se) === et(le, rt === -1 ? 0 : Se - rt)) {
            if (rt === -1 && (rt = Se), Se - rt + 1 === Qe)
              return rt * Pe;
          } else
            rt !== -1 && (Se -= Se - rt), rt = -1;
      } else
        for (ge + Qe > Ge && (ge = Ge - Qe), Se = ge; Se >= 0; Se--) {
          for (var Xe = !0, at = 0; at < Qe; at++)
            if (et(te, Se + at) !== et(le, at)) {
              Xe = !1;
              break;
            }
          if (Xe)
            return Se;
        }
      return -1;
    }
    function ce(te, le, ge, pe) {
      ge = Number(ge) || 0;
      var fe = te.length - ge;
      pe ? (pe = Number(pe)) > fe && (pe = fe) : pe = fe;
      var Se = le.length;
      if (Se % 2 != 0)
        throw new TypeError("Invalid hex string");
      pe > Se / 2 && (pe = Se / 2);
      for (var Pe = 0; Pe < pe; ++Pe) {
        var Ge = parseInt(le.substr(2 * Pe, 2), 16);
        if (isNaN(Ge))
          return Pe;
        te[ge + Pe] = Ge;
      }
      return Pe;
    }
    function he(te, le, ge, pe) {
      return Ce(Oe(le, te.length - ge), te, ge, pe);
    }
    function we(te, le, ge, pe) {
      return Ce(function(fe) {
        for (var Se = [], Pe = 0; Pe < fe.length; ++Pe)
          Se.push(255 & fe.charCodeAt(Pe));
        return Se;
      }(le), te, ge, pe);
    }
    function me(te, le, ge, pe) {
      return we(te, le, ge, pe);
    }
    function de(te, le, ge, pe) {
      return Ce(Te(le), te, ge, pe);
    }
    function be(te, le, ge, pe) {
      return Ce(function(fe, Se) {
        for (var Pe, Ge, Qe, et = [], rt = 0; rt < fe.length && !((Se -= 2) < 0); ++rt)
          Ge = (Pe = fe.charCodeAt(rt)) >> 8, Qe = Pe % 256, et.push(Qe), et.push(Ge);
        return et;
      }(le, te.length - ge), te, ge, pe);
    }
    function _e(te, le, ge) {
      return le === 0 && ge === te.length ? U.fromByteArray(te) : U.fromByteArray(te.slice(le, ge));
    }
    function Me(te, le, ge) {
      ge = Math.min(te.length, ge);
      for (var pe = [], fe = le; fe < ge; ) {
        var Se, Pe, Ge, Qe, et = te[fe], rt = null, Xe = et > 239 ? 4 : et > 223 ? 3 : et > 191 ? 2 : 1;
        if (fe + Xe <= ge)
          switch (Xe) {
            case 1:
              et < 128 && (rt = et);
              break;
            case 2:
              (192 & (Se = te[fe + 1])) == 128 && (Qe = (31 & et) << 6 | 63 & Se) > 127 && (rt = Qe);
              break;
            case 3:
              Se = te[fe + 1], Pe = te[fe + 2], (192 & Se) == 128 && (192 & Pe) == 128 && (Qe = (15 & et) << 12 | (63 & Se) << 6 | 63 & Pe) > 2047 && (Qe < 55296 || Qe > 57343) && (rt = Qe);
              break;
            case 4:
              Se = te[fe + 1], Pe = te[fe + 2], Ge = te[fe + 3], (192 & Se) == 128 && (192 & Pe) == 128 && (192 & Ge) == 128 && (Qe = (15 & et) << 18 | (63 & Se) << 12 | (63 & Pe) << 6 | 63 & Ge) > 65535 && Qe < 1114112 && (rt = Qe);
          }
        rt === null ? (rt = 65533, Xe = 1) : rt > 65535 && (rt -= 65536, pe.push(rt >>> 10 & 1023 | 55296), rt = 56320 | 1023 & rt), pe.push(rt), fe += Xe;
      }
      return function(at) {
        var dt = at.length;
        if (dt <= Ne)
          return String.fromCharCode.apply(String, at);
        for (var st = "", Ue = 0; Ue < dt; )
          st += String.fromCharCode.apply(String, at.slice(Ue, Ue += Ne));
        return st;
      }(pe);
    }
    D.Buffer = Y, D.SlowBuffer = function(te) {
      return +te != te && (te = 0), Y.alloc(+te);
    }, D.INSPECT_MAX_BYTES = 50, Y.TYPED_ARRAY_SUPPORT = F.TYPED_ARRAY_SUPPORT !== void 0 ? F.TYPED_ARRAY_SUPPORT : function() {
      try {
        var te = new Uint8Array(1);
        return te.__proto__ = { __proto__: Uint8Array.prototype, foo: function() {
          return 42;
        } }, te.foo() === 42 && typeof te.subarray == "function" && te.subarray(1, 1).byteLength === 0;
      } catch {
        return !1;
      }
    }(), D.kMaxLength = K(), Y.poolSize = 8192, Y._augment = function(te) {
      return te.__proto__ = Y.prototype, te;
    }, Y.from = function(te, le, ge) {
      return Q(null, te, le, ge);
    }, Y.TYPED_ARRAY_SUPPORT && (Y.prototype.__proto__ = Uint8Array.prototype, Y.__proto__ = Uint8Array, typeof Symbol < "u" && Symbol.species && Y[Symbol.species] === Y && Object.defineProperty(Y, Symbol.species, { value: null, configurable: !0 })), Y.alloc = function(te, le, ge) {
      return function(pe, fe, Se, Pe) {
        return J(fe), fe <= 0 ? X(pe, fe) : Se !== void 0 ? typeof Pe == "string" ? X(pe, fe).fill(Se, Pe) : X(pe, fe).fill(Se) : X(pe, fe);
      }(null, te, le, ge);
    }, Y.allocUnsafe = function(te) {
      return ee(null, te);
    }, Y.allocUnsafeSlow = function(te) {
      return ee(null, te);
    }, Y.isBuffer = function(te) {
      return !(te == null || !te._isBuffer);
    }, Y.compare = function(te, le) {
      if (!Y.isBuffer(te) || !Y.isBuffer(le))
        throw new TypeError("Arguments must be Buffers");
      if (te === le)
        return 0;
      for (var ge = te.length, pe = le.length, fe = 0, Se = Math.min(ge, pe); fe < Se; ++fe)
        if (te[fe] !== le[fe]) {
          ge = te[fe], pe = le[fe];
          break;
        }
      return ge < pe ? -1 : pe < ge ? 1 : 0;
    }, Y.isEncoding = function(te) {
      switch (String(te).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return !0;
        default:
          return !1;
      }
    }, Y.concat = function(te, le) {
      if (!B(te))
        throw new TypeError('"list" argument must be an Array of Buffers');
      if (te.length === 0)
        return Y.alloc(0);
      var ge;
      if (le === void 0)
        for (le = 0, ge = 0; ge < te.length; ++ge)
          le += te[ge].length;
      var pe = Y.allocUnsafe(le), fe = 0;
      for (ge = 0; ge < te.length; ++ge) {
        var Se = te[ge];
        if (!Y.isBuffer(Se))
          throw new TypeError('"list" argument must be an Array of Buffers');
        Se.copy(pe, fe), fe += Se.length;
      }
      return pe;
    }, Y.byteLength = ie, Y.prototype._isBuffer = !0, Y.prototype.swap16 = function() {
      var te = this.length;
      if (te % 2 != 0)
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      for (var le = 0; le < te; le += 2)
        ue(this, le, le + 1);
      return this;
    }, Y.prototype.swap32 = function() {
      var te = this.length;
      if (te % 4 != 0)
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      for (var le = 0; le < te; le += 4)
        ue(this, le, le + 3), ue(this, le + 1, le + 2);
      return this;
    }, Y.prototype.swap64 = function() {
      var te = this.length;
      if (te % 8 != 0)
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      for (var le = 0; le < te; le += 8)
        ue(this, le, le + 7), ue(this, le + 1, le + 6), ue(this, le + 2, le + 5), ue(this, le + 3, le + 4);
      return this;
    }, Y.prototype.toString = function() {
      var te = 0 | this.length;
      return te === 0 ? "" : arguments.length === 0 ? Me(this, 0, te) : (function(le, ge, pe) {
        var fe = !1;
        if ((ge === void 0 || ge < 0) && (ge = 0), ge > this.length || ((pe === void 0 || pe > this.length) && (pe = this.length), pe <= 0) || (pe >>>= 0) <= (ge >>>= 0))
          return "";
        for (le || (le = "utf8"); ; )
          switch (le) {
            case "hex":
              return De(this, ge, pe);
            case "utf8":
            case "utf-8":
              return Me(this, ge, pe);
            case "ascii":
              return Ee(this, ge, pe);
            case "latin1":
            case "binary":
              return $e(this, ge, pe);
            case "base64":
              return _e(this, ge, pe);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return Fe(this, ge, pe);
            default:
              if (fe)
                throw new TypeError("Unknown encoding: " + le);
              le = (le + "").toLowerCase(), fe = !0;
          }
      }).apply(this, arguments);
    }, Y.prototype.equals = function(te) {
      if (!Y.isBuffer(te))
        throw new TypeError("Argument must be a Buffer");
      return this === te || Y.compare(this, te) === 0;
    }, Y.prototype.inspect = function() {
      var te = "", le = D.INSPECT_MAX_BYTES;
      return this.length > 0 && (te = this.toString("hex", 0, le).match(/.{2}/g).join(" "), this.length > le && (te += " ... ")), "<Buffer " + te + ">";
    }, Y.prototype.compare = function(te, le, ge, pe, fe) {
      if (!Y.isBuffer(te))
        throw new TypeError("Argument must be a Buffer");
      if (le === void 0 && (le = 0), ge === void 0 && (ge = te ? te.length : 0), pe === void 0 && (pe = 0), fe === void 0 && (fe = this.length), le < 0 || ge > te.length || pe < 0 || fe > this.length)
        throw new RangeError("out of range index");
      if (pe >= fe && le >= ge)
        return 0;
      if (pe >= fe)
        return -1;
      if (le >= ge)
        return 1;
      if (le >>>= 0, ge >>>= 0, pe >>>= 0, fe >>>= 0, this === te)
        return 0;
      for (var Se = fe - pe, Pe = ge - le, Ge = Math.min(Se, Pe), Qe = this.slice(pe, fe), et = te.slice(le, ge), rt = 0; rt < Ge; ++rt)
        if (Qe[rt] !== et[rt]) {
          Se = Qe[rt], Pe = et[rt];
          break;
        }
      return Se < Pe ? -1 : Pe < Se ? 1 : 0;
    }, Y.prototype.includes = function(te, le, ge) {
      return this.indexOf(te, le, ge) !== -1;
    }, Y.prototype.indexOf = function(te, le, ge) {
      return q(this, te, le, ge, !0);
    }, Y.prototype.lastIndexOf = function(te, le, ge) {
      return q(this, te, le, ge, !1);
    }, Y.prototype.write = function(te, le, ge, pe) {
      if (le === void 0)
        pe = "utf8", ge = this.length, le = 0;
      else if (ge === void 0 && typeof le == "string")
        pe = le, ge = this.length, le = 0;
      else {
        if (!isFinite(le))
          throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
        le |= 0, isFinite(ge) ? (ge |= 0, pe === void 0 && (pe = "utf8")) : (pe = ge, ge = void 0);
      }
      var fe = this.length - le;
      if ((ge === void 0 || ge > fe) && (ge = fe), te.length > 0 && (ge < 0 || le < 0) || le > this.length)
        throw new RangeError("Attempt to write outside buffer bounds");
      pe || (pe = "utf8");
      for (var Se = !1; ; )
        switch (pe) {
          case "hex":
            return ce(this, te, le, ge);
          case "utf8":
          case "utf-8":
            return he(this, te, le, ge);
          case "ascii":
            return we(this, te, le, ge);
          case "latin1":
          case "binary":
            return me(this, te, le, ge);
          case "base64":
            return de(this, te, le, ge);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return be(this, te, le, ge);
          default:
            if (Se)
              throw new TypeError("Unknown encoding: " + pe);
            pe = ("" + pe).toLowerCase(), Se = !0;
        }
    }, Y.prototype.toJSON = function() {
      return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
    };
    var Ne = 4096;
    function Ee(te, le, ge) {
      var pe = "";
      ge = Math.min(te.length, ge);
      for (var fe = le; fe < ge; ++fe)
        pe += String.fromCharCode(127 & te[fe]);
      return pe;
    }
    function $e(te, le, ge) {
      var pe = "";
      ge = Math.min(te.length, ge);
      for (var fe = le; fe < ge; ++fe)
        pe += String.fromCharCode(te[fe]);
      return pe;
    }
    function De(te, le, ge) {
      var pe = te.length;
      (!le || le < 0) && (le = 0), (!ge || ge < 0 || ge > pe) && (ge = pe);
      for (var fe = "", Se = le; Se < ge; ++Se)
        fe += xe(te[Se]);
      return fe;
    }
    function Fe(te, le, ge) {
      for (var pe = te.slice(le, ge), fe = "", Se = 0; Se < pe.length; Se += 2)
        fe += String.fromCharCode(pe[Se] + 256 * pe[Se + 1]);
      return fe;
    }
    function Be(te, le, ge) {
      if (te % 1 != 0 || te < 0)
        throw new RangeError("offset is not uint");
      if (te + le > ge)
        throw new RangeError("Trying to access beyond buffer length");
    }
    function We(te, le, ge, pe, fe, Se) {
      if (!Y.isBuffer(te))
        throw new TypeError('"buffer" argument must be a Buffer instance');
      if (le > fe || le < Se)
        throw new RangeError('"value" argument is out of bounds');
      if (ge + pe > te.length)
        throw new RangeError("Index out of range");
    }
    function Ve(te, le, ge, pe) {
      le < 0 && (le = 65535 + le + 1);
      for (var fe = 0, Se = Math.min(te.length - ge, 2); fe < Se; ++fe)
        te[ge + fe] = (le & 255 << 8 * (pe ? fe : 1 - fe)) >>> 8 * (pe ? fe : 1 - fe);
    }
    function ze(te, le, ge, pe) {
      le < 0 && (le = 4294967295 + le + 1);
      for (var fe = 0, Se = Math.min(te.length - ge, 4); fe < Se; ++fe)
        te[ge + fe] = le >>> 8 * (pe ? fe : 3 - fe) & 255;
    }
    function ke(te, le, ge, pe, fe, Se) {
      if (ge + pe > te.length)
        throw new RangeError("Index out of range");
      if (ge < 0)
        throw new RangeError("Index out of range");
    }
    function je(te, le, ge, pe, fe) {
      return fe || ke(te, 0, ge, 4), W.write(te, le, ge, pe, 23, 4), ge + 4;
    }
    function Ie(te, le, ge, pe, fe) {
      return fe || ke(te, 0, ge, 8), W.write(te, le, ge, pe, 52, 8), ge + 8;
    }
    Y.prototype.slice = function(te, le) {
      var ge, pe = this.length;
      if (te = ~~te, le = le === void 0 ? pe : ~~le, te < 0 ? (te += pe) < 0 && (te = 0) : te > pe && (te = pe), le < 0 ? (le += pe) < 0 && (le = 0) : le > pe && (le = pe), le < te && (le = te), Y.TYPED_ARRAY_SUPPORT)
        (ge = this.subarray(te, le)).__proto__ = Y.prototype;
      else {
        var fe = le - te;
        ge = new Y(fe, void 0);
        for (var Se = 0; Se < fe; ++Se)
          ge[Se] = this[Se + te];
      }
      return ge;
    }, Y.prototype.readUIntLE = function(te, le, ge) {
      te |= 0, le |= 0, ge || Be(te, le, this.length);
      for (var pe = this[te], fe = 1, Se = 0; ++Se < le && (fe *= 256); )
        pe += this[te + Se] * fe;
      return pe;
    }, Y.prototype.readUIntBE = function(te, le, ge) {
      te |= 0, le |= 0, ge || Be(te, le, this.length);
      for (var pe = this[te + --le], fe = 1; le > 0 && (fe *= 256); )
        pe += this[te + --le] * fe;
      return pe;
    }, Y.prototype.readUInt8 = function(te, le) {
      return le || Be(te, 1, this.length), this[te];
    }, Y.prototype.readUInt16LE = function(te, le) {
      return le || Be(te, 2, this.length), this[te] | this[te + 1] << 8;
    }, Y.prototype.readUInt16BE = function(te, le) {
      return le || Be(te, 2, this.length), this[te] << 8 | this[te + 1];
    }, Y.prototype.readUInt32LE = function(te, le) {
      return le || Be(te, 4, this.length), (this[te] | this[te + 1] << 8 | this[te + 2] << 16) + 16777216 * this[te + 3];
    }, Y.prototype.readUInt32BE = function(te, le) {
      return le || Be(te, 4, this.length), 16777216 * this[te] + (this[te + 1] << 16 | this[te + 2] << 8 | this[te + 3]);
    }, Y.prototype.readIntLE = function(te, le, ge) {
      te |= 0, le |= 0, ge || Be(te, le, this.length);
      for (var pe = this[te], fe = 1, Se = 0; ++Se < le && (fe *= 256); )
        pe += this[te + Se] * fe;
      return pe >= (fe *= 128) && (pe -= Math.pow(2, 8 * le)), pe;
    }, Y.prototype.readIntBE = function(te, le, ge) {
      te |= 0, le |= 0, ge || Be(te, le, this.length);
      for (var pe = le, fe = 1, Se = this[te + --pe]; pe > 0 && (fe *= 256); )
        Se += this[te + --pe] * fe;
      return Se >= (fe *= 128) && (Se -= Math.pow(2, 8 * le)), Se;
    }, Y.prototype.readInt8 = function(te, le) {
      return le || Be(te, 1, this.length), 128 & this[te] ? -1 * (255 - this[te] + 1) : this[te];
    }, Y.prototype.readInt16LE = function(te, le) {
      le || Be(te, 2, this.length);
      var ge = this[te] | this[te + 1] << 8;
      return 32768 & ge ? 4294901760 | ge : ge;
    }, Y.prototype.readInt16BE = function(te, le) {
      le || Be(te, 2, this.length);
      var ge = this[te + 1] | this[te] << 8;
      return 32768 & ge ? 4294901760 | ge : ge;
    }, Y.prototype.readInt32LE = function(te, le) {
      return le || Be(te, 4, this.length), this[te] | this[te + 1] << 8 | this[te + 2] << 16 | this[te + 3] << 24;
    }, Y.prototype.readInt32BE = function(te, le) {
      return le || Be(te, 4, this.length), this[te] << 24 | this[te + 1] << 16 | this[te + 2] << 8 | this[te + 3];
    }, Y.prototype.readFloatLE = function(te, le) {
      return le || Be(te, 4, this.length), W.read(this, te, !0, 23, 4);
    }, Y.prototype.readFloatBE = function(te, le) {
      return le || Be(te, 4, this.length), W.read(this, te, !1, 23, 4);
    }, Y.prototype.readDoubleLE = function(te, le) {
      return le || Be(te, 8, this.length), W.read(this, te, !0, 52, 8);
    }, Y.prototype.readDoubleBE = function(te, le) {
      return le || Be(te, 8, this.length), W.read(this, te, !1, 52, 8);
    }, Y.prototype.writeUIntLE = function(te, le, ge, pe) {
      te = +te, le |= 0, ge |= 0, pe || We(this, te, le, ge, Math.pow(2, 8 * ge) - 1, 0);
      var fe = 1, Se = 0;
      for (this[le] = 255 & te; ++Se < ge && (fe *= 256); )
        this[le + Se] = te / fe & 255;
      return le + ge;
    }, Y.prototype.writeUIntBE = function(te, le, ge, pe) {
      te = +te, le |= 0, ge |= 0, pe || We(this, te, le, ge, Math.pow(2, 8 * ge) - 1, 0);
      var fe = ge - 1, Se = 1;
      for (this[le + fe] = 255 & te; --fe >= 0 && (Se *= 256); )
        this[le + fe] = te / Se & 255;
      return le + ge;
    }, Y.prototype.writeUInt8 = function(te, le, ge) {
      return te = +te, le |= 0, ge || We(this, te, le, 1, 255, 0), Y.TYPED_ARRAY_SUPPORT || (te = Math.floor(te)), this[le] = 255 & te, le + 1;
    }, Y.prototype.writeUInt16LE = function(te, le, ge) {
      return te = +te, le |= 0, ge || We(this, te, le, 2, 65535, 0), Y.TYPED_ARRAY_SUPPORT ? (this[le] = 255 & te, this[le + 1] = te >>> 8) : Ve(this, te, le, !0), le + 2;
    }, Y.prototype.writeUInt16BE = function(te, le, ge) {
      return te = +te, le |= 0, ge || We(this, te, le, 2, 65535, 0), Y.TYPED_ARRAY_SUPPORT ? (this[le] = te >>> 8, this[le + 1] = 255 & te) : Ve(this, te, le, !1), le + 2;
    }, Y.prototype.writeUInt32LE = function(te, le, ge) {
      return te = +te, le |= 0, ge || We(this, te, le, 4, 4294967295, 0), Y.TYPED_ARRAY_SUPPORT ? (this[le + 3] = te >>> 24, this[le + 2] = te >>> 16, this[le + 1] = te >>> 8, this[le] = 255 & te) : ze(this, te, le, !0), le + 4;
    }, Y.prototype.writeUInt32BE = function(te, le, ge) {
      return te = +te, le |= 0, ge || We(this, te, le, 4, 4294967295, 0), Y.TYPED_ARRAY_SUPPORT ? (this[le] = te >>> 24, this[le + 1] = te >>> 16, this[le + 2] = te >>> 8, this[le + 3] = 255 & te) : ze(this, te, le, !1), le + 4;
    }, Y.prototype.writeIntLE = function(te, le, ge, pe) {
      if (te = +te, le |= 0, !pe) {
        var fe = Math.pow(2, 8 * ge - 1);
        We(this, te, le, ge, fe - 1, -fe);
      }
      var Se = 0, Pe = 1, Ge = 0;
      for (this[le] = 255 & te; ++Se < ge && (Pe *= 256); )
        te < 0 && Ge === 0 && this[le + Se - 1] !== 0 && (Ge = 1), this[le + Se] = (te / Pe >> 0) - Ge & 255;
      return le + ge;
    }, Y.prototype.writeIntBE = function(te, le, ge, pe) {
      if (te = +te, le |= 0, !pe) {
        var fe = Math.pow(2, 8 * ge - 1);
        We(this, te, le, ge, fe - 1, -fe);
      }
      var Se = ge - 1, Pe = 1, Ge = 0;
      for (this[le + Se] = 255 & te; --Se >= 0 && (Pe *= 256); )
        te < 0 && Ge === 0 && this[le + Se + 1] !== 0 && (Ge = 1), this[le + Se] = (te / Pe >> 0) - Ge & 255;
      return le + ge;
    }, Y.prototype.writeInt8 = function(te, le, ge) {
      return te = +te, le |= 0, ge || We(this, te, le, 1, 127, -128), Y.TYPED_ARRAY_SUPPORT || (te = Math.floor(te)), te < 0 && (te = 255 + te + 1), this[le] = 255 & te, le + 1;
    }, Y.prototype.writeInt16LE = function(te, le, ge) {
      return te = +te, le |= 0, ge || We(this, te, le, 2, 32767, -32768), Y.TYPED_ARRAY_SUPPORT ? (this[le] = 255 & te, this[le + 1] = te >>> 8) : Ve(this, te, le, !0), le + 2;
    }, Y.prototype.writeInt16BE = function(te, le, ge) {
      return te = +te, le |= 0, ge || We(this, te, le, 2, 32767, -32768), Y.TYPED_ARRAY_SUPPORT ? (this[le] = te >>> 8, this[le + 1] = 255 & te) : Ve(this, te, le, !1), le + 2;
    }, Y.prototype.writeInt32LE = function(te, le, ge) {
      return te = +te, le |= 0, ge || We(this, te, le, 4, 2147483647, -2147483648), Y.TYPED_ARRAY_SUPPORT ? (this[le] = 255 & te, this[le + 1] = te >>> 8, this[le + 2] = te >>> 16, this[le + 3] = te >>> 24) : ze(this, te, le, !0), le + 4;
    }, Y.prototype.writeInt32BE = function(te, le, ge) {
      return te = +te, le |= 0, ge || We(this, te, le, 4, 2147483647, -2147483648), te < 0 && (te = 4294967295 + te + 1), Y.TYPED_ARRAY_SUPPORT ? (this[le] = te >>> 24, this[le + 1] = te >>> 16, this[le + 2] = te >>> 8, this[le + 3] = 255 & te) : ze(this, te, le, !1), le + 4;
    }, Y.prototype.writeFloatLE = function(te, le, ge) {
      return je(this, te, le, !0, ge);
    }, Y.prototype.writeFloatBE = function(te, le, ge) {
      return je(this, te, le, !1, ge);
    }, Y.prototype.writeDoubleLE = function(te, le, ge) {
      return Ie(this, te, le, !0, ge);
    }, Y.prototype.writeDoubleBE = function(te, le, ge) {
      return Ie(this, te, le, !1, ge);
    }, Y.prototype.copy = function(te, le, ge, pe) {
      if (ge || (ge = 0), pe || pe === 0 || (pe = this.length), le >= te.length && (le = te.length), le || (le = 0), pe > 0 && pe < ge && (pe = ge), pe === ge || te.length === 0 || this.length === 0)
        return 0;
      if (le < 0)
        throw new RangeError("targetStart out of bounds");
      if (ge < 0 || ge >= this.length)
        throw new RangeError("sourceStart out of bounds");
      if (pe < 0)
        throw new RangeError("sourceEnd out of bounds");
      pe > this.length && (pe = this.length), te.length - le < pe - ge && (pe = te.length - le + ge);
      var fe, Se = pe - ge;
      if (this === te && ge < le && le < pe)
        for (fe = Se - 1; fe >= 0; --fe)
          te[fe + le] = this[fe + ge];
      else if (Se < 1e3 || !Y.TYPED_ARRAY_SUPPORT)
        for (fe = 0; fe < Se; ++fe)
          te[fe + le] = this[fe + ge];
      else
        Uint8Array.prototype.set.call(te, this.subarray(ge, ge + Se), le);
      return Se;
    }, Y.prototype.fill = function(te, le, ge, pe) {
      if (typeof te == "string") {
        if (typeof le == "string" ? (pe = le, le = 0, ge = this.length) : typeof ge == "string" && (pe = ge, ge = this.length), te.length === 1) {
          var fe = te.charCodeAt(0);
          fe < 256 && (te = fe);
        }
        if (pe !== void 0 && typeof pe != "string")
          throw new TypeError("encoding must be a string");
        if (typeof pe == "string" && !Y.isEncoding(pe))
          throw new TypeError("Unknown encoding: " + pe);
      } else
        typeof te == "number" && (te &= 255);
      if (le < 0 || this.length < le || this.length < ge)
        throw new RangeError("Out of range index");
      if (ge <= le)
        return this;
      var Se;
      if (le >>>= 0, ge = ge === void 0 ? this.length : ge >>> 0, te || (te = 0), typeof te == "number")
        for (Se = le; Se < ge; ++Se)
          this[Se] = te;
      else {
        var Pe = Y.isBuffer(te) ? te : Oe(new Y(te, pe).toString()), Ge = Pe.length;
        for (Se = 0; Se < ge - le; ++Se)
          this[Se + le] = Pe[Se % Ge];
      }
      return this;
    };
    var ve = /[^+\/0-9A-Za-z-_]/g;
    function xe(te) {
      return te < 16 ? "0" + te.toString(16) : te.toString(16);
    }
    function Oe(te, le) {
      var ge;
      le = le || 1 / 0;
      for (var pe = te.length, fe = null, Se = [], Pe = 0; Pe < pe; ++Pe) {
        if ((ge = te.charCodeAt(Pe)) > 55295 && ge < 57344) {
          if (!fe) {
            if (ge > 56319) {
              (le -= 3) > -1 && Se.push(239, 191, 189);
              continue;
            }
            if (Pe + 1 === pe) {
              (le -= 3) > -1 && Se.push(239, 191, 189);
              continue;
            }
            fe = ge;
            continue;
          }
          if (ge < 56320) {
            (le -= 3) > -1 && Se.push(239, 191, 189), fe = ge;
            continue;
          }
          ge = 65536 + (fe - 55296 << 10 | ge - 56320);
        } else
          fe && (le -= 3) > -1 && Se.push(239, 191, 189);
        if (fe = null, ge < 128) {
          if ((le -= 1) < 0)
            break;
          Se.push(ge);
        } else if (ge < 2048) {
          if ((le -= 2) < 0)
            break;
          Se.push(ge >> 6 | 192, 63 & ge | 128);
        } else if (ge < 65536) {
          if ((le -= 3) < 0)
            break;
          Se.push(ge >> 12 | 224, ge >> 6 & 63 | 128, 63 & ge | 128);
        } else {
          if (!(ge < 1114112))
            throw new Error("Invalid code point");
          if ((le -= 4) < 0)
            break;
          Se.push(ge >> 18 | 240, ge >> 12 & 63 | 128, ge >> 6 & 63 | 128, 63 & ge | 128);
        }
      }
      return Se;
    }
    function Te(te) {
      return U.toByteArray(function(le) {
        if ((le = function(ge) {
          return ge.trim ? ge.trim() : ge.replace(/^\s+|\s+$/g, "");
        }(le).replace(ve, "")).length < 2)
          return "";
        for (; le.length % 4 != 0; )
          le += "=";
        return le;
      }(te));
    }
    function Ce(te, le, ge, pe) {
      for (var fe = 0; fe < pe && !(fe + ge >= le.length || fe >= te.length); ++fe)
        le[fe + ge] = te[fe];
      return fe;
    }
  }).call(this, O(0));
}, function(z, D) {
  var O, F, U = z.exports = {};
  function W() {
    throw new Error("setTimeout has not been defined");
  }
  function B() {
    throw new Error("clearTimeout has not been defined");
  }
  function K(ue) {
    if (O === setTimeout)
      return setTimeout(ue, 0);
    if ((O === W || !O) && setTimeout)
      return O = setTimeout, setTimeout(ue, 0);
    try {
      return O(ue, 0);
    } catch {
      try {
        return O.call(null, ue, 0);
      } catch {
        return O.call(this, ue, 0);
      }
    }
  }
  (function() {
    try {
      O = typeof setTimeout == "function" ? setTimeout : W;
    } catch {
      O = W;
    }
    try {
      F = typeof clearTimeout == "function" ? clearTimeout : B;
    } catch {
      F = B;
    }
  })();
  var X, Y = [], Q = !1, J = -1;
  function ee() {
    Q && X && (Q = !1, X.length ? Y = X.concat(Y) : J = -1, Y.length && ae());
  }
  function ae() {
    if (!Q) {
      var ue = K(ee);
      Q = !0;
      for (var q = Y.length; q; ) {
        for (X = Y, Y = []; ++J < q; )
          X && X[J].run();
        J = -1, q = Y.length;
      }
      X = null, Q = !1, function(ne) {
        if (F === clearTimeout)
          return clearTimeout(ne);
        if ((F === B || !F) && clearTimeout)
          return F = clearTimeout, clearTimeout(ne);
        try {
          F(ne);
        } catch {
          try {
            return F.call(null, ne);
          } catch {
            return F.call(this, ne);
          }
        }
      }(ue);
    }
  }
  function re(ue, q) {
    this.fun = ue, this.array = q;
  }
  function ie() {
  }
  U.nextTick = function(ue) {
    var q = new Array(arguments.length - 1);
    if (arguments.length > 1)
      for (var ne = 1; ne < arguments.length; ne++)
        q[ne - 1] = arguments[ne];
    Y.push(new re(ue, q)), Y.length !== 1 || Q || K(ae);
  }, re.prototype.run = function() {
    this.fun.apply(null, this.array);
  }, U.title = "browser", U.browser = !0, U.env = {}, U.argv = [], U.version = "", U.versions = {}, U.on = ie, U.addListener = ie, U.once = ie, U.off = ie, U.removeListener = ie, U.removeAllListeners = ie, U.emit = ie, U.prependListener = ie, U.prependOnceListener = ie, U.listeners = function(ue) {
    return [];
  }, U.binding = function(ue) {
    throw new Error("process.binding is not supported");
  }, U.cwd = function() {
    return "/";
  }, U.chdir = function(ue) {
    throw new Error("process.chdir is not supported");
  }, U.umask = function() {
    return 0;
  };
}, function(z, D, O) {
  (function(F) {
    function U(W) {
      return Object.prototype.toString.call(W);
    }
    D.isArray = function(W) {
      return Array.isArray ? Array.isArray(W) : U(W) === "[object Array]";
    }, D.isBoolean = function(W) {
      return typeof W == "boolean";
    }, D.isNull = function(W) {
      return W === null;
    }, D.isNullOrUndefined = function(W) {
      return W == null;
    }, D.isNumber = function(W) {
      return typeof W == "number";
    }, D.isString = function(W) {
      return typeof W == "string";
    }, D.isSymbol = function(W) {
      return typeof W == "symbol";
    }, D.isUndefined = function(W) {
      return W === void 0;
    }, D.isRegExp = function(W) {
      return U(W) === "[object RegExp]";
    }, D.isObject = function(W) {
      return typeof W == "object" && W !== null;
    }, D.isDate = function(W) {
      return U(W) === "[object Date]";
    }, D.isError = function(W) {
      return U(W) === "[object Error]" || W instanceof Error;
    }, D.isFunction = function(W) {
      return typeof W == "function";
    }, D.isPrimitive = function(W) {
      return W === null || typeof W == "boolean" || typeof W == "number" || typeof W == "string" || typeof W == "symbol" || W === void 0;
    }, D.isBuffer = F.isBuffer;
  }).call(this, O(3).Buffer);
}, function(z, D, O) {
  (function(F) {
    !F.version || F.version.indexOf("v0.") === 0 || F.version.indexOf("v1.") === 0 && F.version.indexOf("v1.8.") !== 0 ? z.exports = { nextTick: function(U, W, B, K) {
      if (typeof U != "function")
        throw new TypeError('"callback" argument must be a function');
      var X, Y, Q = arguments.length;
      switch (Q) {
        case 0:
        case 1:
          return F.nextTick(U);
        case 2:
          return F.nextTick(function() {
            U.call(null, W);
          });
        case 3:
          return F.nextTick(function() {
            U.call(null, W, B);
          });
        case 4:
          return F.nextTick(function() {
            U.call(null, W, B, K);
          });
        default:
          for (X = new Array(Q - 1), Y = 0; Y < X.length; )
            X[Y++] = arguments[Y];
          return F.nextTick(function() {
            U.apply(null, X);
          });
      }
    } } : z.exports = F;
  }).call(this, O(4));
}, function(z, D, O) {
  var F = O(3), U = F.Buffer;
  function W(K, X) {
    for (var Y in K)
      X[Y] = K[Y];
  }
  function B(K, X, Y) {
    return U(K, X, Y);
  }
  U.from && U.alloc && U.allocUnsafe && U.allocUnsafeSlow ? z.exports = F : (W(F, D), D.Buffer = B), W(U, B), B.from = function(K, X, Y) {
    if (typeof K == "number")
      throw new TypeError("Argument must not be a number");
    return U(K, X, Y);
  }, B.alloc = function(K, X, Y) {
    if (typeof K != "number")
      throw new TypeError("Argument must be a number");
    var Q = U(K);
    return X !== void 0 ? typeof Y == "string" ? Q.fill(X, Y) : Q.fill(X) : Q.fill(0), Q;
  }, B.allocUnsafe = function(K) {
    if (typeof K != "number")
      throw new TypeError("Argument must be a number");
    return U(K);
  }, B.allocUnsafeSlow = function(K) {
    if (typeof K != "number")
      throw new TypeError("Argument must be a number");
    return F.SlowBuffer(K);
  };
}, function(z, D, O) {
  var F = O(17)(Object, "create");
  z.exports = F;
}, function(z, D, O) {
  var F = O(31);
  z.exports = function(U, W) {
    for (var B = U.length; B--; )
      if (F(U[B][0], W))
        return B;
    return -1;
  };
}, function(z, D, O) {
  var F = O(96);
  z.exports = function(U, W) {
    var B = U.__data__;
    return F(W) ? B[typeof W == "string" ? "string" : "hash"] : B.map;
  };
}, function(z, D, O) {
  (function(F) {
    var U = F !== void 0 && F || typeof self < "u" && self || window, W = Function.prototype.apply;
    function B(K, X) {
      this._id = K, this._clearFn = X;
    }
    D.setTimeout = function() {
      return new B(W.call(setTimeout, U, arguments), clearTimeout);
    }, D.setInterval = function() {
      return new B(W.call(setInterval, U, arguments), clearInterval);
    }, D.clearTimeout = D.clearInterval = function(K) {
      K && K.close();
    }, B.prototype.unref = B.prototype.ref = function() {
    }, B.prototype.close = function() {
      this._clearFn.call(U, this._id);
    }, D.enroll = function(K, X) {
      clearTimeout(K._idleTimeoutId), K._idleTimeout = X;
    }, D.unenroll = function(K) {
      clearTimeout(K._idleTimeoutId), K._idleTimeout = -1;
    }, D._unrefActive = D.active = function(K) {
      clearTimeout(K._idleTimeoutId);
      var X = K._idleTimeout;
      X >= 0 && (K._idleTimeoutId = setTimeout(function() {
        K._onTimeout && K._onTimeout();
      }, X));
    }, O(35), D.setImmediate = typeof self < "u" && self.setImmediate || F !== void 0 && F.setImmediate || this && this.setImmediate, D.clearImmediate = typeof self < "u" && self.clearImmediate || F !== void 0 && F.clearImmediate || this && this.clearImmediate;
  }).call(this, O(0));
}, function(z, D) {
  function O() {
    this._events = this._events || {}, this._maxListeners = this._maxListeners || void 0;
  }
  function F(B) {
    return typeof B == "function";
  }
  function U(B) {
    return typeof B == "object" && B !== null;
  }
  function W(B) {
    return B === void 0;
  }
  z.exports = O, O.EventEmitter = O, O.prototype._events = void 0, O.prototype._maxListeners = void 0, O.defaultMaxListeners = 10, O.prototype.setMaxListeners = function(B) {
    if (!/* @__PURE__ */ function(K) {
      return typeof K == "number";
    }(B) || B < 0 || isNaN(B))
      throw TypeError("n must be a positive number");
    return this._maxListeners = B, this;
  }, O.prototype.emit = function(B) {
    var K, X, Y, Q, J, ee;
    if (this._events || (this._events = {}), B === "error" && (!this._events.error || U(this._events.error) && !this._events.error.length)) {
      if ((K = arguments[1]) instanceof Error)
        throw K;
      var ae = new Error('Uncaught, unspecified "error" event. (' + K + ")");
      throw ae.context = K, ae;
    }
    if (W(X = this._events[B]))
      return !1;
    if (F(X))
      switch (arguments.length) {
        case 1:
          X.call(this);
          break;
        case 2:
          X.call(this, arguments[1]);
          break;
        case 3:
          X.call(this, arguments[1], arguments[2]);
          break;
        default:
          Q = Array.prototype.slice.call(arguments, 1), X.apply(this, Q);
      }
    else if (U(X))
      for (Q = Array.prototype.slice.call(arguments, 1), Y = (ee = X.slice()).length, J = 0; J < Y; J++)
        ee[J].apply(this, Q);
    return !0;
  }, O.prototype.addListener = function(B, K) {
    var X;
    if (!F(K))
      throw TypeError("listener must be a function");
    return this._events || (this._events = {}), this._events.newListener && this.emit("newListener", B, F(K.listener) ? K.listener : K), this._events[B] ? U(this._events[B]) ? this._events[B].push(K) : this._events[B] = [this._events[B], K] : this._events[B] = K, U(this._events[B]) && !this._events[B].warned && (X = W(this._maxListeners) ? O.defaultMaxListeners : this._maxListeners) && X > 0 && this._events[B].length > X && (this._events[B].warned = !0, console.error("(node) warning: possible EventEmitter memory leak detected. %d listeners added. Use emitter.setMaxListeners() to increase limit.", this._events[B].length), typeof console.trace == "function" && console.trace()), this;
  }, O.prototype.on = O.prototype.addListener, O.prototype.once = function(B, K) {
    if (!F(K))
      throw TypeError("listener must be a function");
    var X = !1;
    function Y() {
      this.removeListener(B, Y), X || (X = !0, K.apply(this, arguments));
    }
    return Y.listener = K, this.on(B, Y), this;
  }, O.prototype.removeListener = function(B, K) {
    var X, Y, Q, J;
    if (!F(K))
      throw TypeError("listener must be a function");
    if (!this._events || !this._events[B])
      return this;
    if (Q = (X = this._events[B]).length, Y = -1, X === K || F(X.listener) && X.listener === K)
      delete this._events[B], this._events.removeListener && this.emit("removeListener", B, K);
    else if (U(X)) {
      for (J = Q; J-- > 0; )
        if (X[J] === K || X[J].listener && X[J].listener === K) {
          Y = J;
          break;
        }
      if (Y < 0)
        return this;
      X.length === 1 ? (X.length = 0, delete this._events[B]) : X.splice(Y, 1), this._events.removeListener && this.emit("removeListener", B, K);
    }
    return this;
  }, O.prototype.removeAllListeners = function(B) {
    var K, X;
    if (!this._events)
      return this;
    if (!this._events.removeListener)
      return arguments.length === 0 ? this._events = {} : this._events[B] && delete this._events[B], this;
    if (arguments.length === 0) {
      for (K in this._events)
        K !== "removeListener" && this.removeAllListeners(K);
      return this.removeAllListeners("removeListener"), this._events = {}, this;
    }
    if (F(X = this._events[B]))
      this.removeListener(B, X);
    else if (X)
      for (; X.length; )
        this.removeListener(B, X[X.length - 1]);
    return delete this._events[B], this;
  }, O.prototype.listeners = function(B) {
    return this._events && this._events[B] ? F(this._events[B]) ? [this._events[B]] : this._events[B].slice() : [];
  }, O.prototype.listenerCount = function(B) {
    if (this._events) {
      var K = this._events[B];
      if (F(K))
        return 1;
      if (K)
        return K.length;
    }
    return 0;
  }, O.listenerCount = function(B, K) {
    return B.listenerCount(K);
  };
}, function(z, D, O) {
  (D = z.exports = O(23)).Stream = D, D.Readable = D, D.Writable = O(14), D.Duplex = O(1), D.Transform = O(27), D.PassThrough = O(45);
}, function(z, D, O) {
  (function(F, U, W) {
    var B = O(6);
    function K(Me) {
      var Ne = this;
      this.next = null, this.entry = null, this.finish = function() {
        (function(Ee, $e, De) {
          var Fe = Ee.entry;
          for (Ee.entry = null; Fe; ) {
            var Be = Fe.callback;
            $e.pendingcb--, Be(void 0), Fe = Fe.next;
          }
          $e.corkedRequestsFree ? $e.corkedRequestsFree.next = Ee : $e.corkedRequestsFree = Ee;
        })(Ne, Me);
      };
    }
    z.exports = ce;
    var X, Y = !F.browser && ["v0.10", "v0.9."].indexOf(F.version.slice(0, 5)) > -1 ? U : B.nextTick;
    ce.WritableState = ne;
    var Q = O(5);
    Q.inherits = O(2);
    var J, ee = { deprecate: O(44) }, ae = O(24), re = O(7).Buffer, ie = W.Uint8Array || function() {
    }, ue = O(25);
    function q() {
    }
    function ne(Me, Ne) {
      X = X || O(1), Me = Me || {};
      var Ee = Ne instanceof X;
      this.objectMode = !!Me.objectMode, Ee && (this.objectMode = this.objectMode || !!Me.writableObjectMode);
      var $e = Me.highWaterMark, De = Me.writableHighWaterMark, Fe = this.objectMode ? 16 : 16384;
      this.highWaterMark = $e || $e === 0 ? $e : Ee && (De || De === 0) ? De : Fe, this.highWaterMark = Math.floor(this.highWaterMark), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
      var Be = Me.decodeStrings === !1;
      this.decodeStrings = !Be, this.defaultEncoding = Me.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function(We) {
        (function(Ve, ze) {
          var ke = Ve._writableState, je = ke.sync, Ie = ke.writecb;
          if (function(xe) {
            xe.writing = !1, xe.writecb = null, xe.length -= xe.writelen, xe.writelen = 0;
          }(ke), ze)
            (function(xe, Oe, Te, Ce, te) {
              --Oe.pendingcb, Te ? (B.nextTick(te, Ce), B.nextTick(_e, xe, Oe), xe._writableState.errorEmitted = !0, xe.emit("error", Ce)) : (te(Ce), xe._writableState.errorEmitted = !0, xe.emit("error", Ce), _e(xe, Oe));
            })(Ve, ke, je, ze, Ie);
          else {
            var ve = de(ke);
            ve || ke.corked || ke.bufferProcessing || !ke.bufferedRequest || me(Ve, ke), je ? Y(we, Ve, ke, ve, Ie) : we(Ve, ke, ve, Ie);
          }
        })(Ne, We);
      }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.bufferedRequestCount = 0, this.corkedRequestsFree = new K(this);
    }
    function ce(Me) {
      if (X = X || O(1), !(J.call(ce, this) || this instanceof X))
        return new ce(Me);
      this._writableState = new ne(Me, this), this.writable = !0, Me && (typeof Me.write == "function" && (this._write = Me.write), typeof Me.writev == "function" && (this._writev = Me.writev), typeof Me.destroy == "function" && (this._destroy = Me.destroy), typeof Me.final == "function" && (this._final = Me.final)), ae.call(this);
    }
    function he(Me, Ne, Ee, $e, De, Fe, Be) {
      Ne.writelen = $e, Ne.writecb = Be, Ne.writing = !0, Ne.sync = !0, Ee ? Me._writev(De, Ne.onwrite) : Me._write(De, Fe, Ne.onwrite), Ne.sync = !1;
    }
    function we(Me, Ne, Ee, $e) {
      Ee || function(De, Fe) {
        Fe.length === 0 && Fe.needDrain && (Fe.needDrain = !1, De.emit("drain"));
      }(Me, Ne), Ne.pendingcb--, $e(), _e(Me, Ne);
    }
    function me(Me, Ne) {
      Ne.bufferProcessing = !0;
      var Ee = Ne.bufferedRequest;
      if (Me._writev && Ee && Ee.next) {
        var $e = Ne.bufferedRequestCount, De = new Array($e), Fe = Ne.corkedRequestsFree;
        Fe.entry = Ee;
        for (var Be = 0, We = !0; Ee; )
          De[Be] = Ee, Ee.isBuf || (We = !1), Ee = Ee.next, Be += 1;
        De.allBuffers = We, he(Me, Ne, !0, Ne.length, De, "", Fe.finish), Ne.pendingcb++, Ne.lastBufferedRequest = null, Fe.next ? (Ne.corkedRequestsFree = Fe.next, Fe.next = null) : Ne.corkedRequestsFree = new K(Ne), Ne.bufferedRequestCount = 0;
      } else {
        for (; Ee; ) {
          var Ve = Ee.chunk, ze = Ee.encoding, ke = Ee.callback;
          if (he(Me, Ne, !1, Ne.objectMode ? 1 : Ve.length, Ve, ze, ke), Ee = Ee.next, Ne.bufferedRequestCount--, Ne.writing)
            break;
        }
        Ee === null && (Ne.lastBufferedRequest = null);
      }
      Ne.bufferedRequest = Ee, Ne.bufferProcessing = !1;
    }
    function de(Me) {
      return Me.ending && Me.length === 0 && Me.bufferedRequest === null && !Me.finished && !Me.writing;
    }
    function be(Me, Ne) {
      Me._final(function(Ee) {
        Ne.pendingcb--, Ee && Me.emit("error", Ee), Ne.prefinished = !0, Me.emit("prefinish"), _e(Me, Ne);
      });
    }
    function _e(Me, Ne) {
      var Ee = de(Ne);
      return Ee && (function($e, De) {
        De.prefinished || De.finalCalled || (typeof $e._final == "function" ? (De.pendingcb++, De.finalCalled = !0, B.nextTick(be, $e, De)) : (De.prefinished = !0, $e.emit("prefinish")));
      }(Me, Ne), Ne.pendingcb === 0 && (Ne.finished = !0, Me.emit("finish"))), Ee;
    }
    Q.inherits(ce, ae), ne.prototype.getBuffer = function() {
      for (var Me = this.bufferedRequest, Ne = []; Me; )
        Ne.push(Me), Me = Me.next;
      return Ne;
    }, function() {
      try {
        Object.defineProperty(ne.prototype, "buffer", { get: ee.deprecate(function() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003") });
      } catch {
      }
    }(), typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (J = Function.prototype[Symbol.hasInstance], Object.defineProperty(ce, Symbol.hasInstance, { value: function(Me) {
      return !!J.call(this, Me) || this === ce && Me && Me._writableState instanceof ne;
    } })) : J = function(Me) {
      return Me instanceof this;
    }, ce.prototype.pipe = function() {
      this.emit("error", new Error("Cannot pipe, not readable"));
    }, ce.prototype.write = function(Me, Ne, Ee) {
      var $e = this._writableState, De = !1, Fe = !$e.objectMode && function(Be) {
        return re.isBuffer(Be) || Be instanceof ie;
      }(Me);
      return Fe && !re.isBuffer(Me) && (Me = function(Be) {
        return re.from(Be);
      }(Me)), typeof Ne == "function" && (Ee = Ne, Ne = null), Fe ? Ne = "buffer" : Ne || (Ne = $e.defaultEncoding), typeof Ee != "function" && (Ee = q), $e.ended ? function(Be, We) {
        var Ve = new Error("write after end");
        Be.emit("error", Ve), B.nextTick(We, Ve);
      }(this, Ee) : (Fe || function(Be, We, Ve, ze) {
        var ke = !0, je = !1;
        return Ve === null ? je = new TypeError("May not write null values to stream") : typeof Ve == "string" || Ve === void 0 || We.objectMode || (je = new TypeError("Invalid non-string/buffer chunk")), je && (Be.emit("error", je), B.nextTick(ze, je), ke = !1), ke;
      }(this, $e, Me, Ee)) && ($e.pendingcb++, De = function(Be, We, Ve, ze, ke, je) {
        if (!Ve) {
          var Ie = function(Te, Ce, te) {
            return Te.objectMode || Te.decodeStrings === !1 || typeof Ce != "string" || (Ce = re.from(Ce, te)), Ce;
          }(We, ze, ke);
          ze !== Ie && (Ve = !0, ke = "buffer", ze = Ie);
        }
        var ve = We.objectMode ? 1 : ze.length;
        We.length += ve;
        var xe = We.length < We.highWaterMark;
        if (xe || (We.needDrain = !0), We.writing || We.corked) {
          var Oe = We.lastBufferedRequest;
          We.lastBufferedRequest = { chunk: ze, encoding: ke, isBuf: Ve, callback: je, next: null }, Oe ? Oe.next = We.lastBufferedRequest : We.bufferedRequest = We.lastBufferedRequest, We.bufferedRequestCount += 1;
        } else
          he(Be, We, !1, ve, ze, ke, je);
        return xe;
      }(this, $e, Fe, Me, Ne, Ee)), De;
    }, ce.prototype.cork = function() {
      this._writableState.corked++;
    }, ce.prototype.uncork = function() {
      var Me = this._writableState;
      Me.corked && (Me.corked--, Me.writing || Me.corked || Me.finished || Me.bufferProcessing || !Me.bufferedRequest || me(this, Me));
    }, ce.prototype.setDefaultEncoding = function(Me) {
      if (typeof Me == "string" && (Me = Me.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((Me + "").toLowerCase()) > -1))
        throw new TypeError("Unknown encoding: " + Me);
      return this._writableState.defaultEncoding = Me, this;
    }, Object.defineProperty(ce.prototype, "writableHighWaterMark", { enumerable: !1, get: function() {
      return this._writableState.highWaterMark;
    } }), ce.prototype._write = function(Me, Ne, Ee) {
      Ee(new Error("_write() is not implemented"));
    }, ce.prototype._writev = null, ce.prototype.end = function(Me, Ne, Ee) {
      var $e = this._writableState;
      typeof Me == "function" ? (Ee = Me, Me = null, Ne = null) : typeof Ne == "function" && (Ee = Ne, Ne = null), Me != null && this.write(Me, Ne), $e.corked && ($e.corked = 1, this.uncork()), $e.ending || $e.finished || function(De, Fe, Be) {
        Fe.ending = !0, _e(De, Fe), Be && (Fe.finished ? B.nextTick(Be) : De.once("finish", Be)), Fe.ended = !0, De.writable = !1;
      }(this, $e, Ee);
    }, Object.defineProperty(ce.prototype, "destroyed", { get: function() {
      return this._writableState !== void 0 && this._writableState.destroyed;
    }, set: function(Me) {
      this._writableState && (this._writableState.destroyed = Me);
    } }), ce.prototype.destroy = ue.destroy, ce.prototype._undestroy = ue.undestroy, ce.prototype._destroy = function(Me, Ne) {
      this.end(), Ne(Me);
    };
  }).call(this, O(4), O(11).setImmediate, O(0));
}, function(z, D, O) {
  (function(F, U, W) {
    z.exports = function B(K, X, Y) {
      function Q(ae, re) {
        if (!X[ae]) {
          if (!K[ae]) {
            var ie = typeof _dereq_ == "function" && _dereq_;
            if (!re && ie)
              return ie(ae, !0);
            if (J)
              return J(ae, !0);
            var ue = new Error("Cannot find module '" + ae + "'");
            throw ue.code = "MODULE_NOT_FOUND", ue;
          }
          var q = X[ae] = { exports: {} };
          K[ae][0].call(q.exports, function(ne) {
            return Q(K[ae][1][ne] || ne);
          }, q, q.exports, B, K, X, Y);
        }
        return X[ae].exports;
      }
      for (var J = typeof _dereq_ == "function" && _dereq_, ee = 0; ee < Y.length; ee++)
        Q(Y[ee]);
      return Q;
    }({ 1: [function(B, K, X) {
      K.exports = function(Y) {
        var Q = Y._SomePromiseArray;
        function J(ee) {
          var ae = new Q(ee), re = ae.promise();
          return ae.setHowMany(1), ae.setUnwrap(), ae.init(), re;
        }
        Y.any = function(ee) {
          return J(ee);
        }, Y.prototype.any = function() {
          return J(this);
        };
      };
    }, {}], 2: [function(B, K, X) {
      var Y;
      try {
        throw new Error();
      } catch (q) {
        Y = q;
      }
      var Q = B("./schedule"), J = B("./queue"), ee = B("./util");
      function ae() {
        this._customScheduler = !1, this._isTickUsed = !1, this._lateQueue = new J(16), this._normalQueue = new J(16), this._haveDrainedQueues = !1, this._trampolineEnabled = !0;
        var q = this;
        this.drainQueues = function() {
          q._drainQueues();
        }, this._schedule = Q;
      }
      function re(q, ne, ce) {
        this._lateQueue.push(q, ne, ce), this._queueTick();
      }
      function ie(q, ne, ce) {
        this._normalQueue.push(q, ne, ce), this._queueTick();
      }
      function ue(q) {
        this._normalQueue._pushOne(q), this._queueTick();
      }
      ae.prototype.setScheduler = function(q) {
        var ne = this._schedule;
        return this._schedule = q, this._customScheduler = !0, ne;
      }, ae.prototype.hasCustomScheduler = function() {
        return this._customScheduler;
      }, ae.prototype.enableTrampoline = function() {
        this._trampolineEnabled = !0;
      }, ae.prototype.disableTrampolineIfNecessary = function() {
        ee.hasDevTools && (this._trampolineEnabled = !1);
      }, ae.prototype.haveItemsQueued = function() {
        return this._isTickUsed || this._haveDrainedQueues;
      }, ae.prototype.fatalError = function(q, ne) {
        ne ? (F.stderr.write("Fatal " + (q instanceof Error ? q.stack : q) + `
`), F.exit(2)) : this.throwLater(q);
      }, ae.prototype.throwLater = function(q, ne) {
        if (arguments.length === 1 && (ne = q, q = function() {
          throw ne;
        }), typeof setTimeout < "u")
          setTimeout(function() {
            q(ne);
          }, 0);
        else
          try {
            this._schedule(function() {
              q(ne);
            });
          } catch {
            throw new Error(`No async scheduler available

    See http://goo.gl/MqrFmX
`);
          }
      }, ee.hasDevTools ? (ae.prototype.invokeLater = function(q, ne, ce) {
        this._trampolineEnabled ? re.call(this, q, ne, ce) : this._schedule(function() {
          setTimeout(function() {
            q.call(ne, ce);
          }, 100);
        });
      }, ae.prototype.invoke = function(q, ne, ce) {
        this._trampolineEnabled ? ie.call(this, q, ne, ce) : this._schedule(function() {
          q.call(ne, ce);
        });
      }, ae.prototype.settlePromises = function(q) {
        this._trampolineEnabled ? ue.call(this, q) : this._schedule(function() {
          q._settlePromises();
        });
      }) : (ae.prototype.invokeLater = re, ae.prototype.invoke = ie, ae.prototype.settlePromises = ue), ae.prototype._drainQueue = function(q) {
        for (; q.length() > 0; ) {
          var ne = q.shift();
          if (typeof ne == "function") {
            var ce = q.shift(), he = q.shift();
            ne.call(ce, he);
          } else
            ne._settlePromises();
        }
      }, ae.prototype._drainQueues = function() {
        this._drainQueue(this._normalQueue), this._reset(), this._haveDrainedQueues = !0, this._drainQueue(this._lateQueue);
      }, ae.prototype._queueTick = function() {
        this._isTickUsed || (this._isTickUsed = !0, this._schedule(this.drainQueues));
      }, ae.prototype._reset = function() {
        this._isTickUsed = !1;
      }, K.exports = ae, K.exports.firstLineError = Y;
    }, { "./queue": 26, "./schedule": 29, "./util": 36 }], 3: [function(B, K, X) {
      K.exports = function(Y, Q, J, ee) {
        var ae = !1, re = function(ne, ce) {
          this._reject(ce);
        }, ie = function(ne, ce) {
          ce.promiseRejectionQueued = !0, ce.bindingPromise._then(re, re, null, this, ne);
        }, ue = function(ne, ce) {
          !(50397184 & this._bitField) && this._resolveCallback(ce.target);
        }, q = function(ne, ce) {
          ce.promiseRejectionQueued || this._reject(ne);
        };
        Y.prototype.bind = function(ne) {
          ae || (ae = !0, Y.prototype._propagateFrom = ee.propagateFromFunction(), Y.prototype._boundValue = ee.boundValueFunction());
          var ce = J(ne), he = new Y(Q);
          he._propagateFrom(this, 1);
          var we = this._target();
          if (he._setBoundTo(ce), ce instanceof Y) {
            var me = { promiseRejectionQueued: !1, promise: he, target: we, bindingPromise: ce };
            we._then(Q, ie, void 0, he, me), ce._then(ue, q, void 0, he, me), he._setOnCancel(ce);
          } else
            he._resolveCallback(we);
          return he;
        }, Y.prototype._setBoundTo = function(ne) {
          ne !== void 0 ? (this._bitField = 2097152 | this._bitField, this._boundTo = ne) : this._bitField = -2097153 & this._bitField;
        }, Y.prototype._isBound = function() {
          return (2097152 & this._bitField) == 2097152;
        }, Y.bind = function(ne, ce) {
          return Y.resolve(ce).bind(ne);
        };
      };
    }, {}], 4: [function(B, K, X) {
      var Y;
      typeof Promise < "u" && (Y = Promise);
      var Q = B("./promise")();
      Q.noConflict = function() {
        try {
          Promise === Q && (Promise = Y);
        } catch {
        }
        return Q;
      }, K.exports = Q;
    }, { "./promise": 22 }], 5: [function(B, K, X) {
      var Y = Object.create;
      if (Y) {
        var Q = Y(null), J = Y(null);
        Q[" size"] = J[" size"] = 0;
      }
      K.exports = function(ee) {
        var ae = B("./util"), re = ae.canEvaluate;
        function ie(ne) {
          return function(ce, he) {
            var we;
            if (ce != null && (we = ce[he]), typeof we != "function") {
              var me = "Object " + ae.classString(ce) + " has no method '" + ae.toString(he) + "'";
              throw new ee.TypeError(me);
            }
            return we;
          }(ne, this.pop()).apply(ne, this);
        }
        function ue(ne) {
          return ne[this];
        }
        function q(ne) {
          var ce = +this;
          return ce < 0 && (ce = Math.max(0, ce + ne.length)), ne[ce];
        }
        ae.isIdentifier, ee.prototype.call = function(ne) {
          var ce = [].slice.call(arguments, 1);
          return ce.push(ne), this._then(ie, void 0, void 0, ce, void 0);
        }, ee.prototype.get = function(ne) {
          var ce;
          if (typeof ne == "number")
            ce = q;
          else if (re) {
            var he = (void 0)(ne);
            ce = he !== null ? he : ue;
          } else
            ce = ue;
          return this._then(ce, void 0, void 0, ne, void 0);
        };
      };
    }, { "./util": 36 }], 6: [function(B, K, X) {
      K.exports = function(Y, Q, J, ee) {
        var ae = B("./util"), re = ae.tryCatch, ie = ae.errorObj, ue = Y._async;
        Y.prototype.break = Y.prototype.cancel = function() {
          if (!ee.cancellation())
            return this._warn("cancellation is disabled");
          for (var q = this, ne = q; q._isCancellable(); ) {
            if (!q._cancelBy(ne)) {
              ne._isFollowing() ? ne._followee().cancel() : ne._cancelBranched();
              break;
            }
            var ce = q._cancellationParent;
            if (ce == null || !ce._isCancellable()) {
              q._isFollowing() ? q._followee().cancel() : q._cancelBranched();
              break;
            }
            q._isFollowing() && q._followee().cancel(), q._setWillBeCancelled(), ne = q, q = ce;
          }
        }, Y.prototype._branchHasCancelled = function() {
          this._branchesRemainingToCancel--;
        }, Y.prototype._enoughBranchesHaveCancelled = function() {
          return this._branchesRemainingToCancel === void 0 || this._branchesRemainingToCancel <= 0;
        }, Y.prototype._cancelBy = function(q) {
          return q === this ? (this._branchesRemainingToCancel = 0, this._invokeOnCancel(), !0) : (this._branchHasCancelled(), !!this._enoughBranchesHaveCancelled() && (this._invokeOnCancel(), !0));
        }, Y.prototype._cancelBranched = function() {
          this._enoughBranchesHaveCancelled() && this._cancel();
        }, Y.prototype._cancel = function() {
          this._isCancellable() && (this._setCancelled(), ue.invoke(this._cancelPromises, this, void 0));
        }, Y.prototype._cancelPromises = function() {
          this._length() > 0 && this._settlePromises();
        }, Y.prototype._unsetOnCancel = function() {
          this._onCancelField = void 0;
        }, Y.prototype._isCancellable = function() {
          return this.isPending() && !this._isCancelled();
        }, Y.prototype.isCancellable = function() {
          return this.isPending() && !this.isCancelled();
        }, Y.prototype._doInvokeOnCancel = function(q, ne) {
          if (ae.isArray(q))
            for (var ce = 0; ce < q.length; ++ce)
              this._doInvokeOnCancel(q[ce], ne);
          else if (q !== void 0)
            if (typeof q == "function") {
              if (!ne) {
                var he = re(q).call(this._boundValue());
                he === ie && (this._attachExtraTrace(he.e), ue.throwLater(he.e));
              }
            } else
              q._resultCancelled(this);
        }, Y.prototype._invokeOnCancel = function() {
          var q = this._onCancel();
          this._unsetOnCancel(), ue.invoke(this._doInvokeOnCancel, this, q);
        }, Y.prototype._invokeInternalOnCancel = function() {
          this._isCancellable() && (this._doInvokeOnCancel(this._onCancel(), !0), this._unsetOnCancel());
        }, Y.prototype._resultCancelled = function() {
          this.cancel();
        };
      };
    }, { "./util": 36 }], 7: [function(B, K, X) {
      K.exports = function(Y) {
        var Q = B("./util"), J = B("./es5").keys, ee = Q.tryCatch, ae = Q.errorObj;
        return function(re, ie, ue) {
          return function(q) {
            var ne = ue._boundValue();
            e:
              for (var ce = 0; ce < re.length; ++ce) {
                var he = re[ce];
                if (he === Error || he != null && he.prototype instanceof Error) {
                  if (q instanceof he)
                    return ee(ie).call(ne, q);
                } else if (typeof he == "function") {
                  var we = ee(he).call(ne, q);
                  if (we === ae)
                    return we;
                  if (we)
                    return ee(ie).call(ne, q);
                } else if (Q.isObject(q)) {
                  for (var me = J(he), de = 0; de < me.length; ++de) {
                    var be = me[de];
                    if (he[be] != q[be])
                      continue e;
                  }
                  return ee(ie).call(ne, q);
                }
              }
            return Y;
          };
        };
      };
    }, { "./es5": 13, "./util": 36 }], 8: [function(B, K, X) {
      K.exports = function(Y) {
        var Q = !1, J = [];
        function ee() {
          this._trace = new ee.CapturedTrace(ae());
        }
        function ae() {
          var re = J.length - 1;
          if (re >= 0)
            return J[re];
        }
        return Y.prototype._promiseCreated = function() {
        }, Y.prototype._pushContext = function() {
        }, Y.prototype._popContext = function() {
          return null;
        }, Y._peekContext = Y.prototype._peekContext = function() {
        }, ee.prototype._pushContext = function() {
          this._trace !== void 0 && (this._trace._promiseCreated = null, J.push(this._trace));
        }, ee.prototype._popContext = function() {
          if (this._trace !== void 0) {
            var re = J.pop(), ie = re._promiseCreated;
            return re._promiseCreated = null, ie;
          }
          return null;
        }, ee.CapturedTrace = null, ee.create = function() {
          if (Q)
            return new ee();
        }, ee.deactivateLongStackTraces = function() {
        }, ee.activateLongStackTraces = function() {
          var re = Y.prototype._pushContext, ie = Y.prototype._popContext, ue = Y._peekContext, q = Y.prototype._peekContext, ne = Y.prototype._promiseCreated;
          ee.deactivateLongStackTraces = function() {
            Y.prototype._pushContext = re, Y.prototype._popContext = ie, Y._peekContext = ue, Y.prototype._peekContext = q, Y.prototype._promiseCreated = ne, Q = !1;
          }, Q = !0, Y.prototype._pushContext = ee.prototype._pushContext, Y.prototype._popContext = ee.prototype._popContext, Y._peekContext = Y.prototype._peekContext = ae, Y.prototype._promiseCreated = function() {
            var ce = this._peekContext();
            ce && ce._promiseCreated == null && (ce._promiseCreated = this);
          };
        }, ee;
      };
    }, {}], 9: [function(B, K, X) {
      K.exports = function(Y, Q) {
        var J, ee, ae, re = Y._getDomain, ie = Y._async, ue = B("./errors").Warning, q = B("./util"), ne = q.canAttachTrace, ce = /[\\\/]bluebird[\\\/]js[\\\/](release|debug|instrumented)/, he = /\((?:timers\.js):\d+:\d+\)/, we = /[\/<\(](.+?):(\d+):(\d+)\)?\s*$/, me = null, de = null, be = !1, _e = q.env("BLUEBIRD_DEBUG") != 0, Me = !(q.env("BLUEBIRD_WARNINGS") == 0 || !_e && !q.env("BLUEBIRD_WARNINGS")), Ne = !(q.env("BLUEBIRD_LONG_STACK_TRACES") == 0 || !_e && !q.env("BLUEBIRD_LONG_STACK_TRACES")), Ee = q.env("BLUEBIRD_W_FORGOTTEN_RETURN") != 0 && (Me || !!q.env("BLUEBIRD_W_FORGOTTEN_RETURN"));
        Y.prototype.suppressUnhandledRejections = function() {
          var Ue = this._target();
          Ue._bitField = -1048577 & Ue._bitField | 524288;
        }, Y.prototype._ensurePossibleRejectionHandled = function() {
          if (!(524288 & this._bitField)) {
            this._setRejectionIsUnhandled();
            var Ue = this;
            setTimeout(function() {
              Ue._notifyUnhandledRejection();
            }, 1);
          }
        }, Y.prototype._notifyUnhandledRejectionIsHandled = function() {
          Pe("rejectionHandled", J, void 0, this);
        }, Y.prototype._setReturnedNonUndefined = function() {
          this._bitField = 268435456 | this._bitField;
        }, Y.prototype._returnedNonUndefined = function() {
          return (268435456 & this._bitField) != 0;
        }, Y.prototype._notifyUnhandledRejection = function() {
          if (this._isRejectionUnhandled()) {
            var Ue = this._settledValue();
            this._setUnhandledRejectionIsNotified(), Pe("unhandledRejection", ee, Ue, this);
          }
        }, Y.prototype._setUnhandledRejectionIsNotified = function() {
          this._bitField = 262144 | this._bitField;
        }, Y.prototype._unsetUnhandledRejectionIsNotified = function() {
          this._bitField = -262145 & this._bitField;
        }, Y.prototype._isUnhandledRejectionNotified = function() {
          return (262144 & this._bitField) > 0;
        }, Y.prototype._setRejectionIsUnhandled = function() {
          this._bitField = 1048576 | this._bitField;
        }, Y.prototype._unsetRejectionIsUnhandled = function() {
          this._bitField = -1048577 & this._bitField, this._isUnhandledRejectionNotified() && (this._unsetUnhandledRejectionIsNotified(), this._notifyUnhandledRejectionIsHandled());
        }, Y.prototype._isRejectionUnhandled = function() {
          return (1048576 & this._bitField) > 0;
        }, Y.prototype._warn = function(Ue, Ye, He) {
          return ge(Ue, Ye, He || this);
        }, Y.onPossiblyUnhandledRejection = function(Ue) {
          var Ye = re();
          ee = typeof Ue == "function" ? Ye === null ? Ue : q.domainBind(Ye, Ue) : void 0;
        }, Y.onUnhandledRejectionHandled = function(Ue) {
          var Ye = re();
          J = typeof Ue == "function" ? Ye === null ? Ue : q.domainBind(Ye, Ue) : void 0;
        };
        var $e = function() {
        };
        Y.longStackTraces = function() {
          if (ie.haveItemsQueued() && !st.longStackTraces)
            throw new Error(`cannot enable long stack traces after promises have been created

    See http://goo.gl/MqrFmX
`);
          if (!st.longStackTraces && Qe()) {
            var Ue = Y.prototype._captureStackTrace, Ye = Y.prototype._attachExtraTrace;
            st.longStackTraces = !0, $e = function() {
              if (ie.haveItemsQueued() && !st.longStackTraces)
                throw new Error(`cannot enable long stack traces after promises have been created

    See http://goo.gl/MqrFmX
`);
              Y.prototype._captureStackTrace = Ue, Y.prototype._attachExtraTrace = Ye, Q.deactivateLongStackTraces(), ie.enableTrampoline(), st.longStackTraces = !1;
            }, Y.prototype._captureStackTrace = te, Y.prototype._attachExtraTrace = le, Q.activateLongStackTraces(), ie.disableTrampolineIfNecessary();
          }
        }, Y.hasLongStackTraces = function() {
          return st.longStackTraces && Qe();
        };
        var De = function() {
          try {
            if (typeof CustomEvent == "function") {
              var Ue = new CustomEvent("CustomEvent");
              return q.global.dispatchEvent(Ue), function(Ye, He) {
                var Ke = new CustomEvent(Ye.toLowerCase(), { detail: He, cancelable: !0 });
                return !q.global.dispatchEvent(Ke);
              };
            }
            return typeof Event == "function" ? (Ue = new Event("CustomEvent"), q.global.dispatchEvent(Ue), function(Ye, He) {
              var Ke = new Event(Ye.toLowerCase(), { cancelable: !0 });
              return Ke.detail = He, !q.global.dispatchEvent(Ke);
            }) : ((Ue = document.createEvent("CustomEvent")).initCustomEvent("testingtheevent", !1, !0, {}), q.global.dispatchEvent(Ue), function(Ye, He) {
              var Ke = document.createEvent("CustomEvent");
              return Ke.initCustomEvent(Ye.toLowerCase(), !1, !0, He), !q.global.dispatchEvent(Ke);
            });
          } catch {
          }
          return function() {
            return !1;
          };
        }(), Fe = q.isNode ? function() {
          return F.emit.apply(F, arguments);
        } : q.global ? function(Ue) {
          var Ye = "on" + Ue.toLowerCase(), He = q.global[Ye];
          return !!He && (He.apply(q.global, [].slice.call(arguments, 1)), !0);
        } : function() {
          return !1;
        };
        function Be(Ue, Ye) {
          return { promise: Ye };
        }
        var We = { promiseCreated: Be, promiseFulfilled: Be, promiseRejected: Be, promiseResolved: Be, promiseCancelled: Be, promiseChained: function(Ue, Ye, He) {
          return { promise: Ye, child: He };
        }, warning: function(Ue, Ye) {
          return { warning: Ye };
        }, unhandledRejection: function(Ue, Ye, He) {
          return { reason: Ye, promise: He };
        }, rejectionHandled: Be }, Ve = function(Ue) {
          var Ye = !1;
          try {
            Ye = Fe.apply(null, arguments);
          } catch (Ke) {
            ie.throwLater(Ke), Ye = !0;
          }
          var He = !1;
          try {
            He = De(Ue, We[Ue].apply(null, arguments));
          } catch (Ke) {
            ie.throwLater(Ke), He = !0;
          }
          return He || Ye;
        };
        function ze() {
          return !1;
        }
        function ke(Ue, Ye, He) {
          var Ke = this;
          try {
            Ue(Ye, He, function(tt) {
              if (typeof tt != "function")
                throw new TypeError("onCancel must be a function, got: " + q.toString(tt));
              Ke._attachCancellationCallback(tt);
            });
          } catch (tt) {
            return tt;
          }
        }
        function je(Ue) {
          if (!this._isCancellable())
            return this;
          var Ye = this._onCancel();
          Ye !== void 0 ? q.isArray(Ye) ? Ye.push(Ue) : this._setOnCancel([Ye, Ue]) : this._setOnCancel(Ue);
        }
        function Ie() {
          return this._onCancelField;
        }
        function ve(Ue) {
          this._onCancelField = Ue;
        }
        function xe() {
          this._cancellationParent = void 0, this._onCancelField = void 0;
        }
        function Oe(Ue, Ye) {
          if (1 & Ye) {
            this._cancellationParent = Ue;
            var He = Ue._branchesRemainingToCancel;
            He === void 0 && (He = 0), Ue._branchesRemainingToCancel = He + 1;
          }
          2 & Ye && Ue._isBound() && this._setBoundTo(Ue._boundTo);
        }
        Y.config = function(Ue) {
          if ("longStackTraces" in (Ue = Object(Ue)) && (Ue.longStackTraces ? Y.longStackTraces() : !Ue.longStackTraces && Y.hasLongStackTraces() && $e()), "warnings" in Ue) {
            var Ye = Ue.warnings;
            st.warnings = !!Ye, Ee = st.warnings, q.isObject(Ye) && "wForgottenReturn" in Ye && (Ee = !!Ye.wForgottenReturn);
          }
          if ("cancellation" in Ue && Ue.cancellation && !st.cancellation) {
            if (ie.haveItemsQueued())
              throw new Error("cannot enable cancellation after promises are in use");
            Y.prototype._clearCancellationData = xe, Y.prototype._propagateFrom = Oe, Y.prototype._onCancel = Ie, Y.prototype._setOnCancel = ve, Y.prototype._attachCancellationCallback = je, Y.prototype._execute = ke, Te = Oe, st.cancellation = !0;
          }
          return "monitoring" in Ue && (Ue.monitoring && !st.monitoring ? (st.monitoring = !0, Y.prototype._fireEvent = Ve) : !Ue.monitoring && st.monitoring && (st.monitoring = !1, Y.prototype._fireEvent = ze)), Y;
        }, Y.prototype._fireEvent = ze, Y.prototype._execute = function(Ue, Ye, He) {
          try {
            Ue(Ye, He);
          } catch (Ke) {
            return Ke;
          }
        }, Y.prototype._onCancel = function() {
        }, Y.prototype._setOnCancel = function(Ue) {
        }, Y.prototype._attachCancellationCallback = function(Ue) {
        }, Y.prototype._captureStackTrace = function() {
        }, Y.prototype._attachExtraTrace = function() {
        }, Y.prototype._clearCancellationData = function() {
        }, Y.prototype._propagateFrom = function(Ue, Ye) {
        };
        var Te = function(Ue, Ye) {
          2 & Ye && Ue._isBound() && this._setBoundTo(Ue._boundTo);
        };
        function Ce() {
          var Ue = this._boundTo;
          return Ue !== void 0 && Ue instanceof Y ? Ue.isFulfilled() ? Ue.value() : void 0 : Ue;
        }
        function te() {
          this._trace = new at(this._peekContext());
        }
        function le(Ue, Ye) {
          if (ne(Ue)) {
            var He = this._trace;
            if (He !== void 0 && Ye && (He = He._parent), He !== void 0)
              He.attachExtraTrace(Ue);
            else if (!Ue.__stackCleaned__) {
              var Ke = fe(Ue);
              q.notEnumerableProp(Ue, "stack", Ke.message + `
` + Ke.stack.join(`
`)), q.notEnumerableProp(Ue, "__stackCleaned__", !0);
            }
          }
        }
        function ge(Ue, Ye, He) {
          if (st.warnings) {
            var Ke, tt = new ue(Ue);
            if (Ye)
              He._attachExtraTrace(tt);
            else if (st.longStackTraces && (Ke = Y._peekContext()))
              Ke.attachExtraTrace(tt);
            else {
              var Je = fe(tt);
              tt.stack = Je.message + `
` + Je.stack.join(`
`);
            }
            Ve("warning", tt) || Se(tt, "", !0);
          }
        }
        function pe(Ue) {
          for (var Ye = [], He = 0; He < Ue.length; ++He) {
            var Ke = Ue[He], tt = Ke === "    (No stack trace)" || me.test(Ke), Je = tt && et(Ke);
            tt && !Je && (be && Ke.charAt(0) !== " " && (Ke = "    " + Ke), Ye.push(Ke));
          }
          return Ye;
        }
        function fe(Ue) {
          var Ye = Ue.stack, He = Ue.toString();
          return Ye = typeof Ye == "string" && Ye.length > 0 ? function(Ke) {
            for (var tt = Ke.stack.replace(/\s+$/g, "").split(`
`), Je = 0; Je < tt.length; ++Je) {
              var qe = tt[Je];
              if (qe === "    (No stack trace)" || me.test(qe))
                break;
            }
            return Je > 0 && Ke.name != "SyntaxError" && (tt = tt.slice(Je)), tt;
          }(Ue) : ["    (No stack trace)"], { message: He, stack: Ue.name == "SyntaxError" ? Ye : pe(Ye) };
        }
        function Se(Ue, Ye, He) {
          if (typeof console < "u") {
            var Ke;
            if (q.isObject(Ue)) {
              var tt = Ue.stack;
              Ke = Ye + de(tt, Ue);
            } else
              Ke = Ye + String(Ue);
            typeof ae == "function" ? ae(Ke, He) : typeof console.log != "function" && typeof console.log != "object" || console.log(Ke);
          }
        }
        function Pe(Ue, Ye, He, Ke) {
          var tt = !1;
          try {
            typeof Ye == "function" && (tt = !0, Ue === "rejectionHandled" ? Ye(Ke) : Ye(He, Ke));
          } catch (Je) {
            ie.throwLater(Je);
          }
          Ue === "unhandledRejection" ? Ve(Ue, He, Ke) || tt || Se(He, "Unhandled rejection ") : Ve(Ue, Ke);
        }
        function Ge(Ue) {
          var Ye;
          if (typeof Ue == "function")
            Ye = "[function " + (Ue.name || "anonymous") + "]";
          else {
            if (Ye = Ue && typeof Ue.toString == "function" ? Ue.toString() : q.toString(Ue), /\[object [a-zA-Z0-9$_]+\]/.test(Ye))
              try {
                Ye = JSON.stringify(Ue);
              } catch {
              }
            Ye.length === 0 && (Ye = "(empty array)");
          }
          return "(<" + function(He) {
            return He.length < 41 ? He : He.substr(0, 38) + "...";
          }(Ye) + ">, no stack trace)";
        }
        function Qe() {
          return typeof dt == "function";
        }
        var et = function() {
          return !1;
        }, rt = /[\/<\(]([^:\/]+):(\d+):(?:\d+)\)?\s*$/;
        function Xe(Ue) {
          var Ye = Ue.match(rt);
          if (Ye)
            return { fileName: Ye[1], line: parseInt(Ye[2], 10) };
        }
        function at(Ue) {
          this._parent = Ue, this._promisesCreated = 0;
          var Ye = this._length = 1 + (Ue === void 0 ? 0 : Ue._length);
          dt(this, at), Ye > 32 && this.uncycle();
        }
        q.inherits(at, Error), Q.CapturedTrace = at, at.prototype.uncycle = function() {
          var Ue = this._length;
          if (!(Ue < 2)) {
            for (var Ye = [], He = {}, Ke = 0, tt = this; tt !== void 0; ++Ke)
              Ye.push(tt), tt = tt._parent;
            for (Ke = (Ue = this._length = Ke) - 1; Ke >= 0; --Ke) {
              var Je = Ye[Ke].stack;
              He[Je] === void 0 && (He[Je] = Ke);
            }
            for (Ke = 0; Ke < Ue; ++Ke) {
              var qe = He[Ye[Ke].stack];
              if (qe !== void 0 && qe !== Ke) {
                qe > 0 && (Ye[qe - 1]._parent = void 0, Ye[qe - 1]._length = 1), Ye[Ke]._parent = void 0, Ye[Ke]._length = 1;
                var ye = Ke > 0 ? Ye[Ke - 1] : this;
                qe < Ue - 1 ? (ye._parent = Ye[qe + 1], ye._parent.uncycle(), ye._length = ye._parent._length + 1) : (ye._parent = void 0, ye._length = 1);
                for (var se = ye._length + 1, oe = Ke - 2; oe >= 0; --oe)
                  Ye[oe]._length = se, se++;
                return;
              }
            }
          }
        }, at.prototype.attachExtraTrace = function(Ue) {
          if (!Ue.__stackCleaned__) {
            this.uncycle();
            for (var Ye = fe(Ue), He = Ye.message, Ke = [Ye.stack], tt = this; tt !== void 0; )
              Ke.push(pe(tt.stack.split(`
`))), tt = tt._parent;
            (function(Je) {
              for (var qe = Je[0], ye = 1; ye < Je.length; ++ye) {
                for (var se = Je[ye], oe = qe.length - 1, Le = qe[oe], Ae = -1, Re = se.length - 1; Re >= 0; --Re)
                  if (se[Re] === Le) {
                    Ae = Re;
                    break;
                  }
                for (Re = Ae; Re >= 0; --Re) {
                  var Ze = se[Re];
                  if (qe[oe] !== Ze)
                    break;
                  qe.pop(), oe--;
                }
                qe = se;
              }
            })(Ke), function(Je) {
              for (var qe = 0; qe < Je.length; ++qe)
                (Je[qe].length === 0 || qe + 1 < Je.length && Je[qe][0] === Je[qe + 1][0]) && (Je.splice(qe, 1), qe--);
            }(Ke), q.notEnumerableProp(Ue, "stack", function(Je, qe) {
              for (var ye = 0; ye < qe.length - 1; ++ye)
                qe[ye].push("From previous event:"), qe[ye] = qe[ye].join(`
`);
              return ye < qe.length && (qe[ye] = qe[ye].join(`
`)), Je + `
` + qe.join(`
`);
            }(He, Ke)), q.notEnumerableProp(Ue, "__stackCleaned__", !0);
          }
        };
        var dt = function() {
          var Ue = /^\s*at\s*/, Ye = function(Je, qe) {
            return typeof Je == "string" ? Je : qe.name !== void 0 && qe.message !== void 0 ? qe.toString() : Ge(qe);
          };
          if (typeof Error.stackTraceLimit == "number" && typeof Error.captureStackTrace == "function") {
            Error.stackTraceLimit += 6, me = Ue, de = Ye;
            var He = Error.captureStackTrace;
            return et = function(Je) {
              return ce.test(Je);
            }, function(Je, qe) {
              Error.stackTraceLimit += 6, He(Je, qe), Error.stackTraceLimit -= 6;
            };
          }
          var Ke, tt = new Error();
          if (typeof tt.stack == "string" && tt.stack.split(`
`)[0].indexOf("stackDetection@") >= 0)
            return me = /@/, de = Ye, be = !0, function(Je) {
              Je.stack = new Error().stack;
            };
          try {
            throw new Error();
          } catch (Je) {
            Ke = "stack" in Je;
          }
          return "stack" in tt || !Ke || typeof Error.stackTraceLimit != "number" ? (de = function(Je, qe) {
            return typeof Je == "string" ? Je : typeof qe != "object" && typeof qe != "function" || qe.name === void 0 || qe.message === void 0 ? Ge(qe) : qe.toString();
          }, null) : (me = Ue, de = Ye, function(Je) {
            Error.stackTraceLimit += 6;
            try {
              throw new Error();
            } catch (qe) {
              Je.stack = qe.stack;
            }
            Error.stackTraceLimit -= 6;
          });
        }();
        typeof console < "u" && console.warn !== void 0 && (ae = function(Ue) {
          console.warn(Ue);
        }, q.isNode && F.stderr.isTTY ? ae = function(Ue, Ye) {
          var He = Ye ? "\x1B[33m" : "\x1B[31m";
          console.warn(He + Ue + `\x1B[0m
`);
        } : q.isNode || typeof new Error().stack != "string" || (ae = function(Ue, Ye) {
          console.warn("%c" + Ue, Ye ? "color: darkorange" : "color: red");
        }));
        var st = { warnings: Me, longStackTraces: !1, cancellation: !1, monitoring: !1 };
        return Ne && Y.longStackTraces(), { longStackTraces: function() {
          return st.longStackTraces;
        }, warnings: function() {
          return st.warnings;
        }, cancellation: function() {
          return st.cancellation;
        }, monitoring: function() {
          return st.monitoring;
        }, propagateFromFunction: function() {
          return Te;
        }, boundValueFunction: function() {
          return Ce;
        }, checkForgottenReturns: function(Ue, Ye, He, Ke, tt) {
          if (Ue === void 0 && Ye !== null && Ee) {
            if (tt !== void 0 && tt._returnedNonUndefined() || !(65535 & Ke._bitField))
              return;
            He && (He += " ");
            var Je = "", qe = "";
            if (Ye._trace) {
              for (var ye = Ye._trace.stack.split(`
`), se = pe(ye), oe = se.length - 1; oe >= 0; --oe) {
                var Le = se[oe];
                if (!he.test(Le)) {
                  var Ae = Le.match(we);
                  Ae && (Je = "at " + Ae[1] + ":" + Ae[2] + ":" + Ae[3] + " ");
                  break;
                }
              }
              if (se.length > 0) {
                var Re = se[0];
                for (oe = 0; oe < ye.length; ++oe)
                  if (ye[oe] === Re) {
                    oe > 0 && (qe = `
` + ye[oe - 1]);
                    break;
                  }
              }
            }
            var Ze = "a promise was created in a " + He + "handler " + Je + "but was not returned from it, see http://goo.gl/rRqMUw" + qe;
            Ke._warn(Ze, !0, Ye);
          }
        }, setBounds: function(Ue, Ye) {
          if (Qe()) {
            for (var He, Ke, tt = Ue.stack.split(`
`), Je = Ye.stack.split(`
`), qe = -1, ye = -1, se = 0; se < tt.length; ++se)
              if (oe = Xe(tt[se])) {
                He = oe.fileName, qe = oe.line;
                break;
              }
            for (se = 0; se < Je.length; ++se) {
              var oe;
              if (oe = Xe(Je[se])) {
                Ke = oe.fileName, ye = oe.line;
                break;
              }
            }
            qe < 0 || ye < 0 || !He || !Ke || He !== Ke || qe >= ye || (et = function(Le) {
              if (ce.test(Le))
                return !0;
              var Ae = Xe(Le);
              return !!(Ae && Ae.fileName === He && qe <= Ae.line && Ae.line <= ye);
            });
          }
        }, warn: ge, deprecated: function(Ue, Ye) {
          var He = Ue + " is deprecated and will be removed in a future version.";
          return Ye && (He += " Use " + Ye + " instead."), ge(He);
        }, CapturedTrace: at, fireDomEvent: De, fireGlobalEvent: Fe };
      };
    }, { "./errors": 12, "./util": 36 }], 10: [function(B, K, X) {
      K.exports = function(Y) {
        function Q() {
          return this.value;
        }
        function J() {
          throw this.reason;
        }
        Y.prototype.return = Y.prototype.thenReturn = function(ee) {
          return ee instanceof Y && ee.suppressUnhandledRejections(), this._then(Q, void 0, void 0, { value: ee }, void 0);
        }, Y.prototype.throw = Y.prototype.thenThrow = function(ee) {
          return this._then(J, void 0, void 0, { reason: ee }, void 0);
        }, Y.prototype.catchThrow = function(ee) {
          if (arguments.length <= 1)
            return this._then(void 0, J, void 0, { reason: ee }, void 0);
          var ae = arguments[1];
          return this.caught(ee, function() {
            throw ae;
          });
        }, Y.prototype.catchReturn = function(ee) {
          if (arguments.length <= 1)
            return ee instanceof Y && ee.suppressUnhandledRejections(), this._then(void 0, Q, void 0, { value: ee }, void 0);
          var ae = arguments[1];
          return ae instanceof Y && ae.suppressUnhandledRejections(), this.caught(ee, function() {
            return ae;
          });
        };
      };
    }, {}], 11: [function(B, K, X) {
      K.exports = function(Y, Q) {
        var J = Y.reduce, ee = Y.all;
        function ae() {
          return ee(this);
        }
        Y.prototype.each = function(re) {
          return J(this, re, Q, 0)._then(ae, void 0, void 0, this, void 0);
        }, Y.prototype.mapSeries = function(re) {
          return J(this, re, Q, Q);
        }, Y.each = function(re, ie) {
          return J(re, ie, Q, 0)._then(ae, void 0, void 0, re, void 0);
        }, Y.mapSeries = function(re, ie) {
          return J(re, ie, Q, Q);
        };
      };
    }, {}], 12: [function(B, K, X) {
      var Y, Q, J = B("./es5"), ee = J.freeze, ae = B("./util"), re = ae.inherits, ie = ae.notEnumerableProp;
      function ue(Me, Ne) {
        function Ee($e) {
          if (!(this instanceof Ee))
            return new Ee($e);
          ie(this, "message", typeof $e == "string" ? $e : Ne), ie(this, "name", Me), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : Error.call(this);
        }
        return re(Ee, Error), Ee;
      }
      var q = ue("Warning", "warning"), ne = ue("CancellationError", "cancellation error"), ce = ue("TimeoutError", "timeout error"), he = ue("AggregateError", "aggregate error");
      try {
        Y = TypeError, Q = RangeError;
      } catch {
        Y = ue("TypeError", "type error"), Q = ue("RangeError", "range error");
      }
      for (var we = "join pop push shift unshift slice filter forEach some every map indexOf lastIndexOf reduce reduceRight sort reverse".split(" "), me = 0; me < we.length; ++me)
        typeof Array.prototype[we[me]] == "function" && (he.prototype[we[me]] = Array.prototype[we[me]]);
      J.defineProperty(he.prototype, "length", { value: 0, configurable: !1, writable: !0, enumerable: !0 }), he.prototype.isOperational = !0;
      var de = 0;
      function be(Me) {
        if (!(this instanceof be))
          return new be(Me);
        ie(this, "name", "OperationalError"), ie(this, "message", Me), this.cause = Me, this.isOperational = !0, Me instanceof Error ? (ie(this, "message", Me.message), ie(this, "stack", Me.stack)) : Error.captureStackTrace && Error.captureStackTrace(this, this.constructor);
      }
      he.prototype.toString = function() {
        var Me = Array(4 * de + 1).join(" "), Ne = `
` + Me + `AggregateError of:
`;
        de++, Me = Array(4 * de + 1).join(" ");
        for (var Ee = 0; Ee < this.length; ++Ee) {
          for (var $e = this[Ee] === this ? "[Circular AggregateError]" : this[Ee] + "", De = $e.split(`
`), Fe = 0; Fe < De.length; ++Fe)
            De[Fe] = Me + De[Fe];
          Ne += ($e = De.join(`
`)) + `
`;
        }
        return de--, Ne;
      }, re(be, Error);
      var _e = Error.__BluebirdErrorTypes__;
      _e || (_e = ee({ CancellationError: ne, TimeoutError: ce, OperationalError: be, RejectionError: be, AggregateError: he }), J.defineProperty(Error, "__BluebirdErrorTypes__", { value: _e, writable: !1, enumerable: !1, configurable: !1 })), K.exports = { Error, TypeError: Y, RangeError: Q, CancellationError: _e.CancellationError, OperationalError: _e.OperationalError, TimeoutError: _e.TimeoutError, AggregateError: _e.AggregateError, Warning: q };
    }, { "./es5": 13, "./util": 36 }], 13: [function(B, K, X) {
      var Y = /* @__PURE__ */ function() {
        return this === void 0;
      }();
      if (Y)
        K.exports = { freeze: Object.freeze, defineProperty: Object.defineProperty, getDescriptor: Object.getOwnPropertyDescriptor, keys: Object.keys, names: Object.getOwnPropertyNames, getPrototypeOf: Object.getPrototypeOf, isArray: Array.isArray, isES5: Y, propertyIsWritable: function(re, ie) {
          var ue = Object.getOwnPropertyDescriptor(re, ie);
          return !(ue && !ue.writable && !ue.set);
        } };
      else {
        var Q = {}.hasOwnProperty, J = {}.toString, ee = {}.constructor.prototype, ae = function(re) {
          var ie = [];
          for (var ue in re)
            Q.call(re, ue) && ie.push(ue);
          return ie;
        };
        K.exports = { isArray: function(re) {
          try {
            return J.call(re) === "[object Array]";
          } catch {
            return !1;
          }
        }, keys: ae, names: ae, defineProperty: function(re, ie, ue) {
          return re[ie] = ue.value, re;
        }, getDescriptor: function(re, ie) {
          return { value: re[ie] };
        }, freeze: function(re) {
          return re;
        }, getPrototypeOf: function(re) {
          try {
            return Object(re).constructor.prototype;
          } catch {
            return ee;
          }
        }, isES5: Y, propertyIsWritable: function() {
          return !0;
        } };
      }
    }, {}], 14: [function(B, K, X) {
      K.exports = function(Y, Q) {
        var J = Y.map;
        Y.prototype.filter = function(ee, ae) {
          return J(this, ee, ae, Q);
        }, Y.filter = function(ee, ae, re) {
          return J(ee, ae, re, Q);
        };
      };
    }, {}], 15: [function(B, K, X) {
      K.exports = function(Y, Q, J) {
        var ee = B("./util"), ae = Y.CancellationError, re = ee.errorObj, ie = B("./catch_filter")(J);
        function ue(me, de, be) {
          this.promise = me, this.type = de, this.handler = be, this.called = !1, this.cancelPromise = null;
        }
        function q(me) {
          this.finallyHandler = me;
        }
        function ne(me, de) {
          return me.cancelPromise != null && (arguments.length > 1 ? me.cancelPromise._reject(de) : me.cancelPromise._cancel(), me.cancelPromise = null, !0);
        }
        function ce() {
          return we.call(this, this.promise._target()._settledValue());
        }
        function he(me) {
          if (!ne(this, me))
            return re.e = me, re;
        }
        function we(me) {
          var de = this.promise, be = this.handler;
          if (!this.called) {
            this.called = !0;
            var _e = this.isFinallyHandler() ? be.call(de._boundValue()) : be.call(de._boundValue(), me);
            if (_e === J)
              return _e;
            if (_e !== void 0) {
              de._setReturnedNonUndefined();
              var Me = Q(_e, de);
              if (Me instanceof Y) {
                if (this.cancelPromise != null) {
                  if (Me._isCancelled()) {
                    var Ne = new ae("late cancellation observer");
                    return de._attachExtraTrace(Ne), re.e = Ne, re;
                  }
                  Me.isPending() && Me._attachCancellationCallback(new q(this));
                }
                return Me._then(ce, he, void 0, this, void 0);
              }
            }
          }
          return de.isRejected() ? (ne(this), re.e = me, re) : (ne(this), me);
        }
        return ue.prototype.isFinallyHandler = function() {
          return this.type === 0;
        }, q.prototype._resultCancelled = function() {
          ne(this.finallyHandler);
        }, Y.prototype._passThrough = function(me, de, be, _e) {
          return typeof me != "function" ? this.then() : this._then(be, _e, void 0, new ue(this, de, me), void 0);
        }, Y.prototype.lastly = Y.prototype.finally = function(me) {
          return this._passThrough(me, 0, we, we);
        }, Y.prototype.tap = function(me) {
          return this._passThrough(me, 1, we);
        }, Y.prototype.tapCatch = function(me) {
          var de = arguments.length;
          if (de === 1)
            return this._passThrough(me, 1, void 0, we);
          var be, _e = new Array(de - 1), Me = 0;
          for (be = 0; be < de - 1; ++be) {
            var Ne = arguments[be];
            if (!ee.isObject(Ne))
              return Y.reject(new TypeError("tapCatch statement predicate: expecting an object but got " + ee.classString(Ne)));
            _e[Me++] = Ne;
          }
          _e.length = Me;
          var Ee = arguments[be];
          return this._passThrough(ie(_e, Ee, this), 1, void 0, we);
        }, ue;
      };
    }, { "./catch_filter": 7, "./util": 36 }], 16: [function(B, K, X) {
      K.exports = function(Y, Q, J, ee, ae, re) {
        var ie = B("./errors").TypeError, ue = B("./util"), q = ue.errorObj, ne = ue.tryCatch, ce = [];
        function he(we, me, de, be) {
          if (re.cancellation()) {
            var _e = new Y(J), Me = this._finallyPromise = new Y(J);
            this._promise = _e.lastly(function() {
              return Me;
            }), _e._captureStackTrace(), _e._setOnCancel(this);
          } else
            (this._promise = new Y(J))._captureStackTrace();
          this._stack = be, this._generatorFunction = we, this._receiver = me, this._generator = void 0, this._yieldHandlers = typeof de == "function" ? [de].concat(ce) : ce, this._yieldedPromise = null, this._cancellationPhase = !1;
        }
        ue.inherits(he, ae), he.prototype._isResolved = function() {
          return this._promise === null;
        }, he.prototype._cleanup = function() {
          this._promise = this._generator = null, re.cancellation() && this._finallyPromise !== null && (this._finallyPromise._fulfill(), this._finallyPromise = null);
        }, he.prototype._promiseCancelled = function() {
          if (!this._isResolved()) {
            var we;
            if (this._generator.return !== void 0)
              this._promise._pushContext(), we = ne(this._generator.return).call(this._generator, void 0), this._promise._popContext();
            else {
              var me = new Y.CancellationError("generator .return() sentinel");
              Y.coroutine.returnSentinel = me, this._promise._attachExtraTrace(me), this._promise._pushContext(), we = ne(this._generator.throw).call(this._generator, me), this._promise._popContext();
            }
            this._cancellationPhase = !0, this._yieldedPromise = null, this._continue(we);
          }
        }, he.prototype._promiseFulfilled = function(we) {
          this._yieldedPromise = null, this._promise._pushContext();
          var me = ne(this._generator.next).call(this._generator, we);
          this._promise._popContext(), this._continue(me);
        }, he.prototype._promiseRejected = function(we) {
          this._yieldedPromise = null, this._promise._attachExtraTrace(we), this._promise._pushContext();
          var me = ne(this._generator.throw).call(this._generator, we);
          this._promise._popContext(), this._continue(me);
        }, he.prototype._resultCancelled = function() {
          if (this._yieldedPromise instanceof Y) {
            var we = this._yieldedPromise;
            this._yieldedPromise = null, we.cancel();
          }
        }, he.prototype.promise = function() {
          return this._promise;
        }, he.prototype._run = function() {
          this._generator = this._generatorFunction.call(this._receiver), this._receiver = this._generatorFunction = void 0, this._promiseFulfilled(void 0);
        }, he.prototype._continue = function(we) {
          var me = this._promise;
          if (we === q)
            return this._cleanup(), this._cancellationPhase ? me.cancel() : me._rejectCallback(we.e, !1);
          var de = we.value;
          if (we.done === !0)
            return this._cleanup(), this._cancellationPhase ? me.cancel() : me._resolveCallback(de);
          var be = ee(de, this._promise);
          if (be instanceof Y || (be = function(Me, Ne, Ee) {
            for (var $e = 0; $e < Ne.length; ++$e) {
              Ee._pushContext();
              var De = ne(Ne[$e])(Me);
              if (Ee._popContext(), De === q) {
                Ee._pushContext();
                var Fe = Y.reject(q.e);
                return Ee._popContext(), Fe;
              }
              var Be = ee(De, Ee);
              if (Be instanceof Y)
                return Be;
            }
            return null;
          }(be, this._yieldHandlers, this._promise)) !== null) {
            var _e = (be = be._target())._bitField;
            50397184 & _e ? 33554432 & _e ? Y._async.invoke(this._promiseFulfilled, this, be._value()) : 16777216 & _e ? Y._async.invoke(this._promiseRejected, this, be._reason()) : this._promiseCancelled() : (this._yieldedPromise = be, be._proxy(this, null));
          } else
            this._promiseRejected(new ie(`A value %s was yielded that could not be treated as a promise

    See http://goo.gl/MqrFmX

`.replace("%s", String(de)) + `From coroutine:
` + this._stack.split(`
`).slice(1, -7).join(`
`)));
        }, Y.coroutine = function(we, me) {
          if (typeof we != "function")
            throw new ie(`generatorFunction must be a function

    See http://goo.gl/MqrFmX
`);
          var de = Object(me).yieldHandler, be = he, _e = new Error().stack;
          return function() {
            var Me = we.apply(this, arguments), Ne = new be(void 0, void 0, de, _e), Ee = Ne.promise();
            return Ne._generator = Me, Ne._promiseFulfilled(void 0), Ee;
          };
        }, Y.coroutine.addYieldHandler = function(we) {
          if (typeof we != "function")
            throw new ie("expecting a function but got " + ue.classString(we));
          ce.push(we);
        }, Y.spawn = function(we) {
          if (re.deprecated("Promise.spawn()", "Promise.coroutine()"), typeof we != "function")
            return Q(`generatorFunction must be a function

    See http://goo.gl/MqrFmX
`);
          var me = new he(we, this), de = me.promise();
          return me._run(Y.spawn), de;
        };
      };
    }, { "./errors": 12, "./util": 36 }], 17: [function(B, K, X) {
      K.exports = function(Y, Q, J, ee, ae, re) {
        var ie = B("./util");
        ie.canEvaluate, ie.tryCatch, ie.errorObj, Y.join = function() {
          var ue, q = arguments.length - 1;
          q > 0 && typeof arguments[q] == "function" && (ue = arguments[q]);
          var ne = [].slice.call(arguments);
          ue && ne.pop();
          var ce = new Q(ne).promise();
          return ue !== void 0 ? ce.spread(ue) : ce;
        };
      };
    }, { "./util": 36 }], 18: [function(B, K, X) {
      K.exports = function(Y, Q, J, ee, ae, re) {
        var ie = Y._getDomain, ue = B("./util"), q = ue.tryCatch, ne = ue.errorObj, ce = Y._async;
        function he(me, de, be, _e) {
          this.constructor$(me), this._promise._captureStackTrace();
          var Me = ie();
          this._callback = Me === null ? de : ue.domainBind(Me, de), this._preservedValues = _e === ae ? new Array(this.length()) : null, this._limit = be, this._inFlight = 0, this._queue = [], ce.invoke(this._asyncInit, this, void 0);
        }
        function we(me, de, be, _e) {
          if (typeof de != "function")
            return J("expecting a function but got " + ue.classString(de));
          var Me = 0;
          if (be !== void 0) {
            if (typeof be != "object" || be === null)
              return Y.reject(new TypeError("options argument must be an object but it is " + ue.classString(be)));
            if (typeof be.concurrency != "number")
              return Y.reject(new TypeError("'concurrency' must be a number but it is " + ue.classString(be.concurrency)));
            Me = be.concurrency;
          }
          return new he(me, de, Me = typeof Me == "number" && isFinite(Me) && Me >= 1 ? Me : 0, _e).promise();
        }
        ue.inherits(he, Q), he.prototype._asyncInit = function() {
          this._init$(void 0, -2);
        }, he.prototype._init = function() {
        }, he.prototype._promiseFulfilled = function(me, de) {
          var be = this._values, _e = this.length(), Me = this._preservedValues, Ne = this._limit;
          if (de < 0) {
            if (be[de = -1 * de - 1] = me, Ne >= 1 && (this._inFlight--, this._drainQueue(), this._isResolved()))
              return !0;
          } else {
            if (Ne >= 1 && this._inFlight >= Ne)
              return be[de] = me, this._queue.push(de), !1;
            Me !== null && (Me[de] = me);
            var Ee = this._promise, $e = this._callback, De = Ee._boundValue();
            Ee._pushContext();
            var Fe = q($e).call(De, me, de, _e), Be = Ee._popContext();
            if (re.checkForgottenReturns(Fe, Be, Me !== null ? "Promise.filter" : "Promise.map", Ee), Fe === ne)
              return this._reject(Fe.e), !0;
            var We = ee(Fe, this._promise);
            if (We instanceof Y) {
              var Ve = (We = We._target())._bitField;
              if (!(50397184 & Ve))
                return Ne >= 1 && this._inFlight++, be[de] = We, We._proxy(this, -1 * (de + 1)), !1;
              if (!(33554432 & Ve))
                return 16777216 & Ve ? (this._reject(We._reason()), !0) : (this._cancel(), !0);
              Fe = We._value();
            }
            be[de] = Fe;
          }
          return ++this._totalResolved >= _e && (Me !== null ? this._filter(be, Me) : this._resolve(be), !0);
        }, he.prototype._drainQueue = function() {
          for (var me = this._queue, de = this._limit, be = this._values; me.length > 0 && this._inFlight < de; ) {
            if (this._isResolved())
              return;
            var _e = me.pop();
            this._promiseFulfilled(be[_e], _e);
          }
        }, he.prototype._filter = function(me, de) {
          for (var be = de.length, _e = new Array(be), Me = 0, Ne = 0; Ne < be; ++Ne)
            me[Ne] && (_e[Me++] = de[Ne]);
          _e.length = Me, this._resolve(_e);
        }, he.prototype.preservedValues = function() {
          return this._preservedValues;
        }, Y.prototype.map = function(me, de) {
          return we(this, me, de, null);
        }, Y.map = function(me, de, be, _e) {
          return we(me, de, be, _e);
        };
      };
    }, { "./util": 36 }], 19: [function(B, K, X) {
      K.exports = function(Y, Q, J, ee, ae) {
        var re = B("./util"), ie = re.tryCatch;
        Y.method = function(ue) {
          if (typeof ue != "function")
            throw new Y.TypeError("expecting a function but got " + re.classString(ue));
          return function() {
            var q = new Y(Q);
            q._captureStackTrace(), q._pushContext();
            var ne = ie(ue).apply(this, arguments), ce = q._popContext();
            return ae.checkForgottenReturns(ne, ce, "Promise.method", q), q._resolveFromSyncValue(ne), q;
          };
        }, Y.attempt = Y.try = function(ue) {
          if (typeof ue != "function")
            return ee("expecting a function but got " + re.classString(ue));
          var q, ne = new Y(Q);
          if (ne._captureStackTrace(), ne._pushContext(), arguments.length > 1) {
            ae.deprecated("calling Promise.try with more than 1 argument");
            var ce = arguments[1], he = arguments[2];
            q = re.isArray(ce) ? ie(ue).apply(he, ce) : ie(ue).call(he, ce);
          } else
            q = ie(ue)();
          var we = ne._popContext();
          return ae.checkForgottenReturns(q, we, "Promise.try", ne), ne._resolveFromSyncValue(q), ne;
        }, Y.prototype._resolveFromSyncValue = function(ue) {
          ue === re.errorObj ? this._rejectCallback(ue.e, !1) : this._resolveCallback(ue, !0);
        };
      };
    }, { "./util": 36 }], 20: [function(B, K, X) {
      var Y = B("./util"), Q = Y.maybeWrapAsError, J = B("./errors").OperationalError, ee = B("./es5"), ae = /^(?:name|message|stack|cause)$/;
      function re(ie) {
        var ue;
        if (function(he) {
          return he instanceof Error && ee.getPrototypeOf(he) === Error.prototype;
        }(ie)) {
          (ue = new J(ie)).name = ie.name, ue.message = ie.message, ue.stack = ie.stack;
          for (var q = ee.keys(ie), ne = 0; ne < q.length; ++ne) {
            var ce = q[ne];
            ae.test(ce) || (ue[ce] = ie[ce]);
          }
          return ue;
        }
        return Y.markAsOriginatingFromRejection(ie), ie;
      }
      K.exports = function(ie, ue) {
        return function(q, ne) {
          if (ie !== null) {
            if (q) {
              var ce = re(Q(q));
              ie._attachExtraTrace(ce), ie._reject(ce);
            } else if (ue) {
              var he = [].slice.call(arguments, 1);
              ie._fulfill(he);
            } else
              ie._fulfill(ne);
            ie = null;
          }
        };
      };
    }, { "./errors": 12, "./es5": 13, "./util": 36 }], 21: [function(B, K, X) {
      K.exports = function(Y) {
        var Q = B("./util"), J = Y._async, ee = Q.tryCatch, ae = Q.errorObj;
        function re(q, ne) {
          if (!Q.isArray(q))
            return ie.call(this, q, ne);
          var ce = ee(ne).apply(this._boundValue(), [null].concat(q));
          ce === ae && J.throwLater(ce.e);
        }
        function ie(q, ne) {
          var ce = this._boundValue(), he = q === void 0 ? ee(ne).call(ce, null) : ee(ne).call(ce, null, q);
          he === ae && J.throwLater(he.e);
        }
        function ue(q, ne) {
          if (!q) {
            var ce = new Error(q + "");
            ce.cause = q, q = ce;
          }
          var he = ee(ne).call(this._boundValue(), q);
          he === ae && J.throwLater(he.e);
        }
        Y.prototype.asCallback = Y.prototype.nodeify = function(q, ne) {
          if (typeof q == "function") {
            var ce = ie;
            ne !== void 0 && Object(ne).spread && (ce = re), this._then(ce, ue, void 0, this, q);
          }
          return this;
        };
      };
    }, { "./util": 36 }], 22: [function(B, K, X) {
      K.exports = function() {
        var Y = function() {
          return new he(`circular promise resolution chain

    See http://goo.gl/MqrFmX
`);
        }, Q = function() {
          return new ze.PromiseInspection(this._target());
        }, J = function(ve) {
          return ze.reject(new he(ve));
        };
        function ee() {
        }
        var ae, re = {}, ie = B("./util");
        ae = ie.isNode ? function() {
          var ve = F.domain;
          return ve === void 0 && (ve = null), ve;
        } : function() {
          return null;
        }, ie.notEnumerableProp(ze, "_getDomain", ae);
        var ue = B("./es5"), q = B("./async"), ne = new q();
        ue.defineProperty(ze, "_async", { value: ne });
        var ce = B("./errors"), he = ze.TypeError = ce.TypeError;
        ze.RangeError = ce.RangeError;
        var we = ze.CancellationError = ce.CancellationError;
        ze.TimeoutError = ce.TimeoutError, ze.OperationalError = ce.OperationalError, ze.RejectionError = ce.OperationalError, ze.AggregateError = ce.AggregateError;
        var me = function() {
        }, de = {}, be = {}, _e = B("./thenables")(ze, me), Me = B("./promise_array")(ze, me, _e, J, ee), Ne = B("./context")(ze), Ee = Ne.create, $e = B("./debuggability")(ze, Ne), De = ($e.CapturedTrace, B("./finally")(ze, _e, be)), Fe = B("./catch_filter")(be), Be = B("./nodeback"), We = ie.errorObj, Ve = ie.tryCatch;
        function ze(ve) {
          ve !== me && function(xe, Oe) {
            if (xe == null || xe.constructor !== ze)
              throw new he(`the promise constructor cannot be invoked directly

    See http://goo.gl/MqrFmX
`);
            if (typeof Oe != "function")
              throw new he("expecting a function but got " + ie.classString(Oe));
          }(this, ve), this._bitField = 0, this._fulfillmentHandler0 = void 0, this._rejectionHandler0 = void 0, this._promise0 = void 0, this._receiver0 = void 0, this._resolveFromExecutor(ve), this._promiseCreated(), this._fireEvent("promiseCreated", this);
        }
        function ke(ve) {
          this.promise._resolveCallback(ve);
        }
        function je(ve) {
          this.promise._rejectCallback(ve, !1);
        }
        function Ie(ve) {
          var xe = new ze(me);
          xe._fulfillmentHandler0 = ve, xe._rejectionHandler0 = ve, xe._promise0 = ve, xe._receiver0 = ve;
        }
        return ze.prototype.toString = function() {
          return "[object Promise]";
        }, ze.prototype.caught = ze.prototype.catch = function(ve) {
          var xe = arguments.length;
          if (xe > 1) {
            var Oe, Te = new Array(xe - 1), Ce = 0;
            for (Oe = 0; Oe < xe - 1; ++Oe) {
              var te = arguments[Oe];
              if (!ie.isObject(te))
                return J("Catch statement predicate: expecting an object but got " + ie.classString(te));
              Te[Ce++] = te;
            }
            return Te.length = Ce, ve = arguments[Oe], this.then(void 0, Fe(Te, ve, this));
          }
          return this.then(void 0, ve);
        }, ze.prototype.reflect = function() {
          return this._then(Q, Q, void 0, this, void 0);
        }, ze.prototype.then = function(ve, xe) {
          if ($e.warnings() && arguments.length > 0 && typeof ve != "function" && typeof xe != "function") {
            var Oe = ".then() only accepts functions but was passed: " + ie.classString(ve);
            arguments.length > 1 && (Oe += ", " + ie.classString(xe)), this._warn(Oe);
          }
          return this._then(ve, xe, void 0, void 0, void 0);
        }, ze.prototype.done = function(ve, xe) {
          this._then(ve, xe, void 0, void 0, void 0)._setIsFinal();
        }, ze.prototype.spread = function(ve) {
          return typeof ve != "function" ? J("expecting a function but got " + ie.classString(ve)) : this.all()._then(ve, void 0, void 0, de, void 0);
        }, ze.prototype.toJSON = function() {
          var ve = { isFulfilled: !1, isRejected: !1, fulfillmentValue: void 0, rejectionReason: void 0 };
          return this.isFulfilled() ? (ve.fulfillmentValue = this.value(), ve.isFulfilled = !0) : this.isRejected() && (ve.rejectionReason = this.reason(), ve.isRejected = !0), ve;
        }, ze.prototype.all = function() {
          return arguments.length > 0 && this._warn(".all() was passed arguments but it does not take any"), new Me(this).promise();
        }, ze.prototype.error = function(ve) {
          return this.caught(ie.originatesFromRejection, ve);
        }, ze.getNewLibraryCopy = K.exports, ze.is = function(ve) {
          return ve instanceof ze;
        }, ze.fromNode = ze.fromCallback = function(ve) {
          var xe = new ze(me);
          xe._captureStackTrace();
          var Oe = arguments.length > 1 && !!Object(arguments[1]).multiArgs, Te = Ve(ve)(Be(xe, Oe));
          return Te === We && xe._rejectCallback(Te.e, !0), xe._isFateSealed() || xe._setAsyncGuaranteed(), xe;
        }, ze.all = function(ve) {
          return new Me(ve).promise();
        }, ze.cast = function(ve) {
          var xe = _e(ve);
          return xe instanceof ze || ((xe = new ze(me))._captureStackTrace(), xe._setFulfilled(), xe._rejectionHandler0 = ve), xe;
        }, ze.resolve = ze.fulfilled = ze.cast, ze.reject = ze.rejected = function(ve) {
          var xe = new ze(me);
          return xe._captureStackTrace(), xe._rejectCallback(ve, !0), xe;
        }, ze.setScheduler = function(ve) {
          if (typeof ve != "function")
            throw new he("expecting a function but got " + ie.classString(ve));
          return ne.setScheduler(ve);
        }, ze.prototype._then = function(ve, xe, Oe, Te, Ce) {
          var te = Ce !== void 0, le = te ? Ce : new ze(me), ge = this._target(), pe = ge._bitField;
          te || (le._propagateFrom(this, 3), le._captureStackTrace(), Te === void 0 && 2097152 & this._bitField && (Te = 50397184 & pe ? this._boundValue() : ge === this ? void 0 : this._boundTo), this._fireEvent("promiseChained", this, le));
          var fe = ae();
          if (50397184 & pe) {
            var Se, Pe, Ge = ge._settlePromiseCtx;
            33554432 & pe ? (Pe = ge._rejectionHandler0, Se = ve) : 16777216 & pe ? (Pe = ge._fulfillmentHandler0, Se = xe, ge._unsetRejectionIsUnhandled()) : (Ge = ge._settlePromiseLateCancellationObserver, Pe = new we("late cancellation observer"), ge._attachExtraTrace(Pe), Se = xe), ne.invoke(Ge, ge, { handler: fe === null ? Se : typeof Se == "function" && ie.domainBind(fe, Se), promise: le, receiver: Te, value: Pe });
          } else
            ge._addCallbacks(ve, xe, le, Te, fe);
          return le;
        }, ze.prototype._length = function() {
          return 65535 & this._bitField;
        }, ze.prototype._isFateSealed = function() {
          return (117506048 & this._bitField) != 0;
        }, ze.prototype._isFollowing = function() {
          return (67108864 & this._bitField) == 67108864;
        }, ze.prototype._setLength = function(ve) {
          this._bitField = -65536 & this._bitField | 65535 & ve;
        }, ze.prototype._setFulfilled = function() {
          this._bitField = 33554432 | this._bitField, this._fireEvent("promiseFulfilled", this);
        }, ze.prototype._setRejected = function() {
          this._bitField = 16777216 | this._bitField, this._fireEvent("promiseRejected", this);
        }, ze.prototype._setFollowing = function() {
          this._bitField = 67108864 | this._bitField, this._fireEvent("promiseResolved", this);
        }, ze.prototype._setIsFinal = function() {
          this._bitField = 4194304 | this._bitField;
        }, ze.prototype._isFinal = function() {
          return (4194304 & this._bitField) > 0;
        }, ze.prototype._unsetCancelled = function() {
          this._bitField = -65537 & this._bitField;
        }, ze.prototype._setCancelled = function() {
          this._bitField = 65536 | this._bitField, this._fireEvent("promiseCancelled", this);
        }, ze.prototype._setWillBeCancelled = function() {
          this._bitField = 8388608 | this._bitField;
        }, ze.prototype._setAsyncGuaranteed = function() {
          ne.hasCustomScheduler() || (this._bitField = 134217728 | this._bitField);
        }, ze.prototype._receiverAt = function(ve) {
          var xe = ve === 0 ? this._receiver0 : this[4 * ve - 4 + 3];
          if (xe !== re)
            return xe === void 0 && this._isBound() ? this._boundValue() : xe;
        }, ze.prototype._promiseAt = function(ve) {
          return this[4 * ve - 4 + 2];
        }, ze.prototype._fulfillmentHandlerAt = function(ve) {
          return this[4 * ve - 4 + 0];
        }, ze.prototype._rejectionHandlerAt = function(ve) {
          return this[4 * ve - 4 + 1];
        }, ze.prototype._boundValue = function() {
        }, ze.prototype._migrateCallback0 = function(ve) {
          ve._bitField;
          var xe = ve._fulfillmentHandler0, Oe = ve._rejectionHandler0, Te = ve._promise0, Ce = ve._receiverAt(0);
          Ce === void 0 && (Ce = re), this._addCallbacks(xe, Oe, Te, Ce, null);
        }, ze.prototype._migrateCallbackAt = function(ve, xe) {
          var Oe = ve._fulfillmentHandlerAt(xe), Te = ve._rejectionHandlerAt(xe), Ce = ve._promiseAt(xe), te = ve._receiverAt(xe);
          te === void 0 && (te = re), this._addCallbacks(Oe, Te, Ce, te, null);
        }, ze.prototype._addCallbacks = function(ve, xe, Oe, Te, Ce) {
          var te = this._length();
          if (te >= 65531 && (te = 0, this._setLength(0)), te === 0)
            this._promise0 = Oe, this._receiver0 = Te, typeof ve == "function" && (this._fulfillmentHandler0 = Ce === null ? ve : ie.domainBind(Ce, ve)), typeof xe == "function" && (this._rejectionHandler0 = Ce === null ? xe : ie.domainBind(Ce, xe));
          else {
            var le = 4 * te - 4;
            this[le + 2] = Oe, this[le + 3] = Te, typeof ve == "function" && (this[le + 0] = Ce === null ? ve : ie.domainBind(Ce, ve)), typeof xe == "function" && (this[le + 1] = Ce === null ? xe : ie.domainBind(Ce, xe));
          }
          return this._setLength(te + 1), te;
        }, ze.prototype._proxy = function(ve, xe) {
          this._addCallbacks(void 0, void 0, xe, ve, null);
        }, ze.prototype._resolveCallback = function(ve, xe) {
          if (!(117506048 & this._bitField)) {
            if (ve === this)
              return this._rejectCallback(Y(), !1);
            var Oe = _e(ve, this);
            if (!(Oe instanceof ze))
              return this._fulfill(ve);
            xe && this._propagateFrom(Oe, 2);
            var Te = Oe._target();
            if (Te !== this) {
              var Ce = Te._bitField;
              if (50397184 & Ce)
                if (33554432 & Ce)
                  this._fulfill(Te._value());
                else if (16777216 & Ce)
                  this._reject(Te._reason());
                else {
                  var ge = new we("late cancellation observer");
                  Te._attachExtraTrace(ge), this._reject(ge);
                }
              else {
                var te = this._length();
                te > 0 && Te._migrateCallback0(this);
                for (var le = 1; le < te; ++le)
                  Te._migrateCallbackAt(this, le);
                this._setFollowing(), this._setLength(0), this._setFollowee(Te);
              }
            } else
              this._reject(Y());
          }
        }, ze.prototype._rejectCallback = function(ve, xe, Oe) {
          var Te = ie.ensureErrorObject(ve), Ce = Te === ve;
          if (!Ce && !Oe && $e.warnings()) {
            var te = "a promise was rejected with a non-error: " + ie.classString(ve);
            this._warn(te, !0);
          }
          this._attachExtraTrace(Te, !!xe && Ce), this._reject(ve);
        }, ze.prototype._resolveFromExecutor = function(ve) {
          if (ve !== me) {
            var xe = this;
            this._captureStackTrace(), this._pushContext();
            var Oe = !0, Te = this._execute(ve, function(Ce) {
              xe._resolveCallback(Ce);
            }, function(Ce) {
              xe._rejectCallback(Ce, Oe);
            });
            Oe = !1, this._popContext(), Te !== void 0 && xe._rejectCallback(Te, !0);
          }
        }, ze.prototype._settlePromiseFromHandler = function(ve, xe, Oe, Te) {
          var Ce = Te._bitField;
          if (!(65536 & Ce)) {
            var te;
            Te._pushContext(), xe === de ? Oe && typeof Oe.length == "number" ? te = Ve(ve).apply(this._boundValue(), Oe) : (te = We).e = new he("cannot .spread() a non-array: " + ie.classString(Oe)) : te = Ve(ve).call(xe, Oe);
            var le = Te._popContext();
            !(65536 & (Ce = Te._bitField)) && (te === be ? Te._reject(Oe) : te === We ? Te._rejectCallback(te.e, !1) : ($e.checkForgottenReturns(te, le, "", Te, this), Te._resolveCallback(te)));
          }
        }, ze.prototype._target = function() {
          for (var ve = this; ve._isFollowing(); )
            ve = ve._followee();
          return ve;
        }, ze.prototype._followee = function() {
          return this._rejectionHandler0;
        }, ze.prototype._setFollowee = function(ve) {
          this._rejectionHandler0 = ve;
        }, ze.prototype._settlePromise = function(ve, xe, Oe, Te) {
          var Ce = ve instanceof ze, te = this._bitField, le = (134217728 & te) != 0;
          65536 & te ? (Ce && ve._invokeInternalOnCancel(), Oe instanceof De && Oe.isFinallyHandler() ? (Oe.cancelPromise = ve, Ve(xe).call(Oe, Te) === We && ve._reject(We.e)) : xe === Q ? ve._fulfill(Q.call(Oe)) : Oe instanceof ee ? Oe._promiseCancelled(ve) : Ce || ve instanceof Me ? ve._cancel() : Oe.cancel()) : typeof xe == "function" ? Ce ? (le && ve._setAsyncGuaranteed(), this._settlePromiseFromHandler(xe, Oe, Te, ve)) : xe.call(Oe, Te, ve) : Oe instanceof ee ? Oe._isResolved() || (33554432 & te ? Oe._promiseFulfilled(Te, ve) : Oe._promiseRejected(Te, ve)) : Ce && (le && ve._setAsyncGuaranteed(), 33554432 & te ? ve._fulfill(Te) : ve._reject(Te));
        }, ze.prototype._settlePromiseLateCancellationObserver = function(ve) {
          var xe = ve.handler, Oe = ve.promise, Te = ve.receiver, Ce = ve.value;
          typeof xe == "function" ? Oe instanceof ze ? this._settlePromiseFromHandler(xe, Te, Ce, Oe) : xe.call(Te, Ce, Oe) : Oe instanceof ze && Oe._reject(Ce);
        }, ze.prototype._settlePromiseCtx = function(ve) {
          this._settlePromise(ve.promise, ve.handler, ve.receiver, ve.value);
        }, ze.prototype._settlePromise0 = function(ve, xe, Oe) {
          var Te = this._promise0, Ce = this._receiverAt(0);
          this._promise0 = void 0, this._receiver0 = void 0, this._settlePromise(Te, ve, Ce, xe);
        }, ze.prototype._clearCallbackDataAtIndex = function(ve) {
          var xe = 4 * ve - 4;
          this[xe + 2] = this[xe + 3] = this[xe + 0] = this[xe + 1] = void 0;
        }, ze.prototype._fulfill = function(ve) {
          var xe = this._bitField;
          if (!((117506048 & xe) >>> 16)) {
            if (ve === this) {
              var Oe = Y();
              return this._attachExtraTrace(Oe), this._reject(Oe);
            }
            this._setFulfilled(), this._rejectionHandler0 = ve, (65535 & xe) > 0 && (134217728 & xe ? this._settlePromises() : ne.settlePromises(this));
          }
        }, ze.prototype._reject = function(ve) {
          var xe = this._bitField;
          if (!((117506048 & xe) >>> 16)) {
            if (this._setRejected(), this._fulfillmentHandler0 = ve, this._isFinal())
              return ne.fatalError(ve, ie.isNode);
            (65535 & xe) > 0 ? ne.settlePromises(this) : this._ensurePossibleRejectionHandled();
          }
        }, ze.prototype._fulfillPromises = function(ve, xe) {
          for (var Oe = 1; Oe < ve; Oe++) {
            var Te = this._fulfillmentHandlerAt(Oe), Ce = this._promiseAt(Oe), te = this._receiverAt(Oe);
            this._clearCallbackDataAtIndex(Oe), this._settlePromise(Ce, Te, te, xe);
          }
        }, ze.prototype._rejectPromises = function(ve, xe) {
          for (var Oe = 1; Oe < ve; Oe++) {
            var Te = this._rejectionHandlerAt(Oe), Ce = this._promiseAt(Oe), te = this._receiverAt(Oe);
            this._clearCallbackDataAtIndex(Oe), this._settlePromise(Ce, Te, te, xe);
          }
        }, ze.prototype._settlePromises = function() {
          var ve = this._bitField, xe = 65535 & ve;
          if (xe > 0) {
            if (16842752 & ve) {
              var Oe = this._fulfillmentHandler0;
              this._settlePromise0(this._rejectionHandler0, Oe, ve), this._rejectPromises(xe, Oe);
            } else {
              var Te = this._rejectionHandler0;
              this._settlePromise0(this._fulfillmentHandler0, Te, ve), this._fulfillPromises(xe, Te);
            }
            this._setLength(0);
          }
          this._clearCancellationData();
        }, ze.prototype._settledValue = function() {
          var ve = this._bitField;
          return 33554432 & ve ? this._rejectionHandler0 : 16777216 & ve ? this._fulfillmentHandler0 : void 0;
        }, ze.defer = ze.pending = function() {
          return $e.deprecated("Promise.defer", "new Promise"), { promise: new ze(me), resolve: ke, reject: je };
        }, ie.notEnumerableProp(ze, "_makeSelfResolutionError", Y), B("./method")(ze, me, _e, J, $e), B("./bind")(ze, me, _e, $e), B("./cancel")(ze, Me, J, $e), B("./direct_resolve")(ze), B("./synchronous_inspection")(ze), B("./join")(ze, Me, _e, me, ne, ae), ze.Promise = ze, ze.version = "3.5.1", B("./map.js")(ze, Me, J, _e, me, $e), B("./call_get.js")(ze), B("./using.js")(ze, J, _e, Ee, me, $e), B("./timers.js")(ze, me, $e), B("./generators.js")(ze, J, me, _e, ee, $e), B("./nodeify.js")(ze), B("./promisify.js")(ze, me), B("./props.js")(ze, Me, _e, J), B("./race.js")(ze, me, _e, J), B("./reduce.js")(ze, Me, J, _e, me, $e), B("./settle.js")(ze, Me, $e), B("./some.js")(ze, Me, J), B("./filter.js")(ze, me), B("./each.js")(ze, me), B("./any.js")(ze), ie.toFastProperties(ze), ie.toFastProperties(ze.prototype), Ie({ a: 1 }), Ie({ b: 2 }), Ie({ c: 3 }), Ie(1), Ie(function() {
        }), Ie(void 0), Ie(!1), Ie(new ze(me)), $e.setBounds(q.firstLineError, ie.lastLineError), ze;
      };
    }, { "./any.js": 1, "./async": 2, "./bind": 3, "./call_get.js": 5, "./cancel": 6, "./catch_filter": 7, "./context": 8, "./debuggability": 9, "./direct_resolve": 10, "./each.js": 11, "./errors": 12, "./es5": 13, "./filter.js": 14, "./finally": 15, "./generators.js": 16, "./join": 17, "./map.js": 18, "./method": 19, "./nodeback": 20, "./nodeify.js": 21, "./promise_array": 23, "./promisify.js": 24, "./props.js": 25, "./race.js": 27, "./reduce.js": 28, "./settle.js": 30, "./some.js": 31, "./synchronous_inspection": 32, "./thenables": 33, "./timers.js": 34, "./using.js": 35, "./util": 36 }], 23: [function(B, K, X) {
      K.exports = function(Y, Q, J, ee, ae) {
        var re = B("./util");
        function ie(ue) {
          var q = this._promise = new Y(Q);
          ue instanceof Y && q._propagateFrom(ue, 3), q._setOnCancel(this), this._values = ue, this._length = 0, this._totalResolved = 0, this._init(void 0, -2);
        }
        return re.isArray, re.inherits(ie, ae), ie.prototype.length = function() {
          return this._length;
        }, ie.prototype.promise = function() {
          return this._promise;
        }, ie.prototype._init = function ue(q, ne) {
          var ce = J(this._values, this._promise);
          if (ce instanceof Y) {
            var he = (ce = ce._target())._bitField;
            if (this._values = ce, (50397184 & he) == 0)
              return this._promise._setAsyncGuaranteed(), ce._then(ue, this._reject, void 0, this, ne);
            if (!(33554432 & he))
              return 16777216 & he ? this._reject(ce._reason()) : this._cancel();
            ce = ce._value();
          }
          if ((ce = re.asArray(ce)) !== null)
            ce.length !== 0 ? this._iterate(ce) : ne === -5 ? this._resolveEmptyArray() : this._resolve(function(me) {
              switch (ne) {
                case -2:
                  return [];
                case -3:
                  return {};
                case -6:
                  return /* @__PURE__ */ new Map();
              }
            }());
          else {
            var we = ee("expecting an array or an iterable object but got " + re.classString(ce)).reason();
            this._promise._rejectCallback(we, !1);
          }
        }, ie.prototype._iterate = function(ue) {
          var q = this.getActualLength(ue.length);
          this._length = q, this._values = this.shouldCopyValues() ? new Array(q) : this._values;
          for (var ne = this._promise, ce = !1, he = null, we = 0; we < q; ++we) {
            var me = J(ue[we], ne);
            he = me instanceof Y ? (me = me._target())._bitField : null, ce ? he !== null && me.suppressUnhandledRejections() : he !== null ? 50397184 & he ? ce = 33554432 & he ? this._promiseFulfilled(me._value(), we) : 16777216 & he ? this._promiseRejected(me._reason(), we) : this._promiseCancelled(we) : (me._proxy(this, we), this._values[we] = me) : ce = this._promiseFulfilled(me, we);
          }
          ce || ne._setAsyncGuaranteed();
        }, ie.prototype._isResolved = function() {
          return this._values === null;
        }, ie.prototype._resolve = function(ue) {
          this._values = null, this._promise._fulfill(ue);
        }, ie.prototype._cancel = function() {
          !this._isResolved() && this._promise._isCancellable() && (this._values = null, this._promise._cancel());
        }, ie.prototype._reject = function(ue) {
          this._values = null, this._promise._rejectCallback(ue, !1);
        }, ie.prototype._promiseFulfilled = function(ue, q) {
          return this._values[q] = ue, ++this._totalResolved >= this._length && (this._resolve(this._values), !0);
        }, ie.prototype._promiseCancelled = function() {
          return this._cancel(), !0;
        }, ie.prototype._promiseRejected = function(ue) {
          return this._totalResolved++, this._reject(ue), !0;
        }, ie.prototype._resultCancelled = function() {
          if (!this._isResolved()) {
            var ue = this._values;
            if (this._cancel(), ue instanceof Y)
              ue.cancel();
            else
              for (var q = 0; q < ue.length; ++q)
                ue[q] instanceof Y && ue[q].cancel();
          }
        }, ie.prototype.shouldCopyValues = function() {
          return !0;
        }, ie.prototype.getActualLength = function(ue) {
          return ue;
        }, ie;
      };
    }, { "./util": 36 }], 24: [function(B, K, X) {
      K.exports = function(Y, Q) {
        var J = {}, ee = B("./util"), ae = B("./nodeback"), re = ee.withAppended, ie = ee.maybeWrapAsError, ue = ee.canEvaluate, q = B("./errors").TypeError, ne = { __isPromisified__: !0 }, ce = new RegExp("^(?:" + ["arity", "length", "name", "arguments", "caller", "callee", "prototype", "__isPromisified__"].join("|") + ")$"), he = function(Ee) {
          return ee.isIdentifier(Ee) && Ee.charAt(0) !== "_" && Ee !== "constructor";
        };
        function we(Ee) {
          return !ce.test(Ee);
        }
        function me(Ee) {
          try {
            return Ee.__isPromisified__ === !0;
          } catch {
            return !1;
          }
        }
        function de(Ee, $e, De) {
          var Fe = ee.getDataPropertyOrDefault(Ee, $e + De, ne);
          return !!Fe && me(Fe);
        }
        function be(Ee, $e, De, Fe) {
          for (var Be = ee.inheritedDataKeys(Ee), We = [], Ve = 0; Ve < Be.length; ++Ve) {
            var ze = Be[Ve], ke = Ee[ze], je = Fe === he || he(ze);
            typeof ke != "function" || me(ke) || de(Ee, ze, $e) || !Fe(ze, ke, Ee, je) || We.push(ze, ke);
          }
          return function(Ie, ve, xe) {
            for (var Oe = 0; Oe < Ie.length; Oe += 2) {
              var Te = Ie[Oe];
              if (xe.test(Te)) {
                for (var Ce = Te.replace(xe, ""), te = 0; te < Ie.length; te += 2)
                  if (Ie[te] === Ce)
                    throw new q(`Cannot promisify an API that has normal methods with '%s'-suffix

    See http://goo.gl/MqrFmX
`.replace("%s", ve));
              }
            }
          }(We, $e, De), We;
        }
        var _e = function(Ee) {
          return Ee.replace(/([$])/, "\\$");
        }, Me = ue ? void 0 : function(Ee, $e, De, Fe, Be, We) {
          var Ve = /* @__PURE__ */ function() {
            return this;
          }(), ze = Ee;
          function ke() {
            var je = $e;
            $e === J && (je = this);
            var Ie = new Y(Q);
            Ie._captureStackTrace();
            var ve = typeof ze == "string" && this !== Ve ? this[ze] : Ee, xe = ae(Ie, We);
            try {
              ve.apply(je, re(arguments, xe));
            } catch (Oe) {
              Ie._rejectCallback(ie(Oe), !0, !0);
            }
            return Ie._isFateSealed() || Ie._setAsyncGuaranteed(), Ie;
          }
          return typeof ze == "string" && (Ee = Fe), ee.notEnumerableProp(ke, "__isPromisified__", !0), ke;
        };
        function Ne(Ee, $e, De, Fe, Be) {
          for (var We = new RegExp(_e($e) + "$"), Ve = be(Ee, $e, We, De), ze = 0, ke = Ve.length; ze < ke; ze += 2) {
            var je = Ve[ze], Ie = Ve[ze + 1], ve = je + $e;
            if (Fe === Me)
              Ee[ve] = Me(je, J, je, Ie, $e, Be);
            else {
              var xe = Fe(Ie, function() {
                return Me(je, J, je, Ie, $e, Be);
              });
              ee.notEnumerableProp(xe, "__isPromisified__", !0), Ee[ve] = xe;
            }
          }
          return ee.toFastProperties(Ee), Ee;
        }
        Y.promisify = function(Ee, $e) {
          if (typeof Ee != "function")
            throw new q("expecting a function but got " + ee.classString(Ee));
          if (me(Ee))
            return Ee;
          var De = ($e = Object($e)).context === void 0 ? J : $e.context, Fe = !!$e.multiArgs, Be = function(We, Ve, ze) {
            return Me(We, Ve, void 0, We, null, Fe);
          }(Ee, De);
          return ee.copyDescriptors(Ee, Be, we), Be;
        }, Y.promisifyAll = function(Ee, $e) {
          if (typeof Ee != "function" && typeof Ee != "object")
            throw new q(`the target of promisifyAll must be an object or a function

    See http://goo.gl/MqrFmX
`);
          var De = !!($e = Object($e)).multiArgs, Fe = $e.suffix;
          typeof Fe != "string" && (Fe = "Async");
          var Be = $e.filter;
          typeof Be != "function" && (Be = he);
          var We = $e.promisifier;
          if (typeof We != "function" && (We = Me), !ee.isIdentifier(Fe))
            throw new RangeError(`suffix must be a valid identifier

    See http://goo.gl/MqrFmX
`);
          for (var Ve = ee.inheritedDataKeys(Ee), ze = 0; ze < Ve.length; ++ze) {
            var ke = Ee[Ve[ze]];
            Ve[ze] !== "constructor" && ee.isClass(ke) && (Ne(ke.prototype, Fe, Be, We, De), Ne(ke, Fe, Be, We, De));
          }
          return Ne(Ee, Fe, Be, We, De);
        };
      };
    }, { "./errors": 12, "./nodeback": 20, "./util": 36 }], 25: [function(B, K, X) {
      K.exports = function(Y, Q, J, ee) {
        var ae, re = B("./util"), ie = re.isObject, ue = B("./es5");
        typeof Map == "function" && (ae = Map);
        var q = /* @__PURE__ */ function() {
          var he = 0, we = 0;
          function me(de, be) {
            this[he] = de, this[he + we] = be, he++;
          }
          return function(de) {
            we = de.size, he = 0;
            var be = new Array(2 * de.size);
            return de.forEach(me, be), be;
          };
        }();
        function ne(he) {
          var we, me = !1;
          if (ae !== void 0 && he instanceof ae)
            we = q(he), me = !0;
          else {
            var de = ue.keys(he), be = de.length;
            we = new Array(2 * be);
            for (var _e = 0; _e < be; ++_e) {
              var Me = de[_e];
              we[_e] = he[Me], we[_e + be] = Me;
            }
          }
          this.constructor$(we), this._isMap = me, this._init$(void 0, me ? -6 : -3);
        }
        function ce(he) {
          var we, me = J(he);
          return ie(me) ? (we = me instanceof Y ? me._then(Y.props, void 0, void 0, void 0, void 0) : new ne(me).promise(), me instanceof Y && we._propagateFrom(me, 2), we) : ee(`cannot await properties of a non-object

    See http://goo.gl/MqrFmX
`);
        }
        re.inherits(ne, Q), ne.prototype._init = function() {
        }, ne.prototype._promiseFulfilled = function(he, we) {
          if (this._values[we] = he, ++this._totalResolved >= this._length) {
            var me;
            if (this._isMap)
              me = function(Me) {
                for (var Ne = new ae(), Ee = Me.length / 2 | 0, $e = 0; $e < Ee; ++$e) {
                  var De = Me[Ee + $e], Fe = Me[$e];
                  Ne.set(De, Fe);
                }
                return Ne;
              }(this._values);
            else {
              me = {};
              for (var de = this.length(), be = 0, _e = this.length(); be < _e; ++be)
                me[this._values[be + de]] = this._values[be];
            }
            return this._resolve(me), !0;
          }
          return !1;
        }, ne.prototype.shouldCopyValues = function() {
          return !1;
        }, ne.prototype.getActualLength = function(he) {
          return he >> 1;
        }, Y.prototype.props = function() {
          return ce(this);
        }, Y.props = function(he) {
          return ce(he);
        };
      };
    }, { "./es5": 13, "./util": 36 }], 26: [function(B, K, X) {
      function Y(Q) {
        this._capacity = Q, this._length = 0, this._front = 0;
      }
      Y.prototype._willBeOverCapacity = function(Q) {
        return this._capacity < Q;
      }, Y.prototype._pushOne = function(Q) {
        var J = this.length();
        this._checkCapacity(J + 1), this[this._front + J & this._capacity - 1] = Q, this._length = J + 1;
      }, Y.prototype.push = function(Q, J, ee) {
        var ae = this.length() + 3;
        if (this._willBeOverCapacity(ae))
          return this._pushOne(Q), this._pushOne(J), void this._pushOne(ee);
        var re = this._front + ae - 3;
        this._checkCapacity(ae);
        var ie = this._capacity - 1;
        this[re + 0 & ie] = Q, this[re + 1 & ie] = J, this[re + 2 & ie] = ee, this._length = ae;
      }, Y.prototype.shift = function() {
        var Q = this._front, J = this[Q];
        return this[Q] = void 0, this._front = Q + 1 & this._capacity - 1, this._length--, J;
      }, Y.prototype.length = function() {
        return this._length;
      }, Y.prototype._checkCapacity = function(Q) {
        this._capacity < Q && this._resizeTo(this._capacity << 1);
      }, Y.prototype._resizeTo = function(Q) {
        var J = this._capacity;
        this._capacity = Q, function(ee, ae, re, ie, ue) {
          for (var q = 0; q < ue; ++q)
            re[q + ie] = ee[q + 0], ee[q + 0] = void 0;
        }(this, 0, this, J, this._front + this._length & J - 1);
      }, K.exports = Y;
    }, {}], 27: [function(B, K, X) {
      K.exports = function(Y, Q, J, ee) {
        var ae = B("./util"), re = function(ue) {
          return ue.then(function(q) {
            return ie(q, ue);
          });
        };
        function ie(ue, q) {
          var ne = J(ue);
          if (ne instanceof Y)
            return re(ne);
          if ((ue = ae.asArray(ue)) === null)
            return ee("expecting an array or an iterable object but got " + ae.classString(ue));
          var ce = new Y(Q);
          q !== void 0 && ce._propagateFrom(q, 3);
          for (var he = ce._fulfill, we = ce._reject, me = 0, de = ue.length; me < de; ++me) {
            var be = ue[me];
            (be !== void 0 || me in ue) && Y.cast(be)._then(he, we, void 0, ce, null);
          }
          return ce;
        }
        Y.race = function(ue) {
          return ie(ue, void 0);
        }, Y.prototype.race = function() {
          return ie(this, void 0);
        };
      };
    }, { "./util": 36 }], 28: [function(B, K, X) {
      K.exports = function(Y, Q, J, ee, ae, re) {
        var ie = Y._getDomain, ue = B("./util"), q = ue.tryCatch;
        function ne(de, be, _e, Me) {
          this.constructor$(de);
          var Ne = ie();
          this._fn = Ne === null ? be : ue.domainBind(Ne, be), _e !== void 0 && (_e = Y.resolve(_e))._attachCancellationCallback(this), this._initialValue = _e, this._currentCancellable = null, this._eachValues = Me === ae ? Array(this._length) : Me === 0 ? null : void 0, this._promise._captureStackTrace(), this._init$(void 0, -5);
        }
        function ce(de, be) {
          this.isFulfilled() ? be._resolve(de) : be._reject(de);
        }
        function he(de, be, _e, Me) {
          return typeof be != "function" ? J("expecting a function but got " + ue.classString(be)) : new ne(de, be, _e, Me).promise();
        }
        function we(de) {
          this.accum = de, this.array._gotAccum(de);
          var be = ee(this.value, this.array._promise);
          return be instanceof Y ? (this.array._currentCancellable = be, be._then(me, void 0, void 0, this, void 0)) : me.call(this, be);
        }
        function me(de) {
          var be, _e = this.array, Me = _e._promise, Ne = q(_e._fn);
          Me._pushContext(), (be = _e._eachValues !== void 0 ? Ne.call(Me._boundValue(), de, this.index, this.length) : Ne.call(Me._boundValue(), this.accum, de, this.index, this.length)) instanceof Y && (_e._currentCancellable = be);
          var Ee = Me._popContext();
          return re.checkForgottenReturns(be, Ee, _e._eachValues !== void 0 ? "Promise.each" : "Promise.reduce", Me), be;
        }
        ue.inherits(ne, Q), ne.prototype._gotAccum = function(de) {
          this._eachValues !== void 0 && this._eachValues !== null && de !== ae && this._eachValues.push(de);
        }, ne.prototype._eachComplete = function(de) {
          return this._eachValues !== null && this._eachValues.push(de), this._eachValues;
        }, ne.prototype._init = function() {
        }, ne.prototype._resolveEmptyArray = function() {
          this._resolve(this._eachValues !== void 0 ? this._eachValues : this._initialValue);
        }, ne.prototype.shouldCopyValues = function() {
          return !1;
        }, ne.prototype._resolve = function(de) {
          this._promise._resolveCallback(de), this._values = null;
        }, ne.prototype._resultCancelled = function(de) {
          if (de === this._initialValue)
            return this._cancel();
          this._isResolved() || (this._resultCancelled$(), this._currentCancellable instanceof Y && this._currentCancellable.cancel(), this._initialValue instanceof Y && this._initialValue.cancel());
        }, ne.prototype._iterate = function(de) {
          var be, _e;
          this._values = de;
          var Me = de.length;
          if (this._initialValue !== void 0 ? (be = this._initialValue, _e = 0) : (be = Y.resolve(de[0]), _e = 1), this._currentCancellable = be, !be.isRejected())
            for (; _e < Me; ++_e) {
              var Ne = { accum: null, value: de[_e], index: _e, length: Me, array: this };
              be = be._then(we, void 0, void 0, Ne, void 0);
            }
          this._eachValues !== void 0 && (be = be._then(this._eachComplete, void 0, void 0, this, void 0)), be._then(ce, ce, void 0, be, this);
        }, Y.prototype.reduce = function(de, be) {
          return he(this, de, be, null);
        }, Y.reduce = function(de, be, _e, Me) {
          return he(de, be, _e, Me);
        };
      };
    }, { "./util": 36 }], 29: [function(B, K, X) {
      var Y, Q = B("./util"), J = Q.getNativePromise();
      if (Q.isNode && typeof MutationObserver > "u") {
        var ee = U.setImmediate, ae = F.nextTick;
        Y = Q.isRecentNode ? function(ie) {
          ee.call(U, ie);
        } : function(ie) {
          ae.call(F, ie);
        };
      } else if (typeof J == "function" && typeof J.resolve == "function") {
        var re = J.resolve();
        Y = function(ie) {
          re.then(ie);
        };
      } else
        Y = typeof MutationObserver > "u" || typeof window < "u" && window.navigator && (window.navigator.standalone || window.cordova) ? W !== void 0 ? function(ie) {
          W(ie);
        } : typeof setTimeout < "u" ? function(ie) {
          setTimeout(ie, 0);
        } : function() {
          throw new Error(`No async scheduler available

    See http://goo.gl/MqrFmX
`);
        } : function() {
          var ie = document.createElement("div"), ue = { attributes: !0 }, q = !1, ne = document.createElement("div");
          return new MutationObserver(function() {
            ie.classList.toggle("foo"), q = !1;
          }).observe(ne, ue), function(ce) {
            var he = new MutationObserver(function() {
              he.disconnect(), ce();
            });
            he.observe(ie, ue), q || (q = !0, ne.classList.toggle("foo"));
          };
        }();
      K.exports = Y;
    }, { "./util": 36 }], 30: [function(B, K, X) {
      K.exports = function(Y, Q, J) {
        var ee = Y.PromiseInspection;
        function ae(re) {
          this.constructor$(re);
        }
        B("./util").inherits(ae, Q), ae.prototype._promiseResolved = function(re, ie) {
          return this._values[re] = ie, ++this._totalResolved >= this._length && (this._resolve(this._values), !0);
        }, ae.prototype._promiseFulfilled = function(re, ie) {
          var ue = new ee();
          return ue._bitField = 33554432, ue._settledValueField = re, this._promiseResolved(ie, ue);
        }, ae.prototype._promiseRejected = function(re, ie) {
          var ue = new ee();
          return ue._bitField = 16777216, ue._settledValueField = re, this._promiseResolved(ie, ue);
        }, Y.settle = function(re) {
          return J.deprecated(".settle()", ".reflect()"), new ae(re).promise();
        }, Y.prototype.settle = function() {
          return Y.settle(this);
        };
      };
    }, { "./util": 36 }], 31: [function(B, K, X) {
      K.exports = function(Y, Q, J) {
        var ee = B("./util"), ae = B("./errors").RangeError, re = B("./errors").AggregateError, ie = ee.isArray, ue = {};
        function q(ce) {
          this.constructor$(ce), this._howMany = 0, this._unwrap = !1, this._initialized = !1;
        }
        function ne(ce, he) {
          if ((0 | he) !== he || he < 0)
            return J(`expecting a positive integer

    See http://goo.gl/MqrFmX
`);
          var we = new q(ce), me = we.promise();
          return we.setHowMany(he), we.init(), me;
        }
        ee.inherits(q, Q), q.prototype._init = function() {
          if (this._initialized)
            if (this._howMany !== 0) {
              this._init$(void 0, -5);
              var ce = ie(this._values);
              !this._isResolved() && ce && this._howMany > this._canPossiblyFulfill() && this._reject(this._getRangeError(this.length()));
            } else
              this._resolve([]);
        }, q.prototype.init = function() {
          this._initialized = !0, this._init();
        }, q.prototype.setUnwrap = function() {
          this._unwrap = !0;
        }, q.prototype.howMany = function() {
          return this._howMany;
        }, q.prototype.setHowMany = function(ce) {
          this._howMany = ce;
        }, q.prototype._promiseFulfilled = function(ce) {
          return this._addFulfilled(ce), this._fulfilled() === this.howMany() && (this._values.length = this.howMany(), this.howMany() === 1 && this._unwrap ? this._resolve(this._values[0]) : this._resolve(this._values), !0);
        }, q.prototype._promiseRejected = function(ce) {
          return this._addRejected(ce), this._checkOutcome();
        }, q.prototype._promiseCancelled = function() {
          return this._values instanceof Y || this._values == null ? this._cancel() : (this._addRejected(ue), this._checkOutcome());
        }, q.prototype._checkOutcome = function() {
          if (this.howMany() > this._canPossiblyFulfill()) {
            for (var ce = new re(), he = this.length(); he < this._values.length; ++he)
              this._values[he] !== ue && ce.push(this._values[he]);
            return ce.length > 0 ? this._reject(ce) : this._cancel(), !0;
          }
          return !1;
        }, q.prototype._fulfilled = function() {
          return this._totalResolved;
        }, q.prototype._rejected = function() {
          return this._values.length - this.length();
        }, q.prototype._addRejected = function(ce) {
          this._values.push(ce);
        }, q.prototype._addFulfilled = function(ce) {
          this._values[this._totalResolved++] = ce;
        }, q.prototype._canPossiblyFulfill = function() {
          return this.length() - this._rejected();
        }, q.prototype._getRangeError = function(ce) {
          var he = "Input array must contain at least " + this._howMany + " items but contains only " + ce + " items";
          return new ae(he);
        }, q.prototype._resolveEmptyArray = function() {
          this._reject(this._getRangeError(0));
        }, Y.some = function(ce, he) {
          return ne(ce, he);
        }, Y.prototype.some = function(ce) {
          return ne(this, ce);
        }, Y._SomePromiseArray = q;
      };
    }, { "./errors": 12, "./util": 36 }], 32: [function(B, K, X) {
      K.exports = function(Y) {
        function Q(q) {
          q !== void 0 ? (q = q._target(), this._bitField = q._bitField, this._settledValueField = q._isFateSealed() ? q._settledValue() : void 0) : (this._bitField = 0, this._settledValueField = void 0);
        }
        Q.prototype._settledValue = function() {
          return this._settledValueField;
        };
        var J = Q.prototype.value = function() {
          if (!this.isFulfilled())
            throw new TypeError(`cannot get fulfillment value of a non-fulfilled promise

    See http://goo.gl/MqrFmX
`);
          return this._settledValue();
        }, ee = Q.prototype.error = Q.prototype.reason = function() {
          if (!this.isRejected())
            throw new TypeError(`cannot get rejection reason of a non-rejected promise

    See http://goo.gl/MqrFmX
`);
          return this._settledValue();
        }, ae = Q.prototype.isFulfilled = function() {
          return (33554432 & this._bitField) != 0;
        }, re = Q.prototype.isRejected = function() {
          return (16777216 & this._bitField) != 0;
        }, ie = Q.prototype.isPending = function() {
          return (50397184 & this._bitField) == 0;
        }, ue = Q.prototype.isResolved = function() {
          return (50331648 & this._bitField) != 0;
        };
        Q.prototype.isCancelled = function() {
          return (8454144 & this._bitField) != 0;
        }, Y.prototype.__isCancelled = function() {
          return (65536 & this._bitField) == 65536;
        }, Y.prototype._isCancelled = function() {
          return this._target().__isCancelled();
        }, Y.prototype.isCancelled = function() {
          return (8454144 & this._target()._bitField) != 0;
        }, Y.prototype.isPending = function() {
          return ie.call(this._target());
        }, Y.prototype.isRejected = function() {
          return re.call(this._target());
        }, Y.prototype.isFulfilled = function() {
          return ae.call(this._target());
        }, Y.prototype.isResolved = function() {
          return ue.call(this._target());
        }, Y.prototype.value = function() {
          return J.call(this._target());
        }, Y.prototype.reason = function() {
          var q = this._target();
          return q._unsetRejectionIsUnhandled(), ee.call(q);
        }, Y.prototype._value = function() {
          return this._settledValue();
        }, Y.prototype._reason = function() {
          return this._unsetRejectionIsUnhandled(), this._settledValue();
        }, Y.PromiseInspection = Q;
      };
    }, {}], 33: [function(B, K, X) {
      K.exports = function(Y, Q) {
        var J = B("./util"), ee = J.errorObj, ae = J.isObject, re = {}.hasOwnProperty;
        return function(ie, ue) {
          if (ae(ie)) {
            if (ie instanceof Y)
              return ie;
            var q = function(ce) {
              try {
                return function(he) {
                  return he.then;
                }(ce);
              } catch (he) {
                return ee.e = he, ee;
              }
            }(ie);
            if (q === ee) {
              ue && ue._pushContext();
              var ne = Y.reject(q.e);
              return ue && ue._popContext(), ne;
            }
            if (typeof q == "function")
              return function(ce) {
                try {
                  return re.call(ce, "_promise0");
                } catch {
                  return !1;
                }
              }(ie) ? (ne = new Y(Q), ie._then(ne._fulfill, ne._reject, void 0, ne, null), ne) : function(ce, he, we) {
                var me = new Y(Q), de = me;
                we && we._pushContext(), me._captureStackTrace(), we && we._popContext();
                var be = !0, _e = J.tryCatch(he).call(ce, function(Me) {
                  me && (me._resolveCallback(Me), me = null);
                }, function(Me) {
                  me && (me._rejectCallback(Me, be, !0), me = null);
                });
                return be = !1, me && _e === ee && (me._rejectCallback(_e.e, !0, !0), me = null), de;
              }(ie, q, ue);
          }
          return ie;
        };
      };
    }, { "./util": 36 }], 34: [function(B, K, X) {
      K.exports = function(Y, Q, J) {
        var ee = B("./util"), ae = Y.TimeoutError;
        function re(ce) {
          this.handle = ce;
        }
        re.prototype._resultCancelled = function() {
          clearTimeout(this.handle);
        };
        var ie = function(ce) {
          return ue(+this).thenReturn(ce);
        }, ue = Y.delay = function(ce, he) {
          var we, me;
          return he !== void 0 ? (we = Y.resolve(he)._then(ie, null, null, ce, void 0), J.cancellation() && he instanceof Y && we._setOnCancel(he)) : (we = new Y(Q), me = setTimeout(function() {
            we._fulfill();
          }, +ce), J.cancellation() && we._setOnCancel(new re(me)), we._captureStackTrace()), we._setAsyncGuaranteed(), we;
        };
        function q(ce) {
          return clearTimeout(this.handle), ce;
        }
        function ne(ce) {
          throw clearTimeout(this.handle), ce;
        }
        Y.prototype.delay = function(ce) {
          return ue(ce, this);
        }, Y.prototype.timeout = function(ce, he) {
          var we, me;
          ce = +ce;
          var de = new re(setTimeout(function() {
            we.isPending() && function(be, _e, Me) {
              var Ne;
              Ne = typeof _e != "string" ? _e instanceof Error ? _e : new ae("operation timed out") : new ae(_e), ee.markAsOriginatingFromRejection(Ne), be._attachExtraTrace(Ne), be._reject(Ne), Me != null && Me.cancel();
            }(we, he, me);
          }, ce));
          return J.cancellation() ? (me = this.then(), (we = me._then(q, ne, void 0, de, void 0))._setOnCancel(de)) : we = this._then(q, ne, void 0, de, void 0), we;
        };
      };
    }, { "./util": 36 }], 35: [function(B, K, X) {
      K.exports = function(Y, Q, J, ee, ae, re) {
        var ie = B("./util"), ue = B("./errors").TypeError, q = B("./util").inherits, ne = ie.errorObj, ce = ie.tryCatch, he = {};
        function we(Ne) {
          setTimeout(function() {
            throw Ne;
          }, 0);
        }
        function me(Ne, Ee) {
          var $e = 0, De = Ne.length, Fe = new Y(ae);
          return function Be() {
            if ($e >= De)
              return Fe._fulfill();
            var We = function(Ve) {
              var ze = J(Ve);
              return ze !== Ve && typeof Ve._isDisposable == "function" && typeof Ve._getDisposer == "function" && Ve._isDisposable() && ze._setDisposable(Ve._getDisposer()), ze;
            }(Ne[$e++]);
            if (We instanceof Y && We._isDisposable()) {
              try {
                We = J(We._getDisposer().tryDispose(Ee), Ne.promise);
              } catch (Ve) {
                return we(Ve);
              }
              if (We instanceof Y)
                return We._then(Be, we, null, null, null);
            }
            Be();
          }(), Fe;
        }
        function de(Ne, Ee, $e) {
          this._data = Ne, this._promise = Ee, this._context = $e;
        }
        function be(Ne, Ee, $e) {
          this.constructor$(Ne, Ee, $e);
        }
        function _e(Ne) {
          return de.isDisposer(Ne) ? (this.resources[this.index]._setDisposable(Ne), Ne.promise()) : Ne;
        }
        function Me(Ne) {
          this.length = Ne, this.promise = null, this[Ne - 1] = null;
        }
        de.prototype.data = function() {
          return this._data;
        }, de.prototype.promise = function() {
          return this._promise;
        }, de.prototype.resource = function() {
          return this.promise().isFulfilled() ? this.promise().value() : he;
        }, de.prototype.tryDispose = function(Ne) {
          var Ee = this.resource(), $e = this._context;
          $e !== void 0 && $e._pushContext();
          var De = Ee !== he ? this.doDispose(Ee, Ne) : null;
          return $e !== void 0 && $e._popContext(), this._promise._unsetDisposable(), this._data = null, De;
        }, de.isDisposer = function(Ne) {
          return Ne != null && typeof Ne.resource == "function" && typeof Ne.tryDispose == "function";
        }, q(be, de), be.prototype.doDispose = function(Ne, Ee) {
          return this.data().call(Ne, Ne, Ee);
        }, Me.prototype._resultCancelled = function() {
          for (var Ne = this.length, Ee = 0; Ee < Ne; ++Ee) {
            var $e = this[Ee];
            $e instanceof Y && $e.cancel();
          }
        }, Y.using = function() {
          var Ne = arguments.length;
          if (Ne < 2)
            return Q("you must pass at least 2 arguments to Promise.using");
          var Ee, $e = arguments[Ne - 1];
          if (typeof $e != "function")
            return Q("expecting a function but got " + ie.classString($e));
          var De = !0;
          Ne === 2 && Array.isArray(arguments[0]) ? (Ne = (Ee = arguments[0]).length, De = !1) : (Ee = arguments, Ne--);
          for (var Fe = new Me(Ne), Be = 0; Be < Ne; ++Be) {
            var We = Ee[Be];
            if (de.isDisposer(We)) {
              var Ve = We;
              (We = We.promise())._setDisposable(Ve);
            } else {
              var ze = J(We);
              ze instanceof Y && (We = ze._then(_e, null, null, { resources: Fe, index: Be }, void 0));
            }
            Fe[Be] = We;
          }
          var ke = new Array(Fe.length);
          for (Be = 0; Be < ke.length; ++Be)
            ke[Be] = Y.resolve(Fe[Be]).reflect();
          var je = Y.all(ke).then(function(ve) {
            for (var xe = 0; xe < ve.length; ++xe) {
              var Oe = ve[xe];
              if (Oe.isRejected())
                return ne.e = Oe.error(), ne;
              if (!Oe.isFulfilled())
                return void je.cancel();
              ve[xe] = Oe.value();
            }
            Ie._pushContext(), $e = ce($e);
            var Te = De ? $e.apply(void 0, ve) : $e(ve), Ce = Ie._popContext();
            return re.checkForgottenReturns(Te, Ce, "Promise.using", Ie), Te;
          }), Ie = je.lastly(function() {
            var ve = new Y.PromiseInspection(je);
            return me(Fe, ve);
          });
          return Fe.promise = Ie, Ie._setOnCancel(Fe), Ie;
        }, Y.prototype._setDisposable = function(Ne) {
          this._bitField = 131072 | this._bitField, this._disposer = Ne;
        }, Y.prototype._isDisposable = function() {
          return (131072 & this._bitField) > 0;
        }, Y.prototype._getDisposer = function() {
          return this._disposer;
        }, Y.prototype._unsetDisposable = function() {
          this._bitField = -131073 & this._bitField, this._disposer = void 0;
        }, Y.prototype.disposer = function(Ne) {
          if (typeof Ne == "function")
            return new be(Ne, this, ee());
          throw new ue();
        };
      };
    }, { "./errors": 12, "./util": 36 }], 36: [function(B, K, X) {
      var Y, Q = B("./es5"), J = typeof navigator > "u", ee = { e: {} }, ae = typeof self < "u" ? self : typeof window < "u" ? window : U !== void 0 ? U : this !== void 0 ? this : null;
      function re() {
        try {
          var De = Y;
          return Y = null, De.apply(this, arguments);
        } catch (Fe) {
          return ee.e = Fe, ee;
        }
      }
      function ie(De) {
        return De == null || De === !0 || De === !1 || typeof De == "string" || typeof De == "number";
      }
      function ue(De, Fe, Be) {
        if (ie(De))
          return De;
        var We = { value: Be, configurable: !0, enumerable: !1, writable: !0 };
        return Q.defineProperty(De, Fe, We), De;
      }
      var q = function() {
        var De = [Array.prototype, Object.prototype, Function.prototype], Fe = function(Ve) {
          for (var ze = 0; ze < De.length; ++ze)
            if (De[ze] === Ve)
              return !0;
          return !1;
        };
        if (Q.isES5) {
          var Be = Object.getOwnPropertyNames;
          return function(Ve) {
            for (var ze = [], ke = /* @__PURE__ */ Object.create(null); Ve != null && !Fe(Ve); ) {
              var je;
              try {
                je = Be(Ve);
              } catch {
                return ze;
              }
              for (var Ie = 0; Ie < je.length; ++Ie) {
                var ve = je[Ie];
                if (!ke[ve]) {
                  ke[ve] = !0;
                  var xe = Object.getOwnPropertyDescriptor(Ve, ve);
                  xe != null && xe.get == null && xe.set == null && ze.push(ve);
                }
              }
              Ve = Q.getPrototypeOf(Ve);
            }
            return ze;
          };
        }
        var We = {}.hasOwnProperty;
        return function(Ve) {
          if (Fe(Ve))
            return [];
          var ze = [];
          e:
            for (var ke in Ve)
              if (We.call(Ve, ke))
                ze.push(ke);
              else {
                for (var je = 0; je < De.length; ++je)
                  if (We.call(De[je], ke))
                    continue e;
                ze.push(ke);
              }
          return ze;
        };
      }(), ne = /this\s*\.\s*\S+\s*=/, ce = /^[a-z$_][a-z$_0-9]*$/i;
      function he(De) {
        try {
          return De + "";
        } catch {
          return "[no string representation]";
        }
      }
      function we(De) {
        return De instanceof Error || De !== null && typeof De == "object" && typeof De.message == "string" && typeof De.name == "string";
      }
      function me(De) {
        return we(De) && Q.propertyIsWritable(De, "stack");
      }
      var de = "stack" in new Error() ? function(De) {
        return me(De) ? De : new Error(he(De));
      } : function(De) {
        if (me(De))
          return De;
        try {
          throw new Error(he(De));
        } catch (Fe) {
          return Fe;
        }
      };
      function be(De) {
        return {}.toString.call(De);
      }
      var _e = function(De) {
        return Q.isArray(De) ? De : null;
      };
      if (typeof Symbol < "u" && Symbol.iterator) {
        var Me = typeof Array.from == "function" ? function(De) {
          return Array.from(De);
        } : function(De) {
          for (var Fe, Be = [], We = De[Symbol.iterator](); !(Fe = We.next()).done; )
            Be.push(Fe.value);
          return Be;
        };
        _e = function(De) {
          return Q.isArray(De) ? De : De != null && typeof De[Symbol.iterator] == "function" ? Me(De) : null;
        };
      }
      var Ne = F !== void 0 && be(F).toLowerCase() === "[object process]", Ee = F !== void 0 && F.env !== void 0, $e = { isClass: function(De) {
        try {
          if (typeof De == "function") {
            var Fe = Q.names(De.prototype), Be = Q.isES5 && Fe.length > 1, We = Fe.length > 0 && !(Fe.length === 1 && Fe[0] === "constructor"), Ve = ne.test(De + "") && Q.names(De).length > 0;
            if (Be || We || Ve)
              return !0;
          }
          return !1;
        } catch {
          return !1;
        }
      }, isIdentifier: function(De) {
        return ce.test(De);
      }, inheritedDataKeys: q, getDataPropertyOrDefault: function(De, Fe, Be) {
        if (!Q.isES5)
          return {}.hasOwnProperty.call(De, Fe) ? De[Fe] : void 0;
        var We = Object.getOwnPropertyDescriptor(De, Fe);
        return We != null ? We.get == null && We.set == null ? We.value : Be : void 0;
      }, thrower: function(De) {
        throw De;
      }, isArray: Q.isArray, asArray: _e, notEnumerableProp: ue, isPrimitive: ie, isObject: function(De) {
        return typeof De == "function" || typeof De == "object" && De !== null;
      }, isError: we, canEvaluate: J, errorObj: ee, tryCatch: function(De) {
        return Y = De, re;
      }, inherits: function(De, Fe) {
        var Be = {}.hasOwnProperty;
        function We() {
          for (var Ve in this.constructor = De, this.constructor$ = Fe, Fe.prototype)
            Be.call(Fe.prototype, Ve) && Ve.charAt(Ve.length - 1) !== "$" && (this[Ve + "$"] = Fe.prototype[Ve]);
        }
        return We.prototype = Fe.prototype, De.prototype = new We(), De.prototype;
      }, withAppended: function(De, Fe) {
        var Be, We = De.length, Ve = new Array(We + 1);
        for (Be = 0; Be < We; ++Be)
          Ve[Be] = De[Be];
        return Ve[Be] = Fe, Ve;
      }, maybeWrapAsError: function(De) {
        return ie(De) ? new Error(he(De)) : De;
      }, toFastProperties: function(De) {
        return De;
      }, filledRange: function(De, Fe, Be) {
        for (var We = new Array(De), Ve = 0; Ve < De; ++Ve)
          We[Ve] = Fe + Ve + Be;
        return We;
      }, toString: he, canAttachTrace: me, ensureErrorObject: de, originatesFromRejection: function(De) {
        return De != null && (De instanceof Error.__BluebirdErrorTypes__.OperationalError || De.isOperational === !0);
      }, markAsOriginatingFromRejection: function(De) {
        try {
          ue(De, "isOperational", !0);
        } catch {
        }
      }, classString: be, copyDescriptors: function(De, Fe, Be) {
        for (var We = Q.names(De), Ve = 0; Ve < We.length; ++Ve) {
          var ze = We[Ve];
          if (Be(ze))
            try {
              Q.defineProperty(Fe, ze, Q.getDescriptor(De, ze));
            } catch {
            }
        }
      }, hasDevTools: typeof chrome < "u" && chrome && typeof chrome.loadTimes == "function", isNode: Ne, hasEnvVariables: Ee, env: function(De) {
        return Ee ? F.env[De] : void 0;
      }, global: ae, getNativePromise: function() {
        if (typeof Promise == "function")
          try {
            var De = new Promise(function() {
            });
            if ({}.toString.call(De) === "[object Promise]")
              return Promise;
          } catch {
          }
      }, domainBind: function(De, Fe) {
        return De.bind(Fe);
      } };
      $e.isRecentNode = $e.isNode && function() {
        var De = F.versions.node.split(".").map(Number);
        return De[0] === 0 && De[1] > 10 || De[0] > 0;
      }(), $e.isNode && $e.toFastProperties(F);
      try {
        throw new Error();
      } catch (De) {
        $e.lastLineError = De;
      }
      K.exports = $e;
    }, { "./es5": 13 }] }, {}, [4])(4), typeof window < "u" && window !== null ? window.P = window.Promise : typeof self < "u" && self !== null && (self.P = self.Promise);
  }).call(this, O(4), O(0), O(11).setImmediate);
}, function(z, D, O) {
  Object.defineProperty(D, "__esModule", { value: !0 }), D.default = function(F, U) {
    if (!U.eol && F) {
      for (var W = 0, B = F.length; W < B; W++)
        if (F[W] === "\r") {
          if (F[W + 1] === `
`) {
            U.eol = `\r
`;
            break;
          }
          if (F[W + 1]) {
            U.eol = "\r";
            break;
          }
        } else if (F[W] === `
`) {
          U.eol = `
`;
          break;
        }
    }
    return U.eol || `
`;
  };
}, function(z, D, O) {
  var F = O(65), U = O(73);
  z.exports = function(W, B) {
    var K = U(W, B);
    return F(K) ? K : void 0;
  };
}, function(z, D, O) {
  var F = O(19).Symbol;
  z.exports = F;
}, function(z, D, O) {
  var F = O(67), U = typeof self == "object" && self && self.Object === Object && self, W = F || U || Function("return this")();
  z.exports = W;
}, function(z, D) {
  z.exports = function(O) {
    var F = typeof O;
    return O != null && (F == "object" || F == "function");
  };
}, function(z, D) {
  var O = Array.isArray;
  z.exports = O;
}, function(z, D, O) {
  var F = O(30), U = O(76);
  z.exports = function(W) {
    return typeof W == "symbol" || U(W) && F(W) == "[object Symbol]";
  };
}, function(z, D, O) {
  (function(F, U) {
    var W = O(6);
    z.exports = he;
    var B, K = O(37);
    he.ReadableState = ce, O(12).EventEmitter;
    var X = function(ke, je) {
      return ke.listeners(je).length;
    }, Y = O(24), Q = O(7).Buffer, J = F.Uint8Array || function() {
    }, ee = O(5);
    ee.inherits = O(2);
    var ae = O(41), re = void 0;
    re = ae && ae.debuglog ? ae.debuglog("stream") : function() {
    };
    var ie, ue = O(42), q = O(25);
    ee.inherits(he, Y);
    var ne = ["error", "close", "destroy", "pause", "resume"];
    function ce(ke, je) {
      B = B || O(1), ke = ke || {};
      var Ie = je instanceof B;
      this.objectMode = !!ke.objectMode, Ie && (this.objectMode = this.objectMode || !!ke.readableObjectMode);
      var ve = ke.highWaterMark, xe = ke.readableHighWaterMark, Oe = this.objectMode ? 16 : 16384;
      this.highWaterMark = ve || ve === 0 ? ve : Ie && (xe || xe === 0) ? xe : Oe, this.highWaterMark = Math.floor(this.highWaterMark), this.buffer = new ue(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.destroyed = !1, this.defaultEncoding = ke.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, ke.encoding && (ie || (ie = O(26).StringDecoder), this.decoder = new ie(ke.encoding), this.encoding = ke.encoding);
    }
    function he(ke) {
      if (B = B || O(1), !(this instanceof he))
        return new he(ke);
      this._readableState = new ce(ke, this), this.readable = !0, ke && (typeof ke.read == "function" && (this._read = ke.read), typeof ke.destroy == "function" && (this._destroy = ke.destroy)), Y.call(this);
    }
    function we(ke, je, Ie, ve, xe) {
      var Oe, Te = ke._readableState;
      return je === null ? (Te.reading = !1, function(Ce, te) {
        if (!te.ended) {
          if (te.decoder) {
            var le = te.decoder.end();
            le && le.length && (te.buffer.push(le), te.length += te.objectMode ? 1 : le.length);
          }
          te.ended = !0, _e(Ce);
        }
      }(ke, Te)) : (xe || (Oe = function(Ce, te) {
        var le;
        return function(ge) {
          return Q.isBuffer(ge) || ge instanceof J;
        }(te) || typeof te == "string" || te === void 0 || Ce.objectMode || (le = new TypeError("Invalid non-string/buffer chunk")), le;
      }(Te, je)), Oe ? ke.emit("error", Oe) : Te.objectMode || je && je.length > 0 ? (typeof je == "string" || Te.objectMode || Object.getPrototypeOf(je) === Q.prototype || (je = function(Ce) {
        return Q.from(Ce);
      }(je)), ve ? Te.endEmitted ? ke.emit("error", new Error("stream.unshift() after end event")) : me(ke, Te, je, !0) : Te.ended ? ke.emit("error", new Error("stream.push() after EOF")) : (Te.reading = !1, Te.decoder && !Ie ? (je = Te.decoder.write(je), Te.objectMode || je.length !== 0 ? me(ke, Te, je, !1) : Ne(ke, Te)) : me(ke, Te, je, !1))) : ve || (Te.reading = !1)), function(Ce) {
        return !Ce.ended && (Ce.needReadable || Ce.length < Ce.highWaterMark || Ce.length === 0);
      }(Te);
    }
    function me(ke, je, Ie, ve) {
      je.flowing && je.length === 0 && !je.sync ? (ke.emit("data", Ie), ke.read(0)) : (je.length += je.objectMode ? 1 : Ie.length, ve ? je.buffer.unshift(Ie) : je.buffer.push(Ie), je.needReadable && _e(ke)), Ne(ke, je);
    }
    Object.defineProperty(he.prototype, "destroyed", { get: function() {
      return this._readableState !== void 0 && this._readableState.destroyed;
    }, set: function(ke) {
      this._readableState && (this._readableState.destroyed = ke);
    } }), he.prototype.destroy = q.destroy, he.prototype._undestroy = q.undestroy, he.prototype._destroy = function(ke, je) {
      this.push(null), je(ke);
    }, he.prototype.push = function(ke, je) {
      var Ie, ve = this._readableState;
      return ve.objectMode ? Ie = !0 : typeof ke == "string" && ((je = je || ve.defaultEncoding) !== ve.encoding && (ke = Q.from(ke, je), je = ""), Ie = !0), we(this, ke, je, !1, Ie);
    }, he.prototype.unshift = function(ke) {
      return we(this, ke, null, !0, !1);
    }, he.prototype.isPaused = function() {
      return this._readableState.flowing === !1;
    }, he.prototype.setEncoding = function(ke) {
      return ie || (ie = O(26).StringDecoder), this._readableState.decoder = new ie(ke), this._readableState.encoding = ke, this;
    };
    var de = 8388608;
    function be(ke, je) {
      return ke <= 0 || je.length === 0 && je.ended ? 0 : je.objectMode ? 1 : ke != ke ? je.flowing && je.length ? je.buffer.head.data.length : je.length : (ke > je.highWaterMark && (je.highWaterMark = function(Ie) {
        return Ie >= de ? Ie = de : (Ie--, Ie |= Ie >>> 1, Ie |= Ie >>> 2, Ie |= Ie >>> 4, Ie |= Ie >>> 8, Ie |= Ie >>> 16, Ie++), Ie;
      }(ke)), ke <= je.length ? ke : je.ended ? je.length : (je.needReadable = !0, 0));
    }
    function _e(ke) {
      var je = ke._readableState;
      je.needReadable = !1, je.emittedReadable || (re("emitReadable", je.flowing), je.emittedReadable = !0, je.sync ? W.nextTick(Me, ke) : Me(ke));
    }
    function Me(ke) {
      re("emit readable"), ke.emit("readable"), Fe(ke);
    }
    function Ne(ke, je) {
      je.readingMore || (je.readingMore = !0, W.nextTick(Ee, ke, je));
    }
    function Ee(ke, je) {
      for (var Ie = je.length; !je.reading && !je.flowing && !je.ended && je.length < je.highWaterMark && (re("maybeReadMore read 0"), ke.read(0), Ie !== je.length); )
        Ie = je.length;
      je.readingMore = !1;
    }
    function $e(ke) {
      re("readable nexttick read 0"), ke.read(0);
    }
    function De(ke, je) {
      je.reading || (re("resume read 0"), ke.read(0)), je.resumeScheduled = !1, je.awaitDrain = 0, ke.emit("resume"), Fe(ke), je.flowing && !je.reading && ke.read(0);
    }
    function Fe(ke) {
      var je = ke._readableState;
      for (re("flow", je.flowing); je.flowing && ke.read() !== null; )
        ;
    }
    function Be(ke, je) {
      return je.length === 0 ? null : (je.objectMode ? Ie = je.buffer.shift() : !ke || ke >= je.length ? (Ie = je.decoder ? je.buffer.join("") : je.buffer.length === 1 ? je.buffer.head.data : je.buffer.concat(je.length), je.buffer.clear()) : Ie = function(ve, xe, Oe) {
        var Te;
        return ve < xe.head.data.length ? (Te = xe.head.data.slice(0, ve), xe.head.data = xe.head.data.slice(ve)) : Te = ve === xe.head.data.length ? xe.shift() : Oe ? function(Ce, te) {
          var le = te.head, ge = 1, pe = le.data;
          for (Ce -= pe.length; le = le.next; ) {
            var fe = le.data, Se = Ce > fe.length ? fe.length : Ce;
            if (Se === fe.length ? pe += fe : pe += fe.slice(0, Ce), (Ce -= Se) == 0) {
              Se === fe.length ? (++ge, le.next ? te.head = le.next : te.head = te.tail = null) : (te.head = le, le.data = fe.slice(Se));
              break;
            }
            ++ge;
          }
          return te.length -= ge, pe;
        }(ve, xe) : function(Ce, te) {
          var le = Q.allocUnsafe(Ce), ge = te.head, pe = 1;
          for (ge.data.copy(le), Ce -= ge.data.length; ge = ge.next; ) {
            var fe = ge.data, Se = Ce > fe.length ? fe.length : Ce;
            if (fe.copy(le, le.length - Ce, 0, Se), (Ce -= Se) == 0) {
              Se === fe.length ? (++pe, ge.next ? te.head = ge.next : te.head = te.tail = null) : (te.head = ge, ge.data = fe.slice(Se));
              break;
            }
            ++pe;
          }
          return te.length -= pe, le;
        }(ve, xe), Te;
      }(ke, je.buffer, je.decoder), Ie);
      var Ie;
    }
    function We(ke) {
      var je = ke._readableState;
      if (je.length > 0)
        throw new Error('"endReadable()" called on non-empty stream');
      je.endEmitted || (je.ended = !0, W.nextTick(Ve, je, ke));
    }
    function Ve(ke, je) {
      ke.endEmitted || ke.length !== 0 || (ke.endEmitted = !0, je.readable = !1, je.emit("end"));
    }
    function ze(ke, je) {
      for (var Ie = 0, ve = ke.length; Ie < ve; Ie++)
        if (ke[Ie] === je)
          return Ie;
      return -1;
    }
    he.prototype.read = function(ke) {
      re("read", ke), ke = parseInt(ke, 10);
      var je = this._readableState, Ie = ke;
      if (ke !== 0 && (je.emittedReadable = !1), ke === 0 && je.needReadable && (je.length >= je.highWaterMark || je.ended))
        return re("read: emitReadable", je.length, je.ended), je.length === 0 && je.ended ? We(this) : _e(this), null;
      if ((ke = be(ke, je)) === 0 && je.ended)
        return je.length === 0 && We(this), null;
      var ve, xe = je.needReadable;
      return re("need readable", xe), (je.length === 0 || je.length - ke < je.highWaterMark) && re("length less than watermark", xe = !0), je.ended || je.reading ? re("reading or ended", xe = !1) : xe && (re("do read"), je.reading = !0, je.sync = !0, je.length === 0 && (je.needReadable = !0), this._read(je.highWaterMark), je.sync = !1, je.reading || (ke = be(Ie, je))), (ve = ke > 0 ? Be(ke, je) : null) === null ? (je.needReadable = !0, ke = 0) : je.length -= ke, je.length === 0 && (je.ended || (je.needReadable = !0), Ie !== ke && je.ended && We(this)), ve !== null && this.emit("data", ve), ve;
    }, he.prototype._read = function(ke) {
      this.emit("error", new Error("_read() is not implemented"));
    }, he.prototype.pipe = function(ke, je) {
      var Ie = this, ve = this._readableState;
      switch (ve.pipesCount) {
        case 0:
          ve.pipes = ke;
          break;
        case 1:
          ve.pipes = [ve.pipes, ke];
          break;
        default:
          ve.pipes.push(ke);
      }
      ve.pipesCount += 1, re("pipe count=%d opts=%j", ve.pipesCount, je);
      var xe = je && je.end === !1 || ke === U.stdout || ke === U.stderr ? Se : Oe;
      function Oe() {
        re("onend"), ke.end();
      }
      ve.endEmitted ? W.nextTick(xe) : Ie.once("end", xe), ke.on("unpipe", function Pe(Ge, Qe) {
        re("onunpipe"), Ge === Ie && Qe && Qe.hasUnpiped === !1 && (Qe.hasUnpiped = !0, re("cleanup"), ke.removeListener("close", pe), ke.removeListener("finish", fe), ke.removeListener("drain", Te), ke.removeListener("error", ge), ke.removeListener("unpipe", Pe), Ie.removeListener("end", Oe), Ie.removeListener("end", Se), Ie.removeListener("data", le), Ce = !0, !ve.awaitDrain || ke._writableState && !ke._writableState.needDrain || Te());
      });
      var Te = /* @__PURE__ */ function(Pe) {
        return function() {
          var Ge = Pe._readableState;
          re("pipeOnDrain", Ge.awaitDrain), Ge.awaitDrain && Ge.awaitDrain--, Ge.awaitDrain === 0 && X(Pe, "data") && (Ge.flowing = !0, Fe(Pe));
        };
      }(Ie);
      ke.on("drain", Te);
      var Ce = !1, te = !1;
      function le(Pe) {
        re("ondata"), te = !1, ke.write(Pe) !== !1 || te || ((ve.pipesCount === 1 && ve.pipes === ke || ve.pipesCount > 1 && ze(ve.pipes, ke) !== -1) && !Ce && (re("false write response, pause", Ie._readableState.awaitDrain), Ie._readableState.awaitDrain++, te = !0), Ie.pause());
      }
      function ge(Pe) {
        re("onerror", Pe), Se(), ke.removeListener("error", ge), X(ke, "error") === 0 && ke.emit("error", Pe);
      }
      function pe() {
        ke.removeListener("finish", fe), Se();
      }
      function fe() {
        re("onfinish"), ke.removeListener("close", pe), Se();
      }
      function Se() {
        re("unpipe"), Ie.unpipe(ke);
      }
      return Ie.on("data", le), function(Pe, Ge, Qe) {
        if (typeof Pe.prependListener == "function")
          return Pe.prependListener(Ge, Qe);
        Pe._events && Pe._events[Ge] ? K(Pe._events[Ge]) ? Pe._events[Ge].unshift(Qe) : Pe._events[Ge] = [Qe, Pe._events[Ge]] : Pe.on(Ge, Qe);
      }(ke, "error", ge), ke.once("close", pe), ke.once("finish", fe), ke.emit("pipe", Ie), ve.flowing || (re("pipe resume"), Ie.resume()), ke;
    }, he.prototype.unpipe = function(ke) {
      var je = this._readableState, Ie = { hasUnpiped: !1 };
      if (je.pipesCount === 0)
        return this;
      if (je.pipesCount === 1)
        return ke && ke !== je.pipes ? this : (ke || (ke = je.pipes), je.pipes = null, je.pipesCount = 0, je.flowing = !1, ke && ke.emit("unpipe", this, Ie), this);
      if (!ke) {
        var ve = je.pipes, xe = je.pipesCount;
        je.pipes = null, je.pipesCount = 0, je.flowing = !1;
        for (var Oe = 0; Oe < xe; Oe++)
          ve[Oe].emit("unpipe", this, Ie);
        return this;
      }
      var Te = ze(je.pipes, ke);
      return Te === -1 ? this : (je.pipes.splice(Te, 1), je.pipesCount -= 1, je.pipesCount === 1 && (je.pipes = je.pipes[0]), ke.emit("unpipe", this, Ie), this);
    }, he.prototype.on = function(ke, je) {
      var Ie = Y.prototype.on.call(this, ke, je);
      if (ke === "data")
        this._readableState.flowing !== !1 && this.resume();
      else if (ke === "readable") {
        var ve = this._readableState;
        ve.endEmitted || ve.readableListening || (ve.readableListening = ve.needReadable = !0, ve.emittedReadable = !1, ve.reading ? ve.length && _e(this) : W.nextTick($e, this));
      }
      return Ie;
    }, he.prototype.addListener = he.prototype.on, he.prototype.resume = function() {
      var ke = this._readableState;
      return ke.flowing || (re("resume"), ke.flowing = !0, function(je, Ie) {
        Ie.resumeScheduled || (Ie.resumeScheduled = !0, W.nextTick(De, je, Ie));
      }(this, ke)), this;
    }, he.prototype.pause = function() {
      return re("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1 && (re("pause"), this._readableState.flowing = !1, this.emit("pause")), this;
    }, he.prototype.wrap = function(ke) {
      var je = this, Ie = this._readableState, ve = !1;
      for (var xe in ke.on("end", function() {
        if (re("wrapped end"), Ie.decoder && !Ie.ended) {
          var Te = Ie.decoder.end();
          Te && Te.length && je.push(Te);
        }
        je.push(null);
      }), ke.on("data", function(Te) {
        re("wrapped data"), Ie.decoder && (Te = Ie.decoder.write(Te)), (!Ie.objectMode || Te != null) && (Ie.objectMode || Te && Te.length) && (je.push(Te) || (ve = !0, ke.pause()));
      }), ke)
        this[xe] === void 0 && typeof ke[xe] == "function" && (this[xe] = /* @__PURE__ */ function(Te) {
          return function() {
            return ke[Te].apply(ke, arguments);
          };
        }(xe));
      for (var Oe = 0; Oe < ne.length; Oe++)
        ke.on(ne[Oe], this.emit.bind(this, ne[Oe]));
      return this._read = function(Te) {
        re("wrapped _read", Te), ve && (ve = !1, ke.resume());
      }, this;
    }, Object.defineProperty(he.prototype, "readableHighWaterMark", { enumerable: !1, get: function() {
      return this._readableState.highWaterMark;
    } }), he._fromList = Be;
  }).call(this, O(0), O(4));
}, function(z, D, O) {
  z.exports = O(12).EventEmitter;
}, function(z, D, O) {
  var F = O(6);
  function U(W, B) {
    W.emit("error", B);
  }
  z.exports = { destroy: function(W, B) {
    var K = this, X = this._readableState && this._readableState.destroyed, Y = this._writableState && this._writableState.destroyed;
    return X || Y ? (B ? B(W) : !W || this._writableState && this._writableState.errorEmitted || F.nextTick(U, this, W), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this._writableState.destroyed = !0), this._destroy(W || null, function(Q) {
      !B && Q ? (F.nextTick(U, K, Q), K._writableState && (K._writableState.errorEmitted = !0)) : B && B(Q);
    }), this);
  }, undestroy: function() {
    this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending = !1, this._writableState.finished = !1, this._writableState.errorEmitted = !1);
  } };
}, function(z, D, O) {
  var F = O(7).Buffer, U = F.isEncoding || function(re) {
    switch ((re = "" + re) && re.toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
      case "raw":
        return !0;
      default:
        return !1;
    }
  };
  function W(re) {
    var ie;
    switch (this.encoding = function(ue) {
      var q = function(ne) {
        if (!ne)
          return "utf8";
        for (var ce; ; )
          switch (ne) {
            case "utf8":
            case "utf-8":
              return "utf8";
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return "utf16le";
            case "latin1":
            case "binary":
              return "latin1";
            case "base64":
            case "ascii":
            case "hex":
              return ne;
            default:
              if (ce)
                return;
              ne = ("" + ne).toLowerCase(), ce = !0;
          }
      }(ue);
      if (typeof q != "string" && (F.isEncoding === U || !U(ue)))
        throw new Error("Unknown encoding: " + ue);
      return q || ue;
    }(re), this.encoding) {
      case "utf16le":
        this.text = X, this.end = Y, ie = 4;
        break;
      case "utf8":
        this.fillLast = K, ie = 4;
        break;
      case "base64":
        this.text = Q, this.end = J, ie = 3;
        break;
      default:
        return this.write = ee, void (this.end = ae);
    }
    this.lastNeed = 0, this.lastTotal = 0, this.lastChar = F.allocUnsafe(ie);
  }
  function B(re) {
    return re <= 127 ? 0 : re >> 5 == 6 ? 2 : re >> 4 == 14 ? 3 : re >> 3 == 30 ? 4 : re >> 6 == 2 ? -1 : -2;
  }
  function K(re) {
    var ie = this.lastTotal - this.lastNeed, ue = function(q, ne, ce) {
      if ((192 & ne[0]) != 128)
        return q.lastNeed = 0, "";
      if (q.lastNeed > 1 && ne.length > 1) {
        if ((192 & ne[1]) != 128)
          return q.lastNeed = 1, "";
        if (q.lastNeed > 2 && ne.length > 2 && (192 & ne[2]) != 128)
          return q.lastNeed = 2, "";
      }
    }(this, re);
    return ue !== void 0 ? ue : this.lastNeed <= re.length ? (re.copy(this.lastChar, ie, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal)) : (re.copy(this.lastChar, ie, 0, re.length), void (this.lastNeed -= re.length));
  }
  function X(re, ie) {
    if ((re.length - ie) % 2 == 0) {
      var ue = re.toString("utf16le", ie);
      if (ue) {
        var q = ue.charCodeAt(ue.length - 1);
        if (q >= 55296 && q <= 56319)
          return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = re[re.length - 2], this.lastChar[1] = re[re.length - 1], ue.slice(0, -1);
      }
      return ue;
    }
    return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = re[re.length - 1], re.toString("utf16le", ie, re.length - 1);
  }
  function Y(re) {
    var ie = re && re.length ? this.write(re) : "";
    if (this.lastNeed) {
      var ue = this.lastTotal - this.lastNeed;
      return ie + this.lastChar.toString("utf16le", 0, ue);
    }
    return ie;
  }
  function Q(re, ie) {
    var ue = (re.length - ie) % 3;
    return ue === 0 ? re.toString("base64", ie) : (this.lastNeed = 3 - ue, this.lastTotal = 3, ue === 1 ? this.lastChar[0] = re[re.length - 1] : (this.lastChar[0] = re[re.length - 2], this.lastChar[1] = re[re.length - 1]), re.toString("base64", ie, re.length - ue));
  }
  function J(re) {
    var ie = re && re.length ? this.write(re) : "";
    return this.lastNeed ? ie + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : ie;
  }
  function ee(re) {
    return re.toString(this.encoding);
  }
  function ae(re) {
    return re && re.length ? this.write(re) : "";
  }
  D.StringDecoder = W, W.prototype.write = function(re) {
    if (re.length === 0)
      return "";
    var ie, ue;
    if (this.lastNeed) {
      if ((ie = this.fillLast(re)) === void 0)
        return "";
      ue = this.lastNeed, this.lastNeed = 0;
    } else
      ue = 0;
    return ue < re.length ? ie ? ie + this.text(re, ue) : this.text(re, ue) : ie || "";
  }, W.prototype.end = function(re) {
    var ie = re && re.length ? this.write(re) : "";
    return this.lastNeed ? ie + "" : ie;
  }, W.prototype.text = function(re, ie) {
    var ue = function(ne, ce, he) {
      var we = ce.length - 1;
      if (we < he)
        return 0;
      var me = B(ce[we]);
      return me >= 0 ? (me > 0 && (ne.lastNeed = me - 1), me) : --we < he || me === -2 ? 0 : (me = B(ce[we])) >= 0 ? (me > 0 && (ne.lastNeed = me - 2), me) : --we < he || me === -2 ? 0 : (me = B(ce[we])) >= 0 ? (me > 0 && (me === 2 ? me = 0 : ne.lastNeed = me - 3), me) : 0;
    }(this, re, ie);
    if (!this.lastNeed)
      return re.toString("utf8", ie);
    this.lastTotal = ue;
    var q = re.length - (ue - this.lastNeed);
    return re.copy(this.lastChar, 0, q), re.toString("utf8", ie, q);
  }, W.prototype.fillLast = function(re) {
    if (this.lastNeed <= re.length)
      return re.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
    re.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, re.length), this.lastNeed -= re.length;
  };
}, function(z, D, O) {
  z.exports = W;
  var F = O(1), U = O(5);
  function W(X) {
    if (!(this instanceof W))
      return new W(X);
    F.call(this, X), this._transformState = { afterTransform: (function(Y, Q) {
      var J = this._transformState;
      J.transforming = !1;
      var ee = J.writecb;
      if (!ee)
        return this.emit("error", new Error("write callback called multiple times"));
      J.writechunk = null, J.writecb = null, Q != null && this.push(Q), ee(Y);
      var ae = this._readableState;
      ae.reading = !1, (ae.needReadable || ae.length < ae.highWaterMark) && this._read(ae.highWaterMark);
    }).bind(this), needTransform: !1, transforming: !1, writecb: null, writechunk: null, writeencoding: null }, this._readableState.needReadable = !0, this._readableState.sync = !1, X && (typeof X.transform == "function" && (this._transform = X.transform), typeof X.flush == "function" && (this._flush = X.flush)), this.on("prefinish", B);
  }
  function B() {
    var X = this;
    typeof this._flush == "function" ? this._flush(function(Y, Q) {
      K(X, Y, Q);
    }) : K(this, null, null);
  }
  function K(X, Y, Q) {
    if (Y)
      return X.emit("error", Y);
    if (Q != null && X.push(Q), X._writableState.length)
      throw new Error("Calling transform done when ws.length != 0");
    if (X._transformState.transforming)
      throw new Error("Calling transform done when still transforming");
    return X.push(null);
  }
  U.inherits = O(2), U.inherits(W, F), W.prototype.push = function(X, Y) {
    return this._transformState.needTransform = !1, F.prototype.push.call(this, X, Y);
  }, W.prototype._transform = function(X, Y, Q) {
    throw new Error("_transform() is not implemented");
  }, W.prototype._write = function(X, Y, Q) {
    var J = this._transformState;
    if (J.writecb = Q, J.writechunk = X, J.writeencoding = Y, !J.transforming) {
      var ee = this._readableState;
      (J.needTransform || ee.needReadable || ee.length < ee.highWaterMark) && this._read(ee.highWaterMark);
    }
  }, W.prototype._read = function(X) {
    var Y = this._transformState;
    Y.writechunk !== null && Y.writecb && !Y.transforming ? (Y.transforming = !0, this._transform(Y.writechunk, Y.writeencoding, Y.afterTransform)) : Y.needTransform = !0;
  }, W.prototype._destroy = function(X, Y) {
    var Q = this;
    F.prototype._destroy.call(this, X, function(J) {
      Y(J), Q.emit("close");
    });
  };
}, function(z, D, O) {
  (function(F) {
    Object.defineProperty(D, "__esModule", { value: !0 }), D.bufFromString = function(U) {
      var W = F.byteLength(U), B = F.allocUnsafe ? F.allocUnsafe(W) : new F(W);
      return B.write(U), B;
    }, D.emptyBuffer = function() {
      return F.allocUnsafe ? F.allocUnsafe(0) : new F(0);
    }, D.filterArray = function(U, W) {
      for (var B = [], K = 0; K < U.length; K++)
        W.indexOf(K) > -1 && B.push(U[K]);
      return B;
    }, D.trimLeft = String.prototype.trimLeft ? function(U) {
      return U.trimLeft();
    } : function(U) {
      return U.replace(/^\s+/, "");
    }, D.trimRight = String.prototype.trimRight ? function(U) {
      return U.trimRight();
    } : function(U) {
      return U.replace(/\s+$/, "");
    };
  }).call(this, O(3).Buffer);
}, function(z, D, O) {
  var F = this && this.__extends || function() {
    var W = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(B, K) {
      B.__proto__ = K;
    } || function(B, K) {
      for (var X in K)
        K.hasOwnProperty(X) && (B[X] = K[X]);
    };
    return function(B, K) {
      function X() {
        this.constructor = B;
      }
      W(B, K), B.prototype = K === null ? Object.create(K) : (X.prototype = K.prototype, new X());
    };
  }();
  Object.defineProperty(D, "__esModule", { value: !0 });
  var U = function(W) {
    function B(K, X, Y) {
      var Q = W.call(this, "Error: " + K + ". JSON Line number: " + X + (Y ? " near: " + Y : "")) || this;
      return Q.err = K, Q.line = X, Q.extra = Y, Q.name = "CSV Parse Error", Q;
    }
    return F(B, W), B.column_mismatched = function(K, X) {
      return new B("column_mismatched", K, X);
    }, B.unclosed_quote = function(K, X) {
      return new B("unclosed_quote", K, X);
    }, B.fromJSON = function(K) {
      return new B(K.err, K.line, K.extra);
    }, B.prototype.toJSON = function() {
      return { err: this.err, line: this.line, extra: this.extra };
    }, B;
  }(Error);
  D.default = U;
}, function(z, D, O) {
  var F = O(18), U = O(68), W = O(69), B = F ? F.toStringTag : void 0;
  z.exports = function(K) {
    return K == null ? K === void 0 ? "[object Undefined]" : "[object Null]" : B && B in Object(K) ? U(K) : W(K);
  };
}, function(z, D) {
  z.exports = function(O, F) {
    return O === F || O != O && F != F;
  };
}, function(z, D, O) {
  z.exports = O(33);
}, function(z, D, O) {
  var F = O(34), U = function(W, B) {
    return new F.Converter(W, B);
  };
  U.csv = U, U.Converter = F.Converter, z.exports = U;
}, function(z, D, O) {
  (function(F) {
    var U = this && this.__extends || function() {
      var ae = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(re, ie) {
        re.__proto__ = ie;
      } || function(re, ie) {
        for (var ue in ie)
          ie.hasOwnProperty(ue) && (re[ue] = ie[ue]);
      };
      return function(re, ie) {
        function ue() {
          this.constructor = re;
        }
        ae(re, ie), re.prototype = ie === null ? Object.create(ie) : (ue.prototype = ie.prototype, new ue());
      };
    }(), W = this && this.__importDefault || function(ae) {
      return ae && ae.__esModule ? ae : { default: ae };
    };
    Object.defineProperty(D, "__esModule", { value: !0 });
    var B = O(36), K = O(50), X = O(51), Y = W(O(15)), Q = O(52), J = O(105), ee = function(ae) {
      function re(ie, ue) {
        ue === void 0 && (ue = {});
        var q = ae.call(this, ue) || this;
        return q.options = ue, q.params = K.mergeParams(ie), q.runtime = X.initParseRuntime(q), q.result = new J.Result(q), q.processor = new Q.ProcessorLocal(q), q.once("error", function(ne) {
          F(function() {
            q.result.processError(ne), q.emit("done", ne);
          });
        }), q.once("done", function() {
          q.processor.destroy();
        }), q;
      }
      return U(re, ae), re.prototype.preRawData = function(ie) {
        return this.runtime.preRawDataHook = ie, this;
      }, re.prototype.preFileLine = function(ie) {
        return this.runtime.preFileLineHook = ie, this;
      }, re.prototype.subscribe = function(ie, ue, q) {
        return this.parseRuntime.subscribe = { onNext: ie, onError: ue, onCompleted: q }, this;
      }, re.prototype.fromFile = function(ie, ue) {
        var q = this, ne = O(!function() {
          var ce = new Error("Cannot find module 'fs'");
          throw ce.code = "MODULE_NOT_FOUND", ce;
        }());
        return ne.exists(ie, function(ce) {
          ce ? ne.createReadStream(ie, ue).pipe(q) : q.emit("error", new Error("File does not exist. Check to make sure the file path to your csv is correct."));
        }), this;
      }, re.prototype.fromStream = function(ie) {
        return ie.pipe(this), this;
      }, re.prototype.fromString = function(ie) {
        ie.toString();
        var ue = new B.Readable(), q = 0;
        return ue._read = function(ne) {
          if (q >= ie.length)
            this.push(null);
          else {
            var ce = ie.substr(q, ne);
            this.push(ce), q += ne;
          }
        }, this.fromStream(ue);
      }, re.prototype.then = function(ie, ue) {
        var q = this;
        return new Y.default(function(ne, ce) {
          q.parseRuntime.then = { onfulfilled: function(he) {
            ne(ie ? ie(he) : he);
          }, onrejected: function(he) {
            ue ? ne(ue(he)) : ce(he);
          } };
        });
      }, Object.defineProperty(re.prototype, "parseParam", { get: function() {
        return this.params;
      }, enumerable: !0, configurable: !0 }), Object.defineProperty(re.prototype, "parseRuntime", { get: function() {
        return this.runtime;
      }, enumerable: !0, configurable: !0 }), re.prototype._transform = function(ie, ue, q) {
        var ne = this;
        this.processor.process(ie).then(function(ce) {
          if (ce.length > 0)
            return ne.runtime.started = !0, ne.result.processResult(ce);
        }).then(function() {
          ne.emit("drained"), q();
        }, function(ce) {
          ne.runtime.hasError = !0, ne.runtime.error = ce, ne.emit("error", ce), q();
        });
      }, re.prototype._flush = function(ie) {
        var ue = this;
        this.processor.flush().then(function(q) {
          if (q.length > 0)
            return ue.result.processResult(q);
        }).then(function() {
          ue.processEnd(ie);
        }, function(q) {
          ue.emit("error", q), ie();
        });
      }, re.prototype.processEnd = function(ie) {
        this.result.endProcess(), this.emit("done"), ie();
      }, Object.defineProperty(re.prototype, "parsedLineNumber", { get: function() {
        return this.runtime.parsedLineNumber;
      }, enumerable: !0, configurable: !0 }), re;
    }(B.Transform);
    D.Converter = ee;
  }).call(this, O(11).setImmediate);
}, function(z, D, O) {
  (function(F, U) {
    (function(W, B) {
      if (!W.setImmediate) {
        var K, X = 1, Y = {}, Q = !1, J = W.document, ee = Object.getPrototypeOf && Object.getPrototypeOf(W);
        ee = ee && ee.setTimeout ? ee : W, {}.toString.call(W.process) === "[object process]" ? K = function(ie) {
          U.nextTick(function() {
            re(ie);
          });
        } : function() {
          if (W.postMessage && !W.importScripts) {
            var ie = !0, ue = W.onmessage;
            return W.onmessage = function() {
              ie = !1;
            }, W.postMessage("", "*"), W.onmessage = ue, ie;
          }
        }() ? function() {
          var ie = "setImmediate$" + Math.random() + "$", ue = function(q) {
            q.source === W && typeof q.data == "string" && q.data.indexOf(ie) === 0 && re(+q.data.slice(ie.length));
          };
          W.addEventListener ? W.addEventListener("message", ue, !1) : W.attachEvent("onmessage", ue), K = function(q) {
            W.postMessage(ie + q, "*");
          };
        }() : W.MessageChannel ? function() {
          var ie = new MessageChannel();
          ie.port1.onmessage = function(ue) {
            re(ue.data);
          }, K = function(ue) {
            ie.port2.postMessage(ue);
          };
        }() : J && "onreadystatechange" in J.createElement("script") ? function() {
          var ie = J.documentElement;
          K = function(ue) {
            var q = J.createElement("script");
            q.onreadystatechange = function() {
              re(ue), q.onreadystatechange = null, ie.removeChild(q), q = null;
            }, ie.appendChild(q);
          };
        }() : K = function(ie) {
          setTimeout(re, 0, ie);
        }, ee.setImmediate = function(ie) {
          typeof ie != "function" && (ie = new Function("" + ie));
          for (var ue = new Array(arguments.length - 1), q = 0; q < ue.length; q++)
            ue[q] = arguments[q + 1];
          var ne = { callback: ie, args: ue };
          return Y[X] = ne, K(X), X++;
        }, ee.clearImmediate = ae;
      }
      function ae(ie) {
        delete Y[ie];
      }
      function re(ie) {
        if (Q)
          setTimeout(re, 0, ie);
        else {
          var ue = Y[ie];
          if (ue) {
            Q = !0;
            try {
              (function(q) {
                var ne = q.callback, ce = q.args;
                switch (ce.length) {
                  case 0:
                    ne();
                    break;
                  case 1:
                    ne(ce[0]);
                    break;
                  case 2:
                    ne(ce[0], ce[1]);
                    break;
                  case 3:
                    ne(ce[0], ce[1], ce[2]);
                    break;
                  default:
                    ne.apply(B, ce);
                }
              })(ue);
            } finally {
              ae(ie), Q = !1;
            }
          }
        }
      }
    })(typeof self > "u" ? F === void 0 ? this : F : self);
  }).call(this, O(0), O(4));
}, function(z, D, O) {
  z.exports = U;
  var F = O(12).EventEmitter;
  function U() {
    F.call(this);
  }
  O(2)(U, F), U.Readable = O(13), U.Writable = O(46), U.Duplex = O(47), U.Transform = O(48), U.PassThrough = O(49), U.Stream = U, U.prototype.pipe = function(W, B) {
    var K = this;
    function X(ie) {
      W.writable && W.write(ie) === !1 && K.pause && K.pause();
    }
    function Y() {
      K.readable && K.resume && K.resume();
    }
    K.on("data", X), W.on("drain", Y), W._isStdio || B && B.end === !1 || (K.on("end", J), K.on("close", ee));
    var Q = !1;
    function J() {
      Q || (Q = !0, W.end());
    }
    function ee() {
      Q || (Q = !0, typeof W.destroy == "function" && W.destroy());
    }
    function ae(ie) {
      if (re(), F.listenerCount(this, "error") === 0)
        throw ie;
    }
    function re() {
      K.removeListener("data", X), W.removeListener("drain", Y), K.removeListener("end", J), K.removeListener("close", ee), K.removeListener("error", ae), W.removeListener("error", ae), K.removeListener("end", re), K.removeListener("close", re), W.removeListener("close", re);
    }
    return K.on("error", ae), W.on("error", ae), K.on("end", re), K.on("close", re), W.on("close", re), W.emit("pipe", K), W;
  };
}, function(z, D) {
  var O = {}.toString;
  z.exports = Array.isArray || function(F) {
    return O.call(F) == "[object Array]";
  };
}, function(z, D, O) {
  D.byteLength = function(ee) {
    var ae = Y(ee), re = ae[0], ie = ae[1];
    return 3 * (re + ie) / 4 - ie;
  }, D.toByteArray = function(ee) {
    for (var ae, re = Y(ee), ie = re[0], ue = re[1], q = new W(3 * (ie + ue) / 4 - ue), ne = 0, ce = ue > 0 ? ie - 4 : ie, he = 0; he < ce; he += 4)
      ae = U[ee.charCodeAt(he)] << 18 | U[ee.charCodeAt(he + 1)] << 12 | U[ee.charCodeAt(he + 2)] << 6 | U[ee.charCodeAt(he + 3)], q[ne++] = ae >> 16 & 255, q[ne++] = ae >> 8 & 255, q[ne++] = 255 & ae;
    return ue === 2 && (ae = U[ee.charCodeAt(he)] << 2 | U[ee.charCodeAt(he + 1)] >> 4, q[ne++] = 255 & ae), ue === 1 && (ae = U[ee.charCodeAt(he)] << 10 | U[ee.charCodeAt(he + 1)] << 4 | U[ee.charCodeAt(he + 2)] >> 2, q[ne++] = ae >> 8 & 255, q[ne++] = 255 & ae), q;
  }, D.fromByteArray = function(ee) {
    for (var ae, re = ee.length, ie = re % 3, ue = [], q = 0, ne = re - ie; q < ne; q += 16383)
      ue.push(J(ee, q, q + 16383 > ne ? ne : q + 16383));
    return ie === 1 ? (ae = ee[re - 1], ue.push(F[ae >> 2] + F[ae << 4 & 63] + "==")) : ie === 2 && (ae = (ee[re - 2] << 8) + ee[re - 1], ue.push(F[ae >> 10] + F[ae >> 4 & 63] + F[ae << 2 & 63] + "=")), ue.join("");
  };
  for (var F = [], U = [], W = typeof Uint8Array < "u" ? Uint8Array : Array, B = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", K = 0, X = B.length; K < X; ++K)
    F[K] = B[K], U[B.charCodeAt(K)] = K;
  function Y(ee) {
    var ae = ee.length;
    if (ae % 4 > 0)
      throw new Error("Invalid string. Length must be a multiple of 4");
    var re = ee.indexOf("=");
    return re === -1 && (re = ae), [re, re === ae ? 0 : 4 - re % 4];
  }
  function Q(ee) {
    return F[ee >> 18 & 63] + F[ee >> 12 & 63] + F[ee >> 6 & 63] + F[63 & ee];
  }
  function J(ee, ae, re) {
    for (var ie, ue = [], q = ae; q < re; q += 3)
      ie = (ee[q] << 16 & 16711680) + (ee[q + 1] << 8 & 65280) + (255 & ee[q + 2]), ue.push(Q(ie));
    return ue.join("");
  }
  U[45] = 62, U[95] = 63;
}, function(z, D) {
  D.read = function(O, F, U, W, B) {
    var K, X, Y = 8 * B - W - 1, Q = (1 << Y) - 1, J = Q >> 1, ee = -7, ae = U ? B - 1 : 0, re = U ? -1 : 1, ie = O[F + ae];
    for (ae += re, K = ie & (1 << -ee) - 1, ie >>= -ee, ee += Y; ee > 0; K = 256 * K + O[F + ae], ae += re, ee -= 8)
      ;
    for (X = K & (1 << -ee) - 1, K >>= -ee, ee += W; ee > 0; X = 256 * X + O[F + ae], ae += re, ee -= 8)
      ;
    if (K === 0)
      K = 1 - J;
    else {
      if (K === Q)
        return X ? NaN : 1 / 0 * (ie ? -1 : 1);
      X += Math.pow(2, W), K -= J;
    }
    return (ie ? -1 : 1) * X * Math.pow(2, K - W);
  }, D.write = function(O, F, U, W, B, K) {
    var X, Y, Q, J = 8 * K - B - 1, ee = (1 << J) - 1, ae = ee >> 1, re = B === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, ie = W ? 0 : K - 1, ue = W ? 1 : -1, q = F < 0 || F === 0 && 1 / F < 0 ? 1 : 0;
    for (F = Math.abs(F), isNaN(F) || F === 1 / 0 ? (Y = isNaN(F) ? 1 : 0, X = ee) : (X = Math.floor(Math.log(F) / Math.LN2), F * (Q = Math.pow(2, -X)) < 1 && (X--, Q *= 2), (F += X + ae >= 1 ? re / Q : re * Math.pow(2, 1 - ae)) * Q >= 2 && (X++, Q /= 2), X + ae >= ee ? (Y = 0, X = ee) : X + ae >= 1 ? (Y = (F * Q - 1) * Math.pow(2, B), X += ae) : (Y = F * Math.pow(2, ae - 1) * Math.pow(2, B), X = 0)); B >= 8; O[U + ie] = 255 & Y, ie += ue, Y /= 256, B -= 8)
      ;
    for (X = X << B | Y, J += B; J > 0; O[U + ie] = 255 & X, ie += ue, X /= 256, J -= 8)
      ;
    O[U + ie - ue] |= 128 * q;
  };
}, function(z, D) {
  var O = {}.toString;
  z.exports = Array.isArray || function(F) {
    return O.call(F) == "[object Array]";
  };
}, function(z, D) {
}, function(z, D, O) {
  var F = O(7).Buffer, U = O(43);
  function W(B, K, X) {
    B.copy(K, X);
  }
  z.exports = function() {
    function B() {
      (function(K, X) {
        if (!(K instanceof X))
          throw new TypeError("Cannot call a class as a function");
      })(this, B), this.head = null, this.tail = null, this.length = 0;
    }
    return B.prototype.push = function(K) {
      var X = { data: K, next: null };
      this.length > 0 ? this.tail.next = X : this.head = X, this.tail = X, ++this.length;
    }, B.prototype.unshift = function(K) {
      var X = { data: K, next: this.head };
      this.length === 0 && (this.tail = X), this.head = X, ++this.length;
    }, B.prototype.shift = function() {
      if (this.length !== 0) {
        var K = this.head.data;
        return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, K;
      }
    }, B.prototype.clear = function() {
      this.head = this.tail = null, this.length = 0;
    }, B.prototype.join = function(K) {
      if (this.length === 0)
        return "";
      for (var X = this.head, Y = "" + X.data; X = X.next; )
        Y += K + X.data;
      return Y;
    }, B.prototype.concat = function(K) {
      if (this.length === 0)
        return F.alloc(0);
      if (this.length === 1)
        return this.head.data;
      for (var X = F.allocUnsafe(K >>> 0), Y = this.head, Q = 0; Y; )
        W(Y.data, X, Q), Q += Y.data.length, Y = Y.next;
      return X;
    }, B;
  }(), U && U.inspect && U.inspect.custom && (z.exports.prototype[U.inspect.custom] = function() {
    var B = U.inspect({ length: this.length });
    return this.constructor.name + " " + B;
  });
}, function(z, D) {
}, function(z, D, O) {
  (function(F) {
    function U(W) {
      try {
        if (!F.localStorage)
          return !1;
      } catch {
        return !1;
      }
      var B = F.localStorage[W];
      return B != null && String(B).toLowerCase() === "true";
    }
    z.exports = function(W, B) {
      if (U("noDeprecation"))
        return W;
      var K = !1;
      return function() {
        if (!K) {
          if (U("throwDeprecation"))
            throw new Error(B);
          U("traceDeprecation") ? console.trace(B) : console.warn(B), K = !0;
        }
        return W.apply(this, arguments);
      };
    };
  }).call(this, O(0));
}, function(z, D, O) {
  z.exports = W;
  var F = O(27), U = O(5);
  function W(B) {
    if (!(this instanceof W))
      return new W(B);
    F.call(this, B);
  }
  U.inherits = O(2), U.inherits(W, F), W.prototype._transform = function(B, K, X) {
    X(null, B);
  };
}, function(z, D, O) {
  z.exports = O(14);
}, function(z, D, O) {
  z.exports = O(1);
}, function(z, D, O) {
  z.exports = O(13).Transform;
}, function(z, D, O) {
  z.exports = O(13).PassThrough;
}, function(z, D, O) {
  Object.defineProperty(D, "__esModule", { value: !0 }), D.mergeParams = function(F) {
    var U = { delimiter: ",", ignoreColumns: void 0, includeColumns: void 0, quote: '"', trim: !0, checkType: !1, ignoreEmpty: !1, noheader: !1, headers: void 0, flatKeys: !1, maxRowLength: 0, checkColumn: !1, escape: '"', colParser: {}, eol: void 0, alwaysSplitAtEOL: !1, output: "json", nullObject: !1, downstreamFormat: "line", needEmitAll: !0 };
    for (var W in F || (F = {}), F)
      F.hasOwnProperty(W) && (Array.isArray(F[W]) ? U[W] = [].concat(F[W]) : U[W] = F[W]);
    return U;
  };
}, function(z, D, O) {
  Object.defineProperty(D, "__esModule", { value: !0 }), D.initParseRuntime = function(F) {
    var U = F.parseParam, W = { needProcessIgnoreColumn: !1, needProcessIncludeColumn: !1, selectedColumns: void 0, ended: !1, hasError: !1, error: void 0, delimiter: F.parseParam.delimiter, eol: F.parseParam.eol, columnConv: [], headerType: [], headerTitle: [], headerFlag: [], headers: void 0, started: !1, parsedLineNumber: 0, columnValueSetter: [] };
    return U.ignoreColumns && (W.needProcessIgnoreColumn = !0), U.includeColumns && (W.needProcessIncludeColumn = !0), W;
  };
}, function(z, D, O) {
  (function(F) {
    var U = this && this.__extends || function() {
      var ue = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(q, ne) {
        q.__proto__ = ne;
      } || function(q, ne) {
        for (var ce in ne)
          ne.hasOwnProperty(ce) && (q[ce] = ne[ce]);
      };
      return function(q, ne) {
        function ce() {
          this.constructor = q;
        }
        ue(q, ne), q.prototype = ne === null ? Object.create(ne) : (ce.prototype = ne.prototype, new ce());
      };
    }(), W = this && this.__importDefault || function(ue) {
      return ue && ue.__esModule ? ue : { default: ue };
    };
    Object.defineProperty(D, "__esModule", { value: !0 });
    var B = O(53), K = W(O(15)), X = O(54), Y = W(O(16)), Q = O(57), J = O(28), ee = O(58), ae = W(O(59)), re = W(O(29)), ie = function(ue) {
      function q() {
        var ne = ue !== null && ue.apply(this, arguments) || this;
        return ne.rowSplit = new ee.RowSplit(ne.converter), ne.eolEmitted = !1, ne._needEmitEol = void 0, ne.headEmitted = !1, ne._needEmitHead = void 0, ne;
      }
      return U(q, ue), q.prototype.flush = function() {
        var ne = this;
        if (this.runtime.csvLineBuffer && this.runtime.csvLineBuffer.length > 0) {
          var ce = this.runtime.csvLineBuffer;
          return this.runtime.csvLineBuffer = void 0, this.process(ce, !0).then(function(he) {
            return ne.runtime.csvLineBuffer && ne.runtime.csvLineBuffer.length > 0 ? K.default.reject(re.default.unclosed_quote(ne.runtime.parsedLineNumber, ne.runtime.csvLineBuffer.toString())) : K.default.resolve(he);
          });
        }
        return K.default.resolve([]);
      }, q.prototype.destroy = function() {
        return K.default.resolve();
      }, Object.defineProperty(q.prototype, "needEmitEol", { get: function() {
        return this._needEmitEol === void 0 && (this._needEmitEol = this.converter.listeners("eol").length > 0), this._needEmitEol;
      }, enumerable: !0, configurable: !0 }), Object.defineProperty(q.prototype, "needEmitHead", { get: function() {
        return this._needEmitHead === void 0 && (this._needEmitHead = this.converter.listeners("header").length > 0), this._needEmitHead;
      }, enumerable: !0, configurable: !0 }), q.prototype.process = function(ne, ce) {
        var he, we = this;
        return ce === void 0 && (ce = !1), he = ce ? ne.toString() : X.prepareData(ne, this.converter.parseRuntime), K.default.resolve().then(function() {
          return we.runtime.preRawDataHook ? we.runtime.preRawDataHook(he) : he;
        }).then(function(me) {
          return me && me.length > 0 ? we.processCSV(me, ce) : K.default.resolve([]);
        });
      }, q.prototype.processCSV = function(ne, ce) {
        var he = this, we = this.params, me = this.runtime;
        me.eol || Y.default(ne, me), this.needEmitEol && !this.eolEmitted && me.eol && (this.converter.emit("eol", me.eol), this.eolEmitted = !0), we.ignoreEmpty && !me.started && (ne = J.trimLeft(ne));
        var de = Q.stringToLines(ne, me);
        return ce ? (de.lines.push(de.partial), de.partial = "") : this.prependLeftBuf(J.bufFromString(de.partial)), de.lines.length > 0 ? (me.preFileLineHook ? this.runPreLineHook(de.lines) : K.default.resolve(de.lines)).then(function(be) {
          return me.started || he.runtime.headers ? he.processCSVBody(be) : he.processDataWithHead(be);
        }) : K.default.resolve([]);
      }, q.prototype.processDataWithHead = function(ne) {
        if (this.params.noheader)
          this.params.headers ? this.runtime.headers = this.params.headers : this.runtime.headers = [];
        else {
          for (var ce = "", he = []; ne.length; ) {
            var we = ce + ne.shift(), me = this.rowSplit.parse(we);
            if (me.closed) {
              he = me.cells, ce = "";
              break;
            }
            ce = we + Y.default(we, this.runtime);
          }
          if (this.prependLeftBuf(J.bufFromString(ce)), he.length === 0)
            return [];
          this.params.headers ? this.runtime.headers = this.params.headers : this.runtime.headers = he;
        }
        return (this.runtime.needProcessIgnoreColumn || this.runtime.needProcessIncludeColumn) && this.filterHeader(), this.needEmitHead && !this.headEmitted && (this.converter.emit("header", this.runtime.headers), this.headEmitted = !0), this.processCSVBody(ne);
      }, q.prototype.filterHeader = function() {
        if (this.runtime.selectedColumns = [], this.runtime.headers) {
          for (var ne = this.runtime.headers, ce = 0; ce < ne.length; ce++)
            if (this.params.ignoreColumns)
              if (this.params.ignoreColumns.test(ne[ce])) {
                if (!this.params.includeColumns || !this.params.includeColumns.test(ne[ce]))
                  continue;
                this.runtime.selectedColumns.push(ce);
              } else
                this.runtime.selectedColumns.push(ce);
            else
              this.params.includeColumns ? this.params.includeColumns.test(ne[ce]) && this.runtime.selectedColumns.push(ce) : this.runtime.selectedColumns.push(ce);
          this.runtime.headers = J.filterArray(this.runtime.headers, this.runtime.selectedColumns);
        }
      }, q.prototype.processCSVBody = function(ne) {
        if (this.params.output === "line")
          return ne;
        var ce = this.rowSplit.parseMultiLines(ne);
        return this.prependLeftBuf(J.bufFromString(ce.partial)), this.params.output === "csv" ? ce.rowsCells : ae.default(ce.rowsCells, this.converter);
      }, q.prototype.prependLeftBuf = function(ne) {
        ne && (this.runtime.csvLineBuffer ? this.runtime.csvLineBuffer = F.concat([ne, this.runtime.csvLineBuffer]) : this.runtime.csvLineBuffer = ne);
      }, q.prototype.runPreLineHook = function(ne) {
        var ce = this;
        return new K.default(function(he, we) {
          (function me(de, be, _e, Me) {
            if (_e >= de.length)
              Me();
            else if (be.preFileLineHook) {
              var Ne = de[_e], Ee = be.preFileLineHook(Ne, be.parsedLineNumber + _e);
              if (_e++, Ee && Ee.then)
                Ee.then(function($e) {
                  de[_e - 1] = $e, me(de, be, _e, Me);
                });
              else {
                for (de[_e - 1] = Ee; _e < de.length; )
                  de[_e] = be.preFileLineHook(de[_e], be.parsedLineNumber + _e), _e++;
                Me();
              }
            } else
              Me();
          })(ne, ce.runtime, 0, function(me) {
            me ? we(me) : he(ne);
          });
        });
      }, q;
    }(B.Processor);
    D.ProcessorLocal = ie;
  }).call(this, O(3).Buffer);
}, function(z, D, O) {
  Object.defineProperty(D, "__esModule", { value: !0 });
  var F = function(U) {
    this.converter = U, this.params = U.parseParam, this.runtime = U.parseRuntime;
  };
  D.Processor = F;
}, function(z, D, O) {
  (function(F) {
    var U = this && this.__importDefault || function(B) {
      return B && B.__esModule ? B : { default: B };
    };
    Object.defineProperty(D, "__esModule", { value: !0 });
    var W = U(O(55));
    D.prepareData = function(B, K) {
      var X = function(Q, J) {
        return J.csvLineBuffer && J.csvLineBuffer.length > 0 ? F.concat([J.csvLineBuffer, Q]) : Q;
      }(B, K);
      K.csvLineBuffer = void 0;
      var Y = function(Q, J) {
        var ee = Q.length - 1;
        if (128 & Q[ee]) {
          for (; (192 & Q[ee]) == 128; )
            ee--;
          ee--;
        }
        return ee != Q.length - 1 ? (J.csvLineBuffer = Q.slice(ee + 1), Q.slice(0, ee + 1)) : Q;
      }(X, K).toString("utf8");
      return K.started === !1 ? W.default(Y) : Y;
    };
  }).call(this, O(3).Buffer);
}, function(z, D, O) {
  (function(F) {
    var U = O(56);
    z.exports = function(W) {
      return typeof W == "string" && W.charCodeAt(0) === 65279 ? W.slice(1) : F.isBuffer(W) && U(W) && W[0] === 239 && W[1] === 187 && W[2] === 191 ? W.slice(3) : W;
    };
  }).call(this, O(3).Buffer);
}, function(z, D) {
  z.exports = function(O) {
    for (var F = 0; F < O.length; )
      if (O[F] == 9 || O[F] == 10 || O[F] == 13 || 32 <= O[F] && O[F] <= 126)
        F += 1;
      else if (194 <= O[F] && O[F] <= 223 && 128 <= O[F + 1] && O[F + 1] <= 191)
        F += 2;
      else if (O[F] == 224 && 160 <= O[F + 1] && O[F + 1] <= 191 && 128 <= O[F + 2] && O[F + 2] <= 191 || (225 <= O[F] && O[F] <= 236 || O[F] == 238 || O[F] == 239) && 128 <= O[F + 1] && O[F + 1] <= 191 && 128 <= O[F + 2] && O[F + 2] <= 191 || O[F] == 237 && 128 <= O[F + 1] && O[F + 1] <= 159 && 128 <= O[F + 2] && O[F + 2] <= 191)
        F += 3;
      else {
        if (!(O[F] == 240 && 144 <= O[F + 1] && O[F + 1] <= 191 && 128 <= O[F + 2] && O[F + 2] <= 191 && 128 <= O[F + 3] && O[F + 3] <= 191 || 241 <= O[F] && O[F] <= 243 && 128 <= O[F + 1] && O[F + 1] <= 191 && 128 <= O[F + 2] && O[F + 2] <= 191 && 128 <= O[F + 3] && O[F + 3] <= 191 || O[F] == 244 && 128 <= O[F + 1] && O[F + 1] <= 143 && 128 <= O[F + 2] && O[F + 2] <= 191 && 128 <= O[F + 3] && O[F + 3] <= 191))
          return !1;
        F += 4;
      }
    return !0;
  };
}, function(z, D, O) {
  var F = this && this.__importDefault || function(W) {
    return W && W.__esModule ? W : { default: W };
  };
  Object.defineProperty(D, "__esModule", { value: !0 });
  var U = F(O(16));
  D.stringToLines = function(W, B) {
    var K = U.default(W, B), X = W.split(K);
    return { lines: X, partial: X.pop() || "" };
  };
}, function(z, D, O) {
  var F = this && this.__importDefault || function(X) {
    return X && X.__esModule ? X : { default: X };
  };
  Object.defineProperty(D, "__esModule", { value: !0 });
  var U = F(O(16)), W = O(28), B = [",", "|", "	", ";", ":"], K = function() {
    function X(Y) {
      this.conv = Y, this.cachedRegExp = {}, this.delimiterEmitted = !1, this._needEmitDelimiter = void 0, this.quote = Y.parseParam.quote, this.trim = Y.parseParam.trim, this.escape = Y.parseParam.escape;
    }
    return Object.defineProperty(X.prototype, "needEmitDelimiter", { get: function() {
      return this._needEmitDelimiter === void 0 && (this._needEmitDelimiter = this.conv.listeners("delimiter").length > 0), this._needEmitDelimiter;
    }, enumerable: !0, configurable: !0 }), X.prototype.parse = function(Y) {
      if (Y.length === 0 || this.conv.parseParam.ignoreEmpty && Y.trim().length === 0)
        return { cells: [], closed: !0 };
      var Q = this.quote, J = this.trim;
      this.escape, (this.conv.parseRuntime.delimiter instanceof Array || this.conv.parseRuntime.delimiter.toLowerCase() === "auto") && (this.conv.parseRuntime.delimiter = this.getDelimiter(Y)), this.needEmitDelimiter && !this.delimiterEmitted && (this.conv.emit("delimiter", this.conv.parseRuntime.delimiter), this.delimiterEmitted = !0);
      var ee = this.conv.parseRuntime.delimiter, ae = Y.split(ee);
      if (Q === "off") {
        if (J)
          for (var re = 0; re < ae.length; re++)
            ae[re] = ae[re].trim();
        return { cells: ae, closed: !0 };
      }
      return this.toCSVRow(ae, J, Q, ee);
    }, X.prototype.toCSVRow = function(Y, Q, J, ee) {
      for (var ae = [], re = !1, ie = "", ue = 0, q = Y.length; ue < q; ue++) {
        var ne = Y[ue];
        !re && Q && (ne = W.trimLeft(ne));
        var ce = ne.length;
        if (re)
          this.isQuoteClose(ne) ? (re = !1, ie += ee + (ne = ne.substr(0, ce - 1)), ie = this.escapeQuote(ie), Q && (ie = W.trimRight(ie)), ae.push(ie), ie = "") : ie += ee + ne;
        else {
          if (ce === 2 && ne === this.quote + this.quote) {
            ae.push("");
            continue;
          }
          if (this.isQuoteOpen(ne)) {
            if (ne = ne.substr(1), this.isQuoteClose(ne)) {
              ne = ne.substring(0, ne.lastIndexOf(J)), ne = this.escapeQuote(ne), ae.push(ne);
              continue;
            }
            if (ne.indexOf(J) !== -1) {
              for (var he = 0, we = "", me = 0, de = ne; me < de.length; me++) {
                var be = de[me];
                be === J && we !== this.escape ? (he++, we = "") : we = be;
              }
              if (he % 2 == 1) {
                Q && (ne = W.trimRight(ne)), ae.push(J + ne);
                continue;
              }
              re = !0, ie += ne;
              continue;
            }
            re = !0, ie += ne;
            continue;
          }
          Q && (ne = W.trimRight(ne)), ae.push(ne);
        }
      }
      return { cells: ae, closed: !re };
    }, X.prototype.getDelimiter = function(Y) {
      var Q;
      if (this.conv.parseParam.delimiter === "auto")
        Q = B;
      else {
        if (!(this.conv.parseParam.delimiter instanceof Array))
          return this.conv.parseParam.delimiter;
        Q = this.conv.parseParam.delimiter;
      }
      var J = 0, ee = ",";
      return Q.forEach(function(ae) {
        var re = Y.split(ae).length;
        re > J && (ee = ae, J = re);
      }), ee;
    }, X.prototype.isQuoteOpen = function(Y) {
      var Q = this.quote, J = this.escape;
      return Y[0] === Q && (Y[1] !== Q || Y[1] === J && (Y[2] === Q || Y.length === 2));
    }, X.prototype.isQuoteClose = function(Y) {
      var Q = this.quote, J = this.escape;
      this.conv.parseParam.trim && (Y = W.trimRight(Y));
      for (var ee = 0, ae = Y.length - 1; Y[ae] === Q || Y[ae] === J; )
        ae--, ee++;
      return ee % 2 != 0;
    }, X.prototype.escapeQuote = function(Y) {
      var Q = "es|" + this.quote + "|" + this.escape;
      this.cachedRegExp[Q] === void 0 && (this.cachedRegExp[Q] = new RegExp("\\" + this.escape + "\\" + this.quote, "g"));
      var J = this.cachedRegExp[Q];
      return Y.replace(J, this.quote);
    }, X.prototype.parseMultiLines = function(Y) {
      for (var Q = [], J = ""; Y.length; ) {
        var ee = J + Y.shift(), ae = this.parse(ee);
        ae.cells.length === 0 && this.conv.parseParam.ignoreEmpty || (ae.closed || this.conv.parseParam.alwaysSplitAtEOL ? (this.conv.parseRuntime.selectedColumns ? Q.push(W.filterArray(ae.cells, this.conv.parseRuntime.selectedColumns)) : Q.push(ae.cells), J = "") : J = ee + (U.default(ee, this.conv.parseRuntime) || `
`));
      }
      return { rowsCells: Q, partial: J };
    }, X;
  }();
  D.RowSplit = K;
}, function(z, D, O) {
  var F = this && this.__importDefault || function(q) {
    return q && q.__esModule ? q : { default: q };
  };
  Object.defineProperty(D, "__esModule", { value: !0 });
  var U = F(O(29)), W = F(O(60)), B = /^[-+]?[0-9]*\.?[0-9]+([eE][-+]?[0-9]+)?$/;
  function K(q, ne, ce) {
    if (ne.parseParam.checkColumn && ne.parseRuntime.headers && q.length !== ne.parseRuntime.headers.length)
      throw U.default.column_mismatched(ne.parseRuntime.parsedLineNumber + ce);
    return function(he, we, me) {
      for (var de = !1, be = {}, _e = 0, Me = he.length; _e < Me; _e++) {
        var Ne = he[_e];
        if (!me.parseParam.ignoreEmpty || Ne !== "") {
          de = !0;
          var Ee = we[_e];
          Ee && Ee !== "" || (Ee = we[_e] = "field" + (_e + 1));
          var $e = Y(Ee, _e, me);
          if ($e) {
            var De = $e(Ne, Ee, be, he, _e);
            De !== void 0 && Q(be, Ee, De, me, _e);
          } else
            me.parseParam.checkType && (Ne = ae(Ne, Ee, _e, me)(Ne)), Ne !== void 0 && Q(be, Ee, Ne, me, _e);
        }
      }
      return de ? be : null;
    }(q, ne.parseRuntime.headers || [], ne) || null;
  }
  D.default = function(q, ne) {
    for (var ce = [], he = 0, we = q.length; he < we; he++) {
      var me = K(q[he], ne, he);
      me && ce.push(me);
    }
    return ce;
  };
  var X = { string: ie, number: re, omit: function() {
  } };
  function Y(q, ne, ce) {
    if (ce.parseRuntime.columnConv[ne] !== void 0)
      return ce.parseRuntime.columnConv[ne];
    var he = ce.parseParam.colParser[q];
    if (he === void 0)
      return ce.parseRuntime.columnConv[ne] = null;
    if (typeof he == "object" && (he = he.cellParser || "string"), typeof he == "string") {
      he = he.trim().toLowerCase();
      var we = X[he];
      return ce.parseRuntime.columnConv[ne] = we || null;
    }
    return ce.parseRuntime.columnConv[ne] = typeof he == "function" ? he : null;
  }
  function Q(q, ne, ce, he, we) {
    if (!he.parseRuntime.columnValueSetter[we])
      if (he.parseParam.flatKeys)
        he.parseRuntime.columnValueSetter[we] = J;
      else if (ne.indexOf(".") > -1) {
        for (var me = ne.split("."), de = !0; me.length > 0; )
          if (me.shift().length === 0) {
            de = !1;
            break;
          }
        !de || he.parseParam.colParser[ne] && he.parseParam.colParser[ne].flat ? he.parseRuntime.columnValueSetter[we] = J : he.parseRuntime.columnValueSetter[we] = ee;
      } else
        he.parseRuntime.columnValueSetter[we] = J;
    he.parseParam.nullObject === !0 && ce === "null" && (ce = null), he.parseRuntime.columnValueSetter[we](q, ne, ce);
  }
  function J(q, ne, ce) {
    q[ne] = ce;
  }
  function ee(q, ne, ce) {
    W.default(q, ne, ce);
  }
  function ae(q, ne, ce, he) {
    return he.parseRuntime.headerType[ce] ? he.parseRuntime.headerType[ce] : ne.indexOf("number#!") > -1 ? he.parseRuntime.headerType[ce] = re : ne.indexOf("string#!") > -1 ? he.parseRuntime.headerType[ce] = ie : he.parseParam.checkType ? he.parseRuntime.headerType[ce] = ue : he.parseRuntime.headerType[ce] = ie;
  }
  function re(q) {
    var ne = parseFloat(q);
    return isNaN(ne) ? q : ne;
  }
  function ie(q) {
    return q.toString();
  }
  function ue(q) {
    var ne = q.trim();
    return ne === "" ? ie(q) : B.test(ne) ? re(q) : ne.length === 5 && ne.toLowerCase() === "false" || ne.length === 4 && ne.toLowerCase() === "true" ? function(ce) {
      var he = ce.trim();
      return he.length !== 5 || he.toLowerCase() !== "false";
    }(q) : ne[0] === "{" && ne[ne.length - 1] === "}" || ne[0] === "[" && ne[ne.length - 1] === "]" ? function(ce) {
      try {
        return JSON.parse(ce);
      } catch {
        return ce;
      }
    }(q) : ie(q);
  }
}, function(z, D, O) {
  var F = O(61);
  z.exports = function(U, W, B) {
    return U == null ? U : F(U, W, B);
  };
}, function(z, D, O) {
  var F = O(62), U = O(74), W = O(103), B = O(20), K = O(104);
  z.exports = function(X, Y, Q, J) {
    if (!B(X))
      return X;
    for (var ee = -1, ae = (Y = U(Y, X)).length, re = ae - 1, ie = X; ie != null && ++ee < ae; ) {
      var ue = K(Y[ee]), q = Q;
      if (ee != re) {
        var ne = ie[ue];
        (q = J ? J(ne, ue, ie) : void 0) === void 0 && (q = B(ne) ? ne : W(Y[ee + 1]) ? [] : {});
      }
      F(ie, ue, q), ie = ie[ue];
    }
    return X;
  };
}, function(z, D, O) {
  var F = O(63), U = O(31), W = Object.prototype.hasOwnProperty;
  z.exports = function(B, K, X) {
    var Y = B[K];
    W.call(B, K) && U(Y, X) && (X !== void 0 || K in B) || F(B, K, X);
  };
}, function(z, D, O) {
  var F = O(64);
  z.exports = function(U, W, B) {
    W == "__proto__" && F ? F(U, W, { configurable: !0, enumerable: !0, value: B, writable: !0 }) : U[W] = B;
  };
}, function(z, D, O) {
  var F = O(17), U = function() {
    try {
      var W = F(Object, "defineProperty");
      return W({}, "", {}), W;
    } catch {
    }
  }();
  z.exports = U;
}, function(z, D, O) {
  var F = O(66), U = O(70), W = O(20), B = O(72), K = /^\[object .+?Constructor\]$/, X = Function.prototype, Y = Object.prototype, Q = X.toString, J = Y.hasOwnProperty, ee = RegExp("^" + Q.call(J).replace(/[\\^$.*+?()[\]{}|]/g, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
  z.exports = function(ae) {
    return !(!W(ae) || U(ae)) && (F(ae) ? ee : K).test(B(ae));
  };
}, function(z, D, O) {
  var F = O(30), U = O(20);
  z.exports = function(W) {
    if (!U(W))
      return !1;
    var B = F(W);
    return B == "[object Function]" || B == "[object GeneratorFunction]" || B == "[object AsyncFunction]" || B == "[object Proxy]";
  };
}, function(z, D, O) {
  (function(F) {
    var U = typeof F == "object" && F && F.Object === Object && F;
    z.exports = U;
  }).call(this, O(0));
}, function(z, D, O) {
  var F = O(18), U = Object.prototype, W = U.hasOwnProperty, B = U.toString, K = F ? F.toStringTag : void 0;
  z.exports = function(X) {
    var Y = W.call(X, K), Q = X[K];
    try {
      X[K] = void 0;
      var J = !0;
    } catch {
    }
    var ee = B.call(X);
    return J && (Y ? X[K] = Q : delete X[K]), ee;
  };
}, function(z, D) {
  var O = Object.prototype.toString;
  z.exports = function(F) {
    return O.call(F);
  };
}, function(z, D, O) {
  var F = O(71), U = function() {
    var W = /[^.]+$/.exec(F && F.keys && F.keys.IE_PROTO || "");
    return W ? "Symbol(src)_1." + W : "";
  }();
  z.exports = function(W) {
    return !!U && U in W;
  };
}, function(z, D, O) {
  var F = O(19)["__core-js_shared__"];
  z.exports = F;
}, function(z, D) {
  var O = Function.prototype.toString;
  z.exports = function(F) {
    if (F != null) {
      try {
        return O.call(F);
      } catch {
      }
      try {
        return F + "";
      } catch {
      }
    }
    return "";
  };
}, function(z, D) {
  z.exports = function(O, F) {
    return O == null ? void 0 : O[F];
  };
}, function(z, D, O) {
  var F = O(21), U = O(75), W = O(77), B = O(100);
  z.exports = function(K, X) {
    return F(K) ? K : U(K, X) ? [K] : W(B(K));
  };
}, function(z, D, O) {
  var F = O(21), U = O(22), W = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, B = /^\w*$/;
  z.exports = function(K, X) {
    if (F(K))
      return !1;
    var Y = typeof K;
    return !(Y != "number" && Y != "symbol" && Y != "boolean" && K != null && !U(K)) || B.test(K) || !W.test(K) || X != null && K in Object(X);
  };
}, function(z, D) {
  z.exports = function(O) {
    return O != null && typeof O == "object";
  };
}, function(z, D, O) {
  var F = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, U = /\\(\\)?/g, W = O(78)(function(B) {
    var K = [];
    return B.charCodeAt(0) === 46 && K.push(""), B.replace(F, function(X, Y, Q, J) {
      K.push(Q ? J.replace(U, "$1") : Y || X);
    }), K;
  });
  z.exports = W;
}, function(z, D, O) {
  var F = O(79);
  z.exports = function(U) {
    var W = F(U, function(K) {
      return B.size === 500 && B.clear(), K;
    }), B = W.cache;
    return W;
  };
}, function(z, D, O) {
  var F = O(80), U = "Expected a function";
  function W(B, K) {
    if (typeof B != "function" || K != null && typeof K != "function")
      throw new TypeError(U);
    var X = function() {
      var Y = arguments, Q = K ? K.apply(this, Y) : Y[0], J = X.cache;
      if (J.has(Q))
        return J.get(Q);
      var ee = B.apply(this, Y);
      return X.cache = J.set(Q, ee) || J, ee;
    };
    return X.cache = new (W.Cache || F)(), X;
  }
  W.Cache = F, z.exports = W;
}, function(z, D, O) {
  var F = O(81), U = O(95), W = O(97), B = O(98), K = O(99);
  function X(Y) {
    var Q = -1, J = Y == null ? 0 : Y.length;
    for (this.clear(); ++Q < J; ) {
      var ee = Y[Q];
      this.set(ee[0], ee[1]);
    }
  }
  X.prototype.clear = F, X.prototype.delete = U, X.prototype.get = W, X.prototype.has = B, X.prototype.set = K, z.exports = X;
}, function(z, D, O) {
  var F = O(82), U = O(88), W = O(94);
  z.exports = function() {
    this.size = 0, this.__data__ = { hash: new F(), map: new (W || U)(), string: new F() };
  };
}, function(z, D, O) {
  var F = O(83), U = O(84), W = O(85), B = O(86), K = O(87);
  function X(Y) {
    var Q = -1, J = Y == null ? 0 : Y.length;
    for (this.clear(); ++Q < J; ) {
      var ee = Y[Q];
      this.set(ee[0], ee[1]);
    }
  }
  X.prototype.clear = F, X.prototype.delete = U, X.prototype.get = W, X.prototype.has = B, X.prototype.set = K, z.exports = X;
}, function(z, D, O) {
  var F = O(8);
  z.exports = function() {
    this.__data__ = F ? F(null) : {}, this.size = 0;
  };
}, function(z, D) {
  z.exports = function(O) {
    var F = this.has(O) && delete this.__data__[O];
    return this.size -= F ? 1 : 0, F;
  };
}, function(z, D, O) {
  var F = O(8), U = Object.prototype.hasOwnProperty;
  z.exports = function(W) {
    var B = this.__data__;
    if (F) {
      var K = B[W];
      return K === "__lodash_hash_undefined__" ? void 0 : K;
    }
    return U.call(B, W) ? B[W] : void 0;
  };
}, function(z, D, O) {
  var F = O(8), U = Object.prototype.hasOwnProperty;
  z.exports = function(W) {
    var B = this.__data__;
    return F ? B[W] !== void 0 : U.call(B, W);
  };
}, function(z, D, O) {
  var F = O(8);
  z.exports = function(U, W) {
    var B = this.__data__;
    return this.size += this.has(U) ? 0 : 1, B[U] = F && W === void 0 ? "__lodash_hash_undefined__" : W, this;
  };
}, function(z, D, O) {
  var F = O(89), U = O(90), W = O(91), B = O(92), K = O(93);
  function X(Y) {
    var Q = -1, J = Y == null ? 0 : Y.length;
    for (this.clear(); ++Q < J; ) {
      var ee = Y[Q];
      this.set(ee[0], ee[1]);
    }
  }
  X.prototype.clear = F, X.prototype.delete = U, X.prototype.get = W, X.prototype.has = B, X.prototype.set = K, z.exports = X;
}, function(z, D) {
  z.exports = function() {
    this.__data__ = [], this.size = 0;
  };
}, function(z, D, O) {
  var F = O(9), U = Array.prototype.splice;
  z.exports = function(W) {
    var B = this.__data__, K = F(B, W);
    return !(K < 0 || (K == B.length - 1 ? B.pop() : U.call(B, K, 1), --this.size, 0));
  };
}, function(z, D, O) {
  var F = O(9);
  z.exports = function(U) {
    var W = this.__data__, B = F(W, U);
    return B < 0 ? void 0 : W[B][1];
  };
}, function(z, D, O) {
  var F = O(9);
  z.exports = function(U) {
    return F(this.__data__, U) > -1;
  };
}, function(z, D, O) {
  var F = O(9);
  z.exports = function(U, W) {
    var B = this.__data__, K = F(B, U);
    return K < 0 ? (++this.size, B.push([U, W])) : B[K][1] = W, this;
  };
}, function(z, D, O) {
  var F = O(17)(O(19), "Map");
  z.exports = F;
}, function(z, D, O) {
  var F = O(10);
  z.exports = function(U) {
    var W = F(this, U).delete(U);
    return this.size -= W ? 1 : 0, W;
  };
}, function(z, D) {
  z.exports = function(O) {
    var F = typeof O;
    return F == "string" || F == "number" || F == "symbol" || F == "boolean" ? O !== "__proto__" : O === null;
  };
}, function(z, D, O) {
  var F = O(10);
  z.exports = function(U) {
    return F(this, U).get(U);
  };
}, function(z, D, O) {
  var F = O(10);
  z.exports = function(U) {
    return F(this, U).has(U);
  };
}, function(z, D, O) {
  var F = O(10);
  z.exports = function(U, W) {
    var B = F(this, U), K = B.size;
    return B.set(U, W), this.size += B.size == K ? 0 : 1, this;
  };
}, function(z, D, O) {
  var F = O(101);
  z.exports = function(U) {
    return U == null ? "" : F(U);
  };
}, function(z, D, O) {
  var F = O(18), U = O(102), W = O(21), B = O(22), K = F ? F.prototype : void 0, X = K ? K.toString : void 0;
  z.exports = function Y(Q) {
    if (typeof Q == "string")
      return Q;
    if (W(Q))
      return U(Q, Y) + "";
    if (B(Q))
      return X ? X.call(Q) : "";
    var J = Q + "";
    return J == "0" && 1 / Q == -1 / 0 ? "-0" : J;
  };
}, function(z, D) {
  z.exports = function(O, F) {
    for (var U = -1, W = O == null ? 0 : O.length, B = Array(W); ++U < W; )
      B[U] = F(O[U], U, O);
    return B;
  };
}, function(z, D) {
  var O = /^(?:0|[1-9]\d*)$/;
  z.exports = function(F, U) {
    var W = typeof F;
    return !!(U = U ?? 9007199254740991) && (W == "number" || W != "symbol" && O.test(F)) && F > -1 && F % 1 == 0 && F < U;
  };
}, function(z, D, O) {
  var F = O(22);
  z.exports = function(U) {
    if (typeof U == "string" || F(U))
      return U;
    var W = U + "";
    return W == "0" && 1 / U == -1 / 0 ? "-0" : W;
  };
}, function(z, D, O) {
  var F = this && this.__importDefault || function(X) {
    return X && X.__esModule ? X : { default: X };
  };
  Object.defineProperty(D, "__esModule", { value: !0 });
  var U = F(O(15)), W = O(106), B = function() {
    function X(Y) {
      this.converter = Y, this.finalResult = [];
    }
    return Object.defineProperty(X.prototype, "needEmitLine", { get: function() {
      return !!this.converter.parseRuntime.subscribe && !!this.converter.parseRuntime.subscribe.onNext || this.needPushDownstream;
    }, enumerable: !0, configurable: !0 }), Object.defineProperty(X.prototype, "needPushDownstream", { get: function() {
      return this._needPushDownstream === void 0 && (this._needPushDownstream = this.converter.listeners("data").length > 0 || this.converter.listeners("readable").length > 0), this._needPushDownstream;
    }, enumerable: !0, configurable: !0 }), Object.defineProperty(X.prototype, "needEmitAll", { get: function() {
      return !!this.converter.parseRuntime.then && this.converter.parseParam.needEmitAll;
    }, enumerable: !0, configurable: !0 }), X.prototype.processResult = function(Y) {
      var Q = this, J = this.converter.parseRuntime.parsedLineNumber;
      return this.needPushDownstream && this.converter.parseParam.downstreamFormat === "array" && J === 0 && K(this.converter, "[" + W.EOL), new U.default(function(ee, ae) {
        Q.needEmitLine ? function re(ie, ue, q, ne, ce) {
          if (q >= ie.length)
            ce();
          else if (ue.parseRuntime.subscribe && ue.parseRuntime.subscribe.onNext) {
            var he = ue.parseRuntime.subscribe.onNext, we = ie[q], me = he(we, ue.parseRuntime.parsedLineNumber + q);
            if (q++, me && me.then)
              me.then(function() {
                (function(be, _e, Me, Ne, Ee, $e, De) {
                  Ee && K(Me, De), re(be, Me, Ne, Ee, $e);
                })(ie, 0, ue, q, ne, ce, we);
              }, ce);
            else {
              for (ne && K(ue, we); q < ie.length; ) {
                var de = ie[q];
                he(de, ue.parseRuntime.parsedLineNumber + q), q++, ne && K(ue, de);
              }
              ce();
            }
          } else {
            if (ne)
              for (; q < ie.length; )
                de = ie[q++], K(ue, de);
            ce();
          }
        }(Y, Q.converter, 0, Q.needPushDownstream, function(re) {
          re ? ae(re) : (Q.appendFinalResult(Y), ee());
        }) : (Q.appendFinalResult(Y), ee());
      });
    }, X.prototype.appendFinalResult = function(Y) {
      this.needEmitAll && (this.finalResult = this.finalResult.concat(Y)), this.converter.parseRuntime.parsedLineNumber += Y.length;
    }, X.prototype.processError = function(Y) {
      this.converter.parseRuntime.subscribe && this.converter.parseRuntime.subscribe.onError && this.converter.parseRuntime.subscribe.onError(Y), this.converter.parseRuntime.then && this.converter.parseRuntime.then.onrejected && this.converter.parseRuntime.then.onrejected(Y);
    }, X.prototype.endProcess = function() {
      this.converter.parseRuntime.then && this.converter.parseRuntime.then.onfulfilled && (this.needEmitAll ? this.converter.parseRuntime.then.onfulfilled(this.finalResult) : this.converter.parseRuntime.then.onfulfilled([])), this.converter.parseRuntime.subscribe && this.converter.parseRuntime.subscribe.onCompleted && this.converter.parseRuntime.subscribe.onCompleted(), this.needPushDownstream && this.converter.parseParam.downstreamFormat === "array" && K(this.converter, "]" + W.EOL);
    }, X;
  }();
  function K(X, Y) {
    if (typeof Y != "object" || X.options.objectMode)
      X.push(Y);
    else {
      var Q = JSON.stringify(Y);
      X.push(Q + (X.parseParam.downstreamFormat === "array" ? "," + W.EOL : W.EOL), "utf8");
    }
  }
  D.Result = B;
}, function(z, D) {
  D.endianness = function() {
    return "LE";
  }, D.hostname = function() {
    return typeof location < "u" ? location.hostname : "";
  }, D.loadavg = function() {
    return [];
  }, D.uptime = function() {
    return 0;
  }, D.freemem = function() {
    return Number.MAX_VALUE;
  }, D.totalmem = function() {
    return Number.MAX_VALUE;
  }, D.cpus = function() {
    return [];
  }, D.type = function() {
    return "Browser";
  }, D.release = function() {
    return typeof navigator < "u" ? navigator.appVersion : "";
  }, D.networkInterfaces = D.getNetworkInterfaces = function() {
    return {};
  }, D.arch = function() {
    return "javascript";
  }, D.platform = function() {
    return "browser";
  }, D.tmpdir = D.tmpDir = function() {
    return "/tmp";
  }, D.EOL = `
`, D.homedir = function() {
    return "/";
  };
}]);
const csv = /* @__PURE__ */ getDefaultExportFromCjs$1(browser);
var __defProp$2 = Object.defineProperty, __getOwnPropDesc$2 = Object.getOwnPropertyDescriptor, __decorateClass$2 = (z, D, O, F) => {
  for (var U = F > 1 ? void 0 : F ? __getOwnPropDesc$2(D, O) : D, W = z.length - 1, B; W >= 0; W--)
    (B = z[W]) && (U = (F ? B(D, O, U) : B(U)) || U);
  return F && U && __defProp$2(D, O, U), U;
};
let DataSource = class extends AbstractComponent(s$7) {
  constructor() {
    super(...arguments), this.fileName = null, this.fileType = "json";
  }
  willUpdate(z) {
    if (z.has("for") && this.for || z.has("src") && this.src) {
      const D = document.querySelector(`#${this.for}`);
      if (!D)
        return;
      this.verificationGrid = D, this.updateVerificationGrid();
    }
  }
  async getJsonData() {
    if (!this.for)
      throw new Error("for attribute must be set on a data source");
    if (!this.src)
      return [];
    const z = await fetch(this.src);
    if (!z.ok)
      throw new Error("Could not fetch page");
    const D = await z.text(), O = z.headers.get("Content-Type");
    return O ? this.fileType = O.includes("json") ? "json" : "csv" : this.fileType = this.fileFormat(D[0]), this.fileType === "json" ? JSON.parse(D) : await csv({ flatKeys: !0 }).fromString(D);
  }
  buildCallback(z) {
    if (!Array.isArray(z))
      throw new Error("Response is not an array");
    return async (D) => {
      const O = D, F = O + this.verificationGrid.gridSize;
      return z.slice(O, F) ?? [];
    };
  }
  handleFileChange(z) {
    var U;
    const O = (U = z.target.files) == null ? void 0 : U.item(0);
    if (!O || !this.verificationGrid)
      return;
    const F = new FileReader();
    F.onload = async () => {
      const W = F.result, B = new Blob([W], { type: O.type }), K = URL.createObjectURL(B);
      this.fileName = O.name, this.src = K;
    }, F.readAsText(O);
  }
  // if the user does not explicitly specify a file format that their data is in
  // we can use some simple heuristics to determine the file format
  // this should not be a replacement for the user explicitly specifying the file
  // format, but it is better than throwing an error
  // TODO: The contents should probably be a pointer because otherwise we are copying the entire file!
  fileFormat(z) {
    const D = z === "{" || z === "[";
    return this.fileType = D ? "json" : "csv", this.fileType;
  }
  async updateVerificationGrid() {
    var O;
    if (!this.verificationGrid)
      return;
    const z = await this.getJsonData();
    if (!z)
      return;
    const D = this.buildCallback(z);
    D && (this.fileName || (this.fileName = ((O = this.src) == null ? void 0 : O.split("/").pop()) ?? null), this.verificationGrid.getPage = D, this.verificationGrid.dataSource = this);
  }
  fileInputTemplate() {
    return x`
      <div class="file-picker">
        <button @pointerdown="${(D) => {
      D.preventDefault(), this.fileInput.click();
    }}" class="oe-btn-secondary">
          ${this.src ? `File: ${this.fileName ?? this.src}` : "Browse files"}
        </button>
        <input @change="${this.handleFileChange}" type="file" accept=".csv,.json" class="hidden" />
      </div>
    `;
  }
  render() {
    return this.local ? this.fileInputTemplate() : T;
  }
};
DataSource.styles = dataSourceStyles;
__decorateClass$2([
  n$6({ type: String })
], DataSource.prototype, "src", 2);
__decorateClass$2([
  n$6({ type: String })
], DataSource.prototype, "for", 2);
__decorateClass$2([
  n$6({ type: Boolean, converter: booleanConverter })
], DataSource.prototype, "local", 2);
__decorateClass$2([
  r$4()
], DataSource.prototype, "fileName", 2);
__decorateClass$2([
  e$b("input[type=file]")
], DataSource.prototype, "fileInput", 2);
DataSource = __decorateClass$2([
  t$5("oe-data-source")
], DataSource);
const helpDialogStyles = i$7`
  #help-dialog {
    h1 {
      font-weight: 600;
    }

    h2,
    h3 {
      font-weight: 500;
      margin-bottom: 0;
    }

    hr {
      position: relative;
      margin-top: 1em;
      margin-bottom: 1.5em;
    }

    section {
      position: relative;
      width: fix-content;
      max-width: 60em;
      padding: var(--oe-spacing);
    }
  }

  .dialog-content {
    display: flex;
    flex-wrap: wrap;
    gap: var(--oe-spacing);

    > * {
      flex: 1;

      &:not(:first-child) {
        border-left: 1px dotted var(--oe-font-color);
      }
    }
  }

  .dialog-controls {
    display: block;
    position: relative;
  }
`;
var __defProp$1 = Object.defineProperty, __getOwnPropDesc$1 = Object.getOwnPropertyDescriptor, __decorateClass$1 = (z, D, O, F) => {
  for (var U = F > 1 ? void 0 : F ? __getOwnPropDesc$1(D, O) : D, W = z.length - 1, B; W >= 0; W--)
    (B = z[W]) && (U = (F ? B(D, O, U) : B(U)) || U);
  return F && U && __defProp$1(D, O, U), U;
};
const helpPreferenceLocalStorageKey = "oe-verification-grid-dialog-preferences";
let VerificationHelpDialog = class extends AbstractComponent(s$7) {
  constructor() {
    super(...arguments), this.showRememberOption = !0;
  }
  firstUpdated() {
    localStorage.getItem(helpPreferenceLocalStorageKey) === null && this.helpDialogElement.showModal(), console.log("decision elements", this.decisionElements);
  }
  showModal(z = !0) {
    this.showRememberOption = z, this.helpDialogElement.showModal();
  }
  // TODO: narrow the typing here
  closeHelpDialog() {
    const z = this.shadowRoot.getElementById("dialog-preference");
    if (!z)
      return;
    z.checked ? localStorage.removeItem(helpPreferenceLocalStorageKey) : localStorage.setItem(helpPreferenceLocalStorageKey, "true");
  }
  keyboardShortcutTemplate(z) {
    return x`
      <div class="keyboard-shortcuts">
        ${z.map(
      (D) => x`<div>
            ${D.key.split("+").map((O, F, { length: U }) => x`<kbd class="key">${O}</kbd> ${F !== U - 1 ? "+" : T}`)}
            <span class="description">${D.description}</span>
          </div>`
    )}
      </div>
    `;
  }
  render() {
    var O;
    const z = [
      { key: "Ctrl + A", description: "Select all items" },
      { key: "Shift + Click", description: "Add a range of items to the sub-selection" },
      { key: "Ctrl + Click", description: "Toggle the selection of a single item" },
      { key: "Ctrl + Shift + Click", description: "Select a range of items" },
      { key: "Esc", description: "Deselect all items" },
      { key: "Alt", description: "Show possible keyboard shortcuts" },
      { key: "Left Arrow", description: "Go back to the previous page" },
      { key: "Right Arrow", description: "Go to the next page (when viewing history)" }
    ], D = [
      ...((O = this.decisionElements) == null ? void 0 : O.map((F) => ({
        key: F.shortcut,
        description: `${F.innerText} ${F.additionalTags ? `(${F.additionalTags})` : ""}`
      }))) ?? []
    ];
    return x`
      <dialog id="help-dialog" @click="${() => this.helpDialogElement.close()}" @close="${this.closeHelpDialog}">
        <div class="dialog-container" @click="${(F) => F.stopPropagation()}">
          <div class="dialog-content">
            <section>
              <h1>Information</h1>
              <p>
                The Verification grid is a tool to help you validate and verify audio events either generated by a
                machine learning model or by a human annotator.
              </p>
            </section>

            <section>
              <h2>Decisions</h2>
              <p>Review the samples, press the button that makes the most sense</p>

              ${this.selectionBehavior !== "tablet" ? x`
                    <h3>Keyboard Shortcuts</h3>
                    ${this.keyboardShortcutTemplate(D)}
                  ` : T}
            </section>

            <section>
              <h2>Sub-Selection</h2>
              <p>You can apply a decision to only a few items in the grid by clicking on them.</p>

              ${this.selectionBehavior !== "tablet" ? x`
                    <h3>Keyboard Shortcuts</h3>
                    <p>
                      You can also use <kbd>Alt</kbd> + <math>a number</math> (e.g. <kbd>Alt</kbd> + <kbd>1</kbd>) to
                      select a tile using you keyboard. It is possible to see the possible keyboard shortcuts for
                      selection by holding down the <kbd>Alt</kbd> key.
                    </p>

                    ${this.keyboardShortcutTemplate(z)}
                  ` : T}
            </section>
          </div>

          <hr />

          <form class="dialog-controls" method="dialog">
            <label class="show-again">
              ${this.showRememberOption ? x`
                    <input
                      id="dialog-preference"
                      name="dialog-preference"
                      type="checkbox"
                      ?checked="${localStorage.getItem(helpPreferenceLocalStorageKey) !== null}"
                    />
                    Do not show this dialog again
                  ` : T}
            </label>
            <button class="oe-btn oe-btn-primary close-btn" type="submit" autofocus>Close</button>
          </form>
        </div>
      </dialog>
    `;
  }
};
VerificationHelpDialog.styles = helpDialogStyles;
__decorateClass$1([
  n$6({ type: Array })
], VerificationHelpDialog.prototype, "decisionElements", 2);
__decorateClass$1([
  n$6({ type: String })
], VerificationHelpDialog.prototype, "selectionBehavior", 2);
__decorateClass$1([
  r$4()
], VerificationHelpDialog.prototype, "showRememberOption", 2);
__decorateClass$1([
  e$b("#help-dialog")
], VerificationHelpDialog.prototype, "helpDialogElement", 2);
VerificationHelpDialog = __decorateClass$1([
  t$5("oe-verification-help-dialog")
], VerificationHelpDialog);
var __defProp = Object.defineProperty, __defProps = Object.defineProperties, __getOwnPropDesc = Object.getOwnPropertyDescriptor, __getOwnPropDescs = Object.getOwnPropertyDescriptors, __getOwnPropSymbols = Object.getOwnPropertySymbols, __hasOwnProp = Object.prototype.hasOwnProperty, __propIsEnum = Object.prototype.propertyIsEnumerable, __knownSymbol = (z, D) => (D = Symbol[z]) ? D : Symbol.for("Symbol." + z), __defNormalProp = (z, D, O) => D in z ? __defProp(z, D, { enumerable: !0, configurable: !0, writable: !0, value: O }) : z[D] = O, __spreadValues = (z, D) => {
  for (var O in D || (D = {}))
    __hasOwnProp.call(D, O) && __defNormalProp(z, O, D[O]);
  if (__getOwnPropSymbols)
    for (var O of __getOwnPropSymbols(D))
      __propIsEnum.call(D, O) && __defNormalProp(z, O, D[O]);
  return z;
}, __spreadProps = (z, D) => __defProps(z, __getOwnPropDescs(D)), __decorateClass = (z, D, O, F) => {
  for (var U = F > 1 ? void 0 : F ? __getOwnPropDesc(D, O) : D, W = z.length - 1, B; W >= 0; W--)
    (B = z[W]) && (U = (F ? B(D, O, U) : B(U)) || U);
  return F && U && __defProp(D, O, U), U;
}, __await = function(z, D) {
  this[0] = z, this[1] = D;
}, __yieldStar = (z) => {
  var D = z[__knownSymbol("asyncIterator")], O = !1, F, U = {};
  return D == null ? (D = z[__knownSymbol("iterator")](), F = (W) => U[W] = (B) => D[W](B)) : (D = D.call(z), F = (W) => U[W] = (B) => {
    if (O) {
      if (O = !1, W === "throw")
        throw B;
      return B;
    }
    return O = !0, {
      done: !1,
      value: new __await(new Promise((K) => {
        var X = D[W](B);
        if (!(X instanceof Object))
          throw TypeError("Object expected");
        K(X);
      }), 1)
    };
  }), U[__knownSymbol("iterator")] = () => U, F("next"), "throw" in D ? F("throw") : U.throw = (W) => {
    throw W;
  }, "return" in D && F("return"), U;
}, formCollections = /* @__PURE__ */ new WeakMap(), reportValidityOverloads = /* @__PURE__ */ new WeakMap(), checkValidityOverloads = /* @__PURE__ */ new WeakMap(), userInteractedControls = /* @__PURE__ */ new WeakSet(), interactions = /* @__PURE__ */ new WeakMap(), FormControlController = class {
  constructor(z, D) {
    this.handleFormData = (O) => {
      const F = this.options.disabled(this.host), U = this.options.name(this.host), W = this.options.value(this.host), B = this.host.tagName.toLowerCase() === "sl-button";
      this.host.isConnected && !F && !B && typeof U == "string" && U.length > 0 && typeof W < "u" && (Array.isArray(W) ? W.forEach((K) => {
        O.formData.append(U, K.toString());
      }) : O.formData.append(U, W.toString()));
    }, this.handleFormSubmit = (O) => {
      var F;
      const U = this.options.disabled(this.host), W = this.options.reportValidity;
      this.form && !this.form.noValidate && ((F = formCollections.get(this.form)) == null || F.forEach((B) => {
        this.setUserInteracted(B, !0);
      })), this.form && !this.form.noValidate && !U && !W(this.host) && (O.preventDefault(), O.stopImmediatePropagation());
    }, this.handleFormReset = () => {
      this.options.setValue(this.host, this.options.defaultValue(this.host)), this.setUserInteracted(this.host, !1), interactions.set(this.host, []);
    }, this.handleInteraction = (O) => {
      const F = interactions.get(this.host);
      F.includes(O.type) || F.push(O.type), F.length === this.options.assumeInteractionOn.length && this.setUserInteracted(this.host, !0);
    }, this.checkFormValidity = () => {
      if (this.form && !this.form.noValidate) {
        const O = this.form.querySelectorAll("*");
        for (const F of O)
          if (typeof F.checkValidity == "function" && !F.checkValidity())
            return !1;
      }
      return !0;
    }, this.reportFormValidity = () => {
      if (this.form && !this.form.noValidate) {
        const O = this.form.querySelectorAll("*");
        for (const F of O)
          if (typeof F.reportValidity == "function" && !F.reportValidity())
            return !1;
      }
      return !0;
    }, (this.host = z).addController(this), this.options = __spreadValues({
      form: (O) => {
        const F = O.form;
        if (F) {
          const W = O.getRootNode().querySelector(`#${F}`);
          if (W)
            return W;
        }
        return O.closest("form");
      },
      name: (O) => O.name,
      value: (O) => O.value,
      defaultValue: (O) => O.defaultValue,
      disabled: (O) => {
        var F;
        return (F = O.disabled) != null ? F : !1;
      },
      reportValidity: (O) => typeof O.reportValidity == "function" ? O.reportValidity() : !0,
      checkValidity: (O) => typeof O.checkValidity == "function" ? O.checkValidity() : !0,
      setValue: (O, F) => O.value = F,
      assumeInteractionOn: ["sl-input"]
    }, D);
  }
  hostConnected() {
    const z = this.options.form(this.host);
    z && this.attachForm(z), interactions.set(this.host, []), this.options.assumeInteractionOn.forEach((D) => {
      this.host.addEventListener(D, this.handleInteraction);
    });
  }
  hostDisconnected() {
    this.detachForm(), interactions.delete(this.host), this.options.assumeInteractionOn.forEach((z) => {
      this.host.removeEventListener(z, this.handleInteraction);
    });
  }
  hostUpdated() {
    const z = this.options.form(this.host);
    z || this.detachForm(), z && this.form !== z && (this.detachForm(), this.attachForm(z)), this.host.hasUpdated && this.setValidity(this.host.validity.valid);
  }
  attachForm(z) {
    z ? (this.form = z, formCollections.has(this.form) ? formCollections.get(this.form).add(this.host) : formCollections.set(this.form, /* @__PURE__ */ new Set([this.host])), this.form.addEventListener("formdata", this.handleFormData), this.form.addEventListener("submit", this.handleFormSubmit), this.form.addEventListener("reset", this.handleFormReset), reportValidityOverloads.has(this.form) || (reportValidityOverloads.set(this.form, this.form.reportValidity), this.form.reportValidity = () => this.reportFormValidity()), checkValidityOverloads.has(this.form) || (checkValidityOverloads.set(this.form, this.form.checkValidity), this.form.checkValidity = () => this.checkFormValidity())) : this.form = void 0;
  }
  detachForm() {
    if (!this.form)
      return;
    const z = formCollections.get(this.form);
    z && (z.delete(this.host), z.size <= 0 && (this.form.removeEventListener("formdata", this.handleFormData), this.form.removeEventListener("submit", this.handleFormSubmit), this.form.removeEventListener("reset", this.handleFormReset), reportValidityOverloads.has(this.form) && (this.form.reportValidity = reportValidityOverloads.get(this.form), reportValidityOverloads.delete(this.form)), checkValidityOverloads.has(this.form) && (this.form.checkValidity = checkValidityOverloads.get(this.form), checkValidityOverloads.delete(this.form)), this.form = void 0));
  }
  setUserInteracted(z, D) {
    D ? userInteractedControls.add(z) : userInteractedControls.delete(z), z.requestUpdate();
  }
  doAction(z, D) {
    if (this.form) {
      const O = document.createElement("button");
      O.type = z, O.style.position = "absolute", O.style.width = "0", O.style.height = "0", O.style.clipPath = "inset(50%)", O.style.overflow = "hidden", O.style.whiteSpace = "nowrap", D && (O.name = D.name, O.value = D.value, ["formaction", "formenctype", "formmethod", "formnovalidate", "formtarget"].forEach((F) => {
        D.hasAttribute(F) && O.setAttribute(F, D.getAttribute(F));
      })), this.form.append(O), O.click(), O.remove();
    }
  }
  /** Returns the associated `<form>` element, if one exists. */
  getForm() {
    var z;
    return (z = this.form) != null ? z : null;
  }
  /** Resets the form, restoring all the control to their default value */
  reset(z) {
    this.doAction("reset", z);
  }
  /** Submits the form, triggering validation and form data injection. */
  submit(z) {
    this.doAction("submit", z);
  }
  /**
   * Synchronously sets the form control's validity. Call this when you know the future validity but need to update
   * the host element immediately, i.e. before Lit updates the component in the next update.
   */
  setValidity(z) {
    const D = this.host, O = !!userInteractedControls.has(D), F = !!D.required;
    D.toggleAttribute("data-required", F), D.toggleAttribute("data-optional", !F), D.toggleAttribute("data-invalid", !z), D.toggleAttribute("data-valid", z), D.toggleAttribute("data-user-invalid", !z && O), D.toggleAttribute("data-user-valid", z && O);
  }
  /**
   * Updates the form control's validity based on the current value of `host.validity.valid`. Call this when anything
   * that affects constraint validation changes so the component receives the correct validity states.
   */
  updateValidity() {
    const z = this.host;
    this.setValidity(z.validity.valid);
  }
  /**
   * Dispatches a non-bubbling, cancelable custom event of type `sl-invalid`.
   * If the `sl-invalid` event will be cancelled then the original `invalid`
   * event (which may have been passed as argument) will also be cancelled.
   * If no original `invalid` event has been passed then the `sl-invalid`
   * event will be cancelled before being dispatched.
   */
  emitInvalidEvent(z) {
    const D = new CustomEvent("sl-invalid", {
      bubbles: !1,
      composed: !1,
      cancelable: !0,
      detail: {}
    });
    z || D.preventDefault(), this.host.dispatchEvent(D) || z == null || z.preventDefault();
  }
}, validValidityState = Object.freeze({
  badInput: !1,
  customError: !1,
  patternMismatch: !1,
  rangeOverflow: !1,
  rangeUnderflow: !1,
  stepMismatch: !1,
  tooLong: !1,
  tooShort: !1,
  typeMismatch: !1,
  valid: !0,
  valueMissing: !1
}), valueMissingValidityState = Object.freeze(__spreadProps(__spreadValues({}, validValidityState), {
  valid: !1,
  valueMissing: !0
})), customErrorValidityState = Object.freeze(__spreadProps(__spreadValues({}, validValidityState), {
  valid: !1,
  customError: !0
})), tree_styles_default = i$7`
  :host {
    /*
     * These are actually used by tree item, but we define them here so they can more easily be set and all tree items
     * stay consistent.
     */
    --indent-guide-color: var(--sl-color-neutral-200);
    --indent-guide-offset: 0;
    --indent-guide-style: solid;
    --indent-guide-width: 0;
    --indent-size: var(--sl-spacing-large);

    display: block;

    /*
     * Tree item indentation uses the "em" unit to increment its width on each level, so setting the font size to zero
     * here removes the indentation for all the nodes on the first level.
     */
    font-size: 0;
  }
`, tree_item_styles_default = i$7`
  :host {
    display: block;
    outline: 0;
    z-index: 0;
  }

  :host(:focus) {
    outline: none;
  }

  slot:not([name])::slotted(sl-icon) {
    margin-inline-end: var(--sl-spacing-x-small);
  }

  .tree-item {
    position: relative;
    display: flex;
    align-items: stretch;
    flex-direction: column;
    color: var(--sl-color-neutral-700);
    cursor: pointer;
    user-select: none;
    -webkit-user-select: none;
  }

  .tree-item__checkbox {
    pointer-events: none;
  }

  .tree-item__expand-button,
  .tree-item__checkbox,
  .tree-item__label {
    font-family: var(--sl-font-sans);
    font-size: var(--sl-font-size-medium);
    font-weight: var(--sl-font-weight-normal);
    line-height: var(--sl-line-height-dense);
    letter-spacing: var(--sl-letter-spacing-normal);
  }

  .tree-item__checkbox::part(base) {
    display: flex;
    align-items: center;
  }

  .tree-item__indentation {
    display: block;
    width: 1em;
    flex-shrink: 0;
  }

  .tree-item__expand-button {
    display: flex;
    align-items: center;
    justify-content: center;
    box-sizing: content-box;
    color: var(--sl-color-neutral-500);
    padding: var(--sl-spacing-x-small);
    width: 1rem;
    height: 1rem;
    flex-shrink: 0;
    cursor: pointer;
  }

  .tree-item__expand-button {
    transition: var(--sl-transition-medium) rotate ease;
  }

  .tree-item--expanded .tree-item__expand-button {
    rotate: 90deg;
  }

  .tree-item--expanded.tree-item--rtl .tree-item__expand-button {
    rotate: -90deg;
  }

  .tree-item--expanded slot[name='expand-icon'],
  .tree-item:not(.tree-item--expanded) slot[name='collapse-icon'] {
    display: none;
  }

  .tree-item:not(.tree-item--has-expand-button) .tree-item__expand-icon-slot {
    display: none;
  }

  .tree-item__expand-button--visible {
    cursor: pointer;
  }

  .tree-item__item {
    display: flex;
    align-items: center;
    border-inline-start: solid 3px transparent;
  }

  .tree-item--disabled .tree-item__item {
    opacity: 0.5;
    outline: none;
    cursor: not-allowed;
  }

  :host(:focus-visible) .tree-item__item {
    outline: var(--sl-focus-ring);
    outline-offset: var(--sl-focus-ring-offset);
    z-index: 2;
  }

  :host(:not([aria-disabled='true'])) .tree-item--selected .tree-item__item {
    background-color: var(--sl-color-neutral-100);
    border-inline-start-color: var(--sl-color-primary-600);
  }

  :host(:not([aria-disabled='true'])) .tree-item__expand-button {
    color: var(--sl-color-neutral-600);
  }

  .tree-item__label {
    display: flex;
    align-items: center;
    transition: var(--sl-transition-fast) color;
  }

  .tree-item__children {
    display: block;
    font-size: calc(1em + var(--indent-size, var(--sl-spacing-medium)));
  }

  /* Indentation lines */
  .tree-item__children {
    position: relative;
  }

  .tree-item__children::before {
    content: '';
    position: absolute;
    top: var(--indent-guide-offset);
    bottom: var(--indent-guide-offset);
    left: calc(1em - (var(--indent-guide-width) / 2) - 1px);
    border-inline-end: var(--indent-guide-width) var(--indent-guide-style) var(--indent-guide-color);
    z-index: 1;
  }

  .tree-item--rtl .tree-item__children::before {
    left: auto;
    right: 1em;
  }

  @media (forced-colors: active) {
    :host(:not([aria-disabled='true'])) .tree-item--selected .tree-item__item {
      outline: dashed 1px SelectedItem;
    }
  }
`, checkbox_styles_default = i$7`
  :host {
    display: inline-block;
  }

  .checkbox {
    position: relative;
    display: inline-flex;
    align-items: flex-start;
    font-family: var(--sl-input-font-family);
    font-weight: var(--sl-input-font-weight);
    color: var(--sl-input-label-color);
    vertical-align: middle;
    cursor: pointer;
  }

  .checkbox--small {
    --toggle-size: var(--sl-toggle-size-small);
    font-size: var(--sl-input-font-size-small);
  }

  .checkbox--medium {
    --toggle-size: var(--sl-toggle-size-medium);
    font-size: var(--sl-input-font-size-medium);
  }

  .checkbox--large {
    --toggle-size: var(--sl-toggle-size-large);
    font-size: var(--sl-input-font-size-large);
  }

  .checkbox__control {
    flex: 0 0 auto;
    position: relative;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    width: var(--toggle-size);
    height: var(--toggle-size);
    border: solid var(--sl-input-border-width) var(--sl-input-border-color);
    border-radius: 2px;
    background-color: var(--sl-input-background-color);
    color: var(--sl-color-neutral-0);
    transition:
      var(--sl-transition-fast) border-color,
      var(--sl-transition-fast) background-color,
      var(--sl-transition-fast) color,
      var(--sl-transition-fast) box-shadow;
  }

  .checkbox__input {
    position: absolute;
    opacity: 0;
    padding: 0;
    margin: 0;
    pointer-events: none;
  }

  .checkbox__checked-icon,
  .checkbox__indeterminate-icon {
    display: inline-flex;
    width: var(--toggle-size);
    height: var(--toggle-size);
  }

  /* Hover */
  .checkbox:not(.checkbox--checked):not(.checkbox--disabled) .checkbox__control:hover {
    border-color: var(--sl-input-border-color-hover);
    background-color: var(--sl-input-background-color-hover);
  }

  /* Focus */
  .checkbox:not(.checkbox--checked):not(.checkbox--disabled) .checkbox__input:focus-visible ~ .checkbox__control {
    outline: var(--sl-focus-ring);
    outline-offset: var(--sl-focus-ring-offset);
  }

  /* Checked/indeterminate */
  .checkbox--checked .checkbox__control,
  .checkbox--indeterminate .checkbox__control {
    border-color: var(--sl-color-primary-600);
    background-color: var(--sl-color-primary-600);
  }

  /* Checked/indeterminate + hover */
  .checkbox.checkbox--checked:not(.checkbox--disabled) .checkbox__control:hover,
  .checkbox.checkbox--indeterminate:not(.checkbox--disabled) .checkbox__control:hover {
    border-color: var(--sl-color-primary-500);
    background-color: var(--sl-color-primary-500);
  }

  /* Checked/indeterminate + focus */
  .checkbox.checkbox--checked:not(.checkbox--disabled) .checkbox__input:focus-visible ~ .checkbox__control,
  .checkbox.checkbox--indeterminate:not(.checkbox--disabled) .checkbox__input:focus-visible ~ .checkbox__control {
    outline: var(--sl-focus-ring);
    outline-offset: var(--sl-focus-ring-offset);
  }

  /* Disabled */
  .checkbox--disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }

  .checkbox__label {
    display: inline-block;
    color: var(--sl-input-label-color);
    line-height: var(--toggle-size);
    margin-inline-start: 0.5em;
    user-select: none;
    -webkit-user-select: none;
  }

  :host([required]) .checkbox__label::after {
    content: var(--sl-input-required-content);
    color: var(--sl-input-required-content-color);
    margin-inline-start: var(--sl-input-required-content-offset);
  }
`, defaultValue = (z = "value") => (D, O) => {
  const F = D.constructor, U = F.prototype.attributeChangedCallback;
  F.prototype.attributeChangedCallback = function(W, B, K) {
    var X;
    const Y = F.getPropertyOptions(z), Q = typeof Y.attribute == "string" ? Y.attribute : z;
    if (W === Q) {
      const J = Y.converter || u$3, ae = (typeof J == "function" ? J : (X = J == null ? void 0 : J.fromAttribute) != null ? X : u$3.fromAttribute)(K, Y.type);
      this[z] !== ae && (this[O] = ae);
    }
    U.call(this, W, B, K);
  };
}, form_control_styles_default = i$7`
  .form-control .form-control__label {
    display: none;
  }

  .form-control .form-control__help-text {
    display: none;
  }

  /* Label */
  .form-control--has-label .form-control__label {
    display: inline-block;
    color: var(--sl-input-label-color);
    margin-bottom: var(--sl-spacing-3x-small);
  }

  .form-control--has-label.form-control--small .form-control__label {
    font-size: var(--sl-input-label-font-size-small);
  }

  .form-control--has-label.form-control--medium .form-control__label {
    font-size: var(--sl-input-label-font-size-medium);
  }

  .form-control--has-label.form-control--large .form-control__label {
    font-size: var(--sl-input-label-font-size-large);
  }

  :host([required]) .form-control--has-label .form-control__label::after {
    content: var(--sl-input-required-content);
    margin-inline-start: var(--sl-input-required-content-offset);
    color: var(--sl-input-required-content-color);
  }

  /* Help text */
  .form-control--has-help-text .form-control__help-text {
    display: block;
    color: var(--sl-input-help-text-color);
    margin-top: var(--sl-spacing-3x-small);
  }

  .form-control--has-help-text.form-control--small .form-control__help-text {
    font-size: var(--sl-input-help-text-font-size-small);
  }

  .form-control--has-help-text.form-control--medium .form-control__help-text {
    font-size: var(--sl-input-help-text-font-size-medium);
  }

  .form-control--has-help-text.form-control--large .form-control__help-text {
    font-size: var(--sl-input-help-text-font-size-large);
  }

  .form-control--has-help-text.form-control--radio-group .form-control__help-text {
    margin-top: var(--sl-spacing-2x-small);
  }
`, icon_styles_default = i$7`
  :host {
    display: inline-block;
    width: 1em;
    height: 1em;
    box-sizing: content-box !important;
  }

  svg {
    display: block;
    height: 100%;
    width: 100%;
  }
`, basePath = "";
function setBasePath(z) {
  basePath = z;
}
function getBasePath(z = "") {
  if (!basePath) {
    const D = [...document.getElementsByTagName("script")], O = D.find((F) => F.hasAttribute("data-shoelace"));
    if (O)
      setBasePath(O.getAttribute("data-shoelace"));
    else {
      const F = D.find((W) => /shoelace(\.min)?\.js($|\?)/.test(W.src) || /shoelace-autoloader(\.min)?\.js($|\?)/.test(W.src));
      let U = "";
      F && (U = F.getAttribute("src")), setBasePath(U.split("/").slice(0, -1).join("/"));
    }
  }
  return basePath.replace(/\/$/, "") + (z ? `/${z.replace(/^\//, "")}` : "");
}
var library = {
  name: "default",
  resolver: (z) => getBasePath(`assets/icons/${z}.svg`)
}, library_default_default = library, icons = {
  caret: `
    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <polyline points="6 9 12 15 18 9"></polyline>
    </svg>
  `,
  check: `
    <svg part="checked-icon" class="checkbox__icon" viewBox="0 0 16 16">
      <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd" stroke-linecap="round">
        <g stroke="currentColor">
          <g transform="translate(3.428571, 3.428571)">
            <path d="M0,5.71428571 L3.42857143,9.14285714"></path>
            <path d="M9.14285714,0 L3.42857143,9.14285714"></path>
          </g>
        </g>
      </g>
    </svg>
  `,
  "chevron-down": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-chevron-down" viewBox="0 0 16 16">
      <path fill-rule="evenodd" d="M1.646 4.646a.5.5 0 0 1 .708 0L8 10.293l5.646-5.647a.5.5 0 0 1 .708.708l-6 6a.5.5 0 0 1-.708 0l-6-6a.5.5 0 0 1 0-.708z"/>
    </svg>
  `,
  "chevron-left": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-chevron-left" viewBox="0 0 16 16">
      <path fill-rule="evenodd" d="M11.354 1.646a.5.5 0 0 1 0 .708L5.707 8l5.647 5.646a.5.5 0 0 1-.708.708l-6-6a.5.5 0 0 1 0-.708l6-6a.5.5 0 0 1 .708 0z"/>
    </svg>
  `,
  "chevron-right": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-chevron-right" viewBox="0 0 16 16">
      <path fill-rule="evenodd" d="M4.646 1.646a.5.5 0 0 1 .708 0l6 6a.5.5 0 0 1 0 .708l-6 6a.5.5 0 0 1-.708-.708L10.293 8 4.646 2.354a.5.5 0 0 1 0-.708z"/>
    </svg>
  `,
  copy: `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-copy" viewBox="0 0 16 16">
      <path fill-rule="evenodd" d="M4 2a2 2 0 0 1 2-2h8a2 2 0 0 1 2 2v8a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V2Zm2-1a1 1 0 0 0-1 1v8a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1V2a1 1 0 0 0-1-1H6ZM2 5a1 1 0 0 0-1 1v8a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1v-1h1v1a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h1v1H2Z"/>
    </svg>
  `,
  eye: `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-eye" viewBox="0 0 16 16">
      <path d="M16 8s-3-5.5-8-5.5S0 8 0 8s3 5.5 8 5.5S16 8 16 8zM1.173 8a13.133 13.133 0 0 1 1.66-2.043C4.12 4.668 5.88 3.5 8 3.5c2.12 0 3.879 1.168 5.168 2.457A13.133 13.133 0 0 1 14.828 8c-.058.087-.122.183-.195.288-.335.48-.83 1.12-1.465 1.755C11.879 11.332 10.119 12.5 8 12.5c-2.12 0-3.879-1.168-5.168-2.457A13.134 13.134 0 0 1 1.172 8z"/>
      <path d="M8 5.5a2.5 2.5 0 1 0 0 5 2.5 2.5 0 0 0 0-5zM4.5 8a3.5 3.5 0 1 1 7 0 3.5 3.5 0 0 1-7 0z"/>
    </svg>
  `,
  "eye-slash": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-eye-slash" viewBox="0 0 16 16">
      <path d="M13.359 11.238C15.06 9.72 16 8 16 8s-3-5.5-8-5.5a7.028 7.028 0 0 0-2.79.588l.77.771A5.944 5.944 0 0 1 8 3.5c2.12 0 3.879 1.168 5.168 2.457A13.134 13.134 0 0 1 14.828 8c-.058.087-.122.183-.195.288-.335.48-.83 1.12-1.465 1.755-.165.165-.337.328-.517.486l.708.709z"/>
      <path d="M11.297 9.176a3.5 3.5 0 0 0-4.474-4.474l.823.823a2.5 2.5 0 0 1 2.829 2.829l.822.822zm-2.943 1.299.822.822a3.5 3.5 0 0 1-4.474-4.474l.823.823a2.5 2.5 0 0 0 2.829 2.829z"/>
      <path d="M3.35 5.47c-.18.16-.353.322-.518.487A13.134 13.134 0 0 0 1.172 8l.195.288c.335.48.83 1.12 1.465 1.755C4.121 11.332 5.881 12.5 8 12.5c.716 0 1.39-.133 2.02-.36l.77.772A7.029 7.029 0 0 1 8 13.5C3 13.5 0 8 0 8s.939-1.721 2.641-3.238l.708.709zm10.296 8.884-12-12 .708-.708 12 12-.708.708z"/>
    </svg>
  `,
  eyedropper: `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-eyedropper" viewBox="0 0 16 16">
      <path d="M13.354.646a1.207 1.207 0 0 0-1.708 0L8.5 3.793l-.646-.647a.5.5 0 1 0-.708.708L8.293 5l-7.147 7.146A.5.5 0 0 0 1 12.5v1.793l-.854.853a.5.5 0 1 0 .708.707L1.707 15H3.5a.5.5 0 0 0 .354-.146L11 7.707l1.146 1.147a.5.5 0 0 0 .708-.708l-.647-.646 3.147-3.146a1.207 1.207 0 0 0 0-1.708l-2-2zM2 12.707l7-7L10.293 7l-7 7H2v-1.293z"></path>
    </svg>
  `,
  "grip-vertical": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-grip-vertical" viewBox="0 0 16 16">
      <path d="M7 2a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm3 0a1 1 0 1 1-2 0 1 1 0 0 1 2 0zM7 5a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm3 0a1 1 0 1 1-2 0 1 1 0 0 1 2 0zM7 8a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm3 0a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm-3 3a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm3 0a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm-3 3a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm3 0a1 1 0 1 1-2 0 1 1 0 0 1 2 0z"></path>
    </svg>
  `,
  indeterminate: `
    <svg part="indeterminate-icon" class="checkbox__icon" viewBox="0 0 16 16">
      <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd" stroke-linecap="round">
        <g stroke="currentColor" stroke-width="2">
          <g transform="translate(2.285714, 6.857143)">
            <path d="M10.2857143,1.14285714 L1.14285714,1.14285714"></path>
          </g>
        </g>
      </g>
    </svg>
  `,
  "person-fill": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-person-fill" viewBox="0 0 16 16">
      <path d="M3 14s-1 0-1-1 1-4 6-4 6 3 6 4-1 1-1 1H3zm5-6a3 3 0 1 0 0-6 3 3 0 0 0 0 6z"/>
    </svg>
  `,
  "play-fill": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-play-fill" viewBox="0 0 16 16">
      <path d="m11.596 8.697-6.363 3.692c-.54.313-1.233-.066-1.233-.697V4.308c0-.63.692-1.01 1.233-.696l6.363 3.692a.802.802 0 0 1 0 1.393z"></path>
    </svg>
  `,
  "pause-fill": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-pause-fill" viewBox="0 0 16 16">
      <path d="M5.5 3.5A1.5 1.5 0 0 1 7 5v6a1.5 1.5 0 0 1-3 0V5a1.5 1.5 0 0 1 1.5-1.5zm5 0A1.5 1.5 0 0 1 12 5v6a1.5 1.5 0 0 1-3 0V5a1.5 1.5 0 0 1 1.5-1.5z"></path>
    </svg>
  `,
  radio: `
    <svg part="checked-icon" class="radio__icon" viewBox="0 0 16 16">
      <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g fill="currentColor">
          <circle cx="8" cy="8" r="3.42857143"></circle>
        </g>
      </g>
    </svg>
  `,
  "star-fill": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-star-fill" viewBox="0 0 16 16">
      <path d="M3.612 15.443c-.386.198-.824-.149-.746-.592l.83-4.73L.173 6.765c-.329-.314-.158-.888.283-.95l4.898-.696L7.538.792c.197-.39.73-.39.927 0l2.184 4.327 4.898.696c.441.062.612.636.282.95l-3.522 3.356.83 4.73c.078.443-.36.79-.746.592L8 13.187l-4.389 2.256z"/>
    </svg>
  `,
  "x-lg": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-x-lg" viewBox="0 0 16 16">
      <path d="M2.146 2.854a.5.5 0 1 1 .708-.708L8 7.293l5.146-5.147a.5.5 0 0 1 .708.708L8.707 8l5.147 5.146a.5.5 0 0 1-.708.708L8 8.707l-5.146 5.147a.5.5 0 0 1-.708-.708L7.293 8 2.146 2.854Z"/>
    </svg>
  `,
  "x-circle-fill": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-x-circle-fill" viewBox="0 0 16 16">
      <path d="M16 8A8 8 0 1 1 0 8a8 8 0 0 1 16 0zM5.354 4.646a.5.5 0 1 0-.708.708L7.293 8l-2.647 2.646a.5.5 0 0 0 .708.708L8 8.707l2.646 2.647a.5.5 0 0 0 .708-.708L8.707 8l2.647-2.646a.5.5 0 0 0-.708-.708L8 7.293 5.354 4.646z"></path>
    </svg>
  `
}, systemLibrary = {
  name: "system",
  resolver: (z) => z in icons ? `data:image/svg+xml,${encodeURIComponent(icons[z])}` : ""
}, library_system_default = systemLibrary, registry = [library_default_default, library_system_default], watchedIcons = [];
function watchIcon(z) {
  watchedIcons.push(z);
}
function unwatchIcon(z) {
  watchedIcons = watchedIcons.filter((D) => D !== z);
}
function getIconLibrary(z) {
  return registry.find((D) => D.name === z);
}
function watch(z, D) {
  const O = __spreadValues({
    waitUntilFirstUpdate: !1
  }, D);
  return (F, U) => {
    const { update: W } = F, B = Array.isArray(z) ? z : [z];
    F.update = function(K) {
      B.forEach((X) => {
        const Y = X;
        if (K.has(Y)) {
          const Q = K.get(Y), J = this[Y];
          Q !== J && (!O.waitUntilFirstUpdate || this.hasUpdated) && this[U](Q, J);
        }
      }), W.call(this, K);
    };
  };
}
var component_styles_default = i$7`
  :host {
    box-sizing: border-box;
  }

  :host *,
  :host *::before,
  :host *::after {
    box-sizing: inherit;
  }

  [hidden] {
    display: none !important;
  }
`, ShoelaceElement = class extends s$7 {
  constructor() {
    super(), Object.entries(this.constructor.dependencies).forEach(([z, D]) => {
      this.constructor.define(z, D);
    });
  }
  emit(z, D) {
    const O = new CustomEvent(z, __spreadValues({
      bubbles: !0,
      cancelable: !1,
      composed: !0,
      detail: {}
    }, D));
    return this.dispatchEvent(O), O;
  }
  /* eslint-enable */
  static define(z, D = this, O = {}) {
    const F = customElements.get(z);
    if (!F) {
      customElements.define(z, class extends D {
      }, O);
      return;
    }
    let U = " (unknown version)", W = U;
    "version" in D && D.version && (U = " v" + D.version), "version" in F && F.version && (W = " v" + F.version), !(U && W && U === W) && console.warn(
      `Attempted to register <${z}>${U}, but <${z}>${W} has already been registered.`
    );
  }
};
ShoelaceElement.version = "2.15.1";
ShoelaceElement.dependencies = {};
__decorateClass([
  n$6()
], ShoelaceElement.prototype, "dir", 2);
__decorateClass([
  n$6()
], ShoelaceElement.prototype, "lang", 2);
var CACHEABLE_ERROR = Symbol(), RETRYABLE_ERROR = Symbol(), parser, iconCache = /* @__PURE__ */ new Map(), SlIcon = class extends ShoelaceElement {
  constructor() {
    super(...arguments), this.initialRender = !1, this.svg = null, this.label = "", this.library = "default";
  }
  /** Given a URL, this function returns the resulting SVG element or an appropriate error symbol. */
  async resolveIcon(z, D) {
    var O;
    let F;
    if (D != null && D.spriteSheet) {
      this.svg = x`<svg part="svg">
        <use part="use" href="${z}"></use>
      </svg>`, await this.updateComplete;
      const U = this.shadowRoot.querySelector("[part='svg']");
      return typeof D.mutator == "function" && D.mutator(U), this.svg;
    }
    try {
      if (F = await fetch(z, { mode: "cors" }), !F.ok)
        return F.status === 410 ? CACHEABLE_ERROR : RETRYABLE_ERROR;
    } catch {
      return RETRYABLE_ERROR;
    }
    try {
      const U = document.createElement("div");
      U.innerHTML = await F.text();
      const W = U.firstElementChild;
      if (((O = W == null ? void 0 : W.tagName) == null ? void 0 : O.toLowerCase()) !== "svg")
        return CACHEABLE_ERROR;
      parser || (parser = new DOMParser());
      const K = parser.parseFromString(W.outerHTML, "text/html").body.querySelector("svg");
      return K ? (K.part.add("svg"), document.adoptNode(K)) : CACHEABLE_ERROR;
    } catch {
      return CACHEABLE_ERROR;
    }
  }
  connectedCallback() {
    super.connectedCallback(), watchIcon(this);
  }
  firstUpdated() {
    this.initialRender = !0, this.setIcon();
  }
  disconnectedCallback() {
    super.disconnectedCallback(), unwatchIcon(this);
  }
  getIconSource() {
    const z = getIconLibrary(this.library);
    return this.name && z ? {
      url: z.resolver(this.name),
      fromLibrary: !0
    } : {
      url: this.src,
      fromLibrary: !1
    };
  }
  handleLabelChange() {
    typeof this.label == "string" && this.label.length > 0 ? (this.setAttribute("role", "img"), this.setAttribute("aria-label", this.label), this.removeAttribute("aria-hidden")) : (this.removeAttribute("role"), this.removeAttribute("aria-label"), this.setAttribute("aria-hidden", "true"));
  }
  async setIcon() {
    var z;
    const { url: D, fromLibrary: O } = this.getIconSource(), F = O ? getIconLibrary(this.library) : void 0;
    if (!D) {
      this.svg = null;
      return;
    }
    let U = iconCache.get(D);
    if (U || (U = this.resolveIcon(D, F), iconCache.set(D, U)), !this.initialRender)
      return;
    const W = await U;
    if (W === RETRYABLE_ERROR && iconCache.delete(D), D === this.getIconSource().url) {
      if (e$3(W)) {
        this.svg = W;
        return;
      }
      switch (W) {
        case RETRYABLE_ERROR:
        case CACHEABLE_ERROR:
          this.svg = null, this.emit("sl-error");
          break;
        default:
          this.svg = W.cloneNode(!0), (z = F == null ? void 0 : F.mutator) == null || z.call(F, this.svg), this.emit("sl-load");
      }
    }
  }
  render() {
    return this.svg;
  }
};
SlIcon.styles = [component_styles_default, icon_styles_default];
__decorateClass([
  r$4()
], SlIcon.prototype, "svg", 2);
__decorateClass([
  n$6({ reflect: !0 })
], SlIcon.prototype, "name", 2);
__decorateClass([
  n$6()
], SlIcon.prototype, "src", 2);
__decorateClass([
  n$6()
], SlIcon.prototype, "label", 2);
__decorateClass([
  n$6({ reflect: !0 })
], SlIcon.prototype, "library", 2);
__decorateClass([
  watch("label")
], SlIcon.prototype, "handleLabelChange", 1);
__decorateClass([
  watch(["name", "src", "library"])
], SlIcon.prototype, "setIcon", 1);
var HasSlotController = class {
  constructor(z, ...D) {
    this.slotNames = [], this.handleSlotChange = (O) => {
      const F = O.target;
      (this.slotNames.includes("[default]") && !F.name || F.name && this.slotNames.includes(F.name)) && this.host.requestUpdate();
    }, (this.host = z).addController(this), this.slotNames = D;
  }
  hasDefaultSlot() {
    return [...this.host.childNodes].some((z) => {
      if (z.nodeType === z.TEXT_NODE && z.textContent.trim() !== "")
        return !0;
      if (z.nodeType === z.ELEMENT_NODE) {
        const D = z;
        if (D.tagName.toLowerCase() === "sl-visually-hidden")
          return !1;
        if (!D.hasAttribute("slot"))
          return !0;
      }
      return !1;
    });
  }
  hasNamedSlot(z) {
    return this.host.querySelector(`:scope > [slot="${z}"]`) !== null;
  }
  test(z) {
    return z === "[default]" ? this.hasDefaultSlot() : this.hasNamedSlot(z);
  }
  hostConnected() {
    this.host.shadowRoot.addEventListener("slotchange", this.handleSlotChange);
  }
  hostDisconnected() {
    this.host.shadowRoot.removeEventListener("slotchange", this.handleSlotChange);
  }
};
function getTextContent(z) {
  if (!z)
    return "";
  const D = z.assignedNodes({ flatten: !0 });
  let O = "";
  return [...D].forEach((F) => {
    F.nodeType === Node.TEXT_NODE && (O += F.textContent);
  }), O;
}
/**
 * @license
 * Copyright 2018 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const o$6 = (z) => z ?? T;
/**
 * @license
 * Copyright 2020 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const l$1 = e$7(class extends i$3 {
  constructor(z) {
    if (super(z), z.type !== t$3.PROPERTY && z.type !== t$3.ATTRIBUTE && z.type !== t$3.BOOLEAN_ATTRIBUTE)
      throw Error("The `live` directive is not allowed on child or event bindings");
    if (!f$1(z))
      throw Error("`live` bindings can only contain a single expression");
  }
  render(z) {
    return z;
  }
  update(z, [D]) {
    if (D === w$1 || D === T)
      return D;
    const O = z.element, F = z.name;
    if (z.type === t$3.PROPERTY) {
      if (D === O[F])
        return w$1;
    } else if (z.type === t$3.BOOLEAN_ATTRIBUTE) {
      if (!!D === O.hasAttribute(F))
        return w$1;
    } else if (z.type === t$3.ATTRIBUTE && O.getAttribute(F) === D + "")
      return w$1;
    return m(z), D;
  }
});
var SlCheckbox = class extends ShoelaceElement {
  constructor() {
    super(...arguments), this.formControlController = new FormControlController(this, {
      value: (z) => z.checked ? z.value || "on" : void 0,
      defaultValue: (z) => z.defaultChecked,
      setValue: (z, D) => z.checked = D
    }), this.hasSlotController = new HasSlotController(this, "help-text"), this.hasFocus = !1, this.title = "", this.name = "", this.size = "medium", this.disabled = !1, this.checked = !1, this.indeterminate = !1, this.defaultChecked = !1, this.form = "", this.required = !1, this.helpText = "";
  }
  /** Gets the validity state object */
  get validity() {
    return this.input.validity;
  }
  /** Gets the validation message */
  get validationMessage() {
    return this.input.validationMessage;
  }
  firstUpdated() {
    this.formControlController.updateValidity();
  }
  handleClick() {
    this.checked = !this.checked, this.indeterminate = !1, this.emit("sl-change");
  }
  handleBlur() {
    this.hasFocus = !1, this.emit("sl-blur");
  }
  handleInput() {
    this.emit("sl-input");
  }
  handleInvalid(z) {
    this.formControlController.setValidity(!1), this.formControlController.emitInvalidEvent(z);
  }
  handleFocus() {
    this.hasFocus = !0, this.emit("sl-focus");
  }
  handleDisabledChange() {
    this.formControlController.setValidity(this.disabled);
  }
  handleStateChange() {
    this.input.checked = this.checked, this.input.indeterminate = this.indeterminate, this.formControlController.updateValidity();
  }
  /** Simulates a click on the checkbox. */
  click() {
    this.input.click();
  }
  /** Sets focus on the checkbox. */
  focus(z) {
    this.input.focus(z);
  }
  /** Removes focus from the checkbox. */
  blur() {
    this.input.blur();
  }
  /** Checks for validity but does not show a validation message. Returns `true` when valid and `false` when invalid. */
  checkValidity() {
    return this.input.checkValidity();
  }
  /** Gets the associated form, if one exists. */
  getForm() {
    return this.formControlController.getForm();
  }
  /** Checks for validity and shows the browser's validation message if the control is invalid. */
  reportValidity() {
    return this.input.reportValidity();
  }
  /**
   * Sets a custom validation message. The value provided will be shown to the user when the form is submitted. To clear
   * the custom validation message, call this method with an empty string.
   */
  setCustomValidity(z) {
    this.input.setCustomValidity(z), this.formControlController.updateValidity();
  }
  render() {
    const z = this.hasSlotController.test("help-text"), D = this.helpText ? !0 : !!z;
    return x`
      <div
        class=${e$2({
      "form-control": !0,
      "form-control--small": this.size === "small",
      "form-control--medium": this.size === "medium",
      "form-control--large": this.size === "large",
      "form-control--has-help-text": D
    })}
      >
        <label
          part="base"
          class=${e$2({
      checkbox: !0,
      "checkbox--checked": this.checked,
      "checkbox--disabled": this.disabled,
      "checkbox--focused": this.hasFocus,
      "checkbox--indeterminate": this.indeterminate,
      "checkbox--small": this.size === "small",
      "checkbox--medium": this.size === "medium",
      "checkbox--large": this.size === "large"
    })}
        >
          <input
            class="checkbox__input"
            type="checkbox"
            title=${this.title}
            name=${this.name}
            value=${o$6(this.value)}
            .indeterminate=${l$1(this.indeterminate)}
            .checked=${l$1(this.checked)}
            .disabled=${this.disabled}
            .required=${this.required}
            aria-checked=${this.checked ? "true" : "false"}
            aria-describedby="help-text"
            @click=${this.handleClick}
            @input=${this.handleInput}
            @invalid=${this.handleInvalid}
            @blur=${this.handleBlur}
            @focus=${this.handleFocus}
          />

          <span
            part="control${this.checked ? " control--checked" : ""}${this.indeterminate ? " control--indeterminate" : ""}"
            class="checkbox__control"
          >
            ${this.checked ? x`
                  <sl-icon part="checked-icon" class="checkbox__checked-icon" library="system" name="check"></sl-icon>
                ` : ""}
            ${!this.checked && this.indeterminate ? x`
                  <sl-icon
                    part="indeterminate-icon"
                    class="checkbox__indeterminate-icon"
                    library="system"
                    name="indeterminate"
                  ></sl-icon>
                ` : ""}
          </span>

          <div part="label" class="checkbox__label">
            <slot></slot>
          </div>
        </label>

        <div
          aria-hidden=${D ? "false" : "true"}
          class="form-control__help-text"
          id="help-text"
          part="form-control-help-text"
        >
          <slot name="help-text">${this.helpText}</slot>
        </div>
      </div>
    `;
  }
};
SlCheckbox.styles = [component_styles_default, form_control_styles_default, checkbox_styles_default];
SlCheckbox.dependencies = { "sl-icon": SlIcon };
__decorateClass([
  e$b('input[type="checkbox"]')
], SlCheckbox.prototype, "input", 2);
__decorateClass([
  r$4()
], SlCheckbox.prototype, "hasFocus", 2);
__decorateClass([
  n$6()
], SlCheckbox.prototype, "title", 2);
__decorateClass([
  n$6()
], SlCheckbox.prototype, "name", 2);
__decorateClass([
  n$6()
], SlCheckbox.prototype, "value", 2);
__decorateClass([
  n$6({ reflect: !0 })
], SlCheckbox.prototype, "size", 2);
__decorateClass([
  n$6({ type: Boolean, reflect: !0 })
], SlCheckbox.prototype, "disabled", 2);
__decorateClass([
  n$6({ type: Boolean, reflect: !0 })
], SlCheckbox.prototype, "checked", 2);
__decorateClass([
  n$6({ type: Boolean, reflect: !0 })
], SlCheckbox.prototype, "indeterminate", 2);
__decorateClass([
  defaultValue("checked")
], SlCheckbox.prototype, "defaultChecked", 2);
__decorateClass([
  n$6({ reflect: !0 })
], SlCheckbox.prototype, "form", 2);
__decorateClass([
  n$6({ type: Boolean, reflect: !0 })
], SlCheckbox.prototype, "required", 2);
__decorateClass([
  n$6({ attribute: "help-text" })
], SlCheckbox.prototype, "helpText", 2);
__decorateClass([
  watch("disabled", { waitUntilFirstUpdate: !0 })
], SlCheckbox.prototype, "handleDisabledChange", 1);
__decorateClass([
  watch(["checked", "indeterminate"], { waitUntilFirstUpdate: !0 })
], SlCheckbox.prototype, "handleStateChange", 1);
var spinner_styles_default = i$7`
  :host {
    --track-width: 2px;
    --track-color: rgb(128 128 128 / 25%);
    --indicator-color: var(--sl-color-primary-600);
    --speed: 2s;

    display: inline-flex;
    width: 1em;
    height: 1em;
    flex: none;
  }

  .spinner {
    flex: 1 1 auto;
    height: 100%;
    width: 100%;
  }

  .spinner__track,
  .spinner__indicator {
    fill: none;
    stroke-width: var(--track-width);
    r: calc(0.5em - var(--track-width) / 2);
    cx: 0.5em;
    cy: 0.5em;
    transform-origin: 50% 50%;
  }

  .spinner__track {
    stroke: var(--track-color);
    transform-origin: 0% 0%;
  }

  .spinner__indicator {
    stroke: var(--indicator-color);
    stroke-linecap: round;
    stroke-dasharray: 150% 75%;
    animation: spin var(--speed) linear infinite;
  }

  @keyframes spin {
    0% {
      transform: rotate(0deg);
      stroke-dasharray: 0.05em, 3em;
    }

    50% {
      transform: rotate(450deg);
      stroke-dasharray: 1.375em, 1.375em;
    }

    100% {
      transform: rotate(1080deg);
      stroke-dasharray: 0.05em, 3em;
    }
  }
`;
const connectedElements = /* @__PURE__ */ new Set(), documentElementObserver = new MutationObserver(update), translations = /* @__PURE__ */ new Map();
let documentDirection = document.documentElement.dir || "ltr", documentLanguage = document.documentElement.lang || navigator.language, fallback;
documentElementObserver.observe(document.documentElement, {
  attributes: !0,
  attributeFilter: ["dir", "lang"]
});
function registerTranslation(...z) {
  z.map((D) => {
    const O = D.$code.toLowerCase();
    translations.has(O) ? translations.set(O, Object.assign(Object.assign({}, translations.get(O)), D)) : translations.set(O, D), fallback || (fallback = D);
  }), update();
}
function update() {
  documentDirection = document.documentElement.dir || "ltr", documentLanguage = document.documentElement.lang || navigator.language, [...connectedElements.keys()].map((z) => {
    typeof z.requestUpdate == "function" && z.requestUpdate();
  });
}
let LocalizeController$1 = class {
  constructor(D) {
    this.host = D, this.host.addController(this);
  }
  hostConnected() {
    connectedElements.add(this.host);
  }
  hostDisconnected() {
    connectedElements.delete(this.host);
  }
  dir() {
    return `${this.host.dir || documentDirection}`.toLowerCase();
  }
  lang() {
    return `${this.host.lang || documentLanguage}`.toLowerCase();
  }
  getTranslationData(D) {
    var O, F;
    const U = new Intl.Locale(D.replace(/_/g, "-")), W = U == null ? void 0 : U.language.toLowerCase(), B = (F = (O = U == null ? void 0 : U.region) === null || O === void 0 ? void 0 : O.toLowerCase()) !== null && F !== void 0 ? F : "", K = translations.get(`${W}-${B}`), X = translations.get(W);
    return { locale: U, language: W, region: B, primary: K, secondary: X };
  }
  exists(D, O) {
    var F;
    const { primary: U, secondary: W } = this.getTranslationData((F = O.lang) !== null && F !== void 0 ? F : this.lang());
    return O = Object.assign({ includeFallback: !1 }, O), !!(U && U[D] || W && W[D] || O.includeFallback && fallback && fallback[D]);
  }
  term(D, ...O) {
    const { primary: F, secondary: U } = this.getTranslationData(this.lang());
    let W;
    if (F && F[D])
      W = F[D];
    else if (U && U[D])
      W = U[D];
    else if (fallback && fallback[D])
      W = fallback[D];
    else
      return console.error(`No translation found for: ${String(D)}`), String(D);
    return typeof W == "function" ? W(...O) : W;
  }
  date(D, O) {
    return D = new Date(D), new Intl.DateTimeFormat(this.lang(), O).format(D);
  }
  number(D, O) {
    return D = Number(D), isNaN(D) ? "" : new Intl.NumberFormat(this.lang(), O).format(D);
  }
  relativeTime(D, O, F) {
    return new Intl.RelativeTimeFormat(this.lang(), F).format(D, O);
  }
};
var translation = {
  $code: "en",
  $name: "English",
  $dir: "ltr",
  carousel: "Carousel",
  clearEntry: "Clear entry",
  close: "Close",
  copied: "Copied",
  copy: "Copy",
  currentValue: "Current value",
  error: "Error",
  goToSlide: (z, D) => `Go to slide ${z} of ${D}`,
  hidePassword: "Hide password",
  loading: "Loading",
  nextSlide: "Next slide",
  numOptionsSelected: (z) => z === 0 ? "No options selected" : z === 1 ? "1 option selected" : `${z} options selected`,
  previousSlide: "Previous slide",
  progress: "Progress",
  remove: "Remove",
  resize: "Resize",
  scrollToEnd: "Scroll to end",
  scrollToStart: "Scroll to start",
  selectAColorFromTheScreen: "Select a color from the screen",
  showPassword: "Show password",
  slideNum: (z) => `Slide ${z}`,
  toggleColorFormat: "Toggle color format"
};
registerTranslation(translation);
var en_default = translation, LocalizeController = class extends LocalizeController$1 {
};
registerTranslation(en_default);
var SlSpinner = class extends ShoelaceElement {
  constructor() {
    super(...arguments), this.localize = new LocalizeController(this);
  }
  render() {
    return x`
      <svg part="base" class="spinner" role="progressbar" aria-label=${this.localize.term("loading")}>
        <circle class="spinner__track"></circle>
        <circle class="spinner__indicator"></circle>
      </svg>
    `;
  }
};
SlSpinner.styles = [component_styles_default, spinner_styles_default];
var defaultAnimationRegistry = /* @__PURE__ */ new Map(), customAnimationRegistry = /* @__PURE__ */ new WeakMap();
function ensureAnimation(z) {
  return z ?? { keyframes: [], options: { duration: 0 } };
}
function getLogicalAnimation(z, D) {
  return D.toLowerCase() === "rtl" ? {
    keyframes: z.rtlKeyframes || z.keyframes,
    options: z.options
  } : z;
}
function setDefaultAnimation(z, D) {
  defaultAnimationRegistry.set(z, ensureAnimation(D));
}
function getAnimation(z, D, O) {
  const F = customAnimationRegistry.get(z);
  if (F != null && F[D])
    return getLogicalAnimation(F[D], O.dir);
  const U = defaultAnimationRegistry.get(D);
  return U ? getLogicalAnimation(U, O.dir) : {
    keyframes: [],
    options: { duration: 0 }
  };
}
function animateTo(z, D, O) {
  return new Promise((F) => {
    if ((O == null ? void 0 : O.duration) === 1 / 0)
      throw new Error("Promise-based animations must be finite.");
    const U = z.animate(D, __spreadProps(__spreadValues({}, O), {
      duration: prefersReducedMotion() ? 0 : O.duration
    }));
    U.addEventListener("cancel", F, { once: !0 }), U.addEventListener("finish", F, { once: !0 });
  });
}
function parseDuration(z) {
  return z = z.toString().toLowerCase(), z.indexOf("ms") > -1 ? parseFloat(z) : z.indexOf("s") > -1 ? parseFloat(z) * 1e3 : parseFloat(z);
}
function prefersReducedMotion() {
  return window.matchMedia("(prefers-reduced-motion: reduce)").matches;
}
function stopAnimations(z) {
  return Promise.all(
    z.getAnimations().map((D) => new Promise((O) => {
      D.cancel(), requestAnimationFrame(O);
    }))
  );
}
function shimKeyframesHeightAuto(z, D) {
  return z.map((O) => __spreadProps(__spreadValues({}, O), {
    height: O.height === "auto" ? `${D}px` : O.height
  }));
}
/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
function n$3(z, D, O) {
  return z ? D(z) : O == null ? void 0 : O(z);
}
var _SlTreeItem = class ut extends ShoelaceElement {
  constructor() {
    super(...arguments), this.localize = new LocalizeController(this), this.indeterminate = !1, this.isLeaf = !1, this.loading = !1, this.selectable = !1, this.expanded = !1, this.selected = !1, this.disabled = !1, this.lazy = !1;
  }
  static isTreeItem(D) {
    return D instanceof Element && D.getAttribute("role") === "treeitem";
  }
  connectedCallback() {
    super.connectedCallback(), this.setAttribute("role", "treeitem"), this.setAttribute("tabindex", "-1"), this.isNestedItem() && (this.slot = "children");
  }
  firstUpdated() {
    this.childrenContainer.hidden = !this.expanded, this.childrenContainer.style.height = this.expanded ? "auto" : "0", this.isLeaf = !this.lazy && this.getChildrenItems().length === 0, this.handleExpandedChange();
  }
  async animateCollapse() {
    this.emit("sl-collapse"), await stopAnimations(this.childrenContainer);
    const { keyframes: D, options: O } = getAnimation(this, "tree-item.collapse", { dir: this.localize.dir() });
    await animateTo(
      this.childrenContainer,
      shimKeyframesHeightAuto(D, this.childrenContainer.scrollHeight),
      O
    ), this.childrenContainer.hidden = !0, this.emit("sl-after-collapse");
  }
  // Checks whether the item is nested into an item
  isNestedItem() {
    const D = this.parentElement;
    return !!D && ut.isTreeItem(D);
  }
  handleChildrenSlotChange() {
    this.loading = !1, this.isLeaf = !this.lazy && this.getChildrenItems().length === 0;
  }
  willUpdate(D) {
    D.has("selected") && !D.has("indeterminate") && (this.indeterminate = !1);
  }
  async animateExpand() {
    this.emit("sl-expand"), await stopAnimations(this.childrenContainer), this.childrenContainer.hidden = !1;
    const { keyframes: D, options: O } = getAnimation(this, "tree-item.expand", { dir: this.localize.dir() });
    await animateTo(
      this.childrenContainer,
      shimKeyframesHeightAuto(D, this.childrenContainer.scrollHeight),
      O
    ), this.childrenContainer.style.height = "auto", this.emit("sl-after-expand");
  }
  handleLoadingChange() {
    this.setAttribute("aria-busy", this.loading ? "true" : "false"), this.loading || this.animateExpand();
  }
  handleDisabledChange() {
    this.setAttribute("aria-disabled", this.disabled ? "true" : "false");
  }
  handleSelectedChange() {
    this.setAttribute("aria-selected", this.selected ? "true" : "false");
  }
  handleExpandedChange() {
    this.isLeaf ? this.removeAttribute("aria-expanded") : this.setAttribute("aria-expanded", this.expanded ? "true" : "false");
  }
  handleExpandAnimation() {
    this.expanded ? this.lazy ? (this.loading = !0, this.emit("sl-lazy-load")) : this.animateExpand() : this.animateCollapse();
  }
  handleLazyChange() {
    this.emit("sl-lazy-change");
  }
  /** Gets all the nested tree items in this node. */
  getChildrenItems({ includeDisabled: D = !0 } = {}) {
    return this.childrenSlot ? [...this.childrenSlot.assignedElements({ flatten: !0 })].filter(
      (O) => ut.isTreeItem(O) && (D || !O.disabled)
    ) : [];
  }
  render() {
    const D = this.localize.dir() === "rtl", O = !this.loading && (!this.isLeaf || this.lazy);
    return x`
      <div
        part="base"
        class="${e$2({
      "tree-item": !0,
      "tree-item--expanded": this.expanded,
      "tree-item--selected": this.selected,
      "tree-item--disabled": this.disabled,
      "tree-item--leaf": this.isLeaf,
      "tree-item--has-expand-button": O,
      "tree-item--rtl": this.localize.dir() === "rtl"
    })}"
      >
        <div
          class="tree-item__item"
          part="
            item
            ${this.disabled ? "item--disabled" : ""}
            ${this.expanded ? "item--expanded" : ""}
            ${this.indeterminate ? "item--indeterminate" : ""}
            ${this.selected ? "item--selected" : ""}
          "
        >
          <div class="tree-item__indentation" part="indentation"></div>

          <div
            part="expand-button"
            class=${e$2({
      "tree-item__expand-button": !0,
      "tree-item__expand-button--visible": O
    })}
            aria-hidden="true"
          >
            ${n$3(
      this.loading,
      () => x` <sl-spinner part="spinner" exportparts="base:spinner__base"></sl-spinner> `
    )}
            <slot class="tree-item__expand-icon-slot" name="expand-icon">
              <sl-icon library="system" name=${D ? "chevron-left" : "chevron-right"}></sl-icon>
            </slot>
            <slot class="tree-item__expand-icon-slot" name="collapse-icon">
              <sl-icon library="system" name=${D ? "chevron-left" : "chevron-right"}></sl-icon>
            </slot>
          </div>

          ${n$3(
      this.selectable,
      () => x`
              <sl-checkbox
                part="checkbox"
                exportparts="
                    base:checkbox__base,
                    control:checkbox__control,
                    control--checked:checkbox__control--checked,
                    control--indeterminate:checkbox__control--indeterminate,
                    checked-icon:checkbox__checked-icon,
                    indeterminate-icon:checkbox__indeterminate-icon,
                    label:checkbox__label
                  "
                class="tree-item__checkbox"
                ?disabled="${this.disabled}"
                ?checked="${l$1(this.selected)}"
                ?indeterminate="${this.indeterminate}"
                tabindex="-1"
              ></sl-checkbox>
            `
    )}

          <slot class="tree-item__label" part="label"></slot>
        </div>

        <div class="tree-item__children" part="children" role="group">
          <slot name="children" @slotchange="${this.handleChildrenSlotChange}"></slot>
        </div>
      </div>
    `;
  }
};
_SlTreeItem.styles = [component_styles_default, tree_item_styles_default];
_SlTreeItem.dependencies = {
  "sl-checkbox": SlCheckbox,
  "sl-icon": SlIcon,
  "sl-spinner": SlSpinner
};
__decorateClass([
  r$4()
], _SlTreeItem.prototype, "indeterminate", 2);
__decorateClass([
  r$4()
], _SlTreeItem.prototype, "isLeaf", 2);
__decorateClass([
  r$4()
], _SlTreeItem.prototype, "loading", 2);
__decorateClass([
  r$4()
], _SlTreeItem.prototype, "selectable", 2);
__decorateClass([
  n$6({ type: Boolean, reflect: !0 })
], _SlTreeItem.prototype, "expanded", 2);
__decorateClass([
  n$6({ type: Boolean, reflect: !0 })
], _SlTreeItem.prototype, "selected", 2);
__decorateClass([
  n$6({ type: Boolean, reflect: !0 })
], _SlTreeItem.prototype, "disabled", 2);
__decorateClass([
  n$6({ type: Boolean, reflect: !0 })
], _SlTreeItem.prototype, "lazy", 2);
__decorateClass([
  e$b("slot:not([name])")
], _SlTreeItem.prototype, "defaultSlot", 2);
__decorateClass([
  e$b("slot[name=children]")
], _SlTreeItem.prototype, "childrenSlot", 2);
__decorateClass([
  e$b(".tree-item__item")
], _SlTreeItem.prototype, "itemElement", 2);
__decorateClass([
  e$b(".tree-item__children")
], _SlTreeItem.prototype, "childrenContainer", 2);
__decorateClass([
  e$b(".tree-item__expand-button slot")
], _SlTreeItem.prototype, "expandButtonSlot", 2);
__decorateClass([
  watch("loading", { waitUntilFirstUpdate: !0 })
], _SlTreeItem.prototype, "handleLoadingChange", 1);
__decorateClass([
  watch("disabled")
], _SlTreeItem.prototype, "handleDisabledChange", 1);
__decorateClass([
  watch("selected")
], _SlTreeItem.prototype, "handleSelectedChange", 1);
__decorateClass([
  watch("expanded", { waitUntilFirstUpdate: !0 })
], _SlTreeItem.prototype, "handleExpandedChange", 1);
__decorateClass([
  watch("expanded", { waitUntilFirstUpdate: !0 })
], _SlTreeItem.prototype, "handleExpandAnimation", 1);
__decorateClass([
  watch("lazy", { waitUntilFirstUpdate: !0 })
], _SlTreeItem.prototype, "handleLazyChange", 1);
var SlTreeItem = _SlTreeItem;
setDefaultAnimation("tree-item.expand", {
  keyframes: [
    { height: "0", opacity: "0", overflow: "hidden" },
    { height: "auto", opacity: "1", overflow: "hidden" }
  ],
  options: { duration: 250, easing: "cubic-bezier(0.4, 0.0, 0.2, 1)" }
});
setDefaultAnimation("tree-item.collapse", {
  keyframes: [
    { height: "auto", opacity: "1", overflow: "hidden" },
    { height: "0", opacity: "0", overflow: "hidden" }
  ],
  options: { duration: 200, easing: "cubic-bezier(0.4, 0.0, 0.2, 1)" }
});
function clamp$1(z, D, O) {
  const F = (U) => Object.is(U, -0) ? 0 : U;
  return z < D ? F(D) : z > O ? F(O) : F(z);
}
function syncCheckboxes(z, D = !1) {
  function O(W) {
    const B = W.getChildrenItems({ includeDisabled: !1 });
    if (B.length) {
      const K = B.every((Y) => Y.selected), X = B.every((Y) => !Y.selected && !Y.indeterminate);
      W.selected = K, W.indeterminate = !K && !X;
    }
  }
  function F(W) {
    const B = W.parentElement;
    SlTreeItem.isTreeItem(B) && (O(B), F(B));
  }
  function U(W) {
    for (const B of W.getChildrenItems())
      B.selected = D ? W.selected || B.selected : !B.disabled && W.selected, U(B);
    D && O(W);
  }
  U(z), F(z);
}
var SlTree = class extends ShoelaceElement {
  constructor() {
    super(), this.selection = "single", this.localize = new LocalizeController(this), this.clickTarget = null, this.initTreeItem = (z) => {
      z.selectable = this.selection === "multiple", ["expand", "collapse"].filter((D) => !!this.querySelector(`[slot="${D}-icon"]`)).forEach((D) => {
        const O = z.querySelector(`[slot="${D}-icon"]`), F = this.getExpandButtonIcon(D);
        F && (O === null ? z.append(F) : O.hasAttribute("data-default") && O.replaceWith(F));
      });
    }, this.handleTreeChanged = (z) => {
      for (const D of z) {
        const O = [...D.addedNodes].filter(SlTreeItem.isTreeItem), F = [...D.removedNodes].filter(SlTreeItem.isTreeItem);
        O.forEach(this.initTreeItem), this.lastFocusedItem && F.includes(this.lastFocusedItem) && (this.lastFocusedItem = null);
      }
    }, this.handleFocusOut = (z) => {
      const D = z.relatedTarget;
      (!D || !this.contains(D)) && (this.tabIndex = 0);
    }, this.handleFocusIn = (z) => {
      const D = z.target;
      z.target === this && this.focusItem(this.lastFocusedItem || this.getAllTreeItems()[0]), SlTreeItem.isTreeItem(D) && !D.disabled && (this.lastFocusedItem && (this.lastFocusedItem.tabIndex = -1), this.lastFocusedItem = D, this.tabIndex = -1, D.tabIndex = 0);
    }, this.addEventListener("focusin", this.handleFocusIn), this.addEventListener("focusout", this.handleFocusOut), this.addEventListener("sl-lazy-change", this.handleSlotChange);
  }
  async connectedCallback() {
    super.connectedCallback(), this.setAttribute("role", "tree"), this.setAttribute("tabindex", "0"), await this.updateComplete, this.mutationObserver = new MutationObserver(this.handleTreeChanged), this.mutationObserver.observe(this, { childList: !0, subtree: !0 });
  }
  disconnectedCallback() {
    super.disconnectedCallback(), this.mutationObserver.disconnect();
  }
  // Generates a clone of the expand icon element to use for each tree item
  getExpandButtonIcon(z) {
    const O = (z === "expand" ? this.expandedIconSlot : this.collapsedIconSlot).assignedElements({ flatten: !0 })[0];
    if (O) {
      const F = O.cloneNode(!0);
      return [F, ...F.querySelectorAll("[id]")].forEach((U) => U.removeAttribute("id")), F.setAttribute("data-default", ""), F.slot = `${z}-icon`, F;
    }
    return null;
  }
  selectItem(z) {
    const D = [...this.selectedItems];
    if (this.selection === "multiple")
      z.selected = !z.selected, z.lazy && (z.expanded = !0), syncCheckboxes(z);
    else if (this.selection === "single" || z.isLeaf) {
      const F = this.getAllTreeItems();
      for (const U of F)
        U.selected = U === z;
    } else
      this.selection === "leaf" && (z.expanded = !z.expanded);
    const O = this.selectedItems;
    (D.length !== O.length || O.some((F) => !D.includes(F))) && Promise.all(O.map((F) => F.updateComplete)).then(() => {
      this.emit("sl-selection-change", { detail: { selection: O } });
    });
  }
  getAllTreeItems() {
    return [...this.querySelectorAll("sl-tree-item")];
  }
  focusItem(z) {
    z == null || z.focus();
  }
  handleKeyDown(z) {
    if (!["ArrowDown", "ArrowUp", "ArrowRight", "ArrowLeft", "Home", "End", "Enter", " "].includes(z.key) || z.composedPath().some((U) => {
      var W;
      return ["input", "textarea"].includes((W = U == null ? void 0 : U.tagName) == null ? void 0 : W.toLowerCase());
    }))
      return;
    const D = this.getFocusableItems(), O = this.localize.dir() === "ltr", F = this.localize.dir() === "rtl";
    if (D.length > 0) {
      z.preventDefault();
      const U = D.findIndex((X) => X.matches(":focus")), W = D[U], B = (X) => {
        const Y = D[clamp$1(X, 0, D.length - 1)];
        this.focusItem(Y);
      }, K = (X) => {
        W.expanded = X;
      };
      z.key === "ArrowDown" ? B(U + 1) : z.key === "ArrowUp" ? B(U - 1) : O && z.key === "ArrowRight" || F && z.key === "ArrowLeft" ? !W || W.disabled || W.expanded || W.isLeaf && !W.lazy ? B(U + 1) : K(!0) : O && z.key === "ArrowLeft" || F && z.key === "ArrowRight" ? !W || W.disabled || W.isLeaf || !W.expanded ? B(U - 1) : K(!1) : z.key === "Home" ? B(0) : z.key === "End" ? B(D.length - 1) : (z.key === "Enter" || z.key === " ") && (W.disabled || this.selectItem(W));
    }
  }
  handleClick(z) {
    const D = z.target, O = D.closest("sl-tree-item"), F = z.composedPath().some((U) => {
      var W;
      return (W = U == null ? void 0 : U.classList) == null ? void 0 : W.contains("tree-item__expand-button");
    });
    !O || O.disabled || D !== this.clickTarget || (F ? O.expanded = !O.expanded : this.selectItem(O));
  }
  handleMouseDown(z) {
    this.clickTarget = z.target;
  }
  handleSlotChange() {
    this.getAllTreeItems().forEach(this.initTreeItem);
  }
  async handleSelectionChange() {
    const z = this.selection === "multiple", D = this.getAllTreeItems();
    this.setAttribute("aria-multiselectable", z ? "true" : "false");
    for (const O of D)
      O.selectable = z;
    z && (await this.updateComplete, [...this.querySelectorAll(":scope > sl-tree-item")].forEach(
      (O) => syncCheckboxes(O, !0)
    ));
  }
  /** @internal Returns the list of tree items that are selected in the tree. */
  get selectedItems() {
    const z = this.getAllTreeItems(), D = (O) => O.selected;
    return z.filter(D);
  }
  /** @internal Gets focusable tree items in the tree. */
  getFocusableItems() {
    const z = this.getAllTreeItems(), D = /* @__PURE__ */ new Set();
    return z.filter((O) => {
      var F;
      if (O.disabled)
        return !1;
      const U = (F = O.parentElement) == null ? void 0 : F.closest("[role=treeitem]");
      return U && (!U.expanded || U.loading || D.has(U)) && D.add(O), !D.has(O);
    });
  }
  render() {
    return x`
      <div
        part="base"
        class="tree"
        @click=${this.handleClick}
        @keydown=${this.handleKeyDown}
        @mousedown=${this.handleMouseDown}
      >
        <slot @slotchange=${this.handleSlotChange}></slot>
        <span hidden aria-hidden="true"><slot name="expand-icon"></slot></span>
        <span hidden aria-hidden="true"><slot name="collapse-icon"></slot></span>
      </div>
    `;
  }
};
SlTree.styles = [component_styles_default, tree_styles_default];
__decorateClass([
  e$b("slot:not([name])")
], SlTree.prototype, "defaultSlot", 2);
__decorateClass([
  e$b("slot[name=expand-icon]")
], SlTree.prototype, "expandedIconSlot", 2);
__decorateClass([
  e$b("slot[name=collapse-icon]")
], SlTree.prototype, "collapsedIconSlot", 2);
__decorateClass([
  n$6()
], SlTree.prototype, "selection", 2);
__decorateClass([
  watch("selection")
], SlTree.prototype, "handleSelectionChange", 1);
SlTree.define("sl-tree");
SlTreeItem.define("sl-tree-item");
var textarea_styles_default = i$7`
  :host {
    display: block;
  }

  .textarea {
    display: flex;
    align-items: center;
    position: relative;
    width: 100%;
    font-family: var(--sl-input-font-family);
    font-weight: var(--sl-input-font-weight);
    line-height: var(--sl-line-height-normal);
    letter-spacing: var(--sl-input-letter-spacing);
    vertical-align: middle;
    transition:
      var(--sl-transition-fast) color,
      var(--sl-transition-fast) border,
      var(--sl-transition-fast) box-shadow,
      var(--sl-transition-fast) background-color;
    cursor: text;
  }

  /* Standard textareas */
  .textarea--standard {
    background-color: var(--sl-input-background-color);
    border: solid var(--sl-input-border-width) var(--sl-input-border-color);
  }

  .textarea--standard:hover:not(.textarea--disabled) {
    background-color: var(--sl-input-background-color-hover);
    border-color: var(--sl-input-border-color-hover);
  }
  .textarea--standard:hover:not(.textarea--disabled) .textarea__control {
    color: var(--sl-input-color-hover);
  }

  .textarea--standard.textarea--focused:not(.textarea--disabled) {
    background-color: var(--sl-input-background-color-focus);
    border-color: var(--sl-input-border-color-focus);
    color: var(--sl-input-color-focus);
    box-shadow: 0 0 0 var(--sl-focus-ring-width) var(--sl-input-focus-ring-color);
  }

  .textarea--standard.textarea--focused:not(.textarea--disabled) .textarea__control {
    color: var(--sl-input-color-focus);
  }

  .textarea--standard.textarea--disabled {
    background-color: var(--sl-input-background-color-disabled);
    border-color: var(--sl-input-border-color-disabled);
    opacity: 0.5;
    cursor: not-allowed;
  }

  .textarea--standard.textarea--disabled .textarea__control {
    color: var(--sl-input-color-disabled);
  }

  .textarea--standard.textarea--disabled .textarea__control::placeholder {
    color: var(--sl-input-placeholder-color-disabled);
  }

  /* Filled textareas */
  .textarea--filled {
    border: none;
    background-color: var(--sl-input-filled-background-color);
    color: var(--sl-input-color);
  }

  .textarea--filled:hover:not(.textarea--disabled) {
    background-color: var(--sl-input-filled-background-color-hover);
  }

  .textarea--filled.textarea--focused:not(.textarea--disabled) {
    background-color: var(--sl-input-filled-background-color-focus);
    outline: var(--sl-focus-ring);
    outline-offset: var(--sl-focus-ring-offset);
  }

  .textarea--filled.textarea--disabled {
    background-color: var(--sl-input-filled-background-color-disabled);
    opacity: 0.5;
    cursor: not-allowed;
  }

  .textarea__control {
    flex: 1 1 auto;
    font-family: inherit;
    font-size: inherit;
    font-weight: inherit;
    line-height: 1.4;
    color: var(--sl-input-color);
    border: none;
    background: none;
    box-shadow: none;
    cursor: inherit;
    -webkit-appearance: none;
  }

  .textarea__control::-webkit-search-decoration,
  .textarea__control::-webkit-search-cancel-button,
  .textarea__control::-webkit-search-results-button,
  .textarea__control::-webkit-search-results-decoration {
    -webkit-appearance: none;
  }

  .textarea__control::placeholder {
    color: var(--sl-input-placeholder-color);
    user-select: none;
    -webkit-user-select: none;
  }

  .textarea__control:focus {
    outline: none;
  }

  /*
   * Size modifiers
   */

  .textarea--small {
    border-radius: var(--sl-input-border-radius-small);
    font-size: var(--sl-input-font-size-small);
  }

  .textarea--small .textarea__control {
    padding: 0.5em var(--sl-input-spacing-small);
  }

  .textarea--medium {
    border-radius: var(--sl-input-border-radius-medium);
    font-size: var(--sl-input-font-size-medium);
  }

  .textarea--medium .textarea__control {
    padding: 0.5em var(--sl-input-spacing-medium);
  }

  .textarea--large {
    border-radius: var(--sl-input-border-radius-large);
    font-size: var(--sl-input-font-size-large);
  }

  .textarea--large .textarea__control {
    padding: 0.5em var(--sl-input-spacing-large);
  }

  /*
   * Resize types
   */

  .textarea--resize-none .textarea__control {
    resize: none;
  }

  .textarea--resize-vertical .textarea__control {
    resize: vertical;
  }

  .textarea--resize-auto .textarea__control {
    height: auto;
    resize: none;
    overflow-y: hidden;
  }
`, SlTextarea = class extends ShoelaceElement {
  constructor() {
    super(...arguments), this.formControlController = new FormControlController(this, {
      assumeInteractionOn: ["sl-blur", "sl-input"]
    }), this.hasSlotController = new HasSlotController(this, "help-text", "label"), this.hasFocus = !1, this.title = "", this.name = "", this.value = "", this.size = "medium", this.filled = !1, this.label = "", this.helpText = "", this.placeholder = "", this.rows = 4, this.resize = "vertical", this.disabled = !1, this.readonly = !1, this.form = "", this.required = !1, this.spellcheck = !0, this.defaultValue = "";
  }
  /** Gets the validity state object */
  get validity() {
    return this.input.validity;
  }
  /** Gets the validation message */
  get validationMessage() {
    return this.input.validationMessage;
  }
  connectedCallback() {
    super.connectedCallback(), this.resizeObserver = new ResizeObserver(() => this.setTextareaHeight()), this.updateComplete.then(() => {
      this.setTextareaHeight(), this.resizeObserver.observe(this.input);
    });
  }
  firstUpdated() {
    this.formControlController.updateValidity();
  }
  disconnectedCallback() {
    super.disconnectedCallback(), this.input && this.resizeObserver.unobserve(this.input);
  }
  handleBlur() {
    this.hasFocus = !1, this.emit("sl-blur");
  }
  handleChange() {
    this.value = this.input.value, this.setTextareaHeight(), this.emit("sl-change");
  }
  handleFocus() {
    this.hasFocus = !0, this.emit("sl-focus");
  }
  handleInput() {
    this.value = this.input.value, this.emit("sl-input");
  }
  handleInvalid(z) {
    this.formControlController.setValidity(!1), this.formControlController.emitInvalidEvent(z);
  }
  setTextareaHeight() {
    this.resize === "auto" ? (this.input.style.height = "auto", this.input.style.height = `${this.input.scrollHeight}px`) : this.input.style.height = void 0;
  }
  handleDisabledChange() {
    this.formControlController.setValidity(this.disabled);
  }
  handleRowsChange() {
    this.setTextareaHeight();
  }
  async handleValueChange() {
    await this.updateComplete, this.formControlController.updateValidity(), this.setTextareaHeight();
  }
  /** Sets focus on the textarea. */
  focus(z) {
    this.input.focus(z);
  }
  /** Removes focus from the textarea. */
  blur() {
    this.input.blur();
  }
  /** Selects all the text in the textarea. */
  select() {
    this.input.select();
  }
  /** Gets or sets the textarea's scroll position. */
  scrollPosition(z) {
    if (z) {
      typeof z.top == "number" && (this.input.scrollTop = z.top), typeof z.left == "number" && (this.input.scrollLeft = z.left);
      return;
    }
    return {
      top: this.input.scrollTop,
      left: this.input.scrollTop
    };
  }
  /** Sets the start and end positions of the text selection (0-based). */
  setSelectionRange(z, D, O = "none") {
    this.input.setSelectionRange(z, D, O);
  }
  /** Replaces a range of text with a new string. */
  setRangeText(z, D, O, F = "preserve") {
    const U = D ?? this.input.selectionStart, W = O ?? this.input.selectionEnd;
    this.input.setRangeText(z, U, W, F), this.value !== this.input.value && (this.value = this.input.value, this.setTextareaHeight());
  }
  /** Checks for validity but does not show a validation message. Returns `true` when valid and `false` when invalid. */
  checkValidity() {
    return this.input.checkValidity();
  }
  /** Gets the associated form, if one exists. */
  getForm() {
    return this.formControlController.getForm();
  }
  /** Checks for validity and shows the browser's validation message if the control is invalid. */
  reportValidity() {
    return this.input.reportValidity();
  }
  /** Sets a custom validation message. Pass an empty string to restore validity. */
  setCustomValidity(z) {
    this.input.setCustomValidity(z), this.formControlController.updateValidity();
  }
  render() {
    const z = this.hasSlotController.test("label"), D = this.hasSlotController.test("help-text"), O = this.label ? !0 : !!z, F = this.helpText ? !0 : !!D;
    return x`
      <div
        part="form-control"
        class=${e$2({
      "form-control": !0,
      "form-control--small": this.size === "small",
      "form-control--medium": this.size === "medium",
      "form-control--large": this.size === "large",
      "form-control--has-label": O,
      "form-control--has-help-text": F
    })}
      >
        <label
          part="form-control-label"
          class="form-control__label"
          for="input"
          aria-hidden=${O ? "false" : "true"}
        >
          <slot name="label">${this.label}</slot>
        </label>

        <div part="form-control-input" class="form-control-input">
          <div
            part="base"
            class=${e$2({
      textarea: !0,
      "textarea--small": this.size === "small",
      "textarea--medium": this.size === "medium",
      "textarea--large": this.size === "large",
      "textarea--standard": !this.filled,
      "textarea--filled": this.filled,
      "textarea--disabled": this.disabled,
      "textarea--focused": this.hasFocus,
      "textarea--empty": !this.value,
      "textarea--resize-none": this.resize === "none",
      "textarea--resize-vertical": this.resize === "vertical",
      "textarea--resize-auto": this.resize === "auto"
    })}
          >
            <textarea
              part="textarea"
              id="input"
              class="textarea__control"
              title=${this.title}
              name=${o$6(this.name)}
              .value=${l$1(this.value)}
              ?disabled=${this.disabled}
              ?readonly=${this.readonly}
              ?required=${this.required}
              placeholder=${o$6(this.placeholder)}
              rows=${o$6(this.rows)}
              minlength=${o$6(this.minlength)}
              maxlength=${o$6(this.maxlength)}
              autocapitalize=${o$6(this.autocapitalize)}
              autocorrect=${o$6(this.autocorrect)}
              ?autofocus=${this.autofocus}
              spellcheck=${o$6(this.spellcheck)}
              enterkeyhint=${o$6(this.enterkeyhint)}
              inputmode=${o$6(this.inputmode)}
              aria-describedby="help-text"
              @change=${this.handleChange}
              @input=${this.handleInput}
              @invalid=${this.handleInvalid}
              @focus=${this.handleFocus}
              @blur=${this.handleBlur}
            ></textarea>
          </div>
        </div>

        <div
          part="form-control-help-text"
          id="help-text"
          class="form-control__help-text"
          aria-hidden=${F ? "false" : "true"}
        >
          <slot name="help-text">${this.helpText}</slot>
        </div>
      </div>
    `;
  }
};
SlTextarea.styles = [component_styles_default, form_control_styles_default, textarea_styles_default];
__decorateClass([
  e$b(".textarea__control")
], SlTextarea.prototype, "input", 2);
__decorateClass([
  r$4()
], SlTextarea.prototype, "hasFocus", 2);
__decorateClass([
  n$6()
], SlTextarea.prototype, "title", 2);
__decorateClass([
  n$6()
], SlTextarea.prototype, "name", 2);
__decorateClass([
  n$6()
], SlTextarea.prototype, "value", 2);
__decorateClass([
  n$6({ reflect: !0 })
], SlTextarea.prototype, "size", 2);
__decorateClass([
  n$6({ type: Boolean, reflect: !0 })
], SlTextarea.prototype, "filled", 2);
__decorateClass([
  n$6()
], SlTextarea.prototype, "label", 2);
__decorateClass([
  n$6({ attribute: "help-text" })
], SlTextarea.prototype, "helpText", 2);
__decorateClass([
  n$6()
], SlTextarea.prototype, "placeholder", 2);
__decorateClass([
  n$6({ type: Number })
], SlTextarea.prototype, "rows", 2);
__decorateClass([
  n$6()
], SlTextarea.prototype, "resize", 2);
__decorateClass([
  n$6({ type: Boolean, reflect: !0 })
], SlTextarea.prototype, "disabled", 2);
__decorateClass([
  n$6({ type: Boolean, reflect: !0 })
], SlTextarea.prototype, "readonly", 2);
__decorateClass([
  n$6({ reflect: !0 })
], SlTextarea.prototype, "form", 2);
__decorateClass([
  n$6({ type: Boolean, reflect: !0 })
], SlTextarea.prototype, "required", 2);
__decorateClass([
  n$6({ type: Number })
], SlTextarea.prototype, "minlength", 2);
__decorateClass([
  n$6({ type: Number })
], SlTextarea.prototype, "maxlength", 2);
__decorateClass([
  n$6()
], SlTextarea.prototype, "autocapitalize", 2);
__decorateClass([
  n$6()
], SlTextarea.prototype, "autocorrect", 2);
__decorateClass([
  n$6()
], SlTextarea.prototype, "autocomplete", 2);
__decorateClass([
  n$6({ type: Boolean })
], SlTextarea.prototype, "autofocus", 2);
__decorateClass([
  n$6()
], SlTextarea.prototype, "enterkeyhint", 2);
__decorateClass([
  n$6({
    type: Boolean,
    converter: {
      // Allow "true|false" attribute values but keep the property boolean
      fromAttribute: (z) => !(!z || z === "false"),
      toAttribute: (z) => z ? "true" : "false"
    }
  })
], SlTextarea.prototype, "spellcheck", 2);
__decorateClass([
  n$6()
], SlTextarea.prototype, "inputmode", 2);
__decorateClass([
  defaultValue()
], SlTextarea.prototype, "defaultValue", 2);
__decorateClass([
  watch("disabled", { waitUntilFirstUpdate: !0 })
], SlTextarea.prototype, "handleDisabledChange", 1);
__decorateClass([
  watch("rows", { waitUntilFirstUpdate: !0 })
], SlTextarea.prototype, "handleRowsChange", 1);
__decorateClass([
  watch("value", { waitUntilFirstUpdate: !0 })
], SlTextarea.prototype, "handleValueChange", 1);
SlTextarea.define("sl-textarea");
var visually_hidden_styles_default = i$7`
  :host(:not(:focus-within)) {
    position: absolute !important;
    width: 1px !important;
    height: 1px !important;
    clip: rect(0 0 0 0) !important;
    clip-path: inset(50%) !important;
    border: none !important;
    overflow: hidden !important;
    white-space: nowrap !important;
    padding: 0 !important;
  }
`, SlVisuallyHidden = class extends ShoelaceElement {
  render() {
    return x` <slot></slot> `;
  }
};
SlVisuallyHidden.styles = [component_styles_default, visually_hidden_styles_default];
SlVisuallyHidden.define("sl-visually-hidden");
var tab_panel_styles_default = i$7`
  :host {
    --padding: 0;

    display: none;
  }

  :host([active]) {
    display: block;
  }

  .tab-panel {
    display: block;
    padding: var(--padding);
  }
`, id$1 = 0, SlTabPanel = class extends ShoelaceElement {
  constructor() {
    super(...arguments), this.attrId = ++id$1, this.componentId = `sl-tab-panel-${this.attrId}`, this.name = "", this.active = !1;
  }
  connectedCallback() {
    super.connectedCallback(), this.id = this.id.length > 0 ? this.id : this.componentId, this.setAttribute("role", "tabpanel");
  }
  handleActiveChange() {
    this.setAttribute("aria-hidden", this.active ? "false" : "true");
  }
  render() {
    return x`
      <slot
        part="base"
        class=${e$2({
      "tab-panel": !0,
      "tab-panel--active": this.active
    })}
      ></slot>
    `;
  }
};
SlTabPanel.styles = [component_styles_default, tab_panel_styles_default];
__decorateClass([
  n$6({ reflect: !0 })
], SlTabPanel.prototype, "name", 2);
__decorateClass([
  n$6({ type: Boolean, reflect: !0 })
], SlTabPanel.prototype, "active", 2);
__decorateClass([
  watch("active")
], SlTabPanel.prototype, "handleActiveChange", 1);
SlTabPanel.define("sl-tab-panel");
var tag_styles_default = i$7`
  :host {
    display: inline-block;
  }

  .tag {
    display: flex;
    align-items: center;
    border: solid 1px;
    line-height: 1;
    white-space: nowrap;
    user-select: none;
    -webkit-user-select: none;
  }

  .tag__remove::part(base) {
    color: inherit;
    padding: 0;
  }

  /*
   * Variant modifiers
   */

  .tag--primary {
    background-color: var(--sl-color-primary-50);
    border-color: var(--sl-color-primary-200);
    color: var(--sl-color-primary-800);
  }

  .tag--primary:active > sl-icon-button {
    color: var(--sl-color-primary-600);
  }

  .tag--success {
    background-color: var(--sl-color-success-50);
    border-color: var(--sl-color-success-200);
    color: var(--sl-color-success-800);
  }

  .tag--success:active > sl-icon-button {
    color: var(--sl-color-success-600);
  }

  .tag--neutral {
    background-color: var(--sl-color-neutral-50);
    border-color: var(--sl-color-neutral-200);
    color: var(--sl-color-neutral-800);
  }

  .tag--neutral:active > sl-icon-button {
    color: var(--sl-color-neutral-600);
  }

  .tag--warning {
    background-color: var(--sl-color-warning-50);
    border-color: var(--sl-color-warning-200);
    color: var(--sl-color-warning-800);
  }

  .tag--warning:active > sl-icon-button {
    color: var(--sl-color-warning-600);
  }

  .tag--danger {
    background-color: var(--sl-color-danger-50);
    border-color: var(--sl-color-danger-200);
    color: var(--sl-color-danger-800);
  }

  .tag--danger:active > sl-icon-button {
    color: var(--sl-color-danger-600);
  }

  /*
   * Size modifiers
   */

  .tag--small {
    font-size: var(--sl-button-font-size-small);
    height: calc(var(--sl-input-height-small) * 0.8);
    line-height: calc(var(--sl-input-height-small) - var(--sl-input-border-width) * 2);
    border-radius: var(--sl-input-border-radius-small);
    padding: 0 var(--sl-spacing-x-small);
  }

  .tag--medium {
    font-size: var(--sl-button-font-size-medium);
    height: calc(var(--sl-input-height-medium) * 0.8);
    line-height: calc(var(--sl-input-height-medium) - var(--sl-input-border-width) * 2);
    border-radius: var(--sl-input-border-radius-medium);
    padding: 0 var(--sl-spacing-small);
  }

  .tag--large {
    font-size: var(--sl-button-font-size-large);
    height: calc(var(--sl-input-height-large) * 0.8);
    line-height: calc(var(--sl-input-height-large) - var(--sl-input-border-width) * 2);
    border-radius: var(--sl-input-border-radius-large);
    padding: 0 var(--sl-spacing-medium);
  }

  .tag__remove {
    margin-inline-start: var(--sl-spacing-x-small);
  }

  /*
   * Pill modifier
   */

  .tag--pill {
    border-radius: var(--sl-border-radius-pill);
  }
`, icon_button_styles_default = i$7`
  :host {
    display: inline-block;
    color: var(--sl-color-neutral-600);
  }

  .icon-button {
    flex: 0 0 auto;
    display: flex;
    align-items: center;
    background: none;
    border: none;
    border-radius: var(--sl-border-radius-medium);
    font-size: inherit;
    color: inherit;
    padding: var(--sl-spacing-x-small);
    cursor: pointer;
    transition: var(--sl-transition-x-fast) color;
    -webkit-appearance: none;
  }

  .icon-button:hover:not(.icon-button--disabled),
  .icon-button:focus-visible:not(.icon-button--disabled) {
    color: var(--sl-color-primary-600);
  }

  .icon-button:active:not(.icon-button--disabled) {
    color: var(--sl-color-primary-700);
  }

  .icon-button:focus {
    outline: none;
  }

  .icon-button--disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }

  .icon-button:focus-visible {
    outline: var(--sl-focus-ring);
    outline-offset: var(--sl-focus-ring-offset);
  }

  .icon-button__icon {
    pointer-events: none;
  }
`;
/**
 * @license
 * Copyright 2020 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const e$1 = Symbol.for(""), o$5 = (z) => {
  if ((z == null ? void 0 : z.r) === e$1)
    return z == null ? void 0 : z._$litStatic$;
}, s = (z, ...D) => ({ _$litStatic$: D.reduce((O, F, U) => O + ((W) => {
  if (W._$litStatic$ !== void 0)
    return W._$litStatic$;
  throw Error(`Value passed to 'literal' function must be a 'literal' result: ${W}. Use 'unsafeStatic' to pass non-literal values, but
            take care to ensure page security.`);
})(F) + z[U + 1], z[0]), r: e$1 }), a = /* @__PURE__ */ new Map(), l = (z) => (D, ...O) => {
  const F = O.length;
  let U, W;
  const B = [], K = [];
  let X, Y = 0, Q = !1;
  for (; Y < F; ) {
    for (X = D[Y]; Y < F && (W = O[Y], (U = o$5(W)) !== void 0); )
      X += U + D[++Y], Q = !0;
    Y !== F && K.push(W), B.push(X), Y++;
  }
  if (Y === F && B.push(D[F]), Q) {
    const J = B.join("$$lit$$");
    (D = a.get(J)) === void 0 && (B.raw = B, a.set(J, D = B)), O = K;
  }
  return z(D, ...O);
}, n$2 = l(x);
var SlIconButton = class extends ShoelaceElement {
  constructor() {
    super(...arguments), this.hasFocus = !1, this.label = "", this.disabled = !1;
  }
  handleBlur() {
    this.hasFocus = !1, this.emit("sl-blur");
  }
  handleFocus() {
    this.hasFocus = !0, this.emit("sl-focus");
  }
  handleClick(z) {
    this.disabled && (z.preventDefault(), z.stopPropagation());
  }
  /** Simulates a click on the icon button. */
  click() {
    this.button.click();
  }
  /** Sets focus on the icon button. */
  focus(z) {
    this.button.focus(z);
  }
  /** Removes focus from the icon button. */
  blur() {
    this.button.blur();
  }
  render() {
    const z = !!this.href, D = z ? s`a` : s`button`;
    return n$2`
      <${D}
        part="base"
        class=${e$2({
      "icon-button": !0,
      "icon-button--disabled": !z && this.disabled,
      "icon-button--focused": this.hasFocus
    })}
        ?disabled=${o$6(z ? void 0 : this.disabled)}
        type=${o$6(z ? void 0 : "button")}
        href=${o$6(z ? this.href : void 0)}
        target=${o$6(z ? this.target : void 0)}
        download=${o$6(z ? this.download : void 0)}
        rel=${o$6(z && this.target ? "noreferrer noopener" : void 0)}
        role=${o$6(z ? void 0 : "button")}
        aria-disabled=${this.disabled ? "true" : "false"}
        aria-label="${this.label}"
        tabindex=${this.disabled ? "-1" : "0"}
        @blur=${this.handleBlur}
        @focus=${this.handleFocus}
        @click=${this.handleClick}
      >
        <sl-icon
          class="icon-button__icon"
          name=${o$6(this.name)}
          library=${o$6(this.library)}
          src=${o$6(this.src)}
          aria-hidden="true"
        ></sl-icon>
      </${D}>
    `;
  }
};
SlIconButton.styles = [component_styles_default, icon_button_styles_default];
SlIconButton.dependencies = { "sl-icon": SlIcon };
__decorateClass([
  e$b(".icon-button")
], SlIconButton.prototype, "button", 2);
__decorateClass([
  r$4()
], SlIconButton.prototype, "hasFocus", 2);
__decorateClass([
  n$6()
], SlIconButton.prototype, "name", 2);
__decorateClass([
  n$6()
], SlIconButton.prototype, "library", 2);
__decorateClass([
  n$6()
], SlIconButton.prototype, "src", 2);
__decorateClass([
  n$6()
], SlIconButton.prototype, "href", 2);
__decorateClass([
  n$6()
], SlIconButton.prototype, "target", 2);
__decorateClass([
  n$6()
], SlIconButton.prototype, "download", 2);
__decorateClass([
  n$6()
], SlIconButton.prototype, "label", 2);
__decorateClass([
  n$6({ type: Boolean, reflect: !0 })
], SlIconButton.prototype, "disabled", 2);
var SlTag = class extends ShoelaceElement {
  constructor() {
    super(...arguments), this.localize = new LocalizeController(this), this.variant = "neutral", this.size = "medium", this.pill = !1, this.removable = !1;
  }
  handleRemoveClick() {
    this.emit("sl-remove");
  }
  render() {
    return x`
      <span
        part="base"
        class=${e$2({
      tag: !0,
      // Types
      "tag--primary": this.variant === "primary",
      "tag--success": this.variant === "success",
      "tag--neutral": this.variant === "neutral",
      "tag--warning": this.variant === "warning",
      "tag--danger": this.variant === "danger",
      "tag--text": this.variant === "text",
      // Sizes
      "tag--small": this.size === "small",
      "tag--medium": this.size === "medium",
      "tag--large": this.size === "large",
      // Modifiers
      "tag--pill": this.pill,
      "tag--removable": this.removable
    })}
      >
        <slot part="content" class="tag__content"></slot>

        ${this.removable ? x`
              <sl-icon-button
                part="remove-button"
                exportparts="base:remove-button__base"
                name="x-lg"
                library="system"
                label=${this.localize.term("remove")}
                class="tag__remove"
                @click=${this.handleRemoveClick}
                tabindex="-1"
              ></sl-icon-button>
            ` : ""}
      </span>
    `;
  }
};
SlTag.styles = [component_styles_default, tag_styles_default];
SlTag.dependencies = { "sl-icon-button": SlIconButton };
__decorateClass([
  n$6({ reflect: !0 })
], SlTag.prototype, "variant", 2);
__decorateClass([
  n$6({ reflect: !0 })
], SlTag.prototype, "size", 2);
__decorateClass([
  n$6({ type: Boolean, reflect: !0 })
], SlTag.prototype, "pill", 2);
__decorateClass([
  n$6({ type: Boolean })
], SlTag.prototype, "removable", 2);
SlTag.define("sl-tag");
var tooltip_styles_default = i$7`
  :host {
    --max-width: 20rem;
    --hide-delay: 0ms;
    --show-delay: 150ms;

    display: contents;
  }

  .tooltip {
    --arrow-size: var(--sl-tooltip-arrow-size);
    --arrow-color: var(--sl-tooltip-background-color);
  }

  .tooltip::part(popup) {
    z-index: var(--sl-z-index-tooltip);
  }

  .tooltip[placement^='top']::part(popup) {
    transform-origin: bottom;
  }

  .tooltip[placement^='bottom']::part(popup) {
    transform-origin: top;
  }

  .tooltip[placement^='left']::part(popup) {
    transform-origin: right;
  }

  .tooltip[placement^='right']::part(popup) {
    transform-origin: left;
  }

  .tooltip__body {
    display: block;
    width: max-content;
    max-width: var(--max-width);
    border-radius: var(--sl-tooltip-border-radius);
    background-color: var(--sl-tooltip-background-color);
    font-family: var(--sl-tooltip-font-family);
    font-size: var(--sl-tooltip-font-size);
    font-weight: var(--sl-tooltip-font-weight);
    line-height: var(--sl-tooltip-line-height);
    text-align: start;
    white-space: normal;
    color: var(--sl-tooltip-color);
    padding: var(--sl-tooltip-padding);
    pointer-events: none;
    user-select: none;
    -webkit-user-select: none;
  }
`, popup_styles_default = i$7`
  :host {
    --arrow-color: var(--sl-color-neutral-1000);
    --arrow-size: 6px;

    /*
     * These properties are computed to account for the arrow's dimensions after being rotated 45. The constant
     * 0.7071 is derived from sin(45), which is the diagonal size of the arrow's container after rotating.
     */
    --arrow-size-diagonal: calc(var(--arrow-size) * 0.7071);
    --arrow-padding-offset: calc(var(--arrow-size-diagonal) - var(--arrow-size));

    display: contents;
  }

  .popup {
    position: absolute;
    isolation: isolate;
    max-width: var(--auto-size-available-width, none);
    max-height: var(--auto-size-available-height, none);
  }

  .popup--fixed {
    position: fixed;
  }

  .popup:not(.popup--active) {
    display: none;
  }

  .popup__arrow {
    position: absolute;
    width: calc(var(--arrow-size-diagonal) * 2);
    height: calc(var(--arrow-size-diagonal) * 2);
    rotate: 45deg;
    background: var(--arrow-color);
    z-index: -1;
  }

  /* Hover bridge */
  .popup-hover-bridge:not(.popup-hover-bridge--visible) {
    display: none;
  }

  .popup-hover-bridge {
    position: fixed;
    z-index: calc(var(--sl-z-index-dropdown) - 1);
    top: 0;
    right: 0;
    bottom: 0;
    left: 0;
    clip-path: polygon(
      var(--hover-bridge-top-left-x, 0) var(--hover-bridge-top-left-y, 0),
      var(--hover-bridge-top-right-x, 0) var(--hover-bridge-top-right-y, 0),
      var(--hover-bridge-bottom-right-x, 0) var(--hover-bridge-bottom-right-y, 0),
      var(--hover-bridge-bottom-left-x, 0) var(--hover-bridge-bottom-left-y, 0)
    );
  }
`;
const min = Math.min, max = Math.max, round = Math.round, floor = Math.floor, createCoords = (z) => ({
  x: z,
  y: z
}), oppositeSideMap = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
}, oppositeAlignmentMap = {
  start: "end",
  end: "start"
};
function clamp(z, D, O) {
  return max(z, min(D, O));
}
function evaluate(z, D) {
  return typeof z == "function" ? z(D) : z;
}
function getSide(z) {
  return z.split("-")[0];
}
function getAlignment(z) {
  return z.split("-")[1];
}
function getOppositeAxis(z) {
  return z === "x" ? "y" : "x";
}
function getAxisLength(z) {
  return z === "y" ? "height" : "width";
}
function getSideAxis(z) {
  return ["top", "bottom"].includes(getSide(z)) ? "y" : "x";
}
function getAlignmentAxis(z) {
  return getOppositeAxis(getSideAxis(z));
}
function getAlignmentSides(z, D, O) {
  O === void 0 && (O = !1);
  const F = getAlignment(z), U = getAlignmentAxis(z), W = getAxisLength(U);
  let B = U === "x" ? F === (O ? "end" : "start") ? "right" : "left" : F === "start" ? "bottom" : "top";
  return D.reference[W] > D.floating[W] && (B = getOppositePlacement(B)), [B, getOppositePlacement(B)];
}
function getExpandedPlacements(z) {
  const D = getOppositePlacement(z);
  return [getOppositeAlignmentPlacement(z), D, getOppositeAlignmentPlacement(D)];
}
function getOppositeAlignmentPlacement(z) {
  return z.replace(/start|end/g, (D) => oppositeAlignmentMap[D]);
}
function getSideList(z, D, O) {
  const F = ["left", "right"], U = ["right", "left"], W = ["top", "bottom"], B = ["bottom", "top"];
  switch (z) {
    case "top":
    case "bottom":
      return O ? D ? U : F : D ? F : U;
    case "left":
    case "right":
      return D ? W : B;
    default:
      return [];
  }
}
function getOppositeAxisPlacements(z, D, O, F) {
  const U = getAlignment(z);
  let W = getSideList(getSide(z), O === "start", F);
  return U && (W = W.map((B) => B + "-" + U), D && (W = W.concat(W.map(getOppositeAlignmentPlacement)))), W;
}
function getOppositePlacement(z) {
  return z.replace(/left|right|bottom|top/g, (D) => oppositeSideMap[D]);
}
function expandPaddingObject(z) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...z
  };
}
function getPaddingObject(z) {
  return typeof z != "number" ? expandPaddingObject(z) : {
    top: z,
    right: z,
    bottom: z,
    left: z
  };
}
function rectToClientRect(z) {
  const {
    x: D,
    y: O,
    width: F,
    height: U
  } = z;
  return {
    width: F,
    height: U,
    top: O,
    left: D,
    right: D + F,
    bottom: O + U,
    x: D,
    y: O
  };
}
function computeCoordsFromPlacement(z, D, O) {
  let {
    reference: F,
    floating: U
  } = z;
  const W = getSideAxis(D), B = getAlignmentAxis(D), K = getAxisLength(B), X = getSide(D), Y = W === "y", Q = F.x + F.width / 2 - U.width / 2, J = F.y + F.height / 2 - U.height / 2, ee = F[K] / 2 - U[K] / 2;
  let ae;
  switch (X) {
    case "top":
      ae = {
        x: Q,
        y: F.y - U.height
      };
      break;
    case "bottom":
      ae = {
        x: Q,
        y: F.y + F.height
      };
      break;
    case "right":
      ae = {
        x: F.x + F.width,
        y: J
      };
      break;
    case "left":
      ae = {
        x: F.x - U.width,
        y: J
      };
      break;
    default:
      ae = {
        x: F.x,
        y: F.y
      };
  }
  switch (getAlignment(D)) {
    case "start":
      ae[B] -= ee * (O && Y ? -1 : 1);
      break;
    case "end":
      ae[B] += ee * (O && Y ? -1 : 1);
      break;
  }
  return ae;
}
const computePosition$1 = async (z, D, O) => {
  const {
    placement: F = "bottom",
    strategy: U = "absolute",
    middleware: W = [],
    platform: B
  } = O, K = W.filter(Boolean), X = await (B.isRTL == null ? void 0 : B.isRTL(D));
  let Y = await B.getElementRects({
    reference: z,
    floating: D,
    strategy: U
  }), {
    x: Q,
    y: J
  } = computeCoordsFromPlacement(Y, F, X), ee = F, ae = {}, re = 0;
  for (let ie = 0; ie < K.length; ie++) {
    const {
      name: ue,
      fn: q
    } = K[ie], {
      x: ne,
      y: ce,
      data: he,
      reset: we
    } = await q({
      x: Q,
      y: J,
      initialPlacement: F,
      placement: ee,
      strategy: U,
      middlewareData: ae,
      rects: Y,
      platform: B,
      elements: {
        reference: z,
        floating: D
      }
    });
    Q = ne ?? Q, J = ce ?? J, ae = {
      ...ae,
      [ue]: {
        ...ae[ue],
        ...he
      }
    }, we && re <= 50 && (re++, typeof we == "object" && (we.placement && (ee = we.placement), we.rects && (Y = we.rects === !0 ? await B.getElementRects({
      reference: z,
      floating: D,
      strategy: U
    }) : we.rects), {
      x: Q,
      y: J
    } = computeCoordsFromPlacement(Y, ee, X)), ie = -1);
  }
  return {
    x: Q,
    y: J,
    placement: ee,
    strategy: U,
    middlewareData: ae
  };
};
async function detectOverflow(z, D) {
  var O;
  D === void 0 && (D = {});
  const {
    x: F,
    y: U,
    platform: W,
    rects: B,
    elements: K,
    strategy: X
  } = z, {
    boundary: Y = "clippingAncestors",
    rootBoundary: Q = "viewport",
    elementContext: J = "floating",
    altBoundary: ee = !1,
    padding: ae = 0
  } = evaluate(D, z), re = getPaddingObject(ae), ue = K[ee ? J === "floating" ? "reference" : "floating" : J], q = rectToClientRect(await W.getClippingRect({
    element: (O = await (W.isElement == null ? void 0 : W.isElement(ue))) == null || O ? ue : ue.contextElement || await (W.getDocumentElement == null ? void 0 : W.getDocumentElement(K.floating)),
    boundary: Y,
    rootBoundary: Q,
    strategy: X
  })), ne = J === "floating" ? {
    x: F,
    y: U,
    width: B.floating.width,
    height: B.floating.height
  } : B.reference, ce = await (W.getOffsetParent == null ? void 0 : W.getOffsetParent(K.floating)), he = await (W.isElement == null ? void 0 : W.isElement(ce)) ? await (W.getScale == null ? void 0 : W.getScale(ce)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  }, we = rectToClientRect(W.convertOffsetParentRelativeRectToViewportRelativeRect ? await W.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements: K,
    rect: ne,
    offsetParent: ce,
    strategy: X
  }) : ne);
  return {
    top: (q.top - we.top + re.top) / he.y,
    bottom: (we.bottom - q.bottom + re.bottom) / he.y,
    left: (q.left - we.left + re.left) / he.x,
    right: (we.right - q.right + re.right) / he.x
  };
}
const arrow$1 = (z) => ({
  name: "arrow",
  options: z,
  async fn(D) {
    const {
      x: O,
      y: F,
      placement: U,
      rects: W,
      platform: B,
      elements: K,
      middlewareData: X
    } = D, {
      element: Y,
      padding: Q = 0
    } = evaluate(z, D) || {};
    if (Y == null)
      return {};
    const J = getPaddingObject(Q), ee = {
      x: O,
      y: F
    }, ae = getAlignmentAxis(U), re = getAxisLength(ae), ie = await B.getDimensions(Y), ue = ae === "y", q = ue ? "top" : "left", ne = ue ? "bottom" : "right", ce = ue ? "clientHeight" : "clientWidth", he = W.reference[re] + W.reference[ae] - ee[ae] - W.floating[re], we = ee[ae] - W.reference[ae], me = await (B.getOffsetParent == null ? void 0 : B.getOffsetParent(Y));
    let de = me ? me[ce] : 0;
    (!de || !await (B.isElement == null ? void 0 : B.isElement(me))) && (de = K.floating[ce] || W.floating[re]);
    const be = he / 2 - we / 2, _e = de / 2 - ie[re] / 2 - 1, Me = min(J[q], _e), Ne = min(J[ne], _e), Ee = Me, $e = de - ie[re] - Ne, De = de / 2 - ie[re] / 2 + be, Fe = clamp(Ee, De, $e), Be = !X.arrow && getAlignment(U) != null && De !== Fe && W.reference[re] / 2 - (De < Ee ? Me : Ne) - ie[re] / 2 < 0, We = Be ? De < Ee ? De - Ee : De - $e : 0;
    return {
      [ae]: ee[ae] + We,
      data: {
        [ae]: Fe,
        centerOffset: De - Fe - We,
        ...Be && {
          alignmentOffset: We
        }
      },
      reset: Be
    };
  }
}), flip$2 = function(z) {
  return z === void 0 && (z = {}), {
    name: "flip",
    options: z,
    async fn(D) {
      var O, F;
      const {
        placement: U,
        middlewareData: W,
        rects: B,
        initialPlacement: K,
        platform: X,
        elements: Y
      } = D, {
        mainAxis: Q = !0,
        crossAxis: J = !0,
        fallbackPlacements: ee,
        fallbackStrategy: ae = "bestFit",
        fallbackAxisSideDirection: re = "none",
        flipAlignment: ie = !0,
        ...ue
      } = evaluate(z, D);
      if ((O = W.arrow) != null && O.alignmentOffset)
        return {};
      const q = getSide(U), ne = getSide(K) === K, ce = await (X.isRTL == null ? void 0 : X.isRTL(Y.floating)), he = ee || (ne || !ie ? [getOppositePlacement(K)] : getExpandedPlacements(K));
      !ee && re !== "none" && he.push(...getOppositeAxisPlacements(K, ie, re, ce));
      const we = [K, ...he], me = await detectOverflow(D, ue), de = [];
      let be = ((F = W.flip) == null ? void 0 : F.overflows) || [];
      if (Q && de.push(me[q]), J) {
        const Ee = getAlignmentSides(U, B, ce);
        de.push(me[Ee[0]], me[Ee[1]]);
      }
      if (be = [...be, {
        placement: U,
        overflows: de
      }], !de.every((Ee) => Ee <= 0)) {
        var _e, Me;
        const Ee = (((_e = W.flip) == null ? void 0 : _e.index) || 0) + 1, $e = we[Ee];
        if ($e)
          return {
            data: {
              index: Ee,
              overflows: be
            },
            reset: {
              placement: $e
            }
          };
        let De = (Me = be.filter((Fe) => Fe.overflows[0] <= 0).sort((Fe, Be) => Fe.overflows[1] - Be.overflows[1])[0]) == null ? void 0 : Me.placement;
        if (!De)
          switch (ae) {
            case "bestFit": {
              var Ne;
              const Fe = (Ne = be.map((Be) => [Be.placement, Be.overflows.filter((We) => We > 0).reduce((We, Ve) => We + Ve, 0)]).sort((Be, We) => Be[1] - We[1])[0]) == null ? void 0 : Ne[0];
              Fe && (De = Fe);
              break;
            }
            case "initialPlacement":
              De = K;
              break;
          }
        if (U !== De)
          return {
            reset: {
              placement: De
            }
          };
      }
      return {};
    }
  };
};
async function convertValueToCoords(z, D) {
  const {
    placement: O,
    platform: F,
    elements: U
  } = z, W = await (F.isRTL == null ? void 0 : F.isRTL(U.floating)), B = getSide(O), K = getAlignment(O), X = getSideAxis(O) === "y", Y = ["left", "top"].includes(B) ? -1 : 1, Q = W && X ? -1 : 1, J = evaluate(D, z);
  let {
    mainAxis: ee,
    crossAxis: ae,
    alignmentAxis: re
  } = typeof J == "number" ? {
    mainAxis: J,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: 0,
    crossAxis: 0,
    alignmentAxis: null,
    ...J
  };
  return K && typeof re == "number" && (ae = K === "end" ? re * -1 : re), X ? {
    x: ae * Q,
    y: ee * Y
  } : {
    x: ee * Y,
    y: ae * Q
  };
}
const offset$1 = function(z) {
  return z === void 0 && (z = 0), {
    name: "offset",
    options: z,
    async fn(D) {
      var O, F;
      const {
        x: U,
        y: W,
        placement: B,
        middlewareData: K
      } = D, X = await convertValueToCoords(D, z);
      return B === ((O = K.offset) == null ? void 0 : O.placement) && (F = K.arrow) != null && F.alignmentOffset ? {} : {
        x: U + X.x,
        y: W + X.y,
        data: {
          ...X,
          placement: B
        }
      };
    }
  };
}, shift$1 = function(z) {
  return z === void 0 && (z = {}), {
    name: "shift",
    options: z,
    async fn(D) {
      const {
        x: O,
        y: F,
        placement: U
      } = D, {
        mainAxis: W = !0,
        crossAxis: B = !1,
        limiter: K = {
          fn: (ue) => {
            let {
              x: q,
              y: ne
            } = ue;
            return {
              x: q,
              y: ne
            };
          }
        },
        ...X
      } = evaluate(z, D), Y = {
        x: O,
        y: F
      }, Q = await detectOverflow(D, X), J = getSideAxis(getSide(U)), ee = getOppositeAxis(J);
      let ae = Y[ee], re = Y[J];
      if (W) {
        const ue = ee === "y" ? "top" : "left", q = ee === "y" ? "bottom" : "right", ne = ae + Q[ue], ce = ae - Q[q];
        ae = clamp(ne, ae, ce);
      }
      if (B) {
        const ue = J === "y" ? "top" : "left", q = J === "y" ? "bottom" : "right", ne = re + Q[ue], ce = re - Q[q];
        re = clamp(ne, re, ce);
      }
      const ie = K.fn({
        ...D,
        [ee]: ae,
        [J]: re
      });
      return {
        ...ie,
        data: {
          x: ie.x - O,
          y: ie.y - F
        }
      };
    }
  };
}, size$1 = function(z) {
  return z === void 0 && (z = {}), {
    name: "size",
    options: z,
    async fn(D) {
      const {
        placement: O,
        rects: F,
        platform: U,
        elements: W
      } = D, {
        apply: B = () => {
        },
        ...K
      } = evaluate(z, D), X = await detectOverflow(D, K), Y = getSide(O), Q = getAlignment(O), J = getSideAxis(O) === "y", {
        width: ee,
        height: ae
      } = F.floating;
      let re, ie;
      Y === "top" || Y === "bottom" ? (re = Y, ie = Q === (await (U.isRTL == null ? void 0 : U.isRTL(W.floating)) ? "start" : "end") ? "left" : "right") : (ie = Y, re = Q === "end" ? "top" : "bottom");
      const ue = ae - X.top - X.bottom, q = ee - X.left - X.right, ne = min(ae - X[re], ue), ce = min(ee - X[ie], q), he = !D.middlewareData.shift;
      let we = ne, me = ce;
      if (J ? me = Q || he ? min(ce, q) : q : we = Q || he ? min(ne, ue) : ue, he && !Q) {
        const be = max(X.left, 0), _e = max(X.right, 0), Me = max(X.top, 0), Ne = max(X.bottom, 0);
        J ? me = ee - 2 * (be !== 0 || _e !== 0 ? be + _e : max(X.left, X.right)) : we = ae - 2 * (Me !== 0 || Ne !== 0 ? Me + Ne : max(X.top, X.bottom));
      }
      await B({
        ...D,
        availableWidth: me,
        availableHeight: we
      });
      const de = await U.getDimensions(W.floating);
      return ee !== de.width || ae !== de.height ? {
        reset: {
          rects: !0
        }
      } : {};
    }
  };
};
function getNodeName(z) {
  return isNode(z) ? (z.nodeName || "").toLowerCase() : "#document";
}
function getWindow(z) {
  var D;
  return (z == null || (D = z.ownerDocument) == null ? void 0 : D.defaultView) || window;
}
function getDocumentElement(z) {
  var D;
  return (D = (isNode(z) ? z.ownerDocument : z.document) || window.document) == null ? void 0 : D.documentElement;
}
function isNode(z) {
  return z instanceof Node || z instanceof getWindow(z).Node;
}
function isElement(z) {
  return z instanceof Element || z instanceof getWindow(z).Element;
}
function isHTMLElement(z) {
  return z instanceof HTMLElement || z instanceof getWindow(z).HTMLElement;
}
function isShadowRoot(z) {
  return typeof ShadowRoot > "u" ? !1 : z instanceof ShadowRoot || z instanceof getWindow(z).ShadowRoot;
}
function isOverflowElement(z) {
  const {
    overflow: D,
    overflowX: O,
    overflowY: F,
    display: U
  } = getComputedStyle$1(z);
  return /auto|scroll|overlay|hidden|clip/.test(D + F + O) && !["inline", "contents"].includes(U);
}
function isTableElement(z) {
  return ["table", "td", "th"].includes(getNodeName(z));
}
function isContainingBlock(z) {
  const D = isWebKit(), O = getComputedStyle$1(z);
  return O.transform !== "none" || O.perspective !== "none" || (O.containerType ? O.containerType !== "normal" : !1) || !D && (O.backdropFilter ? O.backdropFilter !== "none" : !1) || !D && (O.filter ? O.filter !== "none" : !1) || ["transform", "perspective", "filter"].some((F) => (O.willChange || "").includes(F)) || ["paint", "layout", "strict", "content"].some((F) => (O.contain || "").includes(F));
}
function getContainingBlock(z) {
  let D = getParentNode(z);
  for (; isHTMLElement(D) && !isLastTraversableNode(D); ) {
    if (isContainingBlock(D))
      return D;
    D = getParentNode(D);
  }
  return null;
}
function isWebKit() {
  return typeof CSS > "u" || !CSS.supports ? !1 : CSS.supports("-webkit-backdrop-filter", "none");
}
function isLastTraversableNode(z) {
  return ["html", "body", "#document"].includes(getNodeName(z));
}
function getComputedStyle$1(z) {
  return getWindow(z).getComputedStyle(z);
}
function getNodeScroll(z) {
  return isElement(z) ? {
    scrollLeft: z.scrollLeft,
    scrollTop: z.scrollTop
  } : {
    scrollLeft: z.pageXOffset,
    scrollTop: z.pageYOffset
  };
}
function getParentNode(z) {
  if (getNodeName(z) === "html")
    return z;
  const D = (
    // Step into the shadow DOM of the parent of a slotted node.
    z.assignedSlot || // DOM Element detected.
    z.parentNode || // ShadowRoot detected.
    isShadowRoot(z) && z.host || // Fallback.
    getDocumentElement(z)
  );
  return isShadowRoot(D) ? D.host : D;
}
function getNearestOverflowAncestor(z) {
  const D = getParentNode(z);
  return isLastTraversableNode(D) ? z.ownerDocument ? z.ownerDocument.body : z.body : isHTMLElement(D) && isOverflowElement(D) ? D : getNearestOverflowAncestor(D);
}
function getOverflowAncestors(z, D, O) {
  var F;
  D === void 0 && (D = []), O === void 0 && (O = !0);
  const U = getNearestOverflowAncestor(z), W = U === ((F = z.ownerDocument) == null ? void 0 : F.body), B = getWindow(U);
  return W ? D.concat(B, B.visualViewport || [], isOverflowElement(U) ? U : [], B.frameElement && O ? getOverflowAncestors(B.frameElement) : []) : D.concat(U, getOverflowAncestors(U, [], O));
}
function getCssDimensions(z) {
  const D = getComputedStyle$1(z);
  let O = parseFloat(D.width) || 0, F = parseFloat(D.height) || 0;
  const U = isHTMLElement(z), W = U ? z.offsetWidth : O, B = U ? z.offsetHeight : F, K = round(O) !== W || round(F) !== B;
  return K && (O = W, F = B), {
    width: O,
    height: F,
    $: K
  };
}
function unwrapElement(z) {
  return isElement(z) ? z : z.contextElement;
}
function getScale(z) {
  const D = unwrapElement(z);
  if (!isHTMLElement(D))
    return createCoords(1);
  const O = D.getBoundingClientRect(), {
    width: F,
    height: U,
    $: W
  } = getCssDimensions(D);
  let B = (W ? round(O.width) : O.width) / F, K = (W ? round(O.height) : O.height) / U;
  return (!B || !Number.isFinite(B)) && (B = 1), (!K || !Number.isFinite(K)) && (K = 1), {
    x: B,
    y: K
  };
}
const noOffsets = /* @__PURE__ */ createCoords(0);
function getVisualOffsets(z) {
  const D = getWindow(z);
  return !isWebKit() || !D.visualViewport ? noOffsets : {
    x: D.visualViewport.offsetLeft,
    y: D.visualViewport.offsetTop
  };
}
function shouldAddVisualOffsets(z, D, O) {
  return D === void 0 && (D = !1), !O || D && O !== getWindow(z) ? !1 : D;
}
function getBoundingClientRect(z, D, O, F) {
  D === void 0 && (D = !1), O === void 0 && (O = !1);
  const U = z.getBoundingClientRect(), W = unwrapElement(z);
  let B = createCoords(1);
  D && (F ? isElement(F) && (B = getScale(F)) : B = getScale(z));
  const K = shouldAddVisualOffsets(W, O, F) ? getVisualOffsets(W) : createCoords(0);
  let X = (U.left + K.x) / B.x, Y = (U.top + K.y) / B.y, Q = U.width / B.x, J = U.height / B.y;
  if (W) {
    const ee = getWindow(W), ae = F && isElement(F) ? getWindow(F) : F;
    let re = ee, ie = re.frameElement;
    for (; ie && F && ae !== re; ) {
      const ue = getScale(ie), q = ie.getBoundingClientRect(), ne = getComputedStyle$1(ie), ce = q.left + (ie.clientLeft + parseFloat(ne.paddingLeft)) * ue.x, he = q.top + (ie.clientTop + parseFloat(ne.paddingTop)) * ue.y;
      X *= ue.x, Y *= ue.y, Q *= ue.x, J *= ue.y, X += ce, Y += he, re = getWindow(ie), ie = re.frameElement;
    }
  }
  return rectToClientRect({
    width: Q,
    height: J,
    x: X,
    y: Y
  });
}
const topLayerSelectors = [":popover-open", ":modal"];
function isTopLayer(z) {
  return topLayerSelectors.some((D) => {
    try {
      return z.matches(D);
    } catch {
      return !1;
    }
  });
}
function convertOffsetParentRelativeRectToViewportRelativeRect(z) {
  let {
    elements: D,
    rect: O,
    offsetParent: F,
    strategy: U
  } = z;
  const W = U === "fixed", B = getDocumentElement(F), K = D ? isTopLayer(D.floating) : !1;
  if (F === B || K && W)
    return O;
  let X = {
    scrollLeft: 0,
    scrollTop: 0
  }, Y = createCoords(1);
  const Q = createCoords(0), J = isHTMLElement(F);
  if ((J || !J && !W) && ((getNodeName(F) !== "body" || isOverflowElement(B)) && (X = getNodeScroll(F)), isHTMLElement(F))) {
    const ee = getBoundingClientRect(F);
    Y = getScale(F), Q.x = ee.x + F.clientLeft, Q.y = ee.y + F.clientTop;
  }
  return {
    width: O.width * Y.x,
    height: O.height * Y.y,
    x: O.x * Y.x - X.scrollLeft * Y.x + Q.x,
    y: O.y * Y.y - X.scrollTop * Y.y + Q.y
  };
}
function getClientRects(z) {
  return Array.from(z.getClientRects());
}
function getWindowScrollBarX(z) {
  return getBoundingClientRect(getDocumentElement(z)).left + getNodeScroll(z).scrollLeft;
}
function getDocumentRect(z) {
  const D = getDocumentElement(z), O = getNodeScroll(z), F = z.ownerDocument.body, U = max(D.scrollWidth, D.clientWidth, F.scrollWidth, F.clientWidth), W = max(D.scrollHeight, D.clientHeight, F.scrollHeight, F.clientHeight);
  let B = -O.scrollLeft + getWindowScrollBarX(z);
  const K = -O.scrollTop;
  return getComputedStyle$1(F).direction === "rtl" && (B += max(D.clientWidth, F.clientWidth) - U), {
    width: U,
    height: W,
    x: B,
    y: K
  };
}
function getViewportRect(z, D) {
  const O = getWindow(z), F = getDocumentElement(z), U = O.visualViewport;
  let W = F.clientWidth, B = F.clientHeight, K = 0, X = 0;
  if (U) {
    W = U.width, B = U.height;
    const Y = isWebKit();
    (!Y || Y && D === "fixed") && (K = U.offsetLeft, X = U.offsetTop);
  }
  return {
    width: W,
    height: B,
    x: K,
    y: X
  };
}
function getInnerBoundingClientRect(z, D) {
  const O = getBoundingClientRect(z, !0, D === "fixed"), F = O.top + z.clientTop, U = O.left + z.clientLeft, W = isHTMLElement(z) ? getScale(z) : createCoords(1), B = z.clientWidth * W.x, K = z.clientHeight * W.y, X = U * W.x, Y = F * W.y;
  return {
    width: B,
    height: K,
    x: X,
    y: Y
  };
}
function getClientRectFromClippingAncestor(z, D, O) {
  let F;
  if (D === "viewport")
    F = getViewportRect(z, O);
  else if (D === "document")
    F = getDocumentRect(getDocumentElement(z));
  else if (isElement(D))
    F = getInnerBoundingClientRect(D, O);
  else {
    const U = getVisualOffsets(z);
    F = {
      ...D,
      x: D.x - U.x,
      y: D.y - U.y
    };
  }
  return rectToClientRect(F);
}
function hasFixedPositionAncestor(z, D) {
  const O = getParentNode(z);
  return O === D || !isElement(O) || isLastTraversableNode(O) ? !1 : getComputedStyle$1(O).position === "fixed" || hasFixedPositionAncestor(O, D);
}
function getClippingElementAncestors(z, D) {
  const O = D.get(z);
  if (O)
    return O;
  let F = getOverflowAncestors(z, [], !1).filter((K) => isElement(K) && getNodeName(K) !== "body"), U = null;
  const W = getComputedStyle$1(z).position === "fixed";
  let B = W ? getParentNode(z) : z;
  for (; isElement(B) && !isLastTraversableNode(B); ) {
    const K = getComputedStyle$1(B), X = isContainingBlock(B);
    !X && K.position === "fixed" && (U = null), (W ? !X && !U : !X && K.position === "static" && !!U && ["absolute", "fixed"].includes(U.position) || isOverflowElement(B) && !X && hasFixedPositionAncestor(z, B)) ? F = F.filter((Q) => Q !== B) : U = K, B = getParentNode(B);
  }
  return D.set(z, F), F;
}
function getClippingRect(z) {
  let {
    element: D,
    boundary: O,
    rootBoundary: F,
    strategy: U
  } = z;
  const B = [...O === "clippingAncestors" ? isTopLayer(D) ? [] : getClippingElementAncestors(D, this._c) : [].concat(O), F], K = B[0], X = B.reduce((Y, Q) => {
    const J = getClientRectFromClippingAncestor(D, Q, U);
    return Y.top = max(J.top, Y.top), Y.right = min(J.right, Y.right), Y.bottom = min(J.bottom, Y.bottom), Y.left = max(J.left, Y.left), Y;
  }, getClientRectFromClippingAncestor(D, K, U));
  return {
    width: X.right - X.left,
    height: X.bottom - X.top,
    x: X.left,
    y: X.top
  };
}
function getDimensions(z) {
  const {
    width: D,
    height: O
  } = getCssDimensions(z);
  return {
    width: D,
    height: O
  };
}
function getRectRelativeToOffsetParent(z, D, O) {
  const F = isHTMLElement(D), U = getDocumentElement(D), W = O === "fixed", B = getBoundingClientRect(z, !0, W, D);
  let K = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const X = createCoords(0);
  if (F || !F && !W)
    if ((getNodeName(D) !== "body" || isOverflowElement(U)) && (K = getNodeScroll(D)), F) {
      const J = getBoundingClientRect(D, !0, W, D);
      X.x = J.x + D.clientLeft, X.y = J.y + D.clientTop;
    } else
      U && (X.x = getWindowScrollBarX(U));
  const Y = B.left + K.scrollLeft - X.x, Q = B.top + K.scrollTop - X.y;
  return {
    x: Y,
    y: Q,
    width: B.width,
    height: B.height
  };
}
function isStaticPositioned(z) {
  return getComputedStyle$1(z).position === "static";
}
function getTrueOffsetParent(z, D) {
  return !isHTMLElement(z) || getComputedStyle$1(z).position === "fixed" ? null : D ? D(z) : z.offsetParent;
}
function getOffsetParent(z, D) {
  const O = getWindow(z);
  if (isTopLayer(z))
    return O;
  if (!isHTMLElement(z)) {
    let U = getParentNode(z);
    for (; U && !isLastTraversableNode(U); ) {
      if (isElement(U) && !isStaticPositioned(U))
        return U;
      U = getParentNode(U);
    }
    return O;
  }
  let F = getTrueOffsetParent(z, D);
  for (; F && isTableElement(F) && isStaticPositioned(F); )
    F = getTrueOffsetParent(F, D);
  return F && isLastTraversableNode(F) && isStaticPositioned(F) && !isContainingBlock(F) ? O : F || getContainingBlock(z) || O;
}
const getElementRects = async function(z) {
  const D = this.getOffsetParent || getOffsetParent, O = this.getDimensions, F = await O(z.floating);
  return {
    reference: getRectRelativeToOffsetParent(z.reference, await D(z.floating), z.strategy),
    floating: {
      x: 0,
      y: 0,
      width: F.width,
      height: F.height
    }
  };
};
function isRTL(z) {
  return getComputedStyle$1(z).direction === "rtl";
}
const platform = {
  convertOffsetParentRelativeRectToViewportRelativeRect,
  getDocumentElement,
  getClippingRect,
  getOffsetParent,
  getElementRects,
  getClientRects,
  getDimensions,
  getScale,
  isElement,
  isRTL
};
function observeMove(z, D) {
  let O = null, F;
  const U = getDocumentElement(z);
  function W() {
    var K;
    clearTimeout(F), (K = O) == null || K.disconnect(), O = null;
  }
  function B(K, X) {
    K === void 0 && (K = !1), X === void 0 && (X = 1), W();
    const {
      left: Y,
      top: Q,
      width: J,
      height: ee
    } = z.getBoundingClientRect();
    if (K || D(), !J || !ee)
      return;
    const ae = floor(Q), re = floor(U.clientWidth - (Y + J)), ie = floor(U.clientHeight - (Q + ee)), ue = floor(Y), ne = {
      rootMargin: -ae + "px " + -re + "px " + -ie + "px " + -ue + "px",
      threshold: max(0, min(1, X)) || 1
    };
    let ce = !0;
    function he(we) {
      const me = we[0].intersectionRatio;
      if (me !== X) {
        if (!ce)
          return B();
        me ? B(!1, me) : F = setTimeout(() => {
          B(!1, 1e-7);
        }, 1e3);
      }
      ce = !1;
    }
    try {
      O = new IntersectionObserver(he, {
        ...ne,
        // Handle <iframe>s
        root: U.ownerDocument
      });
    } catch {
      O = new IntersectionObserver(he, ne);
    }
    O.observe(z);
  }
  return B(!0), W;
}
function autoUpdate(z, D, O, F) {
  F === void 0 && (F = {});
  const {
    ancestorScroll: U = !0,
    ancestorResize: W = !0,
    elementResize: B = typeof ResizeObserver == "function",
    layoutShift: K = typeof IntersectionObserver == "function",
    animationFrame: X = !1
  } = F, Y = unwrapElement(z), Q = U || W ? [...Y ? getOverflowAncestors(Y) : [], ...getOverflowAncestors(D)] : [];
  Q.forEach((q) => {
    U && q.addEventListener("scroll", O, {
      passive: !0
    }), W && q.addEventListener("resize", O);
  });
  const J = Y && K ? observeMove(Y, O) : null;
  let ee = -1, ae = null;
  B && (ae = new ResizeObserver((q) => {
    let [ne] = q;
    ne && ne.target === Y && ae && (ae.unobserve(D), cancelAnimationFrame(ee), ee = requestAnimationFrame(() => {
      var ce;
      (ce = ae) == null || ce.observe(D);
    })), O();
  }), Y && !X && ae.observe(Y), ae.observe(D));
  let re, ie = X ? getBoundingClientRect(z) : null;
  X && ue();
  function ue() {
    const q = getBoundingClientRect(z);
    ie && (q.x !== ie.x || q.y !== ie.y || q.width !== ie.width || q.height !== ie.height) && O(), ie = q, re = requestAnimationFrame(ue);
  }
  return O(), () => {
    var q;
    Q.forEach((ne) => {
      U && ne.removeEventListener("scroll", O), W && ne.removeEventListener("resize", O);
    }), J == null || J(), (q = ae) == null || q.disconnect(), ae = null, X && cancelAnimationFrame(re);
  };
}
const offset = offset$1, shift = shift$1, flip$1 = flip$2, size = size$1, arrow = arrow$1, computePosition = (z, D, O) => {
  const F = /* @__PURE__ */ new Map(), U = {
    platform,
    ...O
  }, W = {
    ...U.platform,
    _c: F
  };
  return computePosition$1(z, D, {
    ...U,
    platform: W
  });
};
function t(z) {
  return r(z);
}
function o$4(z) {
  return z.assignedSlot ? z.assignedSlot : z.parentNode instanceof ShadowRoot ? z.parentNode.host : z.parentNode;
}
function r(z) {
  for (let D = z; D; D = o$4(D))
    if (D instanceof Element && getComputedStyle(D).display === "none")
      return null;
  for (let D = o$4(z); D; D = o$4(D)) {
    if (!(D instanceof Element))
      continue;
    const O = getComputedStyle(D);
    if (O.display !== "contents" && (O.position !== "static" || O.filter !== "none" || D.tagName === "BODY"))
      return D;
  }
  return null;
}
function isVirtualElement(z) {
  return z !== null && typeof z == "object" && "getBoundingClientRect" in z && ("contextElement" in z ? z instanceof Element : !0);
}
var SlPopup = class extends ShoelaceElement {
  constructor() {
    super(...arguments), this.active = !1, this.placement = "top", this.strategy = "absolute", this.distance = 0, this.skidding = 0, this.arrow = !1, this.arrowPlacement = "anchor", this.arrowPadding = 10, this.flip = !1, this.flipFallbackPlacements = "", this.flipFallbackStrategy = "best-fit", this.flipPadding = 0, this.shift = !1, this.shiftPadding = 0, this.autoSizePadding = 0, this.hoverBridge = !1, this.updateHoverBridge = () => {
      if (this.hoverBridge && this.anchorEl) {
        const z = this.anchorEl.getBoundingClientRect(), D = this.popup.getBoundingClientRect(), O = this.placement.includes("top") || this.placement.includes("bottom");
        let F = 0, U = 0, W = 0, B = 0, K = 0, X = 0, Y = 0, Q = 0;
        O ? z.top < D.top ? (F = z.left, U = z.bottom, W = z.right, B = z.bottom, K = D.left, X = D.top, Y = D.right, Q = D.top) : (F = D.left, U = D.bottom, W = D.right, B = D.bottom, K = z.left, X = z.top, Y = z.right, Q = z.top) : z.left < D.left ? (F = z.right, U = z.top, W = D.left, B = D.top, K = z.right, X = z.bottom, Y = D.left, Q = D.bottom) : (F = D.right, U = D.top, W = z.left, B = z.top, K = D.right, X = D.bottom, Y = z.left, Q = z.bottom), this.style.setProperty("--hover-bridge-top-left-x", `${F}px`), this.style.setProperty("--hover-bridge-top-left-y", `${U}px`), this.style.setProperty("--hover-bridge-top-right-x", `${W}px`), this.style.setProperty("--hover-bridge-top-right-y", `${B}px`), this.style.setProperty("--hover-bridge-bottom-left-x", `${K}px`), this.style.setProperty("--hover-bridge-bottom-left-y", `${X}px`), this.style.setProperty("--hover-bridge-bottom-right-x", `${Y}px`), this.style.setProperty("--hover-bridge-bottom-right-y", `${Q}px`);
      }
    };
  }
  async connectedCallback() {
    super.connectedCallback(), await this.updateComplete, this.start();
  }
  disconnectedCallback() {
    super.disconnectedCallback(), this.stop();
  }
  async updated(z) {
    super.updated(z), z.has("active") && (this.active ? this.start() : this.stop()), z.has("anchor") && this.handleAnchorChange(), this.active && (await this.updateComplete, this.reposition());
  }
  async handleAnchorChange() {
    if (await this.stop(), this.anchor && typeof this.anchor == "string") {
      const z = this.getRootNode();
      this.anchorEl = z.getElementById(this.anchor);
    } else
      this.anchor instanceof Element || isVirtualElement(this.anchor) ? this.anchorEl = this.anchor : this.anchorEl = this.querySelector('[slot="anchor"]');
    this.anchorEl instanceof HTMLSlotElement && (this.anchorEl = this.anchorEl.assignedElements({ flatten: !0 })[0]), this.anchorEl && this.start();
  }
  start() {
    this.anchorEl && (this.cleanup = autoUpdate(this.anchorEl, this.popup, () => {
      this.reposition();
    }));
  }
  async stop() {
    return new Promise((z) => {
      this.cleanup ? (this.cleanup(), this.cleanup = void 0, this.removeAttribute("data-current-placement"), this.style.removeProperty("--auto-size-available-width"), this.style.removeProperty("--auto-size-available-height"), requestAnimationFrame(() => z())) : z();
    });
  }
  /** Forces the popup to recalculate and reposition itself. */
  reposition() {
    if (!this.active || !this.anchorEl)
      return;
    const z = [
      // The offset middleware goes first
      offset({ mainAxis: this.distance, crossAxis: this.skidding })
    ];
    this.sync ? z.push(
      size({
        apply: ({ rects: O }) => {
          const F = this.sync === "width" || this.sync === "both", U = this.sync === "height" || this.sync === "both";
          this.popup.style.width = F ? `${O.reference.width}px` : "", this.popup.style.height = U ? `${O.reference.height}px` : "";
        }
      })
    ) : (this.popup.style.width = "", this.popup.style.height = ""), this.flip && z.push(
      flip$1({
        boundary: this.flipBoundary,
        // @ts-expect-error - We're converting a string attribute to an array here
        fallbackPlacements: this.flipFallbackPlacements,
        fallbackStrategy: this.flipFallbackStrategy === "best-fit" ? "bestFit" : "initialPlacement",
        padding: this.flipPadding
      })
    ), this.shift && z.push(
      shift({
        boundary: this.shiftBoundary,
        padding: this.shiftPadding
      })
    ), this.autoSize ? z.push(
      size({
        boundary: this.autoSizeBoundary,
        padding: this.autoSizePadding,
        apply: ({ availableWidth: O, availableHeight: F }) => {
          this.autoSize === "vertical" || this.autoSize === "both" ? this.style.setProperty("--auto-size-available-height", `${F}px`) : this.style.removeProperty("--auto-size-available-height"), this.autoSize === "horizontal" || this.autoSize === "both" ? this.style.setProperty("--auto-size-available-width", `${O}px`) : this.style.removeProperty("--auto-size-available-width");
        }
      })
    ) : (this.style.removeProperty("--auto-size-available-width"), this.style.removeProperty("--auto-size-available-height")), this.arrow && z.push(
      arrow({
        element: this.arrowEl,
        padding: this.arrowPadding
      })
    );
    const D = this.strategy === "absolute" ? (O) => platform.getOffsetParent(O, t) : platform.getOffsetParent;
    computePosition(this.anchorEl, this.popup, {
      placement: this.placement,
      middleware: z,
      strategy: this.strategy,
      platform: __spreadProps(__spreadValues({}, platform), {
        getOffsetParent: D
      })
    }).then(({ x: O, y: F, middlewareData: U, placement: W }) => {
      const B = getComputedStyle(this).direction === "rtl", K = { top: "bottom", right: "left", bottom: "top", left: "right" }[W.split("-")[0]];
      if (this.setAttribute("data-current-placement", W), Object.assign(this.popup.style, {
        left: `${O}px`,
        top: `${F}px`
      }), this.arrow) {
        const X = U.arrow.x, Y = U.arrow.y;
        let Q = "", J = "", ee = "", ae = "";
        if (this.arrowPlacement === "start") {
          const re = typeof X == "number" ? `calc(${this.arrowPadding}px - var(--arrow-padding-offset))` : "";
          Q = typeof Y == "number" ? `calc(${this.arrowPadding}px - var(--arrow-padding-offset))` : "", J = B ? re : "", ae = B ? "" : re;
        } else if (this.arrowPlacement === "end") {
          const re = typeof X == "number" ? `calc(${this.arrowPadding}px - var(--arrow-padding-offset))` : "";
          J = B ? "" : re, ae = B ? re : "", ee = typeof Y == "number" ? `calc(${this.arrowPadding}px - var(--arrow-padding-offset))` : "";
        } else
          this.arrowPlacement === "center" ? (ae = typeof X == "number" ? "calc(50% - var(--arrow-size-diagonal))" : "", Q = typeof Y == "number" ? "calc(50% - var(--arrow-size-diagonal))" : "") : (ae = typeof X == "number" ? `${X}px` : "", Q = typeof Y == "number" ? `${Y}px` : "");
        Object.assign(this.arrowEl.style, {
          top: Q,
          right: J,
          bottom: ee,
          left: ae,
          [K]: "calc(var(--arrow-size-diagonal) * -1)"
        });
      }
    }), requestAnimationFrame(() => this.updateHoverBridge()), this.emit("sl-reposition");
  }
  render() {
    return x`
      <slot name="anchor" @slotchange=${this.handleAnchorChange}></slot>

      <span
        part="hover-bridge"
        class=${e$2({
      "popup-hover-bridge": !0,
      "popup-hover-bridge--visible": this.hoverBridge && this.active
    })}
      ></span>

      <div
        part="popup"
        class=${e$2({
      popup: !0,
      "popup--active": this.active,
      "popup--fixed": this.strategy === "fixed",
      "popup--has-arrow": this.arrow
    })}
      >
        <slot></slot>
        ${this.arrow ? x`<div part="arrow" class="popup__arrow" role="presentation"></div>` : ""}
      </div>
    `;
  }
};
SlPopup.styles = [component_styles_default, popup_styles_default];
__decorateClass([
  e$b(".popup")
], SlPopup.prototype, "popup", 2);
__decorateClass([
  e$b(".popup__arrow")
], SlPopup.prototype, "arrowEl", 2);
__decorateClass([
  n$6()
], SlPopup.prototype, "anchor", 2);
__decorateClass([
  n$6({ type: Boolean, reflect: !0 })
], SlPopup.prototype, "active", 2);
__decorateClass([
  n$6({ reflect: !0 })
], SlPopup.prototype, "placement", 2);
__decorateClass([
  n$6({ reflect: !0 })
], SlPopup.prototype, "strategy", 2);
__decorateClass([
  n$6({ type: Number })
], SlPopup.prototype, "distance", 2);
__decorateClass([
  n$6({ type: Number })
], SlPopup.prototype, "skidding", 2);
__decorateClass([
  n$6({ type: Boolean })
], SlPopup.prototype, "arrow", 2);
__decorateClass([
  n$6({ attribute: "arrow-placement" })
], SlPopup.prototype, "arrowPlacement", 2);
__decorateClass([
  n$6({ attribute: "arrow-padding", type: Number })
], SlPopup.prototype, "arrowPadding", 2);
__decorateClass([
  n$6({ type: Boolean })
], SlPopup.prototype, "flip", 2);
__decorateClass([
  n$6({
    attribute: "flip-fallback-placements",
    converter: {
      fromAttribute: (z) => z.split(" ").map((D) => D.trim()).filter((D) => D !== ""),
      toAttribute: (z) => z.join(" ")
    }
  })
], SlPopup.prototype, "flipFallbackPlacements", 2);
__decorateClass([
  n$6({ attribute: "flip-fallback-strategy" })
], SlPopup.prototype, "flipFallbackStrategy", 2);
__decorateClass([
  n$6({ type: Object })
], SlPopup.prototype, "flipBoundary", 2);
__decorateClass([
  n$6({ attribute: "flip-padding", type: Number })
], SlPopup.prototype, "flipPadding", 2);
__decorateClass([
  n$6({ type: Boolean })
], SlPopup.prototype, "shift", 2);
__decorateClass([
  n$6({ type: Object })
], SlPopup.prototype, "shiftBoundary", 2);
__decorateClass([
  n$6({ attribute: "shift-padding", type: Number })
], SlPopup.prototype, "shiftPadding", 2);
__decorateClass([
  n$6({ attribute: "auto-size" })
], SlPopup.prototype, "autoSize", 2);
__decorateClass([
  n$6()
], SlPopup.prototype, "sync", 2);
__decorateClass([
  n$6({ type: Object })
], SlPopup.prototype, "autoSizeBoundary", 2);
__decorateClass([
  n$6({ attribute: "auto-size-padding", type: Number })
], SlPopup.prototype, "autoSizePadding", 2);
__decorateClass([
  n$6({ attribute: "hover-bridge", type: Boolean })
], SlPopup.prototype, "hoverBridge", 2);
function waitForEvent(z, D) {
  return new Promise((O) => {
    function F(U) {
      U.target === z && (z.removeEventListener(D, F), O());
    }
    z.addEventListener(D, F);
  });
}
var SlTooltip = class extends ShoelaceElement {
  constructor() {
    super(), this.localize = new LocalizeController(this), this.content = "", this.placement = "top", this.disabled = !1, this.distance = 8, this.open = !1, this.skidding = 0, this.trigger = "hover focus", this.hoist = !1, this.handleBlur = () => {
      this.hasTrigger("focus") && this.hide();
    }, this.handleClick = () => {
      this.hasTrigger("click") && (this.open ? this.hide() : this.show());
    }, this.handleFocus = () => {
      this.hasTrigger("focus") && this.show();
    }, this.handleDocumentKeyDown = (z) => {
      z.key === "Escape" && (z.stopPropagation(), this.hide());
    }, this.handleMouseOver = () => {
      if (this.hasTrigger("hover")) {
        const z = parseDuration(getComputedStyle(this).getPropertyValue("--show-delay"));
        clearTimeout(this.hoverTimeout), this.hoverTimeout = window.setTimeout(() => this.show(), z);
      }
    }, this.handleMouseOut = () => {
      if (this.hasTrigger("hover")) {
        const z = parseDuration(getComputedStyle(this).getPropertyValue("--hide-delay"));
        clearTimeout(this.hoverTimeout), this.hoverTimeout = window.setTimeout(() => this.hide(), z);
      }
    }, this.addEventListener("blur", this.handleBlur, !0), this.addEventListener("focus", this.handleFocus, !0), this.addEventListener("click", this.handleClick), this.addEventListener("mouseover", this.handleMouseOver), this.addEventListener("mouseout", this.handleMouseOut);
  }
  disconnectedCallback() {
    var z;
    (z = this.closeWatcher) == null || z.destroy(), document.removeEventListener("keydown", this.handleDocumentKeyDown);
  }
  firstUpdated() {
    this.body.hidden = !this.open, this.open && (this.popup.active = !0, this.popup.reposition());
  }
  hasTrigger(z) {
    return this.trigger.split(" ").includes(z);
  }
  async handleOpenChange() {
    var z, D;
    if (this.open) {
      if (this.disabled)
        return;
      this.emit("sl-show"), "CloseWatcher" in window ? ((z = this.closeWatcher) == null || z.destroy(), this.closeWatcher = new CloseWatcher(), this.closeWatcher.onclose = () => {
        this.hide();
      }) : document.addEventListener("keydown", this.handleDocumentKeyDown), await stopAnimations(this.body), this.body.hidden = !1, this.popup.active = !0;
      const { keyframes: O, options: F } = getAnimation(this, "tooltip.show", { dir: this.localize.dir() });
      await animateTo(this.popup.popup, O, F), this.popup.reposition(), this.emit("sl-after-show");
    } else {
      this.emit("sl-hide"), (D = this.closeWatcher) == null || D.destroy(), document.removeEventListener("keydown", this.handleDocumentKeyDown), await stopAnimations(this.body);
      const { keyframes: O, options: F } = getAnimation(this, "tooltip.hide", { dir: this.localize.dir() });
      await animateTo(this.popup.popup, O, F), this.popup.active = !1, this.body.hidden = !0, this.emit("sl-after-hide");
    }
  }
  async handleOptionsChange() {
    this.hasUpdated && (await this.updateComplete, this.popup.reposition());
  }
  handleDisabledChange() {
    this.disabled && this.open && this.hide();
  }
  /** Shows the tooltip. */
  async show() {
    if (!this.open)
      return this.open = !0, waitForEvent(this, "sl-after-show");
  }
  /** Hides the tooltip */
  async hide() {
    if (this.open)
      return this.open = !1, waitForEvent(this, "sl-after-hide");
  }
  //
  // NOTE: Tooltip is a bit unique in that we're using aria-live instead of aria-labelledby to trick screen readers into
  // announcing the content. It works really well, but it violates an accessibility rule. We're also adding the
  // aria-describedby attribute to a slot, which is required by <sl-popup> to correctly locate the first assigned
  // element, otherwise positioning is incorrect.
  //
  render() {
    return x`
      <sl-popup
        part="base"
        exportparts="
          popup:base__popup,
          arrow:base__arrow
        "
        class=${e$2({
      tooltip: !0,
      "tooltip--open": this.open
    })}
        placement=${this.placement}
        distance=${this.distance}
        skidding=${this.skidding}
        strategy=${this.hoist ? "fixed" : "absolute"}
        flip
        shift
        arrow
        hover-bridge
      >
        ${""}
        <slot slot="anchor" aria-describedby="tooltip"></slot>

        ${""}
        <div part="body" id="tooltip" class="tooltip__body" role="tooltip" aria-live=${this.open ? "polite" : "off"}>
          <slot name="content">${this.content}</slot>
        </div>
      </sl-popup>
    `;
  }
};
SlTooltip.styles = [component_styles_default, tooltip_styles_default];
SlTooltip.dependencies = { "sl-popup": SlPopup };
__decorateClass([
  e$b("slot:not([name])")
], SlTooltip.prototype, "defaultSlot", 2);
__decorateClass([
  e$b(".tooltip__body")
], SlTooltip.prototype, "body", 2);
__decorateClass([
  e$b("sl-popup")
], SlTooltip.prototype, "popup", 2);
__decorateClass([
  n$6()
], SlTooltip.prototype, "content", 2);
__decorateClass([
  n$6()
], SlTooltip.prototype, "placement", 2);
__decorateClass([
  n$6({ type: Boolean, reflect: !0 })
], SlTooltip.prototype, "disabled", 2);
__decorateClass([
  n$6({ type: Number })
], SlTooltip.prototype, "distance", 2);
__decorateClass([
  n$6({ type: Boolean, reflect: !0 })
], SlTooltip.prototype, "open", 2);
__decorateClass([
  n$6({ type: Number })
], SlTooltip.prototype, "skidding", 2);
__decorateClass([
  n$6()
], SlTooltip.prototype, "trigger", 2);
__decorateClass([
  n$6({ type: Boolean })
], SlTooltip.prototype, "hoist", 2);
__decorateClass([
  watch("open", { waitUntilFirstUpdate: !0 })
], SlTooltip.prototype, "handleOpenChange", 1);
__decorateClass([
  watch(["content", "distance", "hoist", "placement", "skidding"])
], SlTooltip.prototype, "handleOptionsChange", 1);
__decorateClass([
  watch("disabled")
], SlTooltip.prototype, "handleDisabledChange", 1);
setDefaultAnimation("tooltip.show", {
  keyframes: [
    { opacity: 0, scale: 0.8 },
    { opacity: 1, scale: 1 }
  ],
  options: { duration: 150, easing: "ease" }
});
setDefaultAnimation("tooltip.hide", {
  keyframes: [
    { opacity: 1, scale: 1 },
    { opacity: 0, scale: 0.8 }
  ],
  options: { duration: 150, easing: "ease" }
});
SlTooltip.define("sl-tooltip");
var skeleton_styles_default = i$7`
  :host {
    --border-radius: var(--sl-border-radius-pill);
    --color: var(--sl-color-neutral-200);
    --sheen-color: var(--sl-color-neutral-300);

    display: block;
    position: relative;
  }

  .skeleton {
    display: flex;
    width: 100%;
    height: 100%;
    min-height: 1rem;
  }

  .skeleton__indicator {
    flex: 1 1 auto;
    background: var(--color);
    border-radius: var(--border-radius);
  }

  .skeleton--sheen .skeleton__indicator {
    background: linear-gradient(270deg, var(--sheen-color), var(--color), var(--color), var(--sheen-color));
    background-size: 400% 100%;
    animation: sheen 8s ease-in-out infinite;
  }

  .skeleton--pulse .skeleton__indicator {
    animation: pulse 2s ease-in-out 0.5s infinite;
  }

  /* Forced colors mode */
  @media (forced-colors: active) {
    :host {
      --color: GrayText;
    }
  }

  @keyframes sheen {
    0% {
      background-position: 200% 0;
    }
    to {
      background-position: -200% 0;
    }
  }

  @keyframes pulse {
    0% {
      opacity: 1;
    }
    50% {
      opacity: 0.4;
    }
    100% {
      opacity: 1;
    }
  }
`, SlSkeleton = class extends ShoelaceElement {
  constructor() {
    super(...arguments), this.effect = "none";
  }
  render() {
    return x`
      <div
        part="base"
        class=${e$2({
      skeleton: !0,
      "skeleton--pulse": this.effect === "pulse",
      "skeleton--sheen": this.effect === "sheen"
    })}
      >
        <div part="indicator" class="skeleton__indicator"></div>
      </div>
    `;
  }
};
SlSkeleton.styles = [component_styles_default, skeleton_styles_default];
__decorateClass([
  n$6()
], SlSkeleton.prototype, "effect", 2);
SlSkeleton.define("sl-skeleton");
var tab_group_styles_default = i$7`
  :host {
    --indicator-color: var(--sl-color-primary-600);
    --track-color: var(--sl-color-neutral-200);
    --track-width: 2px;

    display: block;
  }

  .tab-group {
    display: flex;
    border-radius: 0;
  }

  .tab-group__tabs {
    display: flex;
    position: relative;
  }

  .tab-group__indicator {
    position: absolute;
    transition:
      var(--sl-transition-fast) translate ease,
      var(--sl-transition-fast) width ease;
  }

  .tab-group--has-scroll-controls .tab-group__nav-container {
    position: relative;
    padding: 0 var(--sl-spacing-x-large);
  }

  .tab-group__body {
    display: block;
    overflow: auto;
  }

  .tab-group__scroll-button {
    display: flex;
    align-items: center;
    justify-content: center;
    position: absolute;
    top: 0;
    bottom: 0;
    width: var(--sl-spacing-x-large);
  }

  .tab-group__scroll-button--start {
    left: 0;
  }

  .tab-group__scroll-button--end {
    right: 0;
  }

  .tab-group--rtl .tab-group__scroll-button--start {
    left: auto;
    right: 0;
  }

  .tab-group--rtl .tab-group__scroll-button--end {
    left: 0;
    right: auto;
  }

  /*
   * Top
   */

  .tab-group--top {
    flex-direction: column;
  }

  .tab-group--top .tab-group__nav-container {
    order: 1;
  }

  .tab-group--top .tab-group__nav {
    display: flex;
    overflow-x: auto;

    /* Hide scrollbar in Firefox */
    scrollbar-width: none;
  }

  /* Hide scrollbar in Chrome/Safari */
  .tab-group--top .tab-group__nav::-webkit-scrollbar {
    width: 0;
    height: 0;
  }

  .tab-group--top .tab-group__tabs {
    flex: 1 1 auto;
    position: relative;
    flex-direction: row;
    border-bottom: solid var(--track-width) var(--track-color);
  }

  .tab-group--top .tab-group__indicator {
    bottom: calc(-1 * var(--track-width));
    border-bottom: solid var(--track-width) var(--indicator-color);
  }

  .tab-group--top .tab-group__body {
    order: 2;
  }

  .tab-group--top ::slotted(sl-tab-panel) {
    --padding: var(--sl-spacing-medium) 0;
  }

  /*
   * Bottom
   */

  .tab-group--bottom {
    flex-direction: column;
  }

  .tab-group--bottom .tab-group__nav-container {
    order: 2;
  }

  .tab-group--bottom .tab-group__nav {
    display: flex;
    overflow-x: auto;

    /* Hide scrollbar in Firefox */
    scrollbar-width: none;
  }

  /* Hide scrollbar in Chrome/Safari */
  .tab-group--bottom .tab-group__nav::-webkit-scrollbar {
    width: 0;
    height: 0;
  }

  .tab-group--bottom .tab-group__tabs {
    flex: 1 1 auto;
    position: relative;
    flex-direction: row;
    border-top: solid var(--track-width) var(--track-color);
  }

  .tab-group--bottom .tab-group__indicator {
    top: calc(-1 * var(--track-width));
    border-top: solid var(--track-width) var(--indicator-color);
  }

  .tab-group--bottom .tab-group__body {
    order: 1;
  }

  .tab-group--bottom ::slotted(sl-tab-panel) {
    --padding: var(--sl-spacing-medium) 0;
  }

  /*
   * Start
   */

  .tab-group--start {
    flex-direction: row;
  }

  .tab-group--start .tab-group__nav-container {
    order: 1;
  }

  .tab-group--start .tab-group__tabs {
    flex: 0 0 auto;
    flex-direction: column;
    border-inline-end: solid var(--track-width) var(--track-color);
  }

  .tab-group--start .tab-group__indicator {
    right: calc(-1 * var(--track-width));
    border-right: solid var(--track-width) var(--indicator-color);
  }

  .tab-group--start.tab-group--rtl .tab-group__indicator {
    right: auto;
    left: calc(-1 * var(--track-width));
  }

  .tab-group--start .tab-group__body {
    flex: 1 1 auto;
    order: 2;
  }

  .tab-group--start ::slotted(sl-tab-panel) {
    --padding: 0 var(--sl-spacing-medium);
  }

  /*
   * End
   */

  .tab-group--end {
    flex-direction: row;
  }

  .tab-group--end .tab-group__nav-container {
    order: 2;
  }

  .tab-group--end .tab-group__tabs {
    flex: 0 0 auto;
    flex-direction: column;
    border-left: solid var(--track-width) var(--track-color);
  }

  .tab-group--end .tab-group__indicator {
    left: calc(-1 * var(--track-width));
    border-inline-start: solid var(--track-width) var(--indicator-color);
  }

  .tab-group--end.tab-group--rtl .tab-group__indicator {
    right: calc(-1 * var(--track-width));
    left: auto;
  }

  .tab-group--end .tab-group__body {
    flex: 1 1 auto;
    order: 1;
  }

  .tab-group--end ::slotted(sl-tab-panel) {
    --padding: 0 var(--sl-spacing-medium);
  }
`;
function getOffset(z, D) {
  return {
    top: Math.round(z.getBoundingClientRect().top - D.getBoundingClientRect().top),
    left: Math.round(z.getBoundingClientRect().left - D.getBoundingClientRect().left)
  };
}
var locks = /* @__PURE__ */ new Set();
function getScrollbarWidth() {
  const z = document.documentElement.clientWidth;
  return Math.abs(window.innerWidth - z);
}
function getExistingBodyPadding() {
  const z = Number(getComputedStyle(document.body).paddingRight.replace(/px/, ""));
  return isNaN(z) || !z ? 0 : z;
}
function lockBodyScrolling(z) {
  if (locks.add(z), !document.documentElement.classList.contains("sl-scroll-lock")) {
    const D = getScrollbarWidth() + getExistingBodyPadding();
    let O = getComputedStyle(document.documentElement).scrollbarGutter;
    (!O || O === "auto") && (O = "stable"), D <= 0 && (O = "revert"), document.documentElement.style.setProperty("--sl-scroll-lock-gutter", O), document.documentElement.classList.add("sl-scroll-lock"), document.documentElement.style.setProperty("--sl-scroll-lock-size", `${D}px`);
  }
}
function unlockBodyScrolling(z) {
  locks.delete(z), locks.size === 0 && (document.documentElement.classList.remove("sl-scroll-lock"), document.documentElement.style.removeProperty("--sl-scroll-lock-size"));
}
function scrollIntoView(z, D, O = "vertical", F = "smooth") {
  const U = getOffset(z, D), W = U.top + D.scrollTop, B = U.left + D.scrollLeft, K = D.scrollLeft, X = D.scrollLeft + D.offsetWidth, Y = D.scrollTop, Q = D.scrollTop + D.offsetHeight;
  (O === "horizontal" || O === "both") && (B < K ? D.scrollTo({ left: B, behavior: F }) : B + z.clientWidth > X && D.scrollTo({ left: B - D.offsetWidth + z.clientWidth, behavior: F })), (O === "vertical" || O === "both") && (W < Y ? D.scrollTo({ top: W, behavior: F }) : W + z.clientHeight > Q && D.scrollTo({ top: W - D.offsetHeight + z.clientHeight, behavior: F }));
}
var SlTabGroup = class extends ShoelaceElement {
  constructor() {
    super(...arguments), this.localize = new LocalizeController(this), this.tabs = [], this.panels = [], this.hasScrollControls = !1, this.placement = "top", this.activation = "auto", this.noScrollControls = !1;
  }
  connectedCallback() {
    const z = Promise.all([
      customElements.whenDefined("sl-tab"),
      customElements.whenDefined("sl-tab-panel")
    ]);
    super.connectedCallback(), this.resizeObserver = new ResizeObserver(() => {
      this.repositionIndicator(), this.updateScrollControls();
    }), this.mutationObserver = new MutationObserver((D) => {
      D.some((O) => !["aria-labelledby", "aria-controls"].includes(O.attributeName)) && setTimeout(() => this.setAriaLabels()), D.some((O) => O.attributeName === "disabled") && this.syncTabsAndPanels();
    }), this.updateComplete.then(() => {
      this.syncTabsAndPanels(), this.mutationObserver.observe(this, { attributes: !0, childList: !0, subtree: !0 }), this.resizeObserver.observe(this.nav), z.then(() => {
        new IntersectionObserver((O, F) => {
          var U;
          O[0].intersectionRatio > 0 && (this.setAriaLabels(), this.setActiveTab((U = this.getActiveTab()) != null ? U : this.tabs[0], { emitEvents: !1 }), F.unobserve(O[0].target));
        }).observe(this.tabGroup);
      });
    });
  }
  disconnectedCallback() {
    super.disconnectedCallback(), this.mutationObserver.disconnect(), this.resizeObserver.unobserve(this.nav);
  }
  getAllTabs(z = { includeDisabled: !0 }) {
    return [...this.shadowRoot.querySelector('slot[name="nav"]').assignedElements()].filter((O) => z.includeDisabled ? O.tagName.toLowerCase() === "sl-tab" : O.tagName.toLowerCase() === "sl-tab" && !O.disabled);
  }
  getAllPanels() {
    return [...this.body.assignedElements()].filter((z) => z.tagName.toLowerCase() === "sl-tab-panel");
  }
  getActiveTab() {
    return this.tabs.find((z) => z.active);
  }
  handleClick(z) {
    const O = z.target.closest("sl-tab");
    (O == null ? void 0 : O.closest("sl-tab-group")) === this && O !== null && this.setActiveTab(O, { scrollBehavior: "smooth" });
  }
  handleKeyDown(z) {
    const O = z.target.closest("sl-tab");
    if ((O == null ? void 0 : O.closest("sl-tab-group")) === this && (["Enter", " "].includes(z.key) && O !== null && (this.setActiveTab(O, { scrollBehavior: "smooth" }), z.preventDefault()), ["ArrowLeft", "ArrowRight", "ArrowUp", "ArrowDown", "Home", "End"].includes(z.key))) {
      const U = this.tabs.find((B) => B.matches(":focus")), W = this.localize.dir() === "rtl";
      if ((U == null ? void 0 : U.tagName.toLowerCase()) === "sl-tab") {
        let B = this.tabs.indexOf(U);
        z.key === "Home" ? B = 0 : z.key === "End" ? B = this.tabs.length - 1 : ["top", "bottom"].includes(this.placement) && z.key === (W ? "ArrowRight" : "ArrowLeft") || ["start", "end"].includes(this.placement) && z.key === "ArrowUp" ? B-- : (["top", "bottom"].includes(this.placement) && z.key === (W ? "ArrowLeft" : "ArrowRight") || ["start", "end"].includes(this.placement) && z.key === "ArrowDown") && B++, B < 0 && (B = this.tabs.length - 1), B > this.tabs.length - 1 && (B = 0), this.tabs[B].focus({ preventScroll: !0 }), this.activation === "auto" && this.setActiveTab(this.tabs[B], { scrollBehavior: "smooth" }), ["top", "bottom"].includes(this.placement) && scrollIntoView(this.tabs[B], this.nav, "horizontal"), z.preventDefault();
      }
    }
  }
  handleScrollToStart() {
    this.nav.scroll({
      left: this.localize.dir() === "rtl" ? this.nav.scrollLeft + this.nav.clientWidth : this.nav.scrollLeft - this.nav.clientWidth,
      behavior: "smooth"
    });
  }
  handleScrollToEnd() {
    this.nav.scroll({
      left: this.localize.dir() === "rtl" ? this.nav.scrollLeft - this.nav.clientWidth : this.nav.scrollLeft + this.nav.clientWidth,
      behavior: "smooth"
    });
  }
  setActiveTab(z, D) {
    if (D = __spreadValues({
      emitEvents: !0,
      scrollBehavior: "auto"
    }, D), z !== this.activeTab && !z.disabled) {
      const O = this.activeTab;
      this.activeTab = z, this.tabs.forEach((F) => F.active = F === this.activeTab), this.panels.forEach((F) => {
        var U;
        return F.active = F.name === ((U = this.activeTab) == null ? void 0 : U.panel);
      }), this.syncIndicator(), ["top", "bottom"].includes(this.placement) && scrollIntoView(this.activeTab, this.nav, "horizontal", D.scrollBehavior), D.emitEvents && (O && this.emit("sl-tab-hide", { detail: { name: O.panel } }), this.emit("sl-tab-show", { detail: { name: this.activeTab.panel } }));
    }
  }
  setAriaLabels() {
    this.tabs.forEach((z) => {
      const D = this.panels.find((O) => O.name === z.panel);
      D && (z.setAttribute("aria-controls", D.getAttribute("id")), D.setAttribute("aria-labelledby", z.getAttribute("id")));
    });
  }
  repositionIndicator() {
    const z = this.getActiveTab();
    if (!z)
      return;
    const D = z.clientWidth, O = z.clientHeight, F = this.localize.dir() === "rtl", U = this.getAllTabs(), B = U.slice(0, U.indexOf(z)).reduce(
      (K, X) => ({
        left: K.left + X.clientWidth,
        top: K.top + X.clientHeight
      }),
      { left: 0, top: 0 }
    );
    switch (this.placement) {
      case "top":
      case "bottom":
        this.indicator.style.width = `${D}px`, this.indicator.style.height = "auto", this.indicator.style.translate = F ? `${-1 * B.left}px` : `${B.left}px`;
        break;
      case "start":
      case "end":
        this.indicator.style.width = "auto", this.indicator.style.height = `${O}px`, this.indicator.style.translate = `0 ${B.top}px`;
        break;
    }
  }
  // This stores tabs and panels so we can refer to a cache instead of calling querySelectorAll() multiple times.
  syncTabsAndPanels() {
    this.tabs = this.getAllTabs({ includeDisabled: !1 }), this.panels = this.getAllPanels(), this.syncIndicator(), this.updateComplete.then(() => this.updateScrollControls());
  }
  updateScrollControls() {
    this.noScrollControls ? this.hasScrollControls = !1 : this.hasScrollControls = ["top", "bottom"].includes(this.placement) && this.nav.scrollWidth > this.nav.clientWidth + 1;
  }
  syncIndicator() {
    this.getActiveTab() ? (this.indicator.style.display = "block", this.repositionIndicator()) : this.indicator.style.display = "none";
  }
  /** Shows the specified tab panel. */
  show(z) {
    const D = this.tabs.find((O) => O.panel === z);
    D && this.setActiveTab(D, { scrollBehavior: "smooth" });
  }
  render() {
    const z = this.localize.dir() === "rtl";
    return x`
      <div
        part="base"
        class=${e$2({
      "tab-group": !0,
      "tab-group--top": this.placement === "top",
      "tab-group--bottom": this.placement === "bottom",
      "tab-group--start": this.placement === "start",
      "tab-group--end": this.placement === "end",
      "tab-group--rtl": this.localize.dir() === "rtl",
      "tab-group--has-scroll-controls": this.hasScrollControls
    })}
        @click=${this.handleClick}
        @keydown=${this.handleKeyDown}
      >
        <div class="tab-group__nav-container" part="nav">
          ${this.hasScrollControls ? x`
                <sl-icon-button
                  part="scroll-button scroll-button--start"
                  exportparts="base:scroll-button__base"
                  class="tab-group__scroll-button tab-group__scroll-button--start"
                  name=${z ? "chevron-right" : "chevron-left"}
                  library="system"
                  label=${this.localize.term("scrollToStart")}
                  @click=${this.handleScrollToStart}
                ></sl-icon-button>
              ` : ""}

          <div class="tab-group__nav">
            <div part="tabs" class="tab-group__tabs" role="tablist">
              <div part="active-tab-indicator" class="tab-group__indicator"></div>
              <slot name="nav" @slotchange=${this.syncTabsAndPanels}></slot>
            </div>
          </div>

          ${this.hasScrollControls ? x`
                <sl-icon-button
                  part="scroll-button scroll-button--end"
                  exportparts="base:scroll-button__base"
                  class="tab-group__scroll-button tab-group__scroll-button--end"
                  name=${z ? "chevron-left" : "chevron-right"}
                  library="system"
                  label=${this.localize.term("scrollToEnd")}
                  @click=${this.handleScrollToEnd}
                ></sl-icon-button>
              ` : ""}
        </div>

        <slot part="body" class="tab-group__body" @slotchange=${this.syncTabsAndPanels}></slot>
      </div>
    `;
  }
};
SlTabGroup.styles = [component_styles_default, tab_group_styles_default];
SlTabGroup.dependencies = { "sl-icon-button": SlIconButton };
__decorateClass([
  e$b(".tab-group")
], SlTabGroup.prototype, "tabGroup", 2);
__decorateClass([
  e$b(".tab-group__body")
], SlTabGroup.prototype, "body", 2);
__decorateClass([
  e$b(".tab-group__nav")
], SlTabGroup.prototype, "nav", 2);
__decorateClass([
  e$b(".tab-group__indicator")
], SlTabGroup.prototype, "indicator", 2);
__decorateClass([
  r$4()
], SlTabGroup.prototype, "hasScrollControls", 2);
__decorateClass([
  n$6()
], SlTabGroup.prototype, "placement", 2);
__decorateClass([
  n$6()
], SlTabGroup.prototype, "activation", 2);
__decorateClass([
  n$6({ attribute: "no-scroll-controls", type: Boolean })
], SlTabGroup.prototype, "noScrollControls", 2);
__decorateClass([
  watch("noScrollControls", { waitUntilFirstUpdate: !0 })
], SlTabGroup.prototype, "updateScrollControls", 1);
__decorateClass([
  watch("placement", { waitUntilFirstUpdate: !0 })
], SlTabGroup.prototype, "syncIndicator", 1);
SlTabGroup.define("sl-tab-group");
var split_panel_styles_default = i$7`
  :host {
    --divider-width: 4px;
    --divider-hit-area: 12px;
    --min: 0%;
    --max: 100%;

    display: grid;
  }

  .start,
  .end {
    overflow: hidden;
  }

  .divider {
    flex: 0 0 var(--divider-width);
    display: flex;
    position: relative;
    align-items: center;
    justify-content: center;
    background-color: var(--sl-color-neutral-200);
    color: var(--sl-color-neutral-900);
    z-index: 1;
  }

  .divider:focus {
    outline: none;
  }

  :host(:not([disabled])) .divider:focus-visible {
    background-color: var(--sl-color-primary-600);
    color: var(--sl-color-neutral-0);
  }

  :host([disabled]) .divider {
    cursor: not-allowed;
  }

  /* Horizontal */
  :host(:not([vertical], [disabled])) .divider {
    cursor: col-resize;
  }

  :host(:not([vertical])) .divider::after {
    display: flex;
    content: '';
    position: absolute;
    height: 100%;
    left: calc(var(--divider-hit-area) / -2 + var(--divider-width) / 2);
    width: var(--divider-hit-area);
  }

  /* Vertical */
  :host([vertical]) {
    flex-direction: column;
  }

  :host([vertical]:not([disabled])) .divider {
    cursor: row-resize;
  }

  :host([vertical]) .divider::after {
    content: '';
    position: absolute;
    width: 100%;
    top: calc(var(--divider-hit-area) / -2 + var(--divider-width) / 2);
    height: var(--divider-hit-area);
  }

  @media (forced-colors: active) {
    .divider {
      outline: solid 1px transparent;
    }
  }
`;
function drag(z, D) {
  function O(U) {
    const W = z.getBoundingClientRect(), B = z.ownerDocument.defaultView, K = W.left + B.scrollX, X = W.top + B.scrollY, Y = U.pageX - K, Q = U.pageY - X;
    D != null && D.onMove && D.onMove(Y, Q);
  }
  function F() {
    document.removeEventListener("pointermove", O), document.removeEventListener("pointerup", F), D != null && D.onStop && D.onStop();
  }
  document.addEventListener("pointermove", O, { passive: !0 }), document.addEventListener("pointerup", F), (D == null ? void 0 : D.initialEvent) instanceof PointerEvent && O(D.initialEvent);
}
var SlSplitPanel = class extends ShoelaceElement {
  constructor() {
    super(...arguments), this.localize = new LocalizeController(this), this.position = 50, this.vertical = !1, this.disabled = !1, this.snapThreshold = 12;
  }
  connectedCallback() {
    super.connectedCallback(), this.resizeObserver = new ResizeObserver((z) => this.handleResize(z)), this.updateComplete.then(() => this.resizeObserver.observe(this)), this.detectSize(), this.cachedPositionInPixels = this.percentageToPixels(this.position);
  }
  disconnectedCallback() {
    super.disconnectedCallback(), this.resizeObserver.unobserve(this);
  }
  detectSize() {
    const { width: z, height: D } = this.getBoundingClientRect();
    this.size = this.vertical ? D : z;
  }
  percentageToPixels(z) {
    return this.size * (z / 100);
  }
  pixelsToPercentage(z) {
    return z / this.size * 100;
  }
  handleDrag(z) {
    const D = this.localize.dir() === "rtl";
    this.disabled || (z.cancelable && z.preventDefault(), drag(this, {
      onMove: (O, F) => {
        let U = this.vertical ? F : O;
        this.primary === "end" && (U = this.size - U), this.snap && this.snap.split(" ").forEach((B) => {
          let K;
          B.endsWith("%") ? K = this.size * (parseFloat(B) / 100) : K = parseFloat(B), D && !this.vertical && (K = this.size - K), U >= K - this.snapThreshold && U <= K + this.snapThreshold && (U = K);
        }), this.position = clamp$1(this.pixelsToPercentage(U), 0, 100);
      },
      initialEvent: z
    }));
  }
  handleKeyDown(z) {
    if (!this.disabled && ["ArrowLeft", "ArrowRight", "ArrowUp", "ArrowDown", "Home", "End"].includes(z.key)) {
      let D = this.position;
      const O = (z.shiftKey ? 10 : 1) * (this.primary === "end" ? -1 : 1);
      z.preventDefault(), (z.key === "ArrowLeft" && !this.vertical || z.key === "ArrowUp" && this.vertical) && (D -= O), (z.key === "ArrowRight" && !this.vertical || z.key === "ArrowDown" && this.vertical) && (D += O), z.key === "Home" && (D = this.primary === "end" ? 100 : 0), z.key === "End" && (D = this.primary === "end" ? 0 : 100), this.position = clamp$1(D, 0, 100);
    }
  }
  handleResize(z) {
    const { width: D, height: O } = z[0].contentRect;
    this.size = this.vertical ? O : D, (isNaN(this.cachedPositionInPixels) || this.position === 1 / 0) && (this.cachedPositionInPixels = Number(this.getAttribute("position-in-pixels")), this.positionInPixels = Number(this.getAttribute("position-in-pixels")), this.position = this.pixelsToPercentage(this.positionInPixels)), this.primary && (this.position = this.pixelsToPercentage(this.cachedPositionInPixels));
  }
  handlePositionChange() {
    this.cachedPositionInPixels = this.percentageToPixels(this.position), this.positionInPixels = this.percentageToPixels(this.position), this.emit("sl-reposition");
  }
  handlePositionInPixelsChange() {
    this.position = this.pixelsToPercentage(this.positionInPixels);
  }
  handleVerticalChange() {
    this.detectSize();
  }
  render() {
    const z = this.vertical ? "gridTemplateRows" : "gridTemplateColumns", D = this.vertical ? "gridTemplateColumns" : "gridTemplateRows", O = this.localize.dir() === "rtl", F = `
      clamp(
        0%,
        clamp(
          var(--min),
          ${this.position}% - var(--divider-width) / 2,
          var(--max)
        ),
        calc(100% - var(--divider-width))
      )
    `, U = "auto";
    return this.primary === "end" ? O && !this.vertical ? this.style[z] = `${F} var(--divider-width) ${U}` : this.style[z] = `${U} var(--divider-width) ${F}` : O && !this.vertical ? this.style[z] = `${U} var(--divider-width) ${F}` : this.style[z] = `${F} var(--divider-width) ${U}`, this.style[D] = "", x`
      <slot name="start" part="panel start" class="start"></slot>

      <div
        part="divider"
        class="divider"
        tabindex=${o$6(this.disabled ? void 0 : "0")}
        role="separator"
        aria-valuenow=${this.position}
        aria-valuemin="0"
        aria-valuemax="100"
        aria-label=${this.localize.term("resize")}
        @keydown=${this.handleKeyDown}
        @mousedown=${this.handleDrag}
        @touchstart=${this.handleDrag}
      >
        <slot name="divider"></slot>
      </div>

      <slot name="end" part="panel end" class="end"></slot>
    `;
  }
};
SlSplitPanel.styles = [component_styles_default, split_panel_styles_default];
__decorateClass([
  e$b(".divider")
], SlSplitPanel.prototype, "divider", 2);
__decorateClass([
  n$6({ type: Number, reflect: !0 })
], SlSplitPanel.prototype, "position", 2);
__decorateClass([
  n$6({ attribute: "position-in-pixels", type: Number })
], SlSplitPanel.prototype, "positionInPixels", 2);
__decorateClass([
  n$6({ type: Boolean, reflect: !0 })
], SlSplitPanel.prototype, "vertical", 2);
__decorateClass([
  n$6({ type: Boolean, reflect: !0 })
], SlSplitPanel.prototype, "disabled", 2);
__decorateClass([
  n$6()
], SlSplitPanel.prototype, "primary", 2);
__decorateClass([
  n$6()
], SlSplitPanel.prototype, "snap", 2);
__decorateClass([
  n$6({ type: Number, attribute: "snap-threshold" })
], SlSplitPanel.prototype, "snapThreshold", 2);
__decorateClass([
  watch("position")
], SlSplitPanel.prototype, "handlePositionChange", 1);
__decorateClass([
  watch("positionInPixels")
], SlSplitPanel.prototype, "handlePositionInPixelsChange", 1);
__decorateClass([
  watch("vertical")
], SlSplitPanel.prototype, "handleVerticalChange", 1);
SlSplitPanel.define("sl-split-panel");
var switch_styles_default = i$7`
  :host {
    display: inline-block;
  }

  :host([size='small']) {
    --height: var(--sl-toggle-size-small);
    --thumb-size: calc(var(--sl-toggle-size-small) + 4px);
    --width: calc(var(--height) * 2);

    font-size: var(--sl-input-font-size-small);
  }

  :host([size='medium']) {
    --height: var(--sl-toggle-size-medium);
    --thumb-size: calc(var(--sl-toggle-size-medium) + 4px);
    --width: calc(var(--height) * 2);

    font-size: var(--sl-input-font-size-medium);
  }

  :host([size='large']) {
    --height: var(--sl-toggle-size-large);
    --thumb-size: calc(var(--sl-toggle-size-large) + 4px);
    --width: calc(var(--height) * 2);

    font-size: var(--sl-input-font-size-large);
  }

  .switch {
    position: relative;
    display: inline-flex;
    align-items: center;
    font-family: var(--sl-input-font-family);
    font-size: inherit;
    font-weight: var(--sl-input-font-weight);
    color: var(--sl-input-label-color);
    vertical-align: middle;
    cursor: pointer;
  }

  .switch__control {
    flex: 0 0 auto;
    position: relative;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    width: var(--width);
    height: var(--height);
    background-color: var(--sl-color-neutral-400);
    border: solid var(--sl-input-border-width) var(--sl-color-neutral-400);
    border-radius: var(--height);
    transition:
      var(--sl-transition-fast) border-color,
      var(--sl-transition-fast) background-color;
  }

  .switch__control .switch__thumb {
    width: var(--thumb-size);
    height: var(--thumb-size);
    background-color: var(--sl-color-neutral-0);
    border-radius: 50%;
    border: solid var(--sl-input-border-width) var(--sl-color-neutral-400);
    translate: calc((var(--width) - var(--height)) / -2);
    transition:
      var(--sl-transition-fast) translate ease,
      var(--sl-transition-fast) background-color,
      var(--sl-transition-fast) border-color,
      var(--sl-transition-fast) box-shadow;
  }

  .switch__input {
    position: absolute;
    opacity: 0;
    padding: 0;
    margin: 0;
    pointer-events: none;
  }

  /* Hover */
  .switch:not(.switch--checked):not(.switch--disabled) .switch__control:hover {
    background-color: var(--sl-color-neutral-400);
    border-color: var(--sl-color-neutral-400);
  }

  .switch:not(.switch--checked):not(.switch--disabled) .switch__control:hover .switch__thumb {
    background-color: var(--sl-color-neutral-0);
    border-color: var(--sl-color-neutral-400);
  }

  /* Focus */
  .switch:not(.switch--checked):not(.switch--disabled) .switch__input:focus-visible ~ .switch__control {
    background-color: var(--sl-color-neutral-400);
    border-color: var(--sl-color-neutral-400);
  }

  .switch:not(.switch--checked):not(.switch--disabled) .switch__input:focus-visible ~ .switch__control .switch__thumb {
    background-color: var(--sl-color-neutral-0);
    border-color: var(--sl-color-primary-600);
    outline: var(--sl-focus-ring);
    outline-offset: var(--sl-focus-ring-offset);
  }

  /* Checked */
  .switch--checked .switch__control {
    background-color: var(--sl-color-primary-600);
    border-color: var(--sl-color-primary-600);
  }

  .switch--checked .switch__control .switch__thumb {
    background-color: var(--sl-color-neutral-0);
    border-color: var(--sl-color-primary-600);
    translate: calc((var(--width) - var(--height)) / 2);
  }

  /* Checked + hover */
  .switch.switch--checked:not(.switch--disabled) .switch__control:hover {
    background-color: var(--sl-color-primary-600);
    border-color: var(--sl-color-primary-600);
  }

  .switch.switch--checked:not(.switch--disabled) .switch__control:hover .switch__thumb {
    background-color: var(--sl-color-neutral-0);
    border-color: var(--sl-color-primary-600);
  }

  /* Checked + focus */
  .switch.switch--checked:not(.switch--disabled) .switch__input:focus-visible ~ .switch__control {
    background-color: var(--sl-color-primary-600);
    border-color: var(--sl-color-primary-600);
  }

  .switch.switch--checked:not(.switch--disabled) .switch__input:focus-visible ~ .switch__control .switch__thumb {
    background-color: var(--sl-color-neutral-0);
    border-color: var(--sl-color-primary-600);
    outline: var(--sl-focus-ring);
    outline-offset: var(--sl-focus-ring-offset);
  }

  /* Disabled */
  .switch--disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }

  .switch__label {
    display: inline-block;
    line-height: var(--height);
    margin-inline-start: 0.5em;
    user-select: none;
    -webkit-user-select: none;
  }

  :host([required]) .switch__label::after {
    content: var(--sl-input-required-content);
    color: var(--sl-input-required-content-color);
    margin-inline-start: var(--sl-input-required-content-offset);
  }

  @media (forced-colors: active) {
    .switch.switch--checked:not(.switch--disabled) .switch__control:hover .switch__thumb,
    .switch--checked .switch__control .switch__thumb {
      background-color: ButtonText;
    }
  }
`, SlSwitch = class extends ShoelaceElement {
  constructor() {
    super(...arguments), this.formControlController = new FormControlController(this, {
      value: (z) => z.checked ? z.value || "on" : void 0,
      defaultValue: (z) => z.defaultChecked,
      setValue: (z, D) => z.checked = D
    }), this.hasSlotController = new HasSlotController(this, "help-text"), this.hasFocus = !1, this.title = "", this.name = "", this.size = "medium", this.disabled = !1, this.checked = !1, this.defaultChecked = !1, this.form = "", this.required = !1, this.helpText = "";
  }
  /** Gets the validity state object */
  get validity() {
    return this.input.validity;
  }
  /** Gets the validation message */
  get validationMessage() {
    return this.input.validationMessage;
  }
  firstUpdated() {
    this.formControlController.updateValidity();
  }
  handleBlur() {
    this.hasFocus = !1, this.emit("sl-blur");
  }
  handleInput() {
    this.emit("sl-input");
  }
  handleInvalid(z) {
    this.formControlController.setValidity(!1), this.formControlController.emitInvalidEvent(z);
  }
  handleClick() {
    this.checked = !this.checked, this.emit("sl-change");
  }
  handleFocus() {
    this.hasFocus = !0, this.emit("sl-focus");
  }
  handleKeyDown(z) {
    z.key === "ArrowLeft" && (z.preventDefault(), this.checked = !1, this.emit("sl-change"), this.emit("sl-input")), z.key === "ArrowRight" && (z.preventDefault(), this.checked = !0, this.emit("sl-change"), this.emit("sl-input"));
  }
  handleCheckedChange() {
    this.input.checked = this.checked, this.formControlController.updateValidity();
  }
  handleDisabledChange() {
    this.formControlController.setValidity(!0);
  }
  /** Simulates a click on the switch. */
  click() {
    this.input.click();
  }
  /** Sets focus on the switch. */
  focus(z) {
    this.input.focus(z);
  }
  /** Removes focus from the switch. */
  blur() {
    this.input.blur();
  }
  /** Checks for validity but does not show a validation message. Returns `true` when valid and `false` when invalid. */
  checkValidity() {
    return this.input.checkValidity();
  }
  /** Gets the associated form, if one exists. */
  getForm() {
    return this.formControlController.getForm();
  }
  /** Checks for validity and shows the browser's validation message if the control is invalid. */
  reportValidity() {
    return this.input.reportValidity();
  }
  /** Sets a custom validation message. Pass an empty string to restore validity. */
  setCustomValidity(z) {
    this.input.setCustomValidity(z), this.formControlController.updateValidity();
  }
  render() {
    const z = this.hasSlotController.test("help-text"), D = this.helpText ? !0 : !!z;
    return x`
      <div
        class=${e$2({
      "form-control": !0,
      "form-control--small": this.size === "small",
      "form-control--medium": this.size === "medium",
      "form-control--large": this.size === "large",
      "form-control--has-help-text": D
    })}
      >
        <label
          part="base"
          class=${e$2({
      switch: !0,
      "switch--checked": this.checked,
      "switch--disabled": this.disabled,
      "switch--focused": this.hasFocus,
      "switch--small": this.size === "small",
      "switch--medium": this.size === "medium",
      "switch--large": this.size === "large"
    })}
        >
          <input
            class="switch__input"
            type="checkbox"
            title=${this.title}
            name=${this.name}
            value=${o$6(this.value)}
            .checked=${l$1(this.checked)}
            .disabled=${this.disabled}
            .required=${this.required}
            role="switch"
            aria-checked=${this.checked ? "true" : "false"}
            aria-describedby="help-text"
            @click=${this.handleClick}
            @input=${this.handleInput}
            @invalid=${this.handleInvalid}
            @blur=${this.handleBlur}
            @focus=${this.handleFocus}
            @keydown=${this.handleKeyDown}
          />

          <span part="control" class="switch__control">
            <span part="thumb" class="switch__thumb"></span>
          </span>

          <div part="label" class="switch__label">
            <slot></slot>
          </div>
        </label>

        <div
          aria-hidden=${D ? "false" : "true"}
          class="form-control__help-text"
          id="help-text"
          part="form-control-help-text"
        >
          <slot name="help-text">${this.helpText}</slot>
        </div>
      </div>
    `;
  }
};
SlSwitch.styles = [component_styles_default, form_control_styles_default, switch_styles_default];
__decorateClass([
  e$b('input[type="checkbox"]')
], SlSwitch.prototype, "input", 2);
__decorateClass([
  r$4()
], SlSwitch.prototype, "hasFocus", 2);
__decorateClass([
  n$6()
], SlSwitch.prototype, "title", 2);
__decorateClass([
  n$6()
], SlSwitch.prototype, "name", 2);
__decorateClass([
  n$6()
], SlSwitch.prototype, "value", 2);
__decorateClass([
  n$6({ reflect: !0 })
], SlSwitch.prototype, "size", 2);
__decorateClass([
  n$6({ type: Boolean, reflect: !0 })
], SlSwitch.prototype, "disabled", 2);
__decorateClass([
  n$6({ type: Boolean, reflect: !0 })
], SlSwitch.prototype, "checked", 2);
__decorateClass([
  defaultValue("checked")
], SlSwitch.prototype, "defaultChecked", 2);
__decorateClass([
  n$6({ reflect: !0 })
], SlSwitch.prototype, "form", 2);
__decorateClass([
  n$6({ type: Boolean, reflect: !0 })
], SlSwitch.prototype, "required", 2);
__decorateClass([
  n$6({ attribute: "help-text" })
], SlSwitch.prototype, "helpText", 2);
__decorateClass([
  watch("checked", { waitUntilFirstUpdate: !0 })
], SlSwitch.prototype, "handleCheckedChange", 1);
__decorateClass([
  watch("disabled", { waitUntilFirstUpdate: !0 })
], SlSwitch.prototype, "handleDisabledChange", 1);
SlSwitch.define("sl-switch");
var tab_styles_default = i$7`
  :host {
    display: inline-block;
  }

  .tab {
    display: inline-flex;
    align-items: center;
    font-family: var(--sl-font-sans);
    font-size: var(--sl-font-size-small);
    font-weight: var(--sl-font-weight-semibold);
    border-radius: var(--sl-border-radius-medium);
    color: var(--sl-color-neutral-600);
    padding: var(--sl-spacing-medium) var(--sl-spacing-large);
    white-space: nowrap;
    user-select: none;
    -webkit-user-select: none;
    cursor: pointer;
    transition:
      var(--transition-speed) box-shadow,
      var(--transition-speed) color;
  }

  .tab:hover:not(.tab--disabled) {
    color: var(--sl-color-primary-600);
  }

  .tab:focus {
    outline: none;
  }

  .tab:focus-visible:not(.tab--disabled) {
    color: var(--sl-color-primary-600);
  }

  .tab:focus-visible {
    outline: var(--sl-focus-ring);
    outline-offset: calc(-1 * var(--sl-focus-ring-width) - var(--sl-focus-ring-offset));
  }

  .tab.tab--active:not(.tab--disabled) {
    color: var(--sl-color-primary-600);
  }

  .tab.tab--closable {
    padding-inline-end: var(--sl-spacing-small);
  }

  .tab.tab--disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }

  .tab__close-button {
    font-size: var(--sl-font-size-small);
    margin-inline-start: var(--sl-spacing-small);
  }

  .tab__close-button::part(base) {
    padding: var(--sl-spacing-3x-small);
  }

  @media (forced-colors: active) {
    .tab.tab--active:not(.tab--disabled) {
      outline: solid 1px transparent;
      outline-offset: -3px;
    }
  }
`, id = 0, SlTab = class extends ShoelaceElement {
  constructor() {
    super(...arguments), this.localize = new LocalizeController(this), this.attrId = ++id, this.componentId = `sl-tab-${this.attrId}`, this.panel = "", this.active = !1, this.closable = !1, this.disabled = !1;
  }
  connectedCallback() {
    super.connectedCallback(), this.setAttribute("role", "tab");
  }
  handleCloseClick(z) {
    z.stopPropagation(), this.emit("sl-close");
  }
  handleActiveChange() {
    this.setAttribute("aria-selected", this.active ? "true" : "false");
  }
  handleDisabledChange() {
    this.setAttribute("aria-disabled", this.disabled ? "true" : "false");
  }
  /** Sets focus to the tab. */
  focus(z) {
    this.tab.focus(z);
  }
  /** Removes focus from the tab. */
  blur() {
    this.tab.blur();
  }
  render() {
    return this.id = this.id.length > 0 ? this.id : this.componentId, x`
      <div
        part="base"
        class=${e$2({
      tab: !0,
      "tab--active": this.active,
      "tab--closable": this.closable,
      "tab--disabled": this.disabled
    })}
        tabindex=${this.disabled ? "-1" : "0"}
      >
        <slot></slot>
        ${this.closable ? x`
              <sl-icon-button
                part="close-button"
                exportparts="base:close-button__base"
                name="x-lg"
                library="system"
                label=${this.localize.term("close")}
                class="tab__close-button"
                @click=${this.handleCloseClick}
                tabindex="-1"
              ></sl-icon-button>
            ` : ""}
      </div>
    `;
  }
};
SlTab.styles = [component_styles_default, tab_styles_default];
SlTab.dependencies = { "sl-icon-button": SlIconButton };
__decorateClass([
  e$b(".tab")
], SlTab.prototype, "tab", 2);
__decorateClass([
  n$6({ reflect: !0 })
], SlTab.prototype, "panel", 2);
__decorateClass([
  n$6({ type: Boolean, reflect: !0 })
], SlTab.prototype, "active", 2);
__decorateClass([
  n$6({ type: Boolean })
], SlTab.prototype, "closable", 2);
__decorateClass([
  n$6({ type: Boolean, reflect: !0 })
], SlTab.prototype, "disabled", 2);
__decorateClass([
  watch("active")
], SlTab.prototype, "handleActiveChange", 1);
__decorateClass([
  watch("disabled")
], SlTab.prototype, "handleDisabledChange", 1);
SlTab.define("sl-tab");
var availableUnits = [
  { max: 276e4, value: 6e4, unit: "minute" },
  // max 46 minutes
  { max: 72e6, value: 36e5, unit: "hour" },
  // max 20 hours
  { max: 5184e5, value: 864e5, unit: "day" },
  // max 6 days
  { max: 24192e5, value: 6048e5, unit: "week" },
  // max 28 days
  { max: 28512e6, value: 2592e6, unit: "month" },
  // max 11 months
  { max: 1 / 0, value: 31536e6, unit: "year" }
], SlRelativeTime = class extends ShoelaceElement {
  constructor() {
    super(...arguments), this.localize = new LocalizeController(this), this.isoTime = "", this.relativeTime = "", this.titleTime = "", this.date = /* @__PURE__ */ new Date(), this.format = "long", this.numeric = "auto", this.sync = !1;
  }
  disconnectedCallback() {
    super.disconnectedCallback(), clearTimeout(this.updateTimeout);
  }
  render() {
    const z = /* @__PURE__ */ new Date(), D = new Date(this.date);
    if (isNaN(D.getMilliseconds()))
      return this.relativeTime = "", this.isoTime = "", "";
    const O = D.getTime() - z.getTime(), { unit: F, value: U } = availableUnits.find((W) => Math.abs(O) < W.max);
    if (this.isoTime = D.toISOString(), this.titleTime = this.localize.date(D, {
      month: "long",
      year: "numeric",
      day: "numeric",
      hour: "numeric",
      minute: "numeric",
      timeZoneName: "short"
    }), this.relativeTime = this.localize.relativeTime(Math.round(O / U), F, {
      numeric: this.numeric,
      style: this.format
    }), clearTimeout(this.updateTimeout), this.sync) {
      let W;
      F === "minute" ? W = getTimeUntilNextUnit("second") : F === "hour" ? W = getTimeUntilNextUnit("minute") : F === "day" ? W = getTimeUntilNextUnit("hour") : W = getTimeUntilNextUnit("day"), this.updateTimeout = window.setTimeout(() => this.requestUpdate(), W);
    }
    return x` <time datetime=${this.isoTime} title=${this.titleTime}>${this.relativeTime}</time> `;
  }
};
__decorateClass([
  r$4()
], SlRelativeTime.prototype, "isoTime", 2);
__decorateClass([
  r$4()
], SlRelativeTime.prototype, "relativeTime", 2);
__decorateClass([
  r$4()
], SlRelativeTime.prototype, "titleTime", 2);
__decorateClass([
  n$6()
], SlRelativeTime.prototype, "date", 2);
__decorateClass([
  n$6()
], SlRelativeTime.prototype, "format", 2);
__decorateClass([
  n$6()
], SlRelativeTime.prototype, "numeric", 2);
__decorateClass([
  n$6({ type: Boolean })
], SlRelativeTime.prototype, "sync", 2);
function getTimeUntilNextUnit(z) {
  const O = { second: 1e3, minute: 6e4, hour: 36e5, day: 864e5 }[z];
  return O - Date.now() % O;
}
SlRelativeTime.define("sl-relative-time");
var select_styles_default = i$7`
  :host {
    display: block;
  }

  /** The popup */
  .select {
    flex: 1 1 auto;
    display: inline-flex;
    width: 100%;
    position: relative;
    vertical-align: middle;
  }

  .select::part(popup) {
    z-index: var(--sl-z-index-dropdown);
  }

  .select[data-current-placement^='top']::part(popup) {
    transform-origin: bottom;
  }

  .select[data-current-placement^='bottom']::part(popup) {
    transform-origin: top;
  }

  /* Combobox */
  .select__combobox {
    flex: 1;
    display: flex;
    width: 100%;
    min-width: 0;
    position: relative;
    align-items: center;
    justify-content: start;
    font-family: var(--sl-input-font-family);
    font-weight: var(--sl-input-font-weight);
    letter-spacing: var(--sl-input-letter-spacing);
    vertical-align: middle;
    overflow: hidden;
    cursor: pointer;
    transition:
      var(--sl-transition-fast) color,
      var(--sl-transition-fast) border,
      var(--sl-transition-fast) box-shadow,
      var(--sl-transition-fast) background-color;
  }

  .select__display-input {
    position: relative;
    width: 100%;
    font: inherit;
    border: none;
    background: none;
    color: var(--sl-input-color);
    cursor: inherit;
    overflow: hidden;
    padding: 0;
    margin: 0;
    -webkit-appearance: none;
  }

  .select__display-input::placeholder {
    color: var(--sl-input-placeholder-color);
  }

  .select:not(.select--disabled):hover .select__display-input {
    color: var(--sl-input-color-hover);
  }

  .select__display-input:focus {
    outline: none;
  }

  /* Visually hide the display input when multiple is enabled */
  .select--multiple:not(.select--placeholder-visible) .select__display-input {
    position: absolute;
    z-index: -1;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    opacity: 0;
  }

  .select__value-input {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    padding: 0;
    margin: 0;
    opacity: 0;
    z-index: -1;
  }

  .select__tags {
    display: flex;
    flex: 1;
    align-items: center;
    flex-wrap: wrap;
    margin-inline-start: var(--sl-spacing-2x-small);
  }

  .select__tags::slotted(sl-tag) {
    cursor: pointer !important;
  }

  .select--disabled .select__tags,
  .select--disabled .select__tags::slotted(sl-tag) {
    cursor: not-allowed !important;
  }

  /* Standard selects */
  .select--standard .select__combobox {
    background-color: var(--sl-input-background-color);
    border: solid var(--sl-input-border-width) var(--sl-input-border-color);
  }

  .select--standard.select--disabled .select__combobox {
    background-color: var(--sl-input-background-color-disabled);
    border-color: var(--sl-input-border-color-disabled);
    color: var(--sl-input-color-disabled);
    opacity: 0.5;
    cursor: not-allowed;
    outline: none;
  }

  .select--standard:not(.select--disabled).select--open .select__combobox,
  .select--standard:not(.select--disabled).select--focused .select__combobox {
    background-color: var(--sl-input-background-color-focus);
    border-color: var(--sl-input-border-color-focus);
    box-shadow: 0 0 0 var(--sl-focus-ring-width) var(--sl-input-focus-ring-color);
  }

  /* Filled selects */
  .select--filled .select__combobox {
    border: none;
    background-color: var(--sl-input-filled-background-color);
    color: var(--sl-input-color);
  }

  .select--filled:hover:not(.select--disabled) .select__combobox {
    background-color: var(--sl-input-filled-background-color-hover);
  }

  .select--filled.select--disabled .select__combobox {
    background-color: var(--sl-input-filled-background-color-disabled);
    opacity: 0.5;
    cursor: not-allowed;
  }

  .select--filled:not(.select--disabled).select--open .select__combobox,
  .select--filled:not(.select--disabled).select--focused .select__combobox {
    background-color: var(--sl-input-filled-background-color-focus);
    outline: var(--sl-focus-ring);
  }

  /* Sizes */
  .select--small .select__combobox {
    border-radius: var(--sl-input-border-radius-small);
    font-size: var(--sl-input-font-size-small);
    min-height: var(--sl-input-height-small);
    padding-block: 0;
    padding-inline: var(--sl-input-spacing-small);
  }

  .select--small .select__clear {
    margin-inline-start: var(--sl-input-spacing-small);
  }

  .select--small .select__prefix::slotted(*) {
    margin-inline-end: var(--sl-input-spacing-small);
  }

  .select--small.select--multiple:not(.select--placeholder-visible) .select__combobox {
    padding-block: 2px;
    padding-inline-start: 0;
  }

  .select--small .select__tags {
    gap: 2px;
  }

  .select--medium .select__combobox {
    border-radius: var(--sl-input-border-radius-medium);
    font-size: var(--sl-input-font-size-medium);
    min-height: var(--sl-input-height-medium);
    padding-block: 0;
    padding-inline: var(--sl-input-spacing-medium);
  }

  .select--medium .select__clear {
    margin-inline-start: var(--sl-input-spacing-medium);
  }

  .select--medium .select__prefix::slotted(*) {
    margin-inline-end: var(--sl-input-spacing-medium);
  }

  .select--medium.select--multiple:not(.select--placeholder-visible) .select__combobox {
    padding-inline-start: 0;
    padding-block: 3px;
  }

  .select--medium .select__tags {
    gap: 3px;
  }

  .select--large .select__combobox {
    border-radius: var(--sl-input-border-radius-large);
    font-size: var(--sl-input-font-size-large);
    min-height: var(--sl-input-height-large);
    padding-block: 0;
    padding-inline: var(--sl-input-spacing-large);
  }

  .select--large .select__clear {
    margin-inline-start: var(--sl-input-spacing-large);
  }

  .select--large .select__prefix::slotted(*) {
    margin-inline-end: var(--sl-input-spacing-large);
  }

  .select--large.select--multiple:not(.select--placeholder-visible) .select__combobox {
    padding-inline-start: 0;
    padding-block: 4px;
  }

  .select--large .select__tags {
    gap: 4px;
  }

  /* Pills */
  .select--pill.select--small .select__combobox {
    border-radius: var(--sl-input-height-small);
  }

  .select--pill.select--medium .select__combobox {
    border-radius: var(--sl-input-height-medium);
  }

  .select--pill.select--large .select__combobox {
    border-radius: var(--sl-input-height-large);
  }

  /* Prefix */
  .select__prefix {
    flex: 0;
    display: inline-flex;
    align-items: center;
    color: var(--sl-input-placeholder-color);
  }

  /* Clear button */
  .select__clear {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    font-size: inherit;
    color: var(--sl-input-icon-color);
    border: none;
    background: none;
    padding: 0;
    transition: var(--sl-transition-fast) color;
    cursor: pointer;
  }

  .select__clear:hover {
    color: var(--sl-input-icon-color-hover);
  }

  .select__clear:focus {
    outline: none;
  }

  /* Expand icon */
  .select__expand-icon {
    flex: 0 0 auto;
    display: flex;
    align-items: center;
    transition: var(--sl-transition-medium) rotate ease;
    rotate: 0;
    margin-inline-start: var(--sl-spacing-small);
  }

  .select--open .select__expand-icon {
    rotate: -180deg;
  }

  /* Listbox */
  .select__listbox {
    display: block;
    position: relative;
    font-family: var(--sl-font-sans);
    font-size: var(--sl-font-size-medium);
    font-weight: var(--sl-font-weight-normal);
    box-shadow: var(--sl-shadow-large);
    background: var(--sl-panel-background-color);
    border: solid var(--sl-panel-border-width) var(--sl-panel-border-color);
    border-radius: var(--sl-border-radius-medium);
    padding-block: var(--sl-spacing-x-small);
    padding-inline: 0;
    overflow: auto;
    overscroll-behavior: none;

    /* Make sure it adheres to the popup's auto size */
    max-width: var(--auto-size-available-width);
    max-height: var(--auto-size-available-height);
  }

  .select__listbox ::slotted(sl-divider) {
    --spacing: var(--sl-spacing-x-small);
  }

  .select__listbox ::slotted(small) {
    font-size: var(--sl-font-size-small);
    font-weight: var(--sl-font-weight-semibold);
    color: var(--sl-color-neutral-500);
    padding-block: var(--sl-spacing-x-small);
    padding-inline: var(--sl-spacing-x-large);
  }
`, SlSelect = class extends ShoelaceElement {
  constructor() {
    super(...arguments), this.formControlController = new FormControlController(this, {
      assumeInteractionOn: ["sl-blur", "sl-input"]
    }), this.hasSlotController = new HasSlotController(this, "help-text", "label"), this.localize = new LocalizeController(this), this.typeToSelectString = "", this.hasFocus = !1, this.displayLabel = "", this.selectedOptions = [], this.name = "", this.value = "", this.defaultValue = "", this.size = "medium", this.placeholder = "", this.multiple = !1, this.maxOptionsVisible = 3, this.disabled = !1, this.clearable = !1, this.open = !1, this.hoist = !1, this.filled = !1, this.pill = !1, this.label = "", this.placement = "bottom", this.helpText = "", this.form = "", this.required = !1, this.getTag = (z) => x`
      <sl-tag
        part="tag"
        exportparts="
              base:tag__base,
              content:tag__content,
              remove-button:tag__remove-button,
              remove-button__base:tag__remove-button__base
            "
        ?pill=${this.pill}
        size=${this.size}
        removable
        @sl-remove=${(D) => this.handleTagRemove(D, z)}
      >
        ${z.getTextLabel()}
      </sl-tag>
    `, this.handleDocumentFocusIn = (z) => {
      const D = z.composedPath();
      this && !D.includes(this) && this.hide();
    }, this.handleDocumentKeyDown = (z) => {
      const D = z.target, O = D.closest(".select__clear") !== null, F = D.closest("sl-icon-button") !== null;
      if (!(O || F)) {
        if (z.key === "Escape" && this.open && !this.closeWatcher && (z.preventDefault(), z.stopPropagation(), this.hide(), this.displayInput.focus({ preventScroll: !0 })), z.key === "Enter" || z.key === " " && this.typeToSelectString === "") {
          if (z.preventDefault(), z.stopImmediatePropagation(), !this.open) {
            this.show();
            return;
          }
          this.currentOption && !this.currentOption.disabled && (this.multiple ? this.toggleOptionSelection(this.currentOption) : this.setSelectedOptions(this.currentOption), this.updateComplete.then(() => {
            this.emit("sl-input"), this.emit("sl-change");
          }), this.multiple || (this.hide(), this.displayInput.focus({ preventScroll: !0 })));
          return;
        }
        if (["ArrowUp", "ArrowDown", "Home", "End"].includes(z.key)) {
          const U = this.getAllOptions(), W = U.indexOf(this.currentOption);
          let B = Math.max(0, W);
          if (z.preventDefault(), !this.open && (this.show(), this.currentOption))
            return;
          z.key === "ArrowDown" ? (B = W + 1, B > U.length - 1 && (B = 0)) : z.key === "ArrowUp" ? (B = W - 1, B < 0 && (B = U.length - 1)) : z.key === "Home" ? B = 0 : z.key === "End" && (B = U.length - 1), this.setCurrentOption(U[B]);
        }
        if (z.key.length === 1 || z.key === "Backspace") {
          const U = this.getAllOptions();
          if (z.metaKey || z.ctrlKey || z.altKey)
            return;
          if (!this.open) {
            if (z.key === "Backspace")
              return;
            this.show();
          }
          z.stopPropagation(), z.preventDefault(), clearTimeout(this.typeToSelectTimeout), this.typeToSelectTimeout = window.setTimeout(() => this.typeToSelectString = "", 1e3), z.key === "Backspace" ? this.typeToSelectString = this.typeToSelectString.slice(0, -1) : this.typeToSelectString += z.key.toLowerCase();
          for (const W of U)
            if (W.getTextLabel().toLowerCase().startsWith(this.typeToSelectString)) {
              this.setCurrentOption(W);
              break;
            }
        }
      }
    }, this.handleDocumentMouseDown = (z) => {
      const D = z.composedPath();
      this && !D.includes(this) && this.hide();
    };
  }
  /** Gets the validity state object */
  get validity() {
    return this.valueInput.validity;
  }
  /** Gets the validation message */
  get validationMessage() {
    return this.valueInput.validationMessage;
  }
  connectedCallback() {
    super.connectedCallback(), this.open = !1;
  }
  addOpenListeners() {
    var z;
    document.addEventListener("focusin", this.handleDocumentFocusIn), document.addEventListener("keydown", this.handleDocumentKeyDown), document.addEventListener("mousedown", this.handleDocumentMouseDown), this.getRootNode() !== document && this.getRootNode().addEventListener("focusin", this.handleDocumentFocusIn), "CloseWatcher" in window && ((z = this.closeWatcher) == null || z.destroy(), this.closeWatcher = new CloseWatcher(), this.closeWatcher.onclose = () => {
      this.open && (this.hide(), this.displayInput.focus({ preventScroll: !0 }));
    });
  }
  removeOpenListeners() {
    var z;
    document.removeEventListener("focusin", this.handleDocumentFocusIn), document.removeEventListener("keydown", this.handleDocumentKeyDown), document.removeEventListener("mousedown", this.handleDocumentMouseDown), this.getRootNode() !== document && this.getRootNode().removeEventListener("focusin", this.handleDocumentFocusIn), (z = this.closeWatcher) == null || z.destroy();
  }
  handleFocus() {
    this.hasFocus = !0, this.displayInput.setSelectionRange(0, 0), this.emit("sl-focus");
  }
  handleBlur() {
    this.hasFocus = !1, this.emit("sl-blur");
  }
  handleLabelClick() {
    this.displayInput.focus();
  }
  handleComboboxMouseDown(z) {
    const O = z.composedPath().some((F) => F instanceof Element && F.tagName.toLowerCase() === "sl-icon-button");
    this.disabled || O || (z.preventDefault(), this.displayInput.focus({ preventScroll: !0 }), this.open = !this.open);
  }
  handleComboboxKeyDown(z) {
    z.key !== "Tab" && (z.stopPropagation(), this.handleDocumentKeyDown(z));
  }
  handleClearClick(z) {
    z.stopPropagation(), this.value !== "" && (this.setSelectedOptions([]), this.displayInput.focus({ preventScroll: !0 }), this.updateComplete.then(() => {
      this.emit("sl-clear"), this.emit("sl-input"), this.emit("sl-change");
    }));
  }
  handleClearMouseDown(z) {
    z.stopPropagation(), z.preventDefault();
  }
  handleOptionClick(z) {
    const O = z.target.closest("sl-option"), F = this.value;
    O && !O.disabled && (this.multiple ? this.toggleOptionSelection(O) : this.setSelectedOptions(O), this.updateComplete.then(() => this.displayInput.focus({ preventScroll: !0 })), this.value !== F && this.updateComplete.then(() => {
      this.emit("sl-input"), this.emit("sl-change");
    }), this.multiple || (this.hide(), this.displayInput.focus({ preventScroll: !0 })));
  }
  handleDefaultSlotChange() {
    const z = this.getAllOptions(), D = Array.isArray(this.value) ? this.value : [this.value], O = [];
    customElements.get("sl-option") ? (z.forEach((F) => O.push(F.value)), this.setSelectedOptions(z.filter((F) => D.includes(F.value)))) : customElements.whenDefined("sl-option").then(() => this.handleDefaultSlotChange());
  }
  handleTagRemove(z, D) {
    z.stopPropagation(), this.disabled || (this.toggleOptionSelection(D, !1), this.updateComplete.then(() => {
      this.emit("sl-input"), this.emit("sl-change");
    }));
  }
  // Gets an array of all <sl-option> elements
  getAllOptions() {
    return [...this.querySelectorAll("sl-option")];
  }
  // Gets the first <sl-option> element
  getFirstOption() {
    return this.querySelector("sl-option");
  }
  // Sets the current option, which is the option the user is currently interacting with (e.g. via keyboard). Only one
  // option may be "current" at a time.
  setCurrentOption(z) {
    this.getAllOptions().forEach((O) => {
      O.current = !1, O.tabIndex = -1;
    }), z && (this.currentOption = z, z.current = !0, z.tabIndex = 0, z.focus());
  }
  // Sets the selected option(s)
  setSelectedOptions(z) {
    const D = this.getAllOptions(), O = Array.isArray(z) ? z : [z];
    D.forEach((F) => F.selected = !1), O.length && O.forEach((F) => F.selected = !0), this.selectionChanged();
  }
  // Toggles an option's selected state
  toggleOptionSelection(z, D) {
    D === !0 || D === !1 ? z.selected = D : z.selected = !z.selected, this.selectionChanged();
  }
  // This method must be called whenever the selection changes. It will update the selected options cache, the current
  // value, and the display value
  selectionChanged() {
    var z, D, O, F;
    this.selectedOptions = this.getAllOptions().filter((U) => U.selected), this.multiple ? (this.value = this.selectedOptions.map((U) => U.value), this.placeholder && this.value.length === 0 ? this.displayLabel = "" : this.displayLabel = this.localize.term("numOptionsSelected", this.selectedOptions.length)) : (this.value = (D = (z = this.selectedOptions[0]) == null ? void 0 : z.value) != null ? D : "", this.displayLabel = (F = (O = this.selectedOptions[0]) == null ? void 0 : O.getTextLabel()) != null ? F : ""), this.updateComplete.then(() => {
      this.formControlController.updateValidity();
    });
  }
  get tags() {
    return this.selectedOptions.map((z, D) => {
      if (D < this.maxOptionsVisible || this.maxOptionsVisible <= 0) {
        const O = this.getTag(z, D);
        return x`<div @sl-remove=${(F) => this.handleTagRemove(F, z)}>
          ${typeof O == "string" ? o$a(O) : O}
        </div>`;
      } else if (D === this.maxOptionsVisible)
        return x`<sl-tag size=${this.size}>+${this.selectedOptions.length - D}</sl-tag>`;
      return x``;
    });
  }
  handleInvalid(z) {
    this.formControlController.setValidity(!1), this.formControlController.emitInvalidEvent(z);
  }
  handleDisabledChange() {
    this.disabled && (this.open = !1, this.handleOpenChange());
  }
  handleValueChange() {
    const z = this.getAllOptions(), D = Array.isArray(this.value) ? this.value : [this.value];
    this.setSelectedOptions(z.filter((O) => D.includes(O.value)));
  }
  async handleOpenChange() {
    if (this.open && !this.disabled) {
      this.setCurrentOption(this.selectedOptions[0] || this.getFirstOption()), this.emit("sl-show"), this.addOpenListeners(), await stopAnimations(this), this.listbox.hidden = !1, this.popup.active = !0, requestAnimationFrame(() => {
        this.setCurrentOption(this.currentOption);
      });
      const { keyframes: z, options: D } = getAnimation(this, "select.show", { dir: this.localize.dir() });
      await animateTo(this.popup.popup, z, D), this.currentOption && scrollIntoView(this.currentOption, this.listbox, "vertical", "auto"), this.emit("sl-after-show");
    } else {
      this.emit("sl-hide"), this.removeOpenListeners(), await stopAnimations(this);
      const { keyframes: z, options: D } = getAnimation(this, "select.hide", { dir: this.localize.dir() });
      await animateTo(this.popup.popup, z, D), this.listbox.hidden = !0, this.popup.active = !1, this.emit("sl-after-hide");
    }
  }
  /** Shows the listbox. */
  async show() {
    if (this.open || this.disabled) {
      this.open = !1;
      return;
    }
    return this.open = !0, waitForEvent(this, "sl-after-show");
  }
  /** Hides the listbox. */
  async hide() {
    if (!this.open || this.disabled) {
      this.open = !1;
      return;
    }
    return this.open = !1, waitForEvent(this, "sl-after-hide");
  }
  /** Checks for validity but does not show a validation message. Returns `true` when valid and `false` when invalid. */
  checkValidity() {
    return this.valueInput.checkValidity();
  }
  /** Gets the associated form, if one exists. */
  getForm() {
    return this.formControlController.getForm();
  }
  /** Checks for validity and shows the browser's validation message if the control is invalid. */
  reportValidity() {
    return this.valueInput.reportValidity();
  }
  /** Sets a custom validation message. Pass an empty string to restore validity. */
  setCustomValidity(z) {
    this.valueInput.setCustomValidity(z), this.formControlController.updateValidity();
  }
  /** Sets focus on the control. */
  focus(z) {
    this.displayInput.focus(z);
  }
  /** Removes focus from the control. */
  blur() {
    this.displayInput.blur();
  }
  render() {
    const z = this.hasSlotController.test("label"), D = this.hasSlotController.test("help-text"), O = this.label ? !0 : !!z, F = this.helpText ? !0 : !!D, U = this.clearable && !this.disabled && this.value.length > 0, W = this.placeholder && this.value.length === 0;
    return x`
      <div
        part="form-control"
        class=${e$2({
      "form-control": !0,
      "form-control--small": this.size === "small",
      "form-control--medium": this.size === "medium",
      "form-control--large": this.size === "large",
      "form-control--has-label": O,
      "form-control--has-help-text": F
    })}
      >
        <label
          id="label"
          part="form-control-label"
          class="form-control__label"
          aria-hidden=${O ? "false" : "true"}
          @click=${this.handleLabelClick}
        >
          <slot name="label">${this.label}</slot>
        </label>

        <div part="form-control-input" class="form-control-input">
          <sl-popup
            class=${e$2({
      select: !0,
      "select--standard": !0,
      "select--filled": this.filled,
      "select--pill": this.pill,
      "select--open": this.open,
      "select--disabled": this.disabled,
      "select--multiple": this.multiple,
      "select--focused": this.hasFocus,
      "select--placeholder-visible": W,
      "select--top": this.placement === "top",
      "select--bottom": this.placement === "bottom",
      "select--small": this.size === "small",
      "select--medium": this.size === "medium",
      "select--large": this.size === "large"
    })}
            placement=${this.placement}
            strategy=${this.hoist ? "fixed" : "absolute"}
            flip
            shift
            sync="width"
            auto-size="vertical"
            auto-size-padding="10"
          >
            <div
              part="combobox"
              class="select__combobox"
              slot="anchor"
              @keydown=${this.handleComboboxKeyDown}
              @mousedown=${this.handleComboboxMouseDown}
            >
              <slot part="prefix" name="prefix" class="select__prefix"></slot>

              <input
                part="display-input"
                class="select__display-input"
                type="text"
                placeholder=${this.placeholder}
                .disabled=${this.disabled}
                .value=${this.displayLabel}
                autocomplete="off"
                spellcheck="false"
                autocapitalize="off"
                readonly
                aria-controls="listbox"
                aria-expanded=${this.open ? "true" : "false"}
                aria-haspopup="listbox"
                aria-labelledby="label"
                aria-disabled=${this.disabled ? "true" : "false"}
                aria-describedby="help-text"
                role="combobox"
                tabindex="0"
                @focus=${this.handleFocus}
                @blur=${this.handleBlur}
              />

              ${this.multiple ? x`<div part="tags" class="select__tags">${this.tags}</div>` : ""}

              <input
                class="select__value-input"
                type="text"
                ?disabled=${this.disabled}
                ?required=${this.required}
                .value=${Array.isArray(this.value) ? this.value.join(", ") : this.value}
                tabindex="-1"
                aria-hidden="true"
                @focus=${() => this.focus()}
                @invalid=${this.handleInvalid}
              />

              ${U ? x`
                    <button
                      part="clear-button"
                      class="select__clear"
                      type="button"
                      aria-label=${this.localize.term("clearEntry")}
                      @mousedown=${this.handleClearMouseDown}
                      @click=${this.handleClearClick}
                      tabindex="-1"
                    >
                      <slot name="clear-icon">
                        <sl-icon name="x-circle-fill" library="system"></sl-icon>
                      </slot>
                    </button>
                  ` : ""}

              <slot name="expand-icon" part="expand-icon" class="select__expand-icon">
                <sl-icon library="system" name="chevron-down"></sl-icon>
              </slot>
            </div>

            <div
              id="listbox"
              role="listbox"
              aria-expanded=${this.open ? "true" : "false"}
              aria-multiselectable=${this.multiple ? "true" : "false"}
              aria-labelledby="label"
              part="listbox"
              class="select__listbox"
              tabindex="-1"
              @mouseup=${this.handleOptionClick}
              @slotchange=${this.handleDefaultSlotChange}
            >
              <slot></slot>
            </div>
          </sl-popup>
        </div>

        <div
          part="form-control-help-text"
          id="help-text"
          class="form-control__help-text"
          aria-hidden=${F ? "false" : "true"}
        >
          <slot name="help-text">${this.helpText}</slot>
        </div>
      </div>
    `;
  }
};
SlSelect.styles = [component_styles_default, form_control_styles_default, select_styles_default];
SlSelect.dependencies = {
  "sl-icon": SlIcon,
  "sl-popup": SlPopup,
  "sl-tag": SlTag
};
__decorateClass([
  e$b(".select")
], SlSelect.prototype, "popup", 2);
__decorateClass([
  e$b(".select__combobox")
], SlSelect.prototype, "combobox", 2);
__decorateClass([
  e$b(".select__display-input")
], SlSelect.prototype, "displayInput", 2);
__decorateClass([
  e$b(".select__value-input")
], SlSelect.prototype, "valueInput", 2);
__decorateClass([
  e$b(".select__listbox")
], SlSelect.prototype, "listbox", 2);
__decorateClass([
  r$4()
], SlSelect.prototype, "hasFocus", 2);
__decorateClass([
  r$4()
], SlSelect.prototype, "displayLabel", 2);
__decorateClass([
  r$4()
], SlSelect.prototype, "currentOption", 2);
__decorateClass([
  r$4()
], SlSelect.prototype, "selectedOptions", 2);
__decorateClass([
  n$6()
], SlSelect.prototype, "name", 2);
__decorateClass([
  n$6({
    converter: {
      fromAttribute: (z) => z.split(" "),
      toAttribute: (z) => z.join(" ")
    }
  })
], SlSelect.prototype, "value", 2);
__decorateClass([
  defaultValue()
], SlSelect.prototype, "defaultValue", 2);
__decorateClass([
  n$6({ reflect: !0 })
], SlSelect.prototype, "size", 2);
__decorateClass([
  n$6()
], SlSelect.prototype, "placeholder", 2);
__decorateClass([
  n$6({ type: Boolean, reflect: !0 })
], SlSelect.prototype, "multiple", 2);
__decorateClass([
  n$6({ attribute: "max-options-visible", type: Number })
], SlSelect.prototype, "maxOptionsVisible", 2);
__decorateClass([
  n$6({ type: Boolean, reflect: !0 })
], SlSelect.prototype, "disabled", 2);
__decorateClass([
  n$6({ type: Boolean })
], SlSelect.prototype, "clearable", 2);
__decorateClass([
  n$6({ type: Boolean, reflect: !0 })
], SlSelect.prototype, "open", 2);
__decorateClass([
  n$6({ type: Boolean })
], SlSelect.prototype, "hoist", 2);
__decorateClass([
  n$6({ type: Boolean, reflect: !0 })
], SlSelect.prototype, "filled", 2);
__decorateClass([
  n$6({ type: Boolean, reflect: !0 })
], SlSelect.prototype, "pill", 2);
__decorateClass([
  n$6()
], SlSelect.prototype, "label", 2);
__decorateClass([
  n$6({ reflect: !0 })
], SlSelect.prototype, "placement", 2);
__decorateClass([
  n$6({ attribute: "help-text" })
], SlSelect.prototype, "helpText", 2);
__decorateClass([
  n$6({ reflect: !0 })
], SlSelect.prototype, "form", 2);
__decorateClass([
  n$6({ type: Boolean, reflect: !0 })
], SlSelect.prototype, "required", 2);
__decorateClass([
  n$6()
], SlSelect.prototype, "getTag", 2);
__decorateClass([
  watch("disabled", { waitUntilFirstUpdate: !0 })
], SlSelect.prototype, "handleDisabledChange", 1);
__decorateClass([
  watch("value", { waitUntilFirstUpdate: !0 })
], SlSelect.prototype, "handleValueChange", 1);
__decorateClass([
  watch("open", { waitUntilFirstUpdate: !0 })
], SlSelect.prototype, "handleOpenChange", 1);
setDefaultAnimation("select.show", {
  keyframes: [
    { opacity: 0, scale: 0.9 },
    { opacity: 1, scale: 1 }
  ],
  options: { duration: 100, easing: "ease" }
});
setDefaultAnimation("select.hide", {
  keyframes: [
    { opacity: 1, scale: 1 },
    { opacity: 0, scale: 0.9 }
  ],
  options: { duration: 100, easing: "ease" }
});
SlSelect.define("sl-select");
SlSpinner.define("sl-spinner");
var rating_styles_default = i$7`
  :host {
    --symbol-color: var(--sl-color-neutral-300);
    --symbol-color-active: var(--sl-color-amber-500);
    --symbol-size: 1.2rem;
    --symbol-spacing: var(--sl-spacing-3x-small);

    display: inline-flex;
  }

  .rating {
    position: relative;
    display: inline-flex;
    border-radius: var(--sl-border-radius-medium);
    vertical-align: middle;
  }

  .rating:focus {
    outline: none;
  }

  .rating:focus-visible {
    outline: var(--sl-focus-ring);
    outline-offset: var(--sl-focus-ring-offset);
  }

  .rating__symbols {
    display: inline-flex;
    position: relative;
    font-size: var(--symbol-size);
    line-height: 0;
    color: var(--symbol-color);
    white-space: nowrap;
    cursor: pointer;
  }

  .rating__symbols > * {
    padding: var(--symbol-spacing);
  }

  .rating__symbol--active,
  .rating__partial--filled {
    color: var(--symbol-color-active);
  }

  .rating__partial-symbol-container {
    position: relative;
  }

  .rating__partial--filled {
    position: absolute;
    top: var(--symbol-spacing);
    left: var(--symbol-spacing);
  }

  .rating__symbol {
    transition: var(--sl-transition-fast) scale;
    pointer-events: none;
  }

  .rating__symbol--hover {
    scale: 1.2;
  }

  .rating--disabled .rating__symbols,
  .rating--readonly .rating__symbols {
    cursor: default;
  }

  .rating--disabled .rating__symbol--hover,
  .rating--readonly .rating__symbol--hover {
    scale: none;
  }

  .rating--disabled {
    opacity: 0.5;
  }

  .rating--disabled .rating__symbols {
    cursor: not-allowed;
  }

  /* Forced colors mode */
  @media (forced-colors: active) {
    .rating__symbol--active {
      color: SelectedItem;
    }
  }
`;
/**
 * @license
 * Copyright 2018 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const n$1 = "important", i = " !" + n$1, o$3 = e$7(class extends i$3 {
  constructor(z) {
    var D;
    if (super(z), z.type !== t$3.ATTRIBUTE || z.name !== "style" || ((D = z.strings) == null ? void 0 : D.length) > 2)
      throw Error("The `styleMap` directive must be used in the `style` attribute and must be the only part in the attribute.");
  }
  render(z) {
    return Object.keys(z).reduce((D, O) => {
      const F = z[O];
      return F == null ? D : D + `${O = O.includes("-") ? O : O.replace(/(?:^(webkit|moz|ms|o)|)(?=[A-Z])/g, "-$&").toLowerCase()}:${F};`;
    }, "");
  }
  update(z, [D]) {
    const { style: O } = z.element;
    if (this.ft === void 0)
      return this.ft = new Set(Object.keys(D)), this.render(D);
    for (const F of this.ft)
      D[F] == null && (this.ft.delete(F), F.includes("-") ? O.removeProperty(F) : O[F] = null);
    for (const F in D) {
      const U = D[F];
      if (U != null) {
        this.ft.add(F);
        const W = typeof U == "string" && U.endsWith(i);
        F.includes("-") || W ? O.setProperty(F, W ? U.slice(0, -11) : U, W ? n$1 : "") : O[F] = U;
      }
    }
    return w$1;
  }
});
var SlRating = class extends ShoelaceElement {
  constructor() {
    super(...arguments), this.localize = new LocalizeController(this), this.hoverValue = 0, this.isHovering = !1, this.label = "", this.value = 0, this.max = 5, this.precision = 1, this.readonly = !1, this.disabled = !1, this.getSymbol = () => '<sl-icon name="star-fill" library="system"></sl-icon>';
  }
  getValueFromMousePosition(z) {
    return this.getValueFromXCoordinate(z.clientX);
  }
  getValueFromTouchPosition(z) {
    return this.getValueFromXCoordinate(z.touches[0].clientX);
  }
  getValueFromXCoordinate(z) {
    const D = this.localize.dir() === "rtl", { left: O, right: F, width: U } = this.rating.getBoundingClientRect(), W = D ? this.roundToPrecision((F - z) / U * this.max, this.precision) : this.roundToPrecision((z - O) / U * this.max, this.precision);
    return clamp$1(W, 0, this.max);
  }
  handleClick(z) {
    this.disabled || (this.setValue(this.getValueFromMousePosition(z)), this.emit("sl-change"));
  }
  setValue(z) {
    this.disabled || this.readonly || (this.value = z === this.value ? 0 : z, this.isHovering = !1);
  }
  handleKeyDown(z) {
    const D = this.localize.dir() === "ltr", O = this.localize.dir() === "rtl", F = this.value;
    if (!(this.disabled || this.readonly)) {
      if (z.key === "ArrowDown" || D && z.key === "ArrowLeft" || O && z.key === "ArrowRight") {
        const U = z.shiftKey ? 1 : this.precision;
        this.value = Math.max(0, this.value - U), z.preventDefault();
      }
      if (z.key === "ArrowUp" || D && z.key === "ArrowRight" || O && z.key === "ArrowLeft") {
        const U = z.shiftKey ? 1 : this.precision;
        this.value = Math.min(this.max, this.value + U), z.preventDefault();
      }
      z.key === "Home" && (this.value = 0, z.preventDefault()), z.key === "End" && (this.value = this.max, z.preventDefault()), this.value !== F && this.emit("sl-change");
    }
  }
  handleMouseEnter(z) {
    this.isHovering = !0, this.hoverValue = this.getValueFromMousePosition(z);
  }
  handleMouseMove(z) {
    this.hoverValue = this.getValueFromMousePosition(z);
  }
  handleMouseLeave() {
    this.isHovering = !1;
  }
  handleTouchStart(z) {
    this.isHovering = !0, this.hoverValue = this.getValueFromTouchPosition(z), z.preventDefault();
  }
  handleTouchMove(z) {
    this.hoverValue = this.getValueFromTouchPosition(z);
  }
  handleTouchEnd(z) {
    this.isHovering = !1, this.setValue(this.hoverValue), this.emit("sl-change"), z.preventDefault();
  }
  roundToPrecision(z, D = 0.5) {
    const O = 1 / D;
    return Math.ceil(z * O) / O;
  }
  handleHoverValueChange() {
    this.emit("sl-hover", {
      detail: {
        phase: "move",
        value: this.hoverValue
      }
    });
  }
  handleIsHoveringChange() {
    this.emit("sl-hover", {
      detail: {
        phase: this.isHovering ? "start" : "end",
        value: this.hoverValue
      }
    });
  }
  /** Sets focus on the rating. */
  focus(z) {
    this.rating.focus(z);
  }
  /** Removes focus from the rating. */
  blur() {
    this.rating.blur();
  }
  render() {
    const z = this.localize.dir() === "rtl", D = Array.from(Array(this.max).keys());
    let O = 0;
    return this.disabled || this.readonly ? O = this.value : O = this.isHovering ? this.hoverValue : this.value, x`
      <div
        part="base"
        class=${e$2({
      rating: !0,
      "rating--readonly": this.readonly,
      "rating--disabled": this.disabled,
      "rating--rtl": z
    })}
        role="slider"
        aria-label=${this.label}
        aria-disabled=${this.disabled ? "true" : "false"}
        aria-readonly=${this.readonly ? "true" : "false"}
        aria-valuenow=${this.value}
        aria-valuemin=${0}
        aria-valuemax=${this.max}
        tabindex=${this.disabled ? "-1" : "0"}
        @click=${this.handleClick}
        @keydown=${this.handleKeyDown}
        @mouseenter=${this.handleMouseEnter}
        @touchstart=${this.handleTouchStart}
        @mouseleave=${this.handleMouseLeave}
        @touchend=${this.handleTouchEnd}
        @mousemove=${this.handleMouseMove}
        @touchmove=${this.handleTouchMove}
      >
        <span class="rating__symbols">
          ${D.map((F) => O > F && O < F + 1 ? x`
                <span
                  class=${e$2({
      rating__symbol: !0,
      "rating__partial-symbol-container": !0,
      "rating__symbol--hover": this.isHovering && Math.ceil(O) === F + 1
    })}
                  role="presentation"
                >
                  <div
                    style=${o$3({
      clipPath: z ? `inset(0 ${(O - F) * 100}% 0 0)` : `inset(0 0 0 ${(O - F) * 100}%)`
    })}
                  >
                    ${o$a(this.getSymbol(F + 1))}
                  </div>
                  <div
                    class="rating__partial--filled"
                    style=${o$3({
      clipPath: z ? `inset(0 0 0 ${100 - (O - F) * 100}%)` : `inset(0 ${100 - (O - F) * 100}% 0 0)`
    })}
                  >
                    ${o$a(this.getSymbol(F + 1))}
                  </div>
                </span>
              ` : x`
              <span
                class=${e$2({
      rating__symbol: !0,
      "rating__symbol--hover": this.isHovering && Math.ceil(O) === F + 1,
      "rating__symbol--active": O >= F + 1
    })}
                role="presentation"
              >
                ${o$a(this.getSymbol(F + 1))}
              </span>
            `)}
        </span>
      </div>
    `;
  }
};
SlRating.styles = [component_styles_default, rating_styles_default];
SlRating.dependencies = { "sl-icon": SlIcon };
__decorateClass([
  e$b(".rating")
], SlRating.prototype, "rating", 2);
__decorateClass([
  r$4()
], SlRating.prototype, "hoverValue", 2);
__decorateClass([
  r$4()
], SlRating.prototype, "isHovering", 2);
__decorateClass([
  n$6()
], SlRating.prototype, "label", 2);
__decorateClass([
  n$6({ type: Number })
], SlRating.prototype, "value", 2);
__decorateClass([
  n$6({ type: Number })
], SlRating.prototype, "max", 2);
__decorateClass([
  n$6({ type: Number })
], SlRating.prototype, "precision", 2);
__decorateClass([
  n$6({ type: Boolean, reflect: !0 })
], SlRating.prototype, "readonly", 2);
__decorateClass([
  n$6({ type: Boolean, reflect: !0 })
], SlRating.prototype, "disabled", 2);
__decorateClass([
  n$6()
], SlRating.prototype, "getSymbol", 2);
__decorateClass([
  t$4({ passive: !0 })
], SlRating.prototype, "handleTouchMove", 1);
__decorateClass([
  watch("hoverValue")
], SlRating.prototype, "handleHoverValueChange", 1);
__decorateClass([
  watch("isHovering")
], SlRating.prototype, "handleIsHoveringChange", 1);
SlRating.define("sl-rating");
var button_styles_default = i$7`
  :host {
    display: inline-block;
    position: relative;
    width: auto;
    cursor: pointer;
  }

  .button {
    display: inline-flex;
    align-items: stretch;
    justify-content: center;
    width: 100%;
    border-style: solid;
    border-width: var(--sl-input-border-width);
    font-family: var(--sl-input-font-family);
    font-weight: var(--sl-font-weight-semibold);
    text-decoration: none;
    user-select: none;
    -webkit-user-select: none;
    white-space: nowrap;
    vertical-align: middle;
    padding: 0;
    transition:
      var(--sl-transition-x-fast) background-color,
      var(--sl-transition-x-fast) color,
      var(--sl-transition-x-fast) border,
      var(--sl-transition-x-fast) box-shadow;
    cursor: inherit;
  }

  .button::-moz-focus-inner {
    border: 0;
  }

  .button:focus {
    outline: none;
  }

  .button:focus-visible {
    outline: var(--sl-focus-ring);
    outline-offset: var(--sl-focus-ring-offset);
  }

  .button--disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }

  /* When disabled, prevent mouse events from bubbling up from children */
  .button--disabled * {
    pointer-events: none;
  }

  .button__prefix,
  .button__suffix {
    flex: 0 0 auto;
    display: flex;
    align-items: center;
    pointer-events: none;
  }

  .button__label {
    display: inline-block;
  }

  .button__label::slotted(sl-icon) {
    vertical-align: -2px;
  }

  /*
   * Standard buttons
   */

  /* Default */
  .button--standard.button--default {
    background-color: var(--sl-color-neutral-0);
    border-color: var(--sl-color-neutral-300);
    color: var(--sl-color-neutral-700);
  }

  .button--standard.button--default:hover:not(.button--disabled) {
    background-color: var(--sl-color-primary-50);
    border-color: var(--sl-color-primary-300);
    color: var(--sl-color-primary-700);
  }

  .button--standard.button--default:active:not(.button--disabled) {
    background-color: var(--sl-color-primary-100);
    border-color: var(--sl-color-primary-400);
    color: var(--sl-color-primary-700);
  }

  /* Primary */
  .button--standard.button--primary {
    background-color: var(--sl-color-primary-600);
    border-color: var(--sl-color-primary-600);
    color: var(--sl-color-neutral-0);
  }

  .button--standard.button--primary:hover:not(.button--disabled) {
    background-color: var(--sl-color-primary-500);
    border-color: var(--sl-color-primary-500);
    color: var(--sl-color-neutral-0);
  }

  .button--standard.button--primary:active:not(.button--disabled) {
    background-color: var(--sl-color-primary-600);
    border-color: var(--sl-color-primary-600);
    color: var(--sl-color-neutral-0);
  }

  /* Success */
  .button--standard.button--success {
    background-color: var(--sl-color-success-600);
    border-color: var(--sl-color-success-600);
    color: var(--sl-color-neutral-0);
  }

  .button--standard.button--success:hover:not(.button--disabled) {
    background-color: var(--sl-color-success-500);
    border-color: var(--sl-color-success-500);
    color: var(--sl-color-neutral-0);
  }

  .button--standard.button--success:active:not(.button--disabled) {
    background-color: var(--sl-color-success-600);
    border-color: var(--sl-color-success-600);
    color: var(--sl-color-neutral-0);
  }

  /* Neutral */
  .button--standard.button--neutral {
    background-color: var(--sl-color-neutral-600);
    border-color: var(--sl-color-neutral-600);
    color: var(--sl-color-neutral-0);
  }

  .button--standard.button--neutral:hover:not(.button--disabled) {
    background-color: var(--sl-color-neutral-500);
    border-color: var(--sl-color-neutral-500);
    color: var(--sl-color-neutral-0);
  }

  .button--standard.button--neutral:active:not(.button--disabled) {
    background-color: var(--sl-color-neutral-600);
    border-color: var(--sl-color-neutral-600);
    color: var(--sl-color-neutral-0);
  }

  /* Warning */
  .button--standard.button--warning {
    background-color: var(--sl-color-warning-600);
    border-color: var(--sl-color-warning-600);
    color: var(--sl-color-neutral-0);
  }
  .button--standard.button--warning:hover:not(.button--disabled) {
    background-color: var(--sl-color-warning-500);
    border-color: var(--sl-color-warning-500);
    color: var(--sl-color-neutral-0);
  }

  .button--standard.button--warning:active:not(.button--disabled) {
    background-color: var(--sl-color-warning-600);
    border-color: var(--sl-color-warning-600);
    color: var(--sl-color-neutral-0);
  }

  /* Danger */
  .button--standard.button--danger {
    background-color: var(--sl-color-danger-600);
    border-color: var(--sl-color-danger-600);
    color: var(--sl-color-neutral-0);
  }

  .button--standard.button--danger:hover:not(.button--disabled) {
    background-color: var(--sl-color-danger-500);
    border-color: var(--sl-color-danger-500);
    color: var(--sl-color-neutral-0);
  }

  .button--standard.button--danger:active:not(.button--disabled) {
    background-color: var(--sl-color-danger-600);
    border-color: var(--sl-color-danger-600);
    color: var(--sl-color-neutral-0);
  }

  /*
   * Outline buttons
   */

  .button--outline {
    background: none;
    border: solid 1px;
  }

  /* Default */
  .button--outline.button--default {
    border-color: var(--sl-color-neutral-300);
    color: var(--sl-color-neutral-700);
  }

  .button--outline.button--default:hover:not(.button--disabled),
  .button--outline.button--default.button--checked:not(.button--disabled) {
    border-color: var(--sl-color-primary-600);
    background-color: var(--sl-color-primary-600);
    color: var(--sl-color-neutral-0);
  }

  .button--outline.button--default:active:not(.button--disabled) {
    border-color: var(--sl-color-primary-700);
    background-color: var(--sl-color-primary-700);
    color: var(--sl-color-neutral-0);
  }

  /* Primary */
  .button--outline.button--primary {
    border-color: var(--sl-color-primary-600);
    color: var(--sl-color-primary-600);
  }

  .button--outline.button--primary:hover:not(.button--disabled),
  .button--outline.button--primary.button--checked:not(.button--disabled) {
    background-color: var(--sl-color-primary-600);
    color: var(--sl-color-neutral-0);
  }

  .button--outline.button--primary:active:not(.button--disabled) {
    border-color: var(--sl-color-primary-700);
    background-color: var(--sl-color-primary-700);
    color: var(--sl-color-neutral-0);
  }

  /* Success */
  .button--outline.button--success {
    border-color: var(--sl-color-success-600);
    color: var(--sl-color-success-600);
  }

  .button--outline.button--success:hover:not(.button--disabled),
  .button--outline.button--success.button--checked:not(.button--disabled) {
    background-color: var(--sl-color-success-600);
    color: var(--sl-color-neutral-0);
  }

  .button--outline.button--success:active:not(.button--disabled) {
    border-color: var(--sl-color-success-700);
    background-color: var(--sl-color-success-700);
    color: var(--sl-color-neutral-0);
  }

  /* Neutral */
  .button--outline.button--neutral {
    border-color: var(--sl-color-neutral-600);
    color: var(--sl-color-neutral-600);
  }

  .button--outline.button--neutral:hover:not(.button--disabled),
  .button--outline.button--neutral.button--checked:not(.button--disabled) {
    background-color: var(--sl-color-neutral-600);
    color: var(--sl-color-neutral-0);
  }

  .button--outline.button--neutral:active:not(.button--disabled) {
    border-color: var(--sl-color-neutral-700);
    background-color: var(--sl-color-neutral-700);
    color: var(--sl-color-neutral-0);
  }

  /* Warning */
  .button--outline.button--warning {
    border-color: var(--sl-color-warning-600);
    color: var(--sl-color-warning-600);
  }

  .button--outline.button--warning:hover:not(.button--disabled),
  .button--outline.button--warning.button--checked:not(.button--disabled) {
    background-color: var(--sl-color-warning-600);
    color: var(--sl-color-neutral-0);
  }

  .button--outline.button--warning:active:not(.button--disabled) {
    border-color: var(--sl-color-warning-700);
    background-color: var(--sl-color-warning-700);
    color: var(--sl-color-neutral-0);
  }

  /* Danger */
  .button--outline.button--danger {
    border-color: var(--sl-color-danger-600);
    color: var(--sl-color-danger-600);
  }

  .button--outline.button--danger:hover:not(.button--disabled),
  .button--outline.button--danger.button--checked:not(.button--disabled) {
    background-color: var(--sl-color-danger-600);
    color: var(--sl-color-neutral-0);
  }

  .button--outline.button--danger:active:not(.button--disabled) {
    border-color: var(--sl-color-danger-700);
    background-color: var(--sl-color-danger-700);
    color: var(--sl-color-neutral-0);
  }

  @media (forced-colors: active) {
    .button.button--outline.button--checked:not(.button--disabled) {
      outline: solid 2px transparent;
    }
  }

  /*
   * Text buttons
   */

  .button--text {
    background-color: transparent;
    border-color: transparent;
    color: var(--sl-color-primary-600);
  }

  .button--text:hover:not(.button--disabled) {
    background-color: transparent;
    border-color: transparent;
    color: var(--sl-color-primary-500);
  }

  .button--text:focus-visible:not(.button--disabled) {
    background-color: transparent;
    border-color: transparent;
    color: var(--sl-color-primary-500);
  }

  .button--text:active:not(.button--disabled) {
    background-color: transparent;
    border-color: transparent;
    color: var(--sl-color-primary-700);
  }

  /*
   * Size modifiers
   */

  .button--small {
    height: auto;
    min-height: var(--sl-input-height-small);
    font-size: var(--sl-button-font-size-small);
    line-height: calc(var(--sl-input-height-small) - var(--sl-input-border-width) * 2);
    border-radius: var(--sl-input-border-radius-small);
  }

  .button--medium {
    height: auto;
    min-height: var(--sl-input-height-medium);
    font-size: var(--sl-button-font-size-medium);
    line-height: calc(var(--sl-input-height-medium) - var(--sl-input-border-width) * 2);
    border-radius: var(--sl-input-border-radius-medium);
  }

  .button--large {
    height: auto;
    min-height: var(--sl-input-height-large);
    font-size: var(--sl-button-font-size-large);
    line-height: calc(var(--sl-input-height-large) - var(--sl-input-border-width) * 2);
    border-radius: var(--sl-input-border-radius-large);
  }

  /*
   * Pill modifier
   */

  .button--pill.button--small {
    border-radius: var(--sl-input-height-small);
  }

  .button--pill.button--medium {
    border-radius: var(--sl-input-height-medium);
  }

  .button--pill.button--large {
    border-radius: var(--sl-input-height-large);
  }

  /*
   * Circle modifier
   */

  .button--circle {
    padding-left: 0;
    padding-right: 0;
  }

  .button--circle.button--small {
    width: var(--sl-input-height-small);
    border-radius: 50%;
  }

  .button--circle.button--medium {
    width: var(--sl-input-height-medium);
    border-radius: 50%;
  }

  .button--circle.button--large {
    width: var(--sl-input-height-large);
    border-radius: 50%;
  }

  .button--circle .button__prefix,
  .button--circle .button__suffix,
  .button--circle .button__caret {
    display: none;
  }

  /*
   * Caret modifier
   */

  .button--caret .button__suffix {
    display: none;
  }

  .button--caret .button__caret {
    height: auto;
  }

  /*
   * Loading modifier
   */

  .button--loading {
    position: relative;
    cursor: wait;
  }

  .button--loading .button__prefix,
  .button--loading .button__label,
  .button--loading .button__suffix,
  .button--loading .button__caret {
    visibility: hidden;
  }

  .button--loading sl-spinner {
    --indicator-color: currentColor;
    position: absolute;
    font-size: 1em;
    height: 1em;
    width: 1em;
    top: calc(50% - 0.5em);
    left: calc(50% - 0.5em);
  }

  /*
   * Badges
   */

  .button ::slotted(sl-badge) {
    position: absolute;
    top: 0;
    right: 0;
    translate: 50% -50%;
    pointer-events: none;
  }

  .button--rtl ::slotted(sl-badge) {
    right: auto;
    left: 0;
    translate: -50% -50%;
  }

  /*
   * Button spacing
   */

  .button--has-label.button--small .button__label {
    padding: 0 var(--sl-spacing-small);
  }

  .button--has-label.button--medium .button__label {
    padding: 0 var(--sl-spacing-medium);
  }

  .button--has-label.button--large .button__label {
    padding: 0 var(--sl-spacing-large);
  }

  .button--has-prefix.button--small {
    padding-inline-start: var(--sl-spacing-x-small);
  }

  .button--has-prefix.button--small .button__label {
    padding-inline-start: var(--sl-spacing-x-small);
  }

  .button--has-prefix.button--medium {
    padding-inline-start: var(--sl-spacing-small);
  }

  .button--has-prefix.button--medium .button__label {
    padding-inline-start: var(--sl-spacing-small);
  }

  .button--has-prefix.button--large {
    padding-inline-start: var(--sl-spacing-small);
  }

  .button--has-prefix.button--large .button__label {
    padding-inline-start: var(--sl-spacing-small);
  }

  .button--has-suffix.button--small,
  .button--caret.button--small {
    padding-inline-end: var(--sl-spacing-x-small);
  }

  .button--has-suffix.button--small .button__label,
  .button--caret.button--small .button__label {
    padding-inline-end: var(--sl-spacing-x-small);
  }

  .button--has-suffix.button--medium,
  .button--caret.button--medium {
    padding-inline-end: var(--sl-spacing-small);
  }

  .button--has-suffix.button--medium .button__label,
  .button--caret.button--medium .button__label {
    padding-inline-end: var(--sl-spacing-small);
  }

  .button--has-suffix.button--large,
  .button--caret.button--large {
    padding-inline-end: var(--sl-spacing-small);
  }

  .button--has-suffix.button--large .button__label,
  .button--caret.button--large .button__label {
    padding-inline-end: var(--sl-spacing-small);
  }

  /*
   * Button groups support a variety of button types (e.g. buttons with tooltips, buttons as dropdown triggers, etc.).
   * This means buttons aren't always direct descendants of the button group, thus we can't target them with the
   * ::slotted selector. To work around this, the button group component does some magic to add these special classes to
   * buttons and we style them here instead.
   */

  :host([data-sl-button-group__button--first]:not([data-sl-button-group__button--last])) .button {
    border-start-end-radius: 0;
    border-end-end-radius: 0;
  }

  :host([data-sl-button-group__button--inner]) .button {
    border-radius: 0;
  }

  :host([data-sl-button-group__button--last]:not([data-sl-button-group__button--first])) .button {
    border-start-start-radius: 0;
    border-end-start-radius: 0;
  }

  /* All except the first */
  :host([data-sl-button-group__button]:not([data-sl-button-group__button--first])) {
    margin-inline-start: calc(-1 * var(--sl-input-border-width));
  }

  /* Add a visual separator between solid buttons */
  :host(
      [data-sl-button-group__button]:not(
          [data-sl-button-group__button--first],
          [data-sl-button-group__button--radio],
          [variant='default']
        ):not(:hover)
    )
    .button:after {
    content: '';
    position: absolute;
    top: 0;
    inset-inline-start: 0;
    bottom: 0;
    border-left: solid 1px rgb(128 128 128 / 33%);
    mix-blend-mode: multiply;
  }

  /* Bump hovered, focused, and checked buttons up so their focus ring isn't clipped */
  :host([data-sl-button-group__button--hover]) {
    z-index: 1;
  }

  /* Focus and checked are always on top */
  :host([data-sl-button-group__button--focus]),
  :host([data-sl-button-group__button][checked]) {
    z-index: 2;
  }
`, radio_button_styles_default = i$7`
  ${button_styles_default}

  .button__prefix,
  .button__suffix,
  .button__label {
    display: inline-flex;
    position: relative;
    align-items: center;
  }

  /* We use a hidden input so constraint validation errors work, since they don't appear to show when used with buttons.
    We can't actually hide it, though, otherwise the messages will be suppressed by the browser. */
  .hidden-input {
    all: unset;
    position: absolute;
    top: 0;
    left: 0;
    bottom: 0;
    right: 0;
    outline: dotted 1px red;
    opacity: 0;
    z-index: -1;
  }
`, SlRadioButton = class extends ShoelaceElement {
  constructor() {
    super(...arguments), this.hasSlotController = new HasSlotController(this, "[default]", "prefix", "suffix"), this.hasFocus = !1, this.checked = !1, this.disabled = !1, this.size = "medium", this.pill = !1;
  }
  connectedCallback() {
    super.connectedCallback(), this.setAttribute("role", "presentation");
  }
  handleBlur() {
    this.hasFocus = !1, this.emit("sl-blur");
  }
  handleClick(z) {
    if (this.disabled) {
      z.preventDefault(), z.stopPropagation();
      return;
    }
    this.checked = !0;
  }
  handleFocus() {
    this.hasFocus = !0, this.emit("sl-focus");
  }
  handleDisabledChange() {
    this.setAttribute("aria-disabled", this.disabled ? "true" : "false");
  }
  /** Sets focus on the radio button. */
  focus(z) {
    this.input.focus(z);
  }
  /** Removes focus from the radio button. */
  blur() {
    this.input.blur();
  }
  render() {
    return n$2`
      <div part="base" role="presentation">
        <button
          part="${`button${this.checked ? " button--checked" : ""}`}"
          role="radio"
          aria-checked="${this.checked}"
          class=${e$2({
      button: !0,
      "button--default": !0,
      "button--small": this.size === "small",
      "button--medium": this.size === "medium",
      "button--large": this.size === "large",
      "button--checked": this.checked,
      "button--disabled": this.disabled,
      "button--focused": this.hasFocus,
      "button--outline": !0,
      "button--pill": this.pill,
      "button--has-label": this.hasSlotController.test("[default]"),
      "button--has-prefix": this.hasSlotController.test("prefix"),
      "button--has-suffix": this.hasSlotController.test("suffix")
    })}
          aria-disabled=${this.disabled}
          type="button"
          value=${o$6(this.value)}
          tabindex="${this.checked ? "0" : "-1"}"
          @blur=${this.handleBlur}
          @focus=${this.handleFocus}
          @click=${this.handleClick}
        >
          <slot name="prefix" part="prefix" class="button__prefix"></slot>
          <slot part="label" class="button__label"></slot>
          <slot name="suffix" part="suffix" class="button__suffix"></slot>
        </button>
      </div>
    `;
  }
};
SlRadioButton.styles = [component_styles_default, radio_button_styles_default];
__decorateClass([
  e$b(".button")
], SlRadioButton.prototype, "input", 2);
__decorateClass([
  e$b(".hidden-input")
], SlRadioButton.prototype, "hiddenInput", 2);
__decorateClass([
  r$4()
], SlRadioButton.prototype, "hasFocus", 2);
__decorateClass([
  n$6({ type: Boolean, reflect: !0 })
], SlRadioButton.prototype, "checked", 2);
__decorateClass([
  n$6()
], SlRadioButton.prototype, "value", 2);
__decorateClass([
  n$6({ type: Boolean, reflect: !0 })
], SlRadioButton.prototype, "disabled", 2);
__decorateClass([
  n$6({ reflect: !0 })
], SlRadioButton.prototype, "size", 2);
__decorateClass([
  n$6({ type: Boolean, reflect: !0 })
], SlRadioButton.prototype, "pill", 2);
__decorateClass([
  watch("disabled", { waitUntilFirstUpdate: !0 })
], SlRadioButton.prototype, "handleDisabledChange", 1);
SlRadioButton.define("sl-radio-button");
var resize_observer_styles_default = i$7`
  :host {
    display: contents;
  }
`, SlResizeObserver = class extends ShoelaceElement {
  constructor() {
    super(...arguments), this.observedElements = [], this.disabled = !1;
  }
  connectedCallback() {
    super.connectedCallback(), this.resizeObserver = new ResizeObserver((z) => {
      this.emit("sl-resize", { detail: { entries: z } });
    }), this.disabled || this.startObserver();
  }
  disconnectedCallback() {
    super.disconnectedCallback(), this.stopObserver();
  }
  handleSlotChange() {
    this.disabled || this.startObserver();
  }
  startObserver() {
    const z = this.shadowRoot.querySelector("slot");
    if (z !== null) {
      const D = z.assignedElements({ flatten: !0 });
      this.observedElements.forEach((O) => this.resizeObserver.unobserve(O)), this.observedElements = [], D.forEach((O) => {
        this.resizeObserver.observe(O), this.observedElements.push(O);
      });
    }
  }
  stopObserver() {
    this.resizeObserver.disconnect();
  }
  handleDisabledChange() {
    this.disabled ? this.stopObserver() : this.startObserver();
  }
  render() {
    return x` <slot @slotchange=${this.handleSlotChange}></slot> `;
  }
};
SlResizeObserver.styles = [component_styles_default, resize_observer_styles_default];
__decorateClass([
  n$6({ type: Boolean, reflect: !0 })
], SlResizeObserver.prototype, "disabled", 2);
__decorateClass([
  watch("disabled", { waitUntilFirstUpdate: !0 })
], SlResizeObserver.prototype, "handleDisabledChange", 1);
SlResizeObserver.define("sl-resize-observer");
var radio_group_styles_default = i$7`
  :host {
    display: block;
  }

  .form-control {
    position: relative;
    border: none;
    padding: 0;
    margin: 0;
  }

  .form-control__label {
    padding: 0;
  }

  .radio-group--required .radio-group__label::after {
    content: var(--sl-input-required-content);
    margin-inline-start: var(--sl-input-required-content-offset);
  }

  .visually-hidden {
    position: absolute;
    width: 1px;
    height: 1px;
    padding: 0;
    margin: -1px;
    overflow: hidden;
    clip: rect(0, 0, 0, 0);
    white-space: nowrap;
    border: 0;
  }
`, button_group_styles_default = i$7`
  :host {
    display: inline-block;
  }

  .button-group {
    display: flex;
    flex-wrap: nowrap;
  }
`, SlButtonGroup = class extends ShoelaceElement {
  constructor() {
    super(...arguments), this.disableRole = !1, this.label = "";
  }
  handleFocus(z) {
    const D = findButton(z.target);
    D == null || D.toggleAttribute("data-sl-button-group__button--focus", !0);
  }
  handleBlur(z) {
    const D = findButton(z.target);
    D == null || D.toggleAttribute("data-sl-button-group__button--focus", !1);
  }
  handleMouseOver(z) {
    const D = findButton(z.target);
    D == null || D.toggleAttribute("data-sl-button-group__button--hover", !0);
  }
  handleMouseOut(z) {
    const D = findButton(z.target);
    D == null || D.toggleAttribute("data-sl-button-group__button--hover", !1);
  }
  handleSlotChange() {
    const z = [...this.defaultSlot.assignedElements({ flatten: !0 })];
    z.forEach((D) => {
      const O = z.indexOf(D), F = findButton(D);
      F && (F.toggleAttribute("data-sl-button-group__button", !0), F.toggleAttribute("data-sl-button-group__button--first", O === 0), F.toggleAttribute("data-sl-button-group__button--inner", O > 0 && O < z.length - 1), F.toggleAttribute("data-sl-button-group__button--last", O === z.length - 1), F.toggleAttribute(
        "data-sl-button-group__button--radio",
        F.tagName.toLowerCase() === "sl-radio-button"
      ));
    });
  }
  render() {
    return x`
      <div
        part="base"
        class="button-group"
        role="${this.disableRole ? "presentation" : "group"}"
        aria-label=${this.label}
        @focusout=${this.handleBlur}
        @focusin=${this.handleFocus}
        @mouseover=${this.handleMouseOver}
        @mouseout=${this.handleMouseOut}
      >
        <slot @slotchange=${this.handleSlotChange}></slot>
      </div>
    `;
  }
};
SlButtonGroup.styles = [component_styles_default, button_group_styles_default];
__decorateClass([
  e$b("slot")
], SlButtonGroup.prototype, "defaultSlot", 2);
__decorateClass([
  r$4()
], SlButtonGroup.prototype, "disableRole", 2);
__decorateClass([
  n$6()
], SlButtonGroup.prototype, "label", 2);
function findButton(z) {
  var D;
  const O = "sl-button, sl-radio-button";
  return (D = z.closest(O)) != null ? D : z.querySelector(O);
}
var SlRadioGroup = class extends ShoelaceElement {
  constructor() {
    super(...arguments), this.formControlController = new FormControlController(this), this.hasSlotController = new HasSlotController(this, "help-text", "label"), this.customValidityMessage = "", this.hasButtonGroup = !1, this.errorMessage = "", this.defaultValue = "", this.label = "", this.helpText = "", this.name = "option", this.value = "", this.size = "medium", this.form = "", this.required = !1;
  }
  /** Gets the validity state object */
  get validity() {
    const z = this.required && !this.value;
    return this.customValidityMessage !== "" ? customErrorValidityState : z ? valueMissingValidityState : validValidityState;
  }
  /** Gets the validation message */
  get validationMessage() {
    const z = this.required && !this.value;
    return this.customValidityMessage !== "" ? this.customValidityMessage : z ? this.validationInput.validationMessage : "";
  }
  connectedCallback() {
    super.connectedCallback(), this.defaultValue = this.value;
  }
  firstUpdated() {
    this.formControlController.updateValidity();
  }
  getAllRadios() {
    return [...this.querySelectorAll("sl-radio, sl-radio-button")];
  }
  handleRadioClick(z) {
    const D = z.target.closest("sl-radio, sl-radio-button"), O = this.getAllRadios(), F = this.value;
    !D || D.disabled || (this.value = D.value, O.forEach((U) => U.checked = U === D), this.value !== F && (this.emit("sl-change"), this.emit("sl-input")));
  }
  handleKeyDown(z) {
    var D;
    if (!["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight", " "].includes(z.key))
      return;
    const O = this.getAllRadios().filter((K) => !K.disabled), F = (D = O.find((K) => K.checked)) != null ? D : O[0], U = z.key === " " ? 0 : ["ArrowUp", "ArrowLeft"].includes(z.key) ? -1 : 1, W = this.value;
    let B = O.indexOf(F) + U;
    B < 0 && (B = O.length - 1), B > O.length - 1 && (B = 0), this.getAllRadios().forEach((K) => {
      K.checked = !1, this.hasButtonGroup || (K.tabIndex = -1);
    }), this.value = O[B].value, O[B].checked = !0, this.hasButtonGroup ? O[B].shadowRoot.querySelector("button").focus() : (O[B].tabIndex = 0, O[B].focus()), this.value !== W && (this.emit("sl-change"), this.emit("sl-input")), z.preventDefault();
  }
  handleLabelClick() {
    const z = this.getAllRadios(), O = z.find((F) => F.checked) || z[0];
    O && O.focus();
  }
  handleInvalid(z) {
    this.formControlController.setValidity(!1), this.formControlController.emitInvalidEvent(z);
  }
  async syncRadioElements() {
    var z, D;
    const O = this.getAllRadios();
    if (await Promise.all(
      // Sync the checked state and size
      O.map(async (F) => {
        await F.updateComplete, F.checked = F.value === this.value, F.size = this.size;
      })
    ), this.hasButtonGroup = O.some((F) => F.tagName.toLowerCase() === "sl-radio-button"), O.length > 0 && !O.some((F) => F.checked))
      if (this.hasButtonGroup) {
        const F = (z = O[0].shadowRoot) == null ? void 0 : z.querySelector("button");
        F && (F.tabIndex = 0);
      } else
        O[0].tabIndex = 0;
    if (this.hasButtonGroup) {
      const F = (D = this.shadowRoot) == null ? void 0 : D.querySelector("sl-button-group");
      F && (F.disableRole = !0);
    }
  }
  syncRadios() {
    if (customElements.get("sl-radio") && customElements.get("sl-radio-button")) {
      this.syncRadioElements();
      return;
    }
    customElements.get("sl-radio") ? this.syncRadioElements() : customElements.whenDefined("sl-radio").then(() => this.syncRadios()), customElements.get("sl-radio-button") ? this.syncRadioElements() : customElements.whenDefined("sl-radio-button").then(() => this.syncRadios());
  }
  updateCheckedRadio() {
    this.getAllRadios().forEach((D) => D.checked = D.value === this.value), this.formControlController.setValidity(this.validity.valid);
  }
  handleSizeChange() {
    this.syncRadios();
  }
  handleValueChange() {
    this.hasUpdated && this.updateCheckedRadio();
  }
  /** Checks for validity but does not show a validation message. Returns `true` when valid and `false` when invalid. */
  checkValidity() {
    const z = this.required && !this.value, D = this.customValidityMessage !== "";
    return z || D ? (this.formControlController.emitInvalidEvent(), !1) : !0;
  }
  /** Gets the associated form, if one exists. */
  getForm() {
    return this.formControlController.getForm();
  }
  /** Checks for validity and shows the browser's validation message if the control is invalid. */
  reportValidity() {
    const z = this.validity.valid;
    return this.errorMessage = this.customValidityMessage || z ? "" : this.validationInput.validationMessage, this.formControlController.setValidity(z), this.validationInput.hidden = !0, clearTimeout(this.validationTimeout), z || (this.validationInput.hidden = !1, this.validationInput.reportValidity(), this.validationTimeout = setTimeout(() => this.validationInput.hidden = !0, 1e4)), z;
  }
  /** Sets a custom validation message. Pass an empty string to restore validity. */
  setCustomValidity(z = "") {
    this.customValidityMessage = z, this.errorMessage = z, this.validationInput.setCustomValidity(z), this.formControlController.updateValidity();
  }
  render() {
    const z = this.hasSlotController.test("label"), D = this.hasSlotController.test("help-text"), O = this.label ? !0 : !!z, F = this.helpText ? !0 : !!D, U = x`
      <slot @slotchange=${this.syncRadios} @click=${this.handleRadioClick} @keydown=${this.handleKeyDown}></slot>
    `;
    return x`
      <fieldset
        part="form-control"
        class=${e$2({
      "form-control": !0,
      "form-control--small": this.size === "small",
      "form-control--medium": this.size === "medium",
      "form-control--large": this.size === "large",
      "form-control--radio-group": !0,
      "form-control--has-label": O,
      "form-control--has-help-text": F
    })}
        role="radiogroup"
        aria-labelledby="label"
        aria-describedby="help-text"
        aria-errormessage="error-message"
      >
        <label
          part="form-control-label"
          id="label"
          class="form-control__label"
          aria-hidden=${O ? "false" : "true"}
          @click=${this.handleLabelClick}
        >
          <slot name="label">${this.label}</slot>
        </label>

        <div part="form-control-input" class="form-control-input">
          <div class="visually-hidden">
            <div id="error-message" aria-live="assertive">${this.errorMessage}</div>
            <label class="radio-group__validation">
              <input
                type="text"
                class="radio-group__validation-input"
                ?required=${this.required}
                tabindex="-1"
                hidden
                @invalid=${this.handleInvalid}
              />
            </label>
          </div>

          ${this.hasButtonGroup ? x`
                <sl-button-group part="button-group" exportparts="base:button-group__base" role="presentation">
                  ${U}
                </sl-button-group>
              ` : U}
        </div>

        <div
          part="form-control-help-text"
          id="help-text"
          class="form-control__help-text"
          aria-hidden=${F ? "false" : "true"}
        >
          <slot name="help-text">${this.helpText}</slot>
        </div>
      </fieldset>
    `;
  }
};
SlRadioGroup.styles = [component_styles_default, form_control_styles_default, radio_group_styles_default];
SlRadioGroup.dependencies = { "sl-button-group": SlButtonGroup };
__decorateClass([
  e$b("slot:not([name])")
], SlRadioGroup.prototype, "defaultSlot", 2);
__decorateClass([
  e$b(".radio-group__validation-input")
], SlRadioGroup.prototype, "validationInput", 2);
__decorateClass([
  r$4()
], SlRadioGroup.prototype, "hasButtonGroup", 2);
__decorateClass([
  r$4()
], SlRadioGroup.prototype, "errorMessage", 2);
__decorateClass([
  r$4()
], SlRadioGroup.prototype, "defaultValue", 2);
__decorateClass([
  n$6()
], SlRadioGroup.prototype, "label", 2);
__decorateClass([
  n$6({ attribute: "help-text" })
], SlRadioGroup.prototype, "helpText", 2);
__decorateClass([
  n$6()
], SlRadioGroup.prototype, "name", 2);
__decorateClass([
  n$6({ reflect: !0 })
], SlRadioGroup.prototype, "value", 2);
__decorateClass([
  n$6({ reflect: !0 })
], SlRadioGroup.prototype, "size", 2);
__decorateClass([
  n$6({ reflect: !0 })
], SlRadioGroup.prototype, "form", 2);
__decorateClass([
  n$6({ type: Boolean, reflect: !0 })
], SlRadioGroup.prototype, "required", 2);
__decorateClass([
  watch("size", { waitUntilFirstUpdate: !0 })
], SlRadioGroup.prototype, "handleSizeChange", 1);
__decorateClass([
  watch("value")
], SlRadioGroup.prototype, "handleValueChange", 1);
SlRadioGroup.define("sl-radio-group");
var range_styles_default = i$7`
  :host {
    --thumb-size: 20px;
    --tooltip-offset: 10px;
    --track-color-active: var(--sl-color-neutral-200);
    --track-color-inactive: var(--sl-color-neutral-200);
    --track-active-offset: 0%;
    --track-height: 6px;

    display: block;
  }

  .range {
    position: relative;
  }

  .range__control {
    --percent: 0%;
    -webkit-appearance: none;
    border-radius: 3px;
    width: 100%;
    height: var(--track-height);
    background: transparent;
    line-height: var(--sl-input-height-medium);
    vertical-align: middle;
    margin: 0;

    background-image: linear-gradient(
      to right,
      var(--track-color-inactive) 0%,
      var(--track-color-inactive) min(var(--percent), var(--track-active-offset)),
      var(--track-color-active) min(var(--percent), var(--track-active-offset)),
      var(--track-color-active) max(var(--percent), var(--track-active-offset)),
      var(--track-color-inactive) max(var(--percent), var(--track-active-offset)),
      var(--track-color-inactive) 100%
    );
  }

  .range--rtl .range__control {
    background-image: linear-gradient(
      to left,
      var(--track-color-inactive) 0%,
      var(--track-color-inactive) min(var(--percent), var(--track-active-offset)),
      var(--track-color-active) min(var(--percent), var(--track-active-offset)),
      var(--track-color-active) max(var(--percent), var(--track-active-offset)),
      var(--track-color-inactive) max(var(--percent), var(--track-active-offset)),
      var(--track-color-inactive) 100%
    );
  }

  /* Webkit */
  .range__control::-webkit-slider-runnable-track {
    width: 100%;
    height: var(--track-height);
    border-radius: 3px;
    border: none;
  }

  .range__control::-webkit-slider-thumb {
    border: none;
    width: var(--thumb-size);
    height: var(--thumb-size);
    border-radius: 50%;
    background-color: var(--sl-color-primary-600);
    border: solid var(--sl-input-border-width) var(--sl-color-primary-600);
    -webkit-appearance: none;
    margin-top: calc(var(--thumb-size) / -2 + var(--track-height) / 2);
    cursor: pointer;
  }

  .range__control:enabled::-webkit-slider-thumb:hover {
    background-color: var(--sl-color-primary-500);
    border-color: var(--sl-color-primary-500);
  }

  .range__control:enabled:focus-visible::-webkit-slider-thumb {
    outline: var(--sl-focus-ring);
    outline-offset: var(--sl-focus-ring-offset);
  }

  .range__control:enabled::-webkit-slider-thumb:active {
    background-color: var(--sl-color-primary-500);
    border-color: var(--sl-color-primary-500);
    cursor: grabbing;
  }

  /* Firefox */
  .range__control::-moz-focus-outer {
    border: 0;
  }

  .range__control::-moz-range-progress {
    background-color: var(--track-color-active);
    border-radius: 3px;
    height: var(--track-height);
  }

  .range__control::-moz-range-track {
    width: 100%;
    height: var(--track-height);
    background-color: var(--track-color-inactive);
    border-radius: 3px;
    border: none;
  }

  .range__control::-moz-range-thumb {
    border: none;
    height: var(--thumb-size);
    width: var(--thumb-size);
    border-radius: 50%;
    background-color: var(--sl-color-primary-600);
    border-color: var(--sl-color-primary-600);
    transition:
      var(--sl-transition-fast) border-color,
      var(--sl-transition-fast) background-color,
      var(--sl-transition-fast) color,
      var(--sl-transition-fast) box-shadow;
    cursor: pointer;
  }

  .range__control:enabled::-moz-range-thumb:hover {
    background-color: var(--sl-color-primary-500);
    border-color: var(--sl-color-primary-500);
  }

  .range__control:enabled:focus-visible::-moz-range-thumb {
    outline: var(--sl-focus-ring);
    outline-offset: var(--sl-focus-ring-offset);
  }

  .range__control:enabled::-moz-range-thumb:active {
    background-color: var(--sl-color-primary-500);
    border-color: var(--sl-color-primary-500);
    cursor: grabbing;
  }

  /* States */
  .range__control:focus-visible {
    outline: none;
  }

  .range__control:disabled {
    opacity: 0.5;
  }

  .range__control:disabled::-webkit-slider-thumb {
    cursor: not-allowed;
  }

  .range__control:disabled::-moz-range-thumb {
    cursor: not-allowed;
  }

  /* Tooltip output */
  .range__tooltip {
    position: absolute;
    z-index: var(--sl-z-index-tooltip);
    left: 0;
    border-radius: var(--sl-tooltip-border-radius);
    background-color: var(--sl-tooltip-background-color);
    font-family: var(--sl-tooltip-font-family);
    font-size: var(--sl-tooltip-font-size);
    font-weight: var(--sl-tooltip-font-weight);
    line-height: var(--sl-tooltip-line-height);
    color: var(--sl-tooltip-color);
    opacity: 0;
    padding: var(--sl-tooltip-padding);
    transition: var(--sl-transition-fast) opacity;
    pointer-events: none;
  }

  .range__tooltip:after {
    content: '';
    position: absolute;
    width: 0;
    height: 0;
    left: 50%;
    translate: calc(-1 * var(--sl-tooltip-arrow-size));
  }

  .range--tooltip-visible .range__tooltip {
    opacity: 1;
  }

  /* Tooltip on top */
  .range--tooltip-top .range__tooltip {
    top: calc(-1 * var(--thumb-size) - var(--tooltip-offset));
  }

  .range--tooltip-top .range__tooltip:after {
    border-top: var(--sl-tooltip-arrow-size) solid var(--sl-tooltip-background-color);
    border-left: var(--sl-tooltip-arrow-size) solid transparent;
    border-right: var(--sl-tooltip-arrow-size) solid transparent;
    top: 100%;
  }

  /* Tooltip on bottom */
  .range--tooltip-bottom .range__tooltip {
    bottom: calc(-1 * var(--thumb-size) - var(--tooltip-offset));
  }

  .range--tooltip-bottom .range__tooltip:after {
    border-bottom: var(--sl-tooltip-arrow-size) solid var(--sl-tooltip-background-color);
    border-left: var(--sl-tooltip-arrow-size) solid transparent;
    border-right: var(--sl-tooltip-arrow-size) solid transparent;
    bottom: 100%;
  }

  @media (forced-colors: active) {
    .range__control,
    .range__tooltip {
      border: solid 1px transparent;
    }

    .range__control::-webkit-slider-thumb {
      border: solid 1px transparent;
    }

    .range__control::-moz-range-thumb {
      border: solid 1px transparent;
    }

    .range__tooltip:after {
      display: none;
    }
  }
`, SlRange = class extends ShoelaceElement {
  constructor() {
    super(...arguments), this.formControlController = new FormControlController(this), this.hasSlotController = new HasSlotController(this, "help-text", "label"), this.localize = new LocalizeController(this), this.hasFocus = !1, this.hasTooltip = !1, this.title = "", this.name = "", this.value = 0, this.label = "", this.helpText = "", this.disabled = !1, this.min = 0, this.max = 100, this.step = 1, this.tooltip = "top", this.tooltipFormatter = (z) => z.toString(), this.form = "", this.defaultValue = 0;
  }
  /** Gets the validity state object */
  get validity() {
    return this.input.validity;
  }
  /** Gets the validation message */
  get validationMessage() {
    return this.input.validationMessage;
  }
  connectedCallback() {
    super.connectedCallback(), this.resizeObserver = new ResizeObserver(() => this.syncRange()), this.value < this.min && (this.value = this.min), this.value > this.max && (this.value = this.max), this.updateComplete.then(() => {
      this.syncRange(), this.resizeObserver.observe(this.input);
    });
  }
  disconnectedCallback() {
    super.disconnectedCallback(), this.resizeObserver.unobserve(this.input);
  }
  handleChange() {
    this.emit("sl-change");
  }
  handleInput() {
    this.value = parseFloat(this.input.value), this.emit("sl-input"), this.syncRange();
  }
  handleBlur() {
    this.hasFocus = !1, this.hasTooltip = !1, this.emit("sl-blur");
  }
  handleFocus() {
    this.hasFocus = !0, this.hasTooltip = !0, this.emit("sl-focus");
  }
  handleThumbDragStart() {
    this.hasTooltip = !0;
  }
  handleThumbDragEnd() {
    this.hasTooltip = !1;
  }
  syncProgress(z) {
    this.input.style.setProperty("--percent", `${z * 100}%`);
  }
  syncTooltip(z) {
    if (this.output !== null) {
      const D = this.input.offsetWidth, O = this.output.offsetWidth, F = getComputedStyle(this.input).getPropertyValue("--thumb-size"), U = this.localize.dir() === "rtl", W = D * z;
      if (U) {
        const B = `${D - W}px + ${z} * ${F}`;
        this.output.style.translate = `calc((${B} - ${O / 2}px - ${F} / 2))`;
      } else {
        const B = `${W}px - ${z} * ${F}`;
        this.output.style.translate = `calc(${B} - ${O / 2}px + ${F} / 2)`;
      }
    }
  }
  handleValueChange() {
    this.formControlController.updateValidity(), this.input.value = this.value.toString(), this.value = parseFloat(this.input.value), this.syncRange();
  }
  handleDisabledChange() {
    this.formControlController.setValidity(this.disabled);
  }
  syncRange() {
    const z = Math.max(0, (this.value - this.min) / (this.max - this.min));
    this.syncProgress(z), this.tooltip !== "none" && this.updateComplete.then(() => this.syncTooltip(z));
  }
  handleInvalid(z) {
    this.formControlController.setValidity(!1), this.formControlController.emitInvalidEvent(z);
  }
  /** Sets focus on the range. */
  focus(z) {
    this.input.focus(z);
  }
  /** Removes focus from the range. */
  blur() {
    this.input.blur();
  }
  /** Increments the value of the range by the value of the step attribute. */
  stepUp() {
    this.input.stepUp(), this.value !== Number(this.input.value) && (this.value = Number(this.input.value));
  }
  /** Decrements the value of the range by the value of the step attribute. */
  stepDown() {
    this.input.stepDown(), this.value !== Number(this.input.value) && (this.value = Number(this.input.value));
  }
  /** Checks for validity but does not show a validation message. Returns `true` when valid and `false` when invalid. */
  checkValidity() {
    return this.input.checkValidity();
  }
  /** Gets the associated form, if one exists. */
  getForm() {
    return this.formControlController.getForm();
  }
  /** Checks for validity and shows the browser's validation message if the control is invalid. */
  reportValidity() {
    return this.input.reportValidity();
  }
  /** Sets a custom validation message. Pass an empty string to restore validity. */
  setCustomValidity(z) {
    this.input.setCustomValidity(z), this.formControlController.updateValidity();
  }
  render() {
    const z = this.hasSlotController.test("label"), D = this.hasSlotController.test("help-text"), O = this.label ? !0 : !!z, F = this.helpText ? !0 : !!D;
    return x`
      <div
        part="form-control"
        class=${e$2({
      "form-control": !0,
      "form-control--medium": !0,
      // range only has one size
      "form-control--has-label": O,
      "form-control--has-help-text": F
    })}
      >
        <label
          part="form-control-label"
          class="form-control__label"
          for="input"
          aria-hidden=${O ? "false" : "true"}
        >
          <slot name="label">${this.label}</slot>
        </label>

        <div part="form-control-input" class="form-control-input">
          <div
            part="base"
            class=${e$2({
      range: !0,
      "range--disabled": this.disabled,
      "range--focused": this.hasFocus,
      "range--rtl": this.localize.dir() === "rtl",
      "range--tooltip-visible": this.hasTooltip,
      "range--tooltip-top": this.tooltip === "top",
      "range--tooltip-bottom": this.tooltip === "bottom"
    })}
            @mousedown=${this.handleThumbDragStart}
            @mouseup=${this.handleThumbDragEnd}
            @touchstart=${this.handleThumbDragStart}
            @touchend=${this.handleThumbDragEnd}
          >
            <input
              part="input"
              id="input"
              class="range__control"
              title=${this.title}
              type="range"
              name=${o$6(this.name)}
              ?disabled=${this.disabled}
              min=${o$6(this.min)}
              max=${o$6(this.max)}
              step=${o$6(this.step)}
              .value=${l$1(this.value.toString())}
              aria-describedby="help-text"
              @change=${this.handleChange}
              @focus=${this.handleFocus}
              @input=${this.handleInput}
              @invalid=${this.handleInvalid}
              @blur=${this.handleBlur}
            />
            ${this.tooltip !== "none" && !this.disabled ? x`
                  <output part="tooltip" class="range__tooltip">
                    ${typeof this.tooltipFormatter == "function" ? this.tooltipFormatter(this.value) : this.value}
                  </output>
                ` : ""}
          </div>
        </div>

        <div
          part="form-control-help-text"
          id="help-text"
          class="form-control__help-text"
          aria-hidden=${F ? "false" : "true"}
        >
          <slot name="help-text">${this.helpText}</slot>
        </div>
      </div>
    `;
  }
};
SlRange.styles = [component_styles_default, form_control_styles_default, range_styles_default];
__decorateClass([
  e$b(".range__control")
], SlRange.prototype, "input", 2);
__decorateClass([
  e$b(".range__tooltip")
], SlRange.prototype, "output", 2);
__decorateClass([
  r$4()
], SlRange.prototype, "hasFocus", 2);
__decorateClass([
  r$4()
], SlRange.prototype, "hasTooltip", 2);
__decorateClass([
  n$6()
], SlRange.prototype, "title", 2);
__decorateClass([
  n$6()
], SlRange.prototype, "name", 2);
__decorateClass([
  n$6({ type: Number })
], SlRange.prototype, "value", 2);
__decorateClass([
  n$6()
], SlRange.prototype, "label", 2);
__decorateClass([
  n$6({ attribute: "help-text" })
], SlRange.prototype, "helpText", 2);
__decorateClass([
  n$6({ type: Boolean, reflect: !0 })
], SlRange.prototype, "disabled", 2);
__decorateClass([
  n$6({ type: Number })
], SlRange.prototype, "min", 2);
__decorateClass([
  n$6({ type: Number })
], SlRange.prototype, "max", 2);
__decorateClass([
  n$6({ type: Number })
], SlRange.prototype, "step", 2);
__decorateClass([
  n$6()
], SlRange.prototype, "tooltip", 2);
__decorateClass([
  n$6({ attribute: !1 })
], SlRange.prototype, "tooltipFormatter", 2);
__decorateClass([
  n$6({ reflect: !0 })
], SlRange.prototype, "form", 2);
__decorateClass([
  defaultValue()
], SlRange.prototype, "defaultValue", 2);
__decorateClass([
  t$4({ passive: !0 })
], SlRange.prototype, "handleThumbDragStart", 1);
__decorateClass([
  watch("value", { waitUntilFirstUpdate: !0 })
], SlRange.prototype, "handleValueChange", 1);
__decorateClass([
  watch("disabled", { waitUntilFirstUpdate: !0 })
], SlRange.prototype, "handleDisabledChange", 1);
__decorateClass([
  watch("hasTooltip", { waitUntilFirstUpdate: !0 })
], SlRange.prototype, "syncRange", 1);
SlRange.define("sl-range");
var progress_ring_styles_default = i$7`
  :host {
    --size: 128px;
    --track-width: 4px;
    --track-color: var(--sl-color-neutral-200);
    --indicator-width: var(--track-width);
    --indicator-color: var(--sl-color-primary-600);
    --indicator-transition-duration: 0.35s;

    display: inline-flex;
  }

  .progress-ring {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    position: relative;
  }

  .progress-ring__image {
    width: var(--size);
    height: var(--size);
    rotate: -90deg;
    transform-origin: 50% 50%;
  }

  .progress-ring__track,
  .progress-ring__indicator {
    --radius: calc(var(--size) / 2 - max(var(--track-width), var(--indicator-width)) * 0.5);
    --circumference: calc(var(--radius) * 2 * 3.141592654);

    fill: none;
    r: var(--radius);
    cx: calc(var(--size) / 2);
    cy: calc(var(--size) / 2);
  }

  .progress-ring__track {
    stroke: var(--track-color);
    stroke-width: var(--track-width);
  }

  .progress-ring__indicator {
    stroke: var(--indicator-color);
    stroke-width: var(--indicator-width);
    stroke-linecap: round;
    transition-property: stroke-dashoffset;
    transition-duration: var(--indicator-transition-duration);
    stroke-dasharray: var(--circumference) var(--circumference);
    stroke-dashoffset: calc(var(--circumference) - var(--percentage) * var(--circumference));
  }

  .progress-ring__label {
    display: flex;
    align-items: center;
    justify-content: center;
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    text-align: center;
    user-select: none;
    -webkit-user-select: none;
  }
`, SlProgressRing = class extends ShoelaceElement {
  constructor() {
    super(...arguments), this.localize = new LocalizeController(this), this.value = 0, this.label = "";
  }
  updated(z) {
    if (super.updated(z), z.has("value")) {
      const D = parseFloat(getComputedStyle(this.indicator).getPropertyValue("r")), O = 2 * Math.PI * D, F = O - this.value / 100 * O;
      this.indicatorOffset = `${F}px`;
    }
  }
  render() {
    return x`
      <div
        part="base"
        class="progress-ring"
        role="progressbar"
        aria-label=${this.label.length > 0 ? this.label : this.localize.term("progress")}
        aria-describedby="label"
        aria-valuemin="0"
        aria-valuemax="100"
        aria-valuenow="${this.value}"
        style="--percentage: ${this.value / 100}"
      >
        <svg class="progress-ring__image">
          <circle class="progress-ring__track"></circle>
          <circle class="progress-ring__indicator" style="stroke-dashoffset: ${this.indicatorOffset}"></circle>
        </svg>

        <slot id="label" part="label" class="progress-ring__label"></slot>
      </div>
    `;
  }
};
SlProgressRing.styles = [component_styles_default, progress_ring_styles_default];
__decorateClass([
  e$b(".progress-ring__indicator")
], SlProgressRing.prototype, "indicator", 2);
__decorateClass([
  r$4()
], SlProgressRing.prototype, "indicatorOffset", 2);
__decorateClass([
  n$6({ type: Number, reflect: !0 })
], SlProgressRing.prototype, "value", 2);
__decorateClass([
  n$6()
], SlProgressRing.prototype, "label", 2);
SlProgressRing.define("sl-progress-ring");
var qr_code_styles_default = i$7`
  :host {
    display: inline-block;
  }
`;
let G = null;
class H {
}
H.render = function(z, D) {
  G(z, D);
};
self.QrCreator = H;
(function(z) {
  function D(K, X, Y, Q) {
    var J = {}, ee = z(Y, X);
    ee.u(K), ee.J(), Q = Q || 0;
    var ae = ee.h(), re = ee.h() + 2 * Q;
    return J.text = K, J.level = X, J.version = Y, J.O = re, J.a = function(ie, ue) {
      return ie -= Q, ue -= Q, 0 > ie || ie >= ae || 0 > ue || ue >= ae ? !1 : ee.a(ie, ue);
    }, J;
  }
  function O(K, X, Y, Q, J, ee, ae, re, ie, ue) {
    function q(ne, ce, he, we, me, de, be) {
      ne ? (K.lineTo(ce + de, he + be), K.arcTo(ce, he, we, me, ee)) : K.lineTo(ce, he);
    }
    ae ? K.moveTo(X + ee, Y) : K.moveTo(X, Y), q(re, Q, Y, Q, J, -ee, 0), q(ie, Q, J, X, J, 0, -ee), q(ue, X, J, X, Y, ee, 0), q(ae, X, Y, Q, Y, 0, ee);
  }
  function F(K, X, Y, Q, J, ee, ae, re, ie, ue) {
    function q(ne, ce, he, we) {
      K.moveTo(ne + he, ce), K.lineTo(
        ne,
        ce
      ), K.lineTo(ne, ce + we), K.arcTo(ne, ce, ne + he, ce, ee);
    }
    ae && q(X, Y, ee, ee), re && q(Q, Y, -ee, ee), ie && q(Q, J, -ee, -ee), ue && q(X, J, ee, -ee);
  }
  function U(K, X) {
    var Y = X.fill;
    if (typeof Y == "string")
      K.fillStyle = Y;
    else {
      var Q = Y.type, J = Y.colorStops;
      if (Y = Y.position.map((ae) => Math.round(ae * X.size)), Q === "linear-gradient")
        var ee = K.createLinearGradient.apply(K, Y);
      else if (Q === "radial-gradient")
        ee = K.createRadialGradient.apply(K, Y);
      else
        throw Error("Unsupported fill");
      J.forEach(([ae, re]) => {
        ee.addColorStop(ae, re);
      }), K.fillStyle = ee;
    }
  }
  function W(K, X) {
    e: {
      var Y = X.text, Q = X.v, J = X.N, ee = X.K, ae = X.P;
      for (J = Math.max(1, J || 1), ee = Math.min(40, ee || 40); J <= ee; J += 1)
        try {
          var re = D(Y, Q, J, ae);
          break e;
        } catch {
        }
      re = void 0;
    }
    if (!re)
      return null;
    for (Y = K.getContext("2d"), X.background && (Y.fillStyle = X.background, Y.fillRect(X.left, X.top, X.size, X.size)), Q = re.O, ee = X.size / Q, Y.beginPath(), ae = 0; ae < Q; ae += 1)
      for (J = 0; J < Q; J += 1) {
        var ie = Y, ue = X.left + J * ee, q = X.top + ae * ee, ne = ae, ce = J, he = re.a, we = ue + ee, me = q + ee, de = ne - 1, be = ne + 1, _e = ce - 1, Me = ce + 1, Ne = Math.floor(Math.min(0.5, Math.max(0, X.R)) * ee), Ee = he(ne, ce), $e = he(de, _e), De = he(de, ce);
        de = he(de, Me);
        var Fe = he(ne, Me);
        Me = he(be, Me), ce = he(
          be,
          ce
        ), be = he(be, _e), ne = he(ne, _e), ue = Math.round(ue), q = Math.round(q), we = Math.round(we), me = Math.round(me), Ee ? O(ie, ue, q, we, me, Ne, !De && !ne, !De && !Fe, !ce && !Fe, !ce && !ne) : F(ie, ue, q, we, me, Ne, De && ne && $e, De && Fe && de, ce && Fe && Me, ce && ne && be);
      }
    return U(Y, X), Y.fill(), K;
  }
  var B = { minVersion: 1, maxVersion: 40, ecLevel: "L", left: 0, top: 0, size: 200, fill: "#000", background: null, text: "no text", radius: 0.5, quiet: 0 };
  G = function(K, X) {
    var Y = {};
    Object.assign(Y, B, K), Y.N = Y.minVersion, Y.K = Y.maxVersion, Y.v = Y.ecLevel, Y.left = Y.left, Y.top = Y.top, Y.size = Y.size, Y.fill = Y.fill, Y.background = Y.background, Y.text = Y.text, Y.R = Y.radius, Y.P = Y.quiet, X instanceof HTMLCanvasElement ? ((X.width !== Y.size || X.height !== Y.size) && (X.width = Y.size, X.height = Y.size), X.getContext("2d").clearRect(0, 0, X.width, X.height), W(X, Y)) : (K = document.createElement("canvas"), K.width = Y.size, K.height = Y.size, Y = W(K, Y), X.appendChild(Y));
  };
})(function() {
  function z(X) {
    var Y = O.s(X);
    return { S: function() {
      return 4;
    }, b: function() {
      return Y.length;
    }, write: function(Q) {
      for (var J = 0; J < Y.length; J += 1)
        Q.put(Y[J], 8);
    } };
  }
  function D() {
    var X = [], Y = 0, Q = {
      B: function() {
        return X;
      },
      c: function(J) {
        return (X[Math.floor(J / 8)] >>> 7 - J % 8 & 1) == 1;
      },
      put: function(J, ee) {
        for (var ae = 0; ae < ee; ae += 1)
          Q.m((J >>> ee - ae - 1 & 1) == 1);
      },
      f: function() {
        return Y;
      },
      m: function(J) {
        var ee = Math.floor(Y / 8);
        X.length <= ee && X.push(0), J && (X[ee] |= 128 >>> Y % 8), Y += 1;
      }
    };
    return Q;
  }
  function O(X, Y) {
    function Q(ne, ce) {
      for (var he = -1; 7 >= he; he += 1)
        if (!(-1 >= ne + he || re <= ne + he))
          for (var we = -1; 7 >= we; we += 1)
            -1 >= ce + we || re <= ce + we || (ae[ne + he][ce + we] = 0 <= he && 6 >= he && (we == 0 || we == 6) || 0 <= we && 6 >= we && (he == 0 || he == 6) || 2 <= he && 4 >= he && 2 <= we && 4 >= we);
    }
    function J(ne, ce) {
      for (var he = re = 4 * X + 17, we = Array(he), me = 0; me < he; me += 1) {
        we[me] = Array(he);
        for (var de = 0; de < he; de += 1)
          we[me][de] = null;
      }
      for (ae = we, Q(0, 0), Q(re - 7, 0), Q(0, re - 7), he = W.G(X), we = 0; we < he.length; we += 1)
        for (me = 0; me < he.length; me += 1) {
          de = he[we];
          var be = he[me];
          if (ae[de][be] == null)
            for (var _e = -2; 2 >= _e; _e += 1)
              for (var Me = -2; 2 >= Me; Me += 1)
                ae[de + _e][be + Me] = _e == -2 || _e == 2 || Me == -2 || Me == 2 || _e == 0 && Me == 0;
        }
      for (he = 8; he < re - 8; he += 1)
        ae[he][6] == null && (ae[he][6] = he % 2 == 0);
      for (he = 8; he < re - 8; he += 1)
        ae[6][he] == null && (ae[6][he] = he % 2 == 0);
      for (he = W.w(ee << 3 | ce), we = 0; 15 > we; we += 1)
        me = !ne && (he >> we & 1) == 1, ae[6 > we ? we : 8 > we ? we + 1 : re - 15 + we][8] = me, ae[8][8 > we ? re - we - 1 : 9 > we ? 15 - we : 14 - we] = me;
      if (ae[re - 8][8] = !ne, 7 <= X) {
        for (he = W.A(X), we = 0; 18 > we; we += 1)
          me = !ne && (he >> we & 1) == 1, ae[Math.floor(we / 3)][we % 3 + re - 8 - 3] = me;
        for (we = 0; 18 > we; we += 1)
          me = !ne && (he >> we & 1) == 1, ae[we % 3 + re - 8 - 3][Math.floor(we / 3)] = me;
      }
      if (ie == null) {
        for (ne = K.I(X, ee), he = D(), we = 0; we < ue.length; we += 1)
          me = ue[we], he.put(4, 4), he.put(me.b(), W.f(4, X)), me.write(he);
        for (we = me = 0; we < ne.length; we += 1)
          me += ne[we].j;
        if (he.f() > 8 * me)
          throw Error("code length overflow. (" + he.f() + ">" + 8 * me + ")");
        for (he.f() + 4 <= 8 * me && he.put(0, 4); he.f() % 8 != 0; )
          he.m(!1);
        for (; !(he.f() >= 8 * me) && (he.put(236, 8), !(he.f() >= 8 * me)); )
          he.put(17, 8);
        var Ne = 0;
        for (me = we = 0, de = Array(ne.length), be = Array(ne.length), _e = 0; _e < ne.length; _e += 1) {
          var Ee = ne[_e].j, $e = ne[_e].o - Ee;
          for (we = Math.max(we, Ee), me = Math.max(me, $e), de[_e] = Array(Ee), Me = 0; Me < de[_e].length; Me += 1)
            de[_e][Me] = 255 & he.B()[Me + Ne];
          for (Ne += Ee, Me = W.C($e), Ee = F(de[_e], Me.b() - 1).l(Me), be[_e] = Array(Me.b() - 1), Me = 0; Me < be[_e].length; Me += 1)
            $e = Me + Ee.b() - be[_e].length, be[_e][Me] = 0 <= $e ? Ee.c($e) : 0;
        }
        for (Me = he = 0; Me < ne.length; Me += 1)
          he += ne[Me].o;
        for (he = Array(he), Me = Ne = 0; Me < we; Me += 1)
          for (_e = 0; _e < ne.length; _e += 1)
            Me < de[_e].length && (he[Ne] = de[_e][Me], Ne += 1);
        for (Me = 0; Me < me; Me += 1)
          for (_e = 0; _e < ne.length; _e += 1)
            Me < be[_e].length && (he[Ne] = be[_e][Me], Ne += 1);
        ie = he;
      }
      for (ne = ie, he = -1, we = re - 1, me = 7, de = 0, ce = W.F(ce), be = re - 1; 0 < be; be -= 2)
        for (be == 6 && --be; ; ) {
          for (_e = 0; 2 > _e; _e += 1)
            ae[we][be - _e] == null && (Me = !1, de < ne.length && (Me = (ne[de] >>> me & 1) == 1), ce(we, be - _e) && (Me = !Me), ae[we][be - _e] = Me, --me, me == -1 && (de += 1, me = 7));
          if (we += he, 0 > we || re <= we) {
            we -= he, he = -he;
            break;
          }
        }
    }
    var ee = U[Y], ae = null, re = 0, ie = null, ue = [], q = { u: function(ne) {
      ne = z(ne), ue.push(ne), ie = null;
    }, a: function(ne, ce) {
      if (0 > ne || re <= ne || 0 > ce || re <= ce)
        throw Error(ne + "," + ce);
      return ae[ne][ce];
    }, h: function() {
      return re;
    }, J: function() {
      for (var ne = 0, ce = 0, he = 0; 8 > he; he += 1) {
        J(!0, he);
        var we = W.D(q);
        (he == 0 || ne > we) && (ne = we, ce = he);
      }
      J(!1, ce);
    } };
    return q;
  }
  function F(X, Y) {
    if (typeof X.length > "u")
      throw Error(X.length + "/" + Y);
    var Q = function() {
      for (var ee = 0; ee < X.length && X[ee] == 0; )
        ee += 1;
      for (var ae = Array(X.length - ee + Y), re = 0; re < X.length - ee; re += 1)
        ae[re] = X[re + ee];
      return ae;
    }(), J = { c: function(ee) {
      return Q[ee];
    }, b: function() {
      return Q.length;
    }, multiply: function(ee) {
      for (var ae = Array(J.b() + ee.b() - 1), re = 0; re < J.b(); re += 1)
        for (var ie = 0; ie < ee.b(); ie += 1)
          ae[re + ie] ^= B.i(B.g(J.c(re)) + B.g(ee.c(ie)));
      return F(ae, 0);
    }, l: function(ee) {
      if (0 > J.b() - ee.b())
        return J;
      for (var ae = B.g(J.c(0)) - B.g(ee.c(0)), re = Array(J.b()), ie = 0; ie < J.b(); ie += 1)
        re[ie] = J.c(ie);
      for (ie = 0; ie < ee.b(); ie += 1)
        re[ie] ^= B.i(B.g(ee.c(ie)) + ae);
      return F(re, 0).l(ee);
    } };
    return J;
  }
  O.s = function(X) {
    for (var Y = [], Q = 0; Q < X.length; Q++) {
      var J = X.charCodeAt(Q);
      128 > J ? Y.push(J) : 2048 > J ? Y.push(192 | J >> 6, 128 | J & 63) : 55296 > J || 57344 <= J ? Y.push(224 | J >> 12, 128 | J >> 6 & 63, 128 | J & 63) : (Q++, J = 65536 + ((J & 1023) << 10 | X.charCodeAt(Q) & 1023), Y.push(240 | J >> 18, 128 | J >> 12 & 63, 128 | J >> 6 & 63, 128 | J & 63));
    }
    return Y;
  };
  var U = { L: 1, M: 0, Q: 3, H: 2 }, W = /* @__PURE__ */ function() {
    function X(J) {
      for (var ee = 0; J != 0; )
        ee += 1, J >>>= 1;
      return ee;
    }
    var Y = [
      [],
      [6, 18],
      [6, 22],
      [6, 26],
      [6, 30],
      [6, 34],
      [6, 22, 38],
      [6, 24, 42],
      [6, 26, 46],
      [6, 28, 50],
      [6, 30, 54],
      [6, 32, 58],
      [6, 34, 62],
      [6, 26, 46, 66],
      [6, 26, 48, 70],
      [6, 26, 50, 74],
      [6, 30, 54, 78],
      [6, 30, 56, 82],
      [6, 30, 58, 86],
      [6, 34, 62, 90],
      [6, 28, 50, 72, 94],
      [6, 26, 50, 74, 98],
      [6, 30, 54, 78, 102],
      [6, 28, 54, 80, 106],
      [6, 32, 58, 84, 110],
      [6, 30, 58, 86, 114],
      [6, 34, 62, 90, 118],
      [6, 26, 50, 74, 98, 122],
      [6, 30, 54, 78, 102, 126],
      [6, 26, 52, 78, 104, 130],
      [6, 30, 56, 82, 108, 134],
      [6, 34, 60, 86, 112, 138],
      [6, 30, 58, 86, 114, 142],
      [6, 34, 62, 90, 118, 146],
      [6, 30, 54, 78, 102, 126, 150],
      [6, 24, 50, 76, 102, 128, 154],
      [6, 28, 54, 80, 106, 132, 158],
      [6, 32, 58, 84, 110, 136, 162],
      [6, 26, 54, 82, 110, 138, 166],
      [6, 30, 58, 86, 114, 142, 170]
    ], Q = { w: function(J) {
      for (var ee = J << 10; 0 <= X(ee) - X(1335); )
        ee ^= 1335 << X(ee) - X(1335);
      return (J << 10 | ee) ^ 21522;
    }, A: function(J) {
      for (var ee = J << 12; 0 <= X(ee) - X(7973); )
        ee ^= 7973 << X(ee) - X(7973);
      return J << 12 | ee;
    }, G: function(J) {
      return Y[J - 1];
    }, F: function(J) {
      switch (J) {
        case 0:
          return function(ee, ae) {
            return (ee + ae) % 2 == 0;
          };
        case 1:
          return function(ee) {
            return ee % 2 == 0;
          };
        case 2:
          return function(ee, ae) {
            return ae % 3 == 0;
          };
        case 3:
          return function(ee, ae) {
            return (ee + ae) % 3 == 0;
          };
        case 4:
          return function(ee, ae) {
            return (Math.floor(ee / 2) + Math.floor(ae / 3)) % 2 == 0;
          };
        case 5:
          return function(ee, ae) {
            return ee * ae % 2 + ee * ae % 3 == 0;
          };
        case 6:
          return function(ee, ae) {
            return (ee * ae % 2 + ee * ae % 3) % 2 == 0;
          };
        case 7:
          return function(ee, ae) {
            return (ee * ae % 3 + (ee + ae) % 2) % 2 == 0;
          };
        default:
          throw Error("bad maskPattern:" + J);
      }
    }, C: function(J) {
      for (var ee = F([1], 0), ae = 0; ae < J; ae += 1)
        ee = ee.multiply(F([1, B.i(ae)], 0));
      return ee;
    }, f: function(J, ee) {
      if (J != 4 || 1 > ee || 40 < ee)
        throw Error("mode: " + J + "; type: " + ee);
      return 10 > ee ? 8 : 16;
    }, D: function(J) {
      for (var ee = J.h(), ae = 0, re = 0; re < ee; re += 1)
        for (var ie = 0; ie < ee; ie += 1) {
          for (var ue = 0, q = J.a(re, ie), ne = -1; 1 >= ne; ne += 1)
            if (!(0 > re + ne || ee <= re + ne))
              for (var ce = -1; 1 >= ce; ce += 1)
                0 > ie + ce || ee <= ie + ce || (ne != 0 || ce != 0) && q == J.a(re + ne, ie + ce) && (ue += 1);
          5 < ue && (ae += 3 + ue - 5);
        }
      for (re = 0; re < ee - 1; re += 1)
        for (ie = 0; ie < ee - 1; ie += 1)
          ue = 0, J.a(re, ie) && (ue += 1), J.a(re + 1, ie) && (ue += 1), J.a(re, ie + 1) && (ue += 1), J.a(re + 1, ie + 1) && (ue += 1), (ue == 0 || ue == 4) && (ae += 3);
      for (re = 0; re < ee; re += 1)
        for (ie = 0; ie < ee - 6; ie += 1)
          J.a(re, ie) && !J.a(re, ie + 1) && J.a(re, ie + 2) && J.a(re, ie + 3) && J.a(re, ie + 4) && !J.a(re, ie + 5) && J.a(re, ie + 6) && (ae += 40);
      for (ie = 0; ie < ee; ie += 1)
        for (re = 0; re < ee - 6; re += 1)
          J.a(re, ie) && !J.a(re + 1, ie) && J.a(re + 2, ie) && J.a(re + 3, ie) && J.a(re + 4, ie) && !J.a(re + 5, ie) && J.a(re + 6, ie) && (ae += 40);
      for (ie = ue = 0; ie < ee; ie += 1)
        for (re = 0; re < ee; re += 1)
          J.a(re, ie) && (ue += 1);
      return ae += Math.abs(100 * ue / ee / ee - 50) / 5 * 10;
    } };
    return Q;
  }(), B = function() {
    for (var X = Array(256), Y = Array(256), Q = 0; 8 > Q; Q += 1)
      X[Q] = 1 << Q;
    for (Q = 8; 256 > Q; Q += 1)
      X[Q] = X[Q - 4] ^ X[Q - 5] ^ X[Q - 6] ^ X[Q - 8];
    for (Q = 0; 255 > Q; Q += 1)
      Y[X[Q]] = Q;
    return { g: function(J) {
      if (1 > J)
        throw Error("glog(" + J + ")");
      return Y[J];
    }, i: function(J) {
      for (; 0 > J; )
        J += 255;
      for (; 256 <= J; )
        J -= 255;
      return X[J];
    } };
  }(), K = /* @__PURE__ */ function() {
    function X(J, ee) {
      switch (ee) {
        case U.L:
          return Y[4 * (J - 1)];
        case U.M:
          return Y[4 * (J - 1) + 1];
        case U.Q:
          return Y[4 * (J - 1) + 2];
        case U.H:
          return Y[4 * (J - 1) + 3];
      }
    }
    var Y = [
      [1, 26, 19],
      [1, 26, 16],
      [1, 26, 13],
      [1, 26, 9],
      [1, 44, 34],
      [1, 44, 28],
      [1, 44, 22],
      [1, 44, 16],
      [1, 70, 55],
      [1, 70, 44],
      [2, 35, 17],
      [2, 35, 13],
      [1, 100, 80],
      [2, 50, 32],
      [2, 50, 24],
      [4, 25, 9],
      [1, 134, 108],
      [2, 67, 43],
      [2, 33, 15, 2, 34, 16],
      [2, 33, 11, 2, 34, 12],
      [2, 86, 68],
      [4, 43, 27],
      [4, 43, 19],
      [4, 43, 15],
      [2, 98, 78],
      [4, 49, 31],
      [2, 32, 14, 4, 33, 15],
      [4, 39, 13, 1, 40, 14],
      [2, 121, 97],
      [2, 60, 38, 2, 61, 39],
      [4, 40, 18, 2, 41, 19],
      [4, 40, 14, 2, 41, 15],
      [2, 146, 116],
      [
        3,
        58,
        36,
        2,
        59,
        37
      ],
      [4, 36, 16, 4, 37, 17],
      [4, 36, 12, 4, 37, 13],
      [2, 86, 68, 2, 87, 69],
      [4, 69, 43, 1, 70, 44],
      [6, 43, 19, 2, 44, 20],
      [6, 43, 15, 2, 44, 16],
      [4, 101, 81],
      [1, 80, 50, 4, 81, 51],
      [4, 50, 22, 4, 51, 23],
      [3, 36, 12, 8, 37, 13],
      [2, 116, 92, 2, 117, 93],
      [6, 58, 36, 2, 59, 37],
      [4, 46, 20, 6, 47, 21],
      [7, 42, 14, 4, 43, 15],
      [4, 133, 107],
      [8, 59, 37, 1, 60, 38],
      [8, 44, 20, 4, 45, 21],
      [12, 33, 11, 4, 34, 12],
      [3, 145, 115, 1, 146, 116],
      [4, 64, 40, 5, 65, 41],
      [11, 36, 16, 5, 37, 17],
      [11, 36, 12, 5, 37, 13],
      [5, 109, 87, 1, 110, 88],
      [5, 65, 41, 5, 66, 42],
      [5, 54, 24, 7, 55, 25],
      [11, 36, 12, 7, 37, 13],
      [5, 122, 98, 1, 123, 99],
      [
        7,
        73,
        45,
        3,
        74,
        46
      ],
      [15, 43, 19, 2, 44, 20],
      [3, 45, 15, 13, 46, 16],
      [1, 135, 107, 5, 136, 108],
      [10, 74, 46, 1, 75, 47],
      [1, 50, 22, 15, 51, 23],
      [2, 42, 14, 17, 43, 15],
      [5, 150, 120, 1, 151, 121],
      [9, 69, 43, 4, 70, 44],
      [17, 50, 22, 1, 51, 23],
      [2, 42, 14, 19, 43, 15],
      [3, 141, 113, 4, 142, 114],
      [3, 70, 44, 11, 71, 45],
      [17, 47, 21, 4, 48, 22],
      [9, 39, 13, 16, 40, 14],
      [3, 135, 107, 5, 136, 108],
      [3, 67, 41, 13, 68, 42],
      [15, 54, 24, 5, 55, 25],
      [15, 43, 15, 10, 44, 16],
      [4, 144, 116, 4, 145, 117],
      [17, 68, 42],
      [17, 50, 22, 6, 51, 23],
      [19, 46, 16, 6, 47, 17],
      [2, 139, 111, 7, 140, 112],
      [17, 74, 46],
      [7, 54, 24, 16, 55, 25],
      [34, 37, 13],
      [
        4,
        151,
        121,
        5,
        152,
        122
      ],
      [4, 75, 47, 14, 76, 48],
      [11, 54, 24, 14, 55, 25],
      [16, 45, 15, 14, 46, 16],
      [6, 147, 117, 4, 148, 118],
      [6, 73, 45, 14, 74, 46],
      [11, 54, 24, 16, 55, 25],
      [30, 46, 16, 2, 47, 17],
      [8, 132, 106, 4, 133, 107],
      [8, 75, 47, 13, 76, 48],
      [7, 54, 24, 22, 55, 25],
      [22, 45, 15, 13, 46, 16],
      [10, 142, 114, 2, 143, 115],
      [19, 74, 46, 4, 75, 47],
      [28, 50, 22, 6, 51, 23],
      [33, 46, 16, 4, 47, 17],
      [8, 152, 122, 4, 153, 123],
      [22, 73, 45, 3, 74, 46],
      [8, 53, 23, 26, 54, 24],
      [12, 45, 15, 28, 46, 16],
      [3, 147, 117, 10, 148, 118],
      [3, 73, 45, 23, 74, 46],
      [4, 54, 24, 31, 55, 25],
      [11, 45, 15, 31, 46, 16],
      [7, 146, 116, 7, 147, 117],
      [21, 73, 45, 7, 74, 46],
      [1, 53, 23, 37, 54, 24],
      [19, 45, 15, 26, 46, 16],
      [5, 145, 115, 10, 146, 116],
      [19, 75, 47, 10, 76, 48],
      [15, 54, 24, 25, 55, 25],
      [23, 45, 15, 25, 46, 16],
      [13, 145, 115, 3, 146, 116],
      [2, 74, 46, 29, 75, 47],
      [42, 54, 24, 1, 55, 25],
      [23, 45, 15, 28, 46, 16],
      [17, 145, 115],
      [10, 74, 46, 23, 75, 47],
      [10, 54, 24, 35, 55, 25],
      [19, 45, 15, 35, 46, 16],
      [17, 145, 115, 1, 146, 116],
      [14, 74, 46, 21, 75, 47],
      [29, 54, 24, 19, 55, 25],
      [11, 45, 15, 46, 46, 16],
      [13, 145, 115, 6, 146, 116],
      [14, 74, 46, 23, 75, 47],
      [44, 54, 24, 7, 55, 25],
      [59, 46, 16, 1, 47, 17],
      [12, 151, 121, 7, 152, 122],
      [12, 75, 47, 26, 76, 48],
      [39, 54, 24, 14, 55, 25],
      [22, 45, 15, 41, 46, 16],
      [6, 151, 121, 14, 152, 122],
      [6, 75, 47, 34, 76, 48],
      [46, 54, 24, 10, 55, 25],
      [2, 45, 15, 64, 46, 16],
      [17, 152, 122, 4, 153, 123],
      [29, 74, 46, 14, 75, 47],
      [49, 54, 24, 10, 55, 25],
      [24, 45, 15, 46, 46, 16],
      [4, 152, 122, 18, 153, 123],
      [13, 74, 46, 32, 75, 47],
      [48, 54, 24, 14, 55, 25],
      [42, 45, 15, 32, 46, 16],
      [20, 147, 117, 4, 148, 118],
      [40, 75, 47, 7, 76, 48],
      [43, 54, 24, 22, 55, 25],
      [10, 45, 15, 67, 46, 16],
      [19, 148, 118, 6, 149, 119],
      [18, 75, 47, 31, 76, 48],
      [34, 54, 24, 34, 55, 25],
      [20, 45, 15, 61, 46, 16]
    ], Q = { I: function(J, ee) {
      var ae = X(J, ee);
      if (typeof ae > "u")
        throw Error("bad rs block @ typeNumber:" + J + "/errorCorrectLevel:" + ee);
      J = ae.length / 3, ee = [];
      for (var re = 0; re < J; re += 1)
        for (var ie = ae[3 * re], ue = ae[3 * re + 1], q = ae[3 * re + 2], ne = 0; ne < ie; ne += 1) {
          var ce = q, he = {};
          he.o = ue, he.j = ce, ee.push(he);
        }
      return ee;
    } };
    return Q;
  }();
  return O;
}());
const QrCreator$1 = QrCreator;
var SlQrCode = class extends ShoelaceElement {
  constructor() {
    super(...arguments), this.value = "", this.label = "", this.size = 128, this.fill = "black", this.background = "white", this.radius = 0, this.errorCorrection = "H";
  }
  firstUpdated() {
    this.generate();
  }
  generate() {
    this.hasUpdated && QrCreator$1.render(
      {
        text: this.value,
        radius: this.radius,
        ecLevel: this.errorCorrection,
        fill: this.fill,
        background: this.background,
        // We draw the canvas larger and scale its container down to avoid blurring on high-density displays
        size: this.size * 2
      },
      this.canvas
    );
  }
  render() {
    var z;
    return x`
      <canvas
        part="base"
        class="qr-code"
        role="img"
        aria-label=${((z = this.label) == null ? void 0 : z.length) > 0 ? this.label : this.value}
        style=${o$3({
      width: `${this.size}px`,
      height: `${this.size}px`
    })}
      ></canvas>
    `;
  }
};
SlQrCode.styles = [component_styles_default, qr_code_styles_default];
__decorateClass([
  e$b("canvas")
], SlQrCode.prototype, "canvas", 2);
__decorateClass([
  n$6()
], SlQrCode.prototype, "value", 2);
__decorateClass([
  n$6()
], SlQrCode.prototype, "label", 2);
__decorateClass([
  n$6({ type: Number })
], SlQrCode.prototype, "size", 2);
__decorateClass([
  n$6()
], SlQrCode.prototype, "fill", 2);
__decorateClass([
  n$6()
], SlQrCode.prototype, "background", 2);
__decorateClass([
  n$6({ type: Number })
], SlQrCode.prototype, "radius", 2);
__decorateClass([
  n$6({ attribute: "error-correction" })
], SlQrCode.prototype, "errorCorrection", 2);
__decorateClass([
  watch(["background", "errorCorrection", "fill", "radius", "size", "value"])
], SlQrCode.prototype, "generate", 1);
SlQrCode.define("sl-qr-code");
var radio_styles_default = i$7`
  :host {
    display: block;
  }

  :host(:focus-visible) {
    outline: 0px;
  }

  .radio {
    display: inline-flex;
    align-items: top;
    font-family: var(--sl-input-font-family);
    font-size: var(--sl-input-font-size-medium);
    font-weight: var(--sl-input-font-weight);
    color: var(--sl-input-label-color);
    vertical-align: middle;
    cursor: pointer;
  }

  .radio--small {
    --toggle-size: var(--sl-toggle-size-small);
    font-size: var(--sl-input-font-size-small);
  }

  .radio--medium {
    --toggle-size: var(--sl-toggle-size-medium);
    font-size: var(--sl-input-font-size-medium);
  }

  .radio--large {
    --toggle-size: var(--sl-toggle-size-large);
    font-size: var(--sl-input-font-size-large);
  }

  .radio__checked-icon {
    display: inline-flex;
    width: var(--toggle-size);
    height: var(--toggle-size);
  }

  .radio__control {
    flex: 0 0 auto;
    position: relative;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    width: var(--toggle-size);
    height: var(--toggle-size);
    border: solid var(--sl-input-border-width) var(--sl-input-border-color);
    border-radius: 50%;
    background-color: var(--sl-input-background-color);
    color: transparent;
    transition:
      var(--sl-transition-fast) border-color,
      var(--sl-transition-fast) background-color,
      var(--sl-transition-fast) color,
      var(--sl-transition-fast) box-shadow;
  }

  .radio__input {
    position: absolute;
    opacity: 0;
    padding: 0;
    margin: 0;
    pointer-events: none;
  }

  /* Hover */
  .radio:not(.radio--checked):not(.radio--disabled) .radio__control:hover {
    border-color: var(--sl-input-border-color-hover);
    background-color: var(--sl-input-background-color-hover);
  }

  /* Checked */
  .radio--checked .radio__control {
    color: var(--sl-color-neutral-0);
    border-color: var(--sl-color-primary-600);
    background-color: var(--sl-color-primary-600);
  }

  /* Checked + hover */
  .radio.radio--checked:not(.radio--disabled) .radio__control:hover {
    border-color: var(--sl-color-primary-500);
    background-color: var(--sl-color-primary-500);
  }

  /* Checked + focus */
  :host(:focus-visible) .radio__control {
    outline: var(--sl-focus-ring);
    outline-offset: var(--sl-focus-ring-offset);
  }

  /* Disabled */
  .radio--disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }

  /* When the control isn't checked, hide the circle for Windows High Contrast mode a11y */
  .radio:not(.radio--checked) svg circle {
    opacity: 0;
  }

  .radio__label {
    display: inline-block;
    color: var(--sl-input-label-color);
    line-height: var(--toggle-size);
    margin-inline-start: 0.5em;
    user-select: none;
    -webkit-user-select: none;
  }
`, SlRadio = class extends ShoelaceElement {
  constructor() {
    super(), this.checked = !1, this.hasFocus = !1, this.size = "medium", this.disabled = !1, this.handleBlur = () => {
      this.hasFocus = !1, this.emit("sl-blur");
    }, this.handleClick = () => {
      this.disabled || (this.checked = !0);
    }, this.handleFocus = () => {
      this.hasFocus = !0, this.emit("sl-focus");
    }, this.addEventListener("blur", this.handleBlur), this.addEventListener("click", this.handleClick), this.addEventListener("focus", this.handleFocus);
  }
  connectedCallback() {
    super.connectedCallback(), this.setInitialAttributes();
  }
  setInitialAttributes() {
    this.setAttribute("role", "radio"), this.setAttribute("tabindex", "-1"), this.setAttribute("aria-disabled", this.disabled ? "true" : "false");
  }
  handleCheckedChange() {
    this.setAttribute("aria-checked", this.checked ? "true" : "false"), this.setAttribute("tabindex", this.checked ? "0" : "-1");
  }
  handleDisabledChange() {
    this.setAttribute("aria-disabled", this.disabled ? "true" : "false");
  }
  render() {
    return x`
      <span
        part="base"
        class=${e$2({
      radio: !0,
      "radio--checked": this.checked,
      "radio--disabled": this.disabled,
      "radio--focused": this.hasFocus,
      "radio--small": this.size === "small",
      "radio--medium": this.size === "medium",
      "radio--large": this.size === "large"
    })}
      >
        <span part="${`control${this.checked ? " control--checked" : ""}`}" class="radio__control">
          ${this.checked ? x` <sl-icon part="checked-icon" class="radio__checked-icon" library="system" name="radio"></sl-icon> ` : ""}
        </span>

        <slot part="label" class="radio__label"></slot>
      </span>
    `;
  }
};
SlRadio.styles = [component_styles_default, radio_styles_default];
SlRadio.dependencies = { "sl-icon": SlIcon };
__decorateClass([
  r$4()
], SlRadio.prototype, "checked", 2);
__decorateClass([
  r$4()
], SlRadio.prototype, "hasFocus", 2);
__decorateClass([
  n$6()
], SlRadio.prototype, "value", 2);
__decorateClass([
  n$6({ reflect: !0 })
], SlRadio.prototype, "size", 2);
__decorateClass([
  n$6({ type: Boolean, reflect: !0 })
], SlRadio.prototype, "disabled", 2);
__decorateClass([
  watch("checked")
], SlRadio.prototype, "handleCheckedChange", 1);
__decorateClass([
  watch("disabled", { waitUntilFirstUpdate: !0 })
], SlRadio.prototype, "handleDisabledChange", 1);
SlRadio.define("sl-radio");
var option_styles_default = i$7`
  :host {
    display: block;
    user-select: none;
    -webkit-user-select: none;
  }

  :host(:focus) {
    outline: none;
  }

  .option {
    position: relative;
    display: flex;
    align-items: center;
    font-family: var(--sl-font-sans);
    font-size: var(--sl-font-size-medium);
    font-weight: var(--sl-font-weight-normal);
    line-height: var(--sl-line-height-normal);
    letter-spacing: var(--sl-letter-spacing-normal);
    color: var(--sl-color-neutral-700);
    padding: var(--sl-spacing-x-small) var(--sl-spacing-medium) var(--sl-spacing-x-small) var(--sl-spacing-x-small);
    transition: var(--sl-transition-fast) fill;
    cursor: pointer;
  }

  .option--hover:not(.option--current):not(.option--disabled) {
    background-color: var(--sl-color-neutral-100);
    color: var(--sl-color-neutral-1000);
  }

  .option--current,
  .option--current.option--disabled {
    background-color: var(--sl-color-primary-600);
    color: var(--sl-color-neutral-0);
    opacity: 1;
  }

  .option--disabled {
    outline: none;
    opacity: 0.5;
    cursor: not-allowed;
  }

  .option__label {
    flex: 1 1 auto;
    display: inline-block;
    line-height: var(--sl-line-height-dense);
  }

  .option .option__check {
    flex: 0 0 auto;
    display: flex;
    align-items: center;
    justify-content: center;
    visibility: hidden;
    padding-inline-end: var(--sl-spacing-2x-small);
  }

  .option--selected .option__check {
    visibility: visible;
  }

  .option__prefix,
  .option__suffix {
    flex: 0 0 auto;
    display: flex;
    align-items: center;
  }

  .option__prefix::slotted(*) {
    margin-inline-end: var(--sl-spacing-x-small);
  }

  .option__suffix::slotted(*) {
    margin-inline-start: var(--sl-spacing-x-small);
  }

  @media (forced-colors: active) {
    :host(:hover:not([aria-disabled='true'])) .option {
      outline: dashed 1px SelectedItem;
      outline-offset: -1px;
    }
  }
`, SlOption = class extends ShoelaceElement {
  constructor() {
    super(...arguments), this.localize = new LocalizeController(this), this.current = !1, this.selected = !1, this.hasHover = !1, this.value = "", this.disabled = !1;
  }
  connectedCallback() {
    super.connectedCallback(), this.setAttribute("role", "option"), this.setAttribute("aria-selected", "false");
  }
  handleDefaultSlotChange() {
    const z = this.getTextLabel();
    if (typeof this.cachedTextLabel > "u") {
      this.cachedTextLabel = z;
      return;
    }
    z !== this.cachedTextLabel && (this.cachedTextLabel = z, this.emit("slotchange", { bubbles: !0, composed: !1, cancelable: !1 }));
  }
  handleMouseEnter() {
    this.hasHover = !0;
  }
  handleMouseLeave() {
    this.hasHover = !1;
  }
  handleDisabledChange() {
    this.setAttribute("aria-disabled", this.disabled ? "true" : "false");
  }
  handleSelectedChange() {
    this.setAttribute("aria-selected", this.selected ? "true" : "false");
  }
  handleValueChange() {
    typeof this.value != "string" && (this.value = String(this.value)), this.value.includes(" ") && (console.error("Option values cannot include a space. All spaces have been replaced with underscores.", this), this.value = this.value.replace(/ /g, "_"));
  }
  /** Returns a plain text label based on the option's content. */
  getTextLabel() {
    const z = this.childNodes;
    let D = "";
    return [...z].forEach((O) => {
      O.nodeType === Node.ELEMENT_NODE && (O.hasAttribute("slot") || (D += O.textContent)), O.nodeType === Node.TEXT_NODE && (D += O.textContent);
    }), D.trim();
  }
  render() {
    return x`
      <div
        part="base"
        class=${e$2({
      option: !0,
      "option--current": this.current,
      "option--disabled": this.disabled,
      "option--selected": this.selected,
      "option--hover": this.hasHover
    })}
        @mouseenter=${this.handleMouseEnter}
        @mouseleave=${this.handleMouseLeave}
      >
        <sl-icon part="checked-icon" class="option__check" name="check" library="system" aria-hidden="true"></sl-icon>
        <slot part="prefix" name="prefix" class="option__prefix"></slot>
        <slot part="label" class="option__label" @slotchange=${this.handleDefaultSlotChange}></slot>
        <slot part="suffix" name="suffix" class="option__suffix"></slot>
      </div>
    `;
  }
};
SlOption.styles = [component_styles_default, option_styles_default];
SlOption.dependencies = { "sl-icon": SlIcon };
__decorateClass([
  e$b(".option__label")
], SlOption.prototype, "defaultSlot", 2);
__decorateClass([
  r$4()
], SlOption.prototype, "current", 2);
__decorateClass([
  r$4()
], SlOption.prototype, "selected", 2);
__decorateClass([
  r$4()
], SlOption.prototype, "hasHover", 2);
__decorateClass([
  n$6({ reflect: !0 })
], SlOption.prototype, "value", 2);
__decorateClass([
  n$6({ type: Boolean, reflect: !0 })
], SlOption.prototype, "disabled", 2);
__decorateClass([
  watch("disabled")
], SlOption.prototype, "handleDisabledChange", 1);
__decorateClass([
  watch("selected")
], SlOption.prototype, "handleSelectedChange", 1);
__decorateClass([
  watch("value")
], SlOption.prototype, "handleValueChange", 1);
SlOption.define("sl-option");
var mutation_observer_styles_default = i$7`
  :host {
    display: contents;
  }
`, SlMutationObserver = class extends ShoelaceElement {
  constructor() {
    super(...arguments), this.attrOldValue = !1, this.charData = !1, this.charDataOldValue = !1, this.childList = !1, this.disabled = !1, this.handleMutation = (z) => {
      this.emit("sl-mutation", {
        detail: { mutationList: z }
      });
    };
  }
  connectedCallback() {
    super.connectedCallback(), this.mutationObserver = new MutationObserver(this.handleMutation), this.disabled || this.startObserver();
  }
  disconnectedCallback() {
    super.disconnectedCallback(), this.stopObserver();
  }
  startObserver() {
    const z = typeof this.attr == "string" && this.attr.length > 0, D = z && this.attr !== "*" ? this.attr.split(" ") : void 0;
    try {
      this.mutationObserver.observe(this, {
        subtree: !0,
        childList: this.childList,
        attributes: z,
        attributeFilter: D,
        attributeOldValue: this.attrOldValue,
        characterData: this.charData,
        characterDataOldValue: this.charDataOldValue
      });
    } catch {
    }
  }
  stopObserver() {
    this.mutationObserver.disconnect();
  }
  handleDisabledChange() {
    this.disabled ? this.stopObserver() : this.startObserver();
  }
  handleChange() {
    this.stopObserver(), this.startObserver();
  }
  render() {
    return x` <slot></slot> `;
  }
};
SlMutationObserver.styles = [component_styles_default, mutation_observer_styles_default];
__decorateClass([
  n$6({ reflect: !0 })
], SlMutationObserver.prototype, "attr", 2);
__decorateClass([
  n$6({ attribute: "attr-old-value", type: Boolean, reflect: !0 })
], SlMutationObserver.prototype, "attrOldValue", 2);
__decorateClass([
  n$6({ attribute: "char-data", type: Boolean, reflect: !0 })
], SlMutationObserver.prototype, "charData", 2);
__decorateClass([
  n$6({ attribute: "char-data-old-value", type: Boolean, reflect: !0 })
], SlMutationObserver.prototype, "charDataOldValue", 2);
__decorateClass([
  n$6({ attribute: "child-list", type: Boolean, reflect: !0 })
], SlMutationObserver.prototype, "childList", 2);
__decorateClass([
  n$6({ type: Boolean, reflect: !0 })
], SlMutationObserver.prototype, "disabled", 2);
__decorateClass([
  watch("disabled")
], SlMutationObserver.prototype, "handleDisabledChange", 1);
__decorateClass([
  watch("attr", { waitUntilFirstUpdate: !0 }),
  watch("attr-old-value", { waitUntilFirstUpdate: !0 }),
  watch("char-data", { waitUntilFirstUpdate: !0 }),
  watch("char-data-old-value", { waitUntilFirstUpdate: !0 }),
  watch("childList", { waitUntilFirstUpdate: !0 })
], SlMutationObserver.prototype, "handleChange", 1);
SlMutationObserver.define("sl-mutation-observer");
var progress_bar_styles_default = i$7`
  :host {
    --height: 1rem;
    --track-color: var(--sl-color-neutral-200);
    --indicator-color: var(--sl-color-primary-600);
    --label-color: var(--sl-color-neutral-0);

    display: block;
  }

  .progress-bar {
    position: relative;
    background-color: var(--track-color);
    height: var(--height);
    border-radius: var(--sl-border-radius-pill);
    box-shadow: inset var(--sl-shadow-small);
    overflow: hidden;
  }

  .progress-bar__indicator {
    height: 100%;
    font-family: var(--sl-font-sans);
    font-size: 12px;
    font-weight: var(--sl-font-weight-normal);
    background-color: var(--indicator-color);
    color: var(--label-color);
    text-align: center;
    line-height: var(--height);
    white-space: nowrap;
    overflow: hidden;
    transition:
      400ms width,
      400ms background-color;
    user-select: none;
    -webkit-user-select: none;
  }

  /* Indeterminate */
  .progress-bar--indeterminate .progress-bar__indicator {
    position: absolute;
    animation: indeterminate 2.5s infinite cubic-bezier(0.37, 0, 0.63, 1);
  }

  .progress-bar--indeterminate.progress-bar--rtl .progress-bar__indicator {
    animation-name: indeterminate-rtl;
  }

  @media (forced-colors: active) {
    .progress-bar {
      outline: solid 1px SelectedItem;
      background-color: var(--sl-color-neutral-0);
    }

    .progress-bar__indicator {
      outline: solid 1px SelectedItem;
      background-color: SelectedItem;
    }
  }

  @keyframes indeterminate {
    0% {
      left: -50%;
      width: 50%;
    }
    75%,
    100% {
      left: 100%;
      width: 50%;
    }
  }

  @keyframes indeterminate-rtl {
    0% {
      right: -50%;
      width: 50%;
    }
    75%,
    100% {
      right: 100%;
      width: 50%;
    }
  }
`, SlProgressBar = class extends ShoelaceElement {
  constructor() {
    super(...arguments), this.localize = new LocalizeController(this), this.value = 0, this.indeterminate = !1, this.label = "";
  }
  render() {
    return x`
      <div
        part="base"
        class=${e$2({
      "progress-bar": !0,
      "progress-bar--indeterminate": this.indeterminate,
      "progress-bar--rtl": this.localize.dir() === "rtl"
    })}
        role="progressbar"
        title=${o$6(this.title)}
        aria-label=${this.label.length > 0 ? this.label : this.localize.term("progress")}
        aria-valuemin="0"
        aria-valuemax="100"
        aria-valuenow=${this.indeterminate ? 0 : this.value}
      >
        <div part="indicator" class="progress-bar__indicator" style=${o$3({ width: `${this.value}%` })}>
          ${this.indeterminate ? "" : x` <slot part="label" class="progress-bar__label"></slot> `}
        </div>
      </div>
    `;
  }
};
SlProgressBar.styles = [component_styles_default, progress_bar_styles_default];
__decorateClass([
  n$6({ type: Number, reflect: !0 })
], SlProgressBar.prototype, "value", 2);
__decorateClass([
  n$6({ type: Boolean, reflect: !0 })
], SlProgressBar.prototype, "indeterminate", 2);
__decorateClass([
  n$6()
], SlProgressBar.prototype, "label", 2);
SlProgressBar.define("sl-progress-bar");
var menu_item_styles_default = i$7`
  :host {
    --submenu-offset: -2px;

    display: block;
  }

  :host([inert]) {
    display: none;
  }

  .menu-item {
    position: relative;
    display: flex;
    align-items: stretch;
    font-family: var(--sl-font-sans);
    font-size: var(--sl-font-size-medium);
    font-weight: var(--sl-font-weight-normal);
    line-height: var(--sl-line-height-normal);
    letter-spacing: var(--sl-letter-spacing-normal);
    color: var(--sl-color-neutral-700);
    padding: var(--sl-spacing-2x-small) var(--sl-spacing-2x-small);
    transition: var(--sl-transition-fast) fill;
    user-select: none;
    -webkit-user-select: none;
    white-space: nowrap;
    cursor: pointer;
  }

  .menu-item.menu-item--disabled {
    outline: none;
    opacity: 0.5;
    cursor: not-allowed;
  }

  .menu-item.menu-item--loading {
    outline: none;
    cursor: wait;
  }

  .menu-item.menu-item--loading *:not(sl-spinner) {
    opacity: 0.5;
  }

  .menu-item--loading sl-spinner {
    --indicator-color: currentColor;
    --track-width: 1px;
    position: absolute;
    font-size: 0.75em;
    top: calc(50% - 0.5em);
    left: 0.65rem;
    opacity: 1;
  }

  .menu-item .menu-item__label {
    flex: 1 1 auto;
    display: inline-block;
    text-overflow: ellipsis;
    overflow: hidden;
  }

  .menu-item .menu-item__prefix {
    flex: 0 0 auto;
    display: flex;
    align-items: center;
  }

  .menu-item .menu-item__prefix::slotted(*) {
    margin-inline-end: var(--sl-spacing-x-small);
  }

  .menu-item .menu-item__suffix {
    flex: 0 0 auto;
    display: flex;
    align-items: center;
  }

  .menu-item .menu-item__suffix::slotted(*) {
    margin-inline-start: var(--sl-spacing-x-small);
  }

  /* Safe triangle */
  .menu-item--submenu-expanded::after {
    content: '';
    position: fixed;
    z-index: calc(var(--sl-z-index-dropdown) - 1);
    top: 0;
    right: 0;
    bottom: 0;
    left: 0;
    clip-path: polygon(
      var(--safe-triangle-cursor-x, 0) var(--safe-triangle-cursor-y, 0),
      var(--safe-triangle-submenu-start-x, 0) var(--safe-triangle-submenu-start-y, 0),
      var(--safe-triangle-submenu-end-x, 0) var(--safe-triangle-submenu-end-y, 0)
    );
  }

  :host(:focus-visible) {
    outline: none;
  }

  :host(:hover:not([aria-disabled='true'], :focus-visible)) .menu-item,
  .menu-item--submenu-expanded {
    background-color: var(--sl-color-neutral-100);
    color: var(--sl-color-neutral-1000);
  }

  :host(:focus-visible) .menu-item {
    outline: none;
    background-color: var(--sl-color-primary-600);
    color: var(--sl-color-neutral-0);
    opacity: 1;
  }

  .menu-item .menu-item__check,
  .menu-item .menu-item__chevron {
    flex: 0 0 auto;
    display: flex;
    align-items: center;
    justify-content: center;
    width: 1.5em;
    visibility: hidden;
  }

  .menu-item--checked .menu-item__check,
  .menu-item--has-submenu .menu-item__chevron {
    visibility: visible;
  }

  /* Add elevation and z-index to submenus */
  sl-popup::part(popup) {
    box-shadow: var(--sl-shadow-large);
    z-index: var(--sl-z-index-dropdown);
    margin-left: var(--submenu-offset);
  }

  .menu-item--rtl sl-popup::part(popup) {
    margin-left: calc(-1 * var(--submenu-offset));
  }

  @media (forced-colors: active) {
    :host(:hover:not([aria-disabled='true'])) .menu-item,
    :host(:focus-visible) .menu-item {
      outline: dashed 1px SelectedItem;
      outline-offset: -1px;
    }
  }

  ::slotted(sl-menu) {
    max-width: var(--auto-size-available-width) !important;
    max-height: var(--auto-size-available-height) !important;
  }
`;
/**
 * @license
 * Copyright 2020 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const e = () => new h();
class h {
}
const o$2 = /* @__PURE__ */ new WeakMap(), n = e$7(class extends f {
  render(z) {
    return T;
  }
  update(z, [D]) {
    var F;
    const O = D !== this.Y;
    return O && this.Y !== void 0 && this.rt(void 0), (O || this.lt !== this.ct) && (this.Y = D, this.ht = (F = z.options) == null ? void 0 : F.host, this.rt(this.ct = z.element)), T;
  }
  rt(z) {
    if (typeof this.Y == "function") {
      const D = this.ht ?? globalThis;
      let O = o$2.get(D);
      O === void 0 && (O = /* @__PURE__ */ new WeakMap(), o$2.set(D, O)), O.get(this.Y) !== void 0 && this.Y.call(this.ht, void 0), O.set(this.Y, z), z !== void 0 && this.Y.call(this.ht, z);
    } else
      this.Y.value = z;
  }
  get lt() {
    var z, D;
    return typeof this.Y == "function" ? (z = o$2.get(this.ht ?? globalThis)) == null ? void 0 : z.get(this.Y) : (D = this.Y) == null ? void 0 : D.value;
  }
  disconnected() {
    this.lt === this.ct && this.rt(void 0);
  }
  reconnected() {
    this.rt(this.ct);
  }
});
var SubmenuController = class {
  constructor(z, D, O) {
    this.popupRef = e(), this.enableSubmenuTimer = -1, this.isConnected = !1, this.isPopupConnected = !1, this.skidding = 0, this.submenuOpenDelay = 100, this.handleMouseMove = (F) => {
      this.host.style.setProperty("--safe-triangle-cursor-x", `${F.clientX}px`), this.host.style.setProperty("--safe-triangle-cursor-y", `${F.clientY}px`);
    }, this.handleMouseOver = () => {
      this.hasSlotController.test("submenu") && this.enableSubmenu();
    }, this.handleKeyDown = (F) => {
      switch (F.key) {
        case "Escape":
        case "Tab":
          this.disableSubmenu();
          break;
        case "ArrowLeft":
          F.target !== this.host && (F.preventDefault(), F.stopPropagation(), this.host.focus(), this.disableSubmenu());
          break;
        case "ArrowRight":
        case "Enter":
        case " ":
          this.handleSubmenuEntry(F);
          break;
      }
    }, this.handleClick = (F) => {
      var U;
      F.target === this.host ? (F.preventDefault(), F.stopPropagation()) : F.target instanceof Element && (F.target.tagName === "sl-menu-item" || (U = F.target.role) != null && U.startsWith("menuitem")) && this.disableSubmenu();
    }, this.handleFocusOut = (F) => {
      F.relatedTarget && F.relatedTarget instanceof Element && this.host.contains(F.relatedTarget) || this.disableSubmenu();
    }, this.handlePopupMouseover = (F) => {
      F.stopPropagation();
    }, this.handlePopupReposition = () => {
      const F = this.host.renderRoot.querySelector("slot[name='submenu']"), U = F == null ? void 0 : F.assignedElements({ flatten: !0 }).filter((Q) => Q.localName === "sl-menu")[0], W = this.localize.dir() === "rtl";
      if (!U)
        return;
      const { left: B, top: K, width: X, height: Y } = U.getBoundingClientRect();
      this.host.style.setProperty("--safe-triangle-submenu-start-x", `${W ? B + X : B}px`), this.host.style.setProperty("--safe-triangle-submenu-start-y", `${K}px`), this.host.style.setProperty("--safe-triangle-submenu-end-x", `${W ? B + X : B}px`), this.host.style.setProperty("--safe-triangle-submenu-end-y", `${K + Y}px`);
    }, (this.host = z).addController(this), this.hasSlotController = D, this.localize = O;
  }
  hostConnected() {
    this.hasSlotController.test("submenu") && !this.host.disabled && this.addListeners();
  }
  hostDisconnected() {
    this.removeListeners();
  }
  hostUpdated() {
    this.hasSlotController.test("submenu") && !this.host.disabled ? (this.addListeners(), this.updateSkidding()) : this.removeListeners();
  }
  addListeners() {
    this.isConnected || (this.host.addEventListener("mousemove", this.handleMouseMove), this.host.addEventListener("mouseover", this.handleMouseOver), this.host.addEventListener("keydown", this.handleKeyDown), this.host.addEventListener("click", this.handleClick), this.host.addEventListener("focusout", this.handleFocusOut), this.isConnected = !0), this.isPopupConnected || this.popupRef.value && (this.popupRef.value.addEventListener("mouseover", this.handlePopupMouseover), this.popupRef.value.addEventListener("sl-reposition", this.handlePopupReposition), this.isPopupConnected = !0);
  }
  removeListeners() {
    this.isConnected && (this.host.removeEventListener("mousemove", this.handleMouseMove), this.host.removeEventListener("mouseover", this.handleMouseOver), this.host.removeEventListener("keydown", this.handleKeyDown), this.host.removeEventListener("click", this.handleClick), this.host.removeEventListener("focusout", this.handleFocusOut), this.isConnected = !1), this.isPopupConnected && this.popupRef.value && (this.popupRef.value.removeEventListener("mouseover", this.handlePopupMouseover), this.popupRef.value.removeEventListener("sl-reposition", this.handlePopupReposition), this.isPopupConnected = !1);
  }
  handleSubmenuEntry(z) {
    const D = this.host.renderRoot.querySelector("slot[name='submenu']");
    if (!D) {
      console.error("Cannot activate a submenu if no corresponding menuitem can be found.", this);
      return;
    }
    let O = null;
    for (const F of D.assignedElements())
      if (O = F.querySelectorAll("sl-menu-item, [role^='menuitem']"), O.length !== 0)
        break;
    if (!(!O || O.length === 0)) {
      O[0].setAttribute("tabindex", "0");
      for (let F = 1; F !== O.length; ++F)
        O[F].setAttribute("tabindex", "-1");
      this.popupRef.value && (z.preventDefault(), z.stopPropagation(), this.popupRef.value.active ? O[0] instanceof HTMLElement && O[0].focus() : (this.enableSubmenu(!1), this.host.updateComplete.then(() => {
        O[0] instanceof HTMLElement && O[0].focus();
      }), this.host.requestUpdate()));
    }
  }
  setSubmenuState(z) {
    this.popupRef.value && this.popupRef.value.active !== z && (this.popupRef.value.active = z, this.host.requestUpdate());
  }
  // Shows the submenu. Supports disabling the opening delay, e.g. for keyboard events that want to set the focus to the
  // newly opened menu.
  enableSubmenu(z = !0) {
    z ? (window.clearTimeout(this.enableSubmenuTimer), this.enableSubmenuTimer = window.setTimeout(() => {
      this.setSubmenuState(!0);
    }, this.submenuOpenDelay)) : this.setSubmenuState(!0);
  }
  disableSubmenu() {
    window.clearTimeout(this.enableSubmenuTimer), this.setSubmenuState(!1);
  }
  // Calculate the space the top of a menu takes-up, for aligning the popup menu-item with the activating element.
  updateSkidding() {
    var z;
    if (!((z = this.host.parentElement) != null && z.computedStyleMap))
      return;
    const D = this.host.parentElement.computedStyleMap(), F = ["padding-top", "border-top-width", "margin-top"].reduce((U, W) => {
      var B;
      const K = (B = D.get(W)) != null ? B : new CSSUnitValue(0, "px"), Y = (K instanceof CSSUnitValue ? K : new CSSUnitValue(0, "px")).to("px");
      return U - Y.value;
    }, 0);
    this.skidding = F;
  }
  isExpanded() {
    return this.popupRef.value ? this.popupRef.value.active : !1;
  }
  renderSubmenu() {
    const z = this.localize.dir() === "ltr";
    return this.isConnected ? x`
      <sl-popup
        ${n(this.popupRef)}
        placement=${z ? "right-start" : "left-start"}
        anchor="anchor"
        flip
        flip-fallback-strategy="best-fit"
        skidding="${this.skidding}"
        strategy="fixed"
        auto-size="vertical"
        auto-size-padding="10"
      >
        <slot name="submenu"></slot>
      </sl-popup>
    ` : x` <slot name="submenu" hidden></slot> `;
  }
}, SlMenuItem = class extends ShoelaceElement {
  constructor() {
    super(...arguments), this.type = "normal", this.checked = !1, this.value = "", this.loading = !1, this.disabled = !1, this.localize = new LocalizeController(this), this.hasSlotController = new HasSlotController(this, "submenu"), this.submenuController = new SubmenuController(this, this.hasSlotController, this.localize), this.handleHostClick = (z) => {
      this.disabled && (z.preventDefault(), z.stopImmediatePropagation());
    }, this.handleMouseOver = (z) => {
      this.focus(), z.stopPropagation();
    };
  }
  connectedCallback() {
    super.connectedCallback(), this.addEventListener("click", this.handleHostClick), this.addEventListener("mouseover", this.handleMouseOver);
  }
  disconnectedCallback() {
    super.disconnectedCallback(), this.removeEventListener("click", this.handleHostClick), this.removeEventListener("mouseover", this.handleMouseOver);
  }
  handleDefaultSlotChange() {
    const z = this.getTextLabel();
    if (typeof this.cachedTextLabel > "u") {
      this.cachedTextLabel = z;
      return;
    }
    z !== this.cachedTextLabel && (this.cachedTextLabel = z, this.emit("slotchange", { bubbles: !0, composed: !1, cancelable: !1 }));
  }
  handleCheckedChange() {
    if (this.checked && this.type !== "checkbox") {
      this.checked = !1, console.error('The checked attribute can only be used on menu items with type="checkbox"', this);
      return;
    }
    this.type === "checkbox" ? this.setAttribute("aria-checked", this.checked ? "true" : "false") : this.removeAttribute("aria-checked");
  }
  handleDisabledChange() {
    this.setAttribute("aria-disabled", this.disabled ? "true" : "false");
  }
  handleTypeChange() {
    this.type === "checkbox" ? (this.setAttribute("role", "menuitemcheckbox"), this.setAttribute("aria-checked", this.checked ? "true" : "false")) : (this.setAttribute("role", "menuitem"), this.removeAttribute("aria-checked"));
  }
  /** Returns a text label based on the contents of the menu item's default slot. */
  getTextLabel() {
    return getTextContent(this.defaultSlot);
  }
  isSubmenu() {
    return this.hasSlotController.test("submenu");
  }
  render() {
    const z = this.localize.dir() === "rtl", D = this.submenuController.isExpanded();
    return x`
      <div
        id="anchor"
        part="base"
        class=${e$2({
      "menu-item": !0,
      "menu-item--rtl": z,
      "menu-item--checked": this.checked,
      "menu-item--disabled": this.disabled,
      "menu-item--loading": this.loading,
      "menu-item--has-submenu": this.isSubmenu(),
      "menu-item--submenu-expanded": D
    })}
        ?aria-haspopup="${this.isSubmenu()}"
        ?aria-expanded="${!!D}"
      >
        <span part="checked-icon" class="menu-item__check">
          <sl-icon name="check" library="system" aria-hidden="true"></sl-icon>
        </span>

        <slot name="prefix" part="prefix" class="menu-item__prefix"></slot>

        <slot part="label" class="menu-item__label" @slotchange=${this.handleDefaultSlotChange}></slot>

        <slot name="suffix" part="suffix" class="menu-item__suffix"></slot>

        <span part="submenu-icon" class="menu-item__chevron">
          <sl-icon name=${z ? "chevron-left" : "chevron-right"} library="system" aria-hidden="true"></sl-icon>
        </span>

        ${this.submenuController.renderSubmenu()}
        ${this.loading ? x` <sl-spinner part="spinner" exportparts="base:spinner__base"></sl-spinner> ` : ""}
      </div>
    `;
  }
};
SlMenuItem.styles = [component_styles_default, menu_item_styles_default];
SlMenuItem.dependencies = {
  "sl-icon": SlIcon,
  "sl-popup": SlPopup,
  "sl-spinner": SlSpinner
};
__decorateClass([
  e$b("slot:not([name])")
], SlMenuItem.prototype, "defaultSlot", 2);
__decorateClass([
  e$b(".menu-item")
], SlMenuItem.prototype, "menuItem", 2);
__decorateClass([
  n$6()
], SlMenuItem.prototype, "type", 2);
__decorateClass([
  n$6({ type: Boolean, reflect: !0 })
], SlMenuItem.prototype, "checked", 2);
__decorateClass([
  n$6()
], SlMenuItem.prototype, "value", 2);
__decorateClass([
  n$6({ type: Boolean, reflect: !0 })
], SlMenuItem.prototype, "loading", 2);
__decorateClass([
  n$6({ type: Boolean, reflect: !0 })
], SlMenuItem.prototype, "disabled", 2);
__decorateClass([
  watch("checked")
], SlMenuItem.prototype, "handleCheckedChange", 1);
__decorateClass([
  watch("disabled")
], SlMenuItem.prototype, "handleDisabledChange", 1);
__decorateClass([
  watch("type")
], SlMenuItem.prototype, "handleTypeChange", 1);
SlMenuItem.define("sl-menu-item");
SlPopup.define("sl-popup");
var menu_styles_default = i$7`
  :host {
    display: block;
    position: relative;
    background: var(--sl-panel-background-color);
    border: solid var(--sl-panel-border-width) var(--sl-panel-border-color);
    border-radius: var(--sl-border-radius-medium);
    padding: var(--sl-spacing-x-small) 0;
    overflow: auto;
    overscroll-behavior: none;
  }

  ::slotted(sl-divider) {
    --spacing: var(--sl-spacing-x-small);
  }
`, SlMenu = class extends ShoelaceElement {
  connectedCallback() {
    super.connectedCallback(), this.setAttribute("role", "menu");
  }
  handleClick(z) {
    const D = ["menuitem", "menuitemcheckbox"], O = z.composedPath().find((U) => {
      var W;
      return D.includes(((W = U == null ? void 0 : U.getAttribute) == null ? void 0 : W.call(U, "role")) || "");
    });
    if (!O)
      return;
    const F = O;
    F.type === "checkbox" && (F.checked = !F.checked), this.emit("sl-select", { detail: { item: F } });
  }
  handleKeyDown(z) {
    if (z.key === "Enter" || z.key === " ") {
      const D = this.getCurrentItem();
      z.preventDefault(), z.stopPropagation(), D == null || D.click();
    } else if (["ArrowDown", "ArrowUp", "Home", "End"].includes(z.key)) {
      const D = this.getAllItems(), O = this.getCurrentItem();
      let F = O ? D.indexOf(O) : 0;
      D.length > 0 && (z.preventDefault(), z.stopPropagation(), z.key === "ArrowDown" ? F++ : z.key === "ArrowUp" ? F-- : z.key === "Home" ? F = 0 : z.key === "End" && (F = D.length - 1), F < 0 && (F = D.length - 1), F > D.length - 1 && (F = 0), this.setCurrentItem(D[F]), D[F].focus());
    }
  }
  handleMouseDown(z) {
    const D = z.target;
    this.isMenuItem(D) && this.setCurrentItem(D);
  }
  handleSlotChange() {
    const z = this.getAllItems();
    z.length > 0 && this.setCurrentItem(z[0]);
  }
  isMenuItem(z) {
    var D;
    return z.tagName.toLowerCase() === "sl-menu-item" || ["menuitem", "menuitemcheckbox", "menuitemradio"].includes((D = z.getAttribute("role")) != null ? D : "");
  }
  /** @internal Gets all slotted menu items, ignoring dividers, headers, and other elements. */
  getAllItems() {
    return [...this.defaultSlot.assignedElements({ flatten: !0 })].filter((z) => !(z.inert || !this.isMenuItem(z)));
  }
  /**
   * @internal Gets the current menu item, which is the menu item that has `tabindex="0"` within the roving tab index.
   * The menu item may or may not have focus, but for keyboard interaction purposes it's considered the "active" item.
   */
  getCurrentItem() {
    return this.getAllItems().find((z) => z.getAttribute("tabindex") === "0");
  }
  /**
   * @internal Sets the current menu item to the specified element. This sets `tabindex="0"` on the target element and
   * `tabindex="-1"` to all other items. This method must be called prior to setting focus on a menu item.
   */
  setCurrentItem(z) {
    this.getAllItems().forEach((O) => {
      O.setAttribute("tabindex", O === z ? "0" : "-1");
    });
  }
  render() {
    return x`
      <slot
        @slotchange=${this.handleSlotChange}
        @click=${this.handleClick}
        @keydown=${this.handleKeyDown}
        @mousedown=${this.handleMouseDown}
      ></slot>
    `;
  }
};
SlMenu.styles = [component_styles_default, menu_styles_default];
__decorateClass([
  e$b("slot")
], SlMenu.prototype, "defaultSlot", 2);
SlMenu.define("sl-menu");
var input_styles_default = i$7`
  :host {
    display: block;
  }

  .input {
    flex: 1 1 auto;
    display: inline-flex;
    align-items: stretch;
    justify-content: start;
    position: relative;
    width: 100%;
    font-family: var(--sl-input-font-family);
    font-weight: var(--sl-input-font-weight);
    letter-spacing: var(--sl-input-letter-spacing);
    vertical-align: middle;
    overflow: hidden;
    cursor: text;
    transition:
      var(--sl-transition-fast) color,
      var(--sl-transition-fast) border,
      var(--sl-transition-fast) box-shadow,
      var(--sl-transition-fast) background-color;
  }

  /* Standard inputs */
  .input--standard {
    background-color: var(--sl-input-background-color);
    border: solid var(--sl-input-border-width) var(--sl-input-border-color);
  }

  .input--standard:hover:not(.input--disabled) {
    background-color: var(--sl-input-background-color-hover);
    border-color: var(--sl-input-border-color-hover);
  }

  .input--standard.input--focused:not(.input--disabled) {
    background-color: var(--sl-input-background-color-focus);
    border-color: var(--sl-input-border-color-focus);
    box-shadow: 0 0 0 var(--sl-focus-ring-width) var(--sl-input-focus-ring-color);
  }

  .input--standard.input--focused:not(.input--disabled) .input__control {
    color: var(--sl-input-color-focus);
  }

  .input--standard.input--disabled {
    background-color: var(--sl-input-background-color-disabled);
    border-color: var(--sl-input-border-color-disabled);
    opacity: 0.5;
    cursor: not-allowed;
  }

  .input--standard.input--disabled .input__control {
    color: var(--sl-input-color-disabled);
  }

  .input--standard.input--disabled .input__control::placeholder {
    color: var(--sl-input-placeholder-color-disabled);
  }

  /* Filled inputs */
  .input--filled {
    border: none;
    background-color: var(--sl-input-filled-background-color);
    color: var(--sl-input-color);
  }

  .input--filled:hover:not(.input--disabled) {
    background-color: var(--sl-input-filled-background-color-hover);
  }

  .input--filled.input--focused:not(.input--disabled) {
    background-color: var(--sl-input-filled-background-color-focus);
    outline: var(--sl-focus-ring);
    outline-offset: var(--sl-focus-ring-offset);
  }

  .input--filled.input--disabled {
    background-color: var(--sl-input-filled-background-color-disabled);
    opacity: 0.5;
    cursor: not-allowed;
  }

  .input__control {
    flex: 1 1 auto;
    font-family: inherit;
    font-size: inherit;
    font-weight: inherit;
    min-width: 0;
    height: 100%;
    color: var(--sl-input-color);
    border: none;
    background: inherit;
    box-shadow: none;
    padding: 0;
    margin: 0;
    cursor: inherit;
    -webkit-appearance: none;
  }

  .input__control::-webkit-search-decoration,
  .input__control::-webkit-search-cancel-button,
  .input__control::-webkit-search-results-button,
  .input__control::-webkit-search-results-decoration {
    -webkit-appearance: none;
  }

  .input__control:-webkit-autofill,
  .input__control:-webkit-autofill:hover,
  .input__control:-webkit-autofill:focus,
  .input__control:-webkit-autofill:active {
    box-shadow: 0 0 0 var(--sl-input-height-large) var(--sl-input-background-color-hover) inset !important;
    -webkit-text-fill-color: var(--sl-color-primary-500);
    caret-color: var(--sl-input-color);
  }

  .input--filled .input__control:-webkit-autofill,
  .input--filled .input__control:-webkit-autofill:hover,
  .input--filled .input__control:-webkit-autofill:focus,
  .input--filled .input__control:-webkit-autofill:active {
    box-shadow: 0 0 0 var(--sl-input-height-large) var(--sl-input-filled-background-color) inset !important;
  }

  .input__control::placeholder {
    color: var(--sl-input-placeholder-color);
    user-select: none;
    -webkit-user-select: none;
  }

  .input:hover:not(.input--disabled) .input__control {
    color: var(--sl-input-color-hover);
  }

  .input__control:focus {
    outline: none;
  }

  .input__prefix,
  .input__suffix {
    display: inline-flex;
    flex: 0 0 auto;
    align-items: center;
    cursor: default;
  }

  .input__prefix ::slotted(sl-icon),
  .input__suffix ::slotted(sl-icon) {
    color: var(--sl-input-icon-color);
  }

  /*
   * Size modifiers
   */

  .input--small {
    border-radius: var(--sl-input-border-radius-small);
    font-size: var(--sl-input-font-size-small);
    height: var(--sl-input-height-small);
  }

  .input--small .input__control {
    height: calc(var(--sl-input-height-small) - var(--sl-input-border-width) * 2);
    padding: 0 var(--sl-input-spacing-small);
  }

  .input--small .input__clear,
  .input--small .input__password-toggle {
    width: calc(1em + var(--sl-input-spacing-small) * 2);
  }

  .input--small .input__prefix ::slotted(*) {
    margin-inline-start: var(--sl-input-spacing-small);
  }

  .input--small .input__suffix ::slotted(*) {
    margin-inline-end: var(--sl-input-spacing-small);
  }

  .input--medium {
    border-radius: var(--sl-input-border-radius-medium);
    font-size: var(--sl-input-font-size-medium);
    height: var(--sl-input-height-medium);
  }

  .input--medium .input__control {
    height: calc(var(--sl-input-height-medium) - var(--sl-input-border-width) * 2);
    padding: 0 var(--sl-input-spacing-medium);
  }

  .input--medium .input__clear,
  .input--medium .input__password-toggle {
    width: calc(1em + var(--sl-input-spacing-medium) * 2);
  }

  .input--medium .input__prefix ::slotted(*) {
    margin-inline-start: var(--sl-input-spacing-medium);
  }

  .input--medium .input__suffix ::slotted(*) {
    margin-inline-end: var(--sl-input-spacing-medium);
  }

  .input--large {
    border-radius: var(--sl-input-border-radius-large);
    font-size: var(--sl-input-font-size-large);
    height: var(--sl-input-height-large);
  }

  .input--large .input__control {
    height: calc(var(--sl-input-height-large) - var(--sl-input-border-width) * 2);
    padding: 0 var(--sl-input-spacing-large);
  }

  .input--large .input__clear,
  .input--large .input__password-toggle {
    width: calc(1em + var(--sl-input-spacing-large) * 2);
  }

  .input--large .input__prefix ::slotted(*) {
    margin-inline-start: var(--sl-input-spacing-large);
  }

  .input--large .input__suffix ::slotted(*) {
    margin-inline-end: var(--sl-input-spacing-large);
  }

  /*
   * Pill modifier
   */

  .input--pill.input--small {
    border-radius: var(--sl-input-height-small);
  }

  .input--pill.input--medium {
    border-radius: var(--sl-input-height-medium);
  }

  .input--pill.input--large {
    border-radius: var(--sl-input-height-large);
  }

  /*
   * Clearable + Password Toggle
   */

  .input__clear,
  .input__password-toggle {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    font-size: inherit;
    color: var(--sl-input-icon-color);
    border: none;
    background: none;
    padding: 0;
    transition: var(--sl-transition-fast) color;
    cursor: pointer;
  }

  .input__clear:hover,
  .input__password-toggle:hover {
    color: var(--sl-input-icon-color-hover);
  }

  .input__clear:focus,
  .input__password-toggle:focus {
    outline: none;
  }

  /* Don't show the browser's password toggle in Edge */
  ::-ms-reveal {
    display: none;
  }

  /* Hide the built-in number spinner */
  .input--no-spin-buttons input[type='number']::-webkit-outer-spin-button,
  .input--no-spin-buttons input[type='number']::-webkit-inner-spin-button {
    -webkit-appearance: none;
    display: none;
  }

  .input--no-spin-buttons input[type='number'] {
    -moz-appearance: textfield;
  }
`, SlInput = class extends ShoelaceElement {
  constructor() {
    super(...arguments), this.formControlController = new FormControlController(this, {
      assumeInteractionOn: ["sl-blur", "sl-input"]
    }), this.hasSlotController = new HasSlotController(this, "help-text", "label"), this.localize = new LocalizeController(this), this.hasFocus = !1, this.title = "", this.__numberInput = Object.assign(document.createElement("input"), { type: "number" }), this.__dateInput = Object.assign(document.createElement("input"), { type: "date" }), this.type = "text", this.name = "", this.value = "", this.defaultValue = "", this.size = "medium", this.filled = !1, this.pill = !1, this.label = "", this.helpText = "", this.clearable = !1, this.disabled = !1, this.placeholder = "", this.readonly = !1, this.passwordToggle = !1, this.passwordVisible = !1, this.noSpinButtons = !1, this.form = "", this.required = !1, this.spellcheck = !0;
  }
  //
  // NOTE: We use an in-memory input for these getters/setters instead of the one in the template because the properties
  // can be set before the component is rendered.
  //
  /**
   * Gets or sets the current value as a `Date` object. Returns `null` if the value can't be converted. This will use the native `<input type="{{type}}">` implementation and may result in an error.
   */
  get valueAsDate() {
    var z;
    return this.__dateInput.type = this.type, this.__dateInput.value = this.value, ((z = this.input) == null ? void 0 : z.valueAsDate) || this.__dateInput.valueAsDate;
  }
  set valueAsDate(z) {
    this.__dateInput.type = this.type, this.__dateInput.valueAsDate = z, this.value = this.__dateInput.value;
  }
  /** Gets or sets the current value as a number. Returns `NaN` if the value can't be converted. */
  get valueAsNumber() {
    var z;
    return this.__numberInput.value = this.value, ((z = this.input) == null ? void 0 : z.valueAsNumber) || this.__numberInput.valueAsNumber;
  }
  set valueAsNumber(z) {
    this.__numberInput.valueAsNumber = z, this.value = this.__numberInput.value;
  }
  /** Gets the validity state object */
  get validity() {
    return this.input.validity;
  }
  /** Gets the validation message */
  get validationMessage() {
    return this.input.validationMessage;
  }
  firstUpdated() {
    this.formControlController.updateValidity();
  }
  handleBlur() {
    this.hasFocus = !1, this.emit("sl-blur");
  }
  handleChange() {
    this.value = this.input.value, this.emit("sl-change");
  }
  handleClearClick(z) {
    z.preventDefault(), this.value !== "" && (this.value = "", this.emit("sl-clear"), this.emit("sl-input"), this.emit("sl-change")), this.input.focus();
  }
  handleFocus() {
    this.hasFocus = !0, this.emit("sl-focus");
  }
  handleInput() {
    this.value = this.input.value, this.formControlController.updateValidity(), this.emit("sl-input");
  }
  handleInvalid(z) {
    this.formControlController.setValidity(!1), this.formControlController.emitInvalidEvent(z);
  }
  handleKeyDown(z) {
    const D = z.metaKey || z.ctrlKey || z.shiftKey || z.altKey;
    z.key === "Enter" && !D && setTimeout(() => {
      !z.defaultPrevented && !z.isComposing && this.formControlController.submit();
    });
  }
  handlePasswordToggle() {
    this.passwordVisible = !this.passwordVisible;
  }
  handleDisabledChange() {
    this.formControlController.setValidity(this.disabled);
  }
  handleStepChange() {
    this.input.step = String(this.step), this.formControlController.updateValidity();
  }
  async handleValueChange() {
    await this.updateComplete, this.formControlController.updateValidity();
  }
  /** Sets focus on the input. */
  focus(z) {
    this.input.focus(z);
  }
  /** Removes focus from the input. */
  blur() {
    this.input.blur();
  }
  /** Selects all the text in the input. */
  select() {
    this.input.select();
  }
  /** Sets the start and end positions of the text selection (0-based). */
  setSelectionRange(z, D, O = "none") {
    this.input.setSelectionRange(z, D, O);
  }
  /** Replaces a range of text with a new string. */
  setRangeText(z, D, O, F = "preserve") {
    const U = D ?? this.input.selectionStart, W = O ?? this.input.selectionEnd;
    this.input.setRangeText(z, U, W, F), this.value !== this.input.value && (this.value = this.input.value);
  }
  /** Displays the browser picker for an input element (only works if the browser supports it for the input type). */
  showPicker() {
    "showPicker" in HTMLInputElement.prototype && this.input.showPicker();
  }
  /** Increments the value of a numeric input type by the value of the step attribute. */
  stepUp() {
    this.input.stepUp(), this.value !== this.input.value && (this.value = this.input.value);
  }
  /** Decrements the value of a numeric input type by the value of the step attribute. */
  stepDown() {
    this.input.stepDown(), this.value !== this.input.value && (this.value = this.input.value);
  }
  /** Checks for validity but does not show a validation message. Returns `true` when valid and `false` when invalid. */
  checkValidity() {
    return this.input.checkValidity();
  }
  /** Gets the associated form, if one exists. */
  getForm() {
    return this.formControlController.getForm();
  }
  /** Checks for validity and shows the browser's validation message if the control is invalid. */
  reportValidity() {
    return this.input.reportValidity();
  }
  /** Sets a custom validation message. Pass an empty string to restore validity. */
  setCustomValidity(z) {
    this.input.setCustomValidity(z), this.formControlController.updateValidity();
  }
  render() {
    const z = this.hasSlotController.test("label"), D = this.hasSlotController.test("help-text"), O = this.label ? !0 : !!z, F = this.helpText ? !0 : !!D, W = this.clearable && !this.disabled && !this.readonly && (typeof this.value == "number" || this.value.length > 0);
    return x`
      <div
        part="form-control"
        class=${e$2({
      "form-control": !0,
      "form-control--small": this.size === "small",
      "form-control--medium": this.size === "medium",
      "form-control--large": this.size === "large",
      "form-control--has-label": O,
      "form-control--has-help-text": F
    })}
      >
        <label
          part="form-control-label"
          class="form-control__label"
          for="input"
          aria-hidden=${O ? "false" : "true"}
        >
          <slot name="label">${this.label}</slot>
        </label>

        <div part="form-control-input" class="form-control-input">
          <div
            part="base"
            class=${e$2({
      input: !0,
      // Sizes
      "input--small": this.size === "small",
      "input--medium": this.size === "medium",
      "input--large": this.size === "large",
      // States
      "input--pill": this.pill,
      "input--standard": !this.filled,
      "input--filled": this.filled,
      "input--disabled": this.disabled,
      "input--focused": this.hasFocus,
      "input--empty": !this.value,
      "input--no-spin-buttons": this.noSpinButtons
    })}
          >
            <span part="prefix" class="input__prefix">
              <slot name="prefix"></slot>
            </span>

            <input
              part="input"
              id="input"
              class="input__control"
              type=${this.type === "password" && this.passwordVisible ? "text" : this.type}
              title=${this.title}
              name=${o$6(this.name)}
              ?disabled=${this.disabled}
              ?readonly=${this.readonly}
              ?required=${this.required}
              placeholder=${o$6(this.placeholder)}
              minlength=${o$6(this.minlength)}
              maxlength=${o$6(this.maxlength)}
              min=${o$6(this.min)}
              max=${o$6(this.max)}
              step=${o$6(this.step)}
              .value=${l$1(this.value)}
              autocapitalize=${o$6(this.autocapitalize)}
              autocomplete=${o$6(this.autocomplete)}
              autocorrect=${o$6(this.autocorrect)}
              ?autofocus=${this.autofocus}
              spellcheck=${this.spellcheck}
              pattern=${o$6(this.pattern)}
              enterkeyhint=${o$6(this.enterkeyhint)}
              inputmode=${o$6(this.inputmode)}
              aria-describedby="help-text"
              @change=${this.handleChange}
              @input=${this.handleInput}
              @invalid=${this.handleInvalid}
              @keydown=${this.handleKeyDown}
              @focus=${this.handleFocus}
              @blur=${this.handleBlur}
            />

            ${W ? x`
                  <button
                    part="clear-button"
                    class="input__clear"
                    type="button"
                    aria-label=${this.localize.term("clearEntry")}
                    @click=${this.handleClearClick}
                    tabindex="-1"
                  >
                    <slot name="clear-icon">
                      <sl-icon name="x-circle-fill" library="system"></sl-icon>
                    </slot>
                  </button>
                ` : ""}
            ${this.passwordToggle && !this.disabled ? x`
                  <button
                    part="password-toggle-button"
                    class="input__password-toggle"
                    type="button"
                    aria-label=${this.localize.term(this.passwordVisible ? "hidePassword" : "showPassword")}
                    @click=${this.handlePasswordToggle}
                    tabindex="-1"
                  >
                    ${this.passwordVisible ? x`
                          <slot name="show-password-icon">
                            <sl-icon name="eye-slash" library="system"></sl-icon>
                          </slot>
                        ` : x`
                          <slot name="hide-password-icon">
                            <sl-icon name="eye" library="system"></sl-icon>
                          </slot>
                        `}
                  </button>
                ` : ""}

            <span part="suffix" class="input__suffix">
              <slot name="suffix"></slot>
            </span>
          </div>
        </div>

        <div
          part="form-control-help-text"
          id="help-text"
          class="form-control__help-text"
          aria-hidden=${F ? "false" : "true"}
        >
          <slot name="help-text">${this.helpText}</slot>
        </div>
      </div>
    `;
  }
};
SlInput.styles = [component_styles_default, form_control_styles_default, input_styles_default];
SlInput.dependencies = { "sl-icon": SlIcon };
__decorateClass([
  e$b(".input__control")
], SlInput.prototype, "input", 2);
__decorateClass([
  r$4()
], SlInput.prototype, "hasFocus", 2);
__decorateClass([
  n$6()
], SlInput.prototype, "title", 2);
__decorateClass([
  n$6({ reflect: !0 })
], SlInput.prototype, "type", 2);
__decorateClass([
  n$6()
], SlInput.prototype, "name", 2);
__decorateClass([
  n$6()
], SlInput.prototype, "value", 2);
__decorateClass([
  defaultValue()
], SlInput.prototype, "defaultValue", 2);
__decorateClass([
  n$6({ reflect: !0 })
], SlInput.prototype, "size", 2);
__decorateClass([
  n$6({ type: Boolean, reflect: !0 })
], SlInput.prototype, "filled", 2);
__decorateClass([
  n$6({ type: Boolean, reflect: !0 })
], SlInput.prototype, "pill", 2);
__decorateClass([
  n$6()
], SlInput.prototype, "label", 2);
__decorateClass([
  n$6({ attribute: "help-text" })
], SlInput.prototype, "helpText", 2);
__decorateClass([
  n$6({ type: Boolean })
], SlInput.prototype, "clearable", 2);
__decorateClass([
  n$6({ type: Boolean, reflect: !0 })
], SlInput.prototype, "disabled", 2);
__decorateClass([
  n$6()
], SlInput.prototype, "placeholder", 2);
__decorateClass([
  n$6({ type: Boolean, reflect: !0 })
], SlInput.prototype, "readonly", 2);
__decorateClass([
  n$6({ attribute: "password-toggle", type: Boolean })
], SlInput.prototype, "passwordToggle", 2);
__decorateClass([
  n$6({ attribute: "password-visible", type: Boolean })
], SlInput.prototype, "passwordVisible", 2);
__decorateClass([
  n$6({ attribute: "no-spin-buttons", type: Boolean })
], SlInput.prototype, "noSpinButtons", 2);
__decorateClass([
  n$6({ reflect: !0 })
], SlInput.prototype, "form", 2);
__decorateClass([
  n$6({ type: Boolean, reflect: !0 })
], SlInput.prototype, "required", 2);
__decorateClass([
  n$6()
], SlInput.prototype, "pattern", 2);
__decorateClass([
  n$6({ type: Number })
], SlInput.prototype, "minlength", 2);
__decorateClass([
  n$6({ type: Number })
], SlInput.prototype, "maxlength", 2);
__decorateClass([
  n$6()
], SlInput.prototype, "min", 2);
__decorateClass([
  n$6()
], SlInput.prototype, "max", 2);
__decorateClass([
  n$6()
], SlInput.prototype, "step", 2);
__decorateClass([
  n$6()
], SlInput.prototype, "autocapitalize", 2);
__decorateClass([
  n$6()
], SlInput.prototype, "autocorrect", 2);
__decorateClass([
  n$6()
], SlInput.prototype, "autocomplete", 2);
__decorateClass([
  n$6({ type: Boolean })
], SlInput.prototype, "autofocus", 2);
__decorateClass([
  n$6()
], SlInput.prototype, "enterkeyhint", 2);
__decorateClass([
  n$6({
    type: Boolean,
    converter: {
      // Allow "true|false" attribute values but keep the property boolean
      fromAttribute: (z) => !(!z || z === "false"),
      toAttribute: (z) => z ? "true" : "false"
    }
  })
], SlInput.prototype, "spellcheck", 2);
__decorateClass([
  n$6()
], SlInput.prototype, "inputmode", 2);
__decorateClass([
  watch("disabled", { waitUntilFirstUpdate: !0 })
], SlInput.prototype, "handleDisabledChange", 1);
__decorateClass([
  watch("step", { waitUntilFirstUpdate: !0 })
], SlInput.prototype, "handleStepChange", 1);
__decorateClass([
  watch("value", { waitUntilFirstUpdate: !0 })
], SlInput.prototype, "handleValueChange", 1);
SlInput.define("sl-input");
var menu_label_styles_default = i$7`
  :host {
    display: block;
  }

  .menu-label {
    display: inline-block;
    font-family: var(--sl-font-sans);
    font-size: var(--sl-font-size-small);
    font-weight: var(--sl-font-weight-semibold);
    line-height: var(--sl-line-height-normal);
    letter-spacing: var(--sl-letter-spacing-normal);
    color: var(--sl-color-neutral-500);
    padding: var(--sl-spacing-2x-small) var(--sl-spacing-x-large);
    user-select: none;
    -webkit-user-select: none;
  }
`, SlMenuLabel = class extends ShoelaceElement {
  render() {
    return x` <slot part="base" class="menu-label"></slot> `;
  }
};
SlMenuLabel.styles = [component_styles_default, menu_label_styles_default];
SlMenuLabel.define("sl-menu-label");
SlIcon.define("sl-icon");
SlIconButton.define("sl-icon-button");
var image_comparer_styles_default = i$7`
  :host {
    --divider-width: 2px;
    --handle-size: 2.5rem;

    display: inline-block;
    position: relative;
  }

  .image-comparer {
    max-width: 100%;
    max-height: 100%;
    overflow: hidden;
  }

  .image-comparer__before,
  .image-comparer__after {
    display: block;
    pointer-events: none;
  }

  .image-comparer__before::slotted(img),
  .image-comparer__after::slotted(img),
  .image-comparer__before::slotted(svg),
  .image-comparer__after::slotted(svg) {
    display: block;
    max-width: 100% !important;
    height: auto;
  }

  .image-comparer__after {
    position: absolute;
    top: 0;
    left: 0;
    height: 100%;
    width: 100%;
  }

  .image-comparer__divider {
    display: flex;
    align-items: center;
    justify-content: center;
    position: absolute;
    top: 0;
    width: var(--divider-width);
    height: 100%;
    background-color: var(--sl-color-neutral-0);
    translate: calc(var(--divider-width) / -2);
    cursor: ew-resize;
  }

  .image-comparer__handle {
    display: flex;
    align-items: center;
    justify-content: center;
    position: absolute;
    top: calc(50% - (var(--handle-size) / 2));
    width: var(--handle-size);
    height: var(--handle-size);
    background-color: var(--sl-color-neutral-0);
    border-radius: var(--sl-border-radius-circle);
    font-size: calc(var(--handle-size) * 0.5);
    color: var(--sl-color-neutral-700);
    cursor: inherit;
    z-index: 10;
  }

  .image-comparer__handle:focus-visible {
    outline: var(--sl-focus-ring);
    outline-offset: var(--sl-focus-ring-offset);
  }
`, SlImageComparer = class extends ShoelaceElement {
  constructor() {
    super(...arguments), this.localize = new LocalizeController(this), this.position = 50;
  }
  handleDrag(z) {
    const { width: D } = this.base.getBoundingClientRect(), O = this.localize.dir() === "rtl";
    z.preventDefault(), drag(this.base, {
      onMove: (F) => {
        this.position = parseFloat(clamp$1(F / D * 100, 0, 100).toFixed(2)), O && (this.position = 100 - this.position);
      },
      initialEvent: z
    });
  }
  handleKeyDown(z) {
    const D = this.localize.dir() === "ltr", O = this.localize.dir() === "rtl";
    if (["ArrowLeft", "ArrowRight", "Home", "End"].includes(z.key)) {
      const F = z.shiftKey ? 10 : 1;
      let U = this.position;
      z.preventDefault(), (D && z.key === "ArrowLeft" || O && z.key === "ArrowRight") && (U -= F), (D && z.key === "ArrowRight" || O && z.key === "ArrowLeft") && (U += F), z.key === "Home" && (U = 0), z.key === "End" && (U = 100), U = clamp$1(U, 0, 100), this.position = U;
    }
  }
  handlePositionChange() {
    this.emit("sl-change");
  }
  render() {
    const z = this.localize.dir() === "rtl";
    return x`
      <div
        part="base"
        id="image-comparer"
        class=${e$2({
      "image-comparer": !0,
      "image-comparer--rtl": z
    })}
        @keydown=${this.handleKeyDown}
      >
        <div class="image-comparer__image">
          <div part="before" class="image-comparer__before">
            <slot name="before"></slot>
          </div>

          <div
            part="after"
            class="image-comparer__after"
            style=${o$3({
      clipPath: z ? `inset(0 0 0 ${100 - this.position}%)` : `inset(0 ${100 - this.position}% 0 0)`
    })}
          >
            <slot name="after"></slot>
          </div>
        </div>

        <div
          part="divider"
          class="image-comparer__divider"
          style=${o$3({
      left: z ? `${100 - this.position}%` : `${this.position}%`
    })}
          @mousedown=${this.handleDrag}
          @touchstart=${this.handleDrag}
        >
          <div
            part="handle"
            class="image-comparer__handle"
            role="scrollbar"
            aria-valuenow=${this.position}
            aria-valuemin="0"
            aria-valuemax="100"
            aria-controls="image-comparer"
            tabindex="0"
          >
            <slot name="handle">
              <sl-icon library="system" name="grip-vertical"></sl-icon>
            </slot>
          </div>
        </div>
      </div>
    `;
  }
};
SlImageComparer.styles = [component_styles_default, image_comparer_styles_default];
SlImageComparer.scopedElement = { "sl-icon": SlIcon };
__decorateClass([
  e$b(".image-comparer")
], SlImageComparer.prototype, "base", 2);
__decorateClass([
  e$b(".image-comparer__handle")
], SlImageComparer.prototype, "handle", 2);
__decorateClass([
  n$6({ type: Number, reflect: !0 })
], SlImageComparer.prototype, "position", 2);
__decorateClass([
  watch("position", { waitUntilFirstUpdate: !0 })
], SlImageComparer.prototype, "handlePositionChange", 1);
SlImageComparer.define("sl-image-comparer");
var include_styles_default = i$7`
  :host {
    display: block;
  }
`, includeFiles = /* @__PURE__ */ new Map();
function requestInclude(z, D = "cors") {
  const O = includeFiles.get(z);
  if (O !== void 0)
    return Promise.resolve(O);
  const F = fetch(z, { mode: D }).then(async (U) => {
    const W = {
      ok: U.ok,
      status: U.status,
      html: await U.text()
    };
    return includeFiles.set(z, W), W;
  });
  return includeFiles.set(z, F), F;
}
var SlInclude = class extends ShoelaceElement {
  constructor() {
    super(...arguments), this.mode = "cors", this.allowScripts = !1;
  }
  executeScript(z) {
    const D = document.createElement("script");
    [...z.attributes].forEach((O) => D.setAttribute(O.name, O.value)), D.textContent = z.textContent, z.parentNode.replaceChild(D, z);
  }
  async handleSrcChange() {
    try {
      const z = this.src, D = await requestInclude(z, this.mode);
      if (z !== this.src)
        return;
      if (!D.ok) {
        this.emit("sl-error", { detail: { status: D.status } });
        return;
      }
      this.innerHTML = D.html, this.allowScripts && [...this.querySelectorAll("script")].forEach((O) => this.executeScript(O)), this.emit("sl-load");
    } catch {
      this.emit("sl-error", { detail: { status: -1 } });
    }
  }
  render() {
    return x`<slot></slot>`;
  }
};
SlInclude.styles = [component_styles_default, include_styles_default];
__decorateClass([
  n$6()
], SlInclude.prototype, "src", 2);
__decorateClass([
  n$6()
], SlInclude.prototype, "mode", 2);
__decorateClass([
  n$6({ attribute: "allow-scripts", type: Boolean })
], SlInclude.prototype, "allowScripts", 2);
__decorateClass([
  watch("src")
], SlInclude.prototype, "handleSrcChange", 1);
SlInclude.define("sl-include");
var dropdown_styles_default = i$7`
  :host {
    display: inline-block;
  }

  .dropdown::part(popup) {
    z-index: var(--sl-z-index-dropdown);
  }

  .dropdown[data-current-placement^='top']::part(popup) {
    transform-origin: bottom;
  }

  .dropdown[data-current-placement^='bottom']::part(popup) {
    transform-origin: top;
  }

  .dropdown[data-current-placement^='left']::part(popup) {
    transform-origin: right;
  }

  .dropdown[data-current-placement^='right']::part(popup) {
    transform-origin: left;
  }

  .dropdown__trigger {
    display: block;
  }

  .dropdown__panel {
    font-family: var(--sl-font-sans);
    font-size: var(--sl-font-size-medium);
    font-weight: var(--sl-font-weight-normal);
    box-shadow: var(--sl-shadow-large);
    border-radius: var(--sl-border-radius-medium);
    pointer-events: none;
  }

  .dropdown--open .dropdown__panel {
    display: block;
    pointer-events: all;
  }

  /* When users slot a menu, make sure it conforms to the popup's auto-size */
  ::slotted(sl-menu) {
    max-width: var(--auto-size-available-width) !important;
    max-height: var(--auto-size-available-height) !important;
  }
`, computedStyleMap = /* @__PURE__ */ new WeakMap();
function getCachedComputedStyle(z) {
  let D = computedStyleMap.get(z);
  return D || (D = window.getComputedStyle(z, null), computedStyleMap.set(z, D)), D;
}
function isVisible(z) {
  if (typeof z.checkVisibility == "function")
    return z.checkVisibility({ checkOpacity: !1, checkVisibilityCSS: !0 });
  const D = getCachedComputedStyle(z);
  return D.visibility !== "hidden" && D.display !== "none";
}
function isOverflowingAndTabbable(z) {
  const D = getCachedComputedStyle(z), { overflowY: O, overflowX: F } = D;
  return O === "scroll" || F === "scroll" ? !0 : O !== "auto" || F !== "auto" ? !1 : z.scrollHeight > z.clientHeight && O === "auto" || z.scrollWidth > z.clientWidth && F === "auto";
}
function isTabbable(z) {
  const D = z.tagName.toLowerCase(), O = Number(z.getAttribute("tabindex"));
  return z.hasAttribute("tabindex") && (isNaN(O) || O <= -1) || z.hasAttribute("disabled") || z.closest("[inert]") || D === "input" && z.getAttribute("type") === "radio" && !z.hasAttribute("checked") || !isVisible(z) ? !1 : (D === "audio" || D === "video") && z.hasAttribute("controls") || z.hasAttribute("tabindex") || z.hasAttribute("contenteditable") && z.getAttribute("contenteditable") !== "false" || [
    "button",
    "input",
    "select",
    "textarea",
    "a",
    "audio",
    "video",
    "summary",
    "iframe"
  ].includes(D) ? !0 : isOverflowingAndTabbable(z);
}
function getTabbableBoundary(z) {
  var D, O;
  const F = getTabbableElements(z), U = (D = F[0]) != null ? D : null, W = (O = F[F.length - 1]) != null ? O : null;
  return { start: U, end: W };
}
function getSlottedChildrenOutsideRootElement(z, D) {
  var O;
  return ((O = z.getRootNode({ composed: !0 })) == null ? void 0 : O.host) !== D;
}
function getTabbableElements(z) {
  const D = /* @__PURE__ */ new WeakMap(), O = [];
  function F(U) {
    if (U instanceof Element) {
      if (U.hasAttribute("inert") || U.closest("[inert]") || D.has(U))
        return;
      D.set(U, !0), !O.includes(U) && isTabbable(U) && O.push(U), U instanceof HTMLSlotElement && getSlottedChildrenOutsideRootElement(U, z) && U.assignedElements({ flatten: !0 }).forEach((W) => {
        F(W);
      }), U.shadowRoot !== null && U.shadowRoot.mode === "open" && F(U.shadowRoot);
    }
    for (const W of U.children)
      F(W);
  }
  return F(z), O.sort((U, W) => {
    const B = Number(U.getAttribute("tabindex")) || 0;
    return (Number(W.getAttribute("tabindex")) || 0) - B;
  });
}
var SlDropdown = class extends ShoelaceElement {
  constructor() {
    super(...arguments), this.localize = new LocalizeController(this), this.open = !1, this.placement = "bottom-start", this.disabled = !1, this.stayOpenOnSelect = !1, this.distance = 0, this.skidding = 0, this.hoist = !1, this.sync = void 0, this.handleKeyDown = (z) => {
      this.open && z.key === "Escape" && (z.stopPropagation(), this.hide(), this.focusOnTrigger());
    }, this.handleDocumentKeyDown = (z) => {
      var D;
      if (z.key === "Escape" && this.open && !this.closeWatcher) {
        z.stopPropagation(), this.focusOnTrigger(), this.hide();
        return;
      }
      if (z.key === "Tab") {
        if (this.open && ((D = document.activeElement) == null ? void 0 : D.tagName.toLowerCase()) === "sl-menu-item") {
          z.preventDefault(), this.hide(), this.focusOnTrigger();
          return;
        }
        setTimeout(() => {
          var O, F, U;
          const W = ((O = this.containingElement) == null ? void 0 : O.getRootNode()) instanceof ShadowRoot ? (U = (F = document.activeElement) == null ? void 0 : F.shadowRoot) == null ? void 0 : U.activeElement : document.activeElement;
          (!this.containingElement || (W == null ? void 0 : W.closest(this.containingElement.tagName.toLowerCase())) !== this.containingElement) && this.hide();
        });
      }
    }, this.handleDocumentMouseDown = (z) => {
      const D = z.composedPath();
      this.containingElement && !D.includes(this.containingElement) && this.hide();
    }, this.handlePanelSelect = (z) => {
      const D = z.target;
      !this.stayOpenOnSelect && D.tagName.toLowerCase() === "sl-menu" && (this.hide(), this.focusOnTrigger());
    };
  }
  connectedCallback() {
    super.connectedCallback(), this.containingElement || (this.containingElement = this);
  }
  firstUpdated() {
    this.panel.hidden = !this.open, this.open && (this.addOpenListeners(), this.popup.active = !0);
  }
  disconnectedCallback() {
    super.disconnectedCallback(), this.removeOpenListeners(), this.hide();
  }
  focusOnTrigger() {
    const z = this.trigger.assignedElements({ flatten: !0 })[0];
    typeof (z == null ? void 0 : z.focus) == "function" && z.focus();
  }
  getMenu() {
    return this.panel.assignedElements({ flatten: !0 }).find((z) => z.tagName.toLowerCase() === "sl-menu");
  }
  handleTriggerClick() {
    this.open ? this.hide() : (this.show(), this.focusOnTrigger());
  }
  async handleTriggerKeyDown(z) {
    if ([" ", "Enter"].includes(z.key)) {
      z.preventDefault(), this.handleTriggerClick();
      return;
    }
    const D = this.getMenu();
    if (D) {
      const O = D.getAllItems(), F = O[0], U = O[O.length - 1];
      ["ArrowDown", "ArrowUp", "Home", "End"].includes(z.key) && (z.preventDefault(), this.open || (this.show(), await this.updateComplete), O.length > 0 && this.updateComplete.then(() => {
        (z.key === "ArrowDown" || z.key === "Home") && (D.setCurrentItem(F), F.focus()), (z.key === "ArrowUp" || z.key === "End") && (D.setCurrentItem(U), U.focus());
      }));
    }
  }
  handleTriggerKeyUp(z) {
    z.key === " " && z.preventDefault();
  }
  handleTriggerSlotChange() {
    this.updateAccessibleTrigger();
  }
  //
  // Slotted triggers can be arbitrary content, but we need to link them to the dropdown panel with `aria-haspopup` and
  // `aria-expanded`. These must be applied to the "accessible trigger" (the tabbable portion of the trigger element
  // that gets slotted in) so screen readers will understand them. The accessible trigger could be the slotted element,
  // a child of the slotted element, or an element in the slotted element's shadow root.
  //
  // For example, the accessible trigger of an <sl-button> is a <button> located inside its shadow root.
  //
  // To determine this, we assume the first tabbable element in the trigger slot is the "accessible trigger."
  //
  updateAccessibleTrigger() {
    const D = this.trigger.assignedElements({ flatten: !0 }).find((F) => getTabbableBoundary(F).start);
    let O;
    if (D) {
      switch (D.tagName.toLowerCase()) {
        case "sl-button":
        case "sl-icon-button":
          O = D.button;
          break;
        default:
          O = D;
      }
      O.setAttribute("aria-haspopup", "true"), O.setAttribute("aria-expanded", this.open ? "true" : "false");
    }
  }
  /** Shows the dropdown panel. */
  async show() {
    if (!this.open)
      return this.open = !0, waitForEvent(this, "sl-after-show");
  }
  /** Hides the dropdown panel */
  async hide() {
    if (this.open)
      return this.open = !1, waitForEvent(this, "sl-after-hide");
  }
  /**
   * Instructs the dropdown menu to reposition. Useful when the position or size of the trigger changes when the menu
   * is activated.
   */
  reposition() {
    this.popup.reposition();
  }
  addOpenListeners() {
    var z;
    this.panel.addEventListener("sl-select", this.handlePanelSelect), "CloseWatcher" in window ? ((z = this.closeWatcher) == null || z.destroy(), this.closeWatcher = new CloseWatcher(), this.closeWatcher.onclose = () => {
      this.hide(), this.focusOnTrigger();
    }) : this.panel.addEventListener("keydown", this.handleKeyDown), document.addEventListener("keydown", this.handleDocumentKeyDown), document.addEventListener("mousedown", this.handleDocumentMouseDown);
  }
  removeOpenListeners() {
    var z;
    this.panel && (this.panel.removeEventListener("sl-select", this.handlePanelSelect), this.panel.removeEventListener("keydown", this.handleKeyDown)), document.removeEventListener("keydown", this.handleDocumentKeyDown), document.removeEventListener("mousedown", this.handleDocumentMouseDown), (z = this.closeWatcher) == null || z.destroy();
  }
  async handleOpenChange() {
    if (this.disabled) {
      this.open = !1;
      return;
    }
    if (this.updateAccessibleTrigger(), this.open) {
      this.emit("sl-show"), this.addOpenListeners(), await stopAnimations(this), this.panel.hidden = !1, this.popup.active = !0;
      const { keyframes: z, options: D } = getAnimation(this, "dropdown.show", { dir: this.localize.dir() });
      await animateTo(this.popup.popup, z, D), this.emit("sl-after-show");
    } else {
      this.emit("sl-hide"), this.removeOpenListeners(), await stopAnimations(this);
      const { keyframes: z, options: D } = getAnimation(this, "dropdown.hide", { dir: this.localize.dir() });
      await animateTo(this.popup.popup, z, D), this.panel.hidden = !0, this.popup.active = !1, this.emit("sl-after-hide");
    }
  }
  render() {
    return x`
      <sl-popup
        part="base"
        id="dropdown"
        placement=${this.placement}
        distance=${this.distance}
        skidding=${this.skidding}
        strategy=${this.hoist ? "fixed" : "absolute"}
        flip
        shift
        auto-size="vertical"
        auto-size-padding="10"
        sync=${o$6(this.sync ? this.sync : void 0)}
        class=${e$2({
      dropdown: !0,
      "dropdown--open": this.open
    })}
      >
        <slot
          name="trigger"
          slot="anchor"
          part="trigger"
          class="dropdown__trigger"
          @click=${this.handleTriggerClick}
          @keydown=${this.handleTriggerKeyDown}
          @keyup=${this.handleTriggerKeyUp}
          @slotchange=${this.handleTriggerSlotChange}
        ></slot>

        <div aria-hidden=${this.open ? "false" : "true"} aria-labelledby="dropdown">
          <slot part="panel" class="dropdown__panel"></slot>
        </div>
      </sl-popup>
    `;
  }
};
SlDropdown.styles = [component_styles_default, dropdown_styles_default];
SlDropdown.dependencies = { "sl-popup": SlPopup };
__decorateClass([
  e$b(".dropdown")
], SlDropdown.prototype, "popup", 2);
__decorateClass([
  e$b(".dropdown__trigger")
], SlDropdown.prototype, "trigger", 2);
__decorateClass([
  e$b(".dropdown__panel")
], SlDropdown.prototype, "panel", 2);
__decorateClass([
  n$6({ type: Boolean, reflect: !0 })
], SlDropdown.prototype, "open", 2);
__decorateClass([
  n$6({ reflect: !0 })
], SlDropdown.prototype, "placement", 2);
__decorateClass([
  n$6({ type: Boolean, reflect: !0 })
], SlDropdown.prototype, "disabled", 2);
__decorateClass([
  n$6({ attribute: "stay-open-on-select", type: Boolean, reflect: !0 })
], SlDropdown.prototype, "stayOpenOnSelect", 2);
__decorateClass([
  n$6({ attribute: !1 })
], SlDropdown.prototype, "containingElement", 2);
__decorateClass([
  n$6({ type: Number })
], SlDropdown.prototype, "distance", 2);
__decorateClass([
  n$6({ type: Number })
], SlDropdown.prototype, "skidding", 2);
__decorateClass([
  n$6({ type: Boolean })
], SlDropdown.prototype, "hoist", 2);
__decorateClass([
  n$6({ reflect: !0 })
], SlDropdown.prototype, "sync", 2);
__decorateClass([
  watch("open", { waitUntilFirstUpdate: !0 })
], SlDropdown.prototype, "handleOpenChange", 1);
setDefaultAnimation("dropdown.show", {
  keyframes: [
    { opacity: 0, scale: 0.9 },
    { opacity: 1, scale: 1 }
  ],
  options: { duration: 100, easing: "ease" }
});
setDefaultAnimation("dropdown.hide", {
  keyframes: [
    { opacity: 1, scale: 1 },
    { opacity: 0, scale: 0.9 }
  ],
  options: { duration: 100, easing: "ease" }
});
SlDropdown.define("sl-dropdown");
var SlFormatDate = class extends ShoelaceElement {
  constructor() {
    super(...arguments), this.localize = new LocalizeController(this), this.date = /* @__PURE__ */ new Date(), this.hourFormat = "auto";
  }
  render() {
    const z = new Date(this.date), D = this.hourFormat === "auto" ? void 0 : this.hourFormat === "12";
    if (!isNaN(z.getMilliseconds()))
      return x`
      <time datetime=${z.toISOString()}>
        ${this.localize.date(z, {
        weekday: this.weekday,
        era: this.era,
        year: this.year,
        month: this.month,
        day: this.day,
        hour: this.hour,
        minute: this.minute,
        second: this.second,
        timeZoneName: this.timeZoneName,
        timeZone: this.timeZone,
        hour12: D
      })}
      </time>
    `;
  }
};
__decorateClass([
  n$6()
], SlFormatDate.prototype, "date", 2);
__decorateClass([
  n$6()
], SlFormatDate.prototype, "weekday", 2);
__decorateClass([
  n$6()
], SlFormatDate.prototype, "era", 2);
__decorateClass([
  n$6()
], SlFormatDate.prototype, "year", 2);
__decorateClass([
  n$6()
], SlFormatDate.prototype, "month", 2);
__decorateClass([
  n$6()
], SlFormatDate.prototype, "day", 2);
__decorateClass([
  n$6()
], SlFormatDate.prototype, "hour", 2);
__decorateClass([
  n$6()
], SlFormatDate.prototype, "minute", 2);
__decorateClass([
  n$6()
], SlFormatDate.prototype, "second", 2);
__decorateClass([
  n$6({ attribute: "time-zone-name" })
], SlFormatDate.prototype, "timeZoneName", 2);
__decorateClass([
  n$6({ attribute: "time-zone" })
], SlFormatDate.prototype, "timeZone", 2);
__decorateClass([
  n$6({ attribute: "hour-format" })
], SlFormatDate.prototype, "hourFormat", 2);
SlFormatDate.define("sl-format-date");
var SlFormatNumber = class extends ShoelaceElement {
  constructor() {
    super(...arguments), this.localize = new LocalizeController(this), this.value = 0, this.type = "decimal", this.noGrouping = !1, this.currency = "USD", this.currencyDisplay = "symbol";
  }
  render() {
    return isNaN(this.value) ? "" : this.localize.number(this.value, {
      style: this.type,
      currency: this.currency,
      currencyDisplay: this.currencyDisplay,
      useGrouping: !this.noGrouping,
      minimumIntegerDigits: this.minimumIntegerDigits,
      minimumFractionDigits: this.minimumFractionDigits,
      maximumFractionDigits: this.maximumFractionDigits,
      minimumSignificantDigits: this.minimumSignificantDigits,
      maximumSignificantDigits: this.maximumSignificantDigits
    });
  }
};
__decorateClass([
  n$6({ type: Number })
], SlFormatNumber.prototype, "value", 2);
__decorateClass([
  n$6()
], SlFormatNumber.prototype, "type", 2);
__decorateClass([
  n$6({ attribute: "no-grouping", type: Boolean })
], SlFormatNumber.prototype, "noGrouping", 2);
__decorateClass([
  n$6()
], SlFormatNumber.prototype, "currency", 2);
__decorateClass([
  n$6({ attribute: "currency-display" })
], SlFormatNumber.prototype, "currencyDisplay", 2);
__decorateClass([
  n$6({ attribute: "minimum-integer-digits", type: Number })
], SlFormatNumber.prototype, "minimumIntegerDigits", 2);
__decorateClass([
  n$6({ attribute: "minimum-fraction-digits", type: Number })
], SlFormatNumber.prototype, "minimumFractionDigits", 2);
__decorateClass([
  n$6({ attribute: "maximum-fraction-digits", type: Number })
], SlFormatNumber.prototype, "maximumFractionDigits", 2);
__decorateClass([
  n$6({ attribute: "minimum-significant-digits", type: Number })
], SlFormatNumber.prototype, "minimumSignificantDigits", 2);
__decorateClass([
  n$6({ attribute: "maximum-significant-digits", type: Number })
], SlFormatNumber.prototype, "maximumSignificantDigits", 2);
SlFormatNumber.define("sl-format-number");
var copy_button_styles_default = i$7`
  :host {
    --error-color: var(--sl-color-danger-600);
    --success-color: var(--sl-color-success-600);

    display: inline-block;
  }

  .copy-button__button {
    flex: 0 0 auto;
    display: flex;
    align-items: center;
    background: none;
    border: none;
    border-radius: var(--sl-border-radius-medium);
    font-size: inherit;
    color: inherit;
    padding: var(--sl-spacing-x-small);
    cursor: pointer;
    transition: var(--sl-transition-x-fast) color;
  }

  .copy-button--success .copy-button__button {
    color: var(--success-color);
  }

  .copy-button--error .copy-button__button {
    color: var(--error-color);
  }

  .copy-button__button:focus-visible {
    outline: var(--sl-focus-ring);
    outline-offset: var(--sl-focus-ring-offset);
  }

  .copy-button__button[disabled] {
    opacity: 0.5;
    cursor: not-allowed !important;
  }

  slot {
    display: inline-flex;
  }
`, SlCopyButton = class extends ShoelaceElement {
  constructor() {
    super(...arguments), this.localize = new LocalizeController(this), this.isCopying = !1, this.status = "rest", this.value = "", this.from = "", this.disabled = !1, this.copyLabel = "", this.successLabel = "", this.errorLabel = "", this.feedbackDuration = 1e3, this.tooltipPlacement = "top", this.hoist = !1;
  }
  async handleCopy() {
    if (this.disabled || this.isCopying)
      return;
    this.isCopying = !0;
    let z = this.value;
    if (this.from) {
      const D = this.getRootNode(), O = this.from.includes("."), F = this.from.includes("[") && this.from.includes("]");
      let U = this.from, W = "";
      O ? [U, W] = this.from.trim().split(".") : F && ([U, W] = this.from.trim().replace(/\]$/, "").split("["));
      const B = "getElementById" in D ? D.getElementById(U) : null;
      B ? F ? z = B.getAttribute(W) || "" : O ? z = B[W] || "" : z = B.textContent || "" : (this.showStatus("error"), this.emit("sl-error"));
    }
    if (!z)
      this.showStatus("error"), this.emit("sl-error");
    else
      try {
        await navigator.clipboard.writeText(z), this.showStatus("success"), this.emit("sl-copy", {
          detail: {
            value: z
          }
        });
      } catch {
        this.showStatus("error"), this.emit("sl-error");
      }
  }
  async showStatus(z) {
    const D = this.copyLabel || this.localize.term("copy"), O = this.successLabel || this.localize.term("copied"), F = this.errorLabel || this.localize.term("error"), U = z === "success" ? this.successIcon : this.errorIcon, W = getAnimation(this, "copy.in", { dir: "ltr" }), B = getAnimation(this, "copy.out", { dir: "ltr" });
    this.tooltip.content = z === "success" ? O : F, await this.copyIcon.animate(B.keyframes, B.options).finished, this.copyIcon.hidden = !0, this.status = z, U.hidden = !1, await U.animate(W.keyframes, W.options).finished, setTimeout(async () => {
      await U.animate(B.keyframes, B.options).finished, U.hidden = !0, this.status = "rest", this.copyIcon.hidden = !1, await this.copyIcon.animate(W.keyframes, W.options).finished, this.tooltip.content = D, this.isCopying = !1;
    }, this.feedbackDuration);
  }
  render() {
    const z = this.copyLabel || this.localize.term("copy");
    return x`
      <sl-tooltip
        class=${e$2({
      "copy-button": !0,
      "copy-button--success": this.status === "success",
      "copy-button--error": this.status === "error"
    })}
        content=${z}
        placement=${this.tooltipPlacement}
        ?disabled=${this.disabled}
        ?hoist=${this.hoist}
        exportparts="
          base:tooltip__base,
          base__popup:tooltip__base__popup,
          base__arrow:tooltip__base__arrow,
          body:tooltip__body
        "
      >
        <button
          class="copy-button__button"
          part="button"
          type="button"
          ?disabled=${this.disabled}
          @click=${this.handleCopy}
        >
          <slot part="copy-icon" name="copy-icon">
            <sl-icon library="system" name="copy"></sl-icon>
          </slot>
          <slot part="success-icon" name="success-icon" hidden>
            <sl-icon library="system" name="check"></sl-icon>
          </slot>
          <slot part="error-icon" name="error-icon" hidden>
            <sl-icon library="system" name="x-lg"></sl-icon>
          </slot>
        </button>
      </sl-tooltip>
    `;
  }
};
SlCopyButton.styles = [component_styles_default, copy_button_styles_default];
SlCopyButton.dependencies = {
  "sl-icon": SlIcon,
  "sl-tooltip": SlTooltip
};
__decorateClass([
  e$b('slot[name="copy-icon"]')
], SlCopyButton.prototype, "copyIcon", 2);
__decorateClass([
  e$b('slot[name="success-icon"]')
], SlCopyButton.prototype, "successIcon", 2);
__decorateClass([
  e$b('slot[name="error-icon"]')
], SlCopyButton.prototype, "errorIcon", 2);
__decorateClass([
  e$b("sl-tooltip")
], SlCopyButton.prototype, "tooltip", 2);
__decorateClass([
  r$4()
], SlCopyButton.prototype, "isCopying", 2);
__decorateClass([
  r$4()
], SlCopyButton.prototype, "status", 2);
__decorateClass([
  n$6()
], SlCopyButton.prototype, "value", 2);
__decorateClass([
  n$6()
], SlCopyButton.prototype, "from", 2);
__decorateClass([
  n$6({ type: Boolean, reflect: !0 })
], SlCopyButton.prototype, "disabled", 2);
__decorateClass([
  n$6({ attribute: "copy-label" })
], SlCopyButton.prototype, "copyLabel", 2);
__decorateClass([
  n$6({ attribute: "success-label" })
], SlCopyButton.prototype, "successLabel", 2);
__decorateClass([
  n$6({ attribute: "error-label" })
], SlCopyButton.prototype, "errorLabel", 2);
__decorateClass([
  n$6({ attribute: "feedback-duration", type: Number })
], SlCopyButton.prototype, "feedbackDuration", 2);
__decorateClass([
  n$6({ attribute: "tooltip-placement" })
], SlCopyButton.prototype, "tooltipPlacement", 2);
__decorateClass([
  n$6({ type: Boolean })
], SlCopyButton.prototype, "hoist", 2);
setDefaultAnimation("copy.in", {
  keyframes: [
    { scale: ".25", opacity: ".25" },
    { scale: "1", opacity: "1" }
  ],
  options: { duration: 100 }
});
setDefaultAnimation("copy.out", {
  keyframes: [
    { scale: "1", opacity: "1" },
    { scale: ".25", opacity: "0" }
  ],
  options: { duration: 100 }
});
SlCopyButton.define("sl-copy-button");
var drawer_styles_default = i$7`
  :host {
    --size: 25rem;
    --header-spacing: var(--sl-spacing-large);
    --body-spacing: var(--sl-spacing-large);
    --footer-spacing: var(--sl-spacing-large);

    display: contents;
  }

  .drawer {
    top: 0;
    inset-inline-start: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
    overflow: hidden;
  }

  .drawer--contained {
    position: absolute;
    z-index: initial;
  }

  .drawer--fixed {
    position: fixed;
    z-index: var(--sl-z-index-drawer);
  }

  .drawer__panel {
    position: absolute;
    display: flex;
    flex-direction: column;
    z-index: 2;
    max-width: 100%;
    max-height: 100%;
    background-color: var(--sl-panel-background-color);
    box-shadow: var(--sl-shadow-x-large);
    overflow: auto;
    pointer-events: all;
  }

  .drawer__panel:focus {
    outline: none;
  }

  .drawer--top .drawer__panel {
    top: 0;
    inset-inline-end: auto;
    bottom: auto;
    inset-inline-start: 0;
    width: 100%;
    height: var(--size);
  }

  .drawer--end .drawer__panel {
    top: 0;
    inset-inline-end: 0;
    bottom: auto;
    inset-inline-start: auto;
    width: var(--size);
    height: 100%;
  }

  .drawer--bottom .drawer__panel {
    top: auto;
    inset-inline-end: auto;
    bottom: 0;
    inset-inline-start: 0;
    width: 100%;
    height: var(--size);
  }

  .drawer--start .drawer__panel {
    top: 0;
    inset-inline-end: auto;
    bottom: auto;
    inset-inline-start: 0;
    width: var(--size);
    height: 100%;
  }

  .drawer__header {
    display: flex;
  }

  .drawer__title {
    flex: 1 1 auto;
    font: inherit;
    font-size: var(--sl-font-size-large);
    line-height: var(--sl-line-height-dense);
    padding: var(--header-spacing);
    margin: 0;
  }

  .drawer__header-actions {
    flex-shrink: 0;
    display: flex;
    flex-wrap: wrap;
    justify-content: end;
    gap: var(--sl-spacing-2x-small);
    padding: 0 var(--header-spacing);
  }

  .drawer__header-actions sl-icon-button,
  .drawer__header-actions ::slotted(sl-icon-button) {
    flex: 0 0 auto;
    display: flex;
    align-items: center;
    font-size: var(--sl-font-size-medium);
  }

  .drawer__body {
    flex: 1 1 auto;
    display: block;
    padding: var(--body-spacing);
    overflow: auto;
    -webkit-overflow-scrolling: touch;
  }

  .drawer__footer {
    text-align: right;
    padding: var(--footer-spacing);
  }

  .drawer__footer ::slotted(sl-button:not(:last-of-type)) {
    margin-inline-end: var(--sl-spacing-x-small);
  }

  .drawer:not(.drawer--has-footer) .drawer__footer {
    display: none;
  }

  .drawer__overlay {
    display: block;
    position: fixed;
    top: 0;
    right: 0;
    bottom: 0;
    left: 0;
    background-color: var(--sl-overlay-background-color);
    pointer-events: all;
  }

  .drawer--contained .drawer__overlay {
    display: none;
  }

  @media (forced-colors: active) {
    .drawer__panel {
      border: solid 1px var(--sl-color-neutral-0);
    }
  }
`;
function* activeElements(z = document.activeElement) {
  z != null && (yield z, "shadowRoot" in z && z.shadowRoot && z.shadowRoot.mode !== "closed" && (yield* __yieldStar(activeElements(z.shadowRoot.activeElement))));
}
function getDeepestActiveElement() {
  return [...activeElements()].pop();
}
var activeModals = [], Modal = class {
  constructor(z) {
    this.tabDirection = "forward", this.handleFocusIn = () => {
      this.isActive() && this.checkFocus();
    }, this.handleKeyDown = (D) => {
      var O;
      if (D.key !== "Tab" || this.isExternalActivated || !this.isActive())
        return;
      const F = getDeepestActiveElement();
      if (this.previousFocus = F, this.previousFocus && this.possiblyHasTabbableChildren(this.previousFocus))
        return;
      D.shiftKey ? this.tabDirection = "backward" : this.tabDirection = "forward";
      const U = getTabbableElements(this.element);
      let W = U.findIndex((K) => K === F);
      this.previousFocus = this.currentFocus;
      const B = this.tabDirection === "forward" ? 1 : -1;
      for (; ; ) {
        W + B >= U.length ? W = 0 : W + B < 0 ? W = U.length - 1 : W += B, this.previousFocus = this.currentFocus;
        const K = (
          /** @type {HTMLElement} */
          U[W]
        );
        if (this.tabDirection === "backward" && this.previousFocus && this.possiblyHasTabbableChildren(this.previousFocus) || K && this.possiblyHasTabbableChildren(K))
          return;
        D.preventDefault(), this.currentFocus = K, (O = this.currentFocus) == null || O.focus({ preventScroll: !1 });
        const X = [...activeElements()];
        if (X.includes(this.currentFocus) || !X.includes(this.previousFocus))
          break;
      }
      setTimeout(() => this.checkFocus());
    }, this.handleKeyUp = () => {
      this.tabDirection = "forward";
    }, this.element = z, this.elementsWithTabbableControls = ["iframe"];
  }
  /** Activates focus trapping. */
  activate() {
    activeModals.push(this.element), document.addEventListener("focusin", this.handleFocusIn), document.addEventListener("keydown", this.handleKeyDown), document.addEventListener("keyup", this.handleKeyUp);
  }
  /** Deactivates focus trapping. */
  deactivate() {
    activeModals = activeModals.filter((z) => z !== this.element), this.currentFocus = null, document.removeEventListener("focusin", this.handleFocusIn), document.removeEventListener("keydown", this.handleKeyDown), document.removeEventListener("keyup", this.handleKeyUp);
  }
  /** Determines if this modal element is currently active or not. */
  isActive() {
    return activeModals[activeModals.length - 1] === this.element;
  }
  /** Activates external modal behavior and temporarily disables focus trapping. */
  activateExternal() {
    this.isExternalActivated = !0;
  }
  /** Deactivates external modal behavior and re-enables focus trapping. */
  deactivateExternal() {
    this.isExternalActivated = !1;
  }
  checkFocus() {
    if (this.isActive() && !this.isExternalActivated) {
      const z = getTabbableElements(this.element);
      if (!this.element.matches(":focus-within")) {
        const D = z[0], O = z[z.length - 1], F = this.tabDirection === "forward" ? D : O;
        typeof (F == null ? void 0 : F.focus) == "function" && (this.currentFocus = F, F.focus({ preventScroll: !1 }));
      }
    }
  }
  possiblyHasTabbableChildren(z) {
    return this.elementsWithTabbableControls.includes(z.tagName.toLowerCase()) || z.hasAttribute("controls");
  }
};
function uppercaseFirstLetter(z) {
  return z.charAt(0).toUpperCase() + z.slice(1);
}
var SlDrawer = class extends ShoelaceElement {
  constructor() {
    super(...arguments), this.hasSlotController = new HasSlotController(this, "footer"), this.localize = new LocalizeController(this), this.modal = new Modal(this), this.open = !1, this.label = "", this.placement = "end", this.contained = !1, this.noHeader = !1, this.handleDocumentKeyDown = (z) => {
      this.contained || z.key === "Escape" && this.modal.isActive() && this.open && (z.stopImmediatePropagation(), this.requestClose("keyboard"));
    };
  }
  firstUpdated() {
    this.drawer.hidden = !this.open, this.open && (this.addOpenListeners(), this.contained || (this.modal.activate(), lockBodyScrolling(this)));
  }
  disconnectedCallback() {
    var z;
    super.disconnectedCallback(), unlockBodyScrolling(this), (z = this.closeWatcher) == null || z.destroy();
  }
  requestClose(z) {
    if (this.emit("sl-request-close", {
      cancelable: !0,
      detail: { source: z }
    }).defaultPrevented) {
      const O = getAnimation(this, "drawer.denyClose", { dir: this.localize.dir() });
      animateTo(this.panel, O.keyframes, O.options);
      return;
    }
    this.hide();
  }
  addOpenListeners() {
    var z;
    "CloseWatcher" in window ? ((z = this.closeWatcher) == null || z.destroy(), this.contained || (this.closeWatcher = new CloseWatcher(), this.closeWatcher.onclose = () => this.requestClose("keyboard"))) : document.addEventListener("keydown", this.handleDocumentKeyDown);
  }
  removeOpenListeners() {
    var z;
    document.removeEventListener("keydown", this.handleDocumentKeyDown), (z = this.closeWatcher) == null || z.destroy();
  }
  async handleOpenChange() {
    if (this.open) {
      this.emit("sl-show"), this.addOpenListeners(), this.originalTrigger = document.activeElement, this.contained || (this.modal.activate(), lockBodyScrolling(this));
      const z = this.querySelector("[autofocus]");
      z && z.removeAttribute("autofocus"), await Promise.all([stopAnimations(this.drawer), stopAnimations(this.overlay)]), this.drawer.hidden = !1, requestAnimationFrame(() => {
        this.emit("sl-initial-focus", { cancelable: !0 }).defaultPrevented || (z ? z.focus({ preventScroll: !0 }) : this.panel.focus({ preventScroll: !0 })), z && z.setAttribute("autofocus", "");
      });
      const D = getAnimation(this, `drawer.show${uppercaseFirstLetter(this.placement)}`, {
        dir: this.localize.dir()
      }), O = getAnimation(this, "drawer.overlay.show", { dir: this.localize.dir() });
      await Promise.all([
        animateTo(this.panel, D.keyframes, D.options),
        animateTo(this.overlay, O.keyframes, O.options)
      ]), this.emit("sl-after-show");
    } else {
      this.emit("sl-hide"), this.removeOpenListeners(), this.contained || (this.modal.deactivate(), unlockBodyScrolling(this)), await Promise.all([stopAnimations(this.drawer), stopAnimations(this.overlay)]);
      const z = getAnimation(this, `drawer.hide${uppercaseFirstLetter(this.placement)}`, {
        dir: this.localize.dir()
      }), D = getAnimation(this, "drawer.overlay.hide", { dir: this.localize.dir() });
      await Promise.all([
        animateTo(this.overlay, D.keyframes, D.options).then(() => {
          this.overlay.hidden = !0;
        }),
        animateTo(this.panel, z.keyframes, z.options).then(() => {
          this.panel.hidden = !0;
        })
      ]), this.drawer.hidden = !0, this.overlay.hidden = !1, this.panel.hidden = !1;
      const O = this.originalTrigger;
      typeof (O == null ? void 0 : O.focus) == "function" && setTimeout(() => O.focus()), this.emit("sl-after-hide");
    }
  }
  handleNoModalChange() {
    this.open && !this.contained && (this.modal.activate(), lockBodyScrolling(this)), this.open && this.contained && (this.modal.deactivate(), unlockBodyScrolling(this));
  }
  /** Shows the drawer. */
  async show() {
    if (!this.open)
      return this.open = !0, waitForEvent(this, "sl-after-show");
  }
  /** Hides the drawer */
  async hide() {
    if (this.open)
      return this.open = !1, waitForEvent(this, "sl-after-hide");
  }
  render() {
    return x`
      <div
        part="base"
        class=${e$2({
      drawer: !0,
      "drawer--open": this.open,
      "drawer--top": this.placement === "top",
      "drawer--end": this.placement === "end",
      "drawer--bottom": this.placement === "bottom",
      "drawer--start": this.placement === "start",
      "drawer--contained": this.contained,
      "drawer--fixed": !this.contained,
      "drawer--rtl": this.localize.dir() === "rtl",
      "drawer--has-footer": this.hasSlotController.test("footer")
    })}
      >
        <div part="overlay" class="drawer__overlay" @click=${() => this.requestClose("overlay")} tabindex="-1"></div>

        <div
          part="panel"
          class="drawer__panel"
          role="dialog"
          aria-modal="true"
          aria-hidden=${this.open ? "false" : "true"}
          aria-label=${o$6(this.noHeader ? this.label : void 0)}
          aria-labelledby=${o$6(this.noHeader ? void 0 : "title")}
          tabindex="0"
        >
          ${this.noHeader ? "" : x`
                <header part="header" class="drawer__header">
                  <h2 part="title" class="drawer__title" id="title">
                    <!-- If there's no label, use an invisible character to prevent the header from collapsing -->
                    <slot name="label"> ${this.label.length > 0 ? this.label : "\uFEFF"} </slot>
                  </h2>
                  <div part="header-actions" class="drawer__header-actions">
                    <slot name="header-actions"></slot>
                    <sl-icon-button
                      part="close-button"
                      exportparts="base:close-button__base"
                      class="drawer__close"
                      name="x-lg"
                      label=${this.localize.term("close")}
                      library="system"
                      @click=${() => this.requestClose("close-button")}
                    ></sl-icon-button>
                  </div>
                </header>
              `}

          <slot part="body" class="drawer__body"></slot>

          <footer part="footer" class="drawer__footer">
            <slot name="footer"></slot>
          </footer>
        </div>
      </div>
    `;
  }
};
SlDrawer.styles = [component_styles_default, drawer_styles_default];
SlDrawer.dependencies = { "sl-icon-button": SlIconButton };
__decorateClass([
  e$b(".drawer")
], SlDrawer.prototype, "drawer", 2);
__decorateClass([
  e$b(".drawer__panel")
], SlDrawer.prototype, "panel", 2);
__decorateClass([
  e$b(".drawer__overlay")
], SlDrawer.prototype, "overlay", 2);
__decorateClass([
  n$6({ type: Boolean, reflect: !0 })
], SlDrawer.prototype, "open", 2);
__decorateClass([
  n$6({ reflect: !0 })
], SlDrawer.prototype, "label", 2);
__decorateClass([
  n$6({ reflect: !0 })
], SlDrawer.prototype, "placement", 2);
__decorateClass([
  n$6({ type: Boolean, reflect: !0 })
], SlDrawer.prototype, "contained", 2);
__decorateClass([
  n$6({ attribute: "no-header", type: Boolean, reflect: !0 })
], SlDrawer.prototype, "noHeader", 2);
__decorateClass([
  watch("open", { waitUntilFirstUpdate: !0 })
], SlDrawer.prototype, "handleOpenChange", 1);
__decorateClass([
  watch("contained", { waitUntilFirstUpdate: !0 })
], SlDrawer.prototype, "handleNoModalChange", 1);
setDefaultAnimation("drawer.showTop", {
  keyframes: [
    { opacity: 0, translate: "0 -100%" },
    { opacity: 1, translate: "0 0" }
  ],
  options: { duration: 250, easing: "ease" }
});
setDefaultAnimation("drawer.hideTop", {
  keyframes: [
    { opacity: 1, translate: "0 0" },
    { opacity: 0, translate: "0 -100%" }
  ],
  options: { duration: 250, easing: "ease" }
});
setDefaultAnimation("drawer.showEnd", {
  keyframes: [
    { opacity: 0, translate: "100%" },
    { opacity: 1, translate: "0" }
  ],
  rtlKeyframes: [
    { opacity: 0, translate: "-100%" },
    { opacity: 1, translate: "0" }
  ],
  options: { duration: 250, easing: "ease" }
});
setDefaultAnimation("drawer.hideEnd", {
  keyframes: [
    { opacity: 1, translate: "0" },
    { opacity: 0, translate: "100%" }
  ],
  rtlKeyframes: [
    { opacity: 1, translate: "0" },
    { opacity: 0, translate: "-100%" }
  ],
  options: { duration: 250, easing: "ease" }
});
setDefaultAnimation("drawer.showBottom", {
  keyframes: [
    { opacity: 0, translate: "0 100%" },
    { opacity: 1, translate: "0 0" }
  ],
  options: { duration: 250, easing: "ease" }
});
setDefaultAnimation("drawer.hideBottom", {
  keyframes: [
    { opacity: 1, translate: "0 0" },
    { opacity: 0, translate: "0 100%" }
  ],
  options: { duration: 250, easing: "ease" }
});
setDefaultAnimation("drawer.showStart", {
  keyframes: [
    { opacity: 0, translate: "-100%" },
    { opacity: 1, translate: "0" }
  ],
  rtlKeyframes: [
    { opacity: 0, translate: "100%" },
    { opacity: 1, translate: "0" }
  ],
  options: { duration: 250, easing: "ease" }
});
setDefaultAnimation("drawer.hideStart", {
  keyframes: [
    { opacity: 1, translate: "0" },
    { opacity: 0, translate: "-100%" }
  ],
  rtlKeyframes: [
    { opacity: 1, translate: "0" },
    { opacity: 0, translate: "100%" }
  ],
  options: { duration: 250, easing: "ease" }
});
setDefaultAnimation("drawer.denyClose", {
  keyframes: [{ scale: 1 }, { scale: 1.01 }, { scale: 1 }],
  options: { duration: 250 }
});
setDefaultAnimation("drawer.overlay.show", {
  keyframes: [{ opacity: 0 }, { opacity: 1 }],
  options: { duration: 250 }
});
setDefaultAnimation("drawer.overlay.hide", {
  keyframes: [{ opacity: 1 }, { opacity: 0 }],
  options: { duration: 250 }
});
SlDrawer.define("sl-drawer");
var SlFormatBytes = class extends ShoelaceElement {
  constructor() {
    super(...arguments), this.localize = new LocalizeController(this), this.value = 0, this.unit = "byte", this.display = "short";
  }
  render() {
    if (isNaN(this.value))
      return "";
    const z = ["", "kilo", "mega", "giga", "tera"], D = ["", "kilo", "mega", "giga", "tera", "peta"], O = this.unit === "bit" ? z : D, F = Math.max(0, Math.min(Math.floor(Math.log10(this.value) / 3), O.length - 1)), U = O[F] + this.unit, W = parseFloat((this.value / Math.pow(1e3, F)).toPrecision(3));
    return this.localize.number(W, {
      style: "unit",
      unit: U,
      unitDisplay: this.display
    });
  }
};
__decorateClass([
  n$6({ type: Number })
], SlFormatBytes.prototype, "value", 2);
__decorateClass([
  n$6()
], SlFormatBytes.prototype, "unit", 2);
__decorateClass([
  n$6()
], SlFormatBytes.prototype, "display", 2);
SlFormatBytes.define("sl-format-bytes");
var details_styles_default = i$7`
  :host {
    display: block;
  }

  .details {
    border: solid 1px var(--sl-color-neutral-200);
    border-radius: var(--sl-border-radius-medium);
    background-color: var(--sl-color-neutral-0);
    overflow-anchor: none;
  }

  .details--disabled {
    opacity: 0.5;
  }

  .details__header {
    display: flex;
    align-items: center;
    border-radius: inherit;
    padding: var(--sl-spacing-medium);
    user-select: none;
    -webkit-user-select: none;
    cursor: pointer;
  }

  .details__header::-webkit-details-marker {
    display: none;
  }

  .details__header:focus {
    outline: none;
  }

  .details__header:focus-visible {
    outline: var(--sl-focus-ring);
    outline-offset: calc(1px + var(--sl-focus-ring-offset));
  }

  .details--disabled .details__header {
    cursor: not-allowed;
  }

  .details--disabled .details__header:focus-visible {
    outline: none;
    box-shadow: none;
  }

  .details__summary {
    flex: 1 1 auto;
    display: flex;
    align-items: center;
  }

  .details__summary-icon {
    flex: 0 0 auto;
    display: flex;
    align-items: center;
    transition: var(--sl-transition-medium) rotate ease;
  }

  .details--open .details__summary-icon {
    rotate: 90deg;
  }

  .details--open.details--rtl .details__summary-icon {
    rotate: -90deg;
  }

  .details--open slot[name='expand-icon'],
  .details:not(.details--open) slot[name='collapse-icon'] {
    display: none;
  }

  .details__body {
    overflow: hidden;
  }

  .details__content {
    display: block;
    padding: var(--sl-spacing-medium);
  }
`, SlDetails = class extends ShoelaceElement {
  constructor() {
    super(...arguments), this.localize = new LocalizeController(this), this.open = !1, this.disabled = !1;
  }
  firstUpdated() {
    this.body.style.height = this.open ? "auto" : "0", this.open && (this.details.open = !0), this.detailsObserver = new MutationObserver((z) => {
      for (const D of z)
        D.type === "attributes" && D.attributeName === "open" && (this.details.open ? this.show() : this.hide());
    }), this.detailsObserver.observe(this.details, { attributes: !0 });
  }
  disconnectedCallback() {
    super.disconnectedCallback(), this.detailsObserver.disconnect();
  }
  handleSummaryClick(z) {
    z.preventDefault(), this.disabled || (this.open ? this.hide() : this.show(), this.header.focus());
  }
  handleSummaryKeyDown(z) {
    (z.key === "Enter" || z.key === " ") && (z.preventDefault(), this.open ? this.hide() : this.show()), (z.key === "ArrowUp" || z.key === "ArrowLeft") && (z.preventDefault(), this.hide()), (z.key === "ArrowDown" || z.key === "ArrowRight") && (z.preventDefault(), this.show());
  }
  async handleOpenChange() {
    if (this.open) {
      if (this.details.open = !0, this.emit("sl-show", { cancelable: !0 }).defaultPrevented) {
        this.open = !1, this.details.open = !1;
        return;
      }
      await stopAnimations(this.body);
      const { keyframes: D, options: O } = getAnimation(this, "details.show", { dir: this.localize.dir() });
      await animateTo(this.body, shimKeyframesHeightAuto(D, this.body.scrollHeight), O), this.body.style.height = "auto", this.emit("sl-after-show");
    } else {
      if (this.emit("sl-hide", { cancelable: !0 }).defaultPrevented) {
        this.details.open = !0, this.open = !0;
        return;
      }
      await stopAnimations(this.body);
      const { keyframes: D, options: O } = getAnimation(this, "details.hide", { dir: this.localize.dir() });
      await animateTo(this.body, shimKeyframesHeightAuto(D, this.body.scrollHeight), O), this.body.style.height = "auto", this.details.open = !1, this.emit("sl-after-hide");
    }
  }
  /** Shows the details. */
  async show() {
    if (!(this.open || this.disabled))
      return this.open = !0, waitForEvent(this, "sl-after-show");
  }
  /** Hides the details */
  async hide() {
    if (!(!this.open || this.disabled))
      return this.open = !1, waitForEvent(this, "sl-after-hide");
  }
  render() {
    const z = this.localize.dir() === "rtl";
    return x`
      <details
        part="base"
        class=${e$2({
      details: !0,
      "details--open": this.open,
      "details--disabled": this.disabled,
      "details--rtl": z
    })}
      >
        <summary
          part="header"
          id="header"
          class="details__header"
          role="button"
          aria-expanded=${this.open ? "true" : "false"}
          aria-controls="content"
          aria-disabled=${this.disabled ? "true" : "false"}
          tabindex=${this.disabled ? "-1" : "0"}
          @click=${this.handleSummaryClick}
          @keydown=${this.handleSummaryKeyDown}
        >
          <slot name="summary" part="summary" class="details__summary">${this.summary}</slot>

          <span part="summary-icon" class="details__summary-icon">
            <slot name="expand-icon">
              <sl-icon library="system" name=${z ? "chevron-left" : "chevron-right"}></sl-icon>
            </slot>
            <slot name="collapse-icon">
              <sl-icon library="system" name=${z ? "chevron-left" : "chevron-right"}></sl-icon>
            </slot>
          </span>
        </summary>

        <div class="details__body" role="region" aria-labelledby="header">
          <slot part="content" id="content" class="details__content"></slot>
        </div>
      </details>
    `;
  }
};
SlDetails.styles = [component_styles_default, details_styles_default];
SlDetails.dependencies = {
  "sl-icon": SlIcon
};
__decorateClass([
  e$b(".details")
], SlDetails.prototype, "details", 2);
__decorateClass([
  e$b(".details__header")
], SlDetails.prototype, "header", 2);
__decorateClass([
  e$b(".details__body")
], SlDetails.prototype, "body", 2);
__decorateClass([
  e$b(".details__expand-icon-slot")
], SlDetails.prototype, "expandIconSlot", 2);
__decorateClass([
  n$6({ type: Boolean, reflect: !0 })
], SlDetails.prototype, "open", 2);
__decorateClass([
  n$6()
], SlDetails.prototype, "summary", 2);
__decorateClass([
  n$6({ type: Boolean, reflect: !0 })
], SlDetails.prototype, "disabled", 2);
__decorateClass([
  watch("open", { waitUntilFirstUpdate: !0 })
], SlDetails.prototype, "handleOpenChange", 1);
setDefaultAnimation("details.show", {
  keyframes: [
    { height: "0", opacity: "0" },
    { height: "auto", opacity: "1" }
  ],
  options: { duration: 250, easing: "linear" }
});
setDefaultAnimation("details.hide", {
  keyframes: [
    { height: "auto", opacity: "1" },
    { height: "0", opacity: "0" }
  ],
  options: { duration: 250, easing: "linear" }
});
SlDetails.define("sl-details");
var divider_styles_default = i$7`
  :host {
    --color: var(--sl-panel-border-color);
    --width: var(--sl-panel-border-width);
    --spacing: var(--sl-spacing-medium);
  }

  :host(:not([vertical])) {
    display: block;
    border-top: solid var(--width) var(--color);
    margin: var(--spacing) 0;
  }

  :host([vertical]) {
    display: inline-block;
    height: 100%;
    border-left: solid var(--width) var(--color);
    margin: 0 var(--spacing);
  }
`, SlDivider = class extends ShoelaceElement {
  constructor() {
    super(...arguments), this.vertical = !1;
  }
  connectedCallback() {
    super.connectedCallback(), this.setAttribute("role", "separator");
  }
  handleVerticalChange() {
    this.setAttribute("aria-orientation", this.vertical ? "vertical" : "horizontal");
  }
};
SlDivider.styles = [component_styles_default, divider_styles_default];
__decorateClass([
  n$6({ type: Boolean, reflect: !0 })
], SlDivider.prototype, "vertical", 2);
__decorateClass([
  watch("vertical")
], SlDivider.prototype, "handleVerticalChange", 1);
SlDivider.define("sl-divider");
var dialog_styles_default = i$7`
  :host {
    --width: 31rem;
    --header-spacing: var(--sl-spacing-large);
    --body-spacing: var(--sl-spacing-large);
    --footer-spacing: var(--sl-spacing-large);

    display: contents;
  }

  .dialog {
    display: flex;
    align-items: center;
    justify-content: center;
    position: fixed;
    top: 0;
    right: 0;
    bottom: 0;
    left: 0;
    z-index: var(--sl-z-index-dialog);
  }

  .dialog__panel {
    display: flex;
    flex-direction: column;
    z-index: 2;
    width: var(--width);
    max-width: calc(100% - var(--sl-spacing-2x-large));
    max-height: calc(100% - var(--sl-spacing-2x-large));
    background-color: var(--sl-panel-background-color);
    border-radius: var(--sl-border-radius-medium);
    box-shadow: var(--sl-shadow-x-large);
  }

  .dialog__panel:focus {
    outline: none;
  }

  /* Ensure there's enough vertical padding for phones that don't update vh when chrome appears (e.g. iPhone) */
  @media screen and (max-width: 420px) {
    .dialog__panel {
      max-height: 80vh;
    }
  }

  .dialog--open .dialog__panel {
    display: flex;
    opacity: 1;
  }

  .dialog__header {
    flex: 0 0 auto;
    display: flex;
  }

  .dialog__title {
    flex: 1 1 auto;
    font: inherit;
    font-size: var(--sl-font-size-large);
    line-height: var(--sl-line-height-dense);
    padding: var(--header-spacing);
    margin: 0;
  }

  .dialog__header-actions {
    flex-shrink: 0;
    display: flex;
    flex-wrap: wrap;
    justify-content: end;
    gap: var(--sl-spacing-2x-small);
    padding: 0 var(--header-spacing);
  }

  .dialog__header-actions sl-icon-button,
  .dialog__header-actions ::slotted(sl-icon-button) {
    flex: 0 0 auto;
    display: flex;
    align-items: center;
    font-size: var(--sl-font-size-medium);
  }

  .dialog__body {
    flex: 1 1 auto;
    display: block;
    padding: var(--body-spacing);
    overflow: auto;
    -webkit-overflow-scrolling: touch;
  }

  .dialog__footer {
    flex: 0 0 auto;
    text-align: right;
    padding: var(--footer-spacing);
  }

  .dialog__footer ::slotted(sl-button:not(:first-of-type)) {
    margin-inline-start: var(--sl-spacing-x-small);
  }

  .dialog:not(.dialog--has-footer) .dialog__footer {
    display: none;
  }

  .dialog__overlay {
    position: fixed;
    top: 0;
    right: 0;
    bottom: 0;
    left: 0;
    background-color: var(--sl-overlay-background-color);
  }

  @media (forced-colors: active) {
    .dialog__panel {
      border: solid 1px var(--sl-color-neutral-0);
    }
  }
`, SlDialog = class extends ShoelaceElement {
  constructor() {
    super(...arguments), this.hasSlotController = new HasSlotController(this, "footer"), this.localize = new LocalizeController(this), this.modal = new Modal(this), this.open = !1, this.label = "", this.noHeader = !1, this.handleDocumentKeyDown = (z) => {
      z.key === "Escape" && this.modal.isActive() && this.open && (z.stopPropagation(), this.requestClose("keyboard"));
    };
  }
  firstUpdated() {
    this.dialog.hidden = !this.open, this.open && (this.addOpenListeners(), this.modal.activate(), lockBodyScrolling(this));
  }
  disconnectedCallback() {
    var z;
    super.disconnectedCallback(), this.modal.deactivate(), unlockBodyScrolling(this), (z = this.closeWatcher) == null || z.destroy();
  }
  requestClose(z) {
    if (this.emit("sl-request-close", {
      cancelable: !0,
      detail: { source: z }
    }).defaultPrevented) {
      const O = getAnimation(this, "dialog.denyClose", { dir: this.localize.dir() });
      animateTo(this.panel, O.keyframes, O.options);
      return;
    }
    this.hide();
  }
  addOpenListeners() {
    var z;
    "CloseWatcher" in window ? ((z = this.closeWatcher) == null || z.destroy(), this.closeWatcher = new CloseWatcher(), this.closeWatcher.onclose = () => this.requestClose("keyboard")) : document.addEventListener("keydown", this.handleDocumentKeyDown);
  }
  removeOpenListeners() {
    var z;
    (z = this.closeWatcher) == null || z.destroy(), document.removeEventListener("keydown", this.handleDocumentKeyDown);
  }
  async handleOpenChange() {
    if (this.open) {
      this.emit("sl-show"), this.addOpenListeners(), this.originalTrigger = document.activeElement, this.modal.activate(), lockBodyScrolling(this);
      const z = this.querySelector("[autofocus]");
      z && z.removeAttribute("autofocus"), await Promise.all([stopAnimations(this.dialog), stopAnimations(this.overlay)]), this.dialog.hidden = !1, requestAnimationFrame(() => {
        this.emit("sl-initial-focus", { cancelable: !0 }).defaultPrevented || (z ? z.focus({ preventScroll: !0 }) : this.panel.focus({ preventScroll: !0 })), z && z.setAttribute("autofocus", "");
      });
      const D = getAnimation(this, "dialog.show", { dir: this.localize.dir() }), O = getAnimation(this, "dialog.overlay.show", { dir: this.localize.dir() });
      await Promise.all([
        animateTo(this.panel, D.keyframes, D.options),
        animateTo(this.overlay, O.keyframes, O.options)
      ]), this.emit("sl-after-show");
    } else {
      this.emit("sl-hide"), this.removeOpenListeners(), this.modal.deactivate(), await Promise.all([stopAnimations(this.dialog), stopAnimations(this.overlay)]);
      const z = getAnimation(this, "dialog.hide", { dir: this.localize.dir() }), D = getAnimation(this, "dialog.overlay.hide", { dir: this.localize.dir() });
      await Promise.all([
        animateTo(this.overlay, D.keyframes, D.options).then(() => {
          this.overlay.hidden = !0;
        }),
        animateTo(this.panel, z.keyframes, z.options).then(() => {
          this.panel.hidden = !0;
        })
      ]), this.dialog.hidden = !0, this.overlay.hidden = !1, this.panel.hidden = !1, unlockBodyScrolling(this);
      const O = this.originalTrigger;
      typeof (O == null ? void 0 : O.focus) == "function" && setTimeout(() => O.focus()), this.emit("sl-after-hide");
    }
  }
  /** Shows the dialog. */
  async show() {
    if (!this.open)
      return this.open = !0, waitForEvent(this, "sl-after-show");
  }
  /** Hides the dialog */
  async hide() {
    if (this.open)
      return this.open = !1, waitForEvent(this, "sl-after-hide");
  }
  render() {
    return x`
      <div
        part="base"
        class=${e$2({
      dialog: !0,
      "dialog--open": this.open,
      "dialog--has-footer": this.hasSlotController.test("footer")
    })}
      >
        <div part="overlay" class="dialog__overlay" @click=${() => this.requestClose("overlay")} tabindex="-1"></div>

        <div
          part="panel"
          class="dialog__panel"
          role="dialog"
          aria-modal="true"
          aria-hidden=${this.open ? "false" : "true"}
          aria-label=${o$6(this.noHeader ? this.label : void 0)}
          aria-labelledby=${o$6(this.noHeader ? void 0 : "title")}
          tabindex="-1"
        >
          ${this.noHeader ? "" : x`
                <header part="header" class="dialog__header">
                  <h2 part="title" class="dialog__title" id="title">
                    <slot name="label"> ${this.label.length > 0 ? this.label : "\uFEFF"} </slot>
                  </h2>
                  <div part="header-actions" class="dialog__header-actions">
                    <slot name="header-actions"></slot>
                    <sl-icon-button
                      part="close-button"
                      exportparts="base:close-button__base"
                      class="dialog__close"
                      name="x-lg"
                      label=${this.localize.term("close")}
                      library="system"
                      @click="${() => this.requestClose("close-button")}"
                    ></sl-icon-button>
                  </div>
                </header>
              `}
          ${""}
          <div part="body" class="dialog__body" tabindex="-1"><slot></slot></div>

          <footer part="footer" class="dialog__footer">
            <slot name="footer"></slot>
          </footer>
        </div>
      </div>
    `;
  }
};
SlDialog.styles = [component_styles_default, dialog_styles_default];
SlDialog.dependencies = {
  "sl-icon-button": SlIconButton
};
__decorateClass([
  e$b(".dialog")
], SlDialog.prototype, "dialog", 2);
__decorateClass([
  e$b(".dialog__panel")
], SlDialog.prototype, "panel", 2);
__decorateClass([
  e$b(".dialog__overlay")
], SlDialog.prototype, "overlay", 2);
__decorateClass([
  n$6({ type: Boolean, reflect: !0 })
], SlDialog.prototype, "open", 2);
__decorateClass([
  n$6({ reflect: !0 })
], SlDialog.prototype, "label", 2);
__decorateClass([
  n$6({ attribute: "no-header", type: Boolean, reflect: !0 })
], SlDialog.prototype, "noHeader", 2);
__decorateClass([
  watch("open", { waitUntilFirstUpdate: !0 })
], SlDialog.prototype, "handleOpenChange", 1);
setDefaultAnimation("dialog.show", {
  keyframes: [
    { opacity: 0, scale: 0.8 },
    { opacity: 1, scale: 1 }
  ],
  options: { duration: 250, easing: "ease" }
});
setDefaultAnimation("dialog.hide", {
  keyframes: [
    { opacity: 1, scale: 1 },
    { opacity: 0, scale: 0.8 }
  ],
  options: { duration: 250, easing: "ease" }
});
setDefaultAnimation("dialog.denyClose", {
  keyframes: [{ scale: 1 }, { scale: 1.02 }, { scale: 1 }],
  options: { duration: 250 }
});
setDefaultAnimation("dialog.overlay.show", {
  keyframes: [{ opacity: 0 }, { opacity: 1 }],
  options: { duration: 250 }
});
setDefaultAnimation("dialog.overlay.hide", {
  keyframes: [{ opacity: 1 }, { opacity: 0 }],
  options: { duration: 250 }
});
SlDialog.define("sl-dialog");
SlCheckbox.define("sl-checkbox");
var color_picker_styles_default = i$7`
  :host {
    --grid-width: 280px;
    --grid-height: 200px;
    --grid-handle-size: 16px;
    --slider-height: 15px;
    --slider-handle-size: 17px;
    --swatch-size: 25px;

    display: inline-block;
  }

  .color-picker {
    width: var(--grid-width);
    font-family: var(--sl-font-sans);
    font-size: var(--sl-font-size-medium);
    font-weight: var(--sl-font-weight-normal);
    color: var(--color);
    background-color: var(--sl-panel-background-color);
    border-radius: var(--sl-border-radius-medium);
    user-select: none;
    -webkit-user-select: none;
  }

  .color-picker--inline {
    border: solid var(--sl-panel-border-width) var(--sl-panel-border-color);
  }

  .color-picker--inline:focus-visible {
    outline: var(--sl-focus-ring);
    outline-offset: var(--sl-focus-ring-offset);
  }

  .color-picker__grid {
    position: relative;
    height: var(--grid-height);
    background-image: linear-gradient(to bottom, rgba(0, 0, 0, 0) 0%, rgba(0, 0, 0, 1) 100%),
      linear-gradient(to right, #fff 0%, rgba(255, 255, 255, 0) 100%);
    border-top-left-radius: var(--sl-border-radius-medium);
    border-top-right-radius: var(--sl-border-radius-medium);
    cursor: crosshair;
    forced-color-adjust: none;
  }

  .color-picker__grid-handle {
    position: absolute;
    width: var(--grid-handle-size);
    height: var(--grid-handle-size);
    border-radius: 50%;
    box-shadow: 0 0 0 1px rgba(0, 0, 0, 0.25);
    border: solid 2px white;
    margin-top: calc(var(--grid-handle-size) / -2);
    margin-left: calc(var(--grid-handle-size) / -2);
    transition: var(--sl-transition-fast) scale;
  }

  .color-picker__grid-handle--dragging {
    cursor: none;
    scale: 1.5;
  }

  .color-picker__grid-handle:focus-visible {
    outline: var(--sl-focus-ring);
  }

  .color-picker__controls {
    padding: var(--sl-spacing-small);
    display: flex;
    align-items: center;
  }

  .color-picker__sliders {
    flex: 1 1 auto;
  }

  .color-picker__slider {
    position: relative;
    height: var(--slider-height);
    border-radius: var(--sl-border-radius-pill);
    box-shadow: inset 0 0 0 1px rgba(0, 0, 0, 0.2);
    forced-color-adjust: none;
  }

  .color-picker__slider:not(:last-of-type) {
    margin-bottom: var(--sl-spacing-small);
  }

  .color-picker__slider-handle {
    position: absolute;
    top: calc(50% - var(--slider-handle-size) / 2);
    width: var(--slider-handle-size);
    height: var(--slider-handle-size);
    background-color: white;
    border-radius: 50%;
    box-shadow: 0 0 0 1px rgba(0, 0, 0, 0.25);
    margin-left: calc(var(--slider-handle-size) / -2);
  }

  .color-picker__slider-handle:focus-visible {
    outline: var(--sl-focus-ring);
  }

  .color-picker__hue {
    background-image: linear-gradient(
      to right,
      rgb(255, 0, 0) 0%,
      rgb(255, 255, 0) 17%,
      rgb(0, 255, 0) 33%,
      rgb(0, 255, 255) 50%,
      rgb(0, 0, 255) 67%,
      rgb(255, 0, 255) 83%,
      rgb(255, 0, 0) 100%
    );
  }

  .color-picker__alpha .color-picker__alpha-gradient {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    border-radius: inherit;
  }

  .color-picker__preview {
    flex: 0 0 auto;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    position: relative;
    width: 2.25rem;
    height: 2.25rem;
    border: none;
    border-radius: var(--sl-border-radius-circle);
    background: none;
    margin-left: var(--sl-spacing-small);
    cursor: copy;
    forced-color-adjust: none;
  }

  .color-picker__preview:before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    border-radius: inherit;
    box-shadow: inset 0 0 0 1px rgba(0, 0, 0, 0.2);

    /* We use a custom property in lieu of currentColor because of https://bugs.webkit.org/show_bug.cgi?id=216780 */
    background-color: var(--preview-color);
  }

  .color-picker__preview:focus-visible {
    outline: var(--sl-focus-ring);
    outline-offset: var(--sl-focus-ring-offset);
  }

  .color-picker__preview-color {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    border: solid 1px rgba(0, 0, 0, 0.125);
  }

  .color-picker__preview-color--copied {
    animation: pulse 0.75s;
  }

  @keyframes pulse {
    0% {
      box-shadow: 0 0 0 0 var(--sl-color-primary-500);
    }
    70% {
      box-shadow: 0 0 0 0.5rem transparent;
    }
    100% {
      box-shadow: 0 0 0 0 transparent;
    }
  }

  .color-picker__user-input {
    display: flex;
    padding: 0 var(--sl-spacing-small) var(--sl-spacing-small) var(--sl-spacing-small);
  }

  .color-picker__user-input sl-input {
    min-width: 0; /* fix input width in Safari */
    flex: 1 1 auto;
  }

  .color-picker__user-input sl-button-group {
    margin-left: var(--sl-spacing-small);
  }

  .color-picker__user-input sl-button {
    min-width: 3.25rem;
    max-width: 3.25rem;
    font-size: 1rem;
  }

  .color-picker__swatches {
    display: grid;
    grid-template-columns: repeat(8, 1fr);
    grid-gap: 0.5rem;
    justify-items: center;
    border-top: solid 1px var(--sl-color-neutral-200);
    padding: var(--sl-spacing-small);
    forced-color-adjust: none;
  }

  .color-picker__swatch {
    position: relative;
    width: var(--swatch-size);
    height: var(--swatch-size);
    border-radius: var(--sl-border-radius-small);
  }

  .color-picker__swatch .color-picker__swatch-color {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    border: solid 1px rgba(0, 0, 0, 0.125);
    border-radius: inherit;
    cursor: pointer;
  }

  .color-picker__swatch:focus-visible {
    outline: var(--sl-focus-ring);
    outline-offset: var(--sl-focus-ring-offset);
  }

  .color-picker__transparent-bg {
    background-image: linear-gradient(45deg, var(--sl-color-neutral-300) 25%, transparent 25%),
      linear-gradient(45deg, transparent 75%, var(--sl-color-neutral-300) 75%),
      linear-gradient(45deg, transparent 75%, var(--sl-color-neutral-300) 75%),
      linear-gradient(45deg, var(--sl-color-neutral-300) 25%, transparent 25%);
    background-size: 10px 10px;
    background-position:
      0 0,
      0 0,
      -5px -5px,
      5px 5px;
  }

  .color-picker--disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }

  .color-picker--disabled .color-picker__grid,
  .color-picker--disabled .color-picker__grid-handle,
  .color-picker--disabled .color-picker__slider,
  .color-picker--disabled .color-picker__slider-handle,
  .color-picker--disabled .color-picker__preview,
  .color-picker--disabled .color-picker__swatch,
  .color-picker--disabled .color-picker__swatch-color {
    pointer-events: none;
  }

  /*
   * Color dropdown
   */

  .color-dropdown::part(panel) {
    max-height: none;
    background-color: var(--sl-panel-background-color);
    border: solid var(--sl-panel-border-width) var(--sl-panel-border-color);
    border-radius: var(--sl-border-radius-medium);
    overflow: visible;
  }

  .color-dropdown__trigger {
    display: inline-block;
    position: relative;
    background-color: transparent;
    border: none;
    cursor: pointer;
    forced-color-adjust: none;
  }

  .color-dropdown__trigger.color-dropdown__trigger--small {
    width: var(--sl-input-height-small);
    height: var(--sl-input-height-small);
    border-radius: var(--sl-border-radius-circle);
  }

  .color-dropdown__trigger.color-dropdown__trigger--medium {
    width: var(--sl-input-height-medium);
    height: var(--sl-input-height-medium);
    border-radius: var(--sl-border-radius-circle);
  }

  .color-dropdown__trigger.color-dropdown__trigger--large {
    width: var(--sl-input-height-large);
    height: var(--sl-input-height-large);
    border-radius: var(--sl-border-radius-circle);
  }

  .color-dropdown__trigger:before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    border-radius: inherit;
    background-color: currentColor;
    box-shadow:
      inset 0 0 0 2px var(--sl-input-border-color),
      inset 0 0 0 4px var(--sl-color-neutral-0);
  }

  .color-dropdown__trigger--empty:before {
    background-color: transparent;
  }

  .color-dropdown__trigger:focus-visible {
    outline: none;
  }

  .color-dropdown__trigger:focus-visible:not(.color-dropdown__trigger--disabled) {
    outline: var(--sl-focus-ring);
    outline-offset: var(--sl-focus-ring-offset);
  }

  .color-dropdown__trigger.color-dropdown__trigger--disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }
`, SlButton = class extends ShoelaceElement {
  constructor() {
    super(...arguments), this.formControlController = new FormControlController(this, {
      assumeInteractionOn: ["click"]
    }), this.hasSlotController = new HasSlotController(this, "[default]", "prefix", "suffix"), this.localize = new LocalizeController(this), this.hasFocus = !1, this.invalid = !1, this.title = "", this.variant = "default", this.size = "medium", this.caret = !1, this.disabled = !1, this.loading = !1, this.outline = !1, this.pill = !1, this.circle = !1, this.type = "button", this.name = "", this.value = "", this.href = "", this.rel = "noreferrer noopener";
  }
  /** Gets the validity state object */
  get validity() {
    return this.isButton() ? this.button.validity : validValidityState;
  }
  /** Gets the validation message */
  get validationMessage() {
    return this.isButton() ? this.button.validationMessage : "";
  }
  firstUpdated() {
    this.isButton() && this.formControlController.updateValidity();
  }
  handleBlur() {
    this.hasFocus = !1, this.emit("sl-blur");
  }
  handleFocus() {
    this.hasFocus = !0, this.emit("sl-focus");
  }
  handleClick() {
    this.type === "submit" && this.formControlController.submit(this), this.type === "reset" && this.formControlController.reset(this);
  }
  handleInvalid(z) {
    this.formControlController.setValidity(!1), this.formControlController.emitInvalidEvent(z);
  }
  isButton() {
    return !this.href;
  }
  isLink() {
    return !!this.href;
  }
  handleDisabledChange() {
    this.isButton() && this.formControlController.setValidity(this.disabled);
  }
  /** Simulates a click on the button. */
  click() {
    this.button.click();
  }
  /** Sets focus on the button. */
  focus(z) {
    this.button.focus(z);
  }
  /** Removes focus from the button. */
  blur() {
    this.button.blur();
  }
  /** Checks for validity but does not show a validation message. Returns `true` when valid and `false` when invalid. */
  checkValidity() {
    return this.isButton() ? this.button.checkValidity() : !0;
  }
  /** Gets the associated form, if one exists. */
  getForm() {
    return this.formControlController.getForm();
  }
  /** Checks for validity and shows the browser's validation message if the control is invalid. */
  reportValidity() {
    return this.isButton() ? this.button.reportValidity() : !0;
  }
  /** Sets a custom validation message. Pass an empty string to restore validity. */
  setCustomValidity(z) {
    this.isButton() && (this.button.setCustomValidity(z), this.formControlController.updateValidity());
  }
  render() {
    const z = this.isLink(), D = z ? s`a` : s`button`;
    return n$2`
      <${D}
        part="base"
        class=${e$2({
      button: !0,
      "button--default": this.variant === "default",
      "button--primary": this.variant === "primary",
      "button--success": this.variant === "success",
      "button--neutral": this.variant === "neutral",
      "button--warning": this.variant === "warning",
      "button--danger": this.variant === "danger",
      "button--text": this.variant === "text",
      "button--small": this.size === "small",
      "button--medium": this.size === "medium",
      "button--large": this.size === "large",
      "button--caret": this.caret,
      "button--circle": this.circle,
      "button--disabled": this.disabled,
      "button--focused": this.hasFocus,
      "button--loading": this.loading,
      "button--standard": !this.outline,
      "button--outline": this.outline,
      "button--pill": this.pill,
      "button--rtl": this.localize.dir() === "rtl",
      "button--has-label": this.hasSlotController.test("[default]"),
      "button--has-prefix": this.hasSlotController.test("prefix"),
      "button--has-suffix": this.hasSlotController.test("suffix")
    })}
        ?disabled=${o$6(z ? void 0 : this.disabled)}
        type=${o$6(z ? void 0 : this.type)}
        title=${this.title}
        name=${o$6(z ? void 0 : this.name)}
        value=${o$6(z ? void 0 : this.value)}
        href=${o$6(z ? this.href : void 0)}
        target=${o$6(z ? this.target : void 0)}
        download=${o$6(z ? this.download : void 0)}
        rel=${o$6(z ? this.rel : void 0)}
        role=${o$6(z ? void 0 : "button")}
        aria-disabled=${this.disabled ? "true" : "false"}
        tabindex=${this.disabled ? "-1" : "0"}
        @blur=${this.handleBlur}
        @focus=${this.handleFocus}
        @invalid=${this.isButton() ? this.handleInvalid : null}
        @click=${this.handleClick}
      >
        <slot name="prefix" part="prefix" class="button__prefix"></slot>
        <slot part="label" class="button__label"></slot>
        <slot name="suffix" part="suffix" class="button__suffix"></slot>
        ${this.caret ? n$2` <sl-icon part="caret" class="button__caret" library="system" name="caret"></sl-icon> ` : ""}
        ${this.loading ? n$2`<sl-spinner part="spinner"></sl-spinner>` : ""}
      </${D}>
    `;
  }
};
SlButton.styles = [component_styles_default, button_styles_default];
SlButton.dependencies = {
  "sl-icon": SlIcon,
  "sl-spinner": SlSpinner
};
__decorateClass([
  e$b(".button")
], SlButton.prototype, "button", 2);
__decorateClass([
  r$4()
], SlButton.prototype, "hasFocus", 2);
__decorateClass([
  r$4()
], SlButton.prototype, "invalid", 2);
__decorateClass([
  n$6()
], SlButton.prototype, "title", 2);
__decorateClass([
  n$6({ reflect: !0 })
], SlButton.prototype, "variant", 2);
__decorateClass([
  n$6({ reflect: !0 })
], SlButton.prototype, "size", 2);
__decorateClass([
  n$6({ type: Boolean, reflect: !0 })
], SlButton.prototype, "caret", 2);
__decorateClass([
  n$6({ type: Boolean, reflect: !0 })
], SlButton.prototype, "disabled", 2);
__decorateClass([
  n$6({ type: Boolean, reflect: !0 })
], SlButton.prototype, "loading", 2);
__decorateClass([
  n$6({ type: Boolean, reflect: !0 })
], SlButton.prototype, "outline", 2);
__decorateClass([
  n$6({ type: Boolean, reflect: !0 })
], SlButton.prototype, "pill", 2);
__decorateClass([
  n$6({ type: Boolean, reflect: !0 })
], SlButton.prototype, "circle", 2);
__decorateClass([
  n$6()
], SlButton.prototype, "type", 2);
__decorateClass([
  n$6()
], SlButton.prototype, "name", 2);
__decorateClass([
  n$6()
], SlButton.prototype, "value", 2);
__decorateClass([
  n$6()
], SlButton.prototype, "href", 2);
__decorateClass([
  n$6()
], SlButton.prototype, "target", 2);
__decorateClass([
  n$6()
], SlButton.prototype, "rel", 2);
__decorateClass([
  n$6()
], SlButton.prototype, "download", 2);
__decorateClass([
  n$6()
], SlButton.prototype, "form", 2);
__decorateClass([
  n$6({ attribute: "formaction" })
], SlButton.prototype, "formAction", 2);
__decorateClass([
  n$6({ attribute: "formenctype" })
], SlButton.prototype, "formEnctype", 2);
__decorateClass([
  n$6({ attribute: "formmethod" })
], SlButton.prototype, "formMethod", 2);
__decorateClass([
  n$6({ attribute: "formnovalidate", type: Boolean })
], SlButton.prototype, "formNoValidate", 2);
__decorateClass([
  n$6({ attribute: "formtarget" })
], SlButton.prototype, "formTarget", 2);
__decorateClass([
  watch("disabled", { waitUntilFirstUpdate: !0 })
], SlButton.prototype, "handleDisabledChange", 1);
function bound01(z, D) {
  isOnePointZero(z) && (z = "100%");
  const O = isPercentage(z);
  return z = D === 360 ? z : Math.min(D, Math.max(0, parseFloat(z))), O && (z = parseInt(String(z * D), 10) / 100), Math.abs(z - D) < 1e-6 ? 1 : (D === 360 ? z = (z < 0 ? z % D + D : z % D) / parseFloat(String(D)) : z = z % D / parseFloat(String(D)), z);
}
function clamp01(z) {
  return Math.min(1, Math.max(0, z));
}
function isOnePointZero(z) {
  return typeof z == "string" && z.indexOf(".") !== -1 && parseFloat(z) === 1;
}
function isPercentage(z) {
  return typeof z == "string" && z.indexOf("%") !== -1;
}
function boundAlpha(z) {
  return z = parseFloat(z), (isNaN(z) || z < 0 || z > 1) && (z = 1), z;
}
function convertToPercentage(z) {
  return Number(z) <= 1 ? `${Number(z) * 100}%` : z;
}
function pad2(z) {
  return z.length === 1 ? "0" + z : String(z);
}
function rgbToRgb(z, D, O) {
  return {
    r: bound01(z, 255) * 255,
    g: bound01(D, 255) * 255,
    b: bound01(O, 255) * 255
  };
}
function rgbToHsl(z, D, O) {
  z = bound01(z, 255), D = bound01(D, 255), O = bound01(O, 255);
  const F = Math.max(z, D, O), U = Math.min(z, D, O);
  let W = 0, B = 0;
  const K = (F + U) / 2;
  if (F === U)
    B = 0, W = 0;
  else {
    const X = F - U;
    switch (B = K > 0.5 ? X / (2 - F - U) : X / (F + U), F) {
      case z:
        W = (D - O) / X + (D < O ? 6 : 0);
        break;
      case D:
        W = (O - z) / X + 2;
        break;
      case O:
        W = (z - D) / X + 4;
        break;
    }
    W /= 6;
  }
  return { h: W, s: B, l: K };
}
function hue2rgb(z, D, O) {
  return O < 0 && (O += 1), O > 1 && (O -= 1), O < 1 / 6 ? z + (D - z) * (6 * O) : O < 1 / 2 ? D : O < 2 / 3 ? z + (D - z) * (2 / 3 - O) * 6 : z;
}
function hslToRgb(z, D, O) {
  let F, U, W;
  if (z = bound01(z, 360), D = bound01(D, 100), O = bound01(O, 100), D === 0)
    U = O, W = O, F = O;
  else {
    const B = O < 0.5 ? O * (1 + D) : O + D - O * D, K = 2 * O - B;
    F = hue2rgb(K, B, z + 1 / 3), U = hue2rgb(K, B, z), W = hue2rgb(K, B, z - 1 / 3);
  }
  return { r: F * 255, g: U * 255, b: W * 255 };
}
function rgbToHsv(z, D, O) {
  z = bound01(z, 255), D = bound01(D, 255), O = bound01(O, 255);
  const F = Math.max(z, D, O), U = Math.min(z, D, O);
  let W = 0;
  const B = F, K = F - U, X = F === 0 ? 0 : K / F;
  if (F === U)
    W = 0;
  else {
    switch (F) {
      case z:
        W = (D - O) / K + (D < O ? 6 : 0);
        break;
      case D:
        W = (O - z) / K + 2;
        break;
      case O:
        W = (z - D) / K + 4;
        break;
    }
    W /= 6;
  }
  return { h: W, s: X, v: B };
}
function hsvToRgb(z, D, O) {
  z = bound01(z, 360) * 6, D = bound01(D, 100), O = bound01(O, 100);
  const F = Math.floor(z), U = z - F, W = O * (1 - D), B = O * (1 - U * D), K = O * (1 - (1 - U) * D), X = F % 6, Y = [O, B, W, W, K, O][X], Q = [K, O, O, B, W, W][X], J = [W, W, K, O, O, B][X];
  return { r: Y * 255, g: Q * 255, b: J * 255 };
}
function rgbToHex(z, D, O, F) {
  const U = [
    pad2(Math.round(z).toString(16)),
    pad2(Math.round(D).toString(16)),
    pad2(Math.round(O).toString(16))
  ];
  return F && U[0].startsWith(U[0].charAt(1)) && U[1].startsWith(U[1].charAt(1)) && U[2].startsWith(U[2].charAt(1)) ? U[0].charAt(0) + U[1].charAt(0) + U[2].charAt(0) : U.join("");
}
function rgbaToHex(z, D, O, F, U) {
  const W = [
    pad2(Math.round(z).toString(16)),
    pad2(Math.round(D).toString(16)),
    pad2(Math.round(O).toString(16)),
    pad2(convertDecimalToHex(F))
  ];
  return U && W[0].startsWith(W[0].charAt(1)) && W[1].startsWith(W[1].charAt(1)) && W[2].startsWith(W[2].charAt(1)) && W[3].startsWith(W[3].charAt(1)) ? W[0].charAt(0) + W[1].charAt(0) + W[2].charAt(0) + W[3].charAt(0) : W.join("");
}
function cmykToRgb(z, D, O, F) {
  const U = z / 100, W = D / 100, B = O / 100, K = F / 100, X = 255 * (1 - U) * (1 - K), Y = 255 * (1 - W) * (1 - K), Q = 255 * (1 - B) * (1 - K);
  return { r: X, g: Y, b: Q };
}
function rgbToCmyk(z, D, O) {
  let F = 1 - z / 255, U = 1 - D / 255, W = 1 - O / 255, B = Math.min(F, U, W);
  return B === 1 ? (F = 0, U = 0, W = 0) : (F = (F - B) / (1 - B) * 100, U = (U - B) / (1 - B) * 100, W = (W - B) / (1 - B) * 100), B *= 100, {
    c: Math.round(F),
    m: Math.round(U),
    y: Math.round(W),
    k: Math.round(B)
  };
}
function convertDecimalToHex(z) {
  return Math.round(parseFloat(z) * 255).toString(16);
}
function convertHexToDecimal(z) {
  return parseIntFromHex(z) / 255;
}
function parseIntFromHex(z) {
  return parseInt(z, 16);
}
function numberInputToObject(z) {
  return {
    r: z >> 16,
    g: (z & 65280) >> 8,
    b: z & 255
  };
}
const names = {
  aliceblue: "#f0f8ff",
  antiquewhite: "#faebd7",
  aqua: "#00ffff",
  aquamarine: "#7fffd4",
  azure: "#f0ffff",
  beige: "#f5f5dc",
  bisque: "#ffe4c4",
  black: "#000000",
  blanchedalmond: "#ffebcd",
  blue: "#0000ff",
  blueviolet: "#8a2be2",
  brown: "#a52a2a",
  burlywood: "#deb887",
  cadetblue: "#5f9ea0",
  chartreuse: "#7fff00",
  chocolate: "#d2691e",
  coral: "#ff7f50",
  cornflowerblue: "#6495ed",
  cornsilk: "#fff8dc",
  crimson: "#dc143c",
  cyan: "#00ffff",
  darkblue: "#00008b",
  darkcyan: "#008b8b",
  darkgoldenrod: "#b8860b",
  darkgray: "#a9a9a9",
  darkgreen: "#006400",
  darkgrey: "#a9a9a9",
  darkkhaki: "#bdb76b",
  darkmagenta: "#8b008b",
  darkolivegreen: "#556b2f",
  darkorange: "#ff8c00",
  darkorchid: "#9932cc",
  darkred: "#8b0000",
  darksalmon: "#e9967a",
  darkseagreen: "#8fbc8f",
  darkslateblue: "#483d8b",
  darkslategray: "#2f4f4f",
  darkslategrey: "#2f4f4f",
  darkturquoise: "#00ced1",
  darkviolet: "#9400d3",
  deeppink: "#ff1493",
  deepskyblue: "#00bfff",
  dimgray: "#696969",
  dimgrey: "#696969",
  dodgerblue: "#1e90ff",
  firebrick: "#b22222",
  floralwhite: "#fffaf0",
  forestgreen: "#228b22",
  fuchsia: "#ff00ff",
  gainsboro: "#dcdcdc",
  ghostwhite: "#f8f8ff",
  goldenrod: "#daa520",
  gold: "#ffd700",
  gray: "#808080",
  green: "#008000",
  greenyellow: "#adff2f",
  grey: "#808080",
  honeydew: "#f0fff0",
  hotpink: "#ff69b4",
  indianred: "#cd5c5c",
  indigo: "#4b0082",
  ivory: "#fffff0",
  khaki: "#f0e68c",
  lavenderblush: "#fff0f5",
  lavender: "#e6e6fa",
  lawngreen: "#7cfc00",
  lemonchiffon: "#fffacd",
  lightblue: "#add8e6",
  lightcoral: "#f08080",
  lightcyan: "#e0ffff",
  lightgoldenrodyellow: "#fafad2",
  lightgray: "#d3d3d3",
  lightgreen: "#90ee90",
  lightgrey: "#d3d3d3",
  lightpink: "#ffb6c1",
  lightsalmon: "#ffa07a",
  lightseagreen: "#20b2aa",
  lightskyblue: "#87cefa",
  lightslategray: "#778899",
  lightslategrey: "#778899",
  lightsteelblue: "#b0c4de",
  lightyellow: "#ffffe0",
  lime: "#00ff00",
  limegreen: "#32cd32",
  linen: "#faf0e6",
  magenta: "#ff00ff",
  maroon: "#800000",
  mediumaquamarine: "#66cdaa",
  mediumblue: "#0000cd",
  mediumorchid: "#ba55d3",
  mediumpurple: "#9370db",
  mediumseagreen: "#3cb371",
  mediumslateblue: "#7b68ee",
  mediumspringgreen: "#00fa9a",
  mediumturquoise: "#48d1cc",
  mediumvioletred: "#c71585",
  midnightblue: "#191970",
  mintcream: "#f5fffa",
  mistyrose: "#ffe4e1",
  moccasin: "#ffe4b5",
  navajowhite: "#ffdead",
  navy: "#000080",
  oldlace: "#fdf5e6",
  olive: "#808000",
  olivedrab: "#6b8e23",
  orange: "#ffa500",
  orangered: "#ff4500",
  orchid: "#da70d6",
  palegoldenrod: "#eee8aa",
  palegreen: "#98fb98",
  paleturquoise: "#afeeee",
  palevioletred: "#db7093",
  papayawhip: "#ffefd5",
  peachpuff: "#ffdab9",
  peru: "#cd853f",
  pink: "#ffc0cb",
  plum: "#dda0dd",
  powderblue: "#b0e0e6",
  purple: "#800080",
  rebeccapurple: "#663399",
  red: "#ff0000",
  rosybrown: "#bc8f8f",
  royalblue: "#4169e1",
  saddlebrown: "#8b4513",
  salmon: "#fa8072",
  sandybrown: "#f4a460",
  seagreen: "#2e8b57",
  seashell: "#fff5ee",
  sienna: "#a0522d",
  silver: "#c0c0c0",
  skyblue: "#87ceeb",
  slateblue: "#6a5acd",
  slategray: "#708090",
  slategrey: "#708090",
  snow: "#fffafa",
  springgreen: "#00ff7f",
  steelblue: "#4682b4",
  tan: "#d2b48c",
  teal: "#008080",
  thistle: "#d8bfd8",
  tomato: "#ff6347",
  turquoise: "#40e0d0",
  violet: "#ee82ee",
  wheat: "#f5deb3",
  white: "#ffffff",
  whitesmoke: "#f5f5f5",
  yellow: "#ffff00",
  yellowgreen: "#9acd32"
};
function inputToRGB(z) {
  let D = { r: 0, g: 0, b: 0 }, O = 1, F = null, U = null, W = null, B = !1, K = !1;
  return typeof z == "string" && (z = stringInputToObject(z)), typeof z == "object" && (isValidCSSUnit(z.r) && isValidCSSUnit(z.g) && isValidCSSUnit(z.b) ? (D = rgbToRgb(z.r, z.g, z.b), B = !0, K = String(z.r).substr(-1) === "%" ? "prgb" : "rgb") : isValidCSSUnit(z.h) && isValidCSSUnit(z.s) && isValidCSSUnit(z.v) ? (F = convertToPercentage(z.s), U = convertToPercentage(z.v), D = hsvToRgb(z.h, F, U), B = !0, K = "hsv") : isValidCSSUnit(z.h) && isValidCSSUnit(z.s) && isValidCSSUnit(z.l) ? (F = convertToPercentage(z.s), W = convertToPercentage(z.l), D = hslToRgb(z.h, F, W), B = !0, K = "hsl") : isValidCSSUnit(z.c) && isValidCSSUnit(z.m) && isValidCSSUnit(z.y) && isValidCSSUnit(z.k) && (D = cmykToRgb(z.c, z.m, z.y, z.k), B = !0, K = "cmyk"), Object.prototype.hasOwnProperty.call(z, "a") && (O = z.a)), O = boundAlpha(O), {
    ok: B,
    format: z.format || K,
    r: Math.min(255, Math.max(D.r, 0)),
    g: Math.min(255, Math.max(D.g, 0)),
    b: Math.min(255, Math.max(D.b, 0)),
    a: O
  };
}
const CSS_INTEGER = "[-\\+]?\\d+%?", CSS_NUMBER = "[-\\+]?\\d*\\.\\d+%?", CSS_UNIT = "(?:" + CSS_NUMBER + ")|(?:" + CSS_INTEGER + ")", PERMISSIVE_MATCH3 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?", PERMISSIVE_MATCH4 = (
  // eslint-disable-next-line prettier/prettier
  "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?"
), matchers = {
  CSS_UNIT: new RegExp(CSS_UNIT),
  rgb: new RegExp("rgb" + PERMISSIVE_MATCH3),
  rgba: new RegExp("rgba" + PERMISSIVE_MATCH4),
  hsl: new RegExp("hsl" + PERMISSIVE_MATCH3),
  hsla: new RegExp("hsla" + PERMISSIVE_MATCH4),
  hsv: new RegExp("hsv" + PERMISSIVE_MATCH3),
  hsva: new RegExp("hsva" + PERMISSIVE_MATCH4),
  cmyk: new RegExp("cmyk" + PERMISSIVE_MATCH4),
  hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
  hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
  hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
  hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
};
function stringInputToObject(z) {
  if (z = z.trim().toLowerCase(), z.length === 0)
    return !1;
  let D = !1;
  if (names[z])
    z = names[z], D = !0;
  else if (z === "transparent")
    return { r: 0, g: 0, b: 0, a: 0, format: "name" };
  let O = matchers.rgb.exec(z);
  return O ? { r: O[1], g: O[2], b: O[3] } : (O = matchers.rgba.exec(z), O ? { r: O[1], g: O[2], b: O[3], a: O[4] } : (O = matchers.hsl.exec(z), O ? { h: O[1], s: O[2], l: O[3] } : (O = matchers.hsla.exec(z), O ? { h: O[1], s: O[2], l: O[3], a: O[4] } : (O = matchers.hsv.exec(z), O ? { h: O[1], s: O[2], v: O[3] } : (O = matchers.hsva.exec(z), O ? { h: O[1], s: O[2], v: O[3], a: O[4] } : (O = matchers.cmyk.exec(z), O ? {
    c: O[1],
    m: O[2],
    y: O[3],
    k: O[4]
  } : (O = matchers.hex8.exec(z), O ? {
    r: parseIntFromHex(O[1]),
    g: parseIntFromHex(O[2]),
    b: parseIntFromHex(O[3]),
    a: convertHexToDecimal(O[4]),
    format: D ? "name" : "hex8"
  } : (O = matchers.hex6.exec(z), O ? {
    r: parseIntFromHex(O[1]),
    g: parseIntFromHex(O[2]),
    b: parseIntFromHex(O[3]),
    format: D ? "name" : "hex"
  } : (O = matchers.hex4.exec(z), O ? {
    r: parseIntFromHex(O[1] + O[1]),
    g: parseIntFromHex(O[2] + O[2]),
    b: parseIntFromHex(O[3] + O[3]),
    a: convertHexToDecimal(O[4] + O[4]),
    format: D ? "name" : "hex8"
  } : (O = matchers.hex3.exec(z), O ? {
    r: parseIntFromHex(O[1] + O[1]),
    g: parseIntFromHex(O[2] + O[2]),
    b: parseIntFromHex(O[3] + O[3]),
    format: D ? "name" : "hex"
  } : !1))))))))));
}
function isValidCSSUnit(z) {
  return typeof z == "number" ? !Number.isNaN(z) : matchers.CSS_UNIT.test(z);
}
class TinyColor {
  constructor(D = "", O = {}) {
    if (D instanceof TinyColor)
      return D;
    typeof D == "number" && (D = numberInputToObject(D)), this.originalInput = D;
    const F = inputToRGB(D);
    this.originalInput = D, this.r = F.r, this.g = F.g, this.b = F.b, this.a = F.a, this.roundA = Math.round(100 * this.a) / 100, this.format = O.format ?? F.format, this.gradientType = O.gradientType, this.r < 1 && (this.r = Math.round(this.r)), this.g < 1 && (this.g = Math.round(this.g)), this.b < 1 && (this.b = Math.round(this.b)), this.isValid = F.ok;
  }
  isDark() {
    return this.getBrightness() < 128;
  }
  isLight() {
    return !this.isDark();
  }
  /**
   * Returns the perceived brightness of the color, from 0-255.
   */
  getBrightness() {
    const D = this.toRgb();
    return (D.r * 299 + D.g * 587 + D.b * 114) / 1e3;
  }
  /**
   * Returns the perceived luminance of a color, from 0-1.
   */
  getLuminance() {
    const D = this.toRgb();
    let O, F, U;
    const W = D.r / 255, B = D.g / 255, K = D.b / 255;
    return W <= 0.03928 ? O = W / 12.92 : O = Math.pow((W + 0.055) / 1.055, 2.4), B <= 0.03928 ? F = B / 12.92 : F = Math.pow((B + 0.055) / 1.055, 2.4), K <= 0.03928 ? U = K / 12.92 : U = Math.pow((K + 0.055) / 1.055, 2.4), 0.2126 * O + 0.7152 * F + 0.0722 * U;
  }
  /**
   * Returns the alpha value of a color, from 0-1.
   */
  getAlpha() {
    return this.a;
  }
  /**
   * Sets the alpha value on the current color.
   *
   * @param alpha - The new alpha value. The accepted range is 0-1.
   */
  setAlpha(D) {
    return this.a = boundAlpha(D), this.roundA = Math.round(100 * this.a) / 100, this;
  }
  /**
   * Returns whether the color is monochrome.
   */
  isMonochrome() {
    const { s: D } = this.toHsl();
    return D === 0;
  }
  /**
   * Returns the object as a HSVA object.
   */
  toHsv() {
    const D = rgbToHsv(this.r, this.g, this.b);
    return { h: D.h * 360, s: D.s, v: D.v, a: this.a };
  }
  /**
   * Returns the hsva values interpolated into a string with the following format:
   * "hsva(xxx, xxx, xxx, xx)".
   */
  toHsvString() {
    const D = rgbToHsv(this.r, this.g, this.b), O = Math.round(D.h * 360), F = Math.round(D.s * 100), U = Math.round(D.v * 100);
    return this.a === 1 ? `hsv(${O}, ${F}%, ${U}%)` : `hsva(${O}, ${F}%, ${U}%, ${this.roundA})`;
  }
  /**
   * Returns the object as a HSLA object.
   */
  toHsl() {
    const D = rgbToHsl(this.r, this.g, this.b);
    return { h: D.h * 360, s: D.s, l: D.l, a: this.a };
  }
  /**
   * Returns the hsla values interpolated into a string with the following format:
   * "hsla(xxx, xxx, xxx, xx)".
   */
  toHslString() {
    const D = rgbToHsl(this.r, this.g, this.b), O = Math.round(D.h * 360), F = Math.round(D.s * 100), U = Math.round(D.l * 100);
    return this.a === 1 ? `hsl(${O}, ${F}%, ${U}%)` : `hsla(${O}, ${F}%, ${U}%, ${this.roundA})`;
  }
  /**
   * Returns the hex value of the color.
   * @param allow3Char will shorten hex value to 3 char if possible
   */
  toHex(D = !1) {
    return rgbToHex(this.r, this.g, this.b, D);
  }
  /**
   * Returns the hex value of the color -with a # prefixed.
   * @param allow3Char will shorten hex value to 3 char if possible
   */
  toHexString(D = !1) {
    return "#" + this.toHex(D);
  }
  /**
   * Returns the hex 8 value of the color.
   * @param allow4Char will shorten hex value to 4 char if possible
   */
  toHex8(D = !1) {
    return rgbaToHex(this.r, this.g, this.b, this.a, D);
  }
  /**
   * Returns the hex 8 value of the color -with a # prefixed.
   * @param allow4Char will shorten hex value to 4 char if possible
   */
  toHex8String(D = !1) {
    return "#" + this.toHex8(D);
  }
  /**
   * Returns the shorter hex value of the color depends on its alpha -with a # prefixed.
   * @param allowShortChar will shorten hex value to 3 or 4 char if possible
   */
  toHexShortString(D = !1) {
    return this.a === 1 ? this.toHexString(D) : this.toHex8String(D);
  }
  /**
   * Returns the object as a RGBA object.
   */
  toRgb() {
    return {
      r: Math.round(this.r),
      g: Math.round(this.g),
      b: Math.round(this.b),
      a: this.a
    };
  }
  /**
   * Returns the RGBA values interpolated into a string with the following format:
   * "RGBA(xxx, xxx, xxx, xx)".
   */
  toRgbString() {
    const D = Math.round(this.r), O = Math.round(this.g), F = Math.round(this.b);
    return this.a === 1 ? `rgb(${D}, ${O}, ${F})` : `rgba(${D}, ${O}, ${F}, ${this.roundA})`;
  }
  /**
   * Returns the object as a RGBA object.
   */
  toPercentageRgb() {
    const D = (O) => `${Math.round(bound01(O, 255) * 100)}%`;
    return {
      r: D(this.r),
      g: D(this.g),
      b: D(this.b),
      a: this.a
    };
  }
  /**
   * Returns the RGBA relative values interpolated into a string
   */
  toPercentageRgbString() {
    const D = (O) => Math.round(bound01(O, 255) * 100);
    return this.a === 1 ? `rgb(${D(this.r)}%, ${D(this.g)}%, ${D(this.b)}%)` : `rgba(${D(this.r)}%, ${D(this.g)}%, ${D(this.b)}%, ${this.roundA})`;
  }
  toCmyk() {
    return {
      ...rgbToCmyk(this.r, this.g, this.b)
    };
  }
  toCmykString() {
    const { c: D, m: O, y: F, k: U } = rgbToCmyk(this.r, this.g, this.b);
    return `cmyk(${D}, ${O}, ${F}, ${U})`;
  }
  /**
   * The 'real' name of the color -if there is one.
   */
  toName() {
    if (this.a === 0)
      return "transparent";
    if (this.a < 1)
      return !1;
    const D = "#" + rgbToHex(this.r, this.g, this.b, !1);
    for (const [O, F] of Object.entries(names))
      if (D === F)
        return O;
    return !1;
  }
  toString(D) {
    const O = !!D;
    D = D ?? this.format;
    let F = !1;
    const U = this.a < 1 && this.a >= 0;
    return !O && U && (D.startsWith("hex") || D === "name") ? D === "name" && this.a === 0 ? this.toName() : this.toRgbString() : (D === "rgb" && (F = this.toRgbString()), D === "prgb" && (F = this.toPercentageRgbString()), (D === "hex" || D === "hex6") && (F = this.toHexString()), D === "hex3" && (F = this.toHexString(!0)), D === "hex4" && (F = this.toHex8String(!0)), D === "hex8" && (F = this.toHex8String()), D === "name" && (F = this.toName()), D === "hsl" && (F = this.toHslString()), D === "hsv" && (F = this.toHsvString()), D === "cmyk" && (F = this.toCmykString()), F || this.toHexString());
  }
  toNumber() {
    return (Math.round(this.r) << 16) + (Math.round(this.g) << 8) + Math.round(this.b);
  }
  clone() {
    return new TinyColor(this.toString());
  }
  /**
   * Lighten the color a given amount. Providing 100 will always return white.
   * @param amount - valid between 1-100
   */
  lighten(D = 10) {
    const O = this.toHsl();
    return O.l += D / 100, O.l = clamp01(O.l), new TinyColor(O);
  }
  /**
   * Brighten the color a given amount, from 0 to 100.
   * @param amount - valid between 1-100
   */
  brighten(D = 10) {
    const O = this.toRgb();
    return O.r = Math.max(0, Math.min(255, O.r - Math.round(255 * -(D / 100)))), O.g = Math.max(0, Math.min(255, O.g - Math.round(255 * -(D / 100)))), O.b = Math.max(0, Math.min(255, O.b - Math.round(255 * -(D / 100)))), new TinyColor(O);
  }
  /**
   * Darken the color a given amount, from 0 to 100.
   * Providing 100 will always return black.
   * @param amount - valid between 1-100
   */
  darken(D = 10) {
    const O = this.toHsl();
    return O.l -= D / 100, O.l = clamp01(O.l), new TinyColor(O);
  }
  /**
   * Mix the color with pure white, from 0 to 100.
   * Providing 0 will do nothing, providing 100 will always return white.
   * @param amount - valid between 1-100
   */
  tint(D = 10) {
    return this.mix("white", D);
  }
  /**
   * Mix the color with pure black, from 0 to 100.
   * Providing 0 will do nothing, providing 100 will always return black.
   * @param amount - valid between 1-100
   */
  shade(D = 10) {
    return this.mix("black", D);
  }
  /**
   * Desaturate the color a given amount, from 0 to 100.
   * Providing 100 will is the same as calling greyscale
   * @param amount - valid between 1-100
   */
  desaturate(D = 10) {
    const O = this.toHsl();
    return O.s -= D / 100, O.s = clamp01(O.s), new TinyColor(O);
  }
  /**
   * Saturate the color a given amount, from 0 to 100.
   * @param amount - valid between 1-100
   */
  saturate(D = 10) {
    const O = this.toHsl();
    return O.s += D / 100, O.s = clamp01(O.s), new TinyColor(O);
  }
  /**
   * Completely desaturates a color into greyscale.
   * Same as calling `desaturate(100)`
   */
  greyscale() {
    return this.desaturate(100);
  }
  /**
   * Spin takes a positive or negative amount within [-360, 360] indicating the change of hue.
   * Values outside of this range will be wrapped into this range.
   */
  spin(D) {
    const O = this.toHsl(), F = (O.h + D) % 360;
    return O.h = F < 0 ? 360 + F : F, new TinyColor(O);
  }
  /**
   * Mix the current color a given amount with another color, from 0 to 100.
   * 0 means no mixing (return current color).
   */
  mix(D, O = 50) {
    const F = this.toRgb(), U = new TinyColor(D).toRgb(), W = O / 100, B = {
      r: (U.r - F.r) * W + F.r,
      g: (U.g - F.g) * W + F.g,
      b: (U.b - F.b) * W + F.b,
      a: (U.a - F.a) * W + F.a
    };
    return new TinyColor(B);
  }
  analogous(D = 6, O = 30) {
    const F = this.toHsl(), U = 360 / O, W = [this];
    for (F.h = (F.h - (U * D >> 1) + 720) % 360; --D; )
      F.h = (F.h + U) % 360, W.push(new TinyColor(F));
    return W;
  }
  /**
   * taken from https://github.com/infusion/jQuery-xcolor/blob/master/jquery.xcolor.js
   */
  complement() {
    const D = this.toHsl();
    return D.h = (D.h + 180) % 360, new TinyColor(D);
  }
  monochromatic(D = 6) {
    const O = this.toHsv(), { h: F } = O, { s: U } = O;
    let { v: W } = O;
    const B = [], K = 1 / D;
    for (; D--; )
      B.push(new TinyColor({ h: F, s: U, v: W })), W = (W + K) % 1;
    return B;
  }
  splitcomplement() {
    const D = this.toHsl(), { h: O } = D;
    return [
      this,
      new TinyColor({ h: (O + 72) % 360, s: D.s, l: D.l }),
      new TinyColor({ h: (O + 216) % 360, s: D.s, l: D.l })
    ];
  }
  /**
   * Compute how the color would appear on a background
   */
  onBackground(D) {
    const O = this.toRgb(), F = new TinyColor(D).toRgb(), U = O.a + F.a * (1 - O.a);
    return new TinyColor({
      r: (O.r * O.a + F.r * F.a * (1 - O.a)) / U,
      g: (O.g * O.a + F.g * F.a * (1 - O.a)) / U,
      b: (O.b * O.a + F.b * F.a * (1 - O.a)) / U,
      a: U
    });
  }
  /**
   * Alias for `polyad(3)`
   */
  triad() {
    return this.polyad(3);
  }
  /**
   * Alias for `polyad(4)`
   */
  tetrad() {
    return this.polyad(4);
  }
  /**
   * Get polyad colors, like (for 1, 2, 3, 4, 5, 6, 7, 8, etc...)
   * monad, dyad, triad, tetrad, pentad, hexad, heptad, octad, etc...
   */
  polyad(D) {
    const O = this.toHsl(), { h: F } = O, U = [this], W = 360 / D;
    for (let B = 1; B < D; B++)
      U.push(new TinyColor({ h: (F + B * W) % 360, s: O.s, l: O.l }));
    return U;
  }
  /**
   * compare color vs current color
   */
  equals(D) {
    const O = new TinyColor(D);
    return this.format === "cmyk" || O.format === "cmyk" ? this.toCmykString() === O.toCmykString() : this.toRgbString() === O.toRgbString();
  }
}
var hasEyeDropper = "EyeDropper" in window, SlColorPicker = class extends ShoelaceElement {
  constructor() {
    super(), this.formControlController = new FormControlController(this), this.isSafeValue = !1, this.localize = new LocalizeController(this), this.hasFocus = !1, this.isDraggingGridHandle = !1, this.isEmpty = !1, this.inputValue = "", this.hue = 0, this.saturation = 100, this.brightness = 100, this.alpha = 100, this.value = "", this.defaultValue = "", this.label = "", this.format = "hex", this.inline = !1, this.size = "medium", this.noFormatToggle = !1, this.name = "", this.disabled = !1, this.hoist = !1, this.opacity = !1, this.uppercase = !1, this.swatches = "", this.form = "", this.required = !1, this.handleFocusIn = () => {
      this.hasFocus = !0, this.emit("sl-focus");
    }, this.handleFocusOut = () => {
      this.hasFocus = !1, this.emit("sl-blur");
    }, this.addEventListener("focusin", this.handleFocusIn), this.addEventListener("focusout", this.handleFocusOut);
  }
  /** Gets the validity state object */
  get validity() {
    return this.input.validity;
  }
  /** Gets the validation message */
  get validationMessage() {
    return this.input.validationMessage;
  }
  firstUpdated() {
    this.input.updateComplete.then(() => {
      this.formControlController.updateValidity();
    });
  }
  handleCopy() {
    this.input.select(), document.execCommand("copy"), this.previewButton.focus(), this.previewButton.classList.add("color-picker__preview-color--copied"), this.previewButton.addEventListener("animationend", () => {
      this.previewButton.classList.remove("color-picker__preview-color--copied");
    });
  }
  handleFormatToggle() {
    const z = ["hex", "rgb", "hsl", "hsv"], D = (z.indexOf(this.format) + 1) % z.length;
    this.format = z[D], this.setColor(this.value), this.emit("sl-change"), this.emit("sl-input");
  }
  handleAlphaDrag(z) {
    const D = this.shadowRoot.querySelector(".color-picker__slider.color-picker__alpha"), O = D.querySelector(".color-picker__slider-handle"), { width: F } = D.getBoundingClientRect();
    let U = this.value, W = this.value;
    O.focus(), z.preventDefault(), drag(D, {
      onMove: (B) => {
        this.alpha = clamp$1(B / F * 100, 0, 100), this.syncValues(), this.value !== W && (W = this.value, this.emit("sl-input"));
      },
      onStop: () => {
        this.value !== U && (U = this.value, this.emit("sl-change"));
      },
      initialEvent: z
    });
  }
  handleHueDrag(z) {
    const D = this.shadowRoot.querySelector(".color-picker__slider.color-picker__hue"), O = D.querySelector(".color-picker__slider-handle"), { width: F } = D.getBoundingClientRect();
    let U = this.value, W = this.value;
    O.focus(), z.preventDefault(), drag(D, {
      onMove: (B) => {
        this.hue = clamp$1(B / F * 360, 0, 360), this.syncValues(), this.value !== W && (W = this.value, this.emit("sl-input"));
      },
      onStop: () => {
        this.value !== U && (U = this.value, this.emit("sl-change"));
      },
      initialEvent: z
    });
  }
  handleGridDrag(z) {
    const D = this.shadowRoot.querySelector(".color-picker__grid"), O = D.querySelector(".color-picker__grid-handle"), { width: F, height: U } = D.getBoundingClientRect();
    let W = this.value, B = this.value;
    O.focus(), z.preventDefault(), this.isDraggingGridHandle = !0, drag(D, {
      onMove: (K, X) => {
        this.saturation = clamp$1(K / F * 100, 0, 100), this.brightness = clamp$1(100 - X / U * 100, 0, 100), this.syncValues(), this.value !== B && (B = this.value, this.emit("sl-input"));
      },
      onStop: () => {
        this.isDraggingGridHandle = !1, this.value !== W && (W = this.value, this.emit("sl-change"));
      },
      initialEvent: z
    });
  }
  handleAlphaKeyDown(z) {
    const D = z.shiftKey ? 10 : 1, O = this.value;
    z.key === "ArrowLeft" && (z.preventDefault(), this.alpha = clamp$1(this.alpha - D, 0, 100), this.syncValues()), z.key === "ArrowRight" && (z.preventDefault(), this.alpha = clamp$1(this.alpha + D, 0, 100), this.syncValues()), z.key === "Home" && (z.preventDefault(), this.alpha = 0, this.syncValues()), z.key === "End" && (z.preventDefault(), this.alpha = 100, this.syncValues()), this.value !== O && (this.emit("sl-change"), this.emit("sl-input"));
  }
  handleHueKeyDown(z) {
    const D = z.shiftKey ? 10 : 1, O = this.value;
    z.key === "ArrowLeft" && (z.preventDefault(), this.hue = clamp$1(this.hue - D, 0, 360), this.syncValues()), z.key === "ArrowRight" && (z.preventDefault(), this.hue = clamp$1(this.hue + D, 0, 360), this.syncValues()), z.key === "Home" && (z.preventDefault(), this.hue = 0, this.syncValues()), z.key === "End" && (z.preventDefault(), this.hue = 360, this.syncValues()), this.value !== O && (this.emit("sl-change"), this.emit("sl-input"));
  }
  handleGridKeyDown(z) {
    const D = z.shiftKey ? 10 : 1, O = this.value;
    z.key === "ArrowLeft" && (z.preventDefault(), this.saturation = clamp$1(this.saturation - D, 0, 100), this.syncValues()), z.key === "ArrowRight" && (z.preventDefault(), this.saturation = clamp$1(this.saturation + D, 0, 100), this.syncValues()), z.key === "ArrowUp" && (z.preventDefault(), this.brightness = clamp$1(this.brightness + D, 0, 100), this.syncValues()), z.key === "ArrowDown" && (z.preventDefault(), this.brightness = clamp$1(this.brightness - D, 0, 100), this.syncValues()), this.value !== O && (this.emit("sl-change"), this.emit("sl-input"));
  }
  handleInputChange(z) {
    const D = z.target, O = this.value;
    z.stopPropagation(), this.input.value ? (this.setColor(D.value), D.value = this.value) : this.value = "", this.value !== O && (this.emit("sl-change"), this.emit("sl-input"));
  }
  handleInputInput(z) {
    this.formControlController.updateValidity(), z.stopPropagation();
  }
  handleInputKeyDown(z) {
    if (z.key === "Enter") {
      const D = this.value;
      this.input.value ? (this.setColor(this.input.value), this.input.value = this.value, this.value !== D && (this.emit("sl-change"), this.emit("sl-input")), setTimeout(() => this.input.select())) : this.hue = 0;
    }
  }
  handleInputInvalid(z) {
    this.formControlController.setValidity(!1), this.formControlController.emitInvalidEvent(z);
  }
  handleTouchMove(z) {
    z.preventDefault();
  }
  parseColor(z) {
    const D = new TinyColor(z);
    if (!D.isValid)
      return null;
    const O = D.toHsl(), F = {
      h: O.h,
      s: O.s * 100,
      l: O.l * 100,
      a: O.a
    }, U = D.toRgb(), W = D.toHexString(), B = D.toHex8String(), K = D.toHsv(), X = {
      h: K.h,
      s: K.s * 100,
      v: K.v * 100,
      a: K.a
    };
    return {
      hsl: {
        h: F.h,
        s: F.s,
        l: F.l,
        string: this.setLetterCase(`hsl(${Math.round(F.h)}, ${Math.round(F.s)}%, ${Math.round(F.l)}%)`)
      },
      hsla: {
        h: F.h,
        s: F.s,
        l: F.l,
        a: F.a,
        string: this.setLetterCase(
          `hsla(${Math.round(F.h)}, ${Math.round(F.s)}%, ${Math.round(F.l)}%, ${F.a.toFixed(2).toString()})`
        )
      },
      hsv: {
        h: X.h,
        s: X.s,
        v: X.v,
        string: this.setLetterCase(`hsv(${Math.round(X.h)}, ${Math.round(X.s)}%, ${Math.round(X.v)}%)`)
      },
      hsva: {
        h: X.h,
        s: X.s,
        v: X.v,
        a: X.a,
        string: this.setLetterCase(
          `hsva(${Math.round(X.h)}, ${Math.round(X.s)}%, ${Math.round(X.v)}%, ${X.a.toFixed(2).toString()})`
        )
      },
      rgb: {
        r: U.r,
        g: U.g,
        b: U.b,
        string: this.setLetterCase(`rgb(${Math.round(U.r)}, ${Math.round(U.g)}, ${Math.round(U.b)})`)
      },
      rgba: {
        r: U.r,
        g: U.g,
        b: U.b,
        a: U.a,
        string: this.setLetterCase(
          `rgba(${Math.round(U.r)}, ${Math.round(U.g)}, ${Math.round(U.b)}, ${U.a.toFixed(2).toString()})`
        )
      },
      hex: this.setLetterCase(W),
      hexa: this.setLetterCase(B)
    };
  }
  setColor(z) {
    const D = this.parseColor(z);
    return D === null ? !1 : (this.hue = D.hsva.h, this.saturation = D.hsva.s, this.brightness = D.hsva.v, this.alpha = this.opacity ? D.hsva.a * 100 : 100, this.syncValues(), !0);
  }
  setLetterCase(z) {
    return typeof z != "string" ? "" : this.uppercase ? z.toUpperCase() : z.toLowerCase();
  }
  async syncValues() {
    const z = this.parseColor(
      `hsva(${this.hue}, ${this.saturation}%, ${this.brightness}%, ${this.alpha / 100})`
    );
    z !== null && (this.format === "hsl" ? this.inputValue = this.opacity ? z.hsla.string : z.hsl.string : this.format === "rgb" ? this.inputValue = this.opacity ? z.rgba.string : z.rgb.string : this.format === "hsv" ? this.inputValue = this.opacity ? z.hsva.string : z.hsv.string : this.inputValue = this.opacity ? z.hexa : z.hex, this.isSafeValue = !0, this.value = this.inputValue, await this.updateComplete, this.isSafeValue = !1);
  }
  handleAfterHide() {
    this.previewButton.classList.remove("color-picker__preview-color--copied");
  }
  handleEyeDropper() {
    if (!hasEyeDropper)
      return;
    new EyeDropper().open().then((D) => {
      const O = this.value;
      this.setColor(D.sRGBHex), this.value !== O && (this.emit("sl-change"), this.emit("sl-input"));
    }).catch(() => {
    });
  }
  selectSwatch(z) {
    const D = this.value;
    this.disabled || (this.setColor(z), this.value !== D && (this.emit("sl-change"), this.emit("sl-input")));
  }
  /** Generates a hex string from HSV values. Hue must be 0-360. All other arguments must be 0-100. */
  getHexString(z, D, O, F = 100) {
    const U = new TinyColor(`hsva(${z}, ${D}%, ${O}%, ${F / 100})`);
    return U.isValid ? U.toHex8String() : "";
  }
  // Prevents nested components from leaking events
  stopNestedEventPropagation(z) {
    z.stopImmediatePropagation();
  }
  handleFormatChange() {
    this.syncValues();
  }
  handleOpacityChange() {
    this.alpha = 100;
  }
  handleValueChange(z, D) {
    if (this.isEmpty = !D, D || (this.hue = 0, this.saturation = 0, this.brightness = 100, this.alpha = 100), !this.isSafeValue) {
      const O = this.parseColor(D);
      O !== null ? (this.inputValue = this.value, this.hue = O.hsva.h, this.saturation = O.hsva.s, this.brightness = O.hsva.v, this.alpha = O.hsva.a * 100, this.syncValues()) : this.inputValue = z ?? "";
    }
  }
  /** Sets focus on the color picker. */
  focus(z) {
    this.inline ? this.base.focus(z) : this.trigger.focus(z);
  }
  /** Removes focus from the color picker. */
  blur() {
    var z;
    const D = this.inline ? this.base : this.trigger;
    this.hasFocus && (D.focus({ preventScroll: !0 }), D.blur()), (z = this.dropdown) != null && z.open && this.dropdown.hide();
  }
  /** Returns the current value as a string in the specified format. */
  getFormattedValue(z = "hex") {
    const D = this.parseColor(
      `hsva(${this.hue}, ${this.saturation}%, ${this.brightness}%, ${this.alpha / 100})`
    );
    if (D === null)
      return "";
    switch (z) {
      case "hex":
        return D.hex;
      case "hexa":
        return D.hexa;
      case "rgb":
        return D.rgb.string;
      case "rgba":
        return D.rgba.string;
      case "hsl":
        return D.hsl.string;
      case "hsla":
        return D.hsla.string;
      case "hsv":
        return D.hsv.string;
      case "hsva":
        return D.hsva.string;
      default:
        return "";
    }
  }
  /** Checks for validity but does not show a validation message. Returns `true` when valid and `false` when invalid. */
  checkValidity() {
    return this.input.checkValidity();
  }
  /** Gets the associated form, if one exists. */
  getForm() {
    return this.formControlController.getForm();
  }
  /** Checks for validity and shows the browser's validation message if the control is invalid. */
  reportValidity() {
    return !this.inline && !this.validity.valid ? (this.dropdown.show(), this.addEventListener("sl-after-show", () => this.input.reportValidity(), { once: !0 }), this.disabled || this.formControlController.emitInvalidEvent(), !1) : this.input.reportValidity();
  }
  /** Sets a custom validation message. Pass an empty string to restore validity. */
  setCustomValidity(z) {
    this.input.setCustomValidity(z), this.formControlController.updateValidity();
  }
  render() {
    const z = this.saturation, D = 100 - this.brightness, O = Array.isArray(this.swatches) ? this.swatches : this.swatches.split(";").filter((U) => U.trim() !== ""), F = x`
      <div
        part="base"
        class=${e$2({
      "color-picker": !0,
      "color-picker--inline": this.inline,
      "color-picker--disabled": this.disabled,
      "color-picker--focused": this.hasFocus
    })}
        aria-disabled=${this.disabled ? "true" : "false"}
        aria-labelledby="label"
        tabindex=${this.inline ? "0" : "-1"}
      >
        ${this.inline ? x`
              <sl-visually-hidden id="label">
                <slot name="label">${this.label}</slot>
              </sl-visually-hidden>
            ` : null}

        <div
          part="grid"
          class="color-picker__grid"
          style=${o$3({ backgroundColor: this.getHexString(this.hue, 100, 100) })}
          @pointerdown=${this.handleGridDrag}
          @touchmove=${this.handleTouchMove}
        >
          <span
            part="grid-handle"
            class=${e$2({
      "color-picker__grid-handle": !0,
      "color-picker__grid-handle--dragging": this.isDraggingGridHandle
    })}
            style=${o$3({
      top: `${D}%`,
      left: `${z}%`,
      backgroundColor: this.getHexString(this.hue, this.saturation, this.brightness, this.alpha)
    })}
            role="application"
            aria-label="HSV"
            tabindex=${o$6(this.disabled ? void 0 : "0")}
            @keydown=${this.handleGridKeyDown}
          ></span>
        </div>

        <div class="color-picker__controls">
          <div class="color-picker__sliders">
            <div
              part="slider hue-slider"
              class="color-picker__hue color-picker__slider"
              @pointerdown=${this.handleHueDrag}
              @touchmove=${this.handleTouchMove}
            >
              <span
                part="slider-handle hue-slider-handle"
                class="color-picker__slider-handle"
                style=${o$3({
      left: `${this.hue === 0 ? 0 : 100 / (360 / this.hue)}%`
    })}
                role="slider"
                aria-label="hue"
                aria-orientation="horizontal"
                aria-valuemin="0"
                aria-valuemax="360"
                aria-valuenow=${`${Math.round(this.hue)}`}
                tabindex=${o$6(this.disabled ? void 0 : "0")}
                @keydown=${this.handleHueKeyDown}
              ></span>
            </div>

            ${this.opacity ? x`
                  <div
                    part="slider opacity-slider"
                    class="color-picker__alpha color-picker__slider color-picker__transparent-bg"
                    @pointerdown="${this.handleAlphaDrag}"
                    @touchmove=${this.handleTouchMove}
                  >
                    <div
                      class="color-picker__alpha-gradient"
                      style=${o$3({
      backgroundImage: `linear-gradient(
                          to right,
                          ${this.getHexString(this.hue, this.saturation, this.brightness, 0)} 0%,
                          ${this.getHexString(this.hue, this.saturation, this.brightness, 100)} 100%
                        )`
    })}
                    ></div>
                    <span
                      part="slider-handle opacity-slider-handle"
                      class="color-picker__slider-handle"
                      style=${o$3({
      left: `${this.alpha}%`
    })}
                      role="slider"
                      aria-label="alpha"
                      aria-orientation="horizontal"
                      aria-valuemin="0"
                      aria-valuemax="100"
                      aria-valuenow=${Math.round(this.alpha)}
                      tabindex=${o$6(this.disabled ? void 0 : "0")}
                      @keydown=${this.handleAlphaKeyDown}
                    ></span>
                  </div>
                ` : ""}
          </div>

          <button
            type="button"
            part="preview"
            class="color-picker__preview color-picker__transparent-bg"
            aria-label=${this.localize.term("copy")}
            style=${o$3({
      "--preview-color": this.getHexString(this.hue, this.saturation, this.brightness, this.alpha)
    })}
            @click=${this.handleCopy}
          ></button>
        </div>

        <div class="color-picker__user-input" aria-live="polite">
          <sl-input
            part="input"
            type="text"
            name=${this.name}
            autocomplete="off"
            autocorrect="off"
            autocapitalize="off"
            spellcheck="false"
            value=${this.isEmpty ? "" : this.inputValue}
            ?required=${this.required}
            ?disabled=${this.disabled}
            aria-label=${this.localize.term("currentValue")}
            @keydown=${this.handleInputKeyDown}
            @sl-change=${this.handleInputChange}
            @sl-input=${this.handleInputInput}
            @sl-invalid=${this.handleInputInvalid}
            @sl-blur=${this.stopNestedEventPropagation}
            @sl-focus=${this.stopNestedEventPropagation}
          ></sl-input>

          <sl-button-group>
            ${this.noFormatToggle ? "" : x`
                  <sl-button
                    part="format-button"
                    aria-label=${this.localize.term("toggleColorFormat")}
                    exportparts="
                      base:format-button__base,
                      prefix:format-button__prefix,
                      label:format-button__label,
                      suffix:format-button__suffix,
                      caret:format-button__caret
                    "
                    @click=${this.handleFormatToggle}
                    @sl-blur=${this.stopNestedEventPropagation}
                    @sl-focus=${this.stopNestedEventPropagation}
                  >
                    ${this.setLetterCase(this.format)}
                  </sl-button>
                `}
            ${hasEyeDropper ? x`
                  <sl-button
                    part="eye-dropper-button"
                    exportparts="
                      base:eye-dropper-button__base,
                      prefix:eye-dropper-button__prefix,
                      label:eye-dropper-button__label,
                      suffix:eye-dropper-button__suffix,
                      caret:eye-dropper-button__caret
                    "
                    @click=${this.handleEyeDropper}
                    @sl-blur=${this.stopNestedEventPropagation}
                    @sl-focus=${this.stopNestedEventPropagation}
                  >
                    <sl-icon
                      library="system"
                      name="eyedropper"
                      label=${this.localize.term("selectAColorFromTheScreen")}
                    ></sl-icon>
                  </sl-button>
                ` : ""}
          </sl-button-group>
        </div>

        ${O.length > 0 ? x`
              <div part="swatches" class="color-picker__swatches">
                ${O.map((U) => {
      const W = this.parseColor(U);
      return W ? x`
                    <div
                      part="swatch"
                      class="color-picker__swatch color-picker__transparent-bg"
                      tabindex=${o$6(this.disabled ? void 0 : "0")}
                      role="button"
                      aria-label=${U}
                      @click=${() => this.selectSwatch(U)}
                      @keydown=${(B) => !this.disabled && B.key === "Enter" && this.setColor(W.hexa)}
                    >
                      <div
                        class="color-picker__swatch-color"
                        style=${o$3({ backgroundColor: W.hexa })}
                      ></div>
                    </div>
                  ` : (console.error(`Unable to parse swatch color: "${U}"`, this), "");
    })}
              </div>
            ` : ""}
      </div>
    `;
    return this.inline ? F : x`
      <sl-dropdown
        class="color-dropdown"
        aria-disabled=${this.disabled ? "true" : "false"}
        .containing-element=${this}
        ?disabled=${this.disabled}
        ?hoist=${this.hoist}
        @sl-after-hide=${this.handleAfterHide}
      >
        <button
          part="trigger"
          slot="trigger"
          class=${e$2({
      "color-dropdown__trigger": !0,
      "color-dropdown__trigger--disabled": this.disabled,
      "color-dropdown__trigger--small": this.size === "small",
      "color-dropdown__trigger--medium": this.size === "medium",
      "color-dropdown__trigger--large": this.size === "large",
      "color-dropdown__trigger--empty": this.isEmpty,
      "color-dropdown__trigger--focused": this.hasFocus,
      "color-picker__transparent-bg": !0
    })}
          style=${o$3({
      color: this.getHexString(this.hue, this.saturation, this.brightness, this.alpha)
    })}
          type="button"
        >
          <sl-visually-hidden>
            <slot name="label">${this.label}</slot>
          </sl-visually-hidden>
        </button>
        ${F}
      </sl-dropdown>
    `;
  }
};
SlColorPicker.styles = [component_styles_default, color_picker_styles_default];
SlColorPicker.dependencies = {
  "sl-button-group": SlButtonGroup,
  "sl-button": SlButton,
  "sl-dropdown": SlDropdown,
  "sl-icon": SlIcon,
  "sl-input": SlInput,
  "sl-visually-hidden": SlVisuallyHidden
};
__decorateClass([
  e$b('[part~="base"]')
], SlColorPicker.prototype, "base", 2);
__decorateClass([
  e$b('[part~="input"]')
], SlColorPicker.prototype, "input", 2);
__decorateClass([
  e$b(".color-dropdown")
], SlColorPicker.prototype, "dropdown", 2);
__decorateClass([
  e$b('[part~="preview"]')
], SlColorPicker.prototype, "previewButton", 2);
__decorateClass([
  e$b('[part~="trigger"]')
], SlColorPicker.prototype, "trigger", 2);
__decorateClass([
  r$4()
], SlColorPicker.prototype, "hasFocus", 2);
__decorateClass([
  r$4()
], SlColorPicker.prototype, "isDraggingGridHandle", 2);
__decorateClass([
  r$4()
], SlColorPicker.prototype, "isEmpty", 2);
__decorateClass([
  r$4()
], SlColorPicker.prototype, "inputValue", 2);
__decorateClass([
  r$4()
], SlColorPicker.prototype, "hue", 2);
__decorateClass([
  r$4()
], SlColorPicker.prototype, "saturation", 2);
__decorateClass([
  r$4()
], SlColorPicker.prototype, "brightness", 2);
__decorateClass([
  r$4()
], SlColorPicker.prototype, "alpha", 2);
__decorateClass([
  n$6()
], SlColorPicker.prototype, "value", 2);
__decorateClass([
  defaultValue()
], SlColorPicker.prototype, "defaultValue", 2);
__decorateClass([
  n$6()
], SlColorPicker.prototype, "label", 2);
__decorateClass([
  n$6()
], SlColorPicker.prototype, "format", 2);
__decorateClass([
  n$6({ type: Boolean, reflect: !0 })
], SlColorPicker.prototype, "inline", 2);
__decorateClass([
  n$6({ reflect: !0 })
], SlColorPicker.prototype, "size", 2);
__decorateClass([
  n$6({ attribute: "no-format-toggle", type: Boolean })
], SlColorPicker.prototype, "noFormatToggle", 2);
__decorateClass([
  n$6()
], SlColorPicker.prototype, "name", 2);
__decorateClass([
  n$6({ type: Boolean, reflect: !0 })
], SlColorPicker.prototype, "disabled", 2);
__decorateClass([
  n$6({ type: Boolean })
], SlColorPicker.prototype, "hoist", 2);
__decorateClass([
  n$6({ type: Boolean })
], SlColorPicker.prototype, "opacity", 2);
__decorateClass([
  n$6({ type: Boolean })
], SlColorPicker.prototype, "uppercase", 2);
__decorateClass([
  n$6()
], SlColorPicker.prototype, "swatches", 2);
__decorateClass([
  n$6({ reflect: !0 })
], SlColorPicker.prototype, "form", 2);
__decorateClass([
  n$6({ type: Boolean, reflect: !0 })
], SlColorPicker.prototype, "required", 2);
__decorateClass([
  t$4({ passive: !1 })
], SlColorPicker.prototype, "handleTouchMove", 1);
__decorateClass([
  watch("format", { waitUntilFirstUpdate: !0 })
], SlColorPicker.prototype, "handleFormatChange", 1);
__decorateClass([
  watch("opacity", { waitUntilFirstUpdate: !0 })
], SlColorPicker.prototype, "handleOpacityChange", 1);
__decorateClass([
  watch("value")
], SlColorPicker.prototype, "handleValueChange", 1);
SlColorPicker.define("sl-color-picker");
var card_styles_default = i$7`
  :host {
    --border-color: var(--sl-color-neutral-200);
    --border-radius: var(--sl-border-radius-medium);
    --border-width: 1px;
    --padding: var(--sl-spacing-large);

    display: inline-block;
  }

  .card {
    display: flex;
    flex-direction: column;
    background-color: var(--sl-panel-background-color);
    box-shadow: var(--sl-shadow-x-small);
    border: solid var(--border-width) var(--border-color);
    border-radius: var(--border-radius);
  }

  .card__image {
    display: flex;
    border-top-left-radius: var(--border-radius);
    border-top-right-radius: var(--border-radius);
    margin: calc(-1 * var(--border-width));
    overflow: hidden;
  }

  .card__image::slotted(img) {
    display: block;
    width: 100%;
  }

  .card:not(.card--has-image) .card__image {
    display: none;
  }

  .card__header {
    display: block;
    border-bottom: solid var(--border-width) var(--border-color);
    padding: calc(var(--padding) / 2) var(--padding);
  }

  .card:not(.card--has-header) .card__header {
    display: none;
  }

  .card:not(.card--has-image) .card__header {
    border-top-left-radius: var(--border-radius);
    border-top-right-radius: var(--border-radius);
  }

  .card__body {
    display: block;
    padding: var(--padding);
  }

  .card--has-footer .card__footer {
    display: block;
    border-top: solid var(--border-width) var(--border-color);
    padding: var(--padding);
  }

  .card:not(.card--has-footer) .card__footer {
    display: none;
  }
`, SlCard = class extends ShoelaceElement {
  constructor() {
    super(...arguments), this.hasSlotController = new HasSlotController(this, "footer", "header", "image");
  }
  render() {
    return x`
      <div
        part="base"
        class=${e$2({
      card: !0,
      "card--has-footer": this.hasSlotController.test("footer"),
      "card--has-image": this.hasSlotController.test("image"),
      "card--has-header": this.hasSlotController.test("header")
    })}
      >
        <slot name="image" part="image" class="card__image"></slot>
        <slot name="header" part="header" class="card__header"></slot>
        <slot part="body" class="card__body"></slot>
        <slot name="footer" part="footer" class="card__footer"></slot>
      </div>
    `;
  }
};
SlCard.styles = [component_styles_default, card_styles_default];
SlCard.define("sl-card");
var AutoplayController = class {
  constructor(z, D) {
    this.timerId = 0, this.activeInteractions = 0, this.paused = !1, this.stopped = !0, this.pause = () => {
      this.activeInteractions++ || (this.paused = !0, this.host.requestUpdate());
    }, this.resume = () => {
      --this.activeInteractions || (this.paused = !1, this.host.requestUpdate());
    }, z.addController(this), this.host = z, this.tickCallback = D;
  }
  hostConnected() {
    this.host.addEventListener("mouseenter", this.pause), this.host.addEventListener("mouseleave", this.resume), this.host.addEventListener("focusin", this.pause), this.host.addEventListener("focusout", this.resume), this.host.addEventListener("touchstart", this.pause, { passive: !0 }), this.host.addEventListener("touchend", this.resume);
  }
  hostDisconnected() {
    this.stop(), this.host.removeEventListener("mouseenter", this.pause), this.host.removeEventListener("mouseleave", this.resume), this.host.removeEventListener("focusin", this.pause), this.host.removeEventListener("focusout", this.resume), this.host.removeEventListener("touchstart", this.pause), this.host.removeEventListener("touchend", this.resume);
  }
  start(z) {
    this.stop(), this.stopped = !1, this.timerId = window.setInterval(() => {
      this.paused || this.tickCallback();
    }, z);
  }
  stop() {
    clearInterval(this.timerId), this.stopped = !0, this.host.requestUpdate();
  }
}, carousel_styles_default = i$7`
  :host {
    --slide-gap: var(--sl-spacing-medium, 1rem);
    --aspect-ratio: 16 / 9;
    --scroll-hint: 0px;

    display: flex;
  }

  .carousel {
    display: grid;
    grid-template-columns: min-content 1fr min-content;
    grid-template-rows: 1fr min-content;
    grid-template-areas:
      '. slides .'
      '. pagination .';
    gap: var(--sl-spacing-medium);
    align-items: center;
    min-height: 100%;
    min-width: 100%;
    position: relative;
  }

  .carousel__pagination {
    grid-area: pagination;
    display: flex;
    flex-wrap: wrap;
    justify-content: center;
    gap: var(--sl-spacing-small);
  }

  .carousel__slides {
    grid-area: slides;

    display: grid;
    height: 100%;
    width: 100%;
    align-items: center;
    justify-items: center;
    overflow: auto;
    overscroll-behavior-x: contain;
    scrollbar-width: none;
    aspect-ratio: calc(var(--aspect-ratio) * var(--slides-per-page));
    border-radius: var(--sl-border-radius-small);

    --slide-size: calc((100% - (var(--slides-per-page) - 1) * var(--slide-gap)) / var(--slides-per-page));
  }

  @media (prefers-reduced-motion) {
    :where(.carousel__slides) {
      scroll-behavior: auto;
    }
  }

  .carousel__slides--horizontal {
    grid-auto-flow: column;
    grid-auto-columns: var(--slide-size);
    grid-auto-rows: 100%;
    column-gap: var(--slide-gap);
    scroll-snap-type: x mandatory;
    scroll-padding-inline: var(--scroll-hint);
    padding-inline: var(--scroll-hint);
    overflow-y: hidden;
  }

  .carousel__slides--vertical {
    grid-auto-flow: row;
    grid-auto-columns: 100%;
    grid-auto-rows: var(--slide-size);
    row-gap: var(--slide-gap);
    scroll-snap-type: y mandatory;
    scroll-padding-block: var(--scroll-hint);
    padding-block: var(--scroll-hint);
    overflow-x: hidden;
  }

  .carousel__slides--dragging {
  }

  :host([vertical]) ::slotted(sl-carousel-item) {
    height: 100%;
  }

  .carousel__slides::-webkit-scrollbar {
    display: none;
  }

  .carousel__navigation {
    grid-area: navigation;
    display: contents;
    font-size: var(--sl-font-size-x-large);
  }

  .carousel__navigation-button {
    flex: 0 0 auto;
    display: flex;
    align-items: center;
    background: none;
    border: none;
    border-radius: var(--sl-border-radius-small);
    font-size: inherit;
    color: var(--sl-color-neutral-600);
    padding: var(--sl-spacing-x-small);
    cursor: pointer;
    transition: var(--sl-transition-medium) color;
    appearance: none;
  }

  .carousel__navigation-button--disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }

  .carousel__navigation-button--disabled::part(base) {
    pointer-events: none;
  }

  .carousel__navigation-button--previous {
    grid-column: 1;
    grid-row: 1;
  }

  .carousel__navigation-button--next {
    grid-column: 3;
    grid-row: 1;
  }

  .carousel__pagination-item {
    display: block;
    cursor: pointer;
    background: none;
    border: 0;
    border-radius: var(--sl-border-radius-circle);
    width: var(--sl-spacing-small);
    height: var(--sl-spacing-small);
    background-color: var(--sl-color-neutral-300);
    padding: 0;
    margin: 0;
  }

  .carousel__pagination-item--active {
    background-color: var(--sl-color-neutral-700);
    transform: scale(1.2);
  }

  /* Focus styles */
  .carousel__slides:focus-visible,
  .carousel__navigation-button:focus-visible,
  .carousel__pagination-item:focus-visible {
    outline: var(--sl-focus-ring);
    outline-offset: var(--sl-focus-ring-offset);
  }
`;
/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
function* o$1(z, D) {
  if (z !== void 0) {
    let O = 0;
    for (const F of z)
      yield D(F, O++);
  }
}
/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
function* o(z, D, O = 1) {
  const F = D === void 0 ? 0 : z;
  D ?? (D = z);
  for (let U = F; O > 0 ? U < D : D < U; U += O)
    yield U;
}
var debounce = (z, D) => {
  let O = 0;
  return function(...F) {
    window.clearTimeout(O), O = window.setTimeout(() => {
      z.call(this, ...F);
    }, D);
  };
}, decorate = (z, D, O) => {
  const F = z[D];
  z[D] = function(...U) {
    F.call(this, ...U), O.call(this, F, ...U);
  };
}, isSupported = "onscrollend" in window;
if (!isSupported) {
  const z = /* @__PURE__ */ new Set(), D = /* @__PURE__ */ new WeakMap(), O = (U) => {
    for (const W of U.changedTouches)
      z.add(W.identifier);
  }, F = (U) => {
    for (const W of U.changedTouches)
      z.delete(W.identifier);
  };
  document.addEventListener("touchstart", O, !0), document.addEventListener("touchend", F, !0), document.addEventListener("touchcancel", F, !0), decorate(EventTarget.prototype, "addEventListener", function(U, W) {
    if (W !== "scrollend")
      return;
    const B = debounce(() => {
      z.size ? B() : this.dispatchEvent(new Event("scrollend"));
    }, 100);
    U.call(this, "scroll", B, { passive: !0 }), D.set(this, B);
  }), decorate(EventTarget.prototype, "removeEventListener", function(U, W) {
    if (W !== "scrollend")
      return;
    const B = D.get(this);
    B && U.call(this, "scroll", B, { passive: !0 });
  });
}
var SlCarousel = class extends ShoelaceElement {
  constructor() {
    super(...arguments), this.loop = !1, this.navigation = !1, this.pagination = !1, this.autoplay = !1, this.autoplayInterval = 3e3, this.slidesPerPage = 1, this.slidesPerMove = 1, this.orientation = "horizontal", this.mouseDragging = !1, this.activeSlide = 0, this.scrolling = !1, this.dragging = !1, this.autoplayController = new AutoplayController(this, () => this.next()), this.localize = new LocalizeController(this), this.handleMouseDrag = (z) => {
      this.dragging || (this.scrollContainer.style.setProperty("scroll-snap-type", "none"), this.dragging = !0), this.scrollContainer.scrollBy({
        left: -z.movementX,
        top: -z.movementY,
        behavior: "instant"
      });
    }, this.handleMouseDragEnd = () => {
      const z = this.scrollContainer;
      document.removeEventListener("pointermove", this.handleMouseDrag, { capture: !0 });
      const D = z.scrollLeft, O = z.scrollTop;
      z.style.removeProperty("scroll-snap-type"), z.style.setProperty("overflow", "hidden");
      const F = z.scrollLeft, U = z.scrollTop;
      z.style.removeProperty("overflow"), z.style.setProperty("scroll-snap-type", "none"), z.scrollTo({ left: D, top: O, behavior: "instant" }), requestAnimationFrame(async () => {
        (D !== F || O !== U) && (z.scrollTo({
          left: F,
          top: U,
          behavior: prefersReducedMotion() ? "auto" : "smooth"
        }), await waitForEvent(z, "scrollend")), z.style.removeProperty("scroll-snap-type"), this.dragging = !1, this.handleScrollEnd();
      });
    }, this.handleSlotChange = (z) => {
      z.some(
        (O) => [...O.addedNodes, ...O.removedNodes].some(
          (F) => this.isCarouselItem(F) && !F.hasAttribute("data-clone")
        )
      ) && this.initializeSlides(), this.requestUpdate();
    };
  }
  connectedCallback() {
    super.connectedCallback(), this.setAttribute("role", "region"), this.setAttribute("aria-label", this.localize.term("carousel"));
  }
  disconnectedCallback() {
    super.disconnectedCallback(), this.mutationObserver.disconnect();
  }
  firstUpdated() {
    this.initializeSlides(), this.mutationObserver = new MutationObserver(this.handleSlotChange), this.mutationObserver.observe(this, {
      childList: !0,
      subtree: !0
    });
  }
  willUpdate(z) {
    (z.has("slidesPerMove") || z.has("slidesPerPage")) && (this.slidesPerMove = Math.min(this.slidesPerMove, this.slidesPerPage));
  }
  getPageCount() {
    const z = this.getSlides().length, { slidesPerPage: D, slidesPerMove: O, loop: F } = this, U = F ? z / O : (z - D) / O + 1;
    return Math.ceil(U);
  }
  getCurrentPage() {
    return Math.ceil(this.activeSlide / this.slidesPerMove);
  }
  canScrollNext() {
    return this.loop || this.getCurrentPage() < this.getPageCount() - 1;
  }
  canScrollPrev() {
    return this.loop || this.getCurrentPage() > 0;
  }
  /** @internal Gets all carousel items. */
  getSlides({ excludeClones: z = !0 } = {}) {
    return [...this.children].filter(
      (D) => this.isCarouselItem(D) && (!z || !D.hasAttribute("data-clone"))
    );
  }
  handleKeyDown(z) {
    if (["ArrowLeft", "ArrowRight", "ArrowUp", "ArrowDown", "Home", "End"].includes(z.key)) {
      const D = z.target, O = this.localize.dir() === "rtl", F = D.closest('[part~="pagination-item"]') !== null, U = z.key === "ArrowDown" || !O && z.key === "ArrowRight" || O && z.key === "ArrowLeft", W = z.key === "ArrowUp" || !O && z.key === "ArrowLeft" || O && z.key === "ArrowRight";
      z.preventDefault(), W && this.previous(), U && this.next(), z.key === "Home" && this.goToSlide(0), z.key === "End" && this.goToSlide(this.getSlides().length - 1), F && this.updateComplete.then(() => {
        var B;
        const K = (B = this.shadowRoot) == null ? void 0 : B.querySelector(
          '[part~="pagination-item--active"]'
        );
        K && K.focus();
      });
    }
  }
  handleMouseDragStart(z) {
    this.mouseDragging && z.button === 0 && (z.preventDefault(), document.addEventListener("pointermove", this.handleMouseDrag, { capture: !0, passive: !0 }), document.addEventListener("pointerup", this.handleMouseDragEnd, { capture: !0, once: !0 }));
  }
  handleScroll() {
    this.scrolling = !0;
  }
  /** @internal Synchronizes the slides with the IntersectionObserver API. */
  synchronizeSlides() {
    const z = new IntersectionObserver(
      (D) => {
        z.disconnect();
        for (const F of D) {
          const U = F.target;
          U.toggleAttribute("inert", !F.isIntersecting), U.classList.toggle("--in-view", F.isIntersecting), U.setAttribute("aria-hidden", F.isIntersecting ? "false" : "true");
        }
        const O = D.find((F) => F.isIntersecting);
        if (O)
          if (this.loop && O.target.hasAttribute("data-clone")) {
            const F = Number(O.target.getAttribute("data-clone"));
            this.goToSlide(F, "instant");
          } else {
            const U = this.getSlides().indexOf(O.target);
            this.activeSlide = Math.ceil(U / this.slidesPerMove) * this.slidesPerMove;
          }
      },
      {
        root: this.scrollContainer,
        threshold: 0.6
      }
    );
    this.getSlides({ excludeClones: !1 }).forEach((D) => {
      z.observe(D);
    });
  }
  handleScrollEnd() {
    !this.scrolling || this.dragging || (this.synchronizeSlides(), this.scrolling = !1);
  }
  isCarouselItem(z) {
    return z instanceof Element && z.tagName.toLowerCase() === "sl-carousel-item";
  }
  initializeSlides() {
    this.getSlides({ excludeClones: !1 }).forEach((z, D) => {
      z.classList.remove("--in-view"), z.classList.remove("--is-active"), z.setAttribute("aria-label", this.localize.term("slideNum", D + 1)), z.hasAttribute("data-clone") && z.remove();
    }), this.updateSlidesSnap(), this.loop && this.createClones(), this.synchronizeSlides(), this.goToSlide(this.activeSlide, "auto");
  }
  createClones() {
    const z = this.getSlides(), D = this.slidesPerPage, O = z.slice(-D), F = z.slice(0, D);
    O.reverse().forEach((U, W) => {
      const B = U.cloneNode(!0);
      B.setAttribute("data-clone", String(z.length - W - 1)), this.prepend(B);
    }), F.forEach((U, W) => {
      const B = U.cloneNode(!0);
      B.setAttribute("data-clone", String(W)), this.append(B);
    });
  }
  handelSlideChange() {
    const z = this.getSlides();
    z.forEach((D, O) => {
      D.classList.toggle("--is-active", O === this.activeSlide);
    }), this.hasUpdated && this.emit("sl-slide-change", {
      detail: {
        index: this.activeSlide,
        slide: z[this.activeSlide]
      }
    });
  }
  updateSlidesSnap() {
    const z = this.getSlides(), D = this.slidesPerMove;
    z.forEach((O, F) => {
      (F + D) % D === 0 ? O.style.removeProperty("scroll-snap-align") : O.style.setProperty("scroll-snap-align", "none");
    });
  }
  handleAutoplayChange() {
    this.autoplayController.stop(), this.autoplay && this.autoplayController.start(this.autoplayInterval);
  }
  /**
   * Move the carousel backward by `slides-per-move` slides.
   *
   * @param behavior - The behavior used for scrolling.
   */
  previous(z = "smooth") {
    this.goToSlide(this.activeSlide - this.slidesPerMove, z);
  }
  /**
   * Move the carousel forward by `slides-per-move` slides.
   *
   * @param behavior - The behavior used for scrolling.
   */
  next(z = "smooth") {
    this.goToSlide(this.activeSlide + this.slidesPerMove, z);
  }
  /**
   * Scrolls the carousel to the slide specified by `index`.
   *
   * @param index - The slide index.
   * @param behavior - The behavior used for scrolling.
   */
  goToSlide(z, D = "smooth") {
    const { slidesPerPage: O, loop: F } = this, U = this.getSlides(), W = this.getSlides({ excludeClones: !1 });
    if (!U.length)
      return;
    const B = F ? (z + U.length) % U.length : clamp$1(z, 0, U.length - 1);
    this.activeSlide = B;
    const K = clamp$1(z + (F ? O : 0), 0, W.length - 1), X = W[K];
    this.scrollToSlide(X, prefersReducedMotion() ? "auto" : D);
  }
  scrollToSlide(z, D = "smooth") {
    const O = this.scrollContainer, F = O.getBoundingClientRect(), U = z.getBoundingClientRect(), W = U.left - F.left, B = U.top - F.top;
    O.scrollTo({
      left: W + O.scrollLeft,
      top: B + O.scrollTop,
      behavior: D
    });
  }
  render() {
    const { slidesPerMove: z, scrolling: D } = this, O = this.getPageCount(), F = this.getCurrentPage(), U = this.canScrollPrev(), W = this.canScrollNext(), B = this.localize.dir() === "ltr";
    return x`
      <div part="base" class="carousel">
        <div
          id="scroll-container"
          part="scroll-container"
          class="${e$2({
      carousel__slides: !0,
      "carousel__slides--horizontal": this.orientation === "horizontal",
      "carousel__slides--vertical": this.orientation === "vertical",
      "carousel__slides--dragging": this.dragging
    })}"
          style="--slides-per-page: ${this.slidesPerPage};"
          aria-busy="${D ? "true" : "false"}"
          aria-atomic="true"
          tabindex="0"
          @keydown=${this.handleKeyDown}
          @mousedown="${this.handleMouseDragStart}"
          @scroll="${this.handleScroll}"
          @scrollend=${this.handleScrollEnd}
        >
          <slot></slot>
        </div>

        ${this.navigation ? x`
              <div part="navigation" class="carousel__navigation">
                <button
                  part="navigation-button navigation-button--previous"
                  class="${e$2({
      "carousel__navigation-button": !0,
      "carousel__navigation-button--previous": !0,
      "carousel__navigation-button--disabled": !U
    })}"
                  aria-label="${this.localize.term("previousSlide")}"
                  aria-controls="scroll-container"
                  aria-disabled="${U ? "false" : "true"}"
                  @click=${U ? () => this.previous() : null}
                >
                  <slot name="previous-icon">
                    <sl-icon library="system" name="${B ? "chevron-left" : "chevron-right"}"></sl-icon>
                  </slot>
                </button>

                <button
                  part="navigation-button navigation-button--next"
                  class=${e$2({
      "carousel__navigation-button": !0,
      "carousel__navigation-button--next": !0,
      "carousel__navigation-button--disabled": !W
    })}
                  aria-label="${this.localize.term("nextSlide")}"
                  aria-controls="scroll-container"
                  aria-disabled="${W ? "false" : "true"}"
                  @click=${W ? () => this.next() : null}
                >
                  <slot name="next-icon">
                    <sl-icon library="system" name="${B ? "chevron-right" : "chevron-left"}"></sl-icon>
                  </slot>
                </button>
              </div>
            ` : ""}
        ${this.pagination ? x`
              <div part="pagination" role="tablist" class="carousel__pagination" aria-controls="scroll-container">
                ${o$1(o(O), (K) => {
      const X = K === F;
      return x`
                    <button
                      part="pagination-item ${X ? "pagination-item--active" : ""}"
                      class="${e$2({
        "carousel__pagination-item": !0,
        "carousel__pagination-item--active": X
      })}"
                      role="tab"
                      aria-selected="${X ? "true" : "false"}"
                      aria-label="${this.localize.term("goToSlide", K + 1, O)}"
                      tabindex=${X ? "0" : "-1"}
                      @click=${() => this.goToSlide(K * z)}
                      @keydown=${this.handleKeyDown}
                    ></button>
                  `;
    })}
              </div>
            ` : ""}
      </div>
    `;
  }
};
SlCarousel.styles = [component_styles_default, carousel_styles_default];
SlCarousel.dependencies = { "sl-icon": SlIcon };
__decorateClass([
  n$6({ type: Boolean, reflect: !0 })
], SlCarousel.prototype, "loop", 2);
__decorateClass([
  n$6({ type: Boolean, reflect: !0 })
], SlCarousel.prototype, "navigation", 2);
__decorateClass([
  n$6({ type: Boolean, reflect: !0 })
], SlCarousel.prototype, "pagination", 2);
__decorateClass([
  n$6({ type: Boolean, reflect: !0 })
], SlCarousel.prototype, "autoplay", 2);
__decorateClass([
  n$6({ type: Number, attribute: "autoplay-interval" })
], SlCarousel.prototype, "autoplayInterval", 2);
__decorateClass([
  n$6({ type: Number, attribute: "slides-per-page" })
], SlCarousel.prototype, "slidesPerPage", 2);
__decorateClass([
  n$6({ type: Number, attribute: "slides-per-move" })
], SlCarousel.prototype, "slidesPerMove", 2);
__decorateClass([
  n$6()
], SlCarousel.prototype, "orientation", 2);
__decorateClass([
  n$6({ type: Boolean, reflect: !0, attribute: "mouse-dragging" })
], SlCarousel.prototype, "mouseDragging", 2);
__decorateClass([
  e$b(".carousel__slides")
], SlCarousel.prototype, "scrollContainer", 2);
__decorateClass([
  e$b(".carousel__pagination")
], SlCarousel.prototype, "paginationContainer", 2);
__decorateClass([
  r$4()
], SlCarousel.prototype, "activeSlide", 2);
__decorateClass([
  r$4()
], SlCarousel.prototype, "scrolling", 2);
__decorateClass([
  r$4()
], SlCarousel.prototype, "dragging", 2);
__decorateClass([
  t$4({ passive: !0 })
], SlCarousel.prototype, "handleScroll", 1);
__decorateClass([
  watch("loop", { waitUntilFirstUpdate: !0 }),
  watch("slidesPerPage", { waitUntilFirstUpdate: !0 })
], SlCarousel.prototype, "initializeSlides", 1);
__decorateClass([
  watch("activeSlide")
], SlCarousel.prototype, "handelSlideChange", 1);
__decorateClass([
  watch("slidesPerMove")
], SlCarousel.prototype, "updateSlidesSnap", 1);
__decorateClass([
  watch("autoplay")
], SlCarousel.prototype, "handleAutoplayChange", 1);
SlCarousel.define("sl-carousel");
var carousel_item_styles_default = i$7`
  :host {
    --aspect-ratio: inherit;

    display: flex;
    align-items: center;
    justify-content: center;
    flex-direction: column;
    width: 100%;
    max-height: 100%;
    aspect-ratio: var(--aspect-ratio);
    scroll-snap-align: start;
    scroll-snap-stop: always;
  }

  ::slotted(img) {
    width: 100% !important;
    height: 100% !important;
    object-fit: cover;
  }
`, SlCarouselItem = class extends ShoelaceElement {
  connectedCallback() {
    super.connectedCallback(), this.setAttribute("role", "group");
  }
  render() {
    return x` <slot></slot> `;
  }
};
SlCarouselItem.styles = [component_styles_default, carousel_item_styles_default];
SlCarouselItem.define("sl-carousel-item");
var avatar_styles_default = i$7`
  :host {
    display: inline-block;

    --size: 3rem;
  }

  .avatar {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    position: relative;
    width: var(--size);
    height: var(--size);
    background-color: var(--sl-color-neutral-400);
    font-family: var(--sl-font-sans);
    font-size: calc(var(--size) * 0.5);
    font-weight: var(--sl-font-weight-normal);
    color: var(--sl-color-neutral-0);
    user-select: none;
    -webkit-user-select: none;
    vertical-align: middle;
  }

  .avatar--circle,
  .avatar--circle .avatar__image {
    border-radius: var(--sl-border-radius-circle);
  }

  .avatar--rounded,
  .avatar--rounded .avatar__image {
    border-radius: var(--sl-border-radius-medium);
  }

  .avatar--square {
    border-radius: 0;
  }

  .avatar__icon {
    display: flex;
    align-items: center;
    justify-content: center;
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
  }

  .avatar__initials {
    line-height: 1;
    text-transform: uppercase;
  }

  .avatar__image {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    object-fit: cover;
    overflow: hidden;
  }
`, SlAvatar = class extends ShoelaceElement {
  constructor() {
    super(...arguments), this.hasError = !1, this.image = "", this.label = "", this.initials = "", this.loading = "eager", this.shape = "circle";
  }
  handleImageChange() {
    this.hasError = !1;
  }
  render() {
    const z = x`
      <img
        part="image"
        class="avatar__image"
        src="${this.image}"
        loading="${this.loading}"
        alt=""
        @error="${() => this.hasError = !0}"
      />
    `;
    let D = x``;
    return this.initials ? D = x`<div part="initials" class="avatar__initials">${this.initials}</div>` : D = x`
        <div part="icon" class="avatar__icon" aria-hidden="true">
          <slot name="icon">
            <sl-icon name="person-fill" library="system"></sl-icon>
          </slot>
        </div>
      `, x`
      <div
        part="base"
        class=${e$2({
      avatar: !0,
      "avatar--circle": this.shape === "circle",
      "avatar--rounded": this.shape === "rounded",
      "avatar--square": this.shape === "square"
    })}
        role="img"
        aria-label=${this.label}
      >
        ${this.image && !this.hasError ? z : D}
      </div>
    `;
  }
};
SlAvatar.styles = [component_styles_default, avatar_styles_default];
SlAvatar.dependencies = {
  "sl-icon": SlIcon
};
__decorateClass([
  r$4()
], SlAvatar.prototype, "hasError", 2);
__decorateClass([
  n$6()
], SlAvatar.prototype, "image", 2);
__decorateClass([
  n$6()
], SlAvatar.prototype, "label", 2);
__decorateClass([
  n$6()
], SlAvatar.prototype, "initials", 2);
__decorateClass([
  n$6()
], SlAvatar.prototype, "loading", 2);
__decorateClass([
  n$6({ reflect: !0 })
], SlAvatar.prototype, "shape", 2);
__decorateClass([
  watch("image")
], SlAvatar.prototype, "handleImageChange", 1);
SlAvatar.define("sl-avatar");
var animated_image_styles_default = i$7`
  :host {
    --control-box-size: 3rem;
    --icon-size: calc(var(--control-box-size) * 0.625);

    display: inline-flex;
    position: relative;
    cursor: pointer;
  }

  img {
    display: block;
    width: 100%;
    height: 100%;
  }

  img[aria-hidden='true'] {
    display: none;
  }

  .animated-image__control-box {
    display: flex;
    position: absolute;
    align-items: center;
    justify-content: center;
    top: calc(50% - var(--control-box-size) / 2);
    right: calc(50% - var(--control-box-size) / 2);
    width: var(--control-box-size);
    height: var(--control-box-size);
    font-size: var(--icon-size);
    background: none;
    border: solid 2px currentColor;
    background-color: rgb(0 0 0 /50%);
    border-radius: var(--sl-border-radius-circle);
    color: white;
    pointer-events: none;
    transition: var(--sl-transition-fast) opacity;
  }

  :host([play]:hover) .animated-image__control-box {
    opacity: 1;
  }

  :host([play]:not(:hover)) .animated-image__control-box {
    opacity: 0;
  }

  :host([play]) slot[name='play-icon'],
  :host(:not([play])) slot[name='pause-icon'] {
    display: none;
  }
`, SlAnimatedImage = class extends ShoelaceElement {
  constructor() {
    super(...arguments), this.isLoaded = !1;
  }
  handleClick() {
    this.play = !this.play;
  }
  handleLoad() {
    const z = document.createElement("canvas"), { width: D, height: O } = this.animatedImage;
    z.width = D, z.height = O, z.getContext("2d").drawImage(this.animatedImage, 0, 0, D, O), this.frozenFrame = z.toDataURL("image/gif"), this.isLoaded || (this.emit("sl-load"), this.isLoaded = !0);
  }
  handleError() {
    this.emit("sl-error");
  }
  handlePlayChange() {
    this.play && (this.animatedImage.src = "", this.animatedImage.src = this.src);
  }
  handleSrcChange() {
    this.isLoaded = !1;
  }
  render() {
    return x`
      <div class="animated-image">
        <img
          class="animated-image__animated"
          src=${this.src}
          alt=${this.alt}
          crossorigin="anonymous"
          aria-hidden=${this.play ? "false" : "true"}
          @click=${this.handleClick}
          @load=${this.handleLoad}
          @error=${this.handleError}
        />

        ${this.isLoaded ? x`
              <img
                class="animated-image__frozen"
                src=${this.frozenFrame}
                alt=${this.alt}
                aria-hidden=${this.play ? "true" : "false"}
                @click=${this.handleClick}
              />

              <div part="control-box" class="animated-image__control-box">
                <slot name="play-icon"><sl-icon name="play-fill" library="system"></sl-icon></slot>
                <slot name="pause-icon"><sl-icon name="pause-fill" library="system"></sl-icon></slot>
              </div>
            ` : ""}
      </div>
    `;
  }
};
SlAnimatedImage.styles = [component_styles_default, animated_image_styles_default];
SlAnimatedImage.dependencies = { "sl-icon": SlIcon };
__decorateClass([
  e$b(".animated-image__animated")
], SlAnimatedImage.prototype, "animatedImage", 2);
__decorateClass([
  r$4()
], SlAnimatedImage.prototype, "frozenFrame", 2);
__decorateClass([
  r$4()
], SlAnimatedImage.prototype, "isLoaded", 2);
__decorateClass([
  n$6()
], SlAnimatedImage.prototype, "src", 2);
__decorateClass([
  n$6()
], SlAnimatedImage.prototype, "alt", 2);
__decorateClass([
  n$6({ type: Boolean, reflect: !0 })
], SlAnimatedImage.prototype, "play", 2);
__decorateClass([
  watch("play", { waitUntilFirstUpdate: !0 })
], SlAnimatedImage.prototype, "handlePlayChange", 1);
__decorateClass([
  watch("src")
], SlAnimatedImage.prototype, "handleSrcChange", 1);
SlAnimatedImage.define("sl-animated-image");
var breadcrumb_item_styles_default = i$7`
  :host {
    display: inline-flex;
  }

  .breadcrumb-item {
    display: inline-flex;
    align-items: center;
    font-family: var(--sl-font-sans);
    font-size: var(--sl-font-size-small);
    font-weight: var(--sl-font-weight-semibold);
    color: var(--sl-color-neutral-600);
    line-height: var(--sl-line-height-normal);
    white-space: nowrap;
  }

  .breadcrumb-item__label {
    display: inline-block;
    font-family: inherit;
    font-size: inherit;
    font-weight: inherit;
    line-height: inherit;
    text-decoration: none;
    color: inherit;
    background: none;
    border: none;
    border-radius: var(--sl-border-radius-medium);
    padding: 0;
    margin: 0;
    cursor: pointer;
    transition: var(--sl-transition-fast) --color;
  }

  :host(:not(:last-of-type)) .breadcrumb-item__label {
    color: var(--sl-color-primary-600);
  }

  :host(:not(:last-of-type)) .breadcrumb-item__label:hover {
    color: var(--sl-color-primary-500);
  }

  :host(:not(:last-of-type)) .breadcrumb-item__label:active {
    color: var(--sl-color-primary-600);
  }

  .breadcrumb-item__label:focus {
    outline: none;
  }

  .breadcrumb-item__label:focus-visible {
    outline: var(--sl-focus-ring);
    outline-offset: var(--sl-focus-ring-offset);
  }

  .breadcrumb-item__prefix,
  .breadcrumb-item__suffix {
    display: none;
    flex: 0 0 auto;
    display: flex;
    align-items: center;
  }

  .breadcrumb-item--has-prefix .breadcrumb-item__prefix {
    display: inline-flex;
    margin-inline-end: var(--sl-spacing-x-small);
  }

  .breadcrumb-item--has-suffix .breadcrumb-item__suffix {
    display: inline-flex;
    margin-inline-start: var(--sl-spacing-x-small);
  }

  :host(:last-of-type) .breadcrumb-item__separator {
    display: none;
  }

  .breadcrumb-item__separator {
    display: inline-flex;
    align-items: center;
    margin: 0 var(--sl-spacing-x-small);
    user-select: none;
    -webkit-user-select: none;
  }
`, SlBreadcrumbItem = class extends ShoelaceElement {
  constructor() {
    super(...arguments), this.hasSlotController = new HasSlotController(this, "prefix", "suffix"), this.rel = "noreferrer noopener";
  }
  render() {
    const z = !!this.href;
    return x`
      <div
        part="base"
        class=${e$2({
      "breadcrumb-item": !0,
      "breadcrumb-item--has-prefix": this.hasSlotController.test("prefix"),
      "breadcrumb-item--has-suffix": this.hasSlotController.test("suffix")
    })}
      >
        <span part="prefix" class="breadcrumb-item__prefix">
          <slot name="prefix"></slot>
        </span>

        ${z ? x`
              <a
                part="label"
                class="breadcrumb-item__label breadcrumb-item__label--link"
                href="${this.href}"
                target="${o$6(this.target ? this.target : void 0)}"
                rel=${o$6(this.target ? this.rel : void 0)}
              >
                <slot></slot>
              </a>
            ` : x`
              <button part="label" type="button" class="breadcrumb-item__label breadcrumb-item__label--button">
                <slot></slot>
              </button>
            `}

        <span part="suffix" class="breadcrumb-item__suffix">
          <slot name="suffix"></slot>
        </span>

        <span part="separator" class="breadcrumb-item__separator" aria-hidden="true">
          <slot name="separator"></slot>
        </span>
      </div>
    `;
  }
};
SlBreadcrumbItem.styles = [component_styles_default, breadcrumb_item_styles_default];
__decorateClass([
  n$6()
], SlBreadcrumbItem.prototype, "href", 2);
__decorateClass([
  n$6()
], SlBreadcrumbItem.prototype, "target", 2);
__decorateClass([
  n$6()
], SlBreadcrumbItem.prototype, "rel", 2);
SlBreadcrumbItem.define("sl-breadcrumb-item");
SlButton.define("sl-button");
SlButtonGroup.define("sl-button-group");
var animation_styles_default = i$7`
  :host {
    display: contents;
  }
`;
const bounce = [
  { offset: 0, easing: "cubic-bezier(0.215, 0.61, 0.355, 1)", transform: "translate3d(0, 0, 0)" },
  { offset: 0.2, easing: "cubic-bezier(0.215, 0.61, 0.355, 1)", transform: "translate3d(0, 0, 0)" },
  { offset: 0.4, easing: "cubic-bezier(0.755, 0.05, 0.855, 0.06)", transform: "translate3d(0, -30px, 0) scaleY(1.1)" },
  { offset: 0.43, easing: "cubic-bezier(0.755, 0.05, 0.855, 0.06)", transform: "translate3d(0, -30px, 0) scaleY(1.1)" },
  { offset: 0.53, easing: "cubic-bezier(0.215, 0.61, 0.355, 1)", transform: "translate3d(0, 0, 0)" },
  { offset: 0.7, easing: "cubic-bezier(0.755, 0.05, 0.855, 0.06)", transform: "translate3d(0, -15px, 0) scaleY(1.05)" },
  {
    offset: 0.8,
    "transition-timing-function": "cubic-bezier(0.215, 0.61, 0.355, 1)",
    transform: "translate3d(0, 0, 0) scaleY(0.95)"
  },
  { offset: 0.9, transform: "translate3d(0, -4px, 0) scaleY(1.02)" },
  { offset: 1, easing: "cubic-bezier(0.215, 0.61, 0.355, 1)", transform: "translate3d(0, 0, 0)" }
], flash = [
  { offset: 0, opacity: "1" },
  { offset: 0.25, opacity: "0" },
  { offset: 0.5, opacity: "1" },
  { offset: 0.75, opacity: "0" },
  { offset: 1, opacity: "1" }
], headShake = [
  { offset: 0, transform: "translateX(0)" },
  { offset: 0.065, transform: "translateX(-6px) rotateY(-9deg)" },
  { offset: 0.185, transform: "translateX(5px) rotateY(7deg)" },
  { offset: 0.315, transform: "translateX(-3px) rotateY(-5deg)" },
  { offset: 0.435, transform: "translateX(2px) rotateY(3deg)" },
  { offset: 0.5, transform: "translateX(0)" }
], heartBeat = [
  { offset: 0, transform: "scale(1)" },
  { offset: 0.14, transform: "scale(1.3)" },
  { offset: 0.28, transform: "scale(1)" },
  { offset: 0.42, transform: "scale(1.3)" },
  { offset: 0.7, transform: "scale(1)" }
], jello = [
  { offset: 0, transform: "translate3d(0, 0, 0)" },
  { offset: 0.111, transform: "translate3d(0, 0, 0)" },
  { offset: 0.222, transform: "skewX(-12.5deg) skewY(-12.5deg)" },
  { offset: 0.33299999999999996, transform: "skewX(6.25deg) skewY(6.25deg)" },
  { offset: 0.444, transform: "skewX(-3.125deg) skewY(-3.125deg)" },
  { offset: 0.555, transform: "skewX(1.5625deg) skewY(1.5625deg)" },
  { offset: 0.6659999999999999, transform: "skewX(-0.78125deg) skewY(-0.78125deg)" },
  { offset: 0.777, transform: "skewX(0.390625deg) skewY(0.390625deg)" },
  { offset: 0.888, transform: "skewX(-0.1953125deg) skewY(-0.1953125deg)" },
  { offset: 1, transform: "translate3d(0, 0, 0)" }
], pulse = [
  { offset: 0, transform: "scale3d(1, 1, 1)" },
  { offset: 0.5, transform: "scale3d(1.05, 1.05, 1.05)" },
  { offset: 1, transform: "scale3d(1, 1, 1)" }
], rubberBand = [
  { offset: 0, transform: "scale3d(1, 1, 1)" },
  { offset: 0.3, transform: "scale3d(1.25, 0.75, 1)" },
  { offset: 0.4, transform: "scale3d(0.75, 1.25, 1)" },
  { offset: 0.5, transform: "scale3d(1.15, 0.85, 1)" },
  { offset: 0.65, transform: "scale3d(0.95, 1.05, 1)" },
  { offset: 0.75, transform: "scale3d(1.05, 0.95, 1)" },
  { offset: 1, transform: "scale3d(1, 1, 1)" }
], shake = [
  { offset: 0, transform: "translate3d(0, 0, 0)" },
  { offset: 0.1, transform: "translate3d(-10px, 0, 0)" },
  { offset: 0.2, transform: "translate3d(10px, 0, 0)" },
  { offset: 0.3, transform: "translate3d(-10px, 0, 0)" },
  { offset: 0.4, transform: "translate3d(10px, 0, 0)" },
  { offset: 0.5, transform: "translate3d(-10px, 0, 0)" },
  { offset: 0.6, transform: "translate3d(10px, 0, 0)" },
  { offset: 0.7, transform: "translate3d(-10px, 0, 0)" },
  { offset: 0.8, transform: "translate3d(10px, 0, 0)" },
  { offset: 0.9, transform: "translate3d(-10px, 0, 0)" },
  { offset: 1, transform: "translate3d(0, 0, 0)" }
], shakeX = [
  { offset: 0, transform: "translate3d(0, 0, 0)" },
  { offset: 0.1, transform: "translate3d(-10px, 0, 0)" },
  { offset: 0.2, transform: "translate3d(10px, 0, 0)" },
  { offset: 0.3, transform: "translate3d(-10px, 0, 0)" },
  { offset: 0.4, transform: "translate3d(10px, 0, 0)" },
  { offset: 0.5, transform: "translate3d(-10px, 0, 0)" },
  { offset: 0.6, transform: "translate3d(10px, 0, 0)" },
  { offset: 0.7, transform: "translate3d(-10px, 0, 0)" },
  { offset: 0.8, transform: "translate3d(10px, 0, 0)" },
  { offset: 0.9, transform: "translate3d(-10px, 0, 0)" },
  { offset: 1, transform: "translate3d(0, 0, 0)" }
], shakeY = [
  { offset: 0, transform: "translate3d(0, 0, 0)" },
  { offset: 0.1, transform: "translate3d(0, -10px, 0)" },
  { offset: 0.2, transform: "translate3d(0, 10px, 0)" },
  { offset: 0.3, transform: "translate3d(0, -10px, 0)" },
  { offset: 0.4, transform: "translate3d(0, 10px, 0)" },
  { offset: 0.5, transform: "translate3d(0, -10px, 0)" },
  { offset: 0.6, transform: "translate3d(0, 10px, 0)" },
  { offset: 0.7, transform: "translate3d(0, -10px, 0)" },
  { offset: 0.8, transform: "translate3d(0, 10px, 0)" },
  { offset: 0.9, transform: "translate3d(0, -10px, 0)" },
  { offset: 1, transform: "translate3d(0, 0, 0)" }
], swing = [
  { offset: 0.2, transform: "rotate3d(0, 0, 1, 15deg)" },
  { offset: 0.4, transform: "rotate3d(0, 0, 1, -10deg)" },
  { offset: 0.6, transform: "rotate3d(0, 0, 1, 5deg)" },
  { offset: 0.8, transform: "rotate3d(0, 0, 1, -5deg)" },
  { offset: 1, transform: "rotate3d(0, 0, 1, 0deg)" }
], tada = [
  { offset: 0, transform: "scale3d(1, 1, 1)" },
  { offset: 0.1, transform: "scale3d(0.9, 0.9, 0.9) rotate3d(0, 0, 1, -3deg)" },
  { offset: 0.2, transform: "scale3d(0.9, 0.9, 0.9) rotate3d(0, 0, 1, -3deg)" },
  { offset: 0.3, transform: "scale3d(1.1, 1.1, 1.1) rotate3d(0, 0, 1, 3deg)" },
  { offset: 0.4, transform: "scale3d(1.1, 1.1, 1.1) rotate3d(0, 0, 1, -3deg)" },
  { offset: 0.5, transform: "scale3d(1.1, 1.1, 1.1) rotate3d(0, 0, 1, 3deg)" },
  { offset: 0.6, transform: "scale3d(1.1, 1.1, 1.1) rotate3d(0, 0, 1, -3deg)" },
  { offset: 0.7, transform: "scale3d(1.1, 1.1, 1.1) rotate3d(0, 0, 1, 3deg)" },
  { offset: 0.8, transform: "scale3d(1.1, 1.1, 1.1) rotate3d(0, 0, 1, -3deg)" },
  { offset: 0.9, transform: "scale3d(1.1, 1.1, 1.1) rotate3d(0, 0, 1, 3deg)" },
  { offset: 1, transform: "scale3d(1, 1, 1)" }
], wobble = [
  { offset: 0, transform: "translate3d(0, 0, 0)" },
  { offset: 0.15, transform: "translate3d(-25%, 0, 0) rotate3d(0, 0, 1, -5deg)" },
  { offset: 0.3, transform: "translate3d(20%, 0, 0) rotate3d(0, 0, 1, 3deg)" },
  { offset: 0.45, transform: "translate3d(-15%, 0, 0) rotate3d(0, 0, 1, -3deg)" },
  { offset: 0.6, transform: "translate3d(10%, 0, 0) rotate3d(0, 0, 1, 2deg)" },
  { offset: 0.75, transform: "translate3d(-5%, 0, 0) rotate3d(0, 0, 1, -1deg)" },
  { offset: 1, transform: "translate3d(0, 0, 0)" }
], backInDown = [
  { offset: 0, transform: "translateY(-1200px) scale(0.7)", opacity: "0.7" },
  { offset: 0.8, transform: "translateY(0px) scale(0.7)", opacity: "0.7" },
  { offset: 1, transform: "scale(1)", opacity: "1" }
], backInLeft = [
  { offset: 0, transform: "translateX(-2000px) scale(0.7)", opacity: "0.7" },
  { offset: 0.8, transform: "translateX(0px) scale(0.7)", opacity: "0.7" },
  { offset: 1, transform: "scale(1)", opacity: "1" }
], backInRight = [
  { offset: 0, transform: "translateX(2000px) scale(0.7)", opacity: "0.7" },
  { offset: 0.8, transform: "translateX(0px) scale(0.7)", opacity: "0.7" },
  { offset: 1, transform: "scale(1)", opacity: "1" }
], backInUp = [
  { offset: 0, transform: "translateY(1200px) scale(0.7)", opacity: "0.7" },
  { offset: 0.8, transform: "translateY(0px) scale(0.7)", opacity: "0.7" },
  { offset: 1, transform: "scale(1)", opacity: "1" }
], backOutDown = [
  { offset: 0, transform: "scale(1)", opacity: "1" },
  { offset: 0.2, transform: "translateY(0px) scale(0.7)", opacity: "0.7" },
  { offset: 1, transform: "translateY(700px) scale(0.7)", opacity: "0.7" }
], backOutLeft = [
  { offset: 0, transform: "scale(1)", opacity: "1" },
  { offset: 0.2, transform: "translateX(0px) scale(0.7)", opacity: "0.7" },
  { offset: 1, transform: "translateX(-2000px) scale(0.7)", opacity: "0.7" }
], backOutRight = [
  { offset: 0, transform: "scale(1)", opacity: "1" },
  { offset: 0.2, transform: "translateX(0px) scale(0.7)", opacity: "0.7" },
  { offset: 1, transform: "translateX(2000px) scale(0.7)", opacity: "0.7" }
], backOutUp = [
  { offset: 0, transform: "scale(1)", opacity: "1" },
  { offset: 0.2, transform: "translateY(0px) scale(0.7)", opacity: "0.7" },
  { offset: 1, transform: "translateY(-700px) scale(0.7)", opacity: "0.7" }
], bounceIn = [
  { offset: 0, opacity: "0", transform: "scale3d(0.3, 0.3, 0.3)" },
  { offset: 0, easing: "cubic-bezier(0.215, 0.61, 0.355, 1)" },
  { offset: 0.2, transform: "scale3d(1.1, 1.1, 1.1)" },
  { offset: 0.2, easing: "cubic-bezier(0.215, 0.61, 0.355, 1)" },
  { offset: 0.4, transform: "scale3d(0.9, 0.9, 0.9)" },
  { offset: 0.4, easing: "cubic-bezier(0.215, 0.61, 0.355, 1)" },
  { offset: 0.6, opacity: "1", transform: "scale3d(1.03, 1.03, 1.03)" },
  { offset: 0.6, easing: "cubic-bezier(0.215, 0.61, 0.355, 1)" },
  { offset: 0.8, transform: "scale3d(0.97, 0.97, 0.97)" },
  { offset: 0.8, easing: "cubic-bezier(0.215, 0.61, 0.355, 1)" },
  { offset: 1, opacity: "1", transform: "scale3d(1, 1, 1)" },
  { offset: 1, easing: "cubic-bezier(0.215, 0.61, 0.355, 1)" }
], bounceInDown = [
  { offset: 0, opacity: "0", transform: "translate3d(0, -3000px, 0) scaleY(3)" },
  { offset: 0, easing: "cubic-bezier(0.215, 0.61, 0.355, 1)" },
  { offset: 0.6, opacity: "1", transform: "translate3d(0, 25px, 0) scaleY(0.9)" },
  { offset: 0.6, easing: "cubic-bezier(0.215, 0.61, 0.355, 1)" },
  { offset: 0.75, transform: "translate3d(0, -10px, 0) scaleY(0.95)" },
  { offset: 0.75, easing: "cubic-bezier(0.215, 0.61, 0.355, 1)" },
  { offset: 0.9, transform: "translate3d(0, 5px, 0) scaleY(0.985)" },
  { offset: 0.9, easing: "cubic-bezier(0.215, 0.61, 0.355, 1)" },
  { offset: 1, transform: "translate3d(0, 0, 0)" },
  { offset: 1, easing: "cubic-bezier(0.215, 0.61, 0.355, 1)" }
], bounceInLeft = [
  { offset: 0, opacity: "0", transform: "translate3d(-3000px, 0, 0) scaleX(3)" },
  { offset: 0, easing: "cubic-bezier(0.215, 0.61, 0.355, 1)" },
  { offset: 0.6, opacity: "1", transform: "translate3d(25px, 0, 0) scaleX(1)" },
  { offset: 0.6, easing: "cubic-bezier(0.215, 0.61, 0.355, 1)" },
  { offset: 0.75, transform: "translate3d(-10px, 0, 0) scaleX(0.98)" },
  { offset: 0.75, easing: "cubic-bezier(0.215, 0.61, 0.355, 1)" },
  { offset: 0.9, transform: "translate3d(5px, 0, 0) scaleX(0.995)" },
  { offset: 0.9, easing: "cubic-bezier(0.215, 0.61, 0.355, 1)" },
  { offset: 1, transform: "translate3d(0, 0, 0)" },
  { offset: 1, easing: "cubic-bezier(0.215, 0.61, 0.355, 1)" }
], bounceInRight = [
  { offset: 0, opacity: "0", transform: "translate3d(3000px, 0, 0) scaleX(3)" },
  { offset: 0, easing: "cubic-bezier(0.215, 0.61, 0.355, 1)" },
  { offset: 0.6, opacity: "1", transform: "translate3d(-25px, 0, 0) scaleX(1)" },
  { offset: 0.6, easing: "cubic-bezier(0.215, 0.61, 0.355, 1)" },
  { offset: 0.75, transform: "translate3d(10px, 0, 0) scaleX(0.98)" },
  { offset: 0.75, easing: "cubic-bezier(0.215, 0.61, 0.355, 1)" },
  { offset: 0.9, transform: "translate3d(-5px, 0, 0) scaleX(0.995)" },
  { offset: 0.9, easing: "cubic-bezier(0.215, 0.61, 0.355, 1)" },
  { offset: 1, transform: "translate3d(0, 0, 0)" },
  { offset: 1, easing: "cubic-bezier(0.215, 0.61, 0.355, 1)" }
], bounceInUp = [
  { offset: 0, opacity: "0", transform: "translate3d(0, 3000px, 0) scaleY(5)" },
  { offset: 0, easing: "cubic-bezier(0.215, 0.61, 0.355, 1)" },
  { offset: 0.6, opacity: "1", transform: "translate3d(0, -20px, 0) scaleY(0.9)" },
  { offset: 0.6, easing: "cubic-bezier(0.215, 0.61, 0.355, 1)" },
  { offset: 0.75, transform: "translate3d(0, 10px, 0) scaleY(0.95)" },
  { offset: 0.75, easing: "cubic-bezier(0.215, 0.61, 0.355, 1)" },
  { offset: 0.9, transform: "translate3d(0, -5px, 0) scaleY(0.985)" },
  { offset: 0.9, easing: "cubic-bezier(0.215, 0.61, 0.355, 1)" },
  { offset: 1, transform: "translate3d(0, 0, 0)" },
  { offset: 1, easing: "cubic-bezier(0.215, 0.61, 0.355, 1)" }
], bounceOut = [
  { offset: 0.2, transform: "scale3d(0.9, 0.9, 0.9)" },
  { offset: 0.5, opacity: "1", transform: "scale3d(1.1, 1.1, 1.1)" },
  { offset: 0.55, opacity: "1", transform: "scale3d(1.1, 1.1, 1.1)" },
  { offset: 1, opacity: "0", transform: "scale3d(0.3, 0.3, 0.3)" }
], bounceOutDown = [
  { offset: 0.2, transform: "translate3d(0, 10px, 0) scaleY(0.985)" },
  { offset: 0.4, opacity: "1", transform: "translate3d(0, -20px, 0) scaleY(0.9)" },
  { offset: 0.45, opacity: "1", transform: "translate3d(0, -20px, 0) scaleY(0.9)" },
  { offset: 1, opacity: "0", transform: "translate3d(0, 2000px, 0) scaleY(3)" }
], bounceOutLeft = [
  { offset: 0.2, opacity: "1", transform: "translate3d(20px, 0, 0) scaleX(0.9)" },
  { offset: 1, opacity: "0", transform: "translate3d(-2000px, 0, 0) scaleX(2)" }
], bounceOutRight = [
  { offset: 0.2, opacity: "1", transform: "translate3d(-20px, 0, 0) scaleX(0.9)" },
  { offset: 1, opacity: "0", transform: "translate3d(2000px, 0, 0) scaleX(2)" }
], bounceOutUp = [
  { offset: 0.2, transform: "translate3d(0, -10px, 0) scaleY(0.985)" },
  { offset: 0.4, opacity: "1", transform: "translate3d(0, 20px, 0) scaleY(0.9)" },
  { offset: 0.45, opacity: "1", transform: "translate3d(0, 20px, 0) scaleY(0.9)" },
  { offset: 1, opacity: "0", transform: "translate3d(0, -2000px, 0) scaleY(3)" }
], fadeIn = [
  { offset: 0, opacity: "0" },
  { offset: 1, opacity: "1" }
], fadeInBottomLeft = [
  { offset: 0, opacity: "0", transform: "translate3d(-100%, 100%, 0)" },
  { offset: 1, opacity: "1", transform: "translate3d(0, 0, 0)" }
], fadeInBottomRight = [
  { offset: 0, opacity: "0", transform: "translate3d(100%, 100%, 0)" },
  { offset: 1, opacity: "1", transform: "translate3d(0, 0, 0)" }
], fadeInDown = [
  { offset: 0, opacity: "0", transform: "translate3d(0, -100%, 0)" },
  { offset: 1, opacity: "1", transform: "translate3d(0, 0, 0)" }
], fadeInDownBig = [
  { offset: 0, opacity: "0", transform: "translate3d(0, -2000px, 0)" },
  { offset: 1, opacity: "1", transform: "translate3d(0, 0, 0)" }
], fadeInLeft = [
  { offset: 0, opacity: "0", transform: "translate3d(-100%, 0, 0)" },
  { offset: 1, opacity: "1", transform: "translate3d(0, 0, 0)" }
], fadeInLeftBig = [
  { offset: 0, opacity: "0", transform: "translate3d(-2000px, 0, 0)" },
  { offset: 1, opacity: "1", transform: "translate3d(0, 0, 0)" }
], fadeInRight = [
  { offset: 0, opacity: "0", transform: "translate3d(100%, 0, 0)" },
  { offset: 1, opacity: "1", transform: "translate3d(0, 0, 0)" }
], fadeInRightBig = [
  { offset: 0, opacity: "0", transform: "translate3d(2000px, 0, 0)" },
  { offset: 1, opacity: "1", transform: "translate3d(0, 0, 0)" }
], fadeInTopLeft = [
  { offset: 0, opacity: "0", transform: "translate3d(-100%, -100%, 0)" },
  { offset: 1, opacity: "1", transform: "translate3d(0, 0, 0)" }
], fadeInTopRight = [
  { offset: 0, opacity: "0", transform: "translate3d(100%, -100%, 0)" },
  { offset: 1, opacity: "1", transform: "translate3d(0, 0, 0)" }
], fadeInUp = [
  { offset: 0, opacity: "0", transform: "translate3d(0, 100%, 0)" },
  { offset: 1, opacity: "1", transform: "translate3d(0, 0, 0)" }
], fadeInUpBig = [
  { offset: 0, opacity: "0", transform: "translate3d(0, 2000px, 0)" },
  { offset: 1, opacity: "1", transform: "translate3d(0, 0, 0)" }
], fadeOut = [
  { offset: 0, opacity: "1" },
  { offset: 1, opacity: "0" }
], fadeOutBottomLeft = [
  { offset: 0, opacity: "1", transform: "translate3d(0, 0, 0)" },
  { offset: 1, opacity: "0", transform: "translate3d(-100%, 100%, 0)" }
], fadeOutBottomRight = [
  { offset: 0, opacity: "1", transform: "translate3d(0, 0, 0)" },
  { offset: 1, opacity: "0", transform: "translate3d(100%, 100%, 0)" }
], fadeOutDown = [
  { offset: 0, opacity: "1" },
  { offset: 1, opacity: "0", transform: "translate3d(0, 100%, 0)" }
], fadeOutDownBig = [
  { offset: 0, opacity: "1" },
  { offset: 1, opacity: "0", transform: "translate3d(0, 2000px, 0)" }
], fadeOutLeft = [
  { offset: 0, opacity: "1" },
  { offset: 1, opacity: "0", transform: "translate3d(-100%, 0, 0)" }
], fadeOutLeftBig = [
  { offset: 0, opacity: "1" },
  { offset: 1, opacity: "0", transform: "translate3d(-2000px, 0, 0)" }
], fadeOutRight = [
  { offset: 0, opacity: "1" },
  { offset: 1, opacity: "0", transform: "translate3d(100%, 0, 0)" }
], fadeOutRightBig = [
  { offset: 0, opacity: "1" },
  { offset: 1, opacity: "0", transform: "translate3d(2000px, 0, 0)" }
], fadeOutTopLeft = [
  { offset: 0, opacity: "1", transform: "translate3d(0, 0, 0)" },
  { offset: 1, opacity: "0", transform: "translate3d(-100%, -100%, 0)" }
], fadeOutTopRight = [
  { offset: 0, opacity: "1", transform: "translate3d(0, 0, 0)" },
  { offset: 1, opacity: "0", transform: "translate3d(100%, -100%, 0)" }
], fadeOutUp = [
  { offset: 0, opacity: "1" },
  { offset: 1, opacity: "0", transform: "translate3d(0, -100%, 0)" }
], fadeOutUpBig = [
  { offset: 0, opacity: "1" },
  { offset: 1, opacity: "0", transform: "translate3d(0, -2000px, 0)" }
], flip = [
  {
    offset: 0,
    transform: "perspective(400px) scale3d(1, 1, 1) translate3d(0, 0, 0) rotate3d(0, 1, 0, -360deg)",
    easing: "ease-out"
  },
  {
    offset: 0.4,
    transform: `perspective(400px) scale3d(1, 1, 1) translate3d(0, 0, 150px)
      rotate3d(0, 1, 0, -190deg)`,
    easing: "ease-out"
  },
  {
    offset: 0.5,
    transform: `perspective(400px) scale3d(1, 1, 1) translate3d(0, 0, 150px)
      rotate3d(0, 1, 0, -170deg)`,
    easing: "ease-in"
  },
  {
    offset: 0.8,
    transform: `perspective(400px) scale3d(0.95, 0.95, 0.95) translate3d(0, 0, 0)
      rotate3d(0, 1, 0, 0deg)`,
    easing: "ease-in"
  },
  {
    offset: 1,
    transform: "perspective(400px) scale3d(1, 1, 1) translate3d(0, 0, 0) rotate3d(0, 1, 0, 0deg)",
    easing: "ease-in"
  }
], flipInX = [
  { offset: 0, transform: "perspective(400px) rotate3d(1, 0, 0, 90deg)", easing: "ease-in", opacity: "0" },
  { offset: 0.4, transform: "perspective(400px) rotate3d(1, 0, 0, -20deg)", easing: "ease-in" },
  { offset: 0.6, transform: "perspective(400px) rotate3d(1, 0, 0, 10deg)", opacity: "1" },
  { offset: 0.8, transform: "perspective(400px) rotate3d(1, 0, 0, -5deg)" },
  { offset: 1, transform: "perspective(400px)" }
], flipInY = [
  { offset: 0, transform: "perspective(400px) rotate3d(0, 1, 0, 90deg)", easing: "ease-in", opacity: "0" },
  { offset: 0.4, transform: "perspective(400px) rotate3d(0, 1, 0, -20deg)", easing: "ease-in" },
  { offset: 0.6, transform: "perspective(400px) rotate3d(0, 1, 0, 10deg)", opacity: "1" },
  { offset: 0.8, transform: "perspective(400px) rotate3d(0, 1, 0, -5deg)" },
  { offset: 1, transform: "perspective(400px)" }
], flipOutX = [
  { offset: 0, transform: "perspective(400px)" },
  { offset: 0.3, transform: "perspective(400px) rotate3d(1, 0, 0, -20deg)", opacity: "1" },
  { offset: 1, transform: "perspective(400px) rotate3d(1, 0, 0, 90deg)", opacity: "0" }
], flipOutY = [
  { offset: 0, transform: "perspective(400px)" },
  { offset: 0.3, transform: "perspective(400px) rotate3d(0, 1, 0, -15deg)", opacity: "1" },
  { offset: 1, transform: "perspective(400px) rotate3d(0, 1, 0, 90deg)", opacity: "0" }
], lightSpeedInLeft = [
  { offset: 0, transform: "translate3d(-100%, 0, 0) skewX(30deg)", opacity: "0" },
  { offset: 0.6, transform: "skewX(-20deg)", opacity: "1" },
  { offset: 0.8, transform: "skewX(5deg)" },
  { offset: 1, transform: "translate3d(0, 0, 0)" }
], lightSpeedInRight = [
  { offset: 0, transform: "translate3d(100%, 0, 0) skewX(-30deg)", opacity: "0" },
  { offset: 0.6, transform: "skewX(20deg)", opacity: "1" },
  { offset: 0.8, transform: "skewX(-5deg)" },
  { offset: 1, transform: "translate3d(0, 0, 0)" }
], lightSpeedOutLeft = [
  { offset: 0, opacity: "1" },
  { offset: 1, transform: "translate3d(-100%, 0, 0) skewX(-30deg)", opacity: "0" }
], lightSpeedOutRight = [
  { offset: 0, opacity: "1" },
  { offset: 1, transform: "translate3d(100%, 0, 0) skewX(30deg)", opacity: "0" }
], rotateIn = [
  { offset: 0, transform: "rotate3d(0, 0, 1, -200deg)", opacity: "0" },
  { offset: 1, transform: "translate3d(0, 0, 0)", opacity: "1" }
], rotateInDownLeft = [
  { offset: 0, transform: "rotate3d(0, 0, 1, -45deg)", opacity: "0" },
  { offset: 1, transform: "translate3d(0, 0, 0)", opacity: "1" }
], rotateInDownRight = [
  { offset: 0, transform: "rotate3d(0, 0, 1, 45deg)", opacity: "0" },
  { offset: 1, transform: "translate3d(0, 0, 0)", opacity: "1" }
], rotateInUpLeft = [
  { offset: 0, transform: "rotate3d(0, 0, 1, 45deg)", opacity: "0" },
  { offset: 1, transform: "translate3d(0, 0, 0)", opacity: "1" }
], rotateInUpRight = [
  { offset: 0, transform: "rotate3d(0, 0, 1, -90deg)", opacity: "0" },
  { offset: 1, transform: "translate3d(0, 0, 0)", opacity: "1" }
], rotateOut = [
  { offset: 0, opacity: "1" },
  { offset: 1, transform: "rotate3d(0, 0, 1, 200deg)", opacity: "0" }
], rotateOutDownLeft = [
  { offset: 0, opacity: "1" },
  { offset: 1, transform: "rotate3d(0, 0, 1, 45deg)", opacity: "0" }
], rotateOutDownRight = [
  { offset: 0, opacity: "1" },
  { offset: 1, transform: "rotate3d(0, 0, 1, -45deg)", opacity: "0" }
], rotateOutUpLeft = [
  { offset: 0, opacity: "1" },
  { offset: 1, transform: "rotate3d(0, 0, 1, -45deg)", opacity: "0" }
], rotateOutUpRight = [
  { offset: 0, opacity: "1" },
  { offset: 1, transform: "rotate3d(0, 0, 1, 90deg)", opacity: "0" }
], slideInDown = [
  { offset: 0, transform: "translate3d(0, -100%, 0)", visibility: "visible" },
  { offset: 1, transform: "translate3d(0, 0, 0)" }
], slideInLeft = [
  { offset: 0, transform: "translate3d(-100%, 0, 0)", visibility: "visible" },
  { offset: 1, transform: "translate3d(0, 0, 0)" }
], slideInRight = [
  { offset: 0, transform: "translate3d(100%, 0, 0)", visibility: "visible" },
  { offset: 1, transform: "translate3d(0, 0, 0)" }
], slideInUp = [
  { offset: 0, transform: "translate3d(0, 100%, 0)", visibility: "visible" },
  { offset: 1, transform: "translate3d(0, 0, 0)" }
], slideOutDown = [
  { offset: 0, transform: "translate3d(0, 0, 0)" },
  { offset: 1, visibility: "hidden", transform: "translate3d(0, 100%, 0)" }
], slideOutLeft = [
  { offset: 0, transform: "translate3d(0, 0, 0)" },
  { offset: 1, visibility: "hidden", transform: "translate3d(-100%, 0, 0)" }
], slideOutRight = [
  { offset: 0, transform: "translate3d(0, 0, 0)" },
  { offset: 1, visibility: "hidden", transform: "translate3d(100%, 0, 0)" }
], slideOutUp = [
  { offset: 0, transform: "translate3d(0, 0, 0)" },
  { offset: 1, visibility: "hidden", transform: "translate3d(0, -100%, 0)" }
], hinge = [
  { offset: 0, easing: "ease-in-out" },
  { offset: 0.2, transform: "rotate3d(0, 0, 1, 80deg)", easing: "ease-in-out" },
  { offset: 0.4, transform: "rotate3d(0, 0, 1, 60deg)", easing: "ease-in-out", opacity: "1" },
  { offset: 0.6, transform: "rotate3d(0, 0, 1, 80deg)", easing: "ease-in-out" },
  { offset: 0.8, transform: "rotate3d(0, 0, 1, 60deg)", easing: "ease-in-out", opacity: "1" },
  { offset: 1, transform: "translate3d(0, 700px, 0)", opacity: "0" }
], jackInTheBox = [
  { offset: 0, opacity: "0", transform: "scale(0.1) rotate(30deg)", "transform-origin": "center bottom" },
  { offset: 0.5, transform: "rotate(-10deg)" },
  { offset: 0.7, transform: "rotate(3deg)" },
  { offset: 1, opacity: "1", transform: "scale(1)" }
], rollIn = [
  { offset: 0, opacity: "0", transform: "translate3d(-100%, 0, 0) rotate3d(0, 0, 1, -120deg)" },
  { offset: 1, opacity: "1", transform: "translate3d(0, 0, 0)" }
], rollOut = [
  { offset: 0, opacity: "1" },
  { offset: 1, opacity: "0", transform: "translate3d(100%, 0, 0) rotate3d(0, 0, 1, 120deg)" }
], zoomIn = [
  { offset: 0, opacity: "0", transform: "scale3d(0.3, 0.3, 0.3)" },
  { offset: 0.5, opacity: "1" }
], zoomInDown = [
  {
    offset: 0,
    opacity: "0",
    transform: "scale3d(0.1, 0.1, 0.1) translate3d(0, -1000px, 0)",
    easing: "cubic-bezier(0.55, 0.055, 0.675, 0.19)"
  },
  {
    offset: 0.6,
    opacity: "1",
    transform: "scale3d(0.475, 0.475, 0.475) translate3d(0, 60px, 0)",
    easing: "cubic-bezier(0.175, 0.885, 0.32, 1)"
  }
], zoomInLeft = [
  {
    offset: 0,
    opacity: "0",
    transform: "scale3d(0.1, 0.1, 0.1) translate3d(-1000px, 0, 0)",
    easing: "cubic-bezier(0.55, 0.055, 0.675, 0.19)"
  },
  {
    offset: 0.6,
    opacity: "1",
    transform: "scale3d(0.475, 0.475, 0.475) translate3d(10px, 0, 0)",
    easing: "cubic-bezier(0.175, 0.885, 0.32, 1)"
  }
], zoomInRight = [
  {
    offset: 0,
    opacity: "0",
    transform: "scale3d(0.1, 0.1, 0.1) translate3d(1000px, 0, 0)",
    easing: "cubic-bezier(0.55, 0.055, 0.675, 0.19)"
  },
  {
    offset: 0.6,
    opacity: "1",
    transform: "scale3d(0.475, 0.475, 0.475) translate3d(-10px, 0, 0)",
    easing: "cubic-bezier(0.175, 0.885, 0.32, 1)"
  }
], zoomInUp = [
  {
    offset: 0,
    opacity: "0",
    transform: "scale3d(0.1, 0.1, 0.1) translate3d(0, 1000px, 0)",
    easing: "cubic-bezier(0.55, 0.055, 0.675, 0.19)"
  },
  {
    offset: 0.6,
    opacity: "1",
    transform: "scale3d(0.475, 0.475, 0.475) translate3d(0, -60px, 0)",
    easing: "cubic-bezier(0.175, 0.885, 0.32, 1)"
  }
], zoomOut = [
  { offset: 0, opacity: "1" },
  { offset: 0.5, opacity: "0", transform: "scale3d(0.3, 0.3, 0.3)" },
  { offset: 1, opacity: "0" }
], zoomOutDown = [
  {
    offset: 0.4,
    opacity: "1",
    transform: "scale3d(0.475, 0.475, 0.475) translate3d(0, -60px, 0)",
    easing: "cubic-bezier(0.55, 0.055, 0.675, 0.19)"
  },
  {
    offset: 1,
    opacity: "0",
    transform: "scale3d(0.1, 0.1, 0.1) translate3d(0, 2000px, 0)",
    easing: "cubic-bezier(0.175, 0.885, 0.32, 1)"
  }
], zoomOutLeft = [
  { offset: 0.4, opacity: "1", transform: "scale3d(0.475, 0.475, 0.475) translate3d(42px, 0, 0)" },
  { offset: 1, opacity: "0", transform: "scale(0.1) translate3d(-2000px, 0, 0)" }
], zoomOutRight = [
  { offset: 0.4, opacity: "1", transform: "scale3d(0.475, 0.475, 0.475) translate3d(-42px, 0, 0)" },
  { offset: 1, opacity: "0", transform: "scale(0.1) translate3d(2000px, 0, 0)" }
], zoomOutUp = [
  {
    offset: 0.4,
    opacity: "1",
    transform: "scale3d(0.475, 0.475, 0.475) translate3d(0, 60px, 0)",
    easing: "cubic-bezier(0.55, 0.055, 0.675, 0.19)"
  },
  {
    offset: 1,
    opacity: "0",
    transform: "scale3d(0.1, 0.1, 0.1) translate3d(0, -2000px, 0)",
    easing: "cubic-bezier(0.175, 0.885, 0.32, 1)"
  }
], easings = {
  linear: "linear",
  ease: "ease",
  easeIn: "ease-in",
  easeOut: "ease-out",
  easeInOut: "ease-in-out",
  easeInSine: "cubic-bezier(0.47, 0, 0.745, 0.715)",
  easeOutSine: "cubic-bezier(0.39, 0.575, 0.565, 1)",
  easeInOutSine: "cubic-bezier(0.445, 0.05, 0.55, 0.95)",
  easeInQuad: "cubic-bezier(0.55, 0.085, 0.68, 0.53)",
  easeOutQuad: "cubic-bezier(0.25, 0.46, 0.45, 0.94)",
  easeInOutQuad: "cubic-bezier(0.455, 0.03, 0.515, 0.955)",
  easeInCubic: "cubic-bezier(0.55, 0.055, 0.675, 0.19)",
  easeOutCubic: "cubic-bezier(0.215, 0.61, 0.355, 1)",
  easeInOutCubic: "cubic-bezier(0.645, 0.045, 0.355, 1)",
  easeInQuart: "cubic-bezier(0.895, 0.03, 0.685, 0.22)",
  easeOutQuart: "cubic-bezier(0.165, 0.84, 0.44, 1)",
  easeInOutQuart: "cubic-bezier(0.77, 0, 0.175, 1)",
  easeInQuint: "cubic-bezier(0.755, 0.05, 0.855, 0.06)",
  easeOutQuint: "cubic-bezier(0.23, 1, 0.32, 1)",
  easeInOutQuint: "cubic-bezier(0.86, 0, 0.07, 1)",
  easeInExpo: "cubic-bezier(0.95, 0.05, 0.795, 0.035)",
  easeOutExpo: "cubic-bezier(0.19, 1, 0.22, 1)",
  easeInOutExpo: "cubic-bezier(1, 0, 0, 1)",
  easeInCirc: "cubic-bezier(0.6, 0.04, 0.98, 0.335)",
  easeOutCirc: "cubic-bezier(0.075, 0.82, 0.165, 1)",
  easeInOutCirc: "cubic-bezier(0.785, 0.135, 0.15, 0.86)",
  easeInBack: "cubic-bezier(0.6, -0.28, 0.735, 0.045)",
  easeOutBack: "cubic-bezier(0.175, 0.885, 0.32, 1.275)",
  easeInOutBack: "cubic-bezier(0.68, -0.55, 0.265, 1.55)"
}, animations = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  backInDown,
  backInLeft,
  backInRight,
  backInUp,
  backOutDown,
  backOutLeft,
  backOutRight,
  backOutUp,
  bounce,
  bounceIn,
  bounceInDown,
  bounceInLeft,
  bounceInRight,
  bounceInUp,
  bounceOut,
  bounceOutDown,
  bounceOutLeft,
  bounceOutRight,
  bounceOutUp,
  easings,
  fadeIn,
  fadeInBottomLeft,
  fadeInBottomRight,
  fadeInDown,
  fadeInDownBig,
  fadeInLeft,
  fadeInLeftBig,
  fadeInRight,
  fadeInRightBig,
  fadeInTopLeft,
  fadeInTopRight,
  fadeInUp,
  fadeInUpBig,
  fadeOut,
  fadeOutBottomLeft,
  fadeOutBottomRight,
  fadeOutDown,
  fadeOutDownBig,
  fadeOutLeft,
  fadeOutLeftBig,
  fadeOutRight,
  fadeOutRightBig,
  fadeOutTopLeft,
  fadeOutTopRight,
  fadeOutUp,
  fadeOutUpBig,
  flash,
  flip,
  flipInX,
  flipInY,
  flipOutX,
  flipOutY,
  headShake,
  heartBeat,
  hinge,
  jackInTheBox,
  jello,
  lightSpeedInLeft,
  lightSpeedInRight,
  lightSpeedOutLeft,
  lightSpeedOutRight,
  pulse,
  rollIn,
  rollOut,
  rotateIn,
  rotateInDownLeft,
  rotateInDownRight,
  rotateInUpLeft,
  rotateInUpRight,
  rotateOut,
  rotateOutDownLeft,
  rotateOutDownRight,
  rotateOutUpLeft,
  rotateOutUpRight,
  rubberBand,
  shake,
  shakeX,
  shakeY,
  slideInDown,
  slideInLeft,
  slideInRight,
  slideInUp,
  slideOutDown,
  slideOutLeft,
  slideOutRight,
  slideOutUp,
  swing,
  tada,
  wobble,
  zoomIn,
  zoomInDown,
  zoomInLeft,
  zoomInRight,
  zoomInUp,
  zoomOut,
  zoomOutDown,
  zoomOutLeft,
  zoomOutRight,
  zoomOutUp
}, Symbol.toStringTag, { value: "Module" }));
var SlAnimation = class extends ShoelaceElement {
  constructor() {
    super(...arguments), this.hasStarted = !1, this.name = "none", this.play = !1, this.delay = 0, this.direction = "normal", this.duration = 1e3, this.easing = "linear", this.endDelay = 0, this.fill = "auto", this.iterations = 1 / 0, this.iterationStart = 0, this.playbackRate = 1, this.handleAnimationFinish = () => {
      this.play = !1, this.hasStarted = !1, this.emit("sl-finish");
    }, this.handleAnimationCancel = () => {
      this.play = !1, this.hasStarted = !1, this.emit("sl-cancel");
    };
  }
  /** Gets and sets the current animation time. */
  get currentTime() {
    var z, D;
    return (D = (z = this.animation) == null ? void 0 : z.currentTime) != null ? D : 0;
  }
  set currentTime(z) {
    this.animation && (this.animation.currentTime = z);
  }
  connectedCallback() {
    super.connectedCallback(), this.createAnimation();
  }
  disconnectedCallback() {
    super.disconnectedCallback(), this.destroyAnimation();
  }
  handleSlotChange() {
    this.destroyAnimation(), this.createAnimation();
  }
  async createAnimation() {
    var z, D;
    const O = (z = easings[this.easing]) != null ? z : this.easing, F = (D = this.keyframes) != null ? D : animations[this.name], W = (await this.defaultSlot).assignedElements()[0];
    return !W || !F ? !1 : (this.destroyAnimation(), this.animation = W.animate(F, {
      delay: this.delay,
      direction: this.direction,
      duration: this.duration,
      easing: O,
      endDelay: this.endDelay,
      fill: this.fill,
      iterationStart: this.iterationStart,
      iterations: this.iterations
    }), this.animation.playbackRate = this.playbackRate, this.animation.addEventListener("cancel", this.handleAnimationCancel), this.animation.addEventListener("finish", this.handleAnimationFinish), this.play ? (this.hasStarted = !0, this.emit("sl-start")) : this.animation.pause(), !0);
  }
  destroyAnimation() {
    this.animation && (this.animation.cancel(), this.animation.removeEventListener("cancel", this.handleAnimationCancel), this.animation.removeEventListener("finish", this.handleAnimationFinish), this.hasStarted = !1);
  }
  handleAnimationChange() {
    this.hasUpdated && this.createAnimation();
  }
  handlePlayChange() {
    return this.animation ? (this.play && !this.hasStarted && (this.hasStarted = !0, this.emit("sl-start")), this.play ? this.animation.play() : this.animation.pause(), !0) : !1;
  }
  handlePlaybackRateChange() {
    this.animation && (this.animation.playbackRate = this.playbackRate);
  }
  /** Clears all keyframe effects caused by this animation and aborts its playback. */
  cancel() {
    var z;
    (z = this.animation) == null || z.cancel();
  }
  /** Sets the playback time to the end of the animation corresponding to the current playback direction. */
  finish() {
    var z;
    (z = this.animation) == null || z.finish();
  }
  render() {
    return x` <slot @slotchange=${this.handleSlotChange}></slot> `;
  }
};
SlAnimation.styles = [component_styles_default, animation_styles_default];
__decorateClass([
  r$2("slot")
], SlAnimation.prototype, "defaultSlot", 2);
__decorateClass([
  n$6()
], SlAnimation.prototype, "name", 2);
__decorateClass([
  n$6({ type: Boolean, reflect: !0 })
], SlAnimation.prototype, "play", 2);
__decorateClass([
  n$6({ type: Number })
], SlAnimation.prototype, "delay", 2);
__decorateClass([
  n$6()
], SlAnimation.prototype, "direction", 2);
__decorateClass([
  n$6({ type: Number })
], SlAnimation.prototype, "duration", 2);
__decorateClass([
  n$6()
], SlAnimation.prototype, "easing", 2);
__decorateClass([
  n$6({ attribute: "end-delay", type: Number })
], SlAnimation.prototype, "endDelay", 2);
__decorateClass([
  n$6()
], SlAnimation.prototype, "fill", 2);
__decorateClass([
  n$6({ type: Number })
], SlAnimation.prototype, "iterations", 2);
__decorateClass([
  n$6({ attribute: "iteration-start", type: Number })
], SlAnimation.prototype, "iterationStart", 2);
__decorateClass([
  n$6({ attribute: !1 })
], SlAnimation.prototype, "keyframes", 2);
__decorateClass([
  n$6({ attribute: "playback-rate", type: Number })
], SlAnimation.prototype, "playbackRate", 2);
__decorateClass([
  watch([
    "name",
    "delay",
    "direction",
    "duration",
    "easing",
    "endDelay",
    "fill",
    "iterations",
    "iterationsStart",
    "keyframes"
  ])
], SlAnimation.prototype, "handleAnimationChange", 1);
__decorateClass([
  watch("play")
], SlAnimation.prototype, "handlePlayChange", 1);
__decorateClass([
  watch("playbackRate")
], SlAnimation.prototype, "handlePlaybackRateChange", 1);
SlAnimation.define("sl-animation");
var breadcrumb_styles_default = i$7`
  .breadcrumb {
    display: flex;
    align-items: center;
    flex-wrap: wrap;
  }
`, SlBreadcrumb = class extends ShoelaceElement {
  constructor() {
    super(...arguments), this.localize = new LocalizeController(this), this.separatorDir = this.localize.dir(), this.label = "";
  }
  // Generates a clone of the separator element to use for each breadcrumb item
  getSeparator() {
    const D = this.separatorSlot.assignedElements({ flatten: !0 })[0].cloneNode(!0);
    return [D, ...D.querySelectorAll("[id]")].forEach((O) => O.removeAttribute("id")), D.setAttribute("data-default", ""), D.slot = "separator", D;
  }
  handleSlotChange() {
    const z = [...this.defaultSlot.assignedElements({ flatten: !0 })].filter(
      (D) => D.tagName.toLowerCase() === "sl-breadcrumb-item"
    );
    z.forEach((D, O) => {
      const F = D.querySelector('[slot="separator"]');
      F === null ? D.append(this.getSeparator()) : F.hasAttribute("data-default") && F.replaceWith(this.getSeparator()), O === z.length - 1 ? D.setAttribute("aria-current", "page") : D.removeAttribute("aria-current");
    });
  }
  render() {
    return this.separatorDir !== this.localize.dir() && (this.separatorDir = this.localize.dir(), this.updateComplete.then(() => this.handleSlotChange())), x`
      <nav part="base" class="breadcrumb" aria-label=${this.label}>
        <slot @slotchange=${this.handleSlotChange}></slot>
      </nav>

      <span hidden aria-hidden="true">
        <slot name="separator">
          <sl-icon name=${this.localize.dir() === "rtl" ? "chevron-left" : "chevron-right"} library="system"></sl-icon>
        </slot>
      </span>
    `;
  }
};
SlBreadcrumb.styles = [component_styles_default, breadcrumb_styles_default];
SlBreadcrumb.dependencies = { "sl-icon": SlIcon };
__decorateClass([
  e$b("slot")
], SlBreadcrumb.prototype, "defaultSlot", 2);
__decorateClass([
  e$b('slot[name="separator"]')
], SlBreadcrumb.prototype, "separatorSlot", 2);
__decorateClass([
  n$6()
], SlBreadcrumb.prototype, "label", 2);
SlBreadcrumb.define("sl-breadcrumb");
var alert_styles_default = i$7`
  :host {
    display: contents;

    /* For better DX, we'll reset the margin here so the base part can inherit it */
    margin: 0;
  }

  .alert {
    position: relative;
    display: flex;
    align-items: stretch;
    background-color: var(--sl-panel-background-color);
    border: solid var(--sl-panel-border-width) var(--sl-panel-border-color);
    border-top-width: calc(var(--sl-panel-border-width) * 3);
    border-radius: var(--sl-border-radius-medium);
    font-family: var(--sl-font-sans);
    font-size: var(--sl-font-size-small);
    font-weight: var(--sl-font-weight-normal);
    line-height: 1.6;
    color: var(--sl-color-neutral-700);
    margin: inherit;
  }

  .alert:not(.alert--has-icon) .alert__icon,
  .alert:not(.alert--closable) .alert__close-button {
    display: none;
  }

  .alert__icon {
    flex: 0 0 auto;
    display: flex;
    align-items: center;
    font-size: var(--sl-font-size-large);
    padding-inline-start: var(--sl-spacing-large);
  }

  .alert--primary {
    border-top-color: var(--sl-color-primary-600);
  }

  .alert--primary .alert__icon {
    color: var(--sl-color-primary-600);
  }

  .alert--success {
    border-top-color: var(--sl-color-success-600);
  }

  .alert--success .alert__icon {
    color: var(--sl-color-success-600);
  }

  .alert--neutral {
    border-top-color: var(--sl-color-neutral-600);
  }

  .alert--neutral .alert__icon {
    color: var(--sl-color-neutral-600);
  }

  .alert--warning {
    border-top-color: var(--sl-color-warning-600);
  }

  .alert--warning .alert__icon {
    color: var(--sl-color-warning-600);
  }

  .alert--danger {
    border-top-color: var(--sl-color-danger-600);
  }

  .alert--danger .alert__icon {
    color: var(--sl-color-danger-600);
  }

  .alert__message {
    flex: 1 1 auto;
    display: block;
    padding: var(--sl-spacing-large);
    overflow: hidden;
  }

  .alert__close-button {
    flex: 0 0 auto;
    display: flex;
    align-items: center;
    font-size: var(--sl-font-size-medium);
    padding-inline-end: var(--sl-spacing-medium);
  }
`, toastStack = Object.assign(document.createElement("div"), { className: "sl-toast-stack" }), SlAlert = class extends ShoelaceElement {
  constructor() {
    super(...arguments), this.hasSlotController = new HasSlotController(this, "icon", "suffix"), this.localize = new LocalizeController(this), this.open = !1, this.closable = !1, this.variant = "primary", this.duration = 1 / 0;
  }
  firstUpdated() {
    this.base.hidden = !this.open;
  }
  restartAutoHide() {
    clearTimeout(this.autoHideTimeout), this.open && this.duration < 1 / 0 && (this.autoHideTimeout = window.setTimeout(() => this.hide(), this.duration));
  }
  handleCloseClick() {
    this.hide();
  }
  handleMouseMove() {
    this.restartAutoHide();
  }
  async handleOpenChange() {
    if (this.open) {
      this.emit("sl-show"), this.duration < 1 / 0 && this.restartAutoHide(), await stopAnimations(this.base), this.base.hidden = !1;
      const { keyframes: z, options: D } = getAnimation(this, "alert.show", { dir: this.localize.dir() });
      await animateTo(this.base, z, D), this.emit("sl-after-show");
    } else {
      this.emit("sl-hide"), clearTimeout(this.autoHideTimeout), await stopAnimations(this.base);
      const { keyframes: z, options: D } = getAnimation(this, "alert.hide", { dir: this.localize.dir() });
      await animateTo(this.base, z, D), this.base.hidden = !0, this.emit("sl-after-hide");
    }
  }
  handleDurationChange() {
    this.restartAutoHide();
  }
  /** Shows the alert. */
  async show() {
    if (!this.open)
      return this.open = !0, waitForEvent(this, "sl-after-show");
  }
  /** Hides the alert */
  async hide() {
    if (this.open)
      return this.open = !1, waitForEvent(this, "sl-after-hide");
  }
  /**
   * Displays the alert as a toast notification. This will move the alert out of its position in the DOM and, when
   * dismissed, it will be removed from the DOM completely. By storing a reference to the alert, you can reuse it by
   * calling this method again. The returned promise will resolve after the alert is hidden.
   */
  async toast() {
    return new Promise((z) => {
      toastStack.parentElement === null && document.body.append(toastStack), toastStack.appendChild(this), requestAnimationFrame(() => {
        this.clientWidth, this.show();
      }), this.addEventListener(
        "sl-after-hide",
        () => {
          toastStack.removeChild(this), z(), toastStack.querySelector("sl-alert") === null && toastStack.remove();
        },
        { once: !0 }
      );
    });
  }
  render() {
    return x`
      <div
        part="base"
        class=${e$2({
      alert: !0,
      "alert--open": this.open,
      "alert--closable": this.closable,
      "alert--has-icon": this.hasSlotController.test("icon"),
      "alert--primary": this.variant === "primary",
      "alert--success": this.variant === "success",
      "alert--neutral": this.variant === "neutral",
      "alert--warning": this.variant === "warning",
      "alert--danger": this.variant === "danger"
    })}
        role="alert"
        aria-hidden=${this.open ? "false" : "true"}
        @mousemove=${this.handleMouseMove}
      >
        <div part="icon" class="alert__icon">
          <slot name="icon"></slot>
        </div>

        <div part="message" class="alert__message" aria-live="polite">
          <slot></slot>
        </div>

        ${this.closable ? x`
              <sl-icon-button
                part="close-button"
                exportparts="base:close-button__base"
                class="alert__close-button"
                name="x-lg"
                library="system"
                label=${this.localize.term("close")}
                @click=${this.handleCloseClick}
              ></sl-icon-button>
            ` : ""}
      </div>
    `;
  }
};
SlAlert.styles = [component_styles_default, alert_styles_default];
SlAlert.dependencies = { "sl-icon-button": SlIconButton };
__decorateClass([
  e$b('[part~="base"]')
], SlAlert.prototype, "base", 2);
__decorateClass([
  n$6({ type: Boolean, reflect: !0 })
], SlAlert.prototype, "open", 2);
__decorateClass([
  n$6({ type: Boolean, reflect: !0 })
], SlAlert.prototype, "closable", 2);
__decorateClass([
  n$6({ reflect: !0 })
], SlAlert.prototype, "variant", 2);
__decorateClass([
  n$6({ type: Number })
], SlAlert.prototype, "duration", 2);
__decorateClass([
  watch("open", { waitUntilFirstUpdate: !0 })
], SlAlert.prototype, "handleOpenChange", 1);
__decorateClass([
  watch("duration")
], SlAlert.prototype, "handleDurationChange", 1);
setDefaultAnimation("alert.show", {
  keyframes: [
    { opacity: 0, scale: 0.8 },
    { opacity: 1, scale: 1 }
  ],
  options: { duration: 250, easing: "ease" }
});
setDefaultAnimation("alert.hide", {
  keyframes: [
    { opacity: 1, scale: 1 },
    { opacity: 0, scale: 0.8 }
  ],
  options: { duration: 250, easing: "ease" }
});
SlAlert.define("sl-alert");
var badge_styles_default = i$7`
  :host {
    display: inline-flex;
  }

  .badge {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    font-size: max(12px, 0.75em);
    font-weight: var(--sl-font-weight-semibold);
    letter-spacing: var(--sl-letter-spacing-normal);
    line-height: 1;
    border-radius: var(--sl-border-radius-small);
    border: solid 1px var(--sl-color-neutral-0);
    white-space: nowrap;
    padding: 0.35em 0.6em;
    user-select: none;
    -webkit-user-select: none;
    cursor: inherit;
  }

  /* Variant modifiers */
  .badge--primary {
    background-color: var(--sl-color-primary-600);
    color: var(--sl-color-neutral-0);
  }

  .badge--success {
    background-color: var(--sl-color-success-600);
    color: var(--sl-color-neutral-0);
  }

  .badge--neutral {
    background-color: var(--sl-color-neutral-600);
    color: var(--sl-color-neutral-0);
  }

  .badge--warning {
    background-color: var(--sl-color-warning-600);
    color: var(--sl-color-neutral-0);
  }

  .badge--danger {
    background-color: var(--sl-color-danger-600);
    color: var(--sl-color-neutral-0);
  }

  /* Pill modifier */
  .badge--pill {
    border-radius: var(--sl-border-radius-pill);
  }

  /* Pulse modifier */
  .badge--pulse {
    animation: pulse 1.5s infinite;
  }

  .badge--pulse.badge--primary {
    --pulse-color: var(--sl-color-primary-600);
  }

  .badge--pulse.badge--success {
    --pulse-color: var(--sl-color-success-600);
  }

  .badge--pulse.badge--neutral {
    --pulse-color: var(--sl-color-neutral-600);
  }

  .badge--pulse.badge--warning {
    --pulse-color: var(--sl-color-warning-600);
  }

  .badge--pulse.badge--danger {
    --pulse-color: var(--sl-color-danger-600);
  }

  @keyframes pulse {
    0% {
      box-shadow: 0 0 0 0 var(--pulse-color);
    }
    70% {
      box-shadow: 0 0 0 0.5rem transparent;
    }
    100% {
      box-shadow: 0 0 0 0 transparent;
    }
  }
`, SlBadge = class extends ShoelaceElement {
  constructor() {
    super(...arguments), this.variant = "primary", this.pill = !1, this.pulse = !1;
  }
  render() {
    return x`
      <span
        part="base"
        class=${e$2({
      badge: !0,
      "badge--primary": this.variant === "primary",
      "badge--success": this.variant === "success",
      "badge--neutral": this.variant === "neutral",
      "badge--warning": this.variant === "warning",
      "badge--danger": this.variant === "danger",
      "badge--pill": this.pill,
      "badge--pulse": this.pulse
    })}
        role="status"
      >
        <slot></slot>
      </span>
    `;
  }
};
SlBadge.styles = [component_styles_default, badge_styles_default];
__decorateClass([
  n$6({ reflect: !0 })
], SlBadge.prototype, "variant", 2);
__decorateClass([
  n$6({ type: Boolean, reflect: !0 })
], SlBadge.prototype, "pill", 2);
__decorateClass([
  n$6({ type: Boolean, reflect: !0 })
], SlBadge.prototype, "pulse", 2);
SlBadge.define("sl-badge");
export {
  Axes,
  DataSource,
  Decision,
  Indicator,
  InfoCard,
  LoggerImplementation,
  MediaControls,
  Spectrogram,
  VerificationGrid,
  VerificationGridTile,
  VerificationHelpDialog,
  gridTileContext,
  rootContext
};
