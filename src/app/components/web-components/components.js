var __defProp$e = Object.defineProperty, __defProps = Object.defineProperties, __getOwnPropDesc$d = Object.getOwnPropertyDescriptor, __getOwnPropDescs = Object.getOwnPropertyDescriptors, __getOwnPropSymbols = Object.getOwnPropertySymbols, __hasOwnProp = Object.prototype.hasOwnProperty, __propIsEnum = Object.prototype.propertyIsEnumerable, __knownSymbol = (C, L) => (L = Symbol[C]) ? L : Symbol.for("Symbol." + C), __defNormalProp = (C, L, A) => L in C ? __defProp$e(C, L, { enumerable: !0, configurable: !0, writable: !0, value: A }) : C[L] = A, __spreadValues = (C, L) => {
  for (var A in L || (L = {}))
    __hasOwnProp.call(L, A) && __defNormalProp(C, A, L[A]);
  if (__getOwnPropSymbols)
    for (var A of __getOwnPropSymbols(L))
      __propIsEnum.call(L, A) && __defNormalProp(C, A, L[A]);
  return C;
}, __spreadProps = (C, L) => __defProps(C, __getOwnPropDescs(L)), __decorateClass$e = (C, L, A, W) => {
  for (var X = W > 1 ? void 0 : W ? __getOwnPropDesc$d(L, A) : L, J = C.length - 1, te; J >= 0; J--)
    (te = C[J]) && (X = (W ? te(L, A, X) : te(X)) || X);
  return W && X && __defProp$e(L, A, X), X;
}, __await = function(C, L) {
  this[0] = C, this[1] = L;
}, __yieldStar = (C) => {
  var L = C[__knownSymbol("asyncIterator")], A = !1, W, X = {};
  return L == null ? (L = C[__knownSymbol("iterator")](), W = (J) => X[J] = (te) => L[J](te)) : (L = L.call(C), W = (J) => X[J] = (te) => {
    if (A) {
      if (A = !1, J === "throw")
        throw te;
      return te;
    }
    return A = !0, {
      done: !1,
      value: new __await(new Promise((oe) => {
        var ne = L[J](te);
        if (!(ne instanceof Object))
          throw TypeError("Object expected");
        oe(ne);
      }), 1)
    };
  }), X[__knownSymbol("iterator")] = () => X, W("next"), "throw" in L ? W("throw") : X.throw = (J) => {
    throw J;
  }, "return" in L && W("return"), X;
}, formCollections = /* @__PURE__ */ new WeakMap(), reportValidityOverloads = /* @__PURE__ */ new WeakMap(), checkValidityOverloads = /* @__PURE__ */ new WeakMap(), userInteractedControls = /* @__PURE__ */ new WeakSet(), interactions = /* @__PURE__ */ new WeakMap(), FormControlController = class {
  constructor(C, L) {
    this.handleFormData = (A) => {
      const W = this.options.disabled(this.host), X = this.options.name(this.host), J = this.options.value(this.host), te = this.host.tagName.toLowerCase() === "sl-button";
      this.host.isConnected && !W && !te && typeof X == "string" && X.length > 0 && typeof J < "u" && (Array.isArray(J) ? J.forEach((oe) => {
        A.formData.append(X, oe.toString());
      }) : A.formData.append(X, J.toString()));
    }, this.handleFormSubmit = (A) => {
      var W;
      const X = this.options.disabled(this.host), J = this.options.reportValidity;
      this.form && !this.form.noValidate && ((W = formCollections.get(this.form)) == null || W.forEach((te) => {
        this.setUserInteracted(te, !0);
      })), this.form && !this.form.noValidate && !X && !J(this.host) && (A.preventDefault(), A.stopImmediatePropagation());
    }, this.handleFormReset = () => {
      this.options.setValue(this.host, this.options.defaultValue(this.host)), this.setUserInteracted(this.host, !1), interactions.set(this.host, []);
    }, this.handleInteraction = (A) => {
      const W = interactions.get(this.host);
      W.includes(A.type) || W.push(A.type), W.length === this.options.assumeInteractionOn.length && this.setUserInteracted(this.host, !0);
    }, this.checkFormValidity = () => {
      if (this.form && !this.form.noValidate) {
        const A = this.form.querySelectorAll("*");
        for (const W of A)
          if (typeof W.checkValidity == "function" && !W.checkValidity())
            return !1;
      }
      return !0;
    }, this.reportFormValidity = () => {
      if (this.form && !this.form.noValidate) {
        const A = this.form.querySelectorAll("*");
        for (const W of A)
          if (typeof W.reportValidity == "function" && !W.reportValidity())
            return !1;
      }
      return !0;
    }, (this.host = C).addController(this), this.options = __spreadValues({
      form: (A) => {
        const W = A.form;
        if (W) {
          const J = A.getRootNode().querySelector(`#${W}`);
          if (J)
            return J;
        }
        return A.closest("form");
      },
      name: (A) => A.name,
      value: (A) => A.value,
      defaultValue: (A) => A.defaultValue,
      disabled: (A) => {
        var W;
        return (W = A.disabled) != null ? W : !1;
      },
      reportValidity: (A) => typeof A.reportValidity == "function" ? A.reportValidity() : !0,
      checkValidity: (A) => typeof A.checkValidity == "function" ? A.checkValidity() : !0,
      setValue: (A, W) => A.value = W,
      assumeInteractionOn: ["sl-input"]
    }, L);
  }
  hostConnected() {
    const C = this.options.form(this.host);
    C && this.attachForm(C), interactions.set(this.host, []), this.options.assumeInteractionOn.forEach((L) => {
      this.host.addEventListener(L, this.handleInteraction);
    });
  }
  hostDisconnected() {
    this.detachForm(), interactions.delete(this.host), this.options.assumeInteractionOn.forEach((C) => {
      this.host.removeEventListener(C, this.handleInteraction);
    });
  }
  hostUpdated() {
    const C = this.options.form(this.host);
    C || this.detachForm(), C && this.form !== C && (this.detachForm(), this.attachForm(C)), this.host.hasUpdated && this.setValidity(this.host.validity.valid);
  }
  attachForm(C) {
    C ? (this.form = C, formCollections.has(this.form) ? formCollections.get(this.form).add(this.host) : formCollections.set(this.form, /* @__PURE__ */ new Set([this.host])), this.form.addEventListener("formdata", this.handleFormData), this.form.addEventListener("submit", this.handleFormSubmit), this.form.addEventListener("reset", this.handleFormReset), reportValidityOverloads.has(this.form) || (reportValidityOverloads.set(this.form, this.form.reportValidity), this.form.reportValidity = () => this.reportFormValidity()), checkValidityOverloads.has(this.form) || (checkValidityOverloads.set(this.form, this.form.checkValidity), this.form.checkValidity = () => this.checkFormValidity())) : this.form = void 0;
  }
  detachForm() {
    if (!this.form)
      return;
    const C = formCollections.get(this.form);
    C && (C.delete(this.host), C.size <= 0 && (this.form.removeEventListener("formdata", this.handleFormData), this.form.removeEventListener("submit", this.handleFormSubmit), this.form.removeEventListener("reset", this.handleFormReset), reportValidityOverloads.has(this.form) && (this.form.reportValidity = reportValidityOverloads.get(this.form), reportValidityOverloads.delete(this.form)), checkValidityOverloads.has(this.form) && (this.form.checkValidity = checkValidityOverloads.get(this.form), checkValidityOverloads.delete(this.form)), this.form = void 0));
  }
  setUserInteracted(C, L) {
    L ? userInteractedControls.add(C) : userInteractedControls.delete(C), C.requestUpdate();
  }
  doAction(C, L) {
    if (this.form) {
      const A = document.createElement("button");
      A.type = C, A.style.position = "absolute", A.style.width = "0", A.style.height = "0", A.style.clipPath = "inset(50%)", A.style.overflow = "hidden", A.style.whiteSpace = "nowrap", L && (A.name = L.name, A.value = L.value, ["formaction", "formenctype", "formmethod", "formnovalidate", "formtarget"].forEach((W) => {
        L.hasAttribute(W) && A.setAttribute(W, L.getAttribute(W));
      })), this.form.append(A), A.click(), A.remove();
    }
  }
  /** Returns the associated `<form>` element, if one exists. */
  getForm() {
    var C;
    return (C = this.form) != null ? C : null;
  }
  /** Resets the form, restoring all the control to their default value */
  reset(C) {
    this.doAction("reset", C);
  }
  /** Submits the form, triggering validation and form data injection. */
  submit(C) {
    this.doAction("submit", C);
  }
  /**
   * Synchronously sets the form control's validity. Call this when you know the future validity but need to update
   * the host element immediately, i.e. before Lit updates the component in the next update.
   */
  setValidity(C) {
    const L = this.host, A = !!userInteractedControls.has(L), W = !!L.required;
    L.toggleAttribute("data-required", W), L.toggleAttribute("data-optional", !W), L.toggleAttribute("data-invalid", !C), L.toggleAttribute("data-valid", C), L.toggleAttribute("data-user-invalid", !C && A), L.toggleAttribute("data-user-valid", C && A);
  }
  /**
   * Updates the form control's validity based on the current value of `host.validity.valid`. Call this when anything
   * that affects constraint validation changes so the component receives the correct validity states.
   */
  updateValidity() {
    const C = this.host;
    this.setValidity(C.validity.valid);
  }
  /**
   * Dispatches a non-bubbling, cancelable custom event of type `sl-invalid`.
   * If the `sl-invalid` event will be cancelled then the original `invalid`
   * event (which may have been passed as argument) will also be cancelled.
   * If no original `invalid` event has been passed then the `sl-invalid`
   * event will be cancelled before being dispatched.
   */
  emitInvalidEvent(C) {
    const L = new CustomEvent("sl-invalid", {
      bubbles: !1,
      composed: !1,
      cancelable: !0,
      detail: {}
    });
    C || L.preventDefault(), this.host.dispatchEvent(L) || C == null || C.preventDefault();
  }
}, validValidityState = Object.freeze({
  badInput: !1,
  customError: !1,
  patternMismatch: !1,
  rangeOverflow: !1,
  rangeUnderflow: !1,
  stepMismatch: !1,
  tooLong: !1,
  tooShort: !1,
  typeMismatch: !1,
  valid: !0,
  valueMissing: !1
}), valueMissingValidityState = Object.freeze(__spreadProps(__spreadValues({}, validValidityState), {
  valid: !1,
  valueMissing: !0
})), customErrorValidityState = Object.freeze(__spreadProps(__spreadValues({}, validValidityState), {
  valid: !1,
  customError: !0
}));
/**
 * @license
 * Copyright 2019 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const t$5 = globalThis, e$9 = t$5.ShadowRoot && (t$5.ShadyCSS === void 0 || t$5.ShadyCSS.nativeShadow) && "adoptedStyleSheets" in Document.prototype && "replace" in CSSStyleSheet.prototype, s$5 = Symbol(), o$5 = /* @__PURE__ */ new WeakMap();
let n$4 = class {
  constructor(L, A, W) {
    if (this._$cssResult$ = !0, W !== s$5) throw Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");
    this.cssText = L, this.t = A;
  }
  get styleSheet() {
    let L = this.o;
    const A = this.t;
    if (e$9 && L === void 0) {
      const W = A !== void 0 && A.length === 1;
      W && (L = o$5.get(A)), L === void 0 && ((this.o = L = new CSSStyleSheet()).replaceSync(this.cssText), W && o$5.set(A, L));
    }
    return L;
  }
  toString() {
    return this.cssText;
  }
};
const r$6 = (C) => new n$4(typeof C == "string" ? C : C + "", void 0, s$5), i$5 = (C, ...L) => {
  const A = C.length === 1 ? C[0] : L.reduce((W, X, J) => W + ((te) => {
    if (te._$cssResult$ === !0) return te.cssText;
    if (typeof te == "number") return te;
    throw Error("Value passed to 'css' function must be a 'css' function result: " + te + ". Use 'unsafeCSS' to pass non-literal values, but take care to ensure page security.");
  })(X) + C[J + 1], C[0]);
  return new n$4(A, C, s$5);
}, S$1 = (C, L) => {
  if (e$9) C.adoptedStyleSheets = L.map((A) => A instanceof CSSStyleSheet ? A : A.styleSheet);
  else for (const A of L) {
    const W = document.createElement("style"), X = t$5.litNonce;
    X !== void 0 && W.setAttribute("nonce", X), W.textContent = A.cssText, C.appendChild(W);
  }
}, c$4 = e$9 ? (C) => C : (C) => C instanceof CSSStyleSheet ? ((L) => {
  let A = "";
  for (const W of L.cssRules) A += W.cssText;
  return r$6(A);
})(C) : C;
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const { is: i$4, defineProperty: e$8, getOwnPropertyDescriptor: r$5, getOwnPropertyNames: h$3, getOwnPropertySymbols: o$4, getPrototypeOf: n$3 } = Object, a$1 = globalThis, c$3 = a$1.trustedTypes, l$1 = c$3 ? c$3.emptyScript : "", p$1 = a$1.reactiveElementPolyfillSupport, d$1 = (C, L) => C, u$1 = { toAttribute(C, L) {
  switch (L) {
    case Boolean:
      C = C ? l$1 : null;
      break;
    case Object:
    case Array:
      C = C == null ? C : JSON.stringify(C);
  }
  return C;
}, fromAttribute(C, L) {
  let A = C;
  switch (L) {
    case Boolean:
      A = C !== null;
      break;
    case Number:
      A = C === null ? null : Number(C);
      break;
    case Object:
    case Array:
      try {
        A = JSON.parse(C);
      } catch {
        A = null;
      }
  }
  return A;
} }, f$3 = (C, L) => !i$4(C, L), y$1 = { attribute: !0, type: String, converter: u$1, reflect: !1, hasChanged: f$3 };
Symbol.metadata ?? (Symbol.metadata = Symbol("metadata")), a$1.litPropertyMetadata ?? (a$1.litPropertyMetadata = /* @__PURE__ */ new WeakMap());
let b$1 = class extends HTMLElement {
  static addInitializer(L) {
    this._$Ei(), (this.l ?? (this.l = [])).push(L);
  }
  static get observedAttributes() {
    return this.finalize(), this._$Eh && [...this._$Eh.keys()];
  }
  static createProperty(L, A = y$1) {
    if (A.state && (A.attribute = !1), this._$Ei(), this.elementProperties.set(L, A), !A.noAccessor) {
      const W = Symbol(), X = this.getPropertyDescriptor(L, W, A);
      X !== void 0 && e$8(this.prototype, L, X);
    }
  }
  static getPropertyDescriptor(L, A, W) {
    const { get: X, set: J } = r$5(this.prototype, L) ?? { get() {
      return this[A];
    }, set(te) {
      this[A] = te;
    } };
    return { get() {
      return X == null ? void 0 : X.call(this);
    }, set(te) {
      const oe = X == null ? void 0 : X.call(this);
      J.call(this, te), this.requestUpdate(L, oe, W);
    }, configurable: !0, enumerable: !0 };
  }
  static getPropertyOptions(L) {
    return this.elementProperties.get(L) ?? y$1;
  }
  static _$Ei() {
    if (this.hasOwnProperty(d$1("elementProperties"))) return;
    const L = n$3(this);
    L.finalize(), L.l !== void 0 && (this.l = [...L.l]), this.elementProperties = new Map(L.elementProperties);
  }
  static finalize() {
    if (this.hasOwnProperty(d$1("finalized"))) return;
    if (this.finalized = !0, this._$Ei(), this.hasOwnProperty(d$1("properties"))) {
      const A = this.properties, W = [...h$3(A), ...o$4(A)];
      for (const X of W) this.createProperty(X, A[X]);
    }
    const L = this[Symbol.metadata];
    if (L !== null) {
      const A = litPropertyMetadata.get(L);
      if (A !== void 0) for (const [W, X] of A) this.elementProperties.set(W, X);
    }
    this._$Eh = /* @__PURE__ */ new Map();
    for (const [A, W] of this.elementProperties) {
      const X = this._$Eu(A, W);
      X !== void 0 && this._$Eh.set(X, A);
    }
    this.elementStyles = this.finalizeStyles(this.styles);
  }
  static finalizeStyles(L) {
    const A = [];
    if (Array.isArray(L)) {
      const W = new Set(L.flat(1 / 0).reverse());
      for (const X of W) A.unshift(c$4(X));
    } else L !== void 0 && A.push(c$4(L));
    return A;
  }
  static _$Eu(L, A) {
    const W = A.attribute;
    return W === !1 ? void 0 : typeof W == "string" ? W : typeof L == "string" ? L.toLowerCase() : void 0;
  }
  constructor() {
    super(), this._$Ep = void 0, this.isUpdatePending = !1, this.hasUpdated = !1, this._$Em = null, this._$Ev();
  }
  _$Ev() {
    var L;
    this._$ES = new Promise((A) => this.enableUpdating = A), this._$AL = /* @__PURE__ */ new Map(), this._$E_(), this.requestUpdate(), (L = this.constructor.l) == null || L.forEach((A) => A(this));
  }
  addController(L) {
    var A;
    (this._$EO ?? (this._$EO = /* @__PURE__ */ new Set())).add(L), this.renderRoot !== void 0 && this.isConnected && ((A = L.hostConnected) == null || A.call(L));
  }
  removeController(L) {
    var A;
    (A = this._$EO) == null || A.delete(L);
  }
  _$E_() {
    const L = /* @__PURE__ */ new Map(), A = this.constructor.elementProperties;
    for (const W of A.keys()) this.hasOwnProperty(W) && (L.set(W, this[W]), delete this[W]);
    L.size > 0 && (this._$Ep = L);
  }
  createRenderRoot() {
    const L = this.shadowRoot ?? this.attachShadow(this.constructor.shadowRootOptions);
    return S$1(L, this.constructor.elementStyles), L;
  }
  connectedCallback() {
    var L;
    this.renderRoot ?? (this.renderRoot = this.createRenderRoot()), this.enableUpdating(!0), (L = this._$EO) == null || L.forEach((A) => {
      var W;
      return (W = A.hostConnected) == null ? void 0 : W.call(A);
    });
  }
  enableUpdating(L) {
  }
  disconnectedCallback() {
    var L;
    (L = this._$EO) == null || L.forEach((A) => {
      var W;
      return (W = A.hostDisconnected) == null ? void 0 : W.call(A);
    });
  }
  attributeChangedCallback(L, A, W) {
    this._$AK(L, W);
  }
  _$EC(L, A) {
    var J;
    const W = this.constructor.elementProperties.get(L), X = this.constructor._$Eu(L, W);
    if (X !== void 0 && W.reflect === !0) {
      const te = (((J = W.converter) == null ? void 0 : J.toAttribute) !== void 0 ? W.converter : u$1).toAttribute(A, W.type);
      this._$Em = L, te == null ? this.removeAttribute(X) : this.setAttribute(X, te), this._$Em = null;
    }
  }
  _$AK(L, A) {
    var J;
    const W = this.constructor, X = W._$Eh.get(L);
    if (X !== void 0 && this._$Em !== X) {
      const te = W.getPropertyOptions(X), oe = typeof te.converter == "function" ? { fromAttribute: te.converter } : ((J = te.converter) == null ? void 0 : J.fromAttribute) !== void 0 ? te.converter : u$1;
      this._$Em = X, this[X] = oe.fromAttribute(A, te.type), this._$Em = null;
    }
  }
  requestUpdate(L, A, W) {
    if (L !== void 0) {
      if (W ?? (W = this.constructor.getPropertyOptions(L)), !(W.hasChanged ?? f$3)(this[L], A)) return;
      this.P(L, A, W);
    }
    this.isUpdatePending === !1 && (this._$ES = this._$ET());
  }
  P(L, A, W) {
    this._$AL.has(L) || this._$AL.set(L, A), W.reflect === !0 && this._$Em !== L && (this._$Ej ?? (this._$Ej = /* @__PURE__ */ new Set())).add(L);
  }
  async _$ET() {
    this.isUpdatePending = !0;
    try {
      await this._$ES;
    } catch (A) {
      Promise.reject(A);
    }
    const L = this.scheduleUpdate();
    return L != null && await L, !this.isUpdatePending;
  }
  scheduleUpdate() {
    return this.performUpdate();
  }
  performUpdate() {
    var W;
    if (!this.isUpdatePending) return;
    if (!this.hasUpdated) {
      if (this.renderRoot ?? (this.renderRoot = this.createRenderRoot()), this._$Ep) {
        for (const [J, te] of this._$Ep) this[J] = te;
        this._$Ep = void 0;
      }
      const X = this.constructor.elementProperties;
      if (X.size > 0) for (const [J, te] of X) te.wrapped !== !0 || this._$AL.has(J) || this[J] === void 0 || this.P(J, this[J], te);
    }
    let L = !1;
    const A = this._$AL;
    try {
      L = this.shouldUpdate(A), L ? (this.willUpdate(A), (W = this._$EO) == null || W.forEach((X) => {
        var J;
        return (J = X.hostUpdate) == null ? void 0 : J.call(X);
      }), this.update(A)) : this._$EU();
    } catch (X) {
      throw L = !1, this._$EU(), X;
    }
    L && this._$AE(A);
  }
  willUpdate(L) {
  }
  _$AE(L) {
    var A;
    (A = this._$EO) == null || A.forEach((W) => {
      var X;
      return (X = W.hostUpdated) == null ? void 0 : X.call(W);
    }), this.hasUpdated || (this.hasUpdated = !0, this.firstUpdated(L)), this.updated(L);
  }
  _$EU() {
    this._$AL = /* @__PURE__ */ new Map(), this.isUpdatePending = !1;
  }
  get updateComplete() {
    return this.getUpdateComplete();
  }
  getUpdateComplete() {
    return this._$ES;
  }
  shouldUpdate(L) {
    return !0;
  }
  update(L) {
    this._$Ej && (this._$Ej = this._$Ej.forEach((A) => this._$EC(A, this[A]))), this._$EU();
  }
  updated(L) {
  }
  firstUpdated(L) {
  }
};
b$1.elementStyles = [], b$1.shadowRootOptions = { mode: "open" }, b$1[d$1("elementProperties")] = /* @__PURE__ */ new Map(), b$1[d$1("finalized")] = /* @__PURE__ */ new Map(), p$1 == null || p$1({ ReactiveElement: b$1 }), (a$1.reactiveElementVersions ?? (a$1.reactiveElementVersions = [])).push("2.0.4");
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const n$2 = globalThis, c$2 = n$2.trustedTypes, h$2 = c$2 ? c$2.createPolicy("lit-html", { createHTML: (C) => C }) : void 0, f$2 = "$lit$", v$1 = `lit$${Math.random().toFixed(9).slice(2)}$`, m = "?" + v$1, _$1 = `<${m}>`, w$1 = document, lt$1 = () => w$1.createComment(""), st = (C) => C === null || typeof C != "object" && typeof C != "function", g$3 = Array.isArray, $ = (C) => g$3(C) || typeof (C == null ? void 0 : C[Symbol.iterator]) == "function", x = `[ 	
\f\r]`, T = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g, E$1 = /-->/g, k = />/g, O = RegExp(`>|${x}(?:([^\\s"'>=/]+)(${x}*=${x}*(?:[^ 	
\f\r"'\`<>=]|("|')|))|$)`, "g"), S = /'/g, j = /"/g, M = /^(?:script|style|textarea|title)$/i, P = (C) => (L, ...A) => ({ _$litType$: C, strings: L, values: A }), ke$1 = P(1), Oe = P(2), R$1 = Symbol.for("lit-noChange"), D = Symbol.for("lit-nothing"), V = /* @__PURE__ */ new WeakMap(), I = w$1.createTreeWalker(w$1, 129);
function N(C, L) {
  if (!g$3(C) || !C.hasOwnProperty("raw")) throw Error("invalid template strings array");
  return h$2 !== void 0 ? h$2.createHTML(L) : L;
}
const U = (C, L) => {
  const A = C.length - 1, W = [];
  let X, J = L === 2 ? "<svg>" : L === 3 ? "<math>" : "", te = T;
  for (let oe = 0; oe < A; oe++) {
    const ne = C[oe];
    let re, ce, ue = -1, de = 0;
    for (; de < ne.length && (te.lastIndex = de, ce = te.exec(ne), ce !== null); ) de = te.lastIndex, te === T ? ce[1] === "!--" ? te = E$1 : ce[1] !== void 0 ? te = k : ce[2] !== void 0 ? (M.test(ce[2]) && (X = RegExp("</" + ce[2], "g")), te = O) : ce[3] !== void 0 && (te = O) : te === O ? ce[0] === ">" ? (te = X ?? T, ue = -1) : ce[1] === void 0 ? ue = -2 : (ue = te.lastIndex - ce[2].length, re = ce[1], te = ce[3] === void 0 ? O : ce[3] === '"' ? j : S) : te === j || te === S ? te = O : te === E$1 || te === k ? te = T : (te = O, X = void 0);
    const be = te === O && C[oe + 1].startsWith("/>") ? " " : "";
    J += te === T ? ne + _$1 : ue >= 0 ? (W.push(re), ne.slice(0, ue) + f$2 + ne.slice(ue) + v$1 + be) : ne + v$1 + (ue === -2 ? oe : be);
  }
  return [N(C, J + (C[A] || "<?>") + (L === 2 ? "</svg>" : L === 3 ? "</math>" : "")), W];
};
class B {
  constructor({ strings: L, _$litType$: A }, W) {
    let X;
    this.parts = [];
    let J = 0, te = 0;
    const oe = L.length - 1, ne = this.parts, [re, ce] = U(L, A);
    if (this.el = B.createElement(re, W), I.currentNode = this.el.content, A === 2 || A === 3) {
      const ue = this.el.content.firstChild;
      ue.replaceWith(...ue.childNodes);
    }
    for (; (X = I.nextNode()) !== null && ne.length < oe; ) {
      if (X.nodeType === 1) {
        if (X.hasAttributes()) for (const ue of X.getAttributeNames()) if (ue.endsWith(f$2)) {
          const de = ce[te++], be = X.getAttribute(ue).split(v$1), pe = /([.?@])?(.*)/.exec(de);
          ne.push({ type: 1, index: J, name: pe[2], strings: be, ctor: pe[1] === "." ? Y : pe[1] === "?" ? Z : pe[1] === "@" ? q : G$1 }), X.removeAttribute(ue);
        } else ue.startsWith(v$1) && (ne.push({ type: 6, index: J }), X.removeAttribute(ue));
        if (M.test(X.tagName)) {
          const ue = X.textContent.split(v$1), de = ue.length - 1;
          if (de > 0) {
            X.textContent = c$2 ? c$2.emptyScript : "";
            for (let be = 0; be < de; be++) X.append(ue[be], lt$1()), I.nextNode(), ne.push({ type: 2, index: ++J });
            X.append(ue[de], lt$1());
          }
        }
      } else if (X.nodeType === 8) if (X.data === m) ne.push({ type: 2, index: J });
      else {
        let ue = -1;
        for (; (ue = X.data.indexOf(v$1, ue + 1)) !== -1; ) ne.push({ type: 7, index: J }), ue += v$1.length - 1;
      }
      J++;
    }
  }
  static createElement(L, A) {
    const W = w$1.createElement("template");
    return W.innerHTML = L, W;
  }
}
function z(C, L, A = C, W) {
  var te, oe;
  if (L === R$1) return L;
  let X = W !== void 0 ? (te = A.o) == null ? void 0 : te[W] : A.l;
  const J = st(L) ? void 0 : L._$litDirective$;
  return (X == null ? void 0 : X.constructor) !== J && ((oe = X == null ? void 0 : X._$AO) == null || oe.call(X, !1), J === void 0 ? X = void 0 : (X = new J(C), X._$AT(C, A, W)), W !== void 0 ? (A.o ?? (A.o = []))[W] = X : A.l = X), X !== void 0 && (L = z(C, X._$AS(C, L.values), X, W)), L;
}
class F {
  constructor(L, A) {
    this._$AV = [], this._$AN = void 0, this._$AD = L, this._$AM = A;
  }
  get parentNode() {
    return this._$AM.parentNode;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  u(L) {
    const { el: { content: A }, parts: W } = this._$AD, X = ((L == null ? void 0 : L.creationScope) ?? w$1).importNode(A, !0);
    I.currentNode = X;
    let J = I.nextNode(), te = 0, oe = 0, ne = W[0];
    for (; ne !== void 0; ) {
      if (te === ne.index) {
        let re;
        ne.type === 2 ? re = new et$1(J, J.nextSibling, this, L) : ne.type === 1 ? re = new ne.ctor(J, ne.name, ne.strings, this, L) : ne.type === 6 && (re = new K(J, this, L)), this._$AV.push(re), ne = W[++oe];
      }
      te !== (ne == null ? void 0 : ne.index) && (J = I.nextNode(), te++);
    }
    return I.currentNode = w$1, X;
  }
  p(L) {
    let A = 0;
    for (const W of this._$AV) W !== void 0 && (W.strings !== void 0 ? (W._$AI(L, W, A), A += W.strings.length - 2) : W._$AI(L[A])), A++;
  }
}
let et$1 = class nr {
  get _$AU() {
    var L;
    return ((L = this._$AM) == null ? void 0 : L._$AU) ?? this.v;
  }
  constructor(L, A, W, X) {
    this.type = 2, this._$AH = D, this._$AN = void 0, this._$AA = L, this._$AB = A, this._$AM = W, this.options = X, this.v = (X == null ? void 0 : X.isConnected) ?? !0;
  }
  get parentNode() {
    let L = this._$AA.parentNode;
    const A = this._$AM;
    return A !== void 0 && (L == null ? void 0 : L.nodeType) === 11 && (L = A.parentNode), L;
  }
  get startNode() {
    return this._$AA;
  }
  get endNode() {
    return this._$AB;
  }
  _$AI(L, A = this) {
    L = z(this, L, A), st(L) ? L === D || L == null || L === "" ? (this._$AH !== D && this._$AR(), this._$AH = D) : L !== this._$AH && L !== R$1 && this._(L) : L._$litType$ !== void 0 ? this.$(L) : L.nodeType !== void 0 ? this.T(L) : $(L) ? this.k(L) : this._(L);
  }
  O(L) {
    return this._$AA.parentNode.insertBefore(L, this._$AB);
  }
  T(L) {
    this._$AH !== L && (this._$AR(), this._$AH = this.O(L));
  }
  _(L) {
    this._$AH !== D && st(this._$AH) ? this._$AA.nextSibling.data = L : this.T(w$1.createTextNode(L)), this._$AH = L;
  }
  $(L) {
    var J;
    const { values: A, _$litType$: W } = L, X = typeof W == "number" ? this._$AC(L) : (W.el === void 0 && (W.el = B.createElement(N(W.h, W.h[0]), this.options)), W);
    if (((J = this._$AH) == null ? void 0 : J._$AD) === X) this._$AH.p(A);
    else {
      const te = new F(X, this), oe = te.u(this.options);
      te.p(A), this.T(oe), this._$AH = te;
    }
  }
  _$AC(L) {
    let A = V.get(L.strings);
    return A === void 0 && V.set(L.strings, A = new B(L)), A;
  }
  k(L) {
    g$3(this._$AH) || (this._$AH = [], this._$AR());
    const A = this._$AH;
    let W, X = 0;
    for (const J of L) X === A.length ? A.push(W = new nr(this.O(lt$1()), this.O(lt$1()), this, this.options)) : W = A[X], W._$AI(J), X++;
    X < A.length && (this._$AR(W && W._$AB.nextSibling, X), A.length = X);
  }
  _$AR(L = this._$AA.nextSibling, A) {
    var W;
    for ((W = this._$AP) == null ? void 0 : W.call(this, !1, !0, A); L && L !== this._$AB; ) {
      const X = L.nextSibling;
      L.remove(), L = X;
    }
  }
  setConnected(L) {
    var A;
    this._$AM === void 0 && (this.v = L, (A = this._$AP) == null || A.call(this, L));
  }
}, G$1 = class {
  get tagName() {
    return this.element.tagName;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  constructor(L, A, W, X, J) {
    this.type = 1, this._$AH = D, this._$AN = void 0, this.element = L, this.name = A, this._$AM = X, this.options = J, W.length > 2 || W[0] !== "" || W[1] !== "" ? (this._$AH = Array(W.length - 1).fill(new String()), this.strings = W) : this._$AH = D;
  }
  _$AI(L, A = this, W, X) {
    const J = this.strings;
    let te = !1;
    if (J === void 0) L = z(this, L, A, 0), te = !st(L) || L !== this._$AH && L !== R$1, te && (this._$AH = L);
    else {
      const oe = L;
      let ne, re;
      for (L = J[0], ne = 0; ne < J.length - 1; ne++) re = z(this, oe[W + ne], A, ne), re === R$1 && (re = this._$AH[ne]), te || (te = !st(re) || re !== this._$AH[ne]), re === D ? L = D : L !== D && (L += (re ?? "") + J[ne + 1]), this._$AH[ne] = re;
    }
    te && !X && this.j(L);
  }
  j(L) {
    L === D ? this.element.removeAttribute(this.name) : this.element.setAttribute(this.name, L ?? "");
  }
};
class Y extends G$1 {
  constructor() {
    super(...arguments), this.type = 3;
  }
  j(L) {
    this.element[this.name] = L === D ? void 0 : L;
  }
}
class Z extends G$1 {
  constructor() {
    super(...arguments), this.type = 4;
  }
  j(L) {
    this.element.toggleAttribute(this.name, !!L && L !== D);
  }
}
class q extends G$1 {
  constructor(L, A, W, X, J) {
    super(L, A, W, X, J), this.type = 5;
  }
  _$AI(L, A = this) {
    if ((L = z(this, L, A, 0) ?? D) === R$1) return;
    const W = this._$AH, X = L === D && W !== D || L.capture !== W.capture || L.once !== W.once || L.passive !== W.passive, J = L !== D && (W === D || X);
    X && this.element.removeEventListener(this.name, this, W), J && this.element.addEventListener(this.name, this, L), this._$AH = L;
  }
  handleEvent(L) {
    var A;
    typeof this._$AH == "function" ? this._$AH.call(((A = this.options) == null ? void 0 : A.host) ?? this.element, L) : this._$AH.handleEvent(L);
  }
}
class K {
  constructor(L, A, W) {
    this.element = L, this.type = 6, this._$AN = void 0, this._$AM = A, this.options = W;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AI(L) {
    z(this, L);
  }
}
const si = { M: f$2, P: v$1, A: m, C: 1, L: U, R: F, D: $, V: z, I: et$1, H: G$1, N: Z, U: q, B: Y, F: K }, Re = n$2.litHtmlPolyfillSupport;
Re == null || Re(B, et$1), (n$2.litHtmlVersions ?? (n$2.litHtmlVersions = [])).push("3.2.0");
const Q = (C, L, A) => {
  const W = (A == null ? void 0 : A.renderBefore) ?? L;
  let X = W._$litPart$;
  if (X === void 0) {
    const J = (A == null ? void 0 : A.renderBefore) ?? null;
    W._$litPart$ = X = new et$1(L.insertBefore(lt$1(), J), J, void 0, A ?? {});
  }
  return X._$AI(C), X;
};
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
let h$1 = class extends b$1 {
  constructor() {
    super(...arguments), this.renderOptions = { host: this }, this.o = void 0;
  }
  createRenderRoot() {
    var A;
    const L = super.createRenderRoot();
    return (A = this.renderOptions).renderBefore ?? (A.renderBefore = L.firstChild), L;
  }
  update(L) {
    const A = this.render();
    this.hasUpdated || (this.renderOptions.isConnected = this.isConnected), super.update(L), this.o = Q(A, this.renderRoot, this.renderOptions);
  }
  connectedCallback() {
    var L;
    super.connectedCallback(), (L = this.o) == null || L.setConnected(!0);
  }
  disconnectedCallback() {
    var L;
    super.disconnectedCallback(), (L = this.o) == null || L.setConnected(!1);
  }
  render() {
    return R$1;
  }
};
var or;
h$1._$litElement$ = !0, h$1.finalized = !0, (or = globalThis.litElementHydrateSupport) == null || or.call(globalThis, { LitElement: h$1 });
const f$1 = globalThis.litElementPolyfillSupport;
f$1 == null || f$1({ LitElement: h$1 });
(globalThis.litElementVersions ?? (globalThis.litElementVersions = [])).push("4.1.0");
var visually_hidden_styles_default = i$5`
  :host(:not(:focus-within)) {
    position: absolute !important;
    width: 1px !important;
    height: 1px !important;
    clip: rect(0 0 0 0) !important;
    clip-path: inset(50%) !important;
    border: none !important;
    overflow: hidden !important;
    white-space: nowrap !important;
    padding: 0 !important;
  }
`, component_styles_default = i$5`
  :host {
    box-sizing: border-box;
  }

  :host *,
  :host *::before,
  :host *::after {
    box-sizing: inherit;
  }

  [hidden] {
    display: none !important;
  }
`;
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const t$4 = (C) => (L, A) => {
  A !== void 0 ? A.addInitializer(() => {
    customElements.define(C, L);
  }) : customElements.define(C, L);
};
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const o$3 = { attribute: !0, type: String, converter: u$1, reflect: !1, hasChanged: f$3 }, r$4 = (C = o$3, L, A) => {
  const { kind: W, metadata: X } = A;
  let J = globalThis.litPropertyMetadata.get(X);
  if (J === void 0 && globalThis.litPropertyMetadata.set(X, J = /* @__PURE__ */ new Map()), J.set(A.name, C), W === "accessor") {
    const { name: te } = A;
    return { set(oe) {
      const ne = L.get.call(this);
      L.set.call(this, oe), this.requestUpdate(te, ne, C);
    }, init(oe) {
      return oe !== void 0 && this.P(te, void 0, C), oe;
    } };
  }
  if (W === "setter") {
    const { name: te } = A;
    return function(oe) {
      const ne = this[te];
      L.call(this, oe), this.requestUpdate(te, ne, C);
    };
  }
  throw Error("Unsupported decorator location: " + W);
};
function n$1(C) {
  return (L, A) => typeof A == "object" ? r$4(C, L, A) : ((W, X, J) => {
    const te = X.hasOwnProperty(J);
    return X.constructor.createProperty(J, te ? { ...W, wrapped: !0 } : W), te ? Object.getOwnPropertyDescriptor(X, J) : void 0;
  })(C, L, A);
}
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
function r$3(C) {
  return n$1({ ...C, state: !0, attribute: !1 });
}
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
function t$3(C) {
  return (L, A) => {
    const W = typeof L == "function" ? L : L[A];
    Object.assign(W, C);
  };
}
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const e$7 = (C, L, A) => (A.configurable = !0, A.enumerable = !0, Reflect.decorate && typeof L != "object" && Object.defineProperty(C, L, A), A);
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
function e$6(C, L) {
  return (A, W, X) => {
    const J = (te) => {
      var oe;
      return ((oe = te.renderRoot) == null ? void 0 : oe.querySelector(C)) ?? null;
    };
    return e$7(A, W, { get() {
      return J(this);
    } });
  };
}
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
let e$5;
function r$2(C) {
  return (L, A) => e$7(L, A, { get() {
    return (this.renderRoot ?? e$5 ?? (e$5 = document.createDocumentFragment())).querySelectorAll(C);
  } });
}
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
function r$1(C) {
  return (L, A) => e$7(L, A, { async get() {
    var W;
    return await this.updateComplete, ((W = this.renderRoot) == null ? void 0 : W.querySelector(C)) ?? null;
  } });
}
/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
function o$2(C) {
  return (L, A) => {
    const { slot: W, selector: X } = C ?? {}, J = "slot" + (W ? `[name=${W}]` : ":not([name])");
    return e$7(L, A, { get() {
      var ne;
      const te = (ne = this.renderRoot) == null ? void 0 : ne.querySelector(J), oe = (te == null ? void 0 : te.assignedElements(C)) ?? [];
      return X === void 0 ? oe : oe.filter((re) => re.matches(X));
    } });
  };
}
var ShoelaceElement = class extends h$1 {
  constructor() {
    super(), Object.entries(this.constructor.dependencies).forEach(([C, L]) => {
      this.constructor.define(C, L);
    });
  }
  emit(C, L) {
    const A = new CustomEvent(C, __spreadValues({
      bubbles: !0,
      cancelable: !1,
      composed: !0,
      detail: {}
    }, L));
    return this.dispatchEvent(A), A;
  }
  /* eslint-enable */
  static define(C, L = this, A = {}) {
    const W = customElements.get(C);
    if (!W) {
      try {
        customElements.define(C, L, A);
      } catch {
        customElements.define(C, class extends L {
        }, A);
      }
      return;
    }
    let X = " (unknown version)", J = X;
    "version" in L && L.version && (X = " v" + L.version), "version" in W && W.version && (J = " v" + W.version), !(X && J && X === J) && console.warn(
      `Attempted to register <${C}>${X}, but <${C}>${J} has already been registered.`
    );
  }
};
ShoelaceElement.version = "2.16.0";
ShoelaceElement.dependencies = {};
__decorateClass$e([
  n$1()
], ShoelaceElement.prototype, "dir", 2);
__decorateClass$e([
  n$1()
], ShoelaceElement.prototype, "lang", 2);
var SlVisuallyHidden = class extends ShoelaceElement {
  render() {
    return ke$1` <slot></slot> `;
  }
};
SlVisuallyHidden.styles = [component_styles_default, visually_hidden_styles_default];
SlVisuallyHidden.define("sl-visually-hidden");
var tooltip_styles_default = i$5`
  :host {
    --max-width: 20rem;
    --hide-delay: 0ms;
    --show-delay: 150ms;

    display: contents;
  }

  .tooltip {
    --arrow-size: var(--sl-tooltip-arrow-size);
    --arrow-color: var(--sl-tooltip-background-color);
  }

  .tooltip::part(popup) {
    z-index: var(--sl-z-index-tooltip);
  }

  .tooltip[placement^='top']::part(popup) {
    transform-origin: bottom;
  }

  .tooltip[placement^='bottom']::part(popup) {
    transform-origin: top;
  }

  .tooltip[placement^='left']::part(popup) {
    transform-origin: right;
  }

  .tooltip[placement^='right']::part(popup) {
    transform-origin: left;
  }

  .tooltip__body {
    display: block;
    width: max-content;
    max-width: var(--max-width);
    border-radius: var(--sl-tooltip-border-radius);
    background-color: var(--sl-tooltip-background-color);
    font-family: var(--sl-tooltip-font-family);
    font-size: var(--sl-tooltip-font-size);
    font-weight: var(--sl-tooltip-font-weight);
    line-height: var(--sl-tooltip-line-height);
    text-align: start;
    white-space: normal;
    color: var(--sl-tooltip-color);
    padding: var(--sl-tooltip-padding);
    pointer-events: none;
    user-select: none;
    -webkit-user-select: none;
  }
`, popup_styles_default = i$5`
  :host {
    --arrow-color: var(--sl-color-neutral-1000);
    --arrow-size: 6px;

    /*
     * These properties are computed to account for the arrow's dimensions after being rotated 45º. The constant
     * 0.7071 is derived from sin(45), which is the diagonal size of the arrow's container after rotating.
     */
    --arrow-size-diagonal: calc(var(--arrow-size) * 0.7071);
    --arrow-padding-offset: calc(var(--arrow-size-diagonal) - var(--arrow-size));

    display: contents;
  }

  .popup {
    position: absolute;
    isolation: isolate;
    max-width: var(--auto-size-available-width, none);
    max-height: var(--auto-size-available-height, none);
  }

  .popup--fixed {
    position: fixed;
  }

  .popup:not(.popup--active) {
    display: none;
  }

  .popup__arrow {
    position: absolute;
    width: calc(var(--arrow-size-diagonal) * 2);
    height: calc(var(--arrow-size-diagonal) * 2);
    rotate: 45deg;
    background: var(--arrow-color);
    z-index: -1;
  }

  /* Hover bridge */
  .popup-hover-bridge:not(.popup-hover-bridge--visible) {
    display: none;
  }

  .popup-hover-bridge {
    position: fixed;
    z-index: calc(var(--sl-z-index-dropdown) - 1);
    top: 0;
    right: 0;
    bottom: 0;
    left: 0;
    clip-path: polygon(
      var(--hover-bridge-top-left-x, 0) var(--hover-bridge-top-left-y, 0),
      var(--hover-bridge-top-right-x, 0) var(--hover-bridge-top-right-y, 0),
      var(--hover-bridge-bottom-right-x, 0) var(--hover-bridge-bottom-right-y, 0),
      var(--hover-bridge-bottom-left-x, 0) var(--hover-bridge-bottom-left-y, 0)
    );
  }
`;
const min$4 = Math.min, max$5 = Math.max, round$7 = Math.round, floor$4 = Math.floor, createCoords = (C) => ({
  x: C,
  y: C
}), oppositeSideMap = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
}, oppositeAlignmentMap = {
  start: "end",
  end: "start"
};
function clamp$1(C, L, A) {
  return max$5(C, min$4(L, A));
}
function evaluate(C, L) {
  return typeof C == "function" ? C(L) : C;
}
function getSide(C) {
  return C.split("-")[0];
}
function getAlignment(C) {
  return C.split("-")[1];
}
function getOppositeAxis(C) {
  return C === "x" ? "y" : "x";
}
function getAxisLength(C) {
  return C === "y" ? "height" : "width";
}
function getSideAxis(C) {
  return ["top", "bottom"].includes(getSide(C)) ? "y" : "x";
}
function getAlignmentAxis(C) {
  return getOppositeAxis(getSideAxis(C));
}
function getAlignmentSides(C, L, A) {
  A === void 0 && (A = !1);
  const W = getAlignment(C), X = getAlignmentAxis(C), J = getAxisLength(X);
  let te = X === "x" ? W === (A ? "end" : "start") ? "right" : "left" : W === "start" ? "bottom" : "top";
  return L.reference[J] > L.floating[J] && (te = getOppositePlacement(te)), [te, getOppositePlacement(te)];
}
function getExpandedPlacements(C) {
  const L = getOppositePlacement(C);
  return [getOppositeAlignmentPlacement(C), L, getOppositeAlignmentPlacement(L)];
}
function getOppositeAlignmentPlacement(C) {
  return C.replace(/start|end/g, (L) => oppositeAlignmentMap[L]);
}
function getSideList(C, L, A) {
  const W = ["left", "right"], X = ["right", "left"], J = ["top", "bottom"], te = ["bottom", "top"];
  switch (C) {
    case "top":
    case "bottom":
      return A ? L ? X : W : L ? W : X;
    case "left":
    case "right":
      return L ? J : te;
    default:
      return [];
  }
}
function getOppositeAxisPlacements(C, L, A, W) {
  const X = getAlignment(C);
  let J = getSideList(getSide(C), A === "start", W);
  return X && (J = J.map((te) => te + "-" + X), L && (J = J.concat(J.map(getOppositeAlignmentPlacement)))), J;
}
function getOppositePlacement(C) {
  return C.replace(/left|right|bottom|top/g, (L) => oppositeSideMap[L]);
}
function expandPaddingObject(C) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...C
  };
}
function getPaddingObject(C) {
  return typeof C != "number" ? expandPaddingObject(C) : {
    top: C,
    right: C,
    bottom: C,
    left: C
  };
}
function rectToClientRect(C) {
  const {
    x: L,
    y: A,
    width: W,
    height: X
  } = C;
  return {
    width: W,
    height: X,
    top: A,
    left: L,
    right: L + W,
    bottom: A + X,
    x: L,
    y: A
  };
}
function computeCoordsFromPlacement(C, L, A) {
  let {
    reference: W,
    floating: X
  } = C;
  const J = getSideAxis(L), te = getAlignmentAxis(L), oe = getAxisLength(te), ne = getSide(L), re = J === "y", ce = W.x + W.width / 2 - X.width / 2, ue = W.y + W.height / 2 - X.height / 2, de = W[oe] / 2 - X[oe] / 2;
  let be;
  switch (ne) {
    case "top":
      be = {
        x: ce,
        y: W.y - X.height
      };
      break;
    case "bottom":
      be = {
        x: ce,
        y: W.y + W.height
      };
      break;
    case "right":
      be = {
        x: W.x + W.width,
        y: ue
      };
      break;
    case "left":
      be = {
        x: W.x - X.width,
        y: ue
      };
      break;
    default:
      be = {
        x: W.x,
        y: W.y
      };
  }
  switch (getAlignment(L)) {
    case "start":
      be[te] -= de * (A && re ? -1 : 1);
      break;
    case "end":
      be[te] += de * (A && re ? -1 : 1);
      break;
  }
  return be;
}
const computePosition$1 = async (C, L, A) => {
  const {
    placement: W = "bottom",
    strategy: X = "absolute",
    middleware: J = [],
    platform: te
  } = A, oe = J.filter(Boolean), ne = await (te.isRTL == null ? void 0 : te.isRTL(L));
  let re = await te.getElementRects({
    reference: C,
    floating: L,
    strategy: X
  }), {
    x: ce,
    y: ue
  } = computeCoordsFromPlacement(re, W, ne), de = W, be = {}, pe = 0;
  for (let me = 0; me < oe.length; me++) {
    const {
      name: Me,
      fn: he
    } = oe[me], {
      x: ge,
      y: Ce,
      data: Se,
      reset: Ae
    } = await he({
      x: ce,
      y: ue,
      initialPlacement: W,
      placement: de,
      strategy: X,
      middlewareData: be,
      rects: re,
      platform: te,
      elements: {
        reference: C,
        floating: L
      }
    });
    ce = ge ?? ce, ue = Ce ?? ue, be = {
      ...be,
      [Me]: {
        ...be[Me],
        ...Se
      }
    }, Ae && pe <= 50 && (pe++, typeof Ae == "object" && (Ae.placement && (de = Ae.placement), Ae.rects && (re = Ae.rects === !0 ? await te.getElementRects({
      reference: C,
      floating: L,
      strategy: X
    }) : Ae.rects), {
      x: ce,
      y: ue
    } = computeCoordsFromPlacement(re, de, ne)), me = -1);
  }
  return {
    x: ce,
    y: ue,
    placement: de,
    strategy: X,
    middlewareData: be
  };
};
async function detectOverflow(C, L) {
  var A;
  L === void 0 && (L = {});
  const {
    x: W,
    y: X,
    platform: J,
    rects: te,
    elements: oe,
    strategy: ne
  } = C, {
    boundary: re = "clippingAncestors",
    rootBoundary: ce = "viewport",
    elementContext: ue = "floating",
    altBoundary: de = !1,
    padding: be = 0
  } = evaluate(L, C), pe = getPaddingObject(be), Me = oe[de ? ue === "floating" ? "reference" : "floating" : ue], he = rectToClientRect(await J.getClippingRect({
    element: (A = await (J.isElement == null ? void 0 : J.isElement(Me))) == null || A ? Me : Me.contextElement || await (J.getDocumentElement == null ? void 0 : J.getDocumentElement(oe.floating)),
    boundary: re,
    rootBoundary: ce,
    strategy: ne
  })), ge = ue === "floating" ? {
    x: W,
    y: X,
    width: te.floating.width,
    height: te.floating.height
  } : te.reference, Ce = await (J.getOffsetParent == null ? void 0 : J.getOffsetParent(oe.floating)), Se = await (J.isElement == null ? void 0 : J.isElement(Ce)) ? await (J.getScale == null ? void 0 : J.getScale(Ce)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  }, Ae = rectToClientRect(J.convertOffsetParentRelativeRectToViewportRelativeRect ? await J.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements: oe,
    rect: ge,
    offsetParent: Ce,
    strategy: ne
  }) : ge);
  return {
    top: (he.top - Ae.top + pe.top) / Se.y,
    bottom: (Ae.bottom - he.bottom + pe.bottom) / Se.y,
    left: (he.left - Ae.left + pe.left) / Se.x,
    right: (Ae.right - he.right + pe.right) / Se.x
  };
}
const arrow$1 = (C) => ({
  name: "arrow",
  options: C,
  async fn(L) {
    const {
      x: A,
      y: W,
      placement: X,
      rects: J,
      platform: te,
      elements: oe,
      middlewareData: ne
    } = L, {
      element: re,
      padding: ce = 0
    } = evaluate(C, L) || {};
    if (re == null)
      return {};
    const ue = getPaddingObject(ce), de = {
      x: A,
      y: W
    }, be = getAlignmentAxis(X), pe = getAxisLength(be), me = await te.getDimensions(re), Me = be === "y", he = Me ? "top" : "left", ge = Me ? "bottom" : "right", Ce = Me ? "clientHeight" : "clientWidth", Se = J.reference[pe] + J.reference[be] - de[be] - J.floating[pe], Ae = de[be] - J.reference[be], Le = await (te.getOffsetParent == null ? void 0 : te.getOffsetParent(re));
    let ve = Le ? Le[Ce] : 0;
    (!ve || !await (te.isElement == null ? void 0 : te.isElement(Le))) && (ve = oe.floating[Ce] || J.floating[pe]);
    const De = Se / 2 - Ae / 2, Ue = ve / 2 - me[pe] / 2 - 1, Fe = min$4(ue[he], Ue), We = min$4(ue[ge], Ue), Ke = Fe, it = ve - me[pe] - We, Qe = ve / 2 - me[pe] / 2 + De, vt = clamp$1(Ke, Qe, it), Ct = !ne.arrow && getAlignment(X) != null && Qe !== vt && J.reference[pe] / 2 - (Qe < Ke ? Fe : We) - me[pe] / 2 < 0, Tt = Ct ? Qe < Ke ? Qe - Ke : Qe - it : 0;
    return {
      [be]: de[be] + Tt,
      data: {
        [be]: vt,
        centerOffset: Qe - vt - Tt,
        ...Ct && {
          alignmentOffset: Tt
        }
      },
      reset: Ct
    };
  }
}), flip$2 = function(C) {
  return C === void 0 && (C = {}), {
    name: "flip",
    options: C,
    async fn(L) {
      var A, W;
      const {
        placement: X,
        middlewareData: J,
        rects: te,
        initialPlacement: oe,
        platform: ne,
        elements: re
      } = L, {
        mainAxis: ce = !0,
        crossAxis: ue = !0,
        fallbackPlacements: de,
        fallbackStrategy: be = "bestFit",
        fallbackAxisSideDirection: pe = "none",
        flipAlignment: me = !0,
        ...Me
      } = evaluate(C, L);
      if ((A = J.arrow) != null && A.alignmentOffset)
        return {};
      const he = getSide(X), ge = getSideAxis(oe), Ce = getSide(oe) === oe, Se = await (ne.isRTL == null ? void 0 : ne.isRTL(re.floating)), Ae = de || (Ce || !me ? [getOppositePlacement(oe)] : getExpandedPlacements(oe)), Le = pe !== "none";
      !de && Le && Ae.push(...getOppositeAxisPlacements(oe, me, pe, Se));
      const ve = [oe, ...Ae], De = await detectOverflow(L, Me), Ue = [];
      let Fe = ((W = J.flip) == null ? void 0 : W.overflows) || [];
      if (ce && Ue.push(De[he]), ue) {
        const Qe = getAlignmentSides(X, te, Se);
        Ue.push(De[Qe[0]], De[Qe[1]]);
      }
      if (Fe = [...Fe, {
        placement: X,
        overflows: Ue
      }], !Ue.every((Qe) => Qe <= 0)) {
        var We, Ke;
        const Qe = (((We = J.flip) == null ? void 0 : We.index) || 0) + 1, vt = ve[Qe];
        if (vt)
          return {
            data: {
              index: Qe,
              overflows: Fe
            },
            reset: {
              placement: vt
            }
          };
        let Ct = (Ke = Fe.filter((Tt) => Tt.overflows[0] <= 0).sort((Tt, St) => Tt.overflows[1] - St.overflows[1])[0]) == null ? void 0 : Ke.placement;
        if (!Ct)
          switch (be) {
            case "bestFit": {
              var it;
              const Tt = (it = Fe.filter((St) => {
                if (Le) {
                  const Je = getSideAxis(St.placement);
                  return Je === ge || // Create a bias to the `y` side axis due to horizontal
                  // reading directions favoring greater width.
                  Je === "y";
                }
                return !0;
              }).map((St) => [St.placement, St.overflows.filter((Je) => Je > 0).reduce((Je, He) => Je + He, 0)]).sort((St, Je) => St[1] - Je[1])[0]) == null ? void 0 : it[0];
              Tt && (Ct = Tt);
              break;
            }
            case "initialPlacement":
              Ct = oe;
              break;
          }
        if (X !== Ct)
          return {
            reset: {
              placement: Ct
            }
          };
      }
      return {};
    }
  };
};
async function convertValueToCoords(C, L) {
  const {
    placement: A,
    platform: W,
    elements: X
  } = C, J = await (W.isRTL == null ? void 0 : W.isRTL(X.floating)), te = getSide(A), oe = getAlignment(A), ne = getSideAxis(A) === "y", re = ["left", "top"].includes(te) ? -1 : 1, ce = J && ne ? -1 : 1, ue = evaluate(L, C);
  let {
    mainAxis: de,
    crossAxis: be,
    alignmentAxis: pe
  } = typeof ue == "number" ? {
    mainAxis: ue,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: 0,
    crossAxis: 0,
    alignmentAxis: null,
    ...ue
  };
  return oe && typeof pe == "number" && (be = oe === "end" ? pe * -1 : pe), ne ? {
    x: be * ce,
    y: de * re
  } : {
    x: de * re,
    y: be * ce
  };
}
const offset$1 = function(C) {
  return C === void 0 && (C = 0), {
    name: "offset",
    options: C,
    async fn(L) {
      var A, W;
      const {
        x: X,
        y: J,
        placement: te,
        middlewareData: oe
      } = L, ne = await convertValueToCoords(L, C);
      return te === ((A = oe.offset) == null ? void 0 : A.placement) && (W = oe.arrow) != null && W.alignmentOffset ? {} : {
        x: X + ne.x,
        y: J + ne.y,
        data: {
          ...ne,
          placement: te
        }
      };
    }
  };
}, shift$1 = function(C) {
  return C === void 0 && (C = {}), {
    name: "shift",
    options: C,
    async fn(L) {
      const {
        x: A,
        y: W,
        placement: X
      } = L, {
        mainAxis: J = !0,
        crossAxis: te = !1,
        limiter: oe = {
          fn: (Me) => {
            let {
              x: he,
              y: ge
            } = Me;
            return {
              x: he,
              y: ge
            };
          }
        },
        ...ne
      } = evaluate(C, L), re = {
        x: A,
        y: W
      }, ce = await detectOverflow(L, ne), ue = getSideAxis(getSide(X)), de = getOppositeAxis(ue);
      let be = re[de], pe = re[ue];
      if (J) {
        const Me = de === "y" ? "top" : "left", he = de === "y" ? "bottom" : "right", ge = be + ce[Me], Ce = be - ce[he];
        be = clamp$1(ge, be, Ce);
      }
      if (te) {
        const Me = ue === "y" ? "top" : "left", he = ue === "y" ? "bottom" : "right", ge = pe + ce[Me], Ce = pe - ce[he];
        pe = clamp$1(ge, pe, Ce);
      }
      const me = oe.fn({
        ...L,
        [de]: be,
        [ue]: pe
      });
      return {
        ...me,
        data: {
          x: me.x - A,
          y: me.y - W
        }
      };
    }
  };
}, size$1 = function(C) {
  return C === void 0 && (C = {}), {
    name: "size",
    options: C,
    async fn(L) {
      const {
        placement: A,
        rects: W,
        platform: X,
        elements: J
      } = L, {
        apply: te = () => {
        },
        ...oe
      } = evaluate(C, L), ne = await detectOverflow(L, oe), re = getSide(A), ce = getAlignment(A), ue = getSideAxis(A) === "y", {
        width: de,
        height: be
      } = W.floating;
      let pe, me;
      re === "top" || re === "bottom" ? (pe = re, me = ce === (await (X.isRTL == null ? void 0 : X.isRTL(J.floating)) ? "start" : "end") ? "left" : "right") : (me = re, pe = ce === "end" ? "top" : "bottom");
      const Me = be - ne.top - ne.bottom, he = de - ne.left - ne.right, ge = min$4(be - ne[pe], Me), Ce = min$4(de - ne[me], he), Se = !L.middlewareData.shift;
      let Ae = ge, Le = Ce;
      if (ue ? Le = ce || Se ? min$4(Ce, he) : he : Ae = ce || Se ? min$4(ge, Me) : Me, Se && !ce) {
        const De = max$5(ne.left, 0), Ue = max$5(ne.right, 0), Fe = max$5(ne.top, 0), We = max$5(ne.bottom, 0);
        ue ? Le = de - 2 * (De !== 0 || Ue !== 0 ? De + Ue : max$5(ne.left, ne.right)) : Ae = be - 2 * (Fe !== 0 || We !== 0 ? Fe + We : max$5(ne.top, ne.bottom));
      }
      await te({
        ...L,
        availableWidth: Le,
        availableHeight: Ae
      });
      const ve = await X.getDimensions(J.floating);
      return de !== ve.width || be !== ve.height ? {
        reset: {
          rects: !0
        }
      } : {};
    }
  };
};
function getNodeName(C) {
  return isNode(C) ? (C.nodeName || "").toLowerCase() : "#document";
}
function getWindow(C) {
  var L;
  return (C == null || (L = C.ownerDocument) == null ? void 0 : L.defaultView) || window;
}
function getDocumentElement(C) {
  var L;
  return (L = (isNode(C) ? C.ownerDocument : C.document) || window.document) == null ? void 0 : L.documentElement;
}
function isNode(C) {
  return C instanceof Node || C instanceof getWindow(C).Node;
}
function isElement(C) {
  return C instanceof Element || C instanceof getWindow(C).Element;
}
function isHTMLElement(C) {
  return C instanceof HTMLElement || C instanceof getWindow(C).HTMLElement;
}
function isShadowRoot(C) {
  return typeof ShadowRoot > "u" ? !1 : C instanceof ShadowRoot || C instanceof getWindow(C).ShadowRoot;
}
function isOverflowElement(C) {
  const {
    overflow: L,
    overflowX: A,
    overflowY: W,
    display: X
  } = getComputedStyle$1(C);
  return /auto|scroll|overlay|hidden|clip/.test(L + W + A) && !["inline", "contents"].includes(X);
}
function isTableElement(C) {
  return ["table", "td", "th"].includes(getNodeName(C));
}
function isTopLayer(C) {
  return [":popover-open", ":modal"].some((L) => {
    try {
      return C.matches(L);
    } catch {
      return !1;
    }
  });
}
function isContainingBlock(C) {
  const L = isWebKit(), A = isElement(C) ? getComputedStyle$1(C) : C;
  return A.transform !== "none" || A.perspective !== "none" || (A.containerType ? A.containerType !== "normal" : !1) || !L && (A.backdropFilter ? A.backdropFilter !== "none" : !1) || !L && (A.filter ? A.filter !== "none" : !1) || ["transform", "perspective", "filter"].some((W) => (A.willChange || "").includes(W)) || ["paint", "layout", "strict", "content"].some((W) => (A.contain || "").includes(W));
}
function getContainingBlock(C) {
  let L = getParentNode(C);
  for (; isHTMLElement(L) && !isLastTraversableNode(L); ) {
    if (isContainingBlock(L))
      return L;
    if (isTopLayer(L))
      return null;
    L = getParentNode(L);
  }
  return null;
}
function isWebKit() {
  return typeof CSS > "u" || !CSS.supports ? !1 : CSS.supports("-webkit-backdrop-filter", "none");
}
function isLastTraversableNode(C) {
  return ["html", "body", "#document"].includes(getNodeName(C));
}
function getComputedStyle$1(C) {
  return getWindow(C).getComputedStyle(C);
}
function getNodeScroll(C) {
  return isElement(C) ? {
    scrollLeft: C.scrollLeft,
    scrollTop: C.scrollTop
  } : {
    scrollLeft: C.scrollX,
    scrollTop: C.scrollY
  };
}
function getParentNode(C) {
  if (getNodeName(C) === "html")
    return C;
  const L = (
    // Step into the shadow DOM of the parent of a slotted node.
    C.assignedSlot || // DOM Element detected.
    C.parentNode || // ShadowRoot detected.
    isShadowRoot(C) && C.host || // Fallback.
    getDocumentElement(C)
  );
  return isShadowRoot(L) ? L.host : L;
}
function getNearestOverflowAncestor(C) {
  const L = getParentNode(C);
  return isLastTraversableNode(L) ? C.ownerDocument ? C.ownerDocument.body : C.body : isHTMLElement(L) && isOverflowElement(L) ? L : getNearestOverflowAncestor(L);
}
function getOverflowAncestors(C, L, A) {
  var W;
  L === void 0 && (L = []), A === void 0 && (A = !0);
  const X = getNearestOverflowAncestor(C), J = X === ((W = C.ownerDocument) == null ? void 0 : W.body), te = getWindow(X);
  if (J) {
    const oe = getFrameElement(te);
    return L.concat(te, te.visualViewport || [], isOverflowElement(X) ? X : [], oe && A ? getOverflowAncestors(oe) : []);
  }
  return L.concat(X, getOverflowAncestors(X, [], A));
}
function getFrameElement(C) {
  return Object.getPrototypeOf(C.parent) ? C.frameElement : null;
}
function getCssDimensions(C) {
  const L = getComputedStyle$1(C);
  let A = parseFloat(L.width) || 0, W = parseFloat(L.height) || 0;
  const X = isHTMLElement(C), J = X ? C.offsetWidth : A, te = X ? C.offsetHeight : W, oe = round$7(A) !== J || round$7(W) !== te;
  return oe && (A = J, W = te), {
    width: A,
    height: W,
    $: oe
  };
}
function unwrapElement(C) {
  return isElement(C) ? C : C.contextElement;
}
function getScale(C) {
  const L = unwrapElement(C);
  if (!isHTMLElement(L))
    return createCoords(1);
  const A = L.getBoundingClientRect(), {
    width: W,
    height: X,
    $: J
  } = getCssDimensions(L);
  let te = (J ? round$7(A.width) : A.width) / W, oe = (J ? round$7(A.height) : A.height) / X;
  return (!te || !Number.isFinite(te)) && (te = 1), (!oe || !Number.isFinite(oe)) && (oe = 1), {
    x: te,
    y: oe
  };
}
const noOffsets = /* @__PURE__ */ createCoords(0);
function getVisualOffsets(C) {
  const L = getWindow(C);
  return !isWebKit() || !L.visualViewport ? noOffsets : {
    x: L.visualViewport.offsetLeft,
    y: L.visualViewport.offsetTop
  };
}
function shouldAddVisualOffsets(C, L, A) {
  return L === void 0 && (L = !1), !A || L && A !== getWindow(C) ? !1 : L;
}
function getBoundingClientRect(C, L, A, W) {
  L === void 0 && (L = !1), A === void 0 && (A = !1);
  const X = C.getBoundingClientRect(), J = unwrapElement(C);
  let te = createCoords(1);
  L && (W ? isElement(W) && (te = getScale(W)) : te = getScale(C));
  const oe = shouldAddVisualOffsets(J, A, W) ? getVisualOffsets(J) : createCoords(0);
  let ne = (X.left + oe.x) / te.x, re = (X.top + oe.y) / te.y, ce = X.width / te.x, ue = X.height / te.y;
  if (J) {
    const de = getWindow(J), be = W && isElement(W) ? getWindow(W) : W;
    let pe = de, me = getFrameElement(pe);
    for (; me && W && be !== pe; ) {
      const Me = getScale(me), he = me.getBoundingClientRect(), ge = getComputedStyle$1(me), Ce = he.left + (me.clientLeft + parseFloat(ge.paddingLeft)) * Me.x, Se = he.top + (me.clientTop + parseFloat(ge.paddingTop)) * Me.y;
      ne *= Me.x, re *= Me.y, ce *= Me.x, ue *= Me.y, ne += Ce, re += Se, pe = getWindow(me), me = getFrameElement(pe);
    }
  }
  return rectToClientRect({
    width: ce,
    height: ue,
    x: ne,
    y: re
  });
}
function convertOffsetParentRelativeRectToViewportRelativeRect(C) {
  let {
    elements: L,
    rect: A,
    offsetParent: W,
    strategy: X
  } = C;
  const J = X === "fixed", te = getDocumentElement(W), oe = L ? isTopLayer(L.floating) : !1;
  if (W === te || oe && J)
    return A;
  let ne = {
    scrollLeft: 0,
    scrollTop: 0
  }, re = createCoords(1);
  const ce = createCoords(0), ue = isHTMLElement(W);
  if ((ue || !ue && !J) && ((getNodeName(W) !== "body" || isOverflowElement(te)) && (ne = getNodeScroll(W)), isHTMLElement(W))) {
    const de = getBoundingClientRect(W);
    re = getScale(W), ce.x = de.x + W.clientLeft, ce.y = de.y + W.clientTop;
  }
  return {
    width: A.width * re.x,
    height: A.height * re.y,
    x: A.x * re.x - ne.scrollLeft * re.x + ce.x,
    y: A.y * re.y - ne.scrollTop * re.y + ce.y
  };
}
function getClientRects(C) {
  return Array.from(C.getClientRects());
}
function getWindowScrollBarX(C) {
  return getBoundingClientRect(getDocumentElement(C)).left + getNodeScroll(C).scrollLeft;
}
function getDocumentRect(C) {
  const L = getDocumentElement(C), A = getNodeScroll(C), W = C.ownerDocument.body, X = max$5(L.scrollWidth, L.clientWidth, W.scrollWidth, W.clientWidth), J = max$5(L.scrollHeight, L.clientHeight, W.scrollHeight, W.clientHeight);
  let te = -A.scrollLeft + getWindowScrollBarX(C);
  const oe = -A.scrollTop;
  return getComputedStyle$1(W).direction === "rtl" && (te += max$5(L.clientWidth, W.clientWidth) - X), {
    width: X,
    height: J,
    x: te,
    y: oe
  };
}
function getViewportRect(C, L) {
  const A = getWindow(C), W = getDocumentElement(C), X = A.visualViewport;
  let J = W.clientWidth, te = W.clientHeight, oe = 0, ne = 0;
  if (X) {
    J = X.width, te = X.height;
    const re = isWebKit();
    (!re || re && L === "fixed") && (oe = X.offsetLeft, ne = X.offsetTop);
  }
  return {
    width: J,
    height: te,
    x: oe,
    y: ne
  };
}
function getInnerBoundingClientRect(C, L) {
  const A = getBoundingClientRect(C, !0, L === "fixed"), W = A.top + C.clientTop, X = A.left + C.clientLeft, J = isHTMLElement(C) ? getScale(C) : createCoords(1), te = C.clientWidth * J.x, oe = C.clientHeight * J.y, ne = X * J.x, re = W * J.y;
  return {
    width: te,
    height: oe,
    x: ne,
    y: re
  };
}
function getClientRectFromClippingAncestor(C, L, A) {
  let W;
  if (L === "viewport")
    W = getViewportRect(C, A);
  else if (L === "document")
    W = getDocumentRect(getDocumentElement(C));
  else if (isElement(L))
    W = getInnerBoundingClientRect(L, A);
  else {
    const X = getVisualOffsets(C);
    W = {
      ...L,
      x: L.x - X.x,
      y: L.y - X.y
    };
  }
  return rectToClientRect(W);
}
function hasFixedPositionAncestor(C, L) {
  const A = getParentNode(C);
  return A === L || !isElement(A) || isLastTraversableNode(A) ? !1 : getComputedStyle$1(A).position === "fixed" || hasFixedPositionAncestor(A, L);
}
function getClippingElementAncestors(C, L) {
  const A = L.get(C);
  if (A)
    return A;
  let W = getOverflowAncestors(C, [], !1).filter((oe) => isElement(oe) && getNodeName(oe) !== "body"), X = null;
  const J = getComputedStyle$1(C).position === "fixed";
  let te = J ? getParentNode(C) : C;
  for (; isElement(te) && !isLastTraversableNode(te); ) {
    const oe = getComputedStyle$1(te), ne = isContainingBlock(te);
    !ne && oe.position === "fixed" && (X = null), (J ? !ne && !X : !ne && oe.position === "static" && !!X && ["absolute", "fixed"].includes(X.position) || isOverflowElement(te) && !ne && hasFixedPositionAncestor(C, te)) ? W = W.filter((ce) => ce !== te) : X = oe, te = getParentNode(te);
  }
  return L.set(C, W), W;
}
function getClippingRect(C) {
  let {
    element: L,
    boundary: A,
    rootBoundary: W,
    strategy: X
  } = C;
  const te = [...A === "clippingAncestors" ? isTopLayer(L) ? [] : getClippingElementAncestors(L, this._c) : [].concat(A), W], oe = te[0], ne = te.reduce((re, ce) => {
    const ue = getClientRectFromClippingAncestor(L, ce, X);
    return re.top = max$5(ue.top, re.top), re.right = min$4(ue.right, re.right), re.bottom = min$4(ue.bottom, re.bottom), re.left = max$5(ue.left, re.left), re;
  }, getClientRectFromClippingAncestor(L, oe, X));
  return {
    width: ne.right - ne.left,
    height: ne.bottom - ne.top,
    x: ne.left,
    y: ne.top
  };
}
function getDimensions(C) {
  const {
    width: L,
    height: A
  } = getCssDimensions(C);
  return {
    width: L,
    height: A
  };
}
function getRectRelativeToOffsetParent(C, L, A) {
  const W = isHTMLElement(L), X = getDocumentElement(L), J = A === "fixed", te = getBoundingClientRect(C, !0, J, L);
  let oe = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const ne = createCoords(0);
  if (W || !W && !J)
    if ((getNodeName(L) !== "body" || isOverflowElement(X)) && (oe = getNodeScroll(L)), W) {
      const ue = getBoundingClientRect(L, !0, J, L);
      ne.x = ue.x + L.clientLeft, ne.y = ue.y + L.clientTop;
    } else X && (ne.x = getWindowScrollBarX(X));
  const re = te.left + oe.scrollLeft - ne.x, ce = te.top + oe.scrollTop - ne.y;
  return {
    x: re,
    y: ce,
    width: te.width,
    height: te.height
  };
}
function isStaticPositioned(C) {
  return getComputedStyle$1(C).position === "static";
}
function getTrueOffsetParent(C, L) {
  return !isHTMLElement(C) || getComputedStyle$1(C).position === "fixed" ? null : L ? L(C) : C.offsetParent;
}
function getOffsetParent(C, L) {
  const A = getWindow(C);
  if (isTopLayer(C))
    return A;
  if (!isHTMLElement(C)) {
    let X = getParentNode(C);
    for (; X && !isLastTraversableNode(X); ) {
      if (isElement(X) && !isStaticPositioned(X))
        return X;
      X = getParentNode(X);
    }
    return A;
  }
  let W = getTrueOffsetParent(C, L);
  for (; W && isTableElement(W) && isStaticPositioned(W); )
    W = getTrueOffsetParent(W, L);
  return W && isLastTraversableNode(W) && isStaticPositioned(W) && !isContainingBlock(W) ? A : W || getContainingBlock(C) || A;
}
const getElementRects = async function(C) {
  const L = this.getOffsetParent || getOffsetParent, A = this.getDimensions, W = await A(C.floating);
  return {
    reference: getRectRelativeToOffsetParent(C.reference, await L(C.floating), C.strategy),
    floating: {
      x: 0,
      y: 0,
      width: W.width,
      height: W.height
    }
  };
};
function isRTL(C) {
  return getComputedStyle$1(C).direction === "rtl";
}
const platform = {
  convertOffsetParentRelativeRectToViewportRelativeRect,
  getDocumentElement,
  getClippingRect,
  getOffsetParent,
  getElementRects,
  getClientRects,
  getDimensions,
  getScale,
  isElement,
  isRTL
};
function observeMove(C, L) {
  let A = null, W;
  const X = getDocumentElement(C);
  function J() {
    var oe;
    clearTimeout(W), (oe = A) == null || oe.disconnect(), A = null;
  }
  function te(oe, ne) {
    oe === void 0 && (oe = !1), ne === void 0 && (ne = 1), J();
    const {
      left: re,
      top: ce,
      width: ue,
      height: de
    } = C.getBoundingClientRect();
    if (oe || L(), !ue || !de)
      return;
    const be = floor$4(ce), pe = floor$4(X.clientWidth - (re + ue)), me = floor$4(X.clientHeight - (ce + de)), Me = floor$4(re), ge = {
      rootMargin: -be + "px " + -pe + "px " + -me + "px " + -Me + "px",
      threshold: max$5(0, min$4(1, ne)) || 1
    };
    let Ce = !0;
    function Se(Ae) {
      const Le = Ae[0].intersectionRatio;
      if (Le !== ne) {
        if (!Ce)
          return te();
        Le ? te(!1, Le) : W = setTimeout(() => {
          te(!1, 1e-7);
        }, 1e3);
      }
      Ce = !1;
    }
    try {
      A = new IntersectionObserver(Se, {
        ...ge,
        // Handle <iframe>s
        root: X.ownerDocument
      });
    } catch {
      A = new IntersectionObserver(Se, ge);
    }
    A.observe(C);
  }
  return te(!0), J;
}
function autoUpdate(C, L, A, W) {
  W === void 0 && (W = {});
  const {
    ancestorScroll: X = !0,
    ancestorResize: J = !0,
    elementResize: te = typeof ResizeObserver == "function",
    layoutShift: oe = typeof IntersectionObserver == "function",
    animationFrame: ne = !1
  } = W, re = unwrapElement(C), ce = X || J ? [...re ? getOverflowAncestors(re) : [], ...getOverflowAncestors(L)] : [];
  ce.forEach((he) => {
    X && he.addEventListener("scroll", A, {
      passive: !0
    }), J && he.addEventListener("resize", A);
  });
  const ue = re && oe ? observeMove(re, A) : null;
  let de = -1, be = null;
  te && (be = new ResizeObserver((he) => {
    let [ge] = he;
    ge && ge.target === re && be && (be.unobserve(L), cancelAnimationFrame(de), de = requestAnimationFrame(() => {
      var Ce;
      (Ce = be) == null || Ce.observe(L);
    })), A();
  }), re && !ne && be.observe(re), be.observe(L));
  let pe, me = ne ? getBoundingClientRect(C) : null;
  ne && Me();
  function Me() {
    const he = getBoundingClientRect(C);
    me && (he.x !== me.x || he.y !== me.y || he.width !== me.width || he.height !== me.height) && A(), me = he, pe = requestAnimationFrame(Me);
  }
  return A(), () => {
    var he;
    ce.forEach((ge) => {
      X && ge.removeEventListener("scroll", A), J && ge.removeEventListener("resize", A);
    }), ue == null || ue(), (he = be) == null || he.disconnect(), be = null, ne && cancelAnimationFrame(pe);
  };
}
const offset = offset$1, shift = shift$1, flip$1 = flip$2, size = size$1, arrow = arrow$1, computePosition = (C, L, A) => {
  const W = /* @__PURE__ */ new Map(), X = {
    platform,
    ...A
  }, J = {
    ...X.platform,
    _c: W
  };
  return computePosition$1(C, L, {
    ...X,
    platform: J
  });
};
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const t$2 = { ATTRIBUTE: 1, CHILD: 2, PROPERTY: 3, BOOLEAN_ATTRIBUTE: 4, EVENT: 5, ELEMENT: 6 }, e$4 = (C) => (...L) => ({ _$litDirective$: C, values: L });
let i$3 = class {
  constructor(L) {
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AT(L, A, W) {
    this.t = L, this._$AM = A, this.i = W;
  }
  _$AS(L, A) {
    return this.update(L, A);
  }
  update(L, A) {
    return this.render(...A);
  }
};
/**
 * @license
 * Copyright 2018 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const Rt = e$4(class extends i$3 {
  constructor(C) {
    var L;
    if (super(C), C.type !== t$2.ATTRIBUTE || C.name !== "class" || ((L = C.strings) == null ? void 0 : L.length) > 2) throw Error("`classMap()` can only be used in the `class` attribute and must be the only part in the attribute.");
  }
  render(C) {
    return " " + Object.keys(C).filter((L) => C[L]).join(" ") + " ";
  }
  update(C, [L]) {
    var W, X;
    if (this.st === void 0) {
      this.st = /* @__PURE__ */ new Set(), C.strings !== void 0 && (this.nt = new Set(C.strings.join(" ").split(/\s/).filter((J) => J !== "")));
      for (const J in L) L[J] && !((W = this.nt) != null && W.has(J)) && this.st.add(J);
      return this.render(L);
    }
    const A = C.element.classList;
    for (const J of this.st) J in L || (A.remove(J), this.st.delete(J));
    for (const J in L) {
      const te = !!L[J];
      te === this.st.has(J) || (X = this.nt) != null && X.has(J) || (te ? (A.add(J), this.st.add(J)) : (A.remove(J), this.st.delete(J)));
    }
    return R$1;
  }
});
function t$1(C) {
  return r(C);
}
function o$1(C) {
  return C.assignedSlot ? C.assignedSlot : C.parentNode instanceof ShadowRoot ? C.parentNode.host : C.parentNode;
}
function r(C) {
  for (let L = C; L; L = o$1(L)) if (L instanceof Element && getComputedStyle(L).display === "none") return null;
  for (let L = o$1(C); L; L = o$1(L)) {
    if (!(L instanceof Element)) continue;
    const A = getComputedStyle(L);
    if (A.display !== "contents" && (A.position !== "static" || A.filter !== "none" || L.tagName === "BODY"))
      return L;
  }
  return null;
}
function isVirtualElement(C) {
  return C !== null && typeof C == "object" && "getBoundingClientRect" in C && ("contextElement" in C ? C instanceof Element : !0);
}
var SlPopup = class extends ShoelaceElement {
  constructor() {
    super(...arguments), this.active = !1, this.placement = "top", this.strategy = "absolute", this.distance = 0, this.skidding = 0, this.arrow = !1, this.arrowPlacement = "anchor", this.arrowPadding = 10, this.flip = !1, this.flipFallbackPlacements = "", this.flipFallbackStrategy = "best-fit", this.flipPadding = 0, this.shift = !1, this.shiftPadding = 0, this.autoSizePadding = 0, this.hoverBridge = !1, this.updateHoverBridge = () => {
      if (this.hoverBridge && this.anchorEl) {
        const C = this.anchorEl.getBoundingClientRect(), L = this.popup.getBoundingClientRect(), A = this.placement.includes("top") || this.placement.includes("bottom");
        let W = 0, X = 0, J = 0, te = 0, oe = 0, ne = 0, re = 0, ce = 0;
        A ? C.top < L.top ? (W = C.left, X = C.bottom, J = C.right, te = C.bottom, oe = L.left, ne = L.top, re = L.right, ce = L.top) : (W = L.left, X = L.bottom, J = L.right, te = L.bottom, oe = C.left, ne = C.top, re = C.right, ce = C.top) : C.left < L.left ? (W = C.right, X = C.top, J = L.left, te = L.top, oe = C.right, ne = C.bottom, re = L.left, ce = L.bottom) : (W = L.right, X = L.top, J = C.left, te = C.top, oe = L.right, ne = L.bottom, re = C.left, ce = C.bottom), this.style.setProperty("--hover-bridge-top-left-x", `${W}px`), this.style.setProperty("--hover-bridge-top-left-y", `${X}px`), this.style.setProperty("--hover-bridge-top-right-x", `${J}px`), this.style.setProperty("--hover-bridge-top-right-y", `${te}px`), this.style.setProperty("--hover-bridge-bottom-left-x", `${oe}px`), this.style.setProperty("--hover-bridge-bottom-left-y", `${ne}px`), this.style.setProperty("--hover-bridge-bottom-right-x", `${re}px`), this.style.setProperty("--hover-bridge-bottom-right-y", `${ce}px`);
      }
    };
  }
  async connectedCallback() {
    super.connectedCallback(), await this.updateComplete, this.start();
  }
  disconnectedCallback() {
    super.disconnectedCallback(), this.stop();
  }
  async updated(C) {
    super.updated(C), C.has("active") && (this.active ? this.start() : this.stop()), C.has("anchor") && this.handleAnchorChange(), this.active && (await this.updateComplete, this.reposition());
  }
  async handleAnchorChange() {
    if (await this.stop(), this.anchor && typeof this.anchor == "string") {
      const C = this.getRootNode();
      this.anchorEl = C.getElementById(this.anchor);
    } else this.anchor instanceof Element || isVirtualElement(this.anchor) ? this.anchorEl = this.anchor : this.anchorEl = this.querySelector('[slot="anchor"]');
    this.anchorEl instanceof HTMLSlotElement && (this.anchorEl = this.anchorEl.assignedElements({ flatten: !0 })[0]), this.anchorEl && this.start();
  }
  start() {
    this.anchorEl && (this.cleanup = autoUpdate(this.anchorEl, this.popup, () => {
      this.reposition();
    }));
  }
  async stop() {
    return new Promise((C) => {
      this.cleanup ? (this.cleanup(), this.cleanup = void 0, this.removeAttribute("data-current-placement"), this.style.removeProperty("--auto-size-available-width"), this.style.removeProperty("--auto-size-available-height"), requestAnimationFrame(() => C())) : C();
    });
  }
  /** Forces the popup to recalculate and reposition itself. */
  reposition() {
    if (!this.active || !this.anchorEl)
      return;
    const C = [
      // The offset middleware goes first
      offset({ mainAxis: this.distance, crossAxis: this.skidding })
    ];
    this.sync ? C.push(
      size({
        apply: ({ rects: A }) => {
          const W = this.sync === "width" || this.sync === "both", X = this.sync === "height" || this.sync === "both";
          this.popup.style.width = W ? `${A.reference.width}px` : "", this.popup.style.height = X ? `${A.reference.height}px` : "";
        }
      })
    ) : (this.popup.style.width = "", this.popup.style.height = ""), this.flip && C.push(
      flip$1({
        boundary: this.flipBoundary,
        // @ts-expect-error - We're converting a string attribute to an array here
        fallbackPlacements: this.flipFallbackPlacements,
        fallbackStrategy: this.flipFallbackStrategy === "best-fit" ? "bestFit" : "initialPlacement",
        padding: this.flipPadding
      })
    ), this.shift && C.push(
      shift({
        boundary: this.shiftBoundary,
        padding: this.shiftPadding
      })
    ), this.autoSize ? C.push(
      size({
        boundary: this.autoSizeBoundary,
        padding: this.autoSizePadding,
        apply: ({ availableWidth: A, availableHeight: W }) => {
          this.autoSize === "vertical" || this.autoSize === "both" ? this.style.setProperty("--auto-size-available-height", `${W}px`) : this.style.removeProperty("--auto-size-available-height"), this.autoSize === "horizontal" || this.autoSize === "both" ? this.style.setProperty("--auto-size-available-width", `${A}px`) : this.style.removeProperty("--auto-size-available-width");
        }
      })
    ) : (this.style.removeProperty("--auto-size-available-width"), this.style.removeProperty("--auto-size-available-height")), this.arrow && C.push(
      arrow({
        element: this.arrowEl,
        padding: this.arrowPadding
      })
    );
    const L = this.strategy === "absolute" ? (A) => platform.getOffsetParent(A, t$1) : platform.getOffsetParent;
    computePosition(this.anchorEl, this.popup, {
      placement: this.placement,
      middleware: C,
      strategy: this.strategy,
      platform: __spreadProps(__spreadValues({}, platform), {
        getOffsetParent: L
      })
    }).then(({ x: A, y: W, middlewareData: X, placement: J }) => {
      const te = this.matches(":dir(rtl)"), oe = { top: "bottom", right: "left", bottom: "top", left: "right" }[J.split("-")[0]];
      if (this.setAttribute("data-current-placement", J), Object.assign(this.popup.style, {
        left: `${A}px`,
        top: `${W}px`
      }), this.arrow) {
        const ne = X.arrow.x, re = X.arrow.y;
        let ce = "", ue = "", de = "", be = "";
        if (this.arrowPlacement === "start") {
          const pe = typeof ne == "number" ? `calc(${this.arrowPadding}px - var(--arrow-padding-offset))` : "";
          ce = typeof re == "number" ? `calc(${this.arrowPadding}px - var(--arrow-padding-offset))` : "", ue = te ? pe : "", be = te ? "" : pe;
        } else if (this.arrowPlacement === "end") {
          const pe = typeof ne == "number" ? `calc(${this.arrowPadding}px - var(--arrow-padding-offset))` : "";
          ue = te ? "" : pe, be = te ? pe : "", de = typeof re == "number" ? `calc(${this.arrowPadding}px - var(--arrow-padding-offset))` : "";
        } else this.arrowPlacement === "center" ? (be = typeof ne == "number" ? "calc(50% - var(--arrow-size-diagonal))" : "", ce = typeof re == "number" ? "calc(50% - var(--arrow-size-diagonal))" : "") : (be = typeof ne == "number" ? `${ne}px` : "", ce = typeof re == "number" ? `${re}px` : "");
        Object.assign(this.arrowEl.style, {
          top: ce,
          right: ue,
          bottom: de,
          left: be,
          [oe]: "calc(var(--arrow-size-diagonal) * -1)"
        });
      }
    }), requestAnimationFrame(() => this.updateHoverBridge()), this.emit("sl-reposition");
  }
  render() {
    return ke$1`
      <slot name="anchor" @slotchange=${this.handleAnchorChange}></slot>

      <span
        part="hover-bridge"
        class=${Rt({
      "popup-hover-bridge": !0,
      "popup-hover-bridge--visible": this.hoverBridge && this.active
    })}
      ></span>

      <div
        part="popup"
        class=${Rt({
      popup: !0,
      "popup--active": this.active,
      "popup--fixed": this.strategy === "fixed",
      "popup--has-arrow": this.arrow
    })}
      >
        <slot></slot>
        ${this.arrow ? ke$1`<div part="arrow" class="popup__arrow" role="presentation"></div>` : ""}
      </div>
    `;
  }
};
SlPopup.styles = [component_styles_default, popup_styles_default];
__decorateClass$e([
  e$6(".popup")
], SlPopup.prototype, "popup", 2);
__decorateClass$e([
  e$6(".popup__arrow")
], SlPopup.prototype, "arrowEl", 2);
__decorateClass$e([
  n$1()
], SlPopup.prototype, "anchor", 2);
__decorateClass$e([
  n$1({ type: Boolean, reflect: !0 })
], SlPopup.prototype, "active", 2);
__decorateClass$e([
  n$1({ reflect: !0 })
], SlPopup.prototype, "placement", 2);
__decorateClass$e([
  n$1({ reflect: !0 })
], SlPopup.prototype, "strategy", 2);
__decorateClass$e([
  n$1({ type: Number })
], SlPopup.prototype, "distance", 2);
__decorateClass$e([
  n$1({ type: Number })
], SlPopup.prototype, "skidding", 2);
__decorateClass$e([
  n$1({ type: Boolean })
], SlPopup.prototype, "arrow", 2);
__decorateClass$e([
  n$1({ attribute: "arrow-placement" })
], SlPopup.prototype, "arrowPlacement", 2);
__decorateClass$e([
  n$1({ attribute: "arrow-padding", type: Number })
], SlPopup.prototype, "arrowPadding", 2);
__decorateClass$e([
  n$1({ type: Boolean })
], SlPopup.prototype, "flip", 2);
__decorateClass$e([
  n$1({
    attribute: "flip-fallback-placements",
    converter: {
      fromAttribute: (C) => C.split(" ").map((L) => L.trim()).filter((L) => L !== ""),
      toAttribute: (C) => C.join(" ")
    }
  })
], SlPopup.prototype, "flipFallbackPlacements", 2);
__decorateClass$e([
  n$1({ attribute: "flip-fallback-strategy" })
], SlPopup.prototype, "flipFallbackStrategy", 2);
__decorateClass$e([
  n$1({ type: Object })
], SlPopup.prototype, "flipBoundary", 2);
__decorateClass$e([
  n$1({ attribute: "flip-padding", type: Number })
], SlPopup.prototype, "flipPadding", 2);
__decorateClass$e([
  n$1({ type: Boolean })
], SlPopup.prototype, "shift", 2);
__decorateClass$e([
  n$1({ type: Object })
], SlPopup.prototype, "shiftBoundary", 2);
__decorateClass$e([
  n$1({ attribute: "shift-padding", type: Number })
], SlPopup.prototype, "shiftPadding", 2);
__decorateClass$e([
  n$1({ attribute: "auto-size" })
], SlPopup.prototype, "autoSize", 2);
__decorateClass$e([
  n$1()
], SlPopup.prototype, "sync", 2);
__decorateClass$e([
  n$1({ type: Object })
], SlPopup.prototype, "autoSizeBoundary", 2);
__decorateClass$e([
  n$1({ attribute: "auto-size-padding", type: Number })
], SlPopup.prototype, "autoSizePadding", 2);
__decorateClass$e([
  n$1({ attribute: "hover-bridge", type: Boolean })
], SlPopup.prototype, "hoverBridge", 2);
var defaultAnimationRegistry = /* @__PURE__ */ new Map(), customAnimationRegistry = /* @__PURE__ */ new WeakMap();
function ensureAnimation(C) {
  return C ?? { keyframes: [], options: { duration: 0 } };
}
function getLogicalAnimation(C, L) {
  return L.toLowerCase() === "rtl" ? {
    keyframes: C.rtlKeyframes || C.keyframes,
    options: C.options
  } : C;
}
function setDefaultAnimation(C, L) {
  defaultAnimationRegistry.set(C, ensureAnimation(L));
}
function getAnimation(C, L, A) {
  const W = customAnimationRegistry.get(C);
  if (W != null && W[L])
    return getLogicalAnimation(W[L], A.dir);
  const X = defaultAnimationRegistry.get(L);
  return X ? getLogicalAnimation(X, A.dir) : {
    keyframes: [],
    options: { duration: 0 }
  };
}
function waitForEvent(C, L) {
  return new Promise((A) => {
    function W(X) {
      X.target === C && (C.removeEventListener(L, W), A());
    }
    C.addEventListener(L, W);
  });
}
function animateTo(C, L, A) {
  return new Promise((W) => {
    if ((A == null ? void 0 : A.duration) === 1 / 0)
      throw new Error("Promise-based animations must be finite.");
    const X = C.animate(L, __spreadProps(__spreadValues({}, A), {
      duration: prefersReducedMotion() ? 0 : A.duration
    }));
    X.addEventListener("cancel", W, { once: !0 }), X.addEventListener("finish", W, { once: !0 });
  });
}
function parseDuration(C) {
  return C = C.toString().toLowerCase(), C.indexOf("ms") > -1 ? parseFloat(C) : C.indexOf("s") > -1 ? parseFloat(C) * 1e3 : parseFloat(C);
}
function prefersReducedMotion() {
  return window.matchMedia("(prefers-reduced-motion: reduce)").matches;
}
function stopAnimations(C) {
  return Promise.all(
    C.getAnimations().map((L) => new Promise((A) => {
      L.cancel(), requestAnimationFrame(A);
    }))
  );
}
function shimKeyframesHeightAuto(C, L) {
  return C.map((A) => __spreadProps(__spreadValues({}, A), {
    height: A.height === "auto" ? `${L}px` : A.height
  }));
}
const connectedElements = /* @__PURE__ */ new Set(), translations = /* @__PURE__ */ new Map();
let fallback, documentDirection = "ltr", documentLanguage = "en";
const isClient = typeof MutationObserver < "u" && typeof document < "u" && typeof document.documentElement < "u";
if (isClient) {
  const C = new MutationObserver(update);
  documentDirection = document.documentElement.dir || "ltr", documentLanguage = document.documentElement.lang || navigator.language, C.observe(document.documentElement, {
    attributes: !0,
    attributeFilter: ["dir", "lang"]
  });
}
function registerTranslation(...C) {
  C.map((L) => {
    const A = L.$code.toLowerCase();
    translations.has(A) ? translations.set(A, Object.assign(Object.assign({}, translations.get(A)), L)) : translations.set(A, L), fallback || (fallback = L);
  }), update();
}
function update() {
  isClient && (documentDirection = document.documentElement.dir || "ltr", documentLanguage = document.documentElement.lang || navigator.language), [...connectedElements.keys()].map((C) => {
    typeof C.requestUpdate == "function" && C.requestUpdate();
  });
}
let LocalizeController$1 = class {
  constructor(L) {
    this.host = L, this.host.addController(this);
  }
  hostConnected() {
    connectedElements.add(this.host);
  }
  hostDisconnected() {
    connectedElements.delete(this.host);
  }
  dir() {
    return `${this.host.dir || documentDirection}`.toLowerCase();
  }
  lang() {
    return `${this.host.lang || documentLanguage}`.toLowerCase();
  }
  getTranslationData(L) {
    var A, W;
    const X = new Intl.Locale(L.replace(/_/g, "-")), J = X == null ? void 0 : X.language.toLowerCase(), te = (W = (A = X == null ? void 0 : X.region) === null || A === void 0 ? void 0 : A.toLowerCase()) !== null && W !== void 0 ? W : "", oe = translations.get(`${J}-${te}`), ne = translations.get(J);
    return { locale: X, language: J, region: te, primary: oe, secondary: ne };
  }
  exists(L, A) {
    var W;
    const { primary: X, secondary: J } = this.getTranslationData((W = A.lang) !== null && W !== void 0 ? W : this.lang());
    return A = Object.assign({ includeFallback: !1 }, A), !!(X && X[L] || J && J[L] || A.includeFallback && fallback && fallback[L]);
  }
  term(L, ...A) {
    const { primary: W, secondary: X } = this.getTranslationData(this.lang());
    let J;
    if (W && W[L])
      J = W[L];
    else if (X && X[L])
      J = X[L];
    else if (fallback && fallback[L])
      J = fallback[L];
    else
      return console.error(`No translation found for: ${String(L)}`), String(L);
    return typeof J == "function" ? J(...A) : J;
  }
  date(L, A) {
    return L = new Date(L), new Intl.DateTimeFormat(this.lang(), A).format(L);
  }
  number(L, A) {
    return L = Number(L), isNaN(L) ? "" : new Intl.NumberFormat(this.lang(), A).format(L);
  }
  relativeTime(L, A, W) {
    return new Intl.RelativeTimeFormat(this.lang(), W).format(L, A);
  }
};
var translation = {
  $code: "en",
  $name: "English",
  $dir: "ltr",
  carousel: "Carousel",
  clearEntry: "Clear entry",
  close: "Close",
  copied: "Copied",
  copy: "Copy",
  currentValue: "Current value",
  error: "Error",
  goToSlide: (C, L) => `Go to slide ${C} of ${L}`,
  hidePassword: "Hide password",
  loading: "Loading",
  nextSlide: "Next slide",
  numOptionsSelected: (C) => C === 0 ? "No options selected" : C === 1 ? "1 option selected" : `${C} options selected`,
  previousSlide: "Previous slide",
  progress: "Progress",
  remove: "Remove",
  resize: "Resize",
  scrollToEnd: "Scroll to end",
  scrollToStart: "Scroll to start",
  selectAColorFromTheScreen: "Select a color from the screen",
  showPassword: "Show password",
  slideNum: (C) => `Slide ${C}`,
  toggleColorFormat: "Toggle color format"
};
registerTranslation(translation);
var en_default = translation, LocalizeController = class extends LocalizeController$1 {
};
registerTranslation(en_default);
function watch(C, L) {
  const A = __spreadValues({
    waitUntilFirstUpdate: !1
  }, L);
  return (W, X) => {
    const { update: J } = W, te = Array.isArray(C) ? C : [C];
    W.update = function(oe) {
      te.forEach((ne) => {
        const re = ne;
        if (oe.has(re)) {
          const ce = oe.get(re), ue = this[re];
          ce !== ue && (!A.waitUntilFirstUpdate || this.hasUpdated) && this[X](ce, ue);
        }
      }), J.call(this, oe);
    };
  };
}
var SlTooltip = class extends ShoelaceElement {
  constructor() {
    super(), this.localize = new LocalizeController(this), this.content = "", this.placement = "top", this.disabled = !1, this.distance = 8, this.open = !1, this.skidding = 0, this.trigger = "hover focus", this.hoist = !1, this.handleBlur = () => {
      this.hasTrigger("focus") && this.hide();
    }, this.handleClick = () => {
      this.hasTrigger("click") && (this.open ? this.hide() : this.show());
    }, this.handleFocus = () => {
      this.hasTrigger("focus") && this.show();
    }, this.handleDocumentKeyDown = (C) => {
      C.key === "Escape" && (C.stopPropagation(), this.hide());
    }, this.handleMouseOver = () => {
      if (this.hasTrigger("hover")) {
        const C = parseDuration(getComputedStyle(this).getPropertyValue("--show-delay"));
        clearTimeout(this.hoverTimeout), this.hoverTimeout = window.setTimeout(() => this.show(), C);
      }
    }, this.handleMouseOut = () => {
      if (this.hasTrigger("hover")) {
        const C = parseDuration(getComputedStyle(this).getPropertyValue("--hide-delay"));
        clearTimeout(this.hoverTimeout), this.hoverTimeout = window.setTimeout(() => this.hide(), C);
      }
    }, this.addEventListener("blur", this.handleBlur, !0), this.addEventListener("focus", this.handleFocus, !0), this.addEventListener("click", this.handleClick), this.addEventListener("mouseover", this.handleMouseOver), this.addEventListener("mouseout", this.handleMouseOut);
  }
  disconnectedCallback() {
    var C;
    (C = this.closeWatcher) == null || C.destroy(), document.removeEventListener("keydown", this.handleDocumentKeyDown);
  }
  firstUpdated() {
    this.body.hidden = !this.open, this.open && (this.popup.active = !0, this.popup.reposition());
  }
  hasTrigger(C) {
    return this.trigger.split(" ").includes(C);
  }
  async handleOpenChange() {
    var C, L;
    if (this.open) {
      if (this.disabled)
        return;
      this.emit("sl-show"), "CloseWatcher" in window ? ((C = this.closeWatcher) == null || C.destroy(), this.closeWatcher = new CloseWatcher(), this.closeWatcher.onclose = () => {
        this.hide();
      }) : document.addEventListener("keydown", this.handleDocumentKeyDown), await stopAnimations(this.body), this.body.hidden = !1, this.popup.active = !0;
      const { keyframes: A, options: W } = getAnimation(this, "tooltip.show", { dir: this.localize.dir() });
      await animateTo(this.popup.popup, A, W), this.popup.reposition(), this.emit("sl-after-show");
    } else {
      this.emit("sl-hide"), (L = this.closeWatcher) == null || L.destroy(), document.removeEventListener("keydown", this.handleDocumentKeyDown), await stopAnimations(this.body);
      const { keyframes: A, options: W } = getAnimation(this, "tooltip.hide", { dir: this.localize.dir() });
      await animateTo(this.popup.popup, A, W), this.popup.active = !1, this.body.hidden = !0, this.emit("sl-after-hide");
    }
  }
  async handleOptionsChange() {
    this.hasUpdated && (await this.updateComplete, this.popup.reposition());
  }
  handleDisabledChange() {
    this.disabled && this.open && this.hide();
  }
  /** Shows the tooltip. */
  async show() {
    if (!this.open)
      return this.open = !0, waitForEvent(this, "sl-after-show");
  }
  /** Hides the tooltip */
  async hide() {
    if (this.open)
      return this.open = !1, waitForEvent(this, "sl-after-hide");
  }
  //
  // NOTE: Tooltip is a bit unique in that we're using aria-live instead of aria-labelledby to trick screen readers into
  // announcing the content. It works really well, but it violates an accessibility rule. We're also adding the
  // aria-describedby attribute to a slot, which is required by <sl-popup> to correctly locate the first assigned
  // element, otherwise positioning is incorrect.
  //
  render() {
    return ke$1`
      <sl-popup
        part="base"
        exportparts="
          popup:base__popup,
          arrow:base__arrow
        "
        class=${Rt({
      tooltip: !0,
      "tooltip--open": this.open
    })}
        placement=${this.placement}
        distance=${this.distance}
        skidding=${this.skidding}
        strategy=${this.hoist ? "fixed" : "absolute"}
        flip
        shift
        arrow
        hover-bridge
      >
        ${""}
        <slot slot="anchor" aria-describedby="tooltip"></slot>

        ${""}
        <div part="body" id="tooltip" class="tooltip__body" role="tooltip" aria-live=${this.open ? "polite" : "off"}>
          <slot name="content">${this.content}</slot>
        </div>
      </sl-popup>
    `;
  }
};
SlTooltip.styles = [component_styles_default, tooltip_styles_default];
SlTooltip.dependencies = { "sl-popup": SlPopup };
__decorateClass$e([
  e$6("slot:not([name])")
], SlTooltip.prototype, "defaultSlot", 2);
__decorateClass$e([
  e$6(".tooltip__body")
], SlTooltip.prototype, "body", 2);
__decorateClass$e([
  e$6("sl-popup")
], SlTooltip.prototype, "popup", 2);
__decorateClass$e([
  n$1()
], SlTooltip.prototype, "content", 2);
__decorateClass$e([
  n$1()
], SlTooltip.prototype, "placement", 2);
__decorateClass$e([
  n$1({ type: Boolean, reflect: !0 })
], SlTooltip.prototype, "disabled", 2);
__decorateClass$e([
  n$1({ type: Number })
], SlTooltip.prototype, "distance", 2);
__decorateClass$e([
  n$1({ type: Boolean, reflect: !0 })
], SlTooltip.prototype, "open", 2);
__decorateClass$e([
  n$1({ type: Number })
], SlTooltip.prototype, "skidding", 2);
__decorateClass$e([
  n$1()
], SlTooltip.prototype, "trigger", 2);
__decorateClass$e([
  n$1({ type: Boolean })
], SlTooltip.prototype, "hoist", 2);
__decorateClass$e([
  watch("open", { waitUntilFirstUpdate: !0 })
], SlTooltip.prototype, "handleOpenChange", 1);
__decorateClass$e([
  watch(["content", "distance", "hoist", "placement", "skidding"])
], SlTooltip.prototype, "handleOptionsChange", 1);
__decorateClass$e([
  watch("disabled")
], SlTooltip.prototype, "handleDisabledChange", 1);
setDefaultAnimation("tooltip.show", {
  keyframes: [
    { opacity: 0, scale: 0.8 },
    { opacity: 1, scale: 1 }
  ],
  options: { duration: 150, easing: "ease" }
});
setDefaultAnimation("tooltip.hide", {
  keyframes: [
    { opacity: 1, scale: 1 },
    { opacity: 0, scale: 0.8 }
  ],
  options: { duration: 150, easing: "ease" }
});
SlTooltip.define("sl-tooltip");
var tree_styles_default = i$5`
  :host {
    /*
     * These are actually used by tree item, but we define them here so they can more easily be set and all tree items
     * stay consistent.
     */
    --indent-guide-color: var(--sl-color-neutral-200);
    --indent-guide-offset: 0;
    --indent-guide-style: solid;
    --indent-guide-width: 0;
    --indent-size: var(--sl-spacing-large);

    display: block;

    /*
     * Tree item indentation uses the "em" unit to increment its width on each level, so setting the font size to zero
     * here removes the indentation for all the nodes on the first level.
     */
    font-size: 0;
  }
`, tree_item_styles_default = i$5`
  :host {
    display: block;
    outline: 0;
    z-index: 0;
  }

  :host(:focus) {
    outline: none;
  }

  slot:not([name])::slotted(sl-icon) {
    margin-inline-end: var(--sl-spacing-x-small);
  }

  .tree-item {
    position: relative;
    display: flex;
    align-items: stretch;
    flex-direction: column;
    color: var(--sl-color-neutral-700);
    cursor: pointer;
    user-select: none;
    -webkit-user-select: none;
  }

  .tree-item__checkbox {
    pointer-events: none;
  }

  .tree-item__expand-button,
  .tree-item__checkbox,
  .tree-item__label {
    font-family: var(--sl-font-sans);
    font-size: var(--sl-font-size-medium);
    font-weight: var(--sl-font-weight-normal);
    line-height: var(--sl-line-height-dense);
    letter-spacing: var(--sl-letter-spacing-normal);
  }

  .tree-item__checkbox::part(base) {
    display: flex;
    align-items: center;
  }

  .tree-item__indentation {
    display: block;
    width: 1em;
    flex-shrink: 0;
  }

  .tree-item__expand-button {
    display: flex;
    align-items: center;
    justify-content: center;
    box-sizing: content-box;
    color: var(--sl-color-neutral-500);
    padding: var(--sl-spacing-x-small);
    width: 1rem;
    height: 1rem;
    flex-shrink: 0;
    cursor: pointer;
  }

  .tree-item__expand-button {
    transition: var(--sl-transition-medium) rotate ease;
  }

  .tree-item--expanded .tree-item__expand-button {
    rotate: 90deg;
  }

  .tree-item--expanded.tree-item--rtl .tree-item__expand-button {
    rotate: -90deg;
  }

  .tree-item--expanded slot[name='expand-icon'],
  .tree-item:not(.tree-item--expanded) slot[name='collapse-icon'] {
    display: none;
  }

  .tree-item:not(.tree-item--has-expand-button) .tree-item__expand-icon-slot {
    display: none;
  }

  .tree-item__expand-button--visible {
    cursor: pointer;
  }

  .tree-item__item {
    display: flex;
    align-items: center;
    border-inline-start: solid 3px transparent;
  }

  .tree-item--disabled .tree-item__item {
    opacity: 0.5;
    outline: none;
    cursor: not-allowed;
  }

  :host(:focus-visible) .tree-item__item {
    outline: var(--sl-focus-ring);
    outline-offset: var(--sl-focus-ring-offset);
    z-index: 2;
  }

  :host(:not([aria-disabled='true'])) .tree-item--selected .tree-item__item {
    background-color: var(--sl-color-neutral-100);
    border-inline-start-color: var(--sl-color-primary-600);
  }

  :host(:not([aria-disabled='true'])) .tree-item__expand-button {
    color: var(--sl-color-neutral-600);
  }

  .tree-item__label {
    display: flex;
    align-items: center;
    transition: var(--sl-transition-fast) color;
  }

  .tree-item__children {
    display: block;
    font-size: calc(1em + var(--indent-size, var(--sl-spacing-medium)));
  }

  /* Indentation lines */
  .tree-item__children {
    position: relative;
  }

  .tree-item__children::before {
    content: '';
    position: absolute;
    top: var(--indent-guide-offset);
    bottom: var(--indent-guide-offset);
    left: calc(1em - (var(--indent-guide-width) / 2) - 1px);
    border-inline-end: var(--indent-guide-width) var(--indent-guide-style) var(--indent-guide-color);
    z-index: 1;
  }

  .tree-item--rtl .tree-item__children::before {
    left: auto;
    right: 1em;
  }

  @media (forced-colors: active) {
    :host(:not([aria-disabled='true'])) .tree-item--selected .tree-item__item {
      outline: dashed 1px SelectedItem;
    }
  }
`, checkbox_styles_default = i$5`
  :host {
    display: inline-block;
  }

  .checkbox {
    position: relative;
    display: inline-flex;
    align-items: flex-start;
    font-family: var(--sl-input-font-family);
    font-weight: var(--sl-input-font-weight);
    color: var(--sl-input-label-color);
    vertical-align: middle;
    cursor: pointer;
  }

  .checkbox--small {
    --toggle-size: var(--sl-toggle-size-small);
    font-size: var(--sl-input-font-size-small);
  }

  .checkbox--medium {
    --toggle-size: var(--sl-toggle-size-medium);
    font-size: var(--sl-input-font-size-medium);
  }

  .checkbox--large {
    --toggle-size: var(--sl-toggle-size-large);
    font-size: var(--sl-input-font-size-large);
  }

  .checkbox__control {
    flex: 0 0 auto;
    position: relative;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    width: var(--toggle-size);
    height: var(--toggle-size);
    border: solid var(--sl-input-border-width) var(--sl-input-border-color);
    border-radius: 2px;
    background-color: var(--sl-input-background-color);
    color: var(--sl-color-neutral-0);
    transition:
      var(--sl-transition-fast) border-color,
      var(--sl-transition-fast) background-color,
      var(--sl-transition-fast) color,
      var(--sl-transition-fast) box-shadow;
  }

  .checkbox__input {
    position: absolute;
    opacity: 0;
    padding: 0;
    margin: 0;
    pointer-events: none;
  }

  .checkbox__checked-icon,
  .checkbox__indeterminate-icon {
    display: inline-flex;
    width: var(--toggle-size);
    height: var(--toggle-size);
  }

  /* Hover */
  .checkbox:not(.checkbox--checked):not(.checkbox--disabled) .checkbox__control:hover {
    border-color: var(--sl-input-border-color-hover);
    background-color: var(--sl-input-background-color-hover);
  }

  /* Focus */
  .checkbox:not(.checkbox--checked):not(.checkbox--disabled) .checkbox__input:focus-visible ~ .checkbox__control {
    outline: var(--sl-focus-ring);
    outline-offset: var(--sl-focus-ring-offset);
  }

  /* Checked/indeterminate */
  .checkbox--checked .checkbox__control,
  .checkbox--indeterminate .checkbox__control {
    border-color: var(--sl-color-primary-600);
    background-color: var(--sl-color-primary-600);
  }

  /* Checked/indeterminate + hover */
  .checkbox.checkbox--checked:not(.checkbox--disabled) .checkbox__control:hover,
  .checkbox.checkbox--indeterminate:not(.checkbox--disabled) .checkbox__control:hover {
    border-color: var(--sl-color-primary-500);
    background-color: var(--sl-color-primary-500);
  }

  /* Checked/indeterminate + focus */
  .checkbox.checkbox--checked:not(.checkbox--disabled) .checkbox__input:focus-visible ~ .checkbox__control,
  .checkbox.checkbox--indeterminate:not(.checkbox--disabled) .checkbox__input:focus-visible ~ .checkbox__control {
    outline: var(--sl-focus-ring);
    outline-offset: var(--sl-focus-ring-offset);
  }

  /* Disabled */
  .checkbox--disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }

  .checkbox__label {
    display: inline-block;
    color: var(--sl-input-label-color);
    line-height: var(--toggle-size);
    margin-inline-start: 0.5em;
    user-select: none;
    -webkit-user-select: none;
  }

  :host([required]) .checkbox__label::after {
    content: var(--sl-input-required-content);
    color: var(--sl-input-required-content-color);
    margin-inline-start: var(--sl-input-required-content-offset);
  }
`, defaultValue = (C = "value") => (L, A) => {
  const W = L.constructor, X = W.prototype.attributeChangedCallback;
  W.prototype.attributeChangedCallback = function(J, te, oe) {
    var ne;
    const re = W.getPropertyOptions(C), ce = typeof re.attribute == "string" ? re.attribute : C;
    if (J === ce) {
      const ue = re.converter || u$1, be = (typeof ue == "function" ? ue : (ne = ue == null ? void 0 : ue.fromAttribute) != null ? ne : u$1.fromAttribute)(oe, re.type);
      this[C] !== be && (this[A] = be);
    }
    X.call(this, J, te, oe);
  };
}, form_control_styles_default = i$5`
  .form-control .form-control__label {
    display: none;
  }

  .form-control .form-control__help-text {
    display: none;
  }

  /* Label */
  .form-control--has-label .form-control__label {
    display: inline-block;
    color: var(--sl-input-label-color);
    margin-bottom: var(--sl-spacing-3x-small);
  }

  .form-control--has-label.form-control--small .form-control__label {
    font-size: var(--sl-input-label-font-size-small);
  }

  .form-control--has-label.form-control--medium .form-control__label {
    font-size: var(--sl-input-label-font-size-medium);
  }

  .form-control--has-label.form-control--large .form-control__label {
    font-size: var(--sl-input-label-font-size-large);
  }

  :host([required]) .form-control--has-label .form-control__label::after {
    content: var(--sl-input-required-content);
    margin-inline-start: var(--sl-input-required-content-offset);
    color: var(--sl-input-required-content-color);
  }

  /* Help text */
  .form-control--has-help-text .form-control__help-text {
    display: block;
    color: var(--sl-input-help-text-color);
    margin-top: var(--sl-spacing-3x-small);
  }

  .form-control--has-help-text.form-control--small .form-control__help-text {
    font-size: var(--sl-input-help-text-font-size-small);
  }

  .form-control--has-help-text.form-control--medium .form-control__help-text {
    font-size: var(--sl-input-help-text-font-size-medium);
  }

  .form-control--has-help-text.form-control--large .form-control__help-text {
    font-size: var(--sl-input-help-text-font-size-large);
  }

  .form-control--has-help-text.form-control--radio-group .form-control__help-text {
    margin-top: var(--sl-spacing-2x-small);
  }
`, HasSlotController = class {
  constructor(C, ...L) {
    this.slotNames = [], this.handleSlotChange = (A) => {
      const W = A.target;
      (this.slotNames.includes("[default]") && !W.name || W.name && this.slotNames.includes(W.name)) && this.host.requestUpdate();
    }, (this.host = C).addController(this), this.slotNames = L;
  }
  hasDefaultSlot() {
    return [...this.host.childNodes].some((C) => {
      if (C.nodeType === C.TEXT_NODE && C.textContent.trim() !== "")
        return !0;
      if (C.nodeType === C.ELEMENT_NODE) {
        const L = C;
        if (L.tagName.toLowerCase() === "sl-visually-hidden")
          return !1;
        if (!L.hasAttribute("slot"))
          return !0;
      }
      return !1;
    });
  }
  hasNamedSlot(C) {
    return this.host.querySelector(`:scope > [slot="${C}"]`) !== null;
  }
  test(C) {
    return C === "[default]" ? this.hasDefaultSlot() : this.hasNamedSlot(C);
  }
  hostConnected() {
    this.host.shadowRoot.addEventListener("slotchange", this.handleSlotChange);
  }
  hostDisconnected() {
    this.host.shadowRoot.removeEventListener("slotchange", this.handleSlotChange);
  }
};
function getTextContent(C) {
  if (!C)
    return "";
  const L = C.assignedNodes({ flatten: !0 });
  let A = "";
  return [...L].forEach((W) => {
    W.nodeType === Node.TEXT_NODE && (A += W.textContent);
  }), A;
}
var basePath = "";
function setBasePath(C) {
  basePath = C;
}
function getBasePath(C = "") {
  if (!basePath) {
    const L = [...document.getElementsByTagName("script")], A = L.find((W) => W.hasAttribute("data-shoelace"));
    if (A)
      setBasePath(A.getAttribute("data-shoelace"));
    else {
      const W = L.find((J) => /shoelace(\.min)?\.js($|\?)/.test(J.src) || /shoelace-autoloader(\.min)?\.js($|\?)/.test(J.src));
      let X = "";
      W && (X = W.getAttribute("src")), setBasePath(X.split("/").slice(0, -1).join("/"));
    }
  }
  return basePath.replace(/\/$/, "") + (C ? `/${C.replace(/^\//, "")}` : "");
}
var library = {
  name: "default",
  resolver: (C) => getBasePath(`assets/icons/${C}.svg`)
}, library_default_default = library, icons = {
  caret: `
    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <polyline points="6 9 12 15 18 9"></polyline>
    </svg>
  `,
  check: `
    <svg part="checked-icon" class="checkbox__icon" viewBox="0 0 16 16">
      <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd" stroke-linecap="round">
        <g stroke="currentColor">
          <g transform="translate(3.428571, 3.428571)">
            <path d="M0,5.71428571 L3.42857143,9.14285714"></path>
            <path d="M9.14285714,0 L3.42857143,9.14285714"></path>
          </g>
        </g>
      </g>
    </svg>
  `,
  "chevron-down": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-chevron-down" viewBox="0 0 16 16">
      <path fill-rule="evenodd" d="M1.646 4.646a.5.5 0 0 1 .708 0L8 10.293l5.646-5.647a.5.5 0 0 1 .708.708l-6 6a.5.5 0 0 1-.708 0l-6-6a.5.5 0 0 1 0-.708z"/>
    </svg>
  `,
  "chevron-left": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-chevron-left" viewBox="0 0 16 16">
      <path fill-rule="evenodd" d="M11.354 1.646a.5.5 0 0 1 0 .708L5.707 8l5.647 5.646a.5.5 0 0 1-.708.708l-6-6a.5.5 0 0 1 0-.708l6-6a.5.5 0 0 1 .708 0z"/>
    </svg>
  `,
  "chevron-right": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-chevron-right" viewBox="0 0 16 16">
      <path fill-rule="evenodd" d="M4.646 1.646a.5.5 0 0 1 .708 0l6 6a.5.5 0 0 1 0 .708l-6 6a.5.5 0 0 1-.708-.708L10.293 8 4.646 2.354a.5.5 0 0 1 0-.708z"/>
    </svg>
  `,
  copy: `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-copy" viewBox="0 0 16 16">
      <path fill-rule="evenodd" d="M4 2a2 2 0 0 1 2-2h8a2 2 0 0 1 2 2v8a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V2Zm2-1a1 1 0 0 0-1 1v8a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1V2a1 1 0 0 0-1-1H6ZM2 5a1 1 0 0 0-1 1v8a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1v-1h1v1a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h1v1H2Z"/>
    </svg>
  `,
  eye: `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-eye" viewBox="0 0 16 16">
      <path d="M16 8s-3-5.5-8-5.5S0 8 0 8s3 5.5 8 5.5S16 8 16 8zM1.173 8a13.133 13.133 0 0 1 1.66-2.043C4.12 4.668 5.88 3.5 8 3.5c2.12 0 3.879 1.168 5.168 2.457A13.133 13.133 0 0 1 14.828 8c-.058.087-.122.183-.195.288-.335.48-.83 1.12-1.465 1.755C11.879 11.332 10.119 12.5 8 12.5c-2.12 0-3.879-1.168-5.168-2.457A13.134 13.134 0 0 1 1.172 8z"/>
      <path d="M8 5.5a2.5 2.5 0 1 0 0 5 2.5 2.5 0 0 0 0-5zM4.5 8a3.5 3.5 0 1 1 7 0 3.5 3.5 0 0 1-7 0z"/>
    </svg>
  `,
  "eye-slash": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-eye-slash" viewBox="0 0 16 16">
      <path d="M13.359 11.238C15.06 9.72 16 8 16 8s-3-5.5-8-5.5a7.028 7.028 0 0 0-2.79.588l.77.771A5.944 5.944 0 0 1 8 3.5c2.12 0 3.879 1.168 5.168 2.457A13.134 13.134 0 0 1 14.828 8c-.058.087-.122.183-.195.288-.335.48-.83 1.12-1.465 1.755-.165.165-.337.328-.517.486l.708.709z"/>
      <path d="M11.297 9.176a3.5 3.5 0 0 0-4.474-4.474l.823.823a2.5 2.5 0 0 1 2.829 2.829l.822.822zm-2.943 1.299.822.822a3.5 3.5 0 0 1-4.474-4.474l.823.823a2.5 2.5 0 0 0 2.829 2.829z"/>
      <path d="M3.35 5.47c-.18.16-.353.322-.518.487A13.134 13.134 0 0 0 1.172 8l.195.288c.335.48.83 1.12 1.465 1.755C4.121 11.332 5.881 12.5 8 12.5c.716 0 1.39-.133 2.02-.36l.77.772A7.029 7.029 0 0 1 8 13.5C3 13.5 0 8 0 8s.939-1.721 2.641-3.238l.708.709zm10.296 8.884-12-12 .708-.708 12 12-.708.708z"/>
    </svg>
  `,
  eyedropper: `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-eyedropper" viewBox="0 0 16 16">
      <path d="M13.354.646a1.207 1.207 0 0 0-1.708 0L8.5 3.793l-.646-.647a.5.5 0 1 0-.708.708L8.293 5l-7.147 7.146A.5.5 0 0 0 1 12.5v1.793l-.854.853a.5.5 0 1 0 .708.707L1.707 15H3.5a.5.5 0 0 0 .354-.146L11 7.707l1.146 1.147a.5.5 0 0 0 .708-.708l-.647-.646 3.147-3.146a1.207 1.207 0 0 0 0-1.708l-2-2zM2 12.707l7-7L10.293 7l-7 7H2v-1.293z"></path>
    </svg>
  `,
  "grip-vertical": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-grip-vertical" viewBox="0 0 16 16">
      <path d="M7 2a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm3 0a1 1 0 1 1-2 0 1 1 0 0 1 2 0zM7 5a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm3 0a1 1 0 1 1-2 0 1 1 0 0 1 2 0zM7 8a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm3 0a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm-3 3a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm3 0a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm-3 3a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm3 0a1 1 0 1 1-2 0 1 1 0 0 1 2 0z"></path>
    </svg>
  `,
  indeterminate: `
    <svg part="indeterminate-icon" class="checkbox__icon" viewBox="0 0 16 16">
      <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd" stroke-linecap="round">
        <g stroke="currentColor" stroke-width="2">
          <g transform="translate(2.285714, 6.857143)">
            <path d="M10.2857143,1.14285714 L1.14285714,1.14285714"></path>
          </g>
        </g>
      </g>
    </svg>
  `,
  "person-fill": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-person-fill" viewBox="0 0 16 16">
      <path d="M3 14s-1 0-1-1 1-4 6-4 6 3 6 4-1 1-1 1H3zm5-6a3 3 0 1 0 0-6 3 3 0 0 0 0 6z"/>
    </svg>
  `,
  "play-fill": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-play-fill" viewBox="0 0 16 16">
      <path d="m11.596 8.697-6.363 3.692c-.54.313-1.233-.066-1.233-.697V4.308c0-.63.692-1.01 1.233-.696l6.363 3.692a.802.802 0 0 1 0 1.393z"></path>
    </svg>
  `,
  "pause-fill": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-pause-fill" viewBox="0 0 16 16">
      <path d="M5.5 3.5A1.5 1.5 0 0 1 7 5v6a1.5 1.5 0 0 1-3 0V5a1.5 1.5 0 0 1 1.5-1.5zm5 0A1.5 1.5 0 0 1 12 5v6a1.5 1.5 0 0 1-3 0V5a1.5 1.5 0 0 1 1.5-1.5z"></path>
    </svg>
  `,
  radio: `
    <svg part="checked-icon" class="radio__icon" viewBox="0 0 16 16">
      <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g fill="currentColor">
          <circle cx="8" cy="8" r="3.42857143"></circle>
        </g>
      </g>
    </svg>
  `,
  "star-fill": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-star-fill" viewBox="0 0 16 16">
      <path d="M3.612 15.443c-.386.198-.824-.149-.746-.592l.83-4.73L.173 6.765c-.329-.314-.158-.888.283-.95l4.898-.696L7.538.792c.197-.39.73-.39.927 0l2.184 4.327 4.898.696c.441.062.612.636.282.95l-3.522 3.356.83 4.73c.078.443-.36.79-.746.592L8 13.187l-4.389 2.256z"/>
    </svg>
  `,
  "x-lg": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-x-lg" viewBox="0 0 16 16">
      <path d="M2.146 2.854a.5.5 0 1 1 .708-.708L8 7.293l5.146-5.147a.5.5 0 0 1 .708.708L8.707 8l5.147 5.146a.5.5 0 0 1-.708.708L8 8.707l-5.146 5.147a.5.5 0 0 1-.708-.708L7.293 8 2.146 2.854Z"/>
    </svg>
  `,
  "x-circle-fill": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-x-circle-fill" viewBox="0 0 16 16">
      <path d="M16 8A8 8 0 1 1 0 8a8 8 0 0 1 16 0zM5.354 4.646a.5.5 0 1 0-.708.708L7.293 8l-2.647 2.646a.5.5 0 0 0 .708.708L8 8.707l2.646 2.647a.5.5 0 0 0 .708-.708L8.707 8l2.647-2.646a.5.5 0 0 0-.708-.708L8 7.293 5.354 4.646z"></path>
    </svg>
  `
}, systemLibrary = {
  name: "system",
  resolver: (C) => C in icons ? `data:image/svg+xml,${encodeURIComponent(icons[C])}` : ""
}, library_system_default = systemLibrary, registry = [library_default_default, library_system_default], watchedIcons = [];
function watchIcon(C) {
  watchedIcons.push(C);
}
function unwatchIcon(C) {
  watchedIcons = watchedIcons.filter((L) => L !== C);
}
function getIconLibrary(C) {
  return registry.find((L) => L.name === C);
}
var icon_styles_default = i$5`
  :host {
    display: inline-block;
    width: 1em;
    height: 1em;
    box-sizing: content-box !important;
  }

  svg {
    display: block;
    height: 100%;
    width: 100%;
  }
`;
/**
 * @license
 * Copyright 2020 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const { I: et } = si, nt = (C, L) => (C == null ? void 0 : C._$litType$) !== void 0, rt = (C) => C.strings === void 0, lt = () => document.createComment(""), at = (C, L, A) => {
  var J;
  const W = C._$AA.parentNode, X = L === void 0 ? C._$AB : L._$AA;
  if (A === void 0) {
    const te = W.insertBefore(lt(), X), oe = W.insertBefore(lt(), X);
    A = new et(te, oe, C, C.options);
  } else {
    const te = A._$AB.nextSibling, oe = A._$AM, ne = oe !== C;
    if (ne) {
      let re;
      (J = A._$AQ) == null || J.call(A, C), A._$AM = C, A._$AP !== void 0 && (re = C._$AU) !== oe._$AU && A._$AP(re);
    }
    if (te !== X || ne) {
      let re = A._$AA;
      for (; re !== te; ) {
        const ce = re.nextSibling;
        W.insertBefore(re, X), re = ce;
      }
    }
  }
  return A;
}, ct = (C, L, A = C) => (C._$AI(L, A), C), ht = {}, dt = (C, L = ht) => C._$AH = L, ut = (C) => C._$AH, pt = (C) => {
  var W;
  (W = C._$AP) == null || W.call(C, !1, !0);
  let L = C._$AA;
  const A = C._$AB.nextSibling;
  for (; L !== A; ) {
    const X = L.nextSibling;
    L.remove(), L = X;
  }
};
var CACHEABLE_ERROR = Symbol(), RETRYABLE_ERROR = Symbol(), parser, iconCache = /* @__PURE__ */ new Map(), SlIcon = class extends ShoelaceElement {
  constructor() {
    super(...arguments), this.initialRender = !1, this.svg = null, this.label = "", this.library = "default";
  }
  /** Given a URL, this function returns the resulting SVG element or an appropriate error symbol. */
  async resolveIcon(C, L) {
    var A;
    let W;
    if (L != null && L.spriteSheet) {
      this.svg = ke$1`<svg part="svg">
        <use part="use" href="${C}"></use>
      </svg>`, await this.updateComplete;
      const X = this.shadowRoot.querySelector("[part='svg']");
      return typeof L.mutator == "function" && L.mutator(X), this.svg;
    }
    try {
      if (W = await fetch(C, { mode: "cors" }), !W.ok)
        return W.status === 410 ? CACHEABLE_ERROR : RETRYABLE_ERROR;
    } catch {
      return RETRYABLE_ERROR;
    }
    try {
      const X = document.createElement("div");
      X.innerHTML = await W.text();
      const J = X.firstElementChild;
      if (((A = J == null ? void 0 : J.tagName) == null ? void 0 : A.toLowerCase()) !== "svg")
        return CACHEABLE_ERROR;
      parser || (parser = new DOMParser());
      const oe = parser.parseFromString(J.outerHTML, "text/html").body.querySelector("svg");
      return oe ? (oe.part.add("svg"), document.adoptNode(oe)) : CACHEABLE_ERROR;
    } catch {
      return CACHEABLE_ERROR;
    }
  }
  connectedCallback() {
    super.connectedCallback(), watchIcon(this);
  }
  firstUpdated() {
    this.initialRender = !0, this.setIcon();
  }
  disconnectedCallback() {
    super.disconnectedCallback(), unwatchIcon(this);
  }
  getIconSource() {
    const C = getIconLibrary(this.library);
    return this.name && C ? {
      url: C.resolver(this.name),
      fromLibrary: !0
    } : {
      url: this.src,
      fromLibrary: !1
    };
  }
  handleLabelChange() {
    typeof this.label == "string" && this.label.length > 0 ? (this.setAttribute("role", "img"), this.setAttribute("aria-label", this.label), this.removeAttribute("aria-hidden")) : (this.removeAttribute("role"), this.removeAttribute("aria-label"), this.setAttribute("aria-hidden", "true"));
  }
  async setIcon() {
    var C;
    const { url: L, fromLibrary: A } = this.getIconSource(), W = A ? getIconLibrary(this.library) : void 0;
    if (!L) {
      this.svg = null;
      return;
    }
    let X = iconCache.get(L);
    if (X || (X = this.resolveIcon(L, W), iconCache.set(L, X)), !this.initialRender)
      return;
    const J = await X;
    if (J === RETRYABLE_ERROR && iconCache.delete(L), L === this.getIconSource().url) {
      if (nt(J)) {
        this.svg = J;
        return;
      }
      switch (J) {
        case RETRYABLE_ERROR:
        case CACHEABLE_ERROR:
          this.svg = null, this.emit("sl-error");
          break;
        default:
          this.svg = J.cloneNode(!0), (C = W == null ? void 0 : W.mutator) == null || C.call(W, this.svg), this.emit("sl-load");
      }
    }
  }
  render() {
    return this.svg;
  }
};
SlIcon.styles = [component_styles_default, icon_styles_default];
__decorateClass$e([
  r$3()
], SlIcon.prototype, "svg", 2);
__decorateClass$e([
  n$1({ reflect: !0 })
], SlIcon.prototype, "name", 2);
__decorateClass$e([
  n$1()
], SlIcon.prototype, "src", 2);
__decorateClass$e([
  n$1()
], SlIcon.prototype, "label", 2);
__decorateClass$e([
  n$1({ reflect: !0 })
], SlIcon.prototype, "library", 2);
__decorateClass$e([
  watch("label")
], SlIcon.prototype, "handleLabelChange", 1);
__decorateClass$e([
  watch(["name", "src", "library"])
], SlIcon.prototype, "setIcon", 1);
/**
 * @license
 * Copyright 2018 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const to = (C) => C ?? D;
/**
 * @license
 * Copyright 2020 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const Ft = e$4(class extends i$3 {
  constructor(C) {
    if (super(C), C.type !== t$2.PROPERTY && C.type !== t$2.ATTRIBUTE && C.type !== t$2.BOOLEAN_ATTRIBUTE) throw Error("The `live` directive is not allowed on child or event bindings");
    if (!rt(C)) throw Error("`live` bindings can only contain a single expression");
  }
  render(C) {
    return C;
  }
  update(C, [L]) {
    if (L === R$1 || L === D) return L;
    const A = C.element, W = C.name;
    if (C.type === t$2.PROPERTY) {
      if (L === A[W]) return R$1;
    } else if (C.type === t$2.BOOLEAN_ATTRIBUTE) {
      if (!!L === A.hasAttribute(W)) return R$1;
    } else if (C.type === t$2.ATTRIBUTE && A.getAttribute(W) === L + "") return R$1;
    return dt(C), L;
  }
});
var SlCheckbox = class extends ShoelaceElement {
  constructor() {
    super(...arguments), this.formControlController = new FormControlController(this, {
      value: (C) => C.checked ? C.value || "on" : void 0,
      defaultValue: (C) => C.defaultChecked,
      setValue: (C, L) => C.checked = L
    }), this.hasSlotController = new HasSlotController(this, "help-text"), this.hasFocus = !1, this.title = "", this.name = "", this.size = "medium", this.disabled = !1, this.checked = !1, this.indeterminate = !1, this.defaultChecked = !1, this.form = "", this.required = !1, this.helpText = "";
  }
  /** Gets the validity state object */
  get validity() {
    return this.input.validity;
  }
  /** Gets the validation message */
  get validationMessage() {
    return this.input.validationMessage;
  }
  firstUpdated() {
    this.formControlController.updateValidity();
  }
  handleClick() {
    this.checked = !this.checked, this.indeterminate = !1, this.emit("sl-change");
  }
  handleBlur() {
    this.hasFocus = !1, this.emit("sl-blur");
  }
  handleInput() {
    this.emit("sl-input");
  }
  handleInvalid(C) {
    this.formControlController.setValidity(!1), this.formControlController.emitInvalidEvent(C);
  }
  handleFocus() {
    this.hasFocus = !0, this.emit("sl-focus");
  }
  handleDisabledChange() {
    this.formControlController.setValidity(this.disabled);
  }
  handleStateChange() {
    this.input.checked = this.checked, this.input.indeterminate = this.indeterminate, this.formControlController.updateValidity();
  }
  /** Simulates a click on the checkbox. */
  click() {
    this.input.click();
  }
  /** Sets focus on the checkbox. */
  focus(C) {
    this.input.focus(C);
  }
  /** Removes focus from the checkbox. */
  blur() {
    this.input.blur();
  }
  /** Checks for validity but does not show a validation message. Returns `true` when valid and `false` when invalid. */
  checkValidity() {
    return this.input.checkValidity();
  }
  /** Gets the associated form, if one exists. */
  getForm() {
    return this.formControlController.getForm();
  }
  /** Checks for validity and shows the browser's validation message if the control is invalid. */
  reportValidity() {
    return this.input.reportValidity();
  }
  /**
   * Sets a custom validation message. The value provided will be shown to the user when the form is submitted. To clear
   * the custom validation message, call this method with an empty string.
   */
  setCustomValidity(C) {
    this.input.setCustomValidity(C), this.formControlController.updateValidity();
  }
  render() {
    const C = this.hasSlotController.test("help-text"), L = this.helpText ? !0 : !!C;
    return ke$1`
      <div
        class=${Rt({
      "form-control": !0,
      "form-control--small": this.size === "small",
      "form-control--medium": this.size === "medium",
      "form-control--large": this.size === "large",
      "form-control--has-help-text": L
    })}
      >
        <label
          part="base"
          class=${Rt({
      checkbox: !0,
      "checkbox--checked": this.checked,
      "checkbox--disabled": this.disabled,
      "checkbox--focused": this.hasFocus,
      "checkbox--indeterminate": this.indeterminate,
      "checkbox--small": this.size === "small",
      "checkbox--medium": this.size === "medium",
      "checkbox--large": this.size === "large"
    })}
        >
          <input
            class="checkbox__input"
            type="checkbox"
            title=${this.title}
            name=${this.name}
            value=${to(this.value)}
            .indeterminate=${Ft(this.indeterminate)}
            .checked=${Ft(this.checked)}
            .disabled=${this.disabled}
            .required=${this.required}
            aria-checked=${this.checked ? "true" : "false"}
            aria-describedby="help-text"
            @click=${this.handleClick}
            @input=${this.handleInput}
            @invalid=${this.handleInvalid}
            @blur=${this.handleBlur}
            @focus=${this.handleFocus}
          />

          <span
            part="control${this.checked ? " control--checked" : ""}${this.indeterminate ? " control--indeterminate" : ""}"
            class="checkbox__control"
          >
            ${this.checked ? ke$1`
                  <sl-icon part="checked-icon" class="checkbox__checked-icon" library="system" name="check"></sl-icon>
                ` : ""}
            ${!this.checked && this.indeterminate ? ke$1`
                  <sl-icon
                    part="indeterminate-icon"
                    class="checkbox__indeterminate-icon"
                    library="system"
                    name="indeterminate"
                  ></sl-icon>
                ` : ""}
          </span>

          <div part="label" class="checkbox__label">
            <slot></slot>
          </div>
        </label>

        <div
          aria-hidden=${L ? "false" : "true"}
          class="form-control__help-text"
          id="help-text"
          part="form-control-help-text"
        >
          <slot name="help-text">${this.helpText}</slot>
        </div>
      </div>
    `;
  }
};
SlCheckbox.styles = [component_styles_default, form_control_styles_default, checkbox_styles_default];
SlCheckbox.dependencies = { "sl-icon": SlIcon };
__decorateClass$e([
  e$6('input[type="checkbox"]')
], SlCheckbox.prototype, "input", 2);
__decorateClass$e([
  r$3()
], SlCheckbox.prototype, "hasFocus", 2);
__decorateClass$e([
  n$1()
], SlCheckbox.prototype, "title", 2);
__decorateClass$e([
  n$1()
], SlCheckbox.prototype, "name", 2);
__decorateClass$e([
  n$1()
], SlCheckbox.prototype, "value", 2);
__decorateClass$e([
  n$1({ reflect: !0 })
], SlCheckbox.prototype, "size", 2);
__decorateClass$e([
  n$1({ type: Boolean, reflect: !0 })
], SlCheckbox.prototype, "disabled", 2);
__decorateClass$e([
  n$1({ type: Boolean, reflect: !0 })
], SlCheckbox.prototype, "checked", 2);
__decorateClass$e([
  n$1({ type: Boolean, reflect: !0 })
], SlCheckbox.prototype, "indeterminate", 2);
__decorateClass$e([
  defaultValue("checked")
], SlCheckbox.prototype, "defaultChecked", 2);
__decorateClass$e([
  n$1({ reflect: !0 })
], SlCheckbox.prototype, "form", 2);
__decorateClass$e([
  n$1({ type: Boolean, reflect: !0 })
], SlCheckbox.prototype, "required", 2);
__decorateClass$e([
  n$1({ attribute: "help-text" })
], SlCheckbox.prototype, "helpText", 2);
__decorateClass$e([
  watch("disabled", { waitUntilFirstUpdate: !0 })
], SlCheckbox.prototype, "handleDisabledChange", 1);
__decorateClass$e([
  watch(["checked", "indeterminate"], { waitUntilFirstUpdate: !0 })
], SlCheckbox.prototype, "handleStateChange", 1);
var spinner_styles_default = i$5`
  :host {
    --track-width: 2px;
    --track-color: rgb(128 128 128 / 25%);
    --indicator-color: var(--sl-color-primary-600);
    --speed: 2s;

    display: inline-flex;
    width: 1em;
    height: 1em;
    flex: none;
  }

  .spinner {
    flex: 1 1 auto;
    height: 100%;
    width: 100%;
  }

  .spinner__track,
  .spinner__indicator {
    fill: none;
    stroke-width: var(--track-width);
    r: calc(0.5em - var(--track-width) / 2);
    cx: 0.5em;
    cy: 0.5em;
    transform-origin: 50% 50%;
  }

  .spinner__track {
    stroke: var(--track-color);
    transform-origin: 0% 0%;
  }

  .spinner__indicator {
    stroke: var(--indicator-color);
    stroke-linecap: round;
    stroke-dasharray: 150% 75%;
    animation: spin var(--speed) linear infinite;
  }

  @keyframes spin {
    0% {
      transform: rotate(0deg);
      stroke-dasharray: 0.05em, 3em;
    }

    50% {
      transform: rotate(450deg);
      stroke-dasharray: 1.375em, 1.375em;
    }

    100% {
      transform: rotate(1080deg);
      stroke-dasharray: 0.05em, 3em;
    }
  }
`, SlSpinner = class extends ShoelaceElement {
  constructor() {
    super(...arguments), this.localize = new LocalizeController(this);
  }
  render() {
    return ke$1`
      <svg part="base" class="spinner" role="progressbar" aria-label=${this.localize.term("loading")}>
        <circle class="spinner__track"></circle>
        <circle class="spinner__indicator"></circle>
      </svg>
    `;
  }
};
SlSpinner.styles = [component_styles_default, spinner_styles_default];
/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
function nn(C, L, A) {
  return C ? L(C) : A == null ? void 0 : A(C);
}
var _SlTreeItem = class ir extends ShoelaceElement {
  constructor() {
    super(...arguments), this.localize = new LocalizeController(this), this.indeterminate = !1, this.isLeaf = !1, this.loading = !1, this.selectable = !1, this.expanded = !1, this.selected = !1, this.disabled = !1, this.lazy = !1;
  }
  static isTreeItem(L) {
    return L instanceof Element && L.getAttribute("role") === "treeitem";
  }
  connectedCallback() {
    super.connectedCallback(), this.setAttribute("role", "treeitem"), this.setAttribute("tabindex", "-1"), this.isNestedItem() && (this.slot = "children");
  }
  firstUpdated() {
    this.childrenContainer.hidden = !this.expanded, this.childrenContainer.style.height = this.expanded ? "auto" : "0", this.isLeaf = !this.lazy && this.getChildrenItems().length === 0, this.handleExpandedChange();
  }
  async animateCollapse() {
    this.emit("sl-collapse"), await stopAnimations(this.childrenContainer);
    const { keyframes: L, options: A } = getAnimation(this, "tree-item.collapse", { dir: this.localize.dir() });
    await animateTo(
      this.childrenContainer,
      shimKeyframesHeightAuto(L, this.childrenContainer.scrollHeight),
      A
    ), this.childrenContainer.hidden = !0, this.emit("sl-after-collapse");
  }
  // Checks whether the item is nested into an item
  isNestedItem() {
    const L = this.parentElement;
    return !!L && ir.isTreeItem(L);
  }
  handleChildrenSlotChange() {
    this.loading = !1, this.isLeaf = !this.lazy && this.getChildrenItems().length === 0;
  }
  willUpdate(L) {
    L.has("selected") && !L.has("indeterminate") && (this.indeterminate = !1);
  }
  async animateExpand() {
    this.emit("sl-expand"), await stopAnimations(this.childrenContainer), this.childrenContainer.hidden = !1;
    const { keyframes: L, options: A } = getAnimation(this, "tree-item.expand", { dir: this.localize.dir() });
    await animateTo(
      this.childrenContainer,
      shimKeyframesHeightAuto(L, this.childrenContainer.scrollHeight),
      A
    ), this.childrenContainer.style.height = "auto", this.emit("sl-after-expand");
  }
  handleLoadingChange() {
    this.setAttribute("aria-busy", this.loading ? "true" : "false"), this.loading || this.animateExpand();
  }
  handleDisabledChange() {
    this.setAttribute("aria-disabled", this.disabled ? "true" : "false");
  }
  handleSelectedChange() {
    this.setAttribute("aria-selected", this.selected ? "true" : "false");
  }
  handleExpandedChange() {
    this.isLeaf ? this.removeAttribute("aria-expanded") : this.setAttribute("aria-expanded", this.expanded ? "true" : "false");
  }
  handleExpandAnimation() {
    this.expanded ? this.lazy ? (this.loading = !0, this.emit("sl-lazy-load")) : this.animateExpand() : this.animateCollapse();
  }
  handleLazyChange() {
    this.emit("sl-lazy-change");
  }
  /** Gets all the nested tree items in this node. */
  getChildrenItems({ includeDisabled: L = !0 } = {}) {
    return this.childrenSlot ? [...this.childrenSlot.assignedElements({ flatten: !0 })].filter(
      (A) => ir.isTreeItem(A) && (L || !A.disabled)
    ) : [];
  }
  render() {
    const L = this.matches(":dir(rtl)"), A = !this.loading && (!this.isLeaf || this.lazy);
    return ke$1`
      <div
        part="base"
        class="${Rt({
      "tree-item": !0,
      "tree-item--expanded": this.expanded,
      "tree-item--selected": this.selected,
      "tree-item--disabled": this.disabled,
      "tree-item--leaf": this.isLeaf,
      "tree-item--has-expand-button": A,
      "tree-item--rtl": this.localize.dir() === "rtl"
    })}"
      >
        <div
          class="tree-item__item"
          part="
            item
            ${this.disabled ? "item--disabled" : ""}
            ${this.expanded ? "item--expanded" : ""}
            ${this.indeterminate ? "item--indeterminate" : ""}
            ${this.selected ? "item--selected" : ""}
          "
        >
          <div class="tree-item__indentation" part="indentation"></div>

          <div
            part="expand-button"
            class=${Rt({
      "tree-item__expand-button": !0,
      "tree-item__expand-button--visible": A
    })}
            aria-hidden="true"
          >
            ${nn(
      this.loading,
      () => ke$1` <sl-spinner part="spinner" exportparts="base:spinner__base"></sl-spinner> `
    )}
            <slot class="tree-item__expand-icon-slot" name="expand-icon">
              <sl-icon library="system" name=${L ? "chevron-left" : "chevron-right"}></sl-icon>
            </slot>
            <slot class="tree-item__expand-icon-slot" name="collapse-icon">
              <sl-icon library="system" name=${L ? "chevron-left" : "chevron-right"}></sl-icon>
            </slot>
          </div>

          ${nn(
      this.selectable,
      () => ke$1`
              <sl-checkbox
                part="checkbox"
                exportparts="
                    base:checkbox__base,
                    control:checkbox__control,
                    control--checked:checkbox__control--checked,
                    control--indeterminate:checkbox__control--indeterminate,
                    checked-icon:checkbox__checked-icon,
                    indeterminate-icon:checkbox__indeterminate-icon,
                    label:checkbox__label
                  "
                class="tree-item__checkbox"
                ?disabled="${this.disabled}"
                ?checked="${Ft(this.selected)}"
                ?indeterminate="${this.indeterminate}"
                tabindex="-1"
              ></sl-checkbox>
            `
    )}

          <slot class="tree-item__label" part="label"></slot>
        </div>

        <div class="tree-item__children" part="children" role="group">
          <slot name="children" @slotchange="${this.handleChildrenSlotChange}"></slot>
        </div>
      </div>
    `;
  }
};
_SlTreeItem.styles = [component_styles_default, tree_item_styles_default];
_SlTreeItem.dependencies = {
  "sl-checkbox": SlCheckbox,
  "sl-icon": SlIcon,
  "sl-spinner": SlSpinner
};
__decorateClass$e([
  r$3()
], _SlTreeItem.prototype, "indeterminate", 2);
__decorateClass$e([
  r$3()
], _SlTreeItem.prototype, "isLeaf", 2);
__decorateClass$e([
  r$3()
], _SlTreeItem.prototype, "loading", 2);
__decorateClass$e([
  r$3()
], _SlTreeItem.prototype, "selectable", 2);
__decorateClass$e([
  n$1({ type: Boolean, reflect: !0 })
], _SlTreeItem.prototype, "expanded", 2);
__decorateClass$e([
  n$1({ type: Boolean, reflect: !0 })
], _SlTreeItem.prototype, "selected", 2);
__decorateClass$e([
  n$1({ type: Boolean, reflect: !0 })
], _SlTreeItem.prototype, "disabled", 2);
__decorateClass$e([
  n$1({ type: Boolean, reflect: !0 })
], _SlTreeItem.prototype, "lazy", 2);
__decorateClass$e([
  e$6("slot:not([name])")
], _SlTreeItem.prototype, "defaultSlot", 2);
__decorateClass$e([
  e$6("slot[name=children]")
], _SlTreeItem.prototype, "childrenSlot", 2);
__decorateClass$e([
  e$6(".tree-item__item")
], _SlTreeItem.prototype, "itemElement", 2);
__decorateClass$e([
  e$6(".tree-item__children")
], _SlTreeItem.prototype, "childrenContainer", 2);
__decorateClass$e([
  e$6(".tree-item__expand-button slot")
], _SlTreeItem.prototype, "expandButtonSlot", 2);
__decorateClass$e([
  watch("loading", { waitUntilFirstUpdate: !0 })
], _SlTreeItem.prototype, "handleLoadingChange", 1);
__decorateClass$e([
  watch("disabled")
], _SlTreeItem.prototype, "handleDisabledChange", 1);
__decorateClass$e([
  watch("selected")
], _SlTreeItem.prototype, "handleSelectedChange", 1);
__decorateClass$e([
  watch("expanded", { waitUntilFirstUpdate: !0 })
], _SlTreeItem.prototype, "handleExpandedChange", 1);
__decorateClass$e([
  watch("expanded", { waitUntilFirstUpdate: !0 })
], _SlTreeItem.prototype, "handleExpandAnimation", 1);
__decorateClass$e([
  watch("lazy", { waitUntilFirstUpdate: !0 })
], _SlTreeItem.prototype, "handleLazyChange", 1);
var SlTreeItem = _SlTreeItem;
setDefaultAnimation("tree-item.expand", {
  keyframes: [
    { height: "0", opacity: "0", overflow: "hidden" },
    { height: "auto", opacity: "1", overflow: "hidden" }
  ],
  options: { duration: 250, easing: "cubic-bezier(0.4, 0.0, 0.2, 1)" }
});
setDefaultAnimation("tree-item.collapse", {
  keyframes: [
    { height: "auto", opacity: "1", overflow: "hidden" },
    { height: "0", opacity: "0", overflow: "hidden" }
  ],
  options: { duration: 200, easing: "cubic-bezier(0.4, 0.0, 0.2, 1)" }
});
function clamp(C, L, A) {
  const W = (X) => Object.is(X, -0) ? 0 : X;
  return C < L ? W(L) : C > A ? W(A) : W(C);
}
function syncCheckboxes(C, L = !1) {
  function A(J) {
    const te = J.getChildrenItems({ includeDisabled: !1 });
    if (te.length) {
      const oe = te.every((re) => re.selected), ne = te.every((re) => !re.selected && !re.indeterminate);
      J.selected = oe, J.indeterminate = !oe && !ne;
    }
  }
  function W(J) {
    const te = J.parentElement;
    SlTreeItem.isTreeItem(te) && (A(te), W(te));
  }
  function X(J) {
    for (const te of J.getChildrenItems())
      te.selected = L ? J.selected || te.selected : !te.disabled && J.selected, X(te);
    L && A(J);
  }
  X(C), W(C);
}
var SlTree = class extends ShoelaceElement {
  constructor() {
    super(), this.selection = "single", this.clickTarget = null, this.initTreeItem = (C) => {
      C.selectable = this.selection === "multiple", ["expand", "collapse"].filter((L) => !!this.querySelector(`[slot="${L}-icon"]`)).forEach((L) => {
        const A = C.querySelector(`[slot="${L}-icon"]`), W = this.getExpandButtonIcon(L);
        W && (A === null ? C.append(W) : A.hasAttribute("data-default") && A.replaceWith(W));
      });
    }, this.handleTreeChanged = (C) => {
      for (const L of C) {
        const A = [...L.addedNodes].filter(SlTreeItem.isTreeItem), W = [...L.removedNodes].filter(SlTreeItem.isTreeItem);
        A.forEach(this.initTreeItem), this.lastFocusedItem && W.includes(this.lastFocusedItem) && (this.lastFocusedItem = null);
      }
    }, this.handleFocusOut = (C) => {
      const L = C.relatedTarget;
      (!L || !this.contains(L)) && (this.tabIndex = 0);
    }, this.handleFocusIn = (C) => {
      const L = C.target;
      C.target === this && this.focusItem(this.lastFocusedItem || this.getAllTreeItems()[0]), SlTreeItem.isTreeItem(L) && !L.disabled && (this.lastFocusedItem && (this.lastFocusedItem.tabIndex = -1), this.lastFocusedItem = L, this.tabIndex = -1, L.tabIndex = 0);
    }, this.addEventListener("focusin", this.handleFocusIn), this.addEventListener("focusout", this.handleFocusOut), this.addEventListener("sl-lazy-change", this.handleSlotChange);
  }
  async connectedCallback() {
    super.connectedCallback(), this.setAttribute("role", "tree"), this.setAttribute("tabindex", "0"), await this.updateComplete, this.mutationObserver = new MutationObserver(this.handleTreeChanged), this.mutationObserver.observe(this, { childList: !0, subtree: !0 });
  }
  disconnectedCallback() {
    super.disconnectedCallback(), this.mutationObserver.disconnect();
  }
  // Generates a clone of the expand icon element to use for each tree item
  getExpandButtonIcon(C) {
    const A = (C === "expand" ? this.expandedIconSlot : this.collapsedIconSlot).assignedElements({ flatten: !0 })[0];
    if (A) {
      const W = A.cloneNode(!0);
      return [W, ...W.querySelectorAll("[id]")].forEach((X) => X.removeAttribute("id")), W.setAttribute("data-default", ""), W.slot = `${C}-icon`, W;
    }
    return null;
  }
  selectItem(C) {
    const L = [...this.selectedItems];
    if (this.selection === "multiple")
      C.selected = !C.selected, C.lazy && (C.expanded = !0), syncCheckboxes(C);
    else if (this.selection === "single" || C.isLeaf) {
      const W = this.getAllTreeItems();
      for (const X of W)
        X.selected = X === C;
    } else this.selection === "leaf" && (C.expanded = !C.expanded);
    const A = this.selectedItems;
    (L.length !== A.length || A.some((W) => !L.includes(W))) && Promise.all(A.map((W) => W.updateComplete)).then(() => {
      this.emit("sl-selection-change", { detail: { selection: A } });
    });
  }
  getAllTreeItems() {
    return [...this.querySelectorAll("sl-tree-item")];
  }
  focusItem(C) {
    C == null || C.focus();
  }
  handleKeyDown(C) {
    if (!["ArrowDown", "ArrowUp", "ArrowRight", "ArrowLeft", "Home", "End", "Enter", " "].includes(C.key) || C.composedPath().some((X) => {
      var J;
      return ["input", "textarea"].includes((J = X == null ? void 0 : X.tagName) == null ? void 0 : J.toLowerCase());
    }))
      return;
    const L = this.getFocusableItems(), A = this.matches(":dir(ltr)"), W = this.matches(":dir(rtl)");
    if (L.length > 0) {
      C.preventDefault();
      const X = L.findIndex((ne) => ne.matches(":focus")), J = L[X], te = (ne) => {
        const re = L[clamp(ne, 0, L.length - 1)];
        this.focusItem(re);
      }, oe = (ne) => {
        J.expanded = ne;
      };
      C.key === "ArrowDown" ? te(X + 1) : C.key === "ArrowUp" ? te(X - 1) : A && C.key === "ArrowRight" || W && C.key === "ArrowLeft" ? !J || J.disabled || J.expanded || J.isLeaf && !J.lazy ? te(X + 1) : oe(!0) : A && C.key === "ArrowLeft" || W && C.key === "ArrowRight" ? !J || J.disabled || J.isLeaf || !J.expanded ? te(X - 1) : oe(!1) : C.key === "Home" ? te(0) : C.key === "End" ? te(L.length - 1) : (C.key === "Enter" || C.key === " ") && (J.disabled || this.selectItem(J));
    }
  }
  handleClick(C) {
    const L = C.target, A = L.closest("sl-tree-item"), W = C.composedPath().some((X) => {
      var J;
      return (J = X == null ? void 0 : X.classList) == null ? void 0 : J.contains("tree-item__expand-button");
    });
    !A || A.disabled || L !== this.clickTarget || (W ? A.expanded = !A.expanded : this.selectItem(A));
  }
  handleMouseDown(C) {
    this.clickTarget = C.target;
  }
  handleSlotChange() {
    this.getAllTreeItems().forEach(this.initTreeItem);
  }
  async handleSelectionChange() {
    const C = this.selection === "multiple", L = this.getAllTreeItems();
    this.setAttribute("aria-multiselectable", C ? "true" : "false");
    for (const A of L)
      A.selectable = C;
    C && (await this.updateComplete, [...this.querySelectorAll(":scope > sl-tree-item")].forEach(
      (A) => syncCheckboxes(A, !0)
    ));
  }
  /** @internal Returns the list of tree items that are selected in the tree. */
  get selectedItems() {
    const C = this.getAllTreeItems(), L = (A) => A.selected;
    return C.filter(L);
  }
  /** @internal Gets focusable tree items in the tree. */
  getFocusableItems() {
    const C = this.getAllTreeItems(), L = /* @__PURE__ */ new Set();
    return C.filter((A) => {
      var W;
      if (A.disabled)
        return !1;
      const X = (W = A.parentElement) == null ? void 0 : W.closest("[role=treeitem]");
      return X && (!X.expanded || X.loading || L.has(X)) && L.add(A), !L.has(A);
    });
  }
  render() {
    return ke$1`
      <div
        part="base"
        class="tree"
        @click=${this.handleClick}
        @keydown=${this.handleKeyDown}
        @mousedown=${this.handleMouseDown}
      >
        <slot @slotchange=${this.handleSlotChange}></slot>
        <span hidden aria-hidden="true"><slot name="expand-icon"></slot></span>
        <span hidden aria-hidden="true"><slot name="collapse-icon"></slot></span>
      </div>
    `;
  }
};
SlTree.styles = [component_styles_default, tree_styles_default];
__decorateClass$e([
  e$6("slot:not([name])")
], SlTree.prototype, "defaultSlot", 2);
__decorateClass$e([
  e$6("slot[name=expand-icon]")
], SlTree.prototype, "expandedIconSlot", 2);
__decorateClass$e([
  e$6("slot[name=collapse-icon]")
], SlTree.prototype, "collapsedIconSlot", 2);
__decorateClass$e([
  n$1()
], SlTree.prototype, "selection", 2);
__decorateClass$e([
  watch("selection")
], SlTree.prototype, "handleSelectionChange", 1);
SlTree.define("sl-tree");
SlTreeItem.define("sl-tree-item");
var tab_panel_styles_default = i$5`
  :host {
    --padding: 0;

    display: none;
  }

  :host([active]) {
    display: block;
  }

  .tab-panel {
    display: block;
    padding: var(--padding);
  }
`, id$1 = 0, SlTabPanel = class extends ShoelaceElement {
  constructor() {
    super(...arguments), this.attrId = ++id$1, this.componentId = `sl-tab-panel-${this.attrId}`, this.name = "", this.active = !1;
  }
  connectedCallback() {
    super.connectedCallback(), this.id = this.id.length > 0 ? this.id : this.componentId, this.setAttribute("role", "tabpanel");
  }
  handleActiveChange() {
    this.setAttribute("aria-hidden", this.active ? "false" : "true");
  }
  render() {
    return ke$1`
      <slot
        part="base"
        class=${Rt({
      "tab-panel": !0,
      "tab-panel--active": this.active
    })}
      ></slot>
    `;
  }
};
SlTabPanel.styles = [component_styles_default, tab_panel_styles_default];
__decorateClass$e([
  n$1({ reflect: !0 })
], SlTabPanel.prototype, "name", 2);
__decorateClass$e([
  n$1({ type: Boolean, reflect: !0 })
], SlTabPanel.prototype, "active", 2);
__decorateClass$e([
  watch("active")
], SlTabPanel.prototype, "handleActiveChange", 1);
SlTabPanel.define("sl-tab-panel");
var tag_styles_default = i$5`
  :host {
    display: inline-block;
  }

  .tag {
    display: flex;
    align-items: center;
    border: solid 1px;
    line-height: 1;
    white-space: nowrap;
    user-select: none;
    -webkit-user-select: none;
  }

  .tag__remove::part(base) {
    color: inherit;
    padding: 0;
  }

  /*
   * Variant modifiers
   */

  .tag--primary {
    background-color: var(--sl-color-primary-50);
    border-color: var(--sl-color-primary-200);
    color: var(--sl-color-primary-800);
  }

  .tag--primary:active > sl-icon-button {
    color: var(--sl-color-primary-600);
  }

  .tag--success {
    background-color: var(--sl-color-success-50);
    border-color: var(--sl-color-success-200);
    color: var(--sl-color-success-800);
  }

  .tag--success:active > sl-icon-button {
    color: var(--sl-color-success-600);
  }

  .tag--neutral {
    background-color: var(--sl-color-neutral-50);
    border-color: var(--sl-color-neutral-200);
    color: var(--sl-color-neutral-800);
  }

  .tag--neutral:active > sl-icon-button {
    color: var(--sl-color-neutral-600);
  }

  .tag--warning {
    background-color: var(--sl-color-warning-50);
    border-color: var(--sl-color-warning-200);
    color: var(--sl-color-warning-800);
  }

  .tag--warning:active > sl-icon-button {
    color: var(--sl-color-warning-600);
  }

  .tag--danger {
    background-color: var(--sl-color-danger-50);
    border-color: var(--sl-color-danger-200);
    color: var(--sl-color-danger-800);
  }

  .tag--danger:active > sl-icon-button {
    color: var(--sl-color-danger-600);
  }

  /*
   * Size modifiers
   */

  .tag--small {
    font-size: var(--sl-button-font-size-small);
    height: calc(var(--sl-input-height-small) * 0.8);
    line-height: calc(var(--sl-input-height-small) - var(--sl-input-border-width) * 2);
    border-radius: var(--sl-input-border-radius-small);
    padding: 0 var(--sl-spacing-x-small);
  }

  .tag--medium {
    font-size: var(--sl-button-font-size-medium);
    height: calc(var(--sl-input-height-medium) * 0.8);
    line-height: calc(var(--sl-input-height-medium) - var(--sl-input-border-width) * 2);
    border-radius: var(--sl-input-border-radius-medium);
    padding: 0 var(--sl-spacing-small);
  }

  .tag--large {
    font-size: var(--sl-button-font-size-large);
    height: calc(var(--sl-input-height-large) * 0.8);
    line-height: calc(var(--sl-input-height-large) - var(--sl-input-border-width) * 2);
    border-radius: var(--sl-input-border-radius-large);
    padding: 0 var(--sl-spacing-medium);
  }

  .tag__remove {
    margin-inline-start: var(--sl-spacing-x-small);
  }

  /*
   * Pill modifier
   */

  .tag--pill {
    border-radius: var(--sl-border-radius-pill);
  }
`, icon_button_styles_default = i$5`
  :host {
    display: inline-block;
    color: var(--sl-color-neutral-600);
  }

  .icon-button {
    flex: 0 0 auto;
    display: flex;
    align-items: center;
    background: none;
    border: none;
    border-radius: var(--sl-border-radius-medium);
    font-size: inherit;
    color: inherit;
    padding: var(--sl-spacing-x-small);
    cursor: pointer;
    transition: var(--sl-transition-x-fast) color;
    -webkit-appearance: none;
  }

  .icon-button:hover:not(.icon-button--disabled),
  .icon-button:focus-visible:not(.icon-button--disabled) {
    color: var(--sl-color-primary-600);
  }

  .icon-button:active:not(.icon-button--disabled) {
    color: var(--sl-color-primary-700);
  }

  .icon-button:focus {
    outline: none;
  }

  .icon-button--disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }

  .icon-button:focus-visible {
    outline: var(--sl-focus-ring);
    outline-offset: var(--sl-focus-ring-offset);
  }

  .icon-button__icon {
    pointer-events: none;
  }
`;
/**
 * @license
 * Copyright 2020 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const $e = Symbol.for(""), xe = (C) => {
  if ((C == null ? void 0 : C.r) === $e) return C == null ? void 0 : C._$litStatic$;
}, er = (C, ...L) => ({ _$litStatic$: L.reduce((A, W, X) => A + ((J) => {
  if (J._$litStatic$ !== void 0) return J._$litStatic$;
  throw Error(`Value passed to 'literal' function must be a 'literal' result: ${J}. Use 'unsafeStatic' to pass non-literal values, but
            take care to ensure page security.`);
})(W) + C[X + 1], C[0]), r: $e }), Te = /* @__PURE__ */ new Map(), Ee = (C) => (L, ...A) => {
  const W = A.length;
  let X, J;
  const te = [], oe = [];
  let ne, re = 0, ce = !1;
  for (; re < W; ) {
    for (ne = L[re]; re < W && (J = A[re], (X = xe(J)) !== void 0); ) ne += X + L[++re], ce = !0;
    re !== W && oe.push(J), te.push(ne), re++;
  }
  if (re === W && te.push(L[W]), ce) {
    const ue = te.join("$$lit$$");
    (L = Te.get(ue)) === void 0 && (te.raw = te, Te.set(ue, L = te)), A = oe;
  }
  return C(L, ...A);
}, ke = Ee(ke$1);
var SlIconButton = class extends ShoelaceElement {
  constructor() {
    super(...arguments), this.hasFocus = !1, this.label = "", this.disabled = !1;
  }
  handleBlur() {
    this.hasFocus = !1, this.emit("sl-blur");
  }
  handleFocus() {
    this.hasFocus = !0, this.emit("sl-focus");
  }
  handleClick(C) {
    this.disabled && (C.preventDefault(), C.stopPropagation());
  }
  /** Simulates a click on the icon button. */
  click() {
    this.button.click();
  }
  /** Sets focus on the icon button. */
  focus(C) {
    this.button.focus(C);
  }
  /** Removes focus from the icon button. */
  blur() {
    this.button.blur();
  }
  render() {
    const C = !!this.href, L = C ? er`a` : er`button`;
    return ke`
      <${L}
        part="base"
        class=${Rt({
      "icon-button": !0,
      "icon-button--disabled": !C && this.disabled,
      "icon-button--focused": this.hasFocus
    })}
        ?disabled=${to(C ? void 0 : this.disabled)}
        type=${to(C ? void 0 : "button")}
        href=${to(C ? this.href : void 0)}
        target=${to(C ? this.target : void 0)}
        download=${to(C ? this.download : void 0)}
        rel=${to(C && this.target ? "noreferrer noopener" : void 0)}
        role=${to(C ? void 0 : "button")}
        aria-disabled=${this.disabled ? "true" : "false"}
        aria-label="${this.label}"
        tabindex=${this.disabled ? "-1" : "0"}
        @blur=${this.handleBlur}
        @focus=${this.handleFocus}
        @click=${this.handleClick}
      >
        <sl-icon
          class="icon-button__icon"
          name=${to(this.name)}
          library=${to(this.library)}
          src=${to(this.src)}
          aria-hidden="true"
        ></sl-icon>
      </${L}>
    `;
  }
};
SlIconButton.styles = [component_styles_default, icon_button_styles_default];
SlIconButton.dependencies = { "sl-icon": SlIcon };
__decorateClass$e([
  e$6(".icon-button")
], SlIconButton.prototype, "button", 2);
__decorateClass$e([
  r$3()
], SlIconButton.prototype, "hasFocus", 2);
__decorateClass$e([
  n$1()
], SlIconButton.prototype, "name", 2);
__decorateClass$e([
  n$1()
], SlIconButton.prototype, "library", 2);
__decorateClass$e([
  n$1()
], SlIconButton.prototype, "src", 2);
__decorateClass$e([
  n$1()
], SlIconButton.prototype, "href", 2);
__decorateClass$e([
  n$1()
], SlIconButton.prototype, "target", 2);
__decorateClass$e([
  n$1()
], SlIconButton.prototype, "download", 2);
__decorateClass$e([
  n$1()
], SlIconButton.prototype, "label", 2);
__decorateClass$e([
  n$1({ type: Boolean, reflect: !0 })
], SlIconButton.prototype, "disabled", 2);
var SlTag = class extends ShoelaceElement {
  constructor() {
    super(...arguments), this.localize = new LocalizeController(this), this.variant = "neutral", this.size = "medium", this.pill = !1, this.removable = !1;
  }
  handleRemoveClick() {
    this.emit("sl-remove");
  }
  render() {
    return ke$1`
      <span
        part="base"
        class=${Rt({
      tag: !0,
      // Types
      "tag--primary": this.variant === "primary",
      "tag--success": this.variant === "success",
      "tag--neutral": this.variant === "neutral",
      "tag--warning": this.variant === "warning",
      "tag--danger": this.variant === "danger",
      "tag--text": this.variant === "text",
      // Sizes
      "tag--small": this.size === "small",
      "tag--medium": this.size === "medium",
      "tag--large": this.size === "large",
      // Modifiers
      "tag--pill": this.pill,
      "tag--removable": this.removable
    })}
      >
        <slot part="content" class="tag__content"></slot>

        ${this.removable ? ke$1`
              <sl-icon-button
                part="remove-button"
                exportparts="base:remove-button__base"
                name="x-lg"
                library="system"
                label=${this.localize.term("remove")}
                class="tag__remove"
                @click=${this.handleRemoveClick}
                tabindex="-1"
              ></sl-icon-button>
            ` : ""}
      </span>
    `;
  }
};
SlTag.styles = [component_styles_default, tag_styles_default];
SlTag.dependencies = { "sl-icon-button": SlIconButton };
__decorateClass$e([
  n$1({ reflect: !0 })
], SlTag.prototype, "variant", 2);
__decorateClass$e([
  n$1({ reflect: !0 })
], SlTag.prototype, "size", 2);
__decorateClass$e([
  n$1({ type: Boolean, reflect: !0 })
], SlTag.prototype, "pill", 2);
__decorateClass$e([
  n$1({ type: Boolean })
], SlTag.prototype, "removable", 2);
SlTag.define("sl-tag");
var textarea_styles_default = i$5`
  :host {
    display: block;
  }

  .textarea {
    display: flex;
    align-items: center;
    position: relative;
    width: 100%;
    font-family: var(--sl-input-font-family);
    font-weight: var(--sl-input-font-weight);
    line-height: var(--sl-line-height-normal);
    letter-spacing: var(--sl-input-letter-spacing);
    vertical-align: middle;
    transition:
      var(--sl-transition-fast) color,
      var(--sl-transition-fast) border,
      var(--sl-transition-fast) box-shadow,
      var(--sl-transition-fast) background-color;
    cursor: text;
  }

  /* Standard textareas */
  .textarea--standard {
    background-color: var(--sl-input-background-color);
    border: solid var(--sl-input-border-width) var(--sl-input-border-color);
  }

  .textarea--standard:hover:not(.textarea--disabled) {
    background-color: var(--sl-input-background-color-hover);
    border-color: var(--sl-input-border-color-hover);
  }
  .textarea--standard:hover:not(.textarea--disabled) .textarea__control {
    color: var(--sl-input-color-hover);
  }

  .textarea--standard.textarea--focused:not(.textarea--disabled) {
    background-color: var(--sl-input-background-color-focus);
    border-color: var(--sl-input-border-color-focus);
    color: var(--sl-input-color-focus);
    box-shadow: 0 0 0 var(--sl-focus-ring-width) var(--sl-input-focus-ring-color);
  }

  .textarea--standard.textarea--focused:not(.textarea--disabled) .textarea__control {
    color: var(--sl-input-color-focus);
  }

  .textarea--standard.textarea--disabled {
    background-color: var(--sl-input-background-color-disabled);
    border-color: var(--sl-input-border-color-disabled);
    opacity: 0.5;
    cursor: not-allowed;
  }

  .textarea--standard.textarea--disabled .textarea__control {
    color: var(--sl-input-color-disabled);
  }

  .textarea--standard.textarea--disabled .textarea__control::placeholder {
    color: var(--sl-input-placeholder-color-disabled);
  }

  /* Filled textareas */
  .textarea--filled {
    border: none;
    background-color: var(--sl-input-filled-background-color);
    color: var(--sl-input-color);
  }

  .textarea--filled:hover:not(.textarea--disabled) {
    background-color: var(--sl-input-filled-background-color-hover);
  }

  .textarea--filled.textarea--focused:not(.textarea--disabled) {
    background-color: var(--sl-input-filled-background-color-focus);
    outline: var(--sl-focus-ring);
    outline-offset: var(--sl-focus-ring-offset);
  }

  .textarea--filled.textarea--disabled {
    background-color: var(--sl-input-filled-background-color-disabled);
    opacity: 0.5;
    cursor: not-allowed;
  }

  .textarea__control {
    flex: 1 1 auto;
    font-family: inherit;
    font-size: inherit;
    font-weight: inherit;
    line-height: 1.4;
    color: var(--sl-input-color);
    border: none;
    background: none;
    box-shadow: none;
    cursor: inherit;
    -webkit-appearance: none;
  }

  .textarea__control::-webkit-search-decoration,
  .textarea__control::-webkit-search-cancel-button,
  .textarea__control::-webkit-search-results-button,
  .textarea__control::-webkit-search-results-decoration {
    -webkit-appearance: none;
  }

  .textarea__control::placeholder {
    color: var(--sl-input-placeholder-color);
    user-select: none;
    -webkit-user-select: none;
  }

  .textarea__control:focus {
    outline: none;
  }

  /*
   * Size modifiers
   */

  .textarea--small {
    border-radius: var(--sl-input-border-radius-small);
    font-size: var(--sl-input-font-size-small);
  }

  .textarea--small .textarea__control {
    padding: 0.5em var(--sl-input-spacing-small);
  }

  .textarea--medium {
    border-radius: var(--sl-input-border-radius-medium);
    font-size: var(--sl-input-font-size-medium);
  }

  .textarea--medium .textarea__control {
    padding: 0.5em var(--sl-input-spacing-medium);
  }

  .textarea--large {
    border-radius: var(--sl-input-border-radius-large);
    font-size: var(--sl-input-font-size-large);
  }

  .textarea--large .textarea__control {
    padding: 0.5em var(--sl-input-spacing-large);
  }

  /*
   * Resize types
   */

  .textarea--resize-none .textarea__control {
    resize: none;
  }

  .textarea--resize-vertical .textarea__control {
    resize: vertical;
  }

  .textarea--resize-auto .textarea__control {
    height: auto;
    resize: none;
    overflow-y: hidden;
  }
`, SlTextarea = class extends ShoelaceElement {
  constructor() {
    super(...arguments), this.formControlController = new FormControlController(this, {
      assumeInteractionOn: ["sl-blur", "sl-input"]
    }), this.hasSlotController = new HasSlotController(this, "help-text", "label"), this.hasFocus = !1, this.title = "", this.name = "", this.value = "", this.size = "medium", this.filled = !1, this.label = "", this.helpText = "", this.placeholder = "", this.rows = 4, this.resize = "vertical", this.disabled = !1, this.readonly = !1, this.form = "", this.required = !1, this.spellcheck = !0, this.defaultValue = "";
  }
  /** Gets the validity state object */
  get validity() {
    return this.input.validity;
  }
  /** Gets the validation message */
  get validationMessage() {
    return this.input.validationMessage;
  }
  connectedCallback() {
    super.connectedCallback(), this.resizeObserver = new ResizeObserver(() => this.setTextareaHeight()), this.updateComplete.then(() => {
      this.setTextareaHeight(), this.resizeObserver.observe(this.input);
    });
  }
  firstUpdated() {
    this.formControlController.updateValidity();
  }
  disconnectedCallback() {
    super.disconnectedCallback(), this.input && this.resizeObserver.unobserve(this.input);
  }
  handleBlur() {
    this.hasFocus = !1, this.emit("sl-blur");
  }
  handleChange() {
    this.value = this.input.value, this.setTextareaHeight(), this.emit("sl-change");
  }
  handleFocus() {
    this.hasFocus = !0, this.emit("sl-focus");
  }
  handleInput() {
    this.value = this.input.value, this.emit("sl-input");
  }
  handleInvalid(C) {
    this.formControlController.setValidity(!1), this.formControlController.emitInvalidEvent(C);
  }
  setTextareaHeight() {
    this.resize === "auto" ? (this.input.style.height = "auto", this.input.style.height = `${this.input.scrollHeight}px`) : this.input.style.height = void 0;
  }
  handleDisabledChange() {
    this.formControlController.setValidity(this.disabled);
  }
  handleRowsChange() {
    this.setTextareaHeight();
  }
  async handleValueChange() {
    await this.updateComplete, this.formControlController.updateValidity(), this.setTextareaHeight();
  }
  /** Sets focus on the textarea. */
  focus(C) {
    this.input.focus(C);
  }
  /** Removes focus from the textarea. */
  blur() {
    this.input.blur();
  }
  /** Selects all the text in the textarea. */
  select() {
    this.input.select();
  }
  /** Gets or sets the textarea's scroll position. */
  scrollPosition(C) {
    if (C) {
      typeof C.top == "number" && (this.input.scrollTop = C.top), typeof C.left == "number" && (this.input.scrollLeft = C.left);
      return;
    }
    return {
      top: this.input.scrollTop,
      left: this.input.scrollTop
    };
  }
  /** Sets the start and end positions of the text selection (0-based). */
  setSelectionRange(C, L, A = "none") {
    this.input.setSelectionRange(C, L, A);
  }
  /** Replaces a range of text with a new string. */
  setRangeText(C, L, A, W = "preserve") {
    const X = L ?? this.input.selectionStart, J = A ?? this.input.selectionEnd;
    this.input.setRangeText(C, X, J, W), this.value !== this.input.value && (this.value = this.input.value, this.setTextareaHeight());
  }
  /** Checks for validity but does not show a validation message. Returns `true` when valid and `false` when invalid. */
  checkValidity() {
    return this.input.checkValidity();
  }
  /** Gets the associated form, if one exists. */
  getForm() {
    return this.formControlController.getForm();
  }
  /** Checks for validity and shows the browser's validation message if the control is invalid. */
  reportValidity() {
    return this.input.reportValidity();
  }
  /** Sets a custom validation message. Pass an empty string to restore validity. */
  setCustomValidity(C) {
    this.input.setCustomValidity(C), this.formControlController.updateValidity();
  }
  render() {
    const C = this.hasSlotController.test("label"), L = this.hasSlotController.test("help-text"), A = this.label ? !0 : !!C, W = this.helpText ? !0 : !!L;
    return ke$1`
      <div
        part="form-control"
        class=${Rt({
      "form-control": !0,
      "form-control--small": this.size === "small",
      "form-control--medium": this.size === "medium",
      "form-control--large": this.size === "large",
      "form-control--has-label": A,
      "form-control--has-help-text": W
    })}
      >
        <label
          part="form-control-label"
          class="form-control__label"
          for="input"
          aria-hidden=${A ? "false" : "true"}
        >
          <slot name="label">${this.label}</slot>
        </label>

        <div part="form-control-input" class="form-control-input">
          <div
            part="base"
            class=${Rt({
      textarea: !0,
      "textarea--small": this.size === "small",
      "textarea--medium": this.size === "medium",
      "textarea--large": this.size === "large",
      "textarea--standard": !this.filled,
      "textarea--filled": this.filled,
      "textarea--disabled": this.disabled,
      "textarea--focused": this.hasFocus,
      "textarea--empty": !this.value,
      "textarea--resize-none": this.resize === "none",
      "textarea--resize-vertical": this.resize === "vertical",
      "textarea--resize-auto": this.resize === "auto"
    })}
          >
            <textarea
              part="textarea"
              id="input"
              class="textarea__control"
              title=${this.title}
              name=${to(this.name)}
              .value=${Ft(this.value)}
              ?disabled=${this.disabled}
              ?readonly=${this.readonly}
              ?required=${this.required}
              placeholder=${to(this.placeholder)}
              rows=${to(this.rows)}
              minlength=${to(this.minlength)}
              maxlength=${to(this.maxlength)}
              autocapitalize=${to(this.autocapitalize)}
              autocorrect=${to(this.autocorrect)}
              ?autofocus=${this.autofocus}
              spellcheck=${to(this.spellcheck)}
              enterkeyhint=${to(this.enterkeyhint)}
              inputmode=${to(this.inputmode)}
              aria-describedby="help-text"
              @change=${this.handleChange}
              @input=${this.handleInput}
              @invalid=${this.handleInvalid}
              @focus=${this.handleFocus}
              @blur=${this.handleBlur}
            ></textarea>
          </div>
        </div>

        <div
          part="form-control-help-text"
          id="help-text"
          class="form-control__help-text"
          aria-hidden=${W ? "false" : "true"}
        >
          <slot name="help-text">${this.helpText}</slot>
        </div>
      </div>
    `;
  }
};
SlTextarea.styles = [component_styles_default, form_control_styles_default, textarea_styles_default];
__decorateClass$e([
  e$6(".textarea__control")
], SlTextarea.prototype, "input", 2);
__decorateClass$e([
  r$3()
], SlTextarea.prototype, "hasFocus", 2);
__decorateClass$e([
  n$1()
], SlTextarea.prototype, "title", 2);
__decorateClass$e([
  n$1()
], SlTextarea.prototype, "name", 2);
__decorateClass$e([
  n$1()
], SlTextarea.prototype, "value", 2);
__decorateClass$e([
  n$1({ reflect: !0 })
], SlTextarea.prototype, "size", 2);
__decorateClass$e([
  n$1({ type: Boolean, reflect: !0 })
], SlTextarea.prototype, "filled", 2);
__decorateClass$e([
  n$1()
], SlTextarea.prototype, "label", 2);
__decorateClass$e([
  n$1({ attribute: "help-text" })
], SlTextarea.prototype, "helpText", 2);
__decorateClass$e([
  n$1()
], SlTextarea.prototype, "placeholder", 2);
__decorateClass$e([
  n$1({ type: Number })
], SlTextarea.prototype, "rows", 2);
__decorateClass$e([
  n$1()
], SlTextarea.prototype, "resize", 2);
__decorateClass$e([
  n$1({ type: Boolean, reflect: !0 })
], SlTextarea.prototype, "disabled", 2);
__decorateClass$e([
  n$1({ type: Boolean, reflect: !0 })
], SlTextarea.prototype, "readonly", 2);
__decorateClass$e([
  n$1({ reflect: !0 })
], SlTextarea.prototype, "form", 2);
__decorateClass$e([
  n$1({ type: Boolean, reflect: !0 })
], SlTextarea.prototype, "required", 2);
__decorateClass$e([
  n$1({ type: Number })
], SlTextarea.prototype, "minlength", 2);
__decorateClass$e([
  n$1({ type: Number })
], SlTextarea.prototype, "maxlength", 2);
__decorateClass$e([
  n$1()
], SlTextarea.prototype, "autocapitalize", 2);
__decorateClass$e([
  n$1()
], SlTextarea.prototype, "autocorrect", 2);
__decorateClass$e([
  n$1()
], SlTextarea.prototype, "autocomplete", 2);
__decorateClass$e([
  n$1({ type: Boolean })
], SlTextarea.prototype, "autofocus", 2);
__decorateClass$e([
  n$1()
], SlTextarea.prototype, "enterkeyhint", 2);
__decorateClass$e([
  n$1({
    type: Boolean,
    converter: {
      // Allow "true|false" attribute values but keep the property boolean
      fromAttribute: (C) => !(!C || C === "false"),
      toAttribute: (C) => C ? "true" : "false"
    }
  })
], SlTextarea.prototype, "spellcheck", 2);
__decorateClass$e([
  n$1()
], SlTextarea.prototype, "inputmode", 2);
__decorateClass$e([
  defaultValue()
], SlTextarea.prototype, "defaultValue", 2);
__decorateClass$e([
  watch("disabled", { waitUntilFirstUpdate: !0 })
], SlTextarea.prototype, "handleDisabledChange", 1);
__decorateClass$e([
  watch("rows", { waitUntilFirstUpdate: !0 })
], SlTextarea.prototype, "handleRowsChange", 1);
__decorateClass$e([
  watch("value", { waitUntilFirstUpdate: !0 })
], SlTextarea.prototype, "handleValueChange", 1);
SlTextarea.define("sl-textarea");
var tab_styles_default = i$5`
  :host {
    display: inline-block;
  }

  .tab {
    display: inline-flex;
    align-items: center;
    font-family: var(--sl-font-sans);
    font-size: var(--sl-font-size-small);
    font-weight: var(--sl-font-weight-semibold);
    border-radius: var(--sl-border-radius-medium);
    color: var(--sl-color-neutral-600);
    padding: var(--sl-spacing-medium) var(--sl-spacing-large);
    white-space: nowrap;
    user-select: none;
    -webkit-user-select: none;
    cursor: pointer;
    transition:
      var(--transition-speed) box-shadow,
      var(--transition-speed) color;
  }

  .tab:hover:not(.tab--disabled) {
    color: var(--sl-color-primary-600);
  }

  :host(:focus) {
    outline: transparent;
  }

  :host(:focus-visible):not([disabled]) {
    color: var(--sl-color-primary-600);
  }

  :host(:focus-visible) {
    outline: var(--sl-focus-ring);
    outline-offset: calc(-1 * var(--sl-focus-ring-width) - var(--sl-focus-ring-offset));
  }

  .tab.tab--active:not(.tab--disabled) {
    color: var(--sl-color-primary-600);
  }

  .tab.tab--closable {
    padding-inline-end: var(--sl-spacing-small);
  }

  .tab.tab--disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }

  .tab__close-button {
    font-size: var(--sl-font-size-small);
    margin-inline-start: var(--sl-spacing-small);
  }

  .tab__close-button::part(base) {
    padding: var(--sl-spacing-3x-small);
  }

  @media (forced-colors: active) {
    .tab.tab--active:not(.tab--disabled) {
      outline: solid 1px transparent;
      outline-offset: -3px;
    }
  }
`, id = 0, SlTab = class extends ShoelaceElement {
  constructor() {
    super(...arguments), this.localize = new LocalizeController(this), this.attrId = ++id, this.componentId = `sl-tab-${this.attrId}`, this.panel = "", this.active = !1, this.closable = !1, this.disabled = !1, this.tabIndex = 0;
  }
  connectedCallback() {
    super.connectedCallback(), this.setAttribute("role", "tab");
  }
  handleCloseClick(C) {
    C.stopPropagation(), this.emit("sl-close");
  }
  handleActiveChange() {
    this.setAttribute("aria-selected", this.active ? "true" : "false");
  }
  handleDisabledChange() {
    this.setAttribute("aria-disabled", this.disabled ? "true" : "false"), this.disabled && !this.active ? this.tabIndex = -1 : this.tabIndex = 0;
  }
  render() {
    return this.id = this.id.length > 0 ? this.id : this.componentId, ke$1`
      <div
        part="base"
        class=${Rt({
      tab: !0,
      "tab--active": this.active,
      "tab--closable": this.closable,
      "tab--disabled": this.disabled
    })}
      >
        <slot></slot>
        ${this.closable ? ke$1`
              <sl-icon-button
                part="close-button"
                exportparts="base:close-button__base"
                name="x-lg"
                library="system"
                label=${this.localize.term("close")}
                class="tab__close-button"
                @click=${this.handleCloseClick}
                tabindex="-1"
              ></sl-icon-button>
            ` : ""}
      </div>
    `;
  }
};
SlTab.styles = [component_styles_default, tab_styles_default];
SlTab.dependencies = { "sl-icon-button": SlIconButton };
__decorateClass$e([
  e$6(".tab")
], SlTab.prototype, "tab", 2);
__decorateClass$e([
  n$1({ reflect: !0 })
], SlTab.prototype, "panel", 2);
__decorateClass$e([
  n$1({ type: Boolean, reflect: !0 })
], SlTab.prototype, "active", 2);
__decorateClass$e([
  n$1({ type: Boolean, reflect: !0 })
], SlTab.prototype, "closable", 2);
__decorateClass$e([
  n$1({ type: Boolean, reflect: !0 })
], SlTab.prototype, "disabled", 2);
__decorateClass$e([
  n$1({ type: Number, reflect: !0 })
], SlTab.prototype, "tabIndex", 2);
__decorateClass$e([
  watch("active")
], SlTab.prototype, "handleActiveChange", 1);
__decorateClass$e([
  watch("disabled")
], SlTab.prototype, "handleDisabledChange", 1);
SlTab.define("sl-tab");
var tab_group_styles_default = i$5`
  :host {
    --indicator-color: var(--sl-color-primary-600);
    --track-color: var(--sl-color-neutral-200);
    --track-width: 2px;

    display: block;
  }

  .tab-group {
    display: flex;
    border-radius: 0;
  }

  .tab-group__tabs {
    display: flex;
    position: relative;
  }

  .tab-group__indicator {
    position: absolute;
    transition:
      var(--sl-transition-fast) translate ease,
      var(--sl-transition-fast) width ease;
  }

  .tab-group--has-scroll-controls .tab-group__nav-container {
    position: relative;
    padding: 0 var(--sl-spacing-x-large);
  }

  .tab-group__body {
    display: block;
    overflow: auto;
  }

  .tab-group__scroll-button {
    display: flex;
    align-items: center;
    justify-content: center;
    position: absolute;
    top: 0;
    bottom: 0;
    width: var(--sl-spacing-x-large);
  }

  .tab-group__scroll-button--start {
    left: 0;
  }

  .tab-group__scroll-button--end {
    right: 0;
  }

  .tab-group--rtl .tab-group__scroll-button--start {
    left: auto;
    right: 0;
  }

  .tab-group--rtl .tab-group__scroll-button--end {
    left: 0;
    right: auto;
  }

  /*
   * Top
   */

  .tab-group--top {
    flex-direction: column;
  }

  .tab-group--top .tab-group__nav-container {
    order: 1;
  }

  .tab-group--top .tab-group__nav {
    display: flex;
    overflow-x: auto;

    /* Hide scrollbar in Firefox */
    scrollbar-width: none;
  }

  /* Hide scrollbar in Chrome/Safari */
  .tab-group--top .tab-group__nav::-webkit-scrollbar {
    width: 0;
    height: 0;
  }

  .tab-group--top .tab-group__tabs {
    flex: 1 1 auto;
    position: relative;
    flex-direction: row;
    border-bottom: solid var(--track-width) var(--track-color);
  }

  .tab-group--top .tab-group__indicator {
    bottom: calc(-1 * var(--track-width));
    border-bottom: solid var(--track-width) var(--indicator-color);
  }

  .tab-group--top .tab-group__body {
    order: 2;
  }

  .tab-group--top ::slotted(sl-tab-panel) {
    --padding: var(--sl-spacing-medium) 0;
  }

  /*
   * Bottom
   */

  .tab-group--bottom {
    flex-direction: column;
  }

  .tab-group--bottom .tab-group__nav-container {
    order: 2;
  }

  .tab-group--bottom .tab-group__nav {
    display: flex;
    overflow-x: auto;

    /* Hide scrollbar in Firefox */
    scrollbar-width: none;
  }

  /* Hide scrollbar in Chrome/Safari */
  .tab-group--bottom .tab-group__nav::-webkit-scrollbar {
    width: 0;
    height: 0;
  }

  .tab-group--bottom .tab-group__tabs {
    flex: 1 1 auto;
    position: relative;
    flex-direction: row;
    border-top: solid var(--track-width) var(--track-color);
  }

  .tab-group--bottom .tab-group__indicator {
    top: calc(-1 * var(--track-width));
    border-top: solid var(--track-width) var(--indicator-color);
  }

  .tab-group--bottom .tab-group__body {
    order: 1;
  }

  .tab-group--bottom ::slotted(sl-tab-panel) {
    --padding: var(--sl-spacing-medium) 0;
  }

  /*
   * Start
   */

  .tab-group--start {
    flex-direction: row;
  }

  .tab-group--start .tab-group__nav-container {
    order: 1;
  }

  .tab-group--start .tab-group__tabs {
    flex: 0 0 auto;
    flex-direction: column;
    border-inline-end: solid var(--track-width) var(--track-color);
  }

  .tab-group--start .tab-group__indicator {
    right: calc(-1 * var(--track-width));
    border-right: solid var(--track-width) var(--indicator-color);
  }

  .tab-group--start.tab-group--rtl .tab-group__indicator {
    right: auto;
    left: calc(-1 * var(--track-width));
  }

  .tab-group--start .tab-group__body {
    flex: 1 1 auto;
    order: 2;
  }

  .tab-group--start ::slotted(sl-tab-panel) {
    --padding: 0 var(--sl-spacing-medium);
  }

  /*
   * End
   */

  .tab-group--end {
    flex-direction: row;
  }

  .tab-group--end .tab-group__nav-container {
    order: 2;
  }

  .tab-group--end .tab-group__tabs {
    flex: 0 0 auto;
    flex-direction: column;
    border-left: solid var(--track-width) var(--track-color);
  }

  .tab-group--end .tab-group__indicator {
    left: calc(-1 * var(--track-width));
    border-inline-start: solid var(--track-width) var(--indicator-color);
  }

  .tab-group--end.tab-group--rtl .tab-group__indicator {
    right: calc(-1 * var(--track-width));
    left: auto;
  }

  .tab-group--end .tab-group__body {
    flex: 1 1 auto;
    order: 1;
  }

  .tab-group--end ::slotted(sl-tab-panel) {
    --padding: 0 var(--sl-spacing-medium);
  }
`;
function getOffset(C, L) {
  return {
    top: Math.round(C.getBoundingClientRect().top - L.getBoundingClientRect().top),
    left: Math.round(C.getBoundingClientRect().left - L.getBoundingClientRect().left)
  };
}
var locks = /* @__PURE__ */ new Set();
function getScrollbarWidth() {
  const C = document.documentElement.clientWidth;
  return Math.abs(window.innerWidth - C);
}
function getExistingBodyPadding() {
  const C = Number(getComputedStyle(document.body).paddingRight.replace(/px/, ""));
  return isNaN(C) || !C ? 0 : C;
}
function lockBodyScrolling(C) {
  if (locks.add(C), !document.documentElement.classList.contains("sl-scroll-lock")) {
    const L = getScrollbarWidth() + getExistingBodyPadding();
    let A = getComputedStyle(document.documentElement).scrollbarGutter;
    (!A || A === "auto") && (A = "stable"), L < 2 && (A = ""), document.documentElement.style.setProperty("--sl-scroll-lock-gutter", A), document.documentElement.classList.add("sl-scroll-lock"), document.documentElement.style.setProperty("--sl-scroll-lock-size", `${L}px`);
  }
}
function unlockBodyScrolling(C) {
  locks.delete(C), locks.size === 0 && (document.documentElement.classList.remove("sl-scroll-lock"), document.documentElement.style.removeProperty("--sl-scroll-lock-size"));
}
function scrollIntoView(C, L, A = "vertical", W = "smooth") {
  const X = getOffset(C, L), J = X.top + L.scrollTop, te = X.left + L.scrollLeft, oe = L.scrollLeft, ne = L.scrollLeft + L.offsetWidth, re = L.scrollTop, ce = L.scrollTop + L.offsetHeight;
  (A === "horizontal" || A === "both") && (te < oe ? L.scrollTo({ left: te, behavior: W }) : te + C.clientWidth > ne && L.scrollTo({ left: te - L.offsetWidth + C.clientWidth, behavior: W })), (A === "vertical" || A === "both") && (J < re ? L.scrollTo({ top: J, behavior: W }) : J + C.clientHeight > ce && L.scrollTo({ top: J - L.offsetHeight + C.clientHeight, behavior: W }));
}
var SlTabGroup = class extends ShoelaceElement {
  constructor() {
    super(...arguments), this.localize = new LocalizeController(this), this.tabs = [], this.focusableTabs = [], this.panels = [], this.hasScrollControls = !1, this.placement = "top", this.activation = "auto", this.noScrollControls = !1;
  }
  connectedCallback() {
    const C = Promise.all([
      customElements.whenDefined("sl-tab"),
      customElements.whenDefined("sl-tab-panel")
    ]);
    super.connectedCallback(), this.resizeObserver = new ResizeObserver(() => {
      this.repositionIndicator(), this.updateScrollControls();
    }), this.mutationObserver = new MutationObserver((L) => {
      L.some((A) => !["aria-labelledby", "aria-controls"].includes(A.attributeName)) && setTimeout(() => this.setAriaLabels()), L.some((A) => A.attributeName === "disabled") && this.syncTabsAndPanels();
    }), this.updateComplete.then(() => {
      this.syncTabsAndPanels(), this.mutationObserver.observe(this, { attributes: !0, childList: !0, subtree: !0 }), this.resizeObserver.observe(this.nav), C.then(() => {
        new IntersectionObserver((A, W) => {
          var X;
          A[0].intersectionRatio > 0 && (this.setAriaLabels(), this.setActiveTab((X = this.getActiveTab()) != null ? X : this.tabs[0], { emitEvents: !1 }), W.unobserve(A[0].target));
        }).observe(this.tabGroup);
      });
    });
  }
  disconnectedCallback() {
    super.disconnectedCallback(), this.mutationObserver.disconnect(), this.resizeObserver.unobserve(this.nav);
  }
  getAllTabs() {
    return this.shadowRoot.querySelector('slot[name="nav"]').assignedElements();
  }
  getAllPanels() {
    return [...this.body.assignedElements()].filter((C) => C.tagName.toLowerCase() === "sl-tab-panel");
  }
  getActiveTab() {
    return this.tabs.find((C) => C.active);
  }
  handleClick(C) {
    const A = C.target.closest("sl-tab");
    (A == null ? void 0 : A.closest("sl-tab-group")) === this && A !== null && this.setActiveTab(A, { scrollBehavior: "smooth" });
  }
  handleKeyDown(C) {
    const A = C.target.closest("sl-tab");
    if ((A == null ? void 0 : A.closest("sl-tab-group")) === this && (["Enter", " "].includes(C.key) && A !== null && (this.setActiveTab(A, { scrollBehavior: "smooth" }), C.preventDefault()), ["ArrowLeft", "ArrowRight", "ArrowUp", "ArrowDown", "Home", "End"].includes(C.key))) {
      const X = this.tabs.find((oe) => oe.matches(":focus")), J = this.matches(":dir(rtl)");
      let te = null;
      if ((X == null ? void 0 : X.tagName.toLowerCase()) === "sl-tab") {
        if (C.key === "Home")
          te = this.focusableTabs[0];
        else if (C.key === "End")
          te = this.focusableTabs[this.focusableTabs.length - 1];
        else if (["top", "bottom"].includes(this.placement) && C.key === (J ? "ArrowRight" : "ArrowLeft") || ["start", "end"].includes(this.placement) && C.key === "ArrowUp") {
          const oe = this.tabs.findIndex((ne) => ne === X);
          te = this.findNextFocusableTab(oe, "backward");
        } else if (["top", "bottom"].includes(this.placement) && C.key === (J ? "ArrowLeft" : "ArrowRight") || ["start", "end"].includes(this.placement) && C.key === "ArrowDown") {
          const oe = this.tabs.findIndex((ne) => ne === X);
          te = this.findNextFocusableTab(oe, "forward");
        }
        if (!te)
          return;
        te.tabIndex = 0, te.focus({ preventScroll: !0 }), this.activation === "auto" ? this.setActiveTab(te, { scrollBehavior: "smooth" }) : this.tabs.forEach((oe) => {
          oe.tabIndex = oe === te ? 0 : -1;
        }), ["top", "bottom"].includes(this.placement) && scrollIntoView(te, this.nav, "horizontal"), C.preventDefault();
      }
    }
  }
  handleScrollToStart() {
    this.nav.scroll({
      left: this.localize.dir() === "rtl" ? this.nav.scrollLeft + this.nav.clientWidth : this.nav.scrollLeft - this.nav.clientWidth,
      behavior: "smooth"
    });
  }
  handleScrollToEnd() {
    this.nav.scroll({
      left: this.localize.dir() === "rtl" ? this.nav.scrollLeft - this.nav.clientWidth : this.nav.scrollLeft + this.nav.clientWidth,
      behavior: "smooth"
    });
  }
  setActiveTab(C, L) {
    if (L = __spreadValues({
      emitEvents: !0,
      scrollBehavior: "auto"
    }, L), C !== this.activeTab && !C.disabled) {
      const A = this.activeTab;
      this.activeTab = C, this.tabs.forEach((W) => {
        W.active = W === this.activeTab, W.tabIndex = W === this.activeTab ? 0 : -1;
      }), this.panels.forEach((W) => {
        var X;
        return W.active = W.name === ((X = this.activeTab) == null ? void 0 : X.panel);
      }), this.syncIndicator(), ["top", "bottom"].includes(this.placement) && scrollIntoView(this.activeTab, this.nav, "horizontal", L.scrollBehavior), L.emitEvents && (A && this.emit("sl-tab-hide", { detail: { name: A.panel } }), this.emit("sl-tab-show", { detail: { name: this.activeTab.panel } }));
    }
  }
  setAriaLabels() {
    this.tabs.forEach((C) => {
      const L = this.panels.find((A) => A.name === C.panel);
      L && (C.setAttribute("aria-controls", L.getAttribute("id")), L.setAttribute("aria-labelledby", C.getAttribute("id")));
    });
  }
  repositionIndicator() {
    const C = this.getActiveTab();
    if (!C)
      return;
    const L = C.clientWidth, A = C.clientHeight, W = this.matches(":dir(rtl)"), X = this.getAllTabs(), te = X.slice(0, X.indexOf(C)).reduce(
      (oe, ne) => ({
        left: oe.left + ne.clientWidth,
        top: oe.top + ne.clientHeight
      }),
      { left: 0, top: 0 }
    );
    switch (this.placement) {
      case "top":
      case "bottom":
        this.indicator.style.width = `${L}px`, this.indicator.style.height = "auto", this.indicator.style.translate = W ? `${-1 * te.left}px` : `${te.left}px`;
        break;
      case "start":
      case "end":
        this.indicator.style.width = "auto", this.indicator.style.height = `${A}px`, this.indicator.style.translate = `0 ${te.top}px`;
        break;
    }
  }
  // This stores tabs and panels so we can refer to a cache instead of calling querySelectorAll() multiple times.
  syncTabsAndPanels() {
    this.tabs = this.getAllTabs(), this.focusableTabs = this.tabs.filter((C) => !C.disabled), this.panels = this.getAllPanels(), this.syncIndicator(), this.updateComplete.then(() => this.updateScrollControls());
  }
  findNextFocusableTab(C, L) {
    let A = null;
    const W = L === "forward" ? 1 : -1;
    let X = C + W;
    for (; C < this.tabs.length; ) {
      if (A = this.tabs[X] || null, A === null) {
        L === "forward" ? A = this.focusableTabs[0] : A = this.focusableTabs[this.focusableTabs.length - 1];
        break;
      }
      if (!A.disabled)
        break;
      X += W;
    }
    return A;
  }
  updateScrollControls() {
    this.noScrollControls ? this.hasScrollControls = !1 : this.hasScrollControls = ["top", "bottom"].includes(this.placement) && this.nav.scrollWidth > this.nav.clientWidth + 1;
  }
  syncIndicator() {
    this.getActiveTab() ? (this.indicator.style.display = "block", this.repositionIndicator()) : this.indicator.style.display = "none";
  }
  /** Shows the specified tab panel. */
  show(C) {
    const L = this.tabs.find((A) => A.panel === C);
    L && this.setActiveTab(L, { scrollBehavior: "smooth" });
  }
  render() {
    const C = this.matches(":dir(rtl)");
    return ke$1`
      <div
        part="base"
        class=${Rt({
      "tab-group": !0,
      "tab-group--top": this.placement === "top",
      "tab-group--bottom": this.placement === "bottom",
      "tab-group--start": this.placement === "start",
      "tab-group--end": this.placement === "end",
      "tab-group--rtl": this.localize.dir() === "rtl",
      "tab-group--has-scroll-controls": this.hasScrollControls
    })}
        @click=${this.handleClick}
        @keydown=${this.handleKeyDown}
      >
        <div class="tab-group__nav-container" part="nav">
          ${this.hasScrollControls ? ke$1`
                <sl-icon-button
                  part="scroll-button scroll-button--start"
                  exportparts="base:scroll-button__base"
                  class="tab-group__scroll-button tab-group__scroll-button--start"
                  name=${C ? "chevron-right" : "chevron-left"}
                  library="system"
                  label=${this.localize.term("scrollToStart")}
                  @click=${this.handleScrollToStart}
                ></sl-icon-button>
              ` : ""}

          <div class="tab-group__nav">
            <div part="tabs" class="tab-group__tabs" role="tablist">
              <div part="active-tab-indicator" class="tab-group__indicator"></div>
              <slot name="nav" @slotchange=${this.syncTabsAndPanels}></slot>
            </div>
          </div>

          ${this.hasScrollControls ? ke$1`
                <sl-icon-button
                  part="scroll-button scroll-button--end"
                  exportparts="base:scroll-button__base"
                  class="tab-group__scroll-button tab-group__scroll-button--end"
                  name=${C ? "chevron-left" : "chevron-right"}
                  library="system"
                  label=${this.localize.term("scrollToEnd")}
                  @click=${this.handleScrollToEnd}
                ></sl-icon-button>
              ` : ""}
        </div>

        <slot part="body" class="tab-group__body" @slotchange=${this.syncTabsAndPanels}></slot>
      </div>
    `;
  }
};
SlTabGroup.styles = [component_styles_default, tab_group_styles_default];
SlTabGroup.dependencies = { "sl-icon-button": SlIconButton };
__decorateClass$e([
  e$6(".tab-group")
], SlTabGroup.prototype, "tabGroup", 2);
__decorateClass$e([
  e$6(".tab-group__body")
], SlTabGroup.prototype, "body", 2);
__decorateClass$e([
  e$6(".tab-group__nav")
], SlTabGroup.prototype, "nav", 2);
__decorateClass$e([
  e$6(".tab-group__indicator")
], SlTabGroup.prototype, "indicator", 2);
__decorateClass$e([
  r$3()
], SlTabGroup.prototype, "hasScrollControls", 2);
__decorateClass$e([
  n$1()
], SlTabGroup.prototype, "placement", 2);
__decorateClass$e([
  n$1()
], SlTabGroup.prototype, "activation", 2);
__decorateClass$e([
  n$1({ attribute: "no-scroll-controls", type: Boolean })
], SlTabGroup.prototype, "noScrollControls", 2);
__decorateClass$e([
  watch("noScrollControls", { waitUntilFirstUpdate: !0 })
], SlTabGroup.prototype, "updateScrollControls", 1);
__decorateClass$e([
  watch("placement", { waitUntilFirstUpdate: !0 })
], SlTabGroup.prototype, "syncIndicator", 1);
SlTabGroup.define("sl-tab-group");
SlSpinner.define("sl-spinner");
var split_panel_styles_default = i$5`
  :host {
    --divider-width: 4px;
    --divider-hit-area: 12px;
    --min: 0%;
    --max: 100%;

    display: grid;
  }

  .start,
  .end {
    overflow: hidden;
  }

  .divider {
    flex: 0 0 var(--divider-width);
    display: flex;
    position: relative;
    align-items: center;
    justify-content: center;
    background-color: var(--sl-color-neutral-200);
    color: var(--sl-color-neutral-900);
    z-index: 1;
  }

  .divider:focus {
    outline: none;
  }

  :host(:not([disabled])) .divider:focus-visible {
    background-color: var(--sl-color-primary-600);
    color: var(--sl-color-neutral-0);
  }

  :host([disabled]) .divider {
    cursor: not-allowed;
  }

  /* Horizontal */
  :host(:not([vertical], [disabled])) .divider {
    cursor: col-resize;
  }

  :host(:not([vertical])) .divider::after {
    display: flex;
    content: '';
    position: absolute;
    height: 100%;
    left: calc(var(--divider-hit-area) / -2 + var(--divider-width) / 2);
    width: var(--divider-hit-area);
  }

  /* Vertical */
  :host([vertical]) {
    flex-direction: column;
  }

  :host([vertical]:not([disabled])) .divider {
    cursor: row-resize;
  }

  :host([vertical]) .divider::after {
    content: '';
    position: absolute;
    width: 100%;
    top: calc(var(--divider-hit-area) / -2 + var(--divider-width) / 2);
    height: var(--divider-hit-area);
  }

  @media (forced-colors: active) {
    .divider {
      outline: solid 1px transparent;
    }
  }
`;
function drag(C, L) {
  function A(X) {
    const J = C.getBoundingClientRect(), te = C.ownerDocument.defaultView, oe = J.left + te.scrollX, ne = J.top + te.scrollY, re = X.pageX - oe, ce = X.pageY - ne;
    L != null && L.onMove && L.onMove(re, ce);
  }
  function W() {
    document.removeEventListener("pointermove", A), document.removeEventListener("pointerup", W), L != null && L.onStop && L.onStop();
  }
  document.addEventListener("pointermove", A, { passive: !0 }), document.addEventListener("pointerup", W), (L == null ? void 0 : L.initialEvent) instanceof PointerEvent && A(L.initialEvent);
}
var SlSplitPanel = class extends ShoelaceElement {
  constructor() {
    super(...arguments), this.localize = new LocalizeController(this), this.position = 50, this.vertical = !1, this.disabled = !1, this.snapThreshold = 12;
  }
  connectedCallback() {
    super.connectedCallback(), this.resizeObserver = new ResizeObserver((C) => this.handleResize(C)), this.updateComplete.then(() => this.resizeObserver.observe(this)), this.detectSize(), this.cachedPositionInPixels = this.percentageToPixels(this.position);
  }
  disconnectedCallback() {
    super.disconnectedCallback(), this.resizeObserver.unobserve(this);
  }
  detectSize() {
    const { width: C, height: L } = this.getBoundingClientRect();
    this.size = this.vertical ? L : C;
  }
  percentageToPixels(C) {
    return this.size * (C / 100);
  }
  pixelsToPercentage(C) {
    return C / this.size * 100;
  }
  handleDrag(C) {
    const L = this.matches(":dir(rtl)");
    this.disabled || (C.cancelable && C.preventDefault(), drag(this, {
      onMove: (A, W) => {
        let X = this.vertical ? W : A;
        this.primary === "end" && (X = this.size - X), this.snap && this.snap.split(" ").forEach((te) => {
          let oe;
          te.endsWith("%") ? oe = this.size * (parseFloat(te) / 100) : oe = parseFloat(te), L && !this.vertical && (oe = this.size - oe), X >= oe - this.snapThreshold && X <= oe + this.snapThreshold && (X = oe);
        }), this.position = clamp(this.pixelsToPercentage(X), 0, 100);
      },
      initialEvent: C
    }));
  }
  handleKeyDown(C) {
    if (!this.disabled && ["ArrowLeft", "ArrowRight", "ArrowUp", "ArrowDown", "Home", "End"].includes(C.key)) {
      let L = this.position;
      const A = (C.shiftKey ? 10 : 1) * (this.primary === "end" ? -1 : 1);
      C.preventDefault(), (C.key === "ArrowLeft" && !this.vertical || C.key === "ArrowUp" && this.vertical) && (L -= A), (C.key === "ArrowRight" && !this.vertical || C.key === "ArrowDown" && this.vertical) && (L += A), C.key === "Home" && (L = this.primary === "end" ? 100 : 0), C.key === "End" && (L = this.primary === "end" ? 0 : 100), this.position = clamp(L, 0, 100);
    }
  }
  handleResize(C) {
    const { width: L, height: A } = C[0].contentRect;
    this.size = this.vertical ? A : L, (isNaN(this.cachedPositionInPixels) || this.position === 1 / 0) && (this.cachedPositionInPixels = Number(this.getAttribute("position-in-pixels")), this.positionInPixels = Number(this.getAttribute("position-in-pixels")), this.position = this.pixelsToPercentage(this.positionInPixels)), this.primary && (this.position = this.pixelsToPercentage(this.cachedPositionInPixels));
  }
  handlePositionChange() {
    this.cachedPositionInPixels = this.percentageToPixels(this.position), this.positionInPixels = this.percentageToPixels(this.position), this.emit("sl-reposition");
  }
  handlePositionInPixelsChange() {
    this.position = this.pixelsToPercentage(this.positionInPixels);
  }
  handleVerticalChange() {
    this.detectSize();
  }
  render() {
    const C = this.vertical ? "gridTemplateRows" : "gridTemplateColumns", L = this.vertical ? "gridTemplateColumns" : "gridTemplateRows", A = this.matches(":dir(rtl)"), W = `
      clamp(
        0%,
        clamp(
          var(--min),
          ${this.position}% - var(--divider-width) / 2,
          var(--max)
        ),
        calc(100% - var(--divider-width))
      )
    `, X = "auto";
    return this.primary === "end" ? A && !this.vertical ? this.style[C] = `${W} var(--divider-width) ${X}` : this.style[C] = `${X} var(--divider-width) ${W}` : A && !this.vertical ? this.style[C] = `${X} var(--divider-width) ${W}` : this.style[C] = `${W} var(--divider-width) ${X}`, this.style[L] = "", ke$1`
      <slot name="start" part="panel start" class="start"></slot>

      <div
        part="divider"
        class="divider"
        tabindex=${to(this.disabled ? void 0 : "0")}
        role="separator"
        aria-valuenow=${this.position}
        aria-valuemin="0"
        aria-valuemax="100"
        aria-label=${this.localize.term("resize")}
        @keydown=${this.handleKeyDown}
        @mousedown=${this.handleDrag}
        @touchstart=${this.handleDrag}
      >
        <slot name="divider"></slot>
      </div>

      <slot name="end" part="panel end" class="end"></slot>
    `;
  }
};
SlSplitPanel.styles = [component_styles_default, split_panel_styles_default];
__decorateClass$e([
  e$6(".divider")
], SlSplitPanel.prototype, "divider", 2);
__decorateClass$e([
  n$1({ type: Number, reflect: !0 })
], SlSplitPanel.prototype, "position", 2);
__decorateClass$e([
  n$1({ attribute: "position-in-pixels", type: Number })
], SlSplitPanel.prototype, "positionInPixels", 2);
__decorateClass$e([
  n$1({ type: Boolean, reflect: !0 })
], SlSplitPanel.prototype, "vertical", 2);
__decorateClass$e([
  n$1({ type: Boolean, reflect: !0 })
], SlSplitPanel.prototype, "disabled", 2);
__decorateClass$e([
  n$1()
], SlSplitPanel.prototype, "primary", 2);
__decorateClass$e([
  n$1()
], SlSplitPanel.prototype, "snap", 2);
__decorateClass$e([
  n$1({ type: Number, attribute: "snap-threshold" })
], SlSplitPanel.prototype, "snapThreshold", 2);
__decorateClass$e([
  watch("position")
], SlSplitPanel.prototype, "handlePositionChange", 1);
__decorateClass$e([
  watch("positionInPixels")
], SlSplitPanel.prototype, "handlePositionInPixelsChange", 1);
__decorateClass$e([
  watch("vertical")
], SlSplitPanel.prototype, "handleVerticalChange", 1);
SlSplitPanel.define("sl-split-panel");
var switch_styles_default = i$5`
  :host {
    display: inline-block;
  }

  :host([size='small']) {
    --height: var(--sl-toggle-size-small);
    --thumb-size: calc(var(--sl-toggle-size-small) + 4px);
    --width: calc(var(--height) * 2);

    font-size: var(--sl-input-font-size-small);
  }

  :host([size='medium']) {
    --height: var(--sl-toggle-size-medium);
    --thumb-size: calc(var(--sl-toggle-size-medium) + 4px);
    --width: calc(var(--height) * 2);

    font-size: var(--sl-input-font-size-medium);
  }

  :host([size='large']) {
    --height: var(--sl-toggle-size-large);
    --thumb-size: calc(var(--sl-toggle-size-large) + 4px);
    --width: calc(var(--height) * 2);

    font-size: var(--sl-input-font-size-large);
  }

  .switch {
    position: relative;
    display: inline-flex;
    align-items: center;
    font-family: var(--sl-input-font-family);
    font-size: inherit;
    font-weight: var(--sl-input-font-weight);
    color: var(--sl-input-label-color);
    vertical-align: middle;
    cursor: pointer;
  }

  .switch__control {
    flex: 0 0 auto;
    position: relative;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    width: var(--width);
    height: var(--height);
    background-color: var(--sl-color-neutral-400);
    border: solid var(--sl-input-border-width) var(--sl-color-neutral-400);
    border-radius: var(--height);
    transition:
      var(--sl-transition-fast) border-color,
      var(--sl-transition-fast) background-color;
  }

  .switch__control .switch__thumb {
    width: var(--thumb-size);
    height: var(--thumb-size);
    background-color: var(--sl-color-neutral-0);
    border-radius: 50%;
    border: solid var(--sl-input-border-width) var(--sl-color-neutral-400);
    translate: calc((var(--width) - var(--height)) / -2);
    transition:
      var(--sl-transition-fast) translate ease,
      var(--sl-transition-fast) background-color,
      var(--sl-transition-fast) border-color,
      var(--sl-transition-fast) box-shadow;
  }

  .switch__input {
    position: absolute;
    opacity: 0;
    padding: 0;
    margin: 0;
    pointer-events: none;
  }

  /* Hover */
  .switch:not(.switch--checked):not(.switch--disabled) .switch__control:hover {
    background-color: var(--sl-color-neutral-400);
    border-color: var(--sl-color-neutral-400);
  }

  .switch:not(.switch--checked):not(.switch--disabled) .switch__control:hover .switch__thumb {
    background-color: var(--sl-color-neutral-0);
    border-color: var(--sl-color-neutral-400);
  }

  /* Focus */
  .switch:not(.switch--checked):not(.switch--disabled) .switch__input:focus-visible ~ .switch__control {
    background-color: var(--sl-color-neutral-400);
    border-color: var(--sl-color-neutral-400);
  }

  .switch:not(.switch--checked):not(.switch--disabled) .switch__input:focus-visible ~ .switch__control .switch__thumb {
    background-color: var(--sl-color-neutral-0);
    border-color: var(--sl-color-primary-600);
    outline: var(--sl-focus-ring);
    outline-offset: var(--sl-focus-ring-offset);
  }

  /* Checked */
  .switch--checked .switch__control {
    background-color: var(--sl-color-primary-600);
    border-color: var(--sl-color-primary-600);
  }

  .switch--checked .switch__control .switch__thumb {
    background-color: var(--sl-color-neutral-0);
    border-color: var(--sl-color-primary-600);
    translate: calc((var(--width) - var(--height)) / 2);
  }

  /* Checked + hover */
  .switch.switch--checked:not(.switch--disabled) .switch__control:hover {
    background-color: var(--sl-color-primary-600);
    border-color: var(--sl-color-primary-600);
  }

  .switch.switch--checked:not(.switch--disabled) .switch__control:hover .switch__thumb {
    background-color: var(--sl-color-neutral-0);
    border-color: var(--sl-color-primary-600);
  }

  /* Checked + focus */
  .switch.switch--checked:not(.switch--disabled) .switch__input:focus-visible ~ .switch__control {
    background-color: var(--sl-color-primary-600);
    border-color: var(--sl-color-primary-600);
  }

  .switch.switch--checked:not(.switch--disabled) .switch__input:focus-visible ~ .switch__control .switch__thumb {
    background-color: var(--sl-color-neutral-0);
    border-color: var(--sl-color-primary-600);
    outline: var(--sl-focus-ring);
    outline-offset: var(--sl-focus-ring-offset);
  }

  /* Disabled */
  .switch--disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }

  .switch__label {
    display: inline-block;
    line-height: var(--height);
    margin-inline-start: 0.5em;
    user-select: none;
    -webkit-user-select: none;
  }

  :host([required]) .switch__label::after {
    content: var(--sl-input-required-content);
    color: var(--sl-input-required-content-color);
    margin-inline-start: var(--sl-input-required-content-offset);
  }

  @media (forced-colors: active) {
    .switch.switch--checked:not(.switch--disabled) .switch__control:hover .switch__thumb,
    .switch--checked .switch__control .switch__thumb {
      background-color: ButtonText;
    }
  }
`, SlSwitch = class extends ShoelaceElement {
  constructor() {
    super(...arguments), this.formControlController = new FormControlController(this, {
      value: (C) => C.checked ? C.value || "on" : void 0,
      defaultValue: (C) => C.defaultChecked,
      setValue: (C, L) => C.checked = L
    }), this.hasSlotController = new HasSlotController(this, "help-text"), this.hasFocus = !1, this.title = "", this.name = "", this.size = "medium", this.disabled = !1, this.checked = !1, this.defaultChecked = !1, this.form = "", this.required = !1, this.helpText = "";
  }
  /** Gets the validity state object */
  get validity() {
    return this.input.validity;
  }
  /** Gets the validation message */
  get validationMessage() {
    return this.input.validationMessage;
  }
  firstUpdated() {
    this.formControlController.updateValidity();
  }
  handleBlur() {
    this.hasFocus = !1, this.emit("sl-blur");
  }
  handleInput() {
    this.emit("sl-input");
  }
  handleInvalid(C) {
    this.formControlController.setValidity(!1), this.formControlController.emitInvalidEvent(C);
  }
  handleClick() {
    this.checked = !this.checked, this.emit("sl-change");
  }
  handleFocus() {
    this.hasFocus = !0, this.emit("sl-focus");
  }
  handleKeyDown(C) {
    C.key === "ArrowLeft" && (C.preventDefault(), this.checked = !1, this.emit("sl-change"), this.emit("sl-input")), C.key === "ArrowRight" && (C.preventDefault(), this.checked = !0, this.emit("sl-change"), this.emit("sl-input"));
  }
  handleCheckedChange() {
    this.input.checked = this.checked, this.formControlController.updateValidity();
  }
  handleDisabledChange() {
    this.formControlController.setValidity(!0);
  }
  /** Simulates a click on the switch. */
  click() {
    this.input.click();
  }
  /** Sets focus on the switch. */
  focus(C) {
    this.input.focus(C);
  }
  /** Removes focus from the switch. */
  blur() {
    this.input.blur();
  }
  /** Checks for validity but does not show a validation message. Returns `true` when valid and `false` when invalid. */
  checkValidity() {
    return this.input.checkValidity();
  }
  /** Gets the associated form, if one exists. */
  getForm() {
    return this.formControlController.getForm();
  }
  /** Checks for validity and shows the browser's validation message if the control is invalid. */
  reportValidity() {
    return this.input.reportValidity();
  }
  /** Sets a custom validation message. Pass an empty string to restore validity. */
  setCustomValidity(C) {
    this.input.setCustomValidity(C), this.formControlController.updateValidity();
  }
  render() {
    const C = this.hasSlotController.test("help-text"), L = this.helpText ? !0 : !!C;
    return ke$1`
      <div
        class=${Rt({
      "form-control": !0,
      "form-control--small": this.size === "small",
      "form-control--medium": this.size === "medium",
      "form-control--large": this.size === "large",
      "form-control--has-help-text": L
    })}
      >
        <label
          part="base"
          class=${Rt({
      switch: !0,
      "switch--checked": this.checked,
      "switch--disabled": this.disabled,
      "switch--focused": this.hasFocus,
      "switch--small": this.size === "small",
      "switch--medium": this.size === "medium",
      "switch--large": this.size === "large"
    })}
        >
          <input
            class="switch__input"
            type="checkbox"
            title=${this.title}
            name=${this.name}
            value=${to(this.value)}
            .checked=${Ft(this.checked)}
            .disabled=${this.disabled}
            .required=${this.required}
            role="switch"
            aria-checked=${this.checked ? "true" : "false"}
            aria-describedby="help-text"
            @click=${this.handleClick}
            @input=${this.handleInput}
            @invalid=${this.handleInvalid}
            @blur=${this.handleBlur}
            @focus=${this.handleFocus}
            @keydown=${this.handleKeyDown}
          />

          <span part="control" class="switch__control">
            <span part="thumb" class="switch__thumb"></span>
          </span>

          <div part="label" class="switch__label">
            <slot></slot>
          </div>
        </label>

        <div
          aria-hidden=${L ? "false" : "true"}
          class="form-control__help-text"
          id="help-text"
          part="form-control-help-text"
        >
          <slot name="help-text">${this.helpText}</slot>
        </div>
      </div>
    `;
  }
};
SlSwitch.styles = [component_styles_default, form_control_styles_default, switch_styles_default];
__decorateClass$e([
  e$6('input[type="checkbox"]')
], SlSwitch.prototype, "input", 2);
__decorateClass$e([
  r$3()
], SlSwitch.prototype, "hasFocus", 2);
__decorateClass$e([
  n$1()
], SlSwitch.prototype, "title", 2);
__decorateClass$e([
  n$1()
], SlSwitch.prototype, "name", 2);
__decorateClass$e([
  n$1()
], SlSwitch.prototype, "value", 2);
__decorateClass$e([
  n$1({ reflect: !0 })
], SlSwitch.prototype, "size", 2);
__decorateClass$e([
  n$1({ type: Boolean, reflect: !0 })
], SlSwitch.prototype, "disabled", 2);
__decorateClass$e([
  n$1({ type: Boolean, reflect: !0 })
], SlSwitch.prototype, "checked", 2);
__decorateClass$e([
  defaultValue("checked")
], SlSwitch.prototype, "defaultChecked", 2);
__decorateClass$e([
  n$1({ reflect: !0 })
], SlSwitch.prototype, "form", 2);
__decorateClass$e([
  n$1({ type: Boolean, reflect: !0 })
], SlSwitch.prototype, "required", 2);
__decorateClass$e([
  n$1({ attribute: "help-text" })
], SlSwitch.prototype, "helpText", 2);
__decorateClass$e([
  watch("checked", { waitUntilFirstUpdate: !0 })
], SlSwitch.prototype, "handleCheckedChange", 1);
__decorateClass$e([
  watch("disabled", { waitUntilFirstUpdate: !0 })
], SlSwitch.prototype, "handleDisabledChange", 1);
SlSwitch.define("sl-switch");
var resize_observer_styles_default = i$5`
  :host {
    display: contents;
  }
`, SlResizeObserver = class extends ShoelaceElement {
  constructor() {
    super(...arguments), this.observedElements = [], this.disabled = !1;
  }
  connectedCallback() {
    super.connectedCallback(), this.resizeObserver = new ResizeObserver((C) => {
      this.emit("sl-resize", { detail: { entries: C } });
    }), this.disabled || this.startObserver();
  }
  disconnectedCallback() {
    super.disconnectedCallback(), this.stopObserver();
  }
  handleSlotChange() {
    this.disabled || this.startObserver();
  }
  startObserver() {
    const C = this.shadowRoot.querySelector("slot");
    if (C !== null) {
      const L = C.assignedElements({ flatten: !0 });
      this.observedElements.forEach((A) => this.resizeObserver.unobserve(A)), this.observedElements = [], L.forEach((A) => {
        this.resizeObserver.observe(A), this.observedElements.push(A);
      });
    }
  }
  stopObserver() {
    this.resizeObserver.disconnect();
  }
  handleDisabledChange() {
    this.disabled ? this.stopObserver() : this.startObserver();
  }
  render() {
    return ke$1` <slot @slotchange=${this.handleSlotChange}></slot> `;
  }
};
SlResizeObserver.styles = [component_styles_default, resize_observer_styles_default];
__decorateClass$e([
  n$1({ type: Boolean, reflect: !0 })
], SlResizeObserver.prototype, "disabled", 2);
__decorateClass$e([
  watch("disabled", { waitUntilFirstUpdate: !0 })
], SlResizeObserver.prototype, "handleDisabledChange", 1);
SlResizeObserver.define("sl-resize-observer");
var select_styles_default = i$5`
  :host {
    display: block;
  }

  /** The popup */
  .select {
    flex: 1 1 auto;
    display: inline-flex;
    width: 100%;
    position: relative;
    vertical-align: middle;
  }

  .select::part(popup) {
    z-index: var(--sl-z-index-dropdown);
  }

  .select[data-current-placement^='top']::part(popup) {
    transform-origin: bottom;
  }

  .select[data-current-placement^='bottom']::part(popup) {
    transform-origin: top;
  }

  /* Combobox */
  .select__combobox {
    flex: 1;
    display: flex;
    width: 100%;
    min-width: 0;
    position: relative;
    align-items: center;
    justify-content: start;
    font-family: var(--sl-input-font-family);
    font-weight: var(--sl-input-font-weight);
    letter-spacing: var(--sl-input-letter-spacing);
    vertical-align: middle;
    overflow: hidden;
    cursor: pointer;
    transition:
      var(--sl-transition-fast) color,
      var(--sl-transition-fast) border,
      var(--sl-transition-fast) box-shadow,
      var(--sl-transition-fast) background-color;
  }

  .select__display-input {
    position: relative;
    width: 100%;
    font: inherit;
    border: none;
    background: none;
    color: var(--sl-input-color);
    cursor: inherit;
    overflow: hidden;
    padding: 0;
    margin: 0;
    -webkit-appearance: none;
  }

  .select__display-input::placeholder {
    color: var(--sl-input-placeholder-color);
  }

  .select:not(.select--disabled):hover .select__display-input {
    color: var(--sl-input-color-hover);
  }

  .select__display-input:focus {
    outline: none;
  }

  /* Visually hide the display input when multiple is enabled */
  .select--multiple:not(.select--placeholder-visible) .select__display-input {
    position: absolute;
    z-index: -1;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    opacity: 0;
  }

  .select__value-input {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    padding: 0;
    margin: 0;
    opacity: 0;
    z-index: -1;
  }

  .select__tags {
    display: flex;
    flex: 1;
    align-items: center;
    flex-wrap: wrap;
    margin-inline-start: var(--sl-spacing-2x-small);
  }

  .select__tags::slotted(sl-tag) {
    cursor: pointer !important;
  }

  .select--disabled .select__tags,
  .select--disabled .select__tags::slotted(sl-tag) {
    cursor: not-allowed !important;
  }

  /* Standard selects */
  .select--standard .select__combobox {
    background-color: var(--sl-input-background-color);
    border: solid var(--sl-input-border-width) var(--sl-input-border-color);
  }

  .select--standard.select--disabled .select__combobox {
    background-color: var(--sl-input-background-color-disabled);
    border-color: var(--sl-input-border-color-disabled);
    color: var(--sl-input-color-disabled);
    opacity: 0.5;
    cursor: not-allowed;
    outline: none;
  }

  .select--standard:not(.select--disabled).select--open .select__combobox,
  .select--standard:not(.select--disabled).select--focused .select__combobox {
    background-color: var(--sl-input-background-color-focus);
    border-color: var(--sl-input-border-color-focus);
    box-shadow: 0 0 0 var(--sl-focus-ring-width) var(--sl-input-focus-ring-color);
  }

  /* Filled selects */
  .select--filled .select__combobox {
    border: none;
    background-color: var(--sl-input-filled-background-color);
    color: var(--sl-input-color);
  }

  .select--filled:hover:not(.select--disabled) .select__combobox {
    background-color: var(--sl-input-filled-background-color-hover);
  }

  .select--filled.select--disabled .select__combobox {
    background-color: var(--sl-input-filled-background-color-disabled);
    opacity: 0.5;
    cursor: not-allowed;
  }

  .select--filled:not(.select--disabled).select--open .select__combobox,
  .select--filled:not(.select--disabled).select--focused .select__combobox {
    background-color: var(--sl-input-filled-background-color-focus);
    outline: var(--sl-focus-ring);
  }

  /* Sizes */
  .select--small .select__combobox {
    border-radius: var(--sl-input-border-radius-small);
    font-size: var(--sl-input-font-size-small);
    min-height: var(--sl-input-height-small);
    padding-block: 0;
    padding-inline: var(--sl-input-spacing-small);
  }

  .select--small .select__clear {
    margin-inline-start: var(--sl-input-spacing-small);
  }

  .select--small .select__prefix::slotted(*) {
    margin-inline-end: var(--sl-input-spacing-small);
  }

  .select--small.select--multiple:not(.select--placeholder-visible) .select__combobox {
    padding-block: 2px;
    padding-inline-start: 0;
  }

  .select--small .select__tags {
    gap: 2px;
  }

  .select--medium .select__combobox {
    border-radius: var(--sl-input-border-radius-medium);
    font-size: var(--sl-input-font-size-medium);
    min-height: var(--sl-input-height-medium);
    padding-block: 0;
    padding-inline: var(--sl-input-spacing-medium);
  }

  .select--medium .select__clear {
    margin-inline-start: var(--sl-input-spacing-medium);
  }

  .select--medium .select__prefix::slotted(*) {
    margin-inline-end: var(--sl-input-spacing-medium);
  }

  .select--medium.select--multiple:not(.select--placeholder-visible) .select__combobox {
    padding-inline-start: 0;
    padding-block: 3px;
  }

  .select--medium .select__tags {
    gap: 3px;
  }

  .select--large .select__combobox {
    border-radius: var(--sl-input-border-radius-large);
    font-size: var(--sl-input-font-size-large);
    min-height: var(--sl-input-height-large);
    padding-block: 0;
    padding-inline: var(--sl-input-spacing-large);
  }

  .select--large .select__clear {
    margin-inline-start: var(--sl-input-spacing-large);
  }

  .select--large .select__prefix::slotted(*) {
    margin-inline-end: var(--sl-input-spacing-large);
  }

  .select--large.select--multiple:not(.select--placeholder-visible) .select__combobox {
    padding-inline-start: 0;
    padding-block: 4px;
  }

  .select--large .select__tags {
    gap: 4px;
  }

  /* Pills */
  .select--pill.select--small .select__combobox {
    border-radius: var(--sl-input-height-small);
  }

  .select--pill.select--medium .select__combobox {
    border-radius: var(--sl-input-height-medium);
  }

  .select--pill.select--large .select__combobox {
    border-radius: var(--sl-input-height-large);
  }

  /* Prefix */
  .select__prefix {
    flex: 0;
    display: inline-flex;
    align-items: center;
    color: var(--sl-input-placeholder-color);
  }

  /* Suffix */
  .select__suffix {
    flex: 0;
    display: inline-flex;
    align-items: center;
    color: var(--sl-input-placeholder-color);
  }

  /* Clear button */
  .select__clear {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    font-size: inherit;
    color: var(--sl-input-icon-color);
    border: none;
    background: none;
    padding: 0;
    transition: var(--sl-transition-fast) color;
    cursor: pointer;
  }

  .select__clear:hover {
    color: var(--sl-input-icon-color-hover);
  }

  .select__clear:focus {
    outline: none;
  }

  /* Expand icon */
  .select__expand-icon {
    flex: 0 0 auto;
    display: flex;
    align-items: center;
    transition: var(--sl-transition-medium) rotate ease;
    rotate: 0;
    margin-inline-start: var(--sl-spacing-small);
  }

  .select--open .select__expand-icon {
    rotate: -180deg;
  }

  /* Listbox */
  .select__listbox {
    display: block;
    position: relative;
    font-family: var(--sl-font-sans);
    font-size: var(--sl-font-size-medium);
    font-weight: var(--sl-font-weight-normal);
    box-shadow: var(--sl-shadow-large);
    background: var(--sl-panel-background-color);
    border: solid var(--sl-panel-border-width) var(--sl-panel-border-color);
    border-radius: var(--sl-border-radius-medium);
    padding-block: var(--sl-spacing-x-small);
    padding-inline: 0;
    overflow: auto;
    overscroll-behavior: none;

    /* Make sure it adheres to the popup's auto size */
    max-width: var(--auto-size-available-width);
    max-height: var(--auto-size-available-height);
  }

  .select__listbox ::slotted(sl-divider) {
    --spacing: var(--sl-spacing-x-small);
  }

  .select__listbox ::slotted(small) {
    display: block;
    font-size: var(--sl-font-size-small);
    font-weight: var(--sl-font-weight-semibold);
    color: var(--sl-color-neutral-500);
    padding-block: var(--sl-spacing-2x-small);
    padding-inline: var(--sl-spacing-x-large);
  }
`;
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
class le extends i$3 {
  constructor(L) {
    if (super(L), this.it = D, L.type !== t$2.CHILD) throw Error(this.constructor.directiveName + "() can only be used in child bindings");
  }
  render(L) {
    if (L === D || L == null) return this._t = void 0, this.it = L;
    if (L === R$1) return L;
    if (typeof L != "string") throw Error(this.constructor.directiveName + "() called with a non-string value");
    if (L === this.it) return this._t;
    this.it = L;
    const A = [L];
    return A.raw = A, this._t = { _$litType$: this.constructor.resultType, strings: A, values: [] };
  }
}
le.directiveName = "unsafeHTML", le.resultType = 1;
const ae = e$4(le);
var SlSelect = class extends ShoelaceElement {
  constructor() {
    super(...arguments), this.formControlController = new FormControlController(this, {
      assumeInteractionOn: ["sl-blur", "sl-input"]
    }), this.hasSlotController = new HasSlotController(this, "help-text", "label"), this.localize = new LocalizeController(this), this.typeToSelectString = "", this.hasFocus = !1, this.displayLabel = "", this.selectedOptions = [], this.name = "", this.value = "", this.defaultValue = "", this.size = "medium", this.placeholder = "", this.multiple = !1, this.maxOptionsVisible = 3, this.disabled = !1, this.clearable = !1, this.open = !1, this.hoist = !1, this.filled = !1, this.pill = !1, this.label = "", this.placement = "bottom", this.helpText = "", this.form = "", this.required = !1, this.getTag = (C) => ke$1`
      <sl-tag
        part="tag"
        exportparts="
              base:tag__base,
              content:tag__content,
              remove-button:tag__remove-button,
              remove-button__base:tag__remove-button__base
            "
        ?pill=${this.pill}
        size=${this.size}
        removable
        @sl-remove=${(L) => this.handleTagRemove(L, C)}
      >
        ${C.getTextLabel()}
      </sl-tag>
    `, this.handleDocumentFocusIn = (C) => {
      const L = C.composedPath();
      this && !L.includes(this) && this.hide();
    }, this.handleDocumentKeyDown = (C) => {
      const L = C.target, A = L.closest(".select__clear") !== null, W = L.closest("sl-icon-button") !== null;
      if (!(A || W)) {
        if (C.key === "Escape" && this.open && !this.closeWatcher && (C.preventDefault(), C.stopPropagation(), this.hide(), this.displayInput.focus({ preventScroll: !0 })), C.key === "Enter" || C.key === " " && this.typeToSelectString === "") {
          if (C.preventDefault(), C.stopImmediatePropagation(), !this.open) {
            this.show();
            return;
          }
          this.currentOption && !this.currentOption.disabled && (this.multiple ? this.toggleOptionSelection(this.currentOption) : this.setSelectedOptions(this.currentOption), this.updateComplete.then(() => {
            this.emit("sl-input"), this.emit("sl-change");
          }), this.multiple || (this.hide(), this.displayInput.focus({ preventScroll: !0 })));
          return;
        }
        if (["ArrowUp", "ArrowDown", "Home", "End"].includes(C.key)) {
          const X = this.getAllOptions(), J = X.indexOf(this.currentOption);
          let te = Math.max(0, J);
          if (C.preventDefault(), !this.open && (this.show(), this.currentOption))
            return;
          C.key === "ArrowDown" ? (te = J + 1, te > X.length - 1 && (te = 0)) : C.key === "ArrowUp" ? (te = J - 1, te < 0 && (te = X.length - 1)) : C.key === "Home" ? te = 0 : C.key === "End" && (te = X.length - 1), this.setCurrentOption(X[te]);
        }
        if (C.key.length === 1 || C.key === "Backspace") {
          const X = this.getAllOptions();
          if (C.metaKey || C.ctrlKey || C.altKey)
            return;
          if (!this.open) {
            if (C.key === "Backspace")
              return;
            this.show();
          }
          C.stopPropagation(), C.preventDefault(), clearTimeout(this.typeToSelectTimeout), this.typeToSelectTimeout = window.setTimeout(() => this.typeToSelectString = "", 1e3), C.key === "Backspace" ? this.typeToSelectString = this.typeToSelectString.slice(0, -1) : this.typeToSelectString += C.key.toLowerCase();
          for (const J of X)
            if (J.getTextLabel().toLowerCase().startsWith(this.typeToSelectString)) {
              this.setCurrentOption(J);
              break;
            }
        }
      }
    }, this.handleDocumentMouseDown = (C) => {
      const L = C.composedPath();
      this && !L.includes(this) && this.hide();
    };
  }
  /** Gets the validity state object */
  get validity() {
    return this.valueInput.validity;
  }
  /** Gets the validation message */
  get validationMessage() {
    return this.valueInput.validationMessage;
  }
  connectedCallback() {
    super.connectedCallback(), this.open = !1;
  }
  addOpenListeners() {
    var C;
    document.addEventListener("focusin", this.handleDocumentFocusIn), document.addEventListener("keydown", this.handleDocumentKeyDown), document.addEventListener("mousedown", this.handleDocumentMouseDown), this.getRootNode() !== document && this.getRootNode().addEventListener("focusin", this.handleDocumentFocusIn), "CloseWatcher" in window && ((C = this.closeWatcher) == null || C.destroy(), this.closeWatcher = new CloseWatcher(), this.closeWatcher.onclose = () => {
      this.open && (this.hide(), this.displayInput.focus({ preventScroll: !0 }));
    });
  }
  removeOpenListeners() {
    var C;
    document.removeEventListener("focusin", this.handleDocumentFocusIn), document.removeEventListener("keydown", this.handleDocumentKeyDown), document.removeEventListener("mousedown", this.handleDocumentMouseDown), this.getRootNode() !== document && this.getRootNode().removeEventListener("focusin", this.handleDocumentFocusIn), (C = this.closeWatcher) == null || C.destroy();
  }
  handleFocus() {
    this.hasFocus = !0, this.displayInput.setSelectionRange(0, 0), this.emit("sl-focus");
  }
  handleBlur() {
    this.hasFocus = !1, this.emit("sl-blur");
  }
  handleLabelClick() {
    this.displayInput.focus();
  }
  handleComboboxMouseDown(C) {
    const A = C.composedPath().some((W) => W instanceof Element && W.tagName.toLowerCase() === "sl-icon-button");
    this.disabled || A || (C.preventDefault(), this.displayInput.focus({ preventScroll: !0 }), this.open = !this.open);
  }
  handleComboboxKeyDown(C) {
    C.key !== "Tab" && (C.stopPropagation(), this.handleDocumentKeyDown(C));
  }
  handleClearClick(C) {
    C.stopPropagation(), this.value !== "" && (this.setSelectedOptions([]), this.displayInput.focus({ preventScroll: !0 }), this.updateComplete.then(() => {
      this.emit("sl-clear"), this.emit("sl-input"), this.emit("sl-change");
    }));
  }
  handleClearMouseDown(C) {
    C.stopPropagation(), C.preventDefault();
  }
  handleOptionClick(C) {
    const A = C.target.closest("sl-option"), W = this.value;
    A && !A.disabled && (this.multiple ? this.toggleOptionSelection(A) : this.setSelectedOptions(A), this.updateComplete.then(() => this.displayInput.focus({ preventScroll: !0 })), this.value !== W && this.updateComplete.then(() => {
      this.emit("sl-input"), this.emit("sl-change");
    }), this.multiple || (this.hide(), this.displayInput.focus({ preventScroll: !0 })));
  }
  handleDefaultSlotChange() {
    const C = this.getAllOptions(), L = Array.isArray(this.value) ? this.value : [this.value], A = [];
    customElements.get("sl-option") ? (C.forEach((W) => A.push(W.value)), this.setSelectedOptions(C.filter((W) => L.includes(W.value)))) : customElements.whenDefined("sl-option").then(() => this.handleDefaultSlotChange());
  }
  handleTagRemove(C, L) {
    C.stopPropagation(), this.disabled || (this.toggleOptionSelection(L, !1), this.updateComplete.then(() => {
      this.emit("sl-input"), this.emit("sl-change");
    }));
  }
  // Gets an array of all <sl-option> elements
  getAllOptions() {
    return [...this.querySelectorAll("sl-option")];
  }
  // Gets the first <sl-option> element
  getFirstOption() {
    return this.querySelector("sl-option");
  }
  // Sets the current option, which is the option the user is currently interacting with (e.g. via keyboard). Only one
  // option may be "current" at a time.
  setCurrentOption(C) {
    this.getAllOptions().forEach((A) => {
      A.current = !1, A.tabIndex = -1;
    }), C && (this.currentOption = C, C.current = !0, C.tabIndex = 0, C.focus());
  }
  // Sets the selected option(s)
  setSelectedOptions(C) {
    const L = this.getAllOptions(), A = Array.isArray(C) ? C : [C];
    L.forEach((W) => W.selected = !1), A.length && A.forEach((W) => W.selected = !0), this.selectionChanged();
  }
  // Toggles an option's selected state
  toggleOptionSelection(C, L) {
    L === !0 || L === !1 ? C.selected = L : C.selected = !C.selected, this.selectionChanged();
  }
  // This method must be called whenever the selection changes. It will update the selected options cache, the current
  // value, and the display value
  selectionChanged() {
    var C, L, A, W;
    this.selectedOptions = this.getAllOptions().filter((X) => X.selected), this.multiple ? (this.value = this.selectedOptions.map((X) => X.value), this.placeholder && this.value.length === 0 ? this.displayLabel = "" : this.displayLabel = this.localize.term("numOptionsSelected", this.selectedOptions.length)) : (this.value = (L = (C = this.selectedOptions[0]) == null ? void 0 : C.value) != null ? L : "", this.displayLabel = (W = (A = this.selectedOptions[0]) == null ? void 0 : A.getTextLabel()) != null ? W : ""), this.updateComplete.then(() => {
      this.formControlController.updateValidity();
    });
  }
  get tags() {
    return this.selectedOptions.map((C, L) => {
      if (L < this.maxOptionsVisible || this.maxOptionsVisible <= 0) {
        const A = this.getTag(C, L);
        return ke$1`<div @sl-remove=${(W) => this.handleTagRemove(W, C)}>
          ${typeof A == "string" ? ae(A) : A}
        </div>`;
      } else if (L === this.maxOptionsVisible)
        return ke$1`<sl-tag size=${this.size}>+${this.selectedOptions.length - L}</sl-tag>`;
      return ke$1``;
    });
  }
  handleInvalid(C) {
    this.formControlController.setValidity(!1), this.formControlController.emitInvalidEvent(C);
  }
  handleDisabledChange() {
    this.disabled && (this.open = !1, this.handleOpenChange());
  }
  handleValueChange() {
    const C = this.getAllOptions(), L = Array.isArray(this.value) ? this.value : [this.value];
    this.setSelectedOptions(C.filter((A) => L.includes(A.value)));
  }
  async handleOpenChange() {
    if (this.open && !this.disabled) {
      this.setCurrentOption(this.selectedOptions[0] || this.getFirstOption()), this.emit("sl-show"), this.addOpenListeners(), await stopAnimations(this), this.listbox.hidden = !1, this.popup.active = !0, requestAnimationFrame(() => {
        this.setCurrentOption(this.currentOption);
      });
      const { keyframes: C, options: L } = getAnimation(this, "select.show", { dir: this.localize.dir() });
      await animateTo(this.popup.popup, C, L), this.currentOption && scrollIntoView(this.currentOption, this.listbox, "vertical", "auto"), this.emit("sl-after-show");
    } else {
      this.emit("sl-hide"), this.removeOpenListeners(), await stopAnimations(this);
      const { keyframes: C, options: L } = getAnimation(this, "select.hide", { dir: this.localize.dir() });
      await animateTo(this.popup.popup, C, L), this.listbox.hidden = !0, this.popup.active = !1, this.emit("sl-after-hide");
    }
  }
  /** Shows the listbox. */
  async show() {
    if (this.open || this.disabled) {
      this.open = !1;
      return;
    }
    return this.open = !0, waitForEvent(this, "sl-after-show");
  }
  /** Hides the listbox. */
  async hide() {
    if (!this.open || this.disabled) {
      this.open = !1;
      return;
    }
    return this.open = !1, waitForEvent(this, "sl-after-hide");
  }
  /** Checks for validity but does not show a validation message. Returns `true` when valid and `false` when invalid. */
  checkValidity() {
    return this.valueInput.checkValidity();
  }
  /** Gets the associated form, if one exists. */
  getForm() {
    return this.formControlController.getForm();
  }
  /** Checks for validity and shows the browser's validation message if the control is invalid. */
  reportValidity() {
    return this.valueInput.reportValidity();
  }
  /** Sets a custom validation message. Pass an empty string to restore validity. */
  setCustomValidity(C) {
    this.valueInput.setCustomValidity(C), this.formControlController.updateValidity();
  }
  /** Sets focus on the control. */
  focus(C) {
    this.displayInput.focus(C);
  }
  /** Removes focus from the control. */
  blur() {
    this.displayInput.blur();
  }
  render() {
    const C = this.hasSlotController.test("label"), L = this.hasSlotController.test("help-text"), A = this.label ? !0 : !!C, W = this.helpText ? !0 : !!L, X = this.clearable && !this.disabled && this.value.length > 0, J = this.placeholder && this.value.length === 0;
    return ke$1`
      <div
        part="form-control"
        class=${Rt({
      "form-control": !0,
      "form-control--small": this.size === "small",
      "form-control--medium": this.size === "medium",
      "form-control--large": this.size === "large",
      "form-control--has-label": A,
      "form-control--has-help-text": W
    })}
      >
        <label
          id="label"
          part="form-control-label"
          class="form-control__label"
          aria-hidden=${A ? "false" : "true"}
          @click=${this.handleLabelClick}
        >
          <slot name="label">${this.label}</slot>
        </label>

        <div part="form-control-input" class="form-control-input">
          <sl-popup
            class=${Rt({
      select: !0,
      "select--standard": !0,
      "select--filled": this.filled,
      "select--pill": this.pill,
      "select--open": this.open,
      "select--disabled": this.disabled,
      "select--multiple": this.multiple,
      "select--focused": this.hasFocus,
      "select--placeholder-visible": J,
      "select--top": this.placement === "top",
      "select--bottom": this.placement === "bottom",
      "select--small": this.size === "small",
      "select--medium": this.size === "medium",
      "select--large": this.size === "large"
    })}
            placement=${this.placement}
            strategy=${this.hoist ? "fixed" : "absolute"}
            flip
            shift
            sync="width"
            auto-size="vertical"
            auto-size-padding="10"
          >
            <div
              part="combobox"
              class="select__combobox"
              slot="anchor"
              @keydown=${this.handleComboboxKeyDown}
              @mousedown=${this.handleComboboxMouseDown}
            >
              <slot part="prefix" name="prefix" class="select__prefix"></slot>

              <input
                part="display-input"
                class="select__display-input"
                type="text"
                placeholder=${this.placeholder}
                .disabled=${this.disabled}
                .value=${this.displayLabel}
                autocomplete="off"
                spellcheck="false"
                autocapitalize="off"
                readonly
                aria-controls="listbox"
                aria-expanded=${this.open ? "true" : "false"}
                aria-haspopup="listbox"
                aria-labelledby="label"
                aria-disabled=${this.disabled ? "true" : "false"}
                aria-describedby="help-text"
                role="combobox"
                tabindex="0"
                @focus=${this.handleFocus}
                @blur=${this.handleBlur}
              />

              ${this.multiple ? ke$1`<div part="tags" class="select__tags">${this.tags}</div>` : ""}

              <input
                class="select__value-input"
                type="text"
                ?disabled=${this.disabled}
                ?required=${this.required}
                .value=${Array.isArray(this.value) ? this.value.join(", ") : this.value}
                tabindex="-1"
                aria-hidden="true"
                @focus=${() => this.focus()}
                @invalid=${this.handleInvalid}
              />

              ${X ? ke$1`
                    <button
                      part="clear-button"
                      class="select__clear"
                      type="button"
                      aria-label=${this.localize.term("clearEntry")}
                      @mousedown=${this.handleClearMouseDown}
                      @click=${this.handleClearClick}
                      tabindex="-1"
                    >
                      <slot name="clear-icon">
                        <sl-icon name="x-circle-fill" library="system"></sl-icon>
                      </slot>
                    </button>
                  ` : ""}

              <slot name="suffix" part="suffix" class="select__suffix"></slot>

              <slot name="expand-icon" part="expand-icon" class="select__expand-icon">
                <sl-icon library="system" name="chevron-down"></sl-icon>
              </slot>
            </div>

            <div
              id="listbox"
              role="listbox"
              aria-expanded=${this.open ? "true" : "false"}
              aria-multiselectable=${this.multiple ? "true" : "false"}
              aria-labelledby="label"
              part="listbox"
              class="select__listbox"
              tabindex="-1"
              @mouseup=${this.handleOptionClick}
              @slotchange=${this.handleDefaultSlotChange}
            >
              <slot></slot>
            </div>
          </sl-popup>
        </div>

        <div
          part="form-control-help-text"
          id="help-text"
          class="form-control__help-text"
          aria-hidden=${W ? "false" : "true"}
        >
          <slot name="help-text">${this.helpText}</slot>
        </div>
      </div>
    `;
  }
};
SlSelect.styles = [component_styles_default, form_control_styles_default, select_styles_default];
SlSelect.dependencies = {
  "sl-icon": SlIcon,
  "sl-popup": SlPopup,
  "sl-tag": SlTag
};
__decorateClass$e([
  e$6(".select")
], SlSelect.prototype, "popup", 2);
__decorateClass$e([
  e$6(".select__combobox")
], SlSelect.prototype, "combobox", 2);
__decorateClass$e([
  e$6(".select__display-input")
], SlSelect.prototype, "displayInput", 2);
__decorateClass$e([
  e$6(".select__value-input")
], SlSelect.prototype, "valueInput", 2);
__decorateClass$e([
  e$6(".select__listbox")
], SlSelect.prototype, "listbox", 2);
__decorateClass$e([
  r$3()
], SlSelect.prototype, "hasFocus", 2);
__decorateClass$e([
  r$3()
], SlSelect.prototype, "displayLabel", 2);
__decorateClass$e([
  r$3()
], SlSelect.prototype, "currentOption", 2);
__decorateClass$e([
  r$3()
], SlSelect.prototype, "selectedOptions", 2);
__decorateClass$e([
  n$1()
], SlSelect.prototype, "name", 2);
__decorateClass$e([
  n$1({
    converter: {
      fromAttribute: (C) => C.split(" "),
      toAttribute: (C) => C.join(" ")
    }
  })
], SlSelect.prototype, "value", 2);
__decorateClass$e([
  defaultValue()
], SlSelect.prototype, "defaultValue", 2);
__decorateClass$e([
  n$1({ reflect: !0 })
], SlSelect.prototype, "size", 2);
__decorateClass$e([
  n$1()
], SlSelect.prototype, "placeholder", 2);
__decorateClass$e([
  n$1({ type: Boolean, reflect: !0 })
], SlSelect.prototype, "multiple", 2);
__decorateClass$e([
  n$1({ attribute: "max-options-visible", type: Number })
], SlSelect.prototype, "maxOptionsVisible", 2);
__decorateClass$e([
  n$1({ type: Boolean, reflect: !0 })
], SlSelect.prototype, "disabled", 2);
__decorateClass$e([
  n$1({ type: Boolean })
], SlSelect.prototype, "clearable", 2);
__decorateClass$e([
  n$1({ type: Boolean, reflect: !0 })
], SlSelect.prototype, "open", 2);
__decorateClass$e([
  n$1({ type: Boolean })
], SlSelect.prototype, "hoist", 2);
__decorateClass$e([
  n$1({ type: Boolean, reflect: !0 })
], SlSelect.prototype, "filled", 2);
__decorateClass$e([
  n$1({ type: Boolean, reflect: !0 })
], SlSelect.prototype, "pill", 2);
__decorateClass$e([
  n$1()
], SlSelect.prototype, "label", 2);
__decorateClass$e([
  n$1({ reflect: !0 })
], SlSelect.prototype, "placement", 2);
__decorateClass$e([
  n$1({ attribute: "help-text" })
], SlSelect.prototype, "helpText", 2);
__decorateClass$e([
  n$1({ reflect: !0 })
], SlSelect.prototype, "form", 2);
__decorateClass$e([
  n$1({ type: Boolean, reflect: !0 })
], SlSelect.prototype, "required", 2);
__decorateClass$e([
  n$1()
], SlSelect.prototype, "getTag", 2);
__decorateClass$e([
  watch("disabled", { waitUntilFirstUpdate: !0 })
], SlSelect.prototype, "handleDisabledChange", 1);
__decorateClass$e([
  watch("value", { waitUntilFirstUpdate: !0 })
], SlSelect.prototype, "handleValueChange", 1);
__decorateClass$e([
  watch("open", { waitUntilFirstUpdate: !0 })
], SlSelect.prototype, "handleOpenChange", 1);
setDefaultAnimation("select.show", {
  keyframes: [
    { opacity: 0, scale: 0.9 },
    { opacity: 1, scale: 1 }
  ],
  options: { duration: 100, easing: "ease" }
});
setDefaultAnimation("select.hide", {
  keyframes: [
    { opacity: 1, scale: 1 },
    { opacity: 0, scale: 0.9 }
  ],
  options: { duration: 100, easing: "ease" }
});
SlSelect.define("sl-select");
var skeleton_styles_default = i$5`
  :host {
    --border-radius: var(--sl-border-radius-pill);
    --color: var(--sl-color-neutral-200);
    --sheen-color: var(--sl-color-neutral-300);

    display: block;
    position: relative;
  }

  .skeleton {
    display: flex;
    width: 100%;
    height: 100%;
    min-height: 1rem;
  }

  .skeleton__indicator {
    flex: 1 1 auto;
    background: var(--color);
    border-radius: var(--border-radius);
  }

  .skeleton--sheen .skeleton__indicator {
    background: linear-gradient(270deg, var(--sheen-color), var(--color), var(--color), var(--sheen-color));
    background-size: 400% 100%;
    animation: sheen 8s ease-in-out infinite;
  }

  .skeleton--pulse .skeleton__indicator {
    animation: pulse 2s ease-in-out 0.5s infinite;
  }

  /* Forced colors mode */
  @media (forced-colors: active) {
    :host {
      --color: GrayText;
    }
  }

  @keyframes sheen {
    0% {
      background-position: 200% 0;
    }
    to {
      background-position: -200% 0;
    }
  }

  @keyframes pulse {
    0% {
      opacity: 1;
    }
    50% {
      opacity: 0.4;
    }
    100% {
      opacity: 1;
    }
  }
`, SlSkeleton = class extends ShoelaceElement {
  constructor() {
    super(...arguments), this.effect = "none";
  }
  render() {
    return ke$1`
      <div
        part="base"
        class=${Rt({
      skeleton: !0,
      "skeleton--pulse": this.effect === "pulse",
      "skeleton--sheen": this.effect === "sheen"
    })}
      >
        <div part="indicator" class="skeleton__indicator"></div>
      </div>
    `;
  }
};
SlSkeleton.styles = [component_styles_default, skeleton_styles_default];
__decorateClass$e([
  n$1()
], SlSkeleton.prototype, "effect", 2);
SlSkeleton.define("sl-skeleton");
var range_styles_default = i$5`
  :host {
    --thumb-size: 20px;
    --tooltip-offset: 10px;
    --track-color-active: var(--sl-color-neutral-200);
    --track-color-inactive: var(--sl-color-neutral-200);
    --track-active-offset: 0%;
    --track-height: 6px;

    display: block;
  }

  .range {
    position: relative;
  }

  .range__control {
    --percent: 0%;
    -webkit-appearance: none;
    border-radius: 3px;
    width: 100%;
    height: var(--track-height);
    background: transparent;
    line-height: var(--sl-input-height-medium);
    vertical-align: middle;
    margin: 0;

    background-image: linear-gradient(
      to right,
      var(--track-color-inactive) 0%,
      var(--track-color-inactive) min(var(--percent), var(--track-active-offset)),
      var(--track-color-active) min(var(--percent), var(--track-active-offset)),
      var(--track-color-active) max(var(--percent), var(--track-active-offset)),
      var(--track-color-inactive) max(var(--percent), var(--track-active-offset)),
      var(--track-color-inactive) 100%
    );
  }

  .range--rtl .range__control {
    background-image: linear-gradient(
      to left,
      var(--track-color-inactive) 0%,
      var(--track-color-inactive) min(var(--percent), var(--track-active-offset)),
      var(--track-color-active) min(var(--percent), var(--track-active-offset)),
      var(--track-color-active) max(var(--percent), var(--track-active-offset)),
      var(--track-color-inactive) max(var(--percent), var(--track-active-offset)),
      var(--track-color-inactive) 100%
    );
  }

  /* Webkit */
  .range__control::-webkit-slider-runnable-track {
    width: 100%;
    height: var(--track-height);
    border-radius: 3px;
    border: none;
  }

  .range__control::-webkit-slider-thumb {
    border: none;
    width: var(--thumb-size);
    height: var(--thumb-size);
    border-radius: 50%;
    background-color: var(--sl-color-primary-600);
    border: solid var(--sl-input-border-width) var(--sl-color-primary-600);
    -webkit-appearance: none;
    margin-top: calc(var(--thumb-size) / -2 + var(--track-height) / 2);
    cursor: pointer;
  }

  .range__control:enabled::-webkit-slider-thumb:hover {
    background-color: var(--sl-color-primary-500);
    border-color: var(--sl-color-primary-500);
  }

  .range__control:enabled:focus-visible::-webkit-slider-thumb {
    outline: var(--sl-focus-ring);
    outline-offset: var(--sl-focus-ring-offset);
  }

  .range__control:enabled::-webkit-slider-thumb:active {
    background-color: var(--sl-color-primary-500);
    border-color: var(--sl-color-primary-500);
    cursor: grabbing;
  }

  /* Firefox */
  .range__control::-moz-focus-outer {
    border: 0;
  }

  .range__control::-moz-range-progress {
    background-color: var(--track-color-active);
    border-radius: 3px;
    height: var(--track-height);
  }

  .range__control::-moz-range-track {
    width: 100%;
    height: var(--track-height);
    background-color: var(--track-color-inactive);
    border-radius: 3px;
    border: none;
  }

  .range__control::-moz-range-thumb {
    border: none;
    height: var(--thumb-size);
    width: var(--thumb-size);
    border-radius: 50%;
    background-color: var(--sl-color-primary-600);
    border-color: var(--sl-color-primary-600);
    transition:
      var(--sl-transition-fast) border-color,
      var(--sl-transition-fast) background-color,
      var(--sl-transition-fast) color,
      var(--sl-transition-fast) box-shadow;
    cursor: pointer;
  }

  .range__control:enabled::-moz-range-thumb:hover {
    background-color: var(--sl-color-primary-500);
    border-color: var(--sl-color-primary-500);
  }

  .range__control:enabled:focus-visible::-moz-range-thumb {
    outline: var(--sl-focus-ring);
    outline-offset: var(--sl-focus-ring-offset);
  }

  .range__control:enabled::-moz-range-thumb:active {
    background-color: var(--sl-color-primary-500);
    border-color: var(--sl-color-primary-500);
    cursor: grabbing;
  }

  /* States */
  .range__control:focus-visible {
    outline: none;
  }

  .range__control:disabled {
    opacity: 0.5;
  }

  .range__control:disabled::-webkit-slider-thumb {
    cursor: not-allowed;
  }

  .range__control:disabled::-moz-range-thumb {
    cursor: not-allowed;
  }

  /* Tooltip output */
  .range__tooltip {
    position: absolute;
    z-index: var(--sl-z-index-tooltip);
    left: 0;
    border-radius: var(--sl-tooltip-border-radius);
    background-color: var(--sl-tooltip-background-color);
    font-family: var(--sl-tooltip-font-family);
    font-size: var(--sl-tooltip-font-size);
    font-weight: var(--sl-tooltip-font-weight);
    line-height: var(--sl-tooltip-line-height);
    color: var(--sl-tooltip-color);
    opacity: 0;
    padding: var(--sl-tooltip-padding);
    transition: var(--sl-transition-fast) opacity;
    pointer-events: none;
  }

  .range__tooltip:after {
    content: '';
    position: absolute;
    width: 0;
    height: 0;
    left: 50%;
    translate: calc(-1 * var(--sl-tooltip-arrow-size));
  }

  .range--tooltip-visible .range__tooltip {
    opacity: 1;
  }

  /* Tooltip on top */
  .range--tooltip-top .range__tooltip {
    top: calc(-1 * var(--thumb-size) - var(--tooltip-offset));
  }

  .range--tooltip-top .range__tooltip:after {
    border-top: var(--sl-tooltip-arrow-size) solid var(--sl-tooltip-background-color);
    border-left: var(--sl-tooltip-arrow-size) solid transparent;
    border-right: var(--sl-tooltip-arrow-size) solid transparent;
    top: 100%;
  }

  /* Tooltip on bottom */
  .range--tooltip-bottom .range__tooltip {
    bottom: calc(-1 * var(--thumb-size) - var(--tooltip-offset));
  }

  .range--tooltip-bottom .range__tooltip:after {
    border-bottom: var(--sl-tooltip-arrow-size) solid var(--sl-tooltip-background-color);
    border-left: var(--sl-tooltip-arrow-size) solid transparent;
    border-right: var(--sl-tooltip-arrow-size) solid transparent;
    bottom: 100%;
  }

  @media (forced-colors: active) {
    .range__control,
    .range__tooltip {
      border: solid 1px transparent;
    }

    .range__control::-webkit-slider-thumb {
      border: solid 1px transparent;
    }

    .range__control::-moz-range-thumb {
      border: solid 1px transparent;
    }

    .range__tooltip:after {
      display: none;
    }
  }
`, SlRange = class extends ShoelaceElement {
  constructor() {
    super(...arguments), this.formControlController = new FormControlController(this), this.hasSlotController = new HasSlotController(this, "help-text", "label"), this.localize = new LocalizeController(this), this.hasFocus = !1, this.hasTooltip = !1, this.title = "", this.name = "", this.value = 0, this.label = "", this.helpText = "", this.disabled = !1, this.min = 0, this.max = 100, this.step = 1, this.tooltip = "top", this.tooltipFormatter = (C) => C.toString(), this.form = "", this.defaultValue = 0;
  }
  /** Gets the validity state object */
  get validity() {
    return this.input.validity;
  }
  /** Gets the validation message */
  get validationMessage() {
    return this.input.validationMessage;
  }
  connectedCallback() {
    super.connectedCallback(), this.resizeObserver = new ResizeObserver(() => this.syncRange()), this.value < this.min && (this.value = this.min), this.value > this.max && (this.value = this.max), this.updateComplete.then(() => {
      this.syncRange(), this.resizeObserver.observe(this.input);
    });
  }
  disconnectedCallback() {
    super.disconnectedCallback(), this.resizeObserver.unobserve(this.input);
  }
  handleChange() {
    this.emit("sl-change");
  }
  handleInput() {
    this.value = parseFloat(this.input.value), this.emit("sl-input"), this.syncRange();
  }
  handleBlur() {
    this.hasFocus = !1, this.hasTooltip = !1, this.emit("sl-blur");
  }
  handleFocus() {
    this.hasFocus = !0, this.hasTooltip = !0, this.emit("sl-focus");
  }
  handleThumbDragStart() {
    this.hasTooltip = !0;
  }
  handleThumbDragEnd() {
    this.hasTooltip = !1;
  }
  syncProgress(C) {
    this.input.style.setProperty("--percent", `${C * 100}%`);
  }
  syncTooltip(C) {
    if (this.output !== null) {
      const L = this.input.offsetWidth, A = this.output.offsetWidth, W = getComputedStyle(this.input).getPropertyValue("--thumb-size"), X = this.matches(":dir(rtl)"), J = L * C;
      if (X) {
        const te = `${L - J}px + ${C} * ${W}`;
        this.output.style.translate = `calc((${te} - ${A / 2}px - ${W} / 2))`;
      } else {
        const te = `${J}px - ${C} * ${W}`;
        this.output.style.translate = `calc(${te} - ${A / 2}px + ${W} / 2)`;
      }
    }
  }
  handleValueChange() {
    this.formControlController.updateValidity(), this.input.value = this.value.toString(), this.value = parseFloat(this.input.value), this.syncRange();
  }
  handleDisabledChange() {
    this.formControlController.setValidity(this.disabled);
  }
  syncRange() {
    const C = Math.max(0, (this.value - this.min) / (this.max - this.min));
    this.syncProgress(C), this.tooltip !== "none" && this.updateComplete.then(() => this.syncTooltip(C));
  }
  handleInvalid(C) {
    this.formControlController.setValidity(!1), this.formControlController.emitInvalidEvent(C);
  }
  /** Sets focus on the range. */
  focus(C) {
    this.input.focus(C);
  }
  /** Removes focus from the range. */
  blur() {
    this.input.blur();
  }
  /** Increments the value of the range by the value of the step attribute. */
  stepUp() {
    this.input.stepUp(), this.value !== Number(this.input.value) && (this.value = Number(this.input.value));
  }
  /** Decrements the value of the range by the value of the step attribute. */
  stepDown() {
    this.input.stepDown(), this.value !== Number(this.input.value) && (this.value = Number(this.input.value));
  }
  /** Checks for validity but does not show a validation message. Returns `true` when valid and `false` when invalid. */
  checkValidity() {
    return this.input.checkValidity();
  }
  /** Gets the associated form, if one exists. */
  getForm() {
    return this.formControlController.getForm();
  }
  /** Checks for validity and shows the browser's validation message if the control is invalid. */
  reportValidity() {
    return this.input.reportValidity();
  }
  /** Sets a custom validation message. Pass an empty string to restore validity. */
  setCustomValidity(C) {
    this.input.setCustomValidity(C), this.formControlController.updateValidity();
  }
  render() {
    const C = this.hasSlotController.test("label"), L = this.hasSlotController.test("help-text"), A = this.label ? !0 : !!C, W = this.helpText ? !0 : !!L;
    return ke$1`
      <div
        part="form-control"
        class=${Rt({
      "form-control": !0,
      "form-control--medium": !0,
      // range only has one size
      "form-control--has-label": A,
      "form-control--has-help-text": W
    })}
      >
        <label
          part="form-control-label"
          class="form-control__label"
          for="input"
          aria-hidden=${A ? "false" : "true"}
        >
          <slot name="label">${this.label}</slot>
        </label>

        <div part="form-control-input" class="form-control-input">
          <div
            part="base"
            class=${Rt({
      range: !0,
      "range--disabled": this.disabled,
      "range--focused": this.hasFocus,
      "range--rtl": this.localize.dir() === "rtl",
      "range--tooltip-visible": this.hasTooltip,
      "range--tooltip-top": this.tooltip === "top",
      "range--tooltip-bottom": this.tooltip === "bottom"
    })}
            @mousedown=${this.handleThumbDragStart}
            @mouseup=${this.handleThumbDragEnd}
            @touchstart=${this.handleThumbDragStart}
            @touchend=${this.handleThumbDragEnd}
          >
            <input
              part="input"
              id="input"
              class="range__control"
              title=${this.title}
              type="range"
              name=${to(this.name)}
              ?disabled=${this.disabled}
              min=${to(this.min)}
              max=${to(this.max)}
              step=${to(this.step)}
              .value=${Ft(this.value.toString())}
              aria-describedby="help-text"
              @change=${this.handleChange}
              @focus=${this.handleFocus}
              @input=${this.handleInput}
              @invalid=${this.handleInvalid}
              @blur=${this.handleBlur}
            />
            ${this.tooltip !== "none" && !this.disabled ? ke$1`
                  <output part="tooltip" class="range__tooltip">
                    ${typeof this.tooltipFormatter == "function" ? this.tooltipFormatter(this.value) : this.value}
                  </output>
                ` : ""}
          </div>
        </div>

        <div
          part="form-control-help-text"
          id="help-text"
          class="form-control__help-text"
          aria-hidden=${W ? "false" : "true"}
        >
          <slot name="help-text">${this.helpText}</slot>
        </div>
      </div>
    `;
  }
};
SlRange.styles = [component_styles_default, form_control_styles_default, range_styles_default];
__decorateClass$e([
  e$6(".range__control")
], SlRange.prototype, "input", 2);
__decorateClass$e([
  e$6(".range__tooltip")
], SlRange.prototype, "output", 2);
__decorateClass$e([
  r$3()
], SlRange.prototype, "hasFocus", 2);
__decorateClass$e([
  r$3()
], SlRange.prototype, "hasTooltip", 2);
__decorateClass$e([
  n$1()
], SlRange.prototype, "title", 2);
__decorateClass$e([
  n$1()
], SlRange.prototype, "name", 2);
__decorateClass$e([
  n$1({ type: Number })
], SlRange.prototype, "value", 2);
__decorateClass$e([
  n$1()
], SlRange.prototype, "label", 2);
__decorateClass$e([
  n$1({ attribute: "help-text" })
], SlRange.prototype, "helpText", 2);
__decorateClass$e([
  n$1({ type: Boolean, reflect: !0 })
], SlRange.prototype, "disabled", 2);
__decorateClass$e([
  n$1({ type: Number })
], SlRange.prototype, "min", 2);
__decorateClass$e([
  n$1({ type: Number })
], SlRange.prototype, "max", 2);
__decorateClass$e([
  n$1({ type: Number })
], SlRange.prototype, "step", 2);
__decorateClass$e([
  n$1()
], SlRange.prototype, "tooltip", 2);
__decorateClass$e([
  n$1({ attribute: !1 })
], SlRange.prototype, "tooltipFormatter", 2);
__decorateClass$e([
  n$1({ reflect: !0 })
], SlRange.prototype, "form", 2);
__decorateClass$e([
  defaultValue()
], SlRange.prototype, "defaultValue", 2);
__decorateClass$e([
  t$3({ passive: !0 })
], SlRange.prototype, "handleThumbDragStart", 1);
__decorateClass$e([
  watch("value", { waitUntilFirstUpdate: !0 })
], SlRange.prototype, "handleValueChange", 1);
__decorateClass$e([
  watch("disabled", { waitUntilFirstUpdate: !0 })
], SlRange.prototype, "handleDisabledChange", 1);
__decorateClass$e([
  watch("hasTooltip", { waitUntilFirstUpdate: !0 })
], SlRange.prototype, "syncRange", 1);
SlRange.define("sl-range");
var availableUnits = [
  { max: 276e4, value: 6e4, unit: "minute" },
  // max 46 minutes
  { max: 72e6, value: 36e5, unit: "hour" },
  // max 20 hours
  { max: 5184e5, value: 864e5, unit: "day" },
  // max 6 days
  { max: 24192e5, value: 6048e5, unit: "week" },
  // max 28 days
  { max: 28512e6, value: 2592e6, unit: "month" },
  // max 11 months
  { max: 1 / 0, value: 31536e6, unit: "year" }
], SlRelativeTime = class extends ShoelaceElement {
  constructor() {
    super(...arguments), this.localize = new LocalizeController(this), this.isoTime = "", this.relativeTime = "", this.date = /* @__PURE__ */ new Date(), this.format = "long", this.numeric = "auto", this.sync = !1;
  }
  disconnectedCallback() {
    super.disconnectedCallback(), clearTimeout(this.updateTimeout);
  }
  render() {
    const C = /* @__PURE__ */ new Date(), L = new Date(this.date);
    if (isNaN(L.getMilliseconds()))
      return this.relativeTime = "", this.isoTime = "", "";
    const A = L.getTime() - C.getTime(), { unit: W, value: X } = availableUnits.find((J) => Math.abs(A) < J.max);
    if (this.isoTime = L.toISOString(), this.relativeTime = this.localize.relativeTime(Math.round(A / X), W, {
      numeric: this.numeric,
      style: this.format
    }), clearTimeout(this.updateTimeout), this.sync) {
      let J;
      W === "minute" ? J = getTimeUntilNextUnit("second") : W === "hour" ? J = getTimeUntilNextUnit("minute") : W === "day" ? J = getTimeUntilNextUnit("hour") : J = getTimeUntilNextUnit("day"), this.updateTimeout = window.setTimeout(() => this.requestUpdate(), J);
    }
    return ke$1` <time datetime=${this.isoTime} title=${this.relativeTime}>${this.relativeTime}</time> `;
  }
};
__decorateClass$e([
  r$3()
], SlRelativeTime.prototype, "isoTime", 2);
__decorateClass$e([
  r$3()
], SlRelativeTime.prototype, "relativeTime", 2);
__decorateClass$e([
  n$1()
], SlRelativeTime.prototype, "date", 2);
__decorateClass$e([
  n$1()
], SlRelativeTime.prototype, "format", 2);
__decorateClass$e([
  n$1()
], SlRelativeTime.prototype, "numeric", 2);
__decorateClass$e([
  n$1({ type: Boolean })
], SlRelativeTime.prototype, "sync", 2);
function getTimeUntilNextUnit(C) {
  const A = { second: 1e3, minute: 6e4, hour: 36e5, day: 864e5 }[C];
  return A - Date.now() % A;
}
SlRelativeTime.define("sl-relative-time");
var rating_styles_default = i$5`
  :host {
    --symbol-color: var(--sl-color-neutral-300);
    --symbol-color-active: var(--sl-color-amber-500);
    --symbol-size: 1.2rem;
    --symbol-spacing: var(--sl-spacing-3x-small);

    display: inline-flex;
  }

  .rating {
    position: relative;
    display: inline-flex;
    border-radius: var(--sl-border-radius-medium);
    vertical-align: middle;
  }

  .rating:focus {
    outline: none;
  }

  .rating:focus-visible {
    outline: var(--sl-focus-ring);
    outline-offset: var(--sl-focus-ring-offset);
  }

  .rating__symbols {
    display: inline-flex;
    position: relative;
    font-size: var(--symbol-size);
    line-height: 0;
    color: var(--symbol-color);
    white-space: nowrap;
    cursor: pointer;
  }

  .rating__symbols > * {
    padding: var(--symbol-spacing);
  }

  .rating__symbol--active,
  .rating__partial--filled {
    color: var(--symbol-color-active);
  }

  .rating__partial-symbol-container {
    position: relative;
  }

  .rating__partial--filled {
    position: absolute;
    top: var(--symbol-spacing);
    left: var(--symbol-spacing);
  }

  .rating__symbol {
    transition: var(--sl-transition-fast) scale;
    pointer-events: none;
  }

  .rating__symbol--hover {
    scale: 1.2;
  }

  .rating--disabled .rating__symbols,
  .rating--readonly .rating__symbols {
    cursor: default;
  }

  .rating--disabled .rating__symbol--hover,
  .rating--readonly .rating__symbol--hover {
    scale: none;
  }

  .rating--disabled {
    opacity: 0.5;
  }

  .rating--disabled .rating__symbols {
    cursor: not-allowed;
  }

  /* Forced colors mode */
  @media (forced-colors: active) {
    .rating__symbol--active {
      color: SelectedItem;
    }
  }
`;
/**
 * @license
 * Copyright 2018 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const ee = "important", ie = " !" + ee, se = e$4(class extends i$3 {
  constructor(C) {
    var L;
    if (super(C), C.type !== t$2.ATTRIBUTE || C.name !== "style" || ((L = C.strings) == null ? void 0 : L.length) > 2) throw Error("The `styleMap` directive must be used in the `style` attribute and must be the only part in the attribute.");
  }
  render(C) {
    return Object.keys(C).reduce((L, A) => {
      const W = C[A];
      return W == null ? L : L + `${A = A.includes("-") ? A : A.replace(/(?:^(webkit|moz|ms|o)|)(?=[A-Z])/g, "-$&").toLowerCase()}:${W};`;
    }, "");
  }
  update(C, [L]) {
    const { style: A } = C.element;
    if (this.ft === void 0) return this.ft = new Set(Object.keys(L)), this.render(L);
    for (const W of this.ft) L[W] == null && (this.ft.delete(W), W.includes("-") ? A.removeProperty(W) : A[W] = null);
    for (const W in L) {
      const X = L[W];
      if (X != null) {
        this.ft.add(W);
        const J = typeof X == "string" && X.endsWith(ie);
        W.includes("-") || J ? A.setProperty(W, J ? X.slice(0, -11) : X, J ? ee : "") : A[W] = X;
      }
    }
    return R$1;
  }
});
var SlRating = class extends ShoelaceElement {
  constructor() {
    super(...arguments), this.hoverValue = 0, this.isHovering = !1, this.label = "", this.value = 0, this.max = 5, this.precision = 1, this.readonly = !1, this.disabled = !1, this.getSymbol = () => '<sl-icon name="star-fill" library="system"></sl-icon>';
  }
  getValueFromMousePosition(C) {
    return this.getValueFromXCoordinate(C.clientX);
  }
  getValueFromTouchPosition(C) {
    return this.getValueFromXCoordinate(C.touches[0].clientX);
  }
  getValueFromXCoordinate(C) {
    const L = this.matches(":dir(rtl)"), { left: A, right: W, width: X } = this.rating.getBoundingClientRect(), J = L ? this.roundToPrecision((W - C) / X * this.max, this.precision) : this.roundToPrecision((C - A) / X * this.max, this.precision);
    return clamp(J, 0, this.max);
  }
  handleClick(C) {
    this.disabled || (this.setValue(this.getValueFromMousePosition(C)), this.emit("sl-change"));
  }
  setValue(C) {
    this.disabled || this.readonly || (this.value = C === this.value ? 0 : C, this.isHovering = !1);
  }
  handleKeyDown(C) {
    const L = this.matches(":dir(ltr)"), A = this.matches(":dir(rtl)"), W = this.value;
    if (!(this.disabled || this.readonly)) {
      if (C.key === "ArrowDown" || L && C.key === "ArrowLeft" || A && C.key === "ArrowRight") {
        const X = C.shiftKey ? 1 : this.precision;
        this.value = Math.max(0, this.value - X), C.preventDefault();
      }
      if (C.key === "ArrowUp" || L && C.key === "ArrowRight" || A && C.key === "ArrowLeft") {
        const X = C.shiftKey ? 1 : this.precision;
        this.value = Math.min(this.max, this.value + X), C.preventDefault();
      }
      C.key === "Home" && (this.value = 0, C.preventDefault()), C.key === "End" && (this.value = this.max, C.preventDefault()), this.value !== W && this.emit("sl-change");
    }
  }
  handleMouseEnter(C) {
    this.isHovering = !0, this.hoverValue = this.getValueFromMousePosition(C);
  }
  handleMouseMove(C) {
    this.hoverValue = this.getValueFromMousePosition(C);
  }
  handleMouseLeave() {
    this.isHovering = !1;
  }
  handleTouchStart(C) {
    this.isHovering = !0, this.hoverValue = this.getValueFromTouchPosition(C), C.preventDefault();
  }
  handleTouchMove(C) {
    this.hoverValue = this.getValueFromTouchPosition(C);
  }
  handleTouchEnd(C) {
    this.isHovering = !1, this.setValue(this.hoverValue), this.emit("sl-change"), C.preventDefault();
  }
  roundToPrecision(C, L = 0.5) {
    const A = 1 / L;
    return Math.ceil(C * A) / A;
  }
  handleHoverValueChange() {
    this.emit("sl-hover", {
      detail: {
        phase: "move",
        value: this.hoverValue
      }
    });
  }
  handleIsHoveringChange() {
    this.emit("sl-hover", {
      detail: {
        phase: this.isHovering ? "start" : "end",
        value: this.hoverValue
      }
    });
  }
  /** Sets focus on the rating. */
  focus(C) {
    this.rating.focus(C);
  }
  /** Removes focus from the rating. */
  blur() {
    this.rating.blur();
  }
  render() {
    const C = this.matches(":dir(rtl)"), L = Array.from(Array(this.max).keys());
    let A = 0;
    return this.disabled || this.readonly ? A = this.value : A = this.isHovering ? this.hoverValue : this.value, ke$1`
      <div
        part="base"
        class=${Rt({
      rating: !0,
      "rating--readonly": this.readonly,
      "rating--disabled": this.disabled,
      "rating--rtl": C
    })}
        role="slider"
        aria-label=${this.label}
        aria-disabled=${this.disabled ? "true" : "false"}
        aria-readonly=${this.readonly ? "true" : "false"}
        aria-valuenow=${this.value}
        aria-valuemin=${0}
        aria-valuemax=${this.max}
        tabindex=${this.disabled ? "-1" : "0"}
        @click=${this.handleClick}
        @keydown=${this.handleKeyDown}
        @mouseenter=${this.handleMouseEnter}
        @touchstart=${this.handleTouchStart}
        @mouseleave=${this.handleMouseLeave}
        @touchend=${this.handleTouchEnd}
        @mousemove=${this.handleMouseMove}
        @touchmove=${this.handleTouchMove}
      >
        <span class="rating__symbols">
          ${L.map((W) => A > W && A < W + 1 ? ke$1`
                <span
                  class=${Rt({
      rating__symbol: !0,
      "rating__partial-symbol-container": !0,
      "rating__symbol--hover": this.isHovering && Math.ceil(A) === W + 1
    })}
                  role="presentation"
                >
                  <div
                    style=${se({
      clipPath: C ? `inset(0 ${(A - W) * 100}% 0 0)` : `inset(0 0 0 ${(A - W) * 100}%)`
    })}
                  >
                    ${ae(this.getSymbol(W + 1))}
                  </div>
                  <div
                    class="rating__partial--filled"
                    style=${se({
      clipPath: C ? `inset(0 0 0 ${100 - (A - W) * 100}%)` : `inset(0 ${100 - (A - W) * 100}% 0 0)`
    })}
                  >
                    ${ae(this.getSymbol(W + 1))}
                  </div>
                </span>
              ` : ke$1`
              <span
                class=${Rt({
      rating__symbol: !0,
      "rating__symbol--hover": this.isHovering && Math.ceil(A) === W + 1,
      "rating__symbol--active": A >= W + 1
    })}
                role="presentation"
              >
                ${ae(this.getSymbol(W + 1))}
              </span>
            `)}
        </span>
      </div>
    `;
  }
};
SlRating.styles = [component_styles_default, rating_styles_default];
SlRating.dependencies = { "sl-icon": SlIcon };
__decorateClass$e([
  e$6(".rating")
], SlRating.prototype, "rating", 2);
__decorateClass$e([
  r$3()
], SlRating.prototype, "hoverValue", 2);
__decorateClass$e([
  r$3()
], SlRating.prototype, "isHovering", 2);
__decorateClass$e([
  n$1()
], SlRating.prototype, "label", 2);
__decorateClass$e([
  n$1({ type: Number })
], SlRating.prototype, "value", 2);
__decorateClass$e([
  n$1({ type: Number })
], SlRating.prototype, "max", 2);
__decorateClass$e([
  n$1({ type: Number })
], SlRating.prototype, "precision", 2);
__decorateClass$e([
  n$1({ type: Boolean, reflect: !0 })
], SlRating.prototype, "readonly", 2);
__decorateClass$e([
  n$1({ type: Boolean, reflect: !0 })
], SlRating.prototype, "disabled", 2);
__decorateClass$e([
  n$1()
], SlRating.prototype, "getSymbol", 2);
__decorateClass$e([
  t$3({ passive: !0 })
], SlRating.prototype, "handleTouchMove", 1);
__decorateClass$e([
  watch("hoverValue")
], SlRating.prototype, "handleHoverValueChange", 1);
__decorateClass$e([
  watch("isHovering")
], SlRating.prototype, "handleIsHoveringChange", 1);
SlRating.define("sl-rating");
var button_styles_default = i$5`
  :host {
    display: inline-block;
    position: relative;
    width: auto;
    cursor: pointer;
  }

  .button {
    display: inline-flex;
    align-items: stretch;
    justify-content: center;
    width: 100%;
    border-style: solid;
    border-width: var(--sl-input-border-width);
    font-family: var(--sl-input-font-family);
    font-weight: var(--sl-font-weight-semibold);
    text-decoration: none;
    user-select: none;
    -webkit-user-select: none;
    white-space: nowrap;
    vertical-align: middle;
    padding: 0;
    transition:
      var(--sl-transition-x-fast) background-color,
      var(--sl-transition-x-fast) color,
      var(--sl-transition-x-fast) border,
      var(--sl-transition-x-fast) box-shadow;
    cursor: inherit;
  }

  .button::-moz-focus-inner {
    border: 0;
  }

  .button:focus {
    outline: none;
  }

  .button:focus-visible {
    outline: var(--sl-focus-ring);
    outline-offset: var(--sl-focus-ring-offset);
  }

  .button--disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }

  /* When disabled, prevent mouse events from bubbling up from children */
  .button--disabled * {
    pointer-events: none;
  }

  .button__prefix,
  .button__suffix {
    flex: 0 0 auto;
    display: flex;
    align-items: center;
    pointer-events: none;
  }

  .button__label {
    display: inline-block;
  }

  .button__label::slotted(sl-icon) {
    vertical-align: -2px;
  }

  /*
   * Standard buttons
   */

  /* Default */
  .button--standard.button--default {
    background-color: var(--sl-color-neutral-0);
    border-color: var(--sl-input-border-color);
    color: var(--sl-color-neutral-700);
  }

  .button--standard.button--default:hover:not(.button--disabled) {
    background-color: var(--sl-color-primary-50);
    border-color: var(--sl-color-primary-300);
    color: var(--sl-color-primary-700);
  }

  .button--standard.button--default:active:not(.button--disabled) {
    background-color: var(--sl-color-primary-100);
    border-color: var(--sl-color-primary-400);
    color: var(--sl-color-primary-700);
  }

  /* Primary */
  .button--standard.button--primary {
    background-color: var(--sl-color-primary-600);
    border-color: var(--sl-color-primary-600);
    color: var(--sl-color-neutral-0);
  }

  .button--standard.button--primary:hover:not(.button--disabled) {
    background-color: var(--sl-color-primary-500);
    border-color: var(--sl-color-primary-500);
    color: var(--sl-color-neutral-0);
  }

  .button--standard.button--primary:active:not(.button--disabled) {
    background-color: var(--sl-color-primary-600);
    border-color: var(--sl-color-primary-600);
    color: var(--sl-color-neutral-0);
  }

  /* Success */
  .button--standard.button--success {
    background-color: var(--sl-color-success-600);
    border-color: var(--sl-color-success-600);
    color: var(--sl-color-neutral-0);
  }

  .button--standard.button--success:hover:not(.button--disabled) {
    background-color: var(--sl-color-success-500);
    border-color: var(--sl-color-success-500);
    color: var(--sl-color-neutral-0);
  }

  .button--standard.button--success:active:not(.button--disabled) {
    background-color: var(--sl-color-success-600);
    border-color: var(--sl-color-success-600);
    color: var(--sl-color-neutral-0);
  }

  /* Neutral */
  .button--standard.button--neutral {
    background-color: var(--sl-color-neutral-600);
    border-color: var(--sl-color-neutral-600);
    color: var(--sl-color-neutral-0);
  }

  .button--standard.button--neutral:hover:not(.button--disabled) {
    background-color: var(--sl-color-neutral-500);
    border-color: var(--sl-color-neutral-500);
    color: var(--sl-color-neutral-0);
  }

  .button--standard.button--neutral:active:not(.button--disabled) {
    background-color: var(--sl-color-neutral-600);
    border-color: var(--sl-color-neutral-600);
    color: var(--sl-color-neutral-0);
  }

  /* Warning */
  .button--standard.button--warning {
    background-color: var(--sl-color-warning-600);
    border-color: var(--sl-color-warning-600);
    color: var(--sl-color-neutral-0);
  }
  .button--standard.button--warning:hover:not(.button--disabled) {
    background-color: var(--sl-color-warning-500);
    border-color: var(--sl-color-warning-500);
    color: var(--sl-color-neutral-0);
  }

  .button--standard.button--warning:active:not(.button--disabled) {
    background-color: var(--sl-color-warning-600);
    border-color: var(--sl-color-warning-600);
    color: var(--sl-color-neutral-0);
  }

  /* Danger */
  .button--standard.button--danger {
    background-color: var(--sl-color-danger-600);
    border-color: var(--sl-color-danger-600);
    color: var(--sl-color-neutral-0);
  }

  .button--standard.button--danger:hover:not(.button--disabled) {
    background-color: var(--sl-color-danger-500);
    border-color: var(--sl-color-danger-500);
    color: var(--sl-color-neutral-0);
  }

  .button--standard.button--danger:active:not(.button--disabled) {
    background-color: var(--sl-color-danger-600);
    border-color: var(--sl-color-danger-600);
    color: var(--sl-color-neutral-0);
  }

  /*
   * Outline buttons
   */

  .button--outline {
    background: none;
    border: solid 1px;
  }

  /* Default */
  .button--outline.button--default {
    border-color: var(--sl-input-border-color);
    color: var(--sl-color-neutral-700);
  }

  .button--outline.button--default:hover:not(.button--disabled),
  .button--outline.button--default.button--checked:not(.button--disabled) {
    border-color: var(--sl-color-primary-600);
    background-color: var(--sl-color-primary-600);
    color: var(--sl-color-neutral-0);
  }

  .button--outline.button--default:active:not(.button--disabled) {
    border-color: var(--sl-color-primary-700);
    background-color: var(--sl-color-primary-700);
    color: var(--sl-color-neutral-0);
  }

  /* Primary */
  .button--outline.button--primary {
    border-color: var(--sl-color-primary-600);
    color: var(--sl-color-primary-600);
  }

  .button--outline.button--primary:hover:not(.button--disabled),
  .button--outline.button--primary.button--checked:not(.button--disabled) {
    background-color: var(--sl-color-primary-600);
    color: var(--sl-color-neutral-0);
  }

  .button--outline.button--primary:active:not(.button--disabled) {
    border-color: var(--sl-color-primary-700);
    background-color: var(--sl-color-primary-700);
    color: var(--sl-color-neutral-0);
  }

  /* Success */
  .button--outline.button--success {
    border-color: var(--sl-color-success-600);
    color: var(--sl-color-success-600);
  }

  .button--outline.button--success:hover:not(.button--disabled),
  .button--outline.button--success.button--checked:not(.button--disabled) {
    background-color: var(--sl-color-success-600);
    color: var(--sl-color-neutral-0);
  }

  .button--outline.button--success:active:not(.button--disabled) {
    border-color: var(--sl-color-success-700);
    background-color: var(--sl-color-success-700);
    color: var(--sl-color-neutral-0);
  }

  /* Neutral */
  .button--outline.button--neutral {
    border-color: var(--sl-color-neutral-600);
    color: var(--sl-color-neutral-600);
  }

  .button--outline.button--neutral:hover:not(.button--disabled),
  .button--outline.button--neutral.button--checked:not(.button--disabled) {
    background-color: var(--sl-color-neutral-600);
    color: var(--sl-color-neutral-0);
  }

  .button--outline.button--neutral:active:not(.button--disabled) {
    border-color: var(--sl-color-neutral-700);
    background-color: var(--sl-color-neutral-700);
    color: var(--sl-color-neutral-0);
  }

  /* Warning */
  .button--outline.button--warning {
    border-color: var(--sl-color-warning-600);
    color: var(--sl-color-warning-600);
  }

  .button--outline.button--warning:hover:not(.button--disabled),
  .button--outline.button--warning.button--checked:not(.button--disabled) {
    background-color: var(--sl-color-warning-600);
    color: var(--sl-color-neutral-0);
  }

  .button--outline.button--warning:active:not(.button--disabled) {
    border-color: var(--sl-color-warning-700);
    background-color: var(--sl-color-warning-700);
    color: var(--sl-color-neutral-0);
  }

  /* Danger */
  .button--outline.button--danger {
    border-color: var(--sl-color-danger-600);
    color: var(--sl-color-danger-600);
  }

  .button--outline.button--danger:hover:not(.button--disabled),
  .button--outline.button--danger.button--checked:not(.button--disabled) {
    background-color: var(--sl-color-danger-600);
    color: var(--sl-color-neutral-0);
  }

  .button--outline.button--danger:active:not(.button--disabled) {
    border-color: var(--sl-color-danger-700);
    background-color: var(--sl-color-danger-700);
    color: var(--sl-color-neutral-0);
  }

  @media (forced-colors: active) {
    .button.button--outline.button--checked:not(.button--disabled) {
      outline: solid 2px transparent;
    }
  }

  /*
   * Text buttons
   */

  .button--text {
    background-color: transparent;
    border-color: transparent;
    color: var(--sl-color-primary-600);
  }

  .button--text:hover:not(.button--disabled) {
    background-color: transparent;
    border-color: transparent;
    color: var(--sl-color-primary-500);
  }

  .button--text:focus-visible:not(.button--disabled) {
    background-color: transparent;
    border-color: transparent;
    color: var(--sl-color-primary-500);
  }

  .button--text:active:not(.button--disabled) {
    background-color: transparent;
    border-color: transparent;
    color: var(--sl-color-primary-700);
  }

  /*
   * Size modifiers
   */

  .button--small {
    height: auto;
    min-height: var(--sl-input-height-small);
    font-size: var(--sl-button-font-size-small);
    line-height: calc(var(--sl-input-height-small) - var(--sl-input-border-width) * 2);
    border-radius: var(--sl-input-border-radius-small);
  }

  .button--medium {
    height: auto;
    min-height: var(--sl-input-height-medium);
    font-size: var(--sl-button-font-size-medium);
    line-height: calc(var(--sl-input-height-medium) - var(--sl-input-border-width) * 2);
    border-radius: var(--sl-input-border-radius-medium);
  }

  .button--large {
    height: auto;
    min-height: var(--sl-input-height-large);
    font-size: var(--sl-button-font-size-large);
    line-height: calc(var(--sl-input-height-large) - var(--sl-input-border-width) * 2);
    border-radius: var(--sl-input-border-radius-large);
  }

  /*
   * Pill modifier
   */

  .button--pill.button--small {
    border-radius: var(--sl-input-height-small);
  }

  .button--pill.button--medium {
    border-radius: var(--sl-input-height-medium);
  }

  .button--pill.button--large {
    border-radius: var(--sl-input-height-large);
  }

  /*
   * Circle modifier
   */

  .button--circle {
    padding-left: 0;
    padding-right: 0;
  }

  .button--circle.button--small {
    width: var(--sl-input-height-small);
    border-radius: 50%;
  }

  .button--circle.button--medium {
    width: var(--sl-input-height-medium);
    border-radius: 50%;
  }

  .button--circle.button--large {
    width: var(--sl-input-height-large);
    border-radius: 50%;
  }

  .button--circle .button__prefix,
  .button--circle .button__suffix,
  .button--circle .button__caret {
    display: none;
  }

  /*
   * Caret modifier
   */

  .button--caret .button__suffix {
    display: none;
  }

  .button--caret .button__caret {
    height: auto;
  }

  /*
   * Loading modifier
   */

  .button--loading {
    position: relative;
    cursor: wait;
  }

  .button--loading .button__prefix,
  .button--loading .button__label,
  .button--loading .button__suffix,
  .button--loading .button__caret {
    visibility: hidden;
  }

  .button--loading sl-spinner {
    --indicator-color: currentColor;
    position: absolute;
    font-size: 1em;
    height: 1em;
    width: 1em;
    top: calc(50% - 0.5em);
    left: calc(50% - 0.5em);
  }

  /*
   * Badges
   */

  .button ::slotted(sl-badge) {
    position: absolute;
    top: 0;
    right: 0;
    translate: 50% -50%;
    pointer-events: none;
  }

  .button--rtl ::slotted(sl-badge) {
    right: auto;
    left: 0;
    translate: -50% -50%;
  }

  /*
   * Button spacing
   */

  .button--has-label.button--small .button__label {
    padding: 0 var(--sl-spacing-small);
  }

  .button--has-label.button--medium .button__label {
    padding: 0 var(--sl-spacing-medium);
  }

  .button--has-label.button--large .button__label {
    padding: 0 var(--sl-spacing-large);
  }

  .button--has-prefix.button--small {
    padding-inline-start: var(--sl-spacing-x-small);
  }

  .button--has-prefix.button--small .button__label {
    padding-inline-start: var(--sl-spacing-x-small);
  }

  .button--has-prefix.button--medium {
    padding-inline-start: var(--sl-spacing-small);
  }

  .button--has-prefix.button--medium .button__label {
    padding-inline-start: var(--sl-spacing-small);
  }

  .button--has-prefix.button--large {
    padding-inline-start: var(--sl-spacing-small);
  }

  .button--has-prefix.button--large .button__label {
    padding-inline-start: var(--sl-spacing-small);
  }

  .button--has-suffix.button--small,
  .button--caret.button--small {
    padding-inline-end: var(--sl-spacing-x-small);
  }

  .button--has-suffix.button--small .button__label,
  .button--caret.button--small .button__label {
    padding-inline-end: var(--sl-spacing-x-small);
  }

  .button--has-suffix.button--medium,
  .button--caret.button--medium {
    padding-inline-end: var(--sl-spacing-small);
  }

  .button--has-suffix.button--medium .button__label,
  .button--caret.button--medium .button__label {
    padding-inline-end: var(--sl-spacing-small);
  }

  .button--has-suffix.button--large,
  .button--caret.button--large {
    padding-inline-end: var(--sl-spacing-small);
  }

  .button--has-suffix.button--large .button__label,
  .button--caret.button--large .button__label {
    padding-inline-end: var(--sl-spacing-small);
  }

  /*
   * Button groups support a variety of button types (e.g. buttons with tooltips, buttons as dropdown triggers, etc.).
   * This means buttons aren't always direct descendants of the button group, thus we can't target them with the
   * ::slotted selector. To work around this, the button group component does some magic to add these special classes to
   * buttons and we style them here instead.
   */

  :host([data-sl-button-group__button--first]:not([data-sl-button-group__button--last])) .button {
    border-start-end-radius: 0;
    border-end-end-radius: 0;
  }

  :host([data-sl-button-group__button--inner]) .button {
    border-radius: 0;
  }

  :host([data-sl-button-group__button--last]:not([data-sl-button-group__button--first])) .button {
    border-start-start-radius: 0;
    border-end-start-radius: 0;
  }

  /* All except the first */
  :host([data-sl-button-group__button]:not([data-sl-button-group__button--first])) {
    margin-inline-start: calc(-1 * var(--sl-input-border-width));
  }

  /* Add a visual separator between solid buttons */
  :host(
      [data-sl-button-group__button]:not(
          [data-sl-button-group__button--first],
          [data-sl-button-group__button--radio],
          [variant='default']
        ):not(:hover)
    )
    .button:after {
    content: '';
    position: absolute;
    top: 0;
    inset-inline-start: 0;
    bottom: 0;
    border-left: solid 1px rgb(128 128 128 / 33%);
    mix-blend-mode: multiply;
  }

  /* Bump hovered, focused, and checked buttons up so their focus ring isn't clipped */
  :host([data-sl-button-group__button--hover]) {
    z-index: 1;
  }

  /* Focus and checked are always on top */
  :host([data-sl-button-group__button--focus]),
  :host([data-sl-button-group__button][checked]) {
    z-index: 2;
  }
`, radio_button_styles_default = i$5`
  ${button_styles_default}

  .button__prefix,
  .button__suffix,
  .button__label {
    display: inline-flex;
    position: relative;
    align-items: center;
  }

  /* We use a hidden input so constraint validation errors work, since they don't appear to show when used with buttons.
    We can't actually hide it, though, otherwise the messages will be suppressed by the browser. */
  .hidden-input {
    all: unset;
    position: absolute;
    top: 0;
    left: 0;
    bottom: 0;
    right: 0;
    outline: dotted 1px red;
    opacity: 0;
    z-index: -1;
  }
`, SlRadioButton = class extends ShoelaceElement {
  constructor() {
    super(...arguments), this.hasSlotController = new HasSlotController(this, "[default]", "prefix", "suffix"), this.hasFocus = !1, this.checked = !1, this.disabled = !1, this.size = "medium", this.pill = !1;
  }
  connectedCallback() {
    super.connectedCallback(), this.setAttribute("role", "presentation");
  }
  handleBlur() {
    this.hasFocus = !1, this.emit("sl-blur");
  }
  handleClick(C) {
    if (this.disabled) {
      C.preventDefault(), C.stopPropagation();
      return;
    }
    this.checked = !0;
  }
  handleFocus() {
    this.hasFocus = !0, this.emit("sl-focus");
  }
  handleDisabledChange() {
    this.setAttribute("aria-disabled", this.disabled ? "true" : "false");
  }
  /** Sets focus on the radio button. */
  focus(C) {
    this.input.focus(C);
  }
  /** Removes focus from the radio button. */
  blur() {
    this.input.blur();
  }
  render() {
    return ke`
      <div part="base" role="presentation">
        <button
          part="${`button${this.checked ? " button--checked" : ""}`}"
          role="radio"
          aria-checked="${this.checked}"
          class=${Rt({
      button: !0,
      "button--default": !0,
      "button--small": this.size === "small",
      "button--medium": this.size === "medium",
      "button--large": this.size === "large",
      "button--checked": this.checked,
      "button--disabled": this.disabled,
      "button--focused": this.hasFocus,
      "button--outline": !0,
      "button--pill": this.pill,
      "button--has-label": this.hasSlotController.test("[default]"),
      "button--has-prefix": this.hasSlotController.test("prefix"),
      "button--has-suffix": this.hasSlotController.test("suffix")
    })}
          aria-disabled=${this.disabled}
          type="button"
          value=${to(this.value)}
          @blur=${this.handleBlur}
          @focus=${this.handleFocus}
          @click=${this.handleClick}
        >
          <slot name="prefix" part="prefix" class="button__prefix"></slot>
          <slot part="label" class="button__label"></slot>
          <slot name="suffix" part="suffix" class="button__suffix"></slot>
        </button>
      </div>
    `;
  }
};
SlRadioButton.styles = [component_styles_default, radio_button_styles_default];
__decorateClass$e([
  e$6(".button")
], SlRadioButton.prototype, "input", 2);
__decorateClass$e([
  e$6(".hidden-input")
], SlRadioButton.prototype, "hiddenInput", 2);
__decorateClass$e([
  r$3()
], SlRadioButton.prototype, "hasFocus", 2);
__decorateClass$e([
  n$1({ type: Boolean, reflect: !0 })
], SlRadioButton.prototype, "checked", 2);
__decorateClass$e([
  n$1()
], SlRadioButton.prototype, "value", 2);
__decorateClass$e([
  n$1({ type: Boolean, reflect: !0 })
], SlRadioButton.prototype, "disabled", 2);
__decorateClass$e([
  n$1({ reflect: !0 })
], SlRadioButton.prototype, "size", 2);
__decorateClass$e([
  n$1({ type: Boolean, reflect: !0 })
], SlRadioButton.prototype, "pill", 2);
__decorateClass$e([
  watch("disabled", { waitUntilFirstUpdate: !0 })
], SlRadioButton.prototype, "handleDisabledChange", 1);
SlRadioButton.define("sl-radio-button");
var radio_group_styles_default = i$5`
  :host {
    display: block;
  }

  .form-control {
    position: relative;
    border: none;
    padding: 0;
    margin: 0;
  }

  .form-control__label {
    padding: 0;
  }

  .radio-group--required .radio-group__label::after {
    content: var(--sl-input-required-content);
    margin-inline-start: var(--sl-input-required-content-offset);
  }

  .visually-hidden {
    position: absolute;
    width: 1px;
    height: 1px;
    padding: 0;
    margin: -1px;
    overflow: hidden;
    clip: rect(0, 0, 0, 0);
    white-space: nowrap;
    border: 0;
  }
`, button_group_styles_default = i$5`
  :host {
    display: inline-block;
  }

  .button-group {
    display: flex;
    flex-wrap: nowrap;
  }
`, SlButtonGroup = class extends ShoelaceElement {
  constructor() {
    super(...arguments), this.disableRole = !1, this.label = "";
  }
  handleFocus(C) {
    const L = findButton(C.target);
    L == null || L.toggleAttribute("data-sl-button-group__button--focus", !0);
  }
  handleBlur(C) {
    const L = findButton(C.target);
    L == null || L.toggleAttribute("data-sl-button-group__button--focus", !1);
  }
  handleMouseOver(C) {
    const L = findButton(C.target);
    L == null || L.toggleAttribute("data-sl-button-group__button--hover", !0);
  }
  handleMouseOut(C) {
    const L = findButton(C.target);
    L == null || L.toggleAttribute("data-sl-button-group__button--hover", !1);
  }
  handleSlotChange() {
    const C = [...this.defaultSlot.assignedElements({ flatten: !0 })];
    C.forEach((L) => {
      const A = C.indexOf(L), W = findButton(L);
      W && (W.toggleAttribute("data-sl-button-group__button", !0), W.toggleAttribute("data-sl-button-group__button--first", A === 0), W.toggleAttribute("data-sl-button-group__button--inner", A > 0 && A < C.length - 1), W.toggleAttribute("data-sl-button-group__button--last", A === C.length - 1), W.toggleAttribute(
        "data-sl-button-group__button--radio",
        W.tagName.toLowerCase() === "sl-radio-button"
      ));
    });
  }
  render() {
    return ke$1`
      <div
        part="base"
        class="button-group"
        role="${this.disableRole ? "presentation" : "group"}"
        aria-label=${this.label}
        @focusout=${this.handleBlur}
        @focusin=${this.handleFocus}
        @mouseover=${this.handleMouseOver}
        @mouseout=${this.handleMouseOut}
      >
        <slot @slotchange=${this.handleSlotChange}></slot>
      </div>
    `;
  }
};
SlButtonGroup.styles = [component_styles_default, button_group_styles_default];
__decorateClass$e([
  e$6("slot")
], SlButtonGroup.prototype, "defaultSlot", 2);
__decorateClass$e([
  r$3()
], SlButtonGroup.prototype, "disableRole", 2);
__decorateClass$e([
  n$1()
], SlButtonGroup.prototype, "label", 2);
function findButton(C) {
  var L;
  const A = "sl-button, sl-radio-button";
  return (L = C.closest(A)) != null ? L : C.querySelector(A);
}
var SlRadioGroup = class extends ShoelaceElement {
  constructor() {
    super(...arguments), this.formControlController = new FormControlController(this), this.hasSlotController = new HasSlotController(this, "help-text", "label"), this.customValidityMessage = "", this.hasButtonGroup = !1, this.errorMessage = "", this.defaultValue = "", this.label = "", this.helpText = "", this.name = "option", this.value = "", this.size = "medium", this.form = "", this.required = !1;
  }
  /** Gets the validity state object */
  get validity() {
    const C = this.required && !this.value;
    return this.customValidityMessage !== "" ? customErrorValidityState : C ? valueMissingValidityState : validValidityState;
  }
  /** Gets the validation message */
  get validationMessage() {
    const C = this.required && !this.value;
    return this.customValidityMessage !== "" ? this.customValidityMessage : C ? this.validationInput.validationMessage : "";
  }
  connectedCallback() {
    super.connectedCallback(), this.defaultValue = this.value;
  }
  firstUpdated() {
    this.formControlController.updateValidity();
  }
  getAllRadios() {
    return [...this.querySelectorAll("sl-radio, sl-radio-button")];
  }
  handleRadioClick(C) {
    const L = C.target.closest("sl-radio, sl-radio-button"), A = this.getAllRadios(), W = this.value;
    !L || L.disabled || (this.value = L.value, A.forEach((X) => X.checked = X === L), this.value !== W && (this.emit("sl-change"), this.emit("sl-input")));
  }
  handleKeyDown(C) {
    var L;
    if (!["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight", " "].includes(C.key))
      return;
    const A = this.getAllRadios().filter((oe) => !oe.disabled), W = (L = A.find((oe) => oe.checked)) != null ? L : A[0], X = C.key === " " ? 0 : ["ArrowUp", "ArrowLeft"].includes(C.key) ? -1 : 1, J = this.value;
    let te = A.indexOf(W) + X;
    te < 0 && (te = A.length - 1), te > A.length - 1 && (te = 0), this.getAllRadios().forEach((oe) => {
      oe.checked = !1, this.hasButtonGroup || oe.setAttribute("tabindex", "-1");
    }), this.value = A[te].value, A[te].checked = !0, this.hasButtonGroup ? A[te].shadowRoot.querySelector("button").focus() : (A[te].setAttribute("tabindex", "0"), A[te].focus()), this.value !== J && (this.emit("sl-change"), this.emit("sl-input")), C.preventDefault();
  }
  handleLabelClick() {
    const C = this.getAllRadios(), A = C.find((W) => W.checked) || C[0];
    A && A.focus();
  }
  handleInvalid(C) {
    this.formControlController.setValidity(!1), this.formControlController.emitInvalidEvent(C);
  }
  async syncRadioElements() {
    var C, L;
    const A = this.getAllRadios();
    if (await Promise.all(
      // Sync the checked state and size
      A.map(async (W) => {
        await W.updateComplete, W.checked = W.value === this.value, W.size = this.size;
      })
    ), this.hasButtonGroup = A.some((W) => W.tagName.toLowerCase() === "sl-radio-button"), A.length > 0 && !A.some((W) => W.checked))
      if (this.hasButtonGroup) {
        const W = (C = A[0].shadowRoot) == null ? void 0 : C.querySelector("button");
        W && W.setAttribute("tabindex", "0");
      } else
        A[0].setAttribute("tabindex", "0");
    if (this.hasButtonGroup) {
      const W = (L = this.shadowRoot) == null ? void 0 : L.querySelector("sl-button-group");
      W && (W.disableRole = !0);
    }
  }
  syncRadios() {
    if (customElements.get("sl-radio") && customElements.get("sl-radio-button")) {
      this.syncRadioElements();
      return;
    }
    customElements.get("sl-radio") ? this.syncRadioElements() : customElements.whenDefined("sl-radio").then(() => this.syncRadios()), customElements.get("sl-radio-button") ? this.syncRadioElements() : customElements.whenDefined("sl-radio-button").then(() => this.syncRadios());
  }
  updateCheckedRadio() {
    this.getAllRadios().forEach((L) => L.checked = L.value === this.value), this.formControlController.setValidity(this.validity.valid);
  }
  handleSizeChange() {
    this.syncRadios();
  }
  handleValueChange() {
    this.hasUpdated && this.updateCheckedRadio();
  }
  /** Checks for validity but does not show a validation message. Returns `true` when valid and `false` when invalid. */
  checkValidity() {
    const C = this.required && !this.value, L = this.customValidityMessage !== "";
    return C || L ? (this.formControlController.emitInvalidEvent(), !1) : !0;
  }
  /** Gets the associated form, if one exists. */
  getForm() {
    return this.formControlController.getForm();
  }
  /** Checks for validity and shows the browser's validation message if the control is invalid. */
  reportValidity() {
    const C = this.validity.valid;
    return this.errorMessage = this.customValidityMessage || C ? "" : this.validationInput.validationMessage, this.formControlController.setValidity(C), this.validationInput.hidden = !0, clearTimeout(this.validationTimeout), C || (this.validationInput.hidden = !1, this.validationInput.reportValidity(), this.validationTimeout = setTimeout(() => this.validationInput.hidden = !0, 1e4)), C;
  }
  /** Sets a custom validation message. Pass an empty string to restore validity. */
  setCustomValidity(C = "") {
    this.customValidityMessage = C, this.errorMessage = C, this.validationInput.setCustomValidity(C), this.formControlController.updateValidity();
  }
  render() {
    const C = this.hasSlotController.test("label"), L = this.hasSlotController.test("help-text"), A = this.label ? !0 : !!C, W = this.helpText ? !0 : !!L, X = ke$1`
      <slot @slotchange=${this.syncRadios} @click=${this.handleRadioClick} @keydown=${this.handleKeyDown}></slot>
    `;
    return ke$1`
      <fieldset
        part="form-control"
        class=${Rt({
      "form-control": !0,
      "form-control--small": this.size === "small",
      "form-control--medium": this.size === "medium",
      "form-control--large": this.size === "large",
      "form-control--radio-group": !0,
      "form-control--has-label": A,
      "form-control--has-help-text": W
    })}
        role="radiogroup"
        aria-labelledby="label"
        aria-describedby="help-text"
        aria-errormessage="error-message"
      >
        <label
          part="form-control-label"
          id="label"
          class="form-control__label"
          aria-hidden=${A ? "false" : "true"}
          @click=${this.handleLabelClick}
        >
          <slot name="label">${this.label}</slot>
        </label>

        <div part="form-control-input" class="form-control-input">
          <div class="visually-hidden">
            <div id="error-message" aria-live="assertive">${this.errorMessage}</div>
            <label class="radio-group__validation">
              <input
                type="text"
                class="radio-group__validation-input"
                ?required=${this.required}
                tabindex="-1"
                hidden
                @invalid=${this.handleInvalid}
              />
            </label>
          </div>

          ${this.hasButtonGroup ? ke$1`
                <sl-button-group part="button-group" exportparts="base:button-group__base" role="presentation">
                  ${X}
                </sl-button-group>
              ` : X}
        </div>

        <div
          part="form-control-help-text"
          id="help-text"
          class="form-control__help-text"
          aria-hidden=${W ? "false" : "true"}
        >
          <slot name="help-text">${this.helpText}</slot>
        </div>
      </fieldset>
    `;
  }
};
SlRadioGroup.styles = [component_styles_default, form_control_styles_default, radio_group_styles_default];
SlRadioGroup.dependencies = { "sl-button-group": SlButtonGroup };
__decorateClass$e([
  e$6("slot:not([name])")
], SlRadioGroup.prototype, "defaultSlot", 2);
__decorateClass$e([
  e$6(".radio-group__validation-input")
], SlRadioGroup.prototype, "validationInput", 2);
__decorateClass$e([
  r$3()
], SlRadioGroup.prototype, "hasButtonGroup", 2);
__decorateClass$e([
  r$3()
], SlRadioGroup.prototype, "errorMessage", 2);
__decorateClass$e([
  r$3()
], SlRadioGroup.prototype, "defaultValue", 2);
__decorateClass$e([
  n$1()
], SlRadioGroup.prototype, "label", 2);
__decorateClass$e([
  n$1({ attribute: "help-text" })
], SlRadioGroup.prototype, "helpText", 2);
__decorateClass$e([
  n$1()
], SlRadioGroup.prototype, "name", 2);
__decorateClass$e([
  n$1({ reflect: !0 })
], SlRadioGroup.prototype, "value", 2);
__decorateClass$e([
  n$1({ reflect: !0 })
], SlRadioGroup.prototype, "size", 2);
__decorateClass$e([
  n$1({ reflect: !0 })
], SlRadioGroup.prototype, "form", 2);
__decorateClass$e([
  n$1({ type: Boolean, reflect: !0 })
], SlRadioGroup.prototype, "required", 2);
__decorateClass$e([
  watch("size", { waitUntilFirstUpdate: !0 })
], SlRadioGroup.prototype, "handleSizeChange", 1);
__decorateClass$e([
  watch("value")
], SlRadioGroup.prototype, "handleValueChange", 1);
SlRadioGroup.define("sl-radio-group");
var progress_ring_styles_default = i$5`
  :host {
    --size: 128px;
    --track-width: 4px;
    --track-color: var(--sl-color-neutral-200);
    --indicator-width: var(--track-width);
    --indicator-color: var(--sl-color-primary-600);
    --indicator-transition-duration: 0.35s;

    display: inline-flex;
  }

  .progress-ring {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    position: relative;
  }

  .progress-ring__image {
    width: var(--size);
    height: var(--size);
    rotate: -90deg;
    transform-origin: 50% 50%;
  }

  .progress-ring__track,
  .progress-ring__indicator {
    --radius: calc(var(--size) / 2 - max(var(--track-width), var(--indicator-width)) * 0.5);
    --circumference: calc(var(--radius) * 2 * 3.141592654);

    fill: none;
    r: var(--radius);
    cx: calc(var(--size) / 2);
    cy: calc(var(--size) / 2);
  }

  .progress-ring__track {
    stroke: var(--track-color);
    stroke-width: var(--track-width);
  }

  .progress-ring__indicator {
    stroke: var(--indicator-color);
    stroke-width: var(--indicator-width);
    stroke-linecap: round;
    transition-property: stroke-dashoffset;
    transition-duration: var(--indicator-transition-duration);
    stroke-dasharray: var(--circumference) var(--circumference);
    stroke-dashoffset: calc(var(--circumference) - var(--percentage) * var(--circumference));
  }

  .progress-ring__label {
    display: flex;
    align-items: center;
    justify-content: center;
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    text-align: center;
    user-select: none;
    -webkit-user-select: none;
  }
`, SlProgressRing = class extends ShoelaceElement {
  constructor() {
    super(...arguments), this.localize = new LocalizeController(this), this.value = 0, this.label = "";
  }
  updated(C) {
    if (super.updated(C), C.has("value")) {
      const L = parseFloat(getComputedStyle(this.indicator).getPropertyValue("r")), A = 2 * Math.PI * L, W = A - this.value / 100 * A;
      this.indicatorOffset = `${W}px`;
    }
  }
  render() {
    return ke$1`
      <div
        part="base"
        class="progress-ring"
        role="progressbar"
        aria-label=${this.label.length > 0 ? this.label : this.localize.term("progress")}
        aria-describedby="label"
        aria-valuemin="0"
        aria-valuemax="100"
        aria-valuenow="${this.value}"
        style="--percentage: ${this.value / 100}"
      >
        <svg class="progress-ring__image">
          <circle class="progress-ring__track"></circle>
          <circle class="progress-ring__indicator" style="stroke-dashoffset: ${this.indicatorOffset}"></circle>
        </svg>

        <slot id="label" part="label" class="progress-ring__label"></slot>
      </div>
    `;
  }
};
SlProgressRing.styles = [component_styles_default, progress_ring_styles_default];
__decorateClass$e([
  e$6(".progress-ring__indicator")
], SlProgressRing.prototype, "indicator", 2);
__decorateClass$e([
  r$3()
], SlProgressRing.prototype, "indicatorOffset", 2);
__decorateClass$e([
  n$1({ type: Number, reflect: !0 })
], SlProgressRing.prototype, "value", 2);
__decorateClass$e([
  n$1()
], SlProgressRing.prototype, "label", 2);
SlProgressRing.define("sl-progress-ring");
var qr_code_styles_default = i$5`
  :host {
    display: inline-block;
  }
`;
let G = null;
class H {
}
H.render = function(C, L) {
  G(C, L);
};
self.QrCreator = H;
(function(C) {
  function L(oe, ne, re, ce) {
    var ue = {}, de = C(re, ne);
    de.u(oe), de.J(), ce = ce || 0;
    var be = de.h(), pe = de.h() + 2 * ce;
    return ue.text = oe, ue.level = ne, ue.version = re, ue.O = pe, ue.a = function(me, Me) {
      return me -= ce, Me -= ce, 0 > me || me >= be || 0 > Me || Me >= be ? !1 : de.a(me, Me);
    }, ue;
  }
  function A(oe, ne, re, ce, ue, de, be, pe, me, Me) {
    function he(ge, Ce, Se, Ae, Le, ve, De) {
      ge ? (oe.lineTo(Ce + ve, Se + De), oe.arcTo(Ce, Se, Ae, Le, de)) : oe.lineTo(Ce, Se);
    }
    be ? oe.moveTo(ne + de, re) : oe.moveTo(ne, re), he(pe, ce, re, ce, ue, -de, 0), he(me, ce, ue, ne, ue, 0, -de), he(Me, ne, ue, ne, re, de, 0), he(be, ne, re, ce, re, 0, de);
  }
  function W(oe, ne, re, ce, ue, de, be, pe, me, Me) {
    function he(ge, Ce, Se, Ae) {
      oe.moveTo(ge + Se, Ce), oe.lineTo(
        ge,
        Ce
      ), oe.lineTo(ge, Ce + Ae), oe.arcTo(ge, Ce, ge + Se, Ce, de);
    }
    be && he(ne, re, de, de), pe && he(ce, re, -de, de), me && he(ce, ue, -de, -de), Me && he(ne, ue, de, -de);
  }
  function X(oe, ne) {
    var re = ne.fill;
    if (typeof re == "string") oe.fillStyle = re;
    else {
      var ce = re.type, ue = re.colorStops;
      if (re = re.position.map((be) => Math.round(be * ne.size)), ce === "linear-gradient") var de = oe.createLinearGradient.apply(oe, re);
      else if (ce === "radial-gradient") de = oe.createRadialGradient.apply(oe, re);
      else throw Error("Unsupported fill");
      ue.forEach(([be, pe]) => {
        de.addColorStop(be, pe);
      }), oe.fillStyle = de;
    }
  }
  function J(oe, ne) {
    e: {
      var re = ne.text, ce = ne.v, ue = ne.N, de = ne.K, be = ne.P;
      for (ue = Math.max(1, ue || 1), de = Math.min(40, de || 40); ue <= de; ue += 1) try {
        var pe = L(re, ce, ue, be);
        break e;
      } catch {
      }
      pe = void 0;
    }
    if (!pe) return null;
    for (re = oe.getContext("2d"), ne.background && (re.fillStyle = ne.background, re.fillRect(ne.left, ne.top, ne.size, ne.size)), ce = pe.O, de = ne.size / ce, re.beginPath(), be = 0; be < ce; be += 1) for (ue = 0; ue < ce; ue += 1) {
      var me = re, Me = ne.left + ue * de, he = ne.top + be * de, ge = be, Ce = ue, Se = pe.a, Ae = Me + de, Le = he + de, ve = ge - 1, De = ge + 1, Ue = Ce - 1, Fe = Ce + 1, We = Math.floor(Math.min(0.5, Math.max(0, ne.R)) * de), Ke = Se(ge, Ce), it = Se(ve, Ue), Qe = Se(ve, Ce);
      ve = Se(ve, Fe);
      var vt = Se(ge, Fe);
      Fe = Se(De, Fe), Ce = Se(
        De,
        Ce
      ), De = Se(De, Ue), ge = Se(ge, Ue), Me = Math.round(Me), he = Math.round(he), Ae = Math.round(Ae), Le = Math.round(Le), Ke ? A(me, Me, he, Ae, Le, We, !Qe && !ge, !Qe && !vt, !Ce && !vt, !Ce && !ge) : W(me, Me, he, Ae, Le, We, Qe && ge && it, Qe && vt && ve, Ce && vt && Fe, Ce && ge && De);
    }
    return X(re, ne), re.fill(), oe;
  }
  var te = { minVersion: 1, maxVersion: 40, ecLevel: "L", left: 0, top: 0, size: 200, fill: "#000", background: null, text: "no text", radius: 0.5, quiet: 0 };
  G = function(oe, ne) {
    var re = {};
    Object.assign(re, te, oe), re.N = re.minVersion, re.K = re.maxVersion, re.v = re.ecLevel, re.left = re.left, re.top = re.top, re.size = re.size, re.fill = re.fill, re.background = re.background, re.text = re.text, re.R = re.radius, re.P = re.quiet, ne instanceof HTMLCanvasElement ? ((ne.width !== re.size || ne.height !== re.size) && (ne.width = re.size, ne.height = re.size), ne.getContext("2d").clearRect(0, 0, ne.width, ne.height), J(ne, re)) : (oe = document.createElement("canvas"), oe.width = re.size, oe.height = re.size, re = J(oe, re), ne.appendChild(re));
  };
})(function() {
  function C(ne) {
    var re = A.s(ne);
    return { S: function() {
      return 4;
    }, b: function() {
      return re.length;
    }, write: function(ce) {
      for (var ue = 0; ue < re.length; ue += 1) ce.put(re[ue], 8);
    } };
  }
  function L() {
    var ne = [], re = 0, ce = {
      B: function() {
        return ne;
      },
      c: function(ue) {
        return (ne[Math.floor(ue / 8)] >>> 7 - ue % 8 & 1) == 1;
      },
      put: function(ue, de) {
        for (var be = 0; be < de; be += 1) ce.m((ue >>> de - be - 1 & 1) == 1);
      },
      f: function() {
        return re;
      },
      m: function(ue) {
        var de = Math.floor(re / 8);
        ne.length <= de && ne.push(0), ue && (ne[de] |= 128 >>> re % 8), re += 1;
      }
    };
    return ce;
  }
  function A(ne, re) {
    function ce(ge, Ce) {
      for (var Se = -1; 7 >= Se; Se += 1) if (!(-1 >= ge + Se || pe <= ge + Se)) for (var Ae = -1; 7 >= Ae; Ae += 1) -1 >= Ce + Ae || pe <= Ce + Ae || (be[ge + Se][Ce + Ae] = 0 <= Se && 6 >= Se && (Ae == 0 || Ae == 6) || 0 <= Ae && 6 >= Ae && (Se == 0 || Se == 6) || 2 <= Se && 4 >= Se && 2 <= Ae && 4 >= Ae);
    }
    function ue(ge, Ce) {
      for (var Se = pe = 4 * ne + 17, Ae = Array(Se), Le = 0; Le < Se; Le += 1) {
        Ae[Le] = Array(Se);
        for (var ve = 0; ve < Se; ve += 1) Ae[Le][ve] = null;
      }
      for (be = Ae, ce(0, 0), ce(pe - 7, 0), ce(0, pe - 7), Se = J.G(ne), Ae = 0; Ae < Se.length; Ae += 1) for (Le = 0; Le < Se.length; Le += 1) {
        ve = Se[Ae];
        var De = Se[Le];
        if (be[ve][De] == null) for (var Ue = -2; 2 >= Ue; Ue += 1) for (var Fe = -2; 2 >= Fe; Fe += 1) be[ve + Ue][De + Fe] = Ue == -2 || Ue == 2 || Fe == -2 || Fe == 2 || Ue == 0 && Fe == 0;
      }
      for (Se = 8; Se < pe - 8; Se += 1) be[Se][6] == null && (be[Se][6] = Se % 2 == 0);
      for (Se = 8; Se < pe - 8; Se += 1) be[6][Se] == null && (be[6][Se] = Se % 2 == 0);
      for (Se = J.w(de << 3 | Ce), Ae = 0; 15 > Ae; Ae += 1) Le = !ge && (Se >> Ae & 1) == 1, be[6 > Ae ? Ae : 8 > Ae ? Ae + 1 : pe - 15 + Ae][8] = Le, be[8][8 > Ae ? pe - Ae - 1 : 9 > Ae ? 15 - Ae : 14 - Ae] = Le;
      if (be[pe - 8][8] = !ge, 7 <= ne) {
        for (Se = J.A(ne), Ae = 0; 18 > Ae; Ae += 1) Le = !ge && (Se >> Ae & 1) == 1, be[Math.floor(Ae / 3)][Ae % 3 + pe - 8 - 3] = Le;
        for (Ae = 0; 18 > Ae; Ae += 1) Le = !ge && (Se >> Ae & 1) == 1, be[Ae % 3 + pe - 8 - 3][Math.floor(Ae / 3)] = Le;
      }
      if (me == null) {
        for (ge = oe.I(ne, de), Se = L(), Ae = 0; Ae < Me.length; Ae += 1) Le = Me[Ae], Se.put(4, 4), Se.put(Le.b(), J.f(4, ne)), Le.write(Se);
        for (Ae = Le = 0; Ae < ge.length; Ae += 1) Le += ge[Ae].j;
        if (Se.f() > 8 * Le) throw Error("code length overflow. (" + Se.f() + ">" + 8 * Le + ")");
        for (Se.f() + 4 <= 8 * Le && Se.put(0, 4); Se.f() % 8 != 0; ) Se.m(!1);
        for (; !(Se.f() >= 8 * Le) && (Se.put(236, 8), !(Se.f() >= 8 * Le)); )
          Se.put(17, 8);
        var We = 0;
        for (Le = Ae = 0, ve = Array(ge.length), De = Array(ge.length), Ue = 0; Ue < ge.length; Ue += 1) {
          var Ke = ge[Ue].j, it = ge[Ue].o - Ke;
          for (Ae = Math.max(Ae, Ke), Le = Math.max(Le, it), ve[Ue] = Array(Ke), Fe = 0; Fe < ve[Ue].length; Fe += 1) ve[Ue][Fe] = 255 & Se.B()[Fe + We];
          for (We += Ke, Fe = J.C(it), Ke = W(ve[Ue], Fe.b() - 1).l(Fe), De[Ue] = Array(Fe.b() - 1), Fe = 0; Fe < De[Ue].length; Fe += 1) it = Fe + Ke.b() - De[Ue].length, De[Ue][Fe] = 0 <= it ? Ke.c(it) : 0;
        }
        for (Fe = Se = 0; Fe < ge.length; Fe += 1) Se += ge[Fe].o;
        for (Se = Array(Se), Fe = We = 0; Fe < Ae; Fe += 1) for (Ue = 0; Ue < ge.length; Ue += 1) Fe < ve[Ue].length && (Se[We] = ve[Ue][Fe], We += 1);
        for (Fe = 0; Fe < Le; Fe += 1) for (Ue = 0; Ue < ge.length; Ue += 1) Fe < De[Ue].length && (Se[We] = De[Ue][Fe], We += 1);
        me = Se;
      }
      for (ge = me, Se = -1, Ae = pe - 1, Le = 7, ve = 0, Ce = J.F(Ce), De = pe - 1; 0 < De; De -= 2) for (De == 6 && --De; ; ) {
        for (Ue = 0; 2 > Ue; Ue += 1) be[Ae][De - Ue] == null && (Fe = !1, ve < ge.length && (Fe = (ge[ve] >>> Le & 1) == 1), Ce(Ae, De - Ue) && (Fe = !Fe), be[Ae][De - Ue] = Fe, --Le, Le == -1 && (ve += 1, Le = 7));
        if (Ae += Se, 0 > Ae || pe <= Ae) {
          Ae -= Se, Se = -Se;
          break;
        }
      }
    }
    var de = X[re], be = null, pe = 0, me = null, Me = [], he = { u: function(ge) {
      ge = C(ge), Me.push(ge), me = null;
    }, a: function(ge, Ce) {
      if (0 > ge || pe <= ge || 0 > Ce || pe <= Ce) throw Error(ge + "," + Ce);
      return be[ge][Ce];
    }, h: function() {
      return pe;
    }, J: function() {
      for (var ge = 0, Ce = 0, Se = 0; 8 > Se; Se += 1) {
        ue(!0, Se);
        var Ae = J.D(he);
        (Se == 0 || ge > Ae) && (ge = Ae, Ce = Se);
      }
      ue(!1, Ce);
    } };
    return he;
  }
  function W(ne, re) {
    if (typeof ne.length > "u") throw Error(ne.length + "/" + re);
    var ce = function() {
      for (var de = 0; de < ne.length && ne[de] == 0; ) de += 1;
      for (var be = Array(ne.length - de + re), pe = 0; pe < ne.length - de; pe += 1) be[pe] = ne[pe + de];
      return be;
    }(), ue = { c: function(de) {
      return ce[de];
    }, b: function() {
      return ce.length;
    }, multiply: function(de) {
      for (var be = Array(ue.b() + de.b() - 1), pe = 0; pe < ue.b(); pe += 1) for (var me = 0; me < de.b(); me += 1) be[pe + me] ^= te.i(te.g(ue.c(pe)) + te.g(de.c(me)));
      return W(be, 0);
    }, l: function(de) {
      if (0 > ue.b() - de.b()) return ue;
      for (var be = te.g(ue.c(0)) - te.g(de.c(0)), pe = Array(ue.b()), me = 0; me < ue.b(); me += 1) pe[me] = ue.c(me);
      for (me = 0; me < de.b(); me += 1) pe[me] ^= te.i(te.g(de.c(me)) + be);
      return W(pe, 0).l(de);
    } };
    return ue;
  }
  A.s = function(ne) {
    for (var re = [], ce = 0; ce < ne.length; ce++) {
      var ue = ne.charCodeAt(ce);
      128 > ue ? re.push(ue) : 2048 > ue ? re.push(192 | ue >> 6, 128 | ue & 63) : 55296 > ue || 57344 <= ue ? re.push(224 | ue >> 12, 128 | ue >> 6 & 63, 128 | ue & 63) : (ce++, ue = 65536 + ((ue & 1023) << 10 | ne.charCodeAt(ce) & 1023), re.push(240 | ue >> 18, 128 | ue >> 12 & 63, 128 | ue >> 6 & 63, 128 | ue & 63));
    }
    return re;
  };
  var X = { L: 1, M: 0, Q: 3, H: 2 }, J = /* @__PURE__ */ function() {
    function ne(ue) {
      for (var de = 0; ue != 0; ) de += 1, ue >>>= 1;
      return de;
    }
    var re = [
      [],
      [6, 18],
      [6, 22],
      [6, 26],
      [6, 30],
      [6, 34],
      [6, 22, 38],
      [6, 24, 42],
      [6, 26, 46],
      [6, 28, 50],
      [6, 30, 54],
      [6, 32, 58],
      [6, 34, 62],
      [6, 26, 46, 66],
      [6, 26, 48, 70],
      [6, 26, 50, 74],
      [6, 30, 54, 78],
      [6, 30, 56, 82],
      [6, 30, 58, 86],
      [6, 34, 62, 90],
      [6, 28, 50, 72, 94],
      [6, 26, 50, 74, 98],
      [6, 30, 54, 78, 102],
      [6, 28, 54, 80, 106],
      [6, 32, 58, 84, 110],
      [6, 30, 58, 86, 114],
      [6, 34, 62, 90, 118],
      [6, 26, 50, 74, 98, 122],
      [6, 30, 54, 78, 102, 126],
      [6, 26, 52, 78, 104, 130],
      [6, 30, 56, 82, 108, 134],
      [6, 34, 60, 86, 112, 138],
      [6, 30, 58, 86, 114, 142],
      [6, 34, 62, 90, 118, 146],
      [6, 30, 54, 78, 102, 126, 150],
      [6, 24, 50, 76, 102, 128, 154],
      [6, 28, 54, 80, 106, 132, 158],
      [6, 32, 58, 84, 110, 136, 162],
      [6, 26, 54, 82, 110, 138, 166],
      [6, 30, 58, 86, 114, 142, 170]
    ], ce = { w: function(ue) {
      for (var de = ue << 10; 0 <= ne(de) - ne(1335); ) de ^= 1335 << ne(de) - ne(1335);
      return (ue << 10 | de) ^ 21522;
    }, A: function(ue) {
      for (var de = ue << 12; 0 <= ne(de) - ne(7973); ) de ^= 7973 << ne(de) - ne(7973);
      return ue << 12 | de;
    }, G: function(ue) {
      return re[ue - 1];
    }, F: function(ue) {
      switch (ue) {
        case 0:
          return function(de, be) {
            return (de + be) % 2 == 0;
          };
        case 1:
          return function(de) {
            return de % 2 == 0;
          };
        case 2:
          return function(de, be) {
            return be % 3 == 0;
          };
        case 3:
          return function(de, be) {
            return (de + be) % 3 == 0;
          };
        case 4:
          return function(de, be) {
            return (Math.floor(de / 2) + Math.floor(be / 3)) % 2 == 0;
          };
        case 5:
          return function(de, be) {
            return de * be % 2 + de * be % 3 == 0;
          };
        case 6:
          return function(de, be) {
            return (de * be % 2 + de * be % 3) % 2 == 0;
          };
        case 7:
          return function(de, be) {
            return (de * be % 3 + (de + be) % 2) % 2 == 0;
          };
        default:
          throw Error("bad maskPattern:" + ue);
      }
    }, C: function(ue) {
      for (var de = W([1], 0), be = 0; be < ue; be += 1) de = de.multiply(W([1, te.i(be)], 0));
      return de;
    }, f: function(ue, de) {
      if (ue != 4 || 1 > de || 40 < de) throw Error("mode: " + ue + "; type: " + de);
      return 10 > de ? 8 : 16;
    }, D: function(ue) {
      for (var de = ue.h(), be = 0, pe = 0; pe < de; pe += 1) for (var me = 0; me < de; me += 1) {
        for (var Me = 0, he = ue.a(pe, me), ge = -1; 1 >= ge; ge += 1) if (!(0 > pe + ge || de <= pe + ge)) for (var Ce = -1; 1 >= Ce; Ce += 1) 0 > me + Ce || de <= me + Ce || (ge != 0 || Ce != 0) && he == ue.a(pe + ge, me + Ce) && (Me += 1);
        5 < Me && (be += 3 + Me - 5);
      }
      for (pe = 0; pe < de - 1; pe += 1) for (me = 0; me < de - 1; me += 1) Me = 0, ue.a(pe, me) && (Me += 1), ue.a(pe + 1, me) && (Me += 1), ue.a(pe, me + 1) && (Me += 1), ue.a(pe + 1, me + 1) && (Me += 1), (Me == 0 || Me == 4) && (be += 3);
      for (pe = 0; pe < de; pe += 1) for (me = 0; me < de - 6; me += 1) ue.a(pe, me) && !ue.a(pe, me + 1) && ue.a(pe, me + 2) && ue.a(pe, me + 3) && ue.a(pe, me + 4) && !ue.a(pe, me + 5) && ue.a(pe, me + 6) && (be += 40);
      for (me = 0; me < de; me += 1) for (pe = 0; pe < de - 6; pe += 1) ue.a(pe, me) && !ue.a(pe + 1, me) && ue.a(pe + 2, me) && ue.a(pe + 3, me) && ue.a(pe + 4, me) && !ue.a(pe + 5, me) && ue.a(pe + 6, me) && (be += 40);
      for (me = Me = 0; me < de; me += 1) for (pe = 0; pe < de; pe += 1) ue.a(pe, me) && (Me += 1);
      return be += Math.abs(100 * Me / de / de - 50) / 5 * 10;
    } };
    return ce;
  }(), te = function() {
    for (var ne = Array(256), re = Array(256), ce = 0; 8 > ce; ce += 1) ne[ce] = 1 << ce;
    for (ce = 8; 256 > ce; ce += 1) ne[ce] = ne[ce - 4] ^ ne[ce - 5] ^ ne[ce - 6] ^ ne[ce - 8];
    for (ce = 0; 255 > ce; ce += 1) re[ne[ce]] = ce;
    return { g: function(ue) {
      if (1 > ue) throw Error("glog(" + ue + ")");
      return re[ue];
    }, i: function(ue) {
      for (; 0 > ue; ) ue += 255;
      for (; 256 <= ue; ) ue -= 255;
      return ne[ue];
    } };
  }(), oe = /* @__PURE__ */ function() {
    function ne(ue, de) {
      switch (de) {
        case X.L:
          return re[4 * (ue - 1)];
        case X.M:
          return re[4 * (ue - 1) + 1];
        case X.Q:
          return re[4 * (ue - 1) + 2];
        case X.H:
          return re[4 * (ue - 1) + 3];
      }
    }
    var re = [
      [1, 26, 19],
      [1, 26, 16],
      [1, 26, 13],
      [1, 26, 9],
      [1, 44, 34],
      [1, 44, 28],
      [1, 44, 22],
      [1, 44, 16],
      [1, 70, 55],
      [1, 70, 44],
      [2, 35, 17],
      [2, 35, 13],
      [1, 100, 80],
      [2, 50, 32],
      [2, 50, 24],
      [4, 25, 9],
      [1, 134, 108],
      [2, 67, 43],
      [2, 33, 15, 2, 34, 16],
      [2, 33, 11, 2, 34, 12],
      [2, 86, 68],
      [4, 43, 27],
      [4, 43, 19],
      [4, 43, 15],
      [2, 98, 78],
      [4, 49, 31],
      [2, 32, 14, 4, 33, 15],
      [4, 39, 13, 1, 40, 14],
      [2, 121, 97],
      [2, 60, 38, 2, 61, 39],
      [4, 40, 18, 2, 41, 19],
      [4, 40, 14, 2, 41, 15],
      [2, 146, 116],
      [
        3,
        58,
        36,
        2,
        59,
        37
      ],
      [4, 36, 16, 4, 37, 17],
      [4, 36, 12, 4, 37, 13],
      [2, 86, 68, 2, 87, 69],
      [4, 69, 43, 1, 70, 44],
      [6, 43, 19, 2, 44, 20],
      [6, 43, 15, 2, 44, 16],
      [4, 101, 81],
      [1, 80, 50, 4, 81, 51],
      [4, 50, 22, 4, 51, 23],
      [3, 36, 12, 8, 37, 13],
      [2, 116, 92, 2, 117, 93],
      [6, 58, 36, 2, 59, 37],
      [4, 46, 20, 6, 47, 21],
      [7, 42, 14, 4, 43, 15],
      [4, 133, 107],
      [8, 59, 37, 1, 60, 38],
      [8, 44, 20, 4, 45, 21],
      [12, 33, 11, 4, 34, 12],
      [3, 145, 115, 1, 146, 116],
      [4, 64, 40, 5, 65, 41],
      [11, 36, 16, 5, 37, 17],
      [11, 36, 12, 5, 37, 13],
      [5, 109, 87, 1, 110, 88],
      [5, 65, 41, 5, 66, 42],
      [5, 54, 24, 7, 55, 25],
      [11, 36, 12, 7, 37, 13],
      [5, 122, 98, 1, 123, 99],
      [
        7,
        73,
        45,
        3,
        74,
        46
      ],
      [15, 43, 19, 2, 44, 20],
      [3, 45, 15, 13, 46, 16],
      [1, 135, 107, 5, 136, 108],
      [10, 74, 46, 1, 75, 47],
      [1, 50, 22, 15, 51, 23],
      [2, 42, 14, 17, 43, 15],
      [5, 150, 120, 1, 151, 121],
      [9, 69, 43, 4, 70, 44],
      [17, 50, 22, 1, 51, 23],
      [2, 42, 14, 19, 43, 15],
      [3, 141, 113, 4, 142, 114],
      [3, 70, 44, 11, 71, 45],
      [17, 47, 21, 4, 48, 22],
      [9, 39, 13, 16, 40, 14],
      [3, 135, 107, 5, 136, 108],
      [3, 67, 41, 13, 68, 42],
      [15, 54, 24, 5, 55, 25],
      [15, 43, 15, 10, 44, 16],
      [4, 144, 116, 4, 145, 117],
      [17, 68, 42],
      [17, 50, 22, 6, 51, 23],
      [19, 46, 16, 6, 47, 17],
      [2, 139, 111, 7, 140, 112],
      [17, 74, 46],
      [7, 54, 24, 16, 55, 25],
      [34, 37, 13],
      [
        4,
        151,
        121,
        5,
        152,
        122
      ],
      [4, 75, 47, 14, 76, 48],
      [11, 54, 24, 14, 55, 25],
      [16, 45, 15, 14, 46, 16],
      [6, 147, 117, 4, 148, 118],
      [6, 73, 45, 14, 74, 46],
      [11, 54, 24, 16, 55, 25],
      [30, 46, 16, 2, 47, 17],
      [8, 132, 106, 4, 133, 107],
      [8, 75, 47, 13, 76, 48],
      [7, 54, 24, 22, 55, 25],
      [22, 45, 15, 13, 46, 16],
      [10, 142, 114, 2, 143, 115],
      [19, 74, 46, 4, 75, 47],
      [28, 50, 22, 6, 51, 23],
      [33, 46, 16, 4, 47, 17],
      [8, 152, 122, 4, 153, 123],
      [22, 73, 45, 3, 74, 46],
      [8, 53, 23, 26, 54, 24],
      [12, 45, 15, 28, 46, 16],
      [3, 147, 117, 10, 148, 118],
      [3, 73, 45, 23, 74, 46],
      [4, 54, 24, 31, 55, 25],
      [11, 45, 15, 31, 46, 16],
      [7, 146, 116, 7, 147, 117],
      [21, 73, 45, 7, 74, 46],
      [1, 53, 23, 37, 54, 24],
      [19, 45, 15, 26, 46, 16],
      [5, 145, 115, 10, 146, 116],
      [19, 75, 47, 10, 76, 48],
      [15, 54, 24, 25, 55, 25],
      [23, 45, 15, 25, 46, 16],
      [13, 145, 115, 3, 146, 116],
      [2, 74, 46, 29, 75, 47],
      [42, 54, 24, 1, 55, 25],
      [23, 45, 15, 28, 46, 16],
      [17, 145, 115],
      [10, 74, 46, 23, 75, 47],
      [10, 54, 24, 35, 55, 25],
      [19, 45, 15, 35, 46, 16],
      [17, 145, 115, 1, 146, 116],
      [14, 74, 46, 21, 75, 47],
      [29, 54, 24, 19, 55, 25],
      [11, 45, 15, 46, 46, 16],
      [13, 145, 115, 6, 146, 116],
      [14, 74, 46, 23, 75, 47],
      [44, 54, 24, 7, 55, 25],
      [59, 46, 16, 1, 47, 17],
      [12, 151, 121, 7, 152, 122],
      [12, 75, 47, 26, 76, 48],
      [39, 54, 24, 14, 55, 25],
      [22, 45, 15, 41, 46, 16],
      [6, 151, 121, 14, 152, 122],
      [6, 75, 47, 34, 76, 48],
      [46, 54, 24, 10, 55, 25],
      [2, 45, 15, 64, 46, 16],
      [17, 152, 122, 4, 153, 123],
      [29, 74, 46, 14, 75, 47],
      [49, 54, 24, 10, 55, 25],
      [24, 45, 15, 46, 46, 16],
      [4, 152, 122, 18, 153, 123],
      [13, 74, 46, 32, 75, 47],
      [48, 54, 24, 14, 55, 25],
      [42, 45, 15, 32, 46, 16],
      [20, 147, 117, 4, 148, 118],
      [40, 75, 47, 7, 76, 48],
      [43, 54, 24, 22, 55, 25],
      [10, 45, 15, 67, 46, 16],
      [19, 148, 118, 6, 149, 119],
      [18, 75, 47, 31, 76, 48],
      [34, 54, 24, 34, 55, 25],
      [20, 45, 15, 61, 46, 16]
    ], ce = { I: function(ue, de) {
      var be = ne(ue, de);
      if (typeof be > "u") throw Error("bad rs block @ typeNumber:" + ue + "/errorCorrectLevel:" + de);
      ue = be.length / 3, de = [];
      for (var pe = 0; pe < ue; pe += 1) for (var me = be[3 * pe], Me = be[3 * pe + 1], he = be[3 * pe + 2], ge = 0; ge < me; ge += 1) {
        var Ce = he, Se = {};
        Se.o = Me, Se.j = Ce, de.push(Se);
      }
      return de;
    } };
    return ce;
  }();
  return A;
}());
const QrCreator$1 = QrCreator;
var SlQrCode = class extends ShoelaceElement {
  constructor() {
    super(...arguments), this.value = "", this.label = "", this.size = 128, this.fill = "black", this.background = "white", this.radius = 0, this.errorCorrection = "H";
  }
  firstUpdated() {
    this.generate();
  }
  generate() {
    this.hasUpdated && QrCreator$1.render(
      {
        text: this.value,
        radius: this.radius,
        ecLevel: this.errorCorrection,
        fill: this.fill,
        background: this.background,
        // We draw the canvas larger and scale its container down to avoid blurring on high-density displays
        size: this.size * 2
      },
      this.canvas
    );
  }
  render() {
    var C;
    return ke$1`
      <canvas
        part="base"
        class="qr-code"
        role="img"
        aria-label=${((C = this.label) == null ? void 0 : C.length) > 0 ? this.label : this.value}
        style=${se({
      width: `${this.size}px`,
      height: `${this.size}px`
    })}
      ></canvas>
    `;
  }
};
SlQrCode.styles = [component_styles_default, qr_code_styles_default];
__decorateClass$e([
  e$6("canvas")
], SlQrCode.prototype, "canvas", 2);
__decorateClass$e([
  n$1()
], SlQrCode.prototype, "value", 2);
__decorateClass$e([
  n$1()
], SlQrCode.prototype, "label", 2);
__decorateClass$e([
  n$1({ type: Number })
], SlQrCode.prototype, "size", 2);
__decorateClass$e([
  n$1()
], SlQrCode.prototype, "fill", 2);
__decorateClass$e([
  n$1()
], SlQrCode.prototype, "background", 2);
__decorateClass$e([
  n$1({ type: Number })
], SlQrCode.prototype, "radius", 2);
__decorateClass$e([
  n$1({ attribute: "error-correction" })
], SlQrCode.prototype, "errorCorrection", 2);
__decorateClass$e([
  watch(["background", "errorCorrection", "fill", "radius", "size", "value"])
], SlQrCode.prototype, "generate", 1);
SlQrCode.define("sl-qr-code");
var radio_styles_default = i$5`
  :host {
    display: block;
  }

  :host(:focus-visible) {
    outline: 0px;
  }

  .radio {
    display: inline-flex;
    align-items: top;
    font-family: var(--sl-input-font-family);
    font-size: var(--sl-input-font-size-medium);
    font-weight: var(--sl-input-font-weight);
    color: var(--sl-input-label-color);
    vertical-align: middle;
    cursor: pointer;
  }

  .radio--small {
    --toggle-size: var(--sl-toggle-size-small);
    font-size: var(--sl-input-font-size-small);
  }

  .radio--medium {
    --toggle-size: var(--sl-toggle-size-medium);
    font-size: var(--sl-input-font-size-medium);
  }

  .radio--large {
    --toggle-size: var(--sl-toggle-size-large);
    font-size: var(--sl-input-font-size-large);
  }

  .radio__checked-icon {
    display: inline-flex;
    width: var(--toggle-size);
    height: var(--toggle-size);
  }

  .radio__control {
    flex: 0 0 auto;
    position: relative;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    width: var(--toggle-size);
    height: var(--toggle-size);
    border: solid var(--sl-input-border-width) var(--sl-input-border-color);
    border-radius: 50%;
    background-color: var(--sl-input-background-color);
    color: transparent;
    transition:
      var(--sl-transition-fast) border-color,
      var(--sl-transition-fast) background-color,
      var(--sl-transition-fast) color,
      var(--sl-transition-fast) box-shadow;
  }

  .radio__input {
    position: absolute;
    opacity: 0;
    padding: 0;
    margin: 0;
    pointer-events: none;
  }

  /* Hover */
  .radio:not(.radio--checked):not(.radio--disabled) .radio__control:hover {
    border-color: var(--sl-input-border-color-hover);
    background-color: var(--sl-input-background-color-hover);
  }

  /* Checked */
  .radio--checked .radio__control {
    color: var(--sl-color-neutral-0);
    border-color: var(--sl-color-primary-600);
    background-color: var(--sl-color-primary-600);
  }

  /* Checked + hover */
  .radio.radio--checked:not(.radio--disabled) .radio__control:hover {
    border-color: var(--sl-color-primary-500);
    background-color: var(--sl-color-primary-500);
  }

  /* Checked + focus */
  :host(:focus-visible) .radio__control {
    outline: var(--sl-focus-ring);
    outline-offset: var(--sl-focus-ring-offset);
  }

  /* Disabled */
  .radio--disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }

  /* When the control isn't checked, hide the circle for Windows High Contrast mode a11y */
  .radio:not(.radio--checked) svg circle {
    opacity: 0;
  }

  .radio__label {
    display: inline-block;
    color: var(--sl-input-label-color);
    line-height: var(--toggle-size);
    margin-inline-start: 0.5em;
    user-select: none;
    -webkit-user-select: none;
  }
`, SlRadio = class extends ShoelaceElement {
  constructor() {
    super(), this.checked = !1, this.hasFocus = !1, this.size = "medium", this.disabled = !1, this.handleBlur = () => {
      this.hasFocus = !1, this.emit("sl-blur");
    }, this.handleClick = () => {
      this.disabled || (this.checked = !0);
    }, this.handleFocus = () => {
      this.hasFocus = !0, this.emit("sl-focus");
    }, this.addEventListener("blur", this.handleBlur), this.addEventListener("click", this.handleClick), this.addEventListener("focus", this.handleFocus);
  }
  connectedCallback() {
    super.connectedCallback(), this.setInitialAttributes();
  }
  setInitialAttributes() {
    this.setAttribute("role", "radio"), this.setAttribute("tabindex", "-1"), this.setAttribute("aria-disabled", this.disabled ? "true" : "false");
  }
  handleCheckedChange() {
    this.setAttribute("aria-checked", this.checked ? "true" : "false"), this.setAttribute("tabindex", this.checked ? "0" : "-1");
  }
  handleDisabledChange() {
    this.setAttribute("aria-disabled", this.disabled ? "true" : "false");
  }
  render() {
    return ke$1`
      <span
        part="base"
        class=${Rt({
      radio: !0,
      "radio--checked": this.checked,
      "radio--disabled": this.disabled,
      "radio--focused": this.hasFocus,
      "radio--small": this.size === "small",
      "radio--medium": this.size === "medium",
      "radio--large": this.size === "large"
    })}
      >
        <span part="${`control${this.checked ? " control--checked" : ""}`}" class="radio__control">
          ${this.checked ? ke$1` <sl-icon part="checked-icon" class="radio__checked-icon" library="system" name="radio"></sl-icon> ` : ""}
        </span>

        <slot part="label" class="radio__label"></slot>
      </span>
    `;
  }
};
SlRadio.styles = [component_styles_default, radio_styles_default];
SlRadio.dependencies = { "sl-icon": SlIcon };
__decorateClass$e([
  r$3()
], SlRadio.prototype, "checked", 2);
__decorateClass$e([
  r$3()
], SlRadio.prototype, "hasFocus", 2);
__decorateClass$e([
  n$1()
], SlRadio.prototype, "value", 2);
__decorateClass$e([
  n$1({ reflect: !0 })
], SlRadio.prototype, "size", 2);
__decorateClass$e([
  n$1({ type: Boolean, reflect: !0 })
], SlRadio.prototype, "disabled", 2);
__decorateClass$e([
  watch("checked")
], SlRadio.prototype, "handleCheckedChange", 1);
__decorateClass$e([
  watch("disabled", { waitUntilFirstUpdate: !0 })
], SlRadio.prototype, "handleDisabledChange", 1);
SlRadio.define("sl-radio");
var option_styles_default = i$5`
  :host {
    display: block;
    user-select: none;
    -webkit-user-select: none;
  }

  :host(:focus) {
    outline: none;
  }

  .option {
    position: relative;
    display: flex;
    align-items: center;
    font-family: var(--sl-font-sans);
    font-size: var(--sl-font-size-medium);
    font-weight: var(--sl-font-weight-normal);
    line-height: var(--sl-line-height-normal);
    letter-spacing: var(--sl-letter-spacing-normal);
    color: var(--sl-color-neutral-700);
    padding: var(--sl-spacing-x-small) var(--sl-spacing-medium) var(--sl-spacing-x-small) var(--sl-spacing-x-small);
    transition: var(--sl-transition-fast) fill;
    cursor: pointer;
  }

  .option--hover:not(.option--current):not(.option--disabled) {
    background-color: var(--sl-color-neutral-100);
    color: var(--sl-color-neutral-1000);
  }

  .option--current,
  .option--current.option--disabled {
    background-color: var(--sl-color-primary-600);
    color: var(--sl-color-neutral-0);
    opacity: 1;
  }

  .option--disabled {
    outline: none;
    opacity: 0.5;
    cursor: not-allowed;
  }

  .option__label {
    flex: 1 1 auto;
    display: inline-block;
    line-height: var(--sl-line-height-dense);
  }

  .option .option__check {
    flex: 0 0 auto;
    display: flex;
    align-items: center;
    justify-content: center;
    visibility: hidden;
    padding-inline-end: var(--sl-spacing-2x-small);
  }

  .option--selected .option__check {
    visibility: visible;
  }

  .option__prefix,
  .option__suffix {
    flex: 0 0 auto;
    display: flex;
    align-items: center;
  }

  .option__prefix::slotted(*) {
    margin-inline-end: var(--sl-spacing-x-small);
  }

  .option__suffix::slotted(*) {
    margin-inline-start: var(--sl-spacing-x-small);
  }

  @media (forced-colors: active) {
    :host(:hover:not([aria-disabled='true'])) .option {
      outline: dashed 1px SelectedItem;
      outline-offset: -1px;
    }
  }
`, SlOption = class extends ShoelaceElement {
  constructor() {
    super(...arguments), this.localize = new LocalizeController(this), this.current = !1, this.selected = !1, this.hasHover = !1, this.value = "", this.disabled = !1;
  }
  connectedCallback() {
    super.connectedCallback(), this.setAttribute("role", "option"), this.setAttribute("aria-selected", "false");
  }
  handleDefaultSlotChange() {
    const C = this.getTextLabel();
    if (typeof this.cachedTextLabel > "u") {
      this.cachedTextLabel = C;
      return;
    }
    C !== this.cachedTextLabel && (this.cachedTextLabel = C, this.emit("slotchange", { bubbles: !0, composed: !1, cancelable: !1 }));
  }
  handleMouseEnter() {
    this.hasHover = !0;
  }
  handleMouseLeave() {
    this.hasHover = !1;
  }
  handleDisabledChange() {
    this.setAttribute("aria-disabled", this.disabled ? "true" : "false");
  }
  handleSelectedChange() {
    this.setAttribute("aria-selected", this.selected ? "true" : "false");
  }
  handleValueChange() {
    typeof this.value != "string" && (this.value = String(this.value)), this.value.includes(" ") && (console.error("Option values cannot include a space. All spaces have been replaced with underscores.", this), this.value = this.value.replace(/ /g, "_"));
  }
  /** Returns a plain text label based on the option's content. */
  getTextLabel() {
    const C = this.childNodes;
    let L = "";
    return [...C].forEach((A) => {
      A.nodeType === Node.ELEMENT_NODE && (A.hasAttribute("slot") || (L += A.textContent)), A.nodeType === Node.TEXT_NODE && (L += A.textContent);
    }), L.trim();
  }
  render() {
    return ke$1`
      <div
        part="base"
        class=${Rt({
      option: !0,
      "option--current": this.current,
      "option--disabled": this.disabled,
      "option--selected": this.selected,
      "option--hover": this.hasHover
    })}
        @mouseenter=${this.handleMouseEnter}
        @mouseleave=${this.handleMouseLeave}
      >
        <sl-icon part="checked-icon" class="option__check" name="check" library="system" aria-hidden="true"></sl-icon>
        <slot part="prefix" name="prefix" class="option__prefix"></slot>
        <slot part="label" class="option__label" @slotchange=${this.handleDefaultSlotChange}></slot>
        <slot part="suffix" name="suffix" class="option__suffix"></slot>
      </div>
    `;
  }
};
SlOption.styles = [component_styles_default, option_styles_default];
SlOption.dependencies = { "sl-icon": SlIcon };
__decorateClass$e([
  e$6(".option__label")
], SlOption.prototype, "defaultSlot", 2);
__decorateClass$e([
  r$3()
], SlOption.prototype, "current", 2);
__decorateClass$e([
  r$3()
], SlOption.prototype, "selected", 2);
__decorateClass$e([
  r$3()
], SlOption.prototype, "hasHover", 2);
__decorateClass$e([
  n$1({ reflect: !0 })
], SlOption.prototype, "value", 2);
__decorateClass$e([
  n$1({ type: Boolean, reflect: !0 })
], SlOption.prototype, "disabled", 2);
__decorateClass$e([
  watch("disabled")
], SlOption.prototype, "handleDisabledChange", 1);
__decorateClass$e([
  watch("selected")
], SlOption.prototype, "handleSelectedChange", 1);
__decorateClass$e([
  watch("value")
], SlOption.prototype, "handleValueChange", 1);
SlOption.define("sl-option");
SlPopup.define("sl-popup");
var progress_bar_styles_default = i$5`
  :host {
    --height: 1rem;
    --track-color: var(--sl-color-neutral-200);
    --indicator-color: var(--sl-color-primary-600);
    --label-color: var(--sl-color-neutral-0);

    display: block;
  }

  .progress-bar {
    position: relative;
    background-color: var(--track-color);
    height: var(--height);
    border-radius: var(--sl-border-radius-pill);
    box-shadow: inset var(--sl-shadow-small);
    overflow: hidden;
  }

  .progress-bar__indicator {
    height: 100%;
    font-family: var(--sl-font-sans);
    font-size: 12px;
    font-weight: var(--sl-font-weight-normal);
    background-color: var(--indicator-color);
    color: var(--label-color);
    text-align: center;
    line-height: var(--height);
    white-space: nowrap;
    overflow: hidden;
    transition:
      400ms width,
      400ms background-color;
    user-select: none;
    -webkit-user-select: none;
  }

  /* Indeterminate */
  .progress-bar--indeterminate .progress-bar__indicator {
    position: absolute;
    animation: indeterminate 2.5s infinite cubic-bezier(0.37, 0, 0.63, 1);
  }

  .progress-bar--indeterminate.progress-bar--rtl .progress-bar__indicator {
    animation-name: indeterminate-rtl;
  }

  @media (forced-colors: active) {
    .progress-bar {
      outline: solid 1px SelectedItem;
      background-color: var(--sl-color-neutral-0);
    }

    .progress-bar__indicator {
      outline: solid 1px SelectedItem;
      background-color: SelectedItem;
    }
  }

  @keyframes indeterminate {
    0% {
      left: -50%;
      width: 50%;
    }
    75%,
    100% {
      left: 100%;
      width: 50%;
    }
  }

  @keyframes indeterminate-rtl {
    0% {
      right: -50%;
      width: 50%;
    }
    75%,
    100% {
      right: 100%;
      width: 50%;
    }
  }
`, SlProgressBar = class extends ShoelaceElement {
  constructor() {
    super(...arguments), this.localize = new LocalizeController(this), this.value = 0, this.indeterminate = !1, this.label = "";
  }
  render() {
    return ke$1`
      <div
        part="base"
        class=${Rt({
      "progress-bar": !0,
      "progress-bar--indeterminate": this.indeterminate,
      "progress-bar--rtl": this.localize.dir() === "rtl"
    })}
        role="progressbar"
        title=${to(this.title)}
        aria-label=${this.label.length > 0 ? this.label : this.localize.term("progress")}
        aria-valuemin="0"
        aria-valuemax="100"
        aria-valuenow=${this.indeterminate ? 0 : this.value}
      >
        <div part="indicator" class="progress-bar__indicator" style=${se({ width: `${this.value}%` })}>
          ${this.indeterminate ? "" : ke$1` <slot part="label" class="progress-bar__label"></slot> `}
        </div>
      </div>
    `;
  }
};
SlProgressBar.styles = [component_styles_default, progress_bar_styles_default];
__decorateClass$e([
  n$1({ type: Number, reflect: !0 })
], SlProgressBar.prototype, "value", 2);
__decorateClass$e([
  n$1({ type: Boolean, reflect: !0 })
], SlProgressBar.prototype, "indeterminate", 2);
__decorateClass$e([
  n$1()
], SlProgressBar.prototype, "label", 2);
SlProgressBar.define("sl-progress-bar");
var menu_item_styles_default = i$5`
  :host {
    --submenu-offset: -2px;

    display: block;
  }

  :host([inert]) {
    display: none;
  }

  .menu-item {
    position: relative;
    display: flex;
    align-items: stretch;
    font-family: var(--sl-font-sans);
    font-size: var(--sl-font-size-medium);
    font-weight: var(--sl-font-weight-normal);
    line-height: var(--sl-line-height-normal);
    letter-spacing: var(--sl-letter-spacing-normal);
    color: var(--sl-color-neutral-700);
    padding: var(--sl-spacing-2x-small) var(--sl-spacing-2x-small);
    transition: var(--sl-transition-fast) fill;
    user-select: none;
    -webkit-user-select: none;
    white-space: nowrap;
    cursor: pointer;
  }

  .menu-item.menu-item--disabled {
    outline: none;
    opacity: 0.5;
    cursor: not-allowed;
  }

  .menu-item.menu-item--loading {
    outline: none;
    cursor: wait;
  }

  .menu-item.menu-item--loading *:not(sl-spinner) {
    opacity: 0.5;
  }

  .menu-item--loading sl-spinner {
    --indicator-color: currentColor;
    --track-width: 1px;
    position: absolute;
    font-size: 0.75em;
    top: calc(50% - 0.5em);
    left: 0.65rem;
    opacity: 1;
  }

  .menu-item .menu-item__label {
    flex: 1 1 auto;
    display: inline-block;
    text-overflow: ellipsis;
    overflow: hidden;
  }

  .menu-item .menu-item__prefix {
    flex: 0 0 auto;
    display: flex;
    align-items: center;
  }

  .menu-item .menu-item__prefix::slotted(*) {
    margin-inline-end: var(--sl-spacing-x-small);
  }

  .menu-item .menu-item__suffix {
    flex: 0 0 auto;
    display: flex;
    align-items: center;
  }

  .menu-item .menu-item__suffix::slotted(*) {
    margin-inline-start: var(--sl-spacing-x-small);
  }

  /* Safe triangle */
  .menu-item--submenu-expanded::after {
    content: '';
    position: fixed;
    z-index: calc(var(--sl-z-index-dropdown) - 1);
    top: 0;
    right: 0;
    bottom: 0;
    left: 0;
    clip-path: polygon(
      var(--safe-triangle-cursor-x, 0) var(--safe-triangle-cursor-y, 0),
      var(--safe-triangle-submenu-start-x, 0) var(--safe-triangle-submenu-start-y, 0),
      var(--safe-triangle-submenu-end-x, 0) var(--safe-triangle-submenu-end-y, 0)
    );
  }

  :host(:focus-visible) {
    outline: none;
  }

  :host(:hover:not([aria-disabled='true'], :focus-visible)) .menu-item,
  .menu-item--submenu-expanded {
    background-color: var(--sl-color-neutral-100);
    color: var(--sl-color-neutral-1000);
  }

  :host(:focus-visible) .menu-item {
    outline: none;
    background-color: var(--sl-color-primary-600);
    color: var(--sl-color-neutral-0);
    opacity: 1;
  }

  .menu-item .menu-item__check,
  .menu-item .menu-item__chevron {
    flex: 0 0 auto;
    display: flex;
    align-items: center;
    justify-content: center;
    width: 1.5em;
    visibility: hidden;
  }

  .menu-item--checked .menu-item__check,
  .menu-item--has-submenu .menu-item__chevron {
    visibility: visible;
  }

  /* Add elevation and z-index to submenus */
  sl-popup::part(popup) {
    box-shadow: var(--sl-shadow-large);
    z-index: var(--sl-z-index-dropdown);
    margin-left: var(--submenu-offset);
  }

  .menu-item--rtl sl-popup::part(popup) {
    margin-left: calc(-1 * var(--submenu-offset));
  }

  @media (forced-colors: active) {
    :host(:hover:not([aria-disabled='true'])) .menu-item,
    :host(:focus-visible) .menu-item {
      outline: dashed 1px SelectedItem;
      outline-offset: -1px;
    }
  }

  ::slotted(sl-menu) {
    max-width: var(--auto-size-available-width) !important;
    max-height: var(--auto-size-available-height) !important;
  }
`;
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const mt = (C, L) => {
  var W;
  const A = C._$AN;
  if (A === void 0) return !1;
  for (const X of A) (W = X._$AO) == null || W.call(X, L, !1), mt(X, L);
  return !0;
}, _t = (C) => {
  let L, A;
  do {
    if ((L = C._$AM) === void 0) break;
    A = L._$AN, A.delete(C), C = L;
  } while ((A == null ? void 0 : A.size) === 0);
}, wt = (C) => {
  for (let L; L = C._$AM; C = L) {
    let A = L._$AN;
    if (A === void 0) L._$AN = A = /* @__PURE__ */ new Set();
    else if (A.has(C)) break;
    A.add(C), gt(L);
  }
};
function bt(C) {
  this._$AN !== void 0 ? (_t(this), this._$AM = C, wt(this)) : this._$AM = C;
}
function yt(C, L = !1, A = 0) {
  const W = this._$AH, X = this._$AN;
  if (X !== void 0 && X.size !== 0) if (L) if (Array.isArray(W)) for (let J = A; J < W.length; J++) mt(W[J], !1), _t(W[J]);
  else W != null && (mt(W, !1), _t(W));
  else mt(this, C);
}
const gt = (C) => {
  C.type == t$2.CHILD && (C._$AP ?? (C._$AP = yt), C._$AQ ?? (C._$AQ = bt));
};
class $t extends i$3 {
  constructor() {
    super(...arguments), this._$AN = void 0;
  }
  _$AT(L, A, W) {
    super._$AT(L, A, W), wt(this), this.isConnected = L._$AU;
  }
  _$AO(L, A = !0) {
    var W, X;
    L !== this.isConnected && (this.isConnected = L, L ? (W = this.reconnected) == null || W.call(this) : (X = this.disconnected) == null || X.call(this)), A && (mt(this, L), _t(this));
  }
  setValue(L) {
    if (rt(this.t)) this.t._$AI(L, this);
    else {
      const A = [...this.t._$AH];
      A[this.i] = L, this.t._$AI(A, this, 0);
    }
  }
  disconnected() {
  }
  reconnected() {
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const ii = () => new Zt();
class Zt {
}
const qt = /* @__PURE__ */ new WeakMap(), Kt = e$4(class extends $t {
  render(C) {
    return D;
  }
  update(C, [L]) {
    var W;
    const A = L !== this.Y;
    return A && this.Y !== void 0 && this.rt(void 0), (A || this.lt !== this.ct) && (this.Y = L, this.ht = (W = C.options) == null ? void 0 : W.host, this.rt(this.ct = C.element)), D;
  }
  rt(C) {
    if (this.isConnected || (C = void 0), typeof this.Y == "function") {
      const L = this.ht ?? globalThis;
      let A = qt.get(L);
      A === void 0 && (A = /* @__PURE__ */ new WeakMap(), qt.set(L, A)), A.get(this.Y) !== void 0 && this.Y.call(this.ht, void 0), A.set(this.Y, C), C !== void 0 && this.Y.call(this.ht, C);
    } else this.Y.value = C;
  }
  get lt() {
    var C, L;
    return typeof this.Y == "function" ? (C = qt.get(this.ht ?? globalThis)) == null ? void 0 : C.get(this.Y) : (L = this.Y) == null ? void 0 : L.value;
  }
  disconnected() {
    this.lt === this.ct && this.rt(void 0);
  }
  reconnected() {
    this.rt(this.ct);
  }
});
var SubmenuController = class {
  constructor(C, L) {
    this.popupRef = ii(), this.enableSubmenuTimer = -1, this.isConnected = !1, this.isPopupConnected = !1, this.skidding = 0, this.submenuOpenDelay = 100, this.handleMouseMove = (A) => {
      this.host.style.setProperty("--safe-triangle-cursor-x", `${A.clientX}px`), this.host.style.setProperty("--safe-triangle-cursor-y", `${A.clientY}px`);
    }, this.handleMouseOver = () => {
      this.hasSlotController.test("submenu") && this.enableSubmenu();
    }, this.handleKeyDown = (A) => {
      switch (A.key) {
        case "Escape":
        case "Tab":
          this.disableSubmenu();
          break;
        case "ArrowLeft":
          A.target !== this.host && (A.preventDefault(), A.stopPropagation(), this.host.focus(), this.disableSubmenu());
          break;
        case "ArrowRight":
        case "Enter":
        case " ":
          this.handleSubmenuEntry(A);
          break;
      }
    }, this.handleClick = (A) => {
      var W;
      A.target === this.host ? (A.preventDefault(), A.stopPropagation()) : A.target instanceof Element && (A.target.tagName === "sl-menu-item" || (W = A.target.role) != null && W.startsWith("menuitem")) && this.disableSubmenu();
    }, this.handleFocusOut = (A) => {
      A.relatedTarget && A.relatedTarget instanceof Element && this.host.contains(A.relatedTarget) || this.disableSubmenu();
    }, this.handlePopupMouseover = (A) => {
      A.stopPropagation();
    }, this.handlePopupReposition = () => {
      const A = this.host.renderRoot.querySelector("slot[name='submenu']"), W = A == null ? void 0 : A.assignedElements({ flatten: !0 }).filter((re) => re.localName === "sl-menu")[0], X = this.host.matches(":dir(rtl)");
      if (!W)
        return;
      const { left: J, top: te, width: oe, height: ne } = W.getBoundingClientRect();
      this.host.style.setProperty("--safe-triangle-submenu-start-x", `${X ? J + oe : J}px`), this.host.style.setProperty("--safe-triangle-submenu-start-y", `${te}px`), this.host.style.setProperty("--safe-triangle-submenu-end-x", `${X ? J + oe : J}px`), this.host.style.setProperty("--safe-triangle-submenu-end-y", `${te + ne}px`);
    }, (this.host = C).addController(this), this.hasSlotController = L;
  }
  hostConnected() {
    this.hasSlotController.test("submenu") && !this.host.disabled && this.addListeners();
  }
  hostDisconnected() {
    this.removeListeners();
  }
  hostUpdated() {
    this.hasSlotController.test("submenu") && !this.host.disabled ? (this.addListeners(), this.updateSkidding()) : this.removeListeners();
  }
  addListeners() {
    this.isConnected || (this.host.addEventListener("mousemove", this.handleMouseMove), this.host.addEventListener("mouseover", this.handleMouseOver), this.host.addEventListener("keydown", this.handleKeyDown), this.host.addEventListener("click", this.handleClick), this.host.addEventListener("focusout", this.handleFocusOut), this.isConnected = !0), this.isPopupConnected || this.popupRef.value && (this.popupRef.value.addEventListener("mouseover", this.handlePopupMouseover), this.popupRef.value.addEventListener("sl-reposition", this.handlePopupReposition), this.isPopupConnected = !0);
  }
  removeListeners() {
    this.isConnected && (this.host.removeEventListener("mousemove", this.handleMouseMove), this.host.removeEventListener("mouseover", this.handleMouseOver), this.host.removeEventListener("keydown", this.handleKeyDown), this.host.removeEventListener("click", this.handleClick), this.host.removeEventListener("focusout", this.handleFocusOut), this.isConnected = !1), this.isPopupConnected && this.popupRef.value && (this.popupRef.value.removeEventListener("mouseover", this.handlePopupMouseover), this.popupRef.value.removeEventListener("sl-reposition", this.handlePopupReposition), this.isPopupConnected = !1);
  }
  handleSubmenuEntry(C) {
    const L = this.host.renderRoot.querySelector("slot[name='submenu']");
    if (!L) {
      console.error("Cannot activate a submenu if no corresponding menuitem can be found.", this);
      return;
    }
    let A = null;
    for (const W of L.assignedElements())
      if (A = W.querySelectorAll("sl-menu-item, [role^='menuitem']"), A.length !== 0)
        break;
    if (!(!A || A.length === 0)) {
      A[0].setAttribute("tabindex", "0");
      for (let W = 1; W !== A.length; ++W)
        A[W].setAttribute("tabindex", "-1");
      this.popupRef.value && (C.preventDefault(), C.stopPropagation(), this.popupRef.value.active ? A[0] instanceof HTMLElement && A[0].focus() : (this.enableSubmenu(!1), this.host.updateComplete.then(() => {
        A[0] instanceof HTMLElement && A[0].focus();
      }), this.host.requestUpdate()));
    }
  }
  setSubmenuState(C) {
    this.popupRef.value && this.popupRef.value.active !== C && (this.popupRef.value.active = C, this.host.requestUpdate());
  }
  // Shows the submenu. Supports disabling the opening delay, e.g. for keyboard events that want to set the focus to the
  // newly opened menu.
  enableSubmenu(C = !0) {
    C ? (window.clearTimeout(this.enableSubmenuTimer), this.enableSubmenuTimer = window.setTimeout(() => {
      this.setSubmenuState(!0);
    }, this.submenuOpenDelay)) : this.setSubmenuState(!0);
  }
  disableSubmenu() {
    window.clearTimeout(this.enableSubmenuTimer), this.setSubmenuState(!1);
  }
  // Calculate the space the top of a menu takes-up, for aligning the popup menu-item with the activating element.
  updateSkidding() {
    var C;
    if (!((C = this.host.parentElement) != null && C.computedStyleMap))
      return;
    const L = this.host.parentElement.computedStyleMap(), W = ["padding-top", "border-top-width", "margin-top"].reduce((X, J) => {
      var te;
      const oe = (te = L.get(J)) != null ? te : new CSSUnitValue(0, "px"), re = (oe instanceof CSSUnitValue ? oe : new CSSUnitValue(0, "px")).to("px");
      return X - re.value;
    }, 0);
    this.skidding = W;
  }
  isExpanded() {
    return this.popupRef.value ? this.popupRef.value.active : !1;
  }
  renderSubmenu() {
    const C = this.host.matches(":dir(rtl)");
    return this.isConnected ? ke$1`
      <sl-popup
        ${Kt(this.popupRef)}
        placement=${C ? "left-start" : "right-start"}
        anchor="anchor"
        flip
        flip-fallback-strategy="best-fit"
        skidding="${this.skidding}"
        strategy="fixed"
        auto-size="vertical"
        auto-size-padding="10"
      >
        <slot name="submenu"></slot>
      </sl-popup>
    ` : ke$1` <slot name="submenu" hidden></slot> `;
  }
}, SlMenuItem = class extends ShoelaceElement {
  constructor() {
    super(...arguments), this.type = "normal", this.checked = !1, this.value = "", this.loading = !1, this.disabled = !1, this.hasSlotController = new HasSlotController(this, "submenu"), this.submenuController = new SubmenuController(this, this.hasSlotController), this.handleHostClick = (C) => {
      this.disabled && (C.preventDefault(), C.stopImmediatePropagation());
    }, this.handleMouseOver = (C) => {
      this.focus(), C.stopPropagation();
    };
  }
  connectedCallback() {
    super.connectedCallback(), this.addEventListener("click", this.handleHostClick), this.addEventListener("mouseover", this.handleMouseOver);
  }
  disconnectedCallback() {
    super.disconnectedCallback(), this.removeEventListener("click", this.handleHostClick), this.removeEventListener("mouseover", this.handleMouseOver);
  }
  handleDefaultSlotChange() {
    const C = this.getTextLabel();
    if (typeof this.cachedTextLabel > "u") {
      this.cachedTextLabel = C;
      return;
    }
    C !== this.cachedTextLabel && (this.cachedTextLabel = C, this.emit("slotchange", { bubbles: !0, composed: !1, cancelable: !1 }));
  }
  handleCheckedChange() {
    if (this.checked && this.type !== "checkbox") {
      this.checked = !1, console.error('The checked attribute can only be used on menu items with type="checkbox"', this);
      return;
    }
    this.type === "checkbox" ? this.setAttribute("aria-checked", this.checked ? "true" : "false") : this.removeAttribute("aria-checked");
  }
  handleDisabledChange() {
    this.setAttribute("aria-disabled", this.disabled ? "true" : "false");
  }
  handleTypeChange() {
    this.type === "checkbox" ? (this.setAttribute("role", "menuitemcheckbox"), this.setAttribute("aria-checked", this.checked ? "true" : "false")) : (this.setAttribute("role", "menuitem"), this.removeAttribute("aria-checked"));
  }
  /** Returns a text label based on the contents of the menu item's default slot. */
  getTextLabel() {
    return getTextContent(this.defaultSlot);
  }
  isSubmenu() {
    return this.hasSlotController.test("submenu");
  }
  render() {
    const C = this.matches(":dir(rtl)"), L = this.submenuController.isExpanded();
    return ke$1`
      <div
        id="anchor"
        part="base"
        class=${Rt({
      "menu-item": !0,
      "menu-item--rtl": C,
      "menu-item--checked": this.checked,
      "menu-item--disabled": this.disabled,
      "menu-item--loading": this.loading,
      "menu-item--has-submenu": this.isSubmenu(),
      "menu-item--submenu-expanded": L
    })}
        ?aria-haspopup="${this.isSubmenu()}"
        ?aria-expanded="${!!L}"
      >
        <span part="checked-icon" class="menu-item__check">
          <sl-icon name="check" library="system" aria-hidden="true"></sl-icon>
        </span>

        <slot name="prefix" part="prefix" class="menu-item__prefix"></slot>

        <slot part="label" class="menu-item__label" @slotchange=${this.handleDefaultSlotChange}></slot>

        <slot name="suffix" part="suffix" class="menu-item__suffix"></slot>

        <span part="submenu-icon" class="menu-item__chevron">
          <sl-icon name=${C ? "chevron-left" : "chevron-right"} library="system" aria-hidden="true"></sl-icon>
        </span>

        ${this.submenuController.renderSubmenu()}
        ${this.loading ? ke$1` <sl-spinner part="spinner" exportparts="base:spinner__base"></sl-spinner> ` : ""}
      </div>
    `;
  }
};
SlMenuItem.styles = [component_styles_default, menu_item_styles_default];
SlMenuItem.dependencies = {
  "sl-icon": SlIcon,
  "sl-popup": SlPopup,
  "sl-spinner": SlSpinner
};
__decorateClass$e([
  e$6("slot:not([name])")
], SlMenuItem.prototype, "defaultSlot", 2);
__decorateClass$e([
  e$6(".menu-item")
], SlMenuItem.prototype, "menuItem", 2);
__decorateClass$e([
  n$1()
], SlMenuItem.prototype, "type", 2);
__decorateClass$e([
  n$1({ type: Boolean, reflect: !0 })
], SlMenuItem.prototype, "checked", 2);
__decorateClass$e([
  n$1()
], SlMenuItem.prototype, "value", 2);
__decorateClass$e([
  n$1({ type: Boolean, reflect: !0 })
], SlMenuItem.prototype, "loading", 2);
__decorateClass$e([
  n$1({ type: Boolean, reflect: !0 })
], SlMenuItem.prototype, "disabled", 2);
__decorateClass$e([
  watch("checked")
], SlMenuItem.prototype, "handleCheckedChange", 1);
__decorateClass$e([
  watch("disabled")
], SlMenuItem.prototype, "handleDisabledChange", 1);
__decorateClass$e([
  watch("type")
], SlMenuItem.prototype, "handleTypeChange", 1);
SlMenuItem.define("sl-menu-item");
var mutation_observer_styles_default = i$5`
  :host {
    display: contents;
  }
`, SlMutationObserver = class extends ShoelaceElement {
  constructor() {
    super(...arguments), this.attrOldValue = !1, this.charData = !1, this.charDataOldValue = !1, this.childList = !1, this.disabled = !1, this.handleMutation = (C) => {
      this.emit("sl-mutation", {
        detail: { mutationList: C }
      });
    };
  }
  connectedCallback() {
    super.connectedCallback(), this.mutationObserver = new MutationObserver(this.handleMutation), this.disabled || this.startObserver();
  }
  disconnectedCallback() {
    super.disconnectedCallback(), this.stopObserver();
  }
  startObserver() {
    const C = typeof this.attr == "string" && this.attr.length > 0, L = C && this.attr !== "*" ? this.attr.split(" ") : void 0;
    try {
      this.mutationObserver.observe(this, {
        subtree: !0,
        childList: this.childList,
        attributes: C,
        attributeFilter: L,
        attributeOldValue: this.attrOldValue,
        characterData: this.charData,
        characterDataOldValue: this.charDataOldValue
      });
    } catch {
    }
  }
  stopObserver() {
    this.mutationObserver.disconnect();
  }
  handleDisabledChange() {
    this.disabled ? this.stopObserver() : this.startObserver();
  }
  handleChange() {
    this.stopObserver(), this.startObserver();
  }
  render() {
    return ke$1` <slot></slot> `;
  }
};
SlMutationObserver.styles = [component_styles_default, mutation_observer_styles_default];
__decorateClass$e([
  n$1({ reflect: !0 })
], SlMutationObserver.prototype, "attr", 2);
__decorateClass$e([
  n$1({ attribute: "attr-old-value", type: Boolean, reflect: !0 })
], SlMutationObserver.prototype, "attrOldValue", 2);
__decorateClass$e([
  n$1({ attribute: "char-data", type: Boolean, reflect: !0 })
], SlMutationObserver.prototype, "charData", 2);
__decorateClass$e([
  n$1({ attribute: "char-data-old-value", type: Boolean, reflect: !0 })
], SlMutationObserver.prototype, "charDataOldValue", 2);
__decorateClass$e([
  n$1({ attribute: "child-list", type: Boolean, reflect: !0 })
], SlMutationObserver.prototype, "childList", 2);
__decorateClass$e([
  n$1({ type: Boolean, reflect: !0 })
], SlMutationObserver.prototype, "disabled", 2);
__decorateClass$e([
  watch("disabled")
], SlMutationObserver.prototype, "handleDisabledChange", 1);
__decorateClass$e([
  watch("attr", { waitUntilFirstUpdate: !0 }),
  watch("attr-old-value", { waitUntilFirstUpdate: !0 }),
  watch("char-data", { waitUntilFirstUpdate: !0 }),
  watch("char-data-old-value", { waitUntilFirstUpdate: !0 }),
  watch("childList", { waitUntilFirstUpdate: !0 })
], SlMutationObserver.prototype, "handleChange", 1);
SlMutationObserver.define("sl-mutation-observer");
var input_styles_default = i$5`
  :host {
    display: block;
  }

  .input {
    flex: 1 1 auto;
    display: inline-flex;
    align-items: stretch;
    justify-content: start;
    position: relative;
    width: 100%;
    font-family: var(--sl-input-font-family);
    font-weight: var(--sl-input-font-weight);
    letter-spacing: var(--sl-input-letter-spacing);
    vertical-align: middle;
    overflow: hidden;
    cursor: text;
    transition:
      var(--sl-transition-fast) color,
      var(--sl-transition-fast) border,
      var(--sl-transition-fast) box-shadow,
      var(--sl-transition-fast) background-color;
  }

  /* Standard inputs */
  .input--standard {
    background-color: var(--sl-input-background-color);
    border: solid var(--sl-input-border-width) var(--sl-input-border-color);
  }

  .input--standard:hover:not(.input--disabled) {
    background-color: var(--sl-input-background-color-hover);
    border-color: var(--sl-input-border-color-hover);
  }

  .input--standard.input--focused:not(.input--disabled) {
    background-color: var(--sl-input-background-color-focus);
    border-color: var(--sl-input-border-color-focus);
    box-shadow: 0 0 0 var(--sl-focus-ring-width) var(--sl-input-focus-ring-color);
  }

  .input--standard.input--focused:not(.input--disabled) .input__control {
    color: var(--sl-input-color-focus);
  }

  .input--standard.input--disabled {
    background-color: var(--sl-input-background-color-disabled);
    border-color: var(--sl-input-border-color-disabled);
    opacity: 0.5;
    cursor: not-allowed;
  }

  .input--standard.input--disabled .input__control {
    color: var(--sl-input-color-disabled);
  }

  .input--standard.input--disabled .input__control::placeholder {
    color: var(--sl-input-placeholder-color-disabled);
  }

  /* Filled inputs */
  .input--filled {
    border: none;
    background-color: var(--sl-input-filled-background-color);
    color: var(--sl-input-color);
  }

  .input--filled:hover:not(.input--disabled) {
    background-color: var(--sl-input-filled-background-color-hover);
  }

  .input--filled.input--focused:not(.input--disabled) {
    background-color: var(--sl-input-filled-background-color-focus);
    outline: var(--sl-focus-ring);
    outline-offset: var(--sl-focus-ring-offset);
  }

  .input--filled.input--disabled {
    background-color: var(--sl-input-filled-background-color-disabled);
    opacity: 0.5;
    cursor: not-allowed;
  }

  .input__control {
    flex: 1 1 auto;
    font-family: inherit;
    font-size: inherit;
    font-weight: inherit;
    min-width: 0;
    height: 100%;
    color: var(--sl-input-color);
    border: none;
    background: inherit;
    box-shadow: none;
    padding: 0;
    margin: 0;
    cursor: inherit;
    -webkit-appearance: none;
  }

  .input__control::-webkit-search-decoration,
  .input__control::-webkit-search-cancel-button,
  .input__control::-webkit-search-results-button,
  .input__control::-webkit-search-results-decoration {
    -webkit-appearance: none;
  }

  .input__control:-webkit-autofill,
  .input__control:-webkit-autofill:hover,
  .input__control:-webkit-autofill:focus,
  .input__control:-webkit-autofill:active {
    box-shadow: 0 0 0 var(--sl-input-height-large) var(--sl-input-background-color-hover) inset !important;
    -webkit-text-fill-color: var(--sl-color-primary-500);
    caret-color: var(--sl-input-color);
  }

  .input--filled .input__control:-webkit-autofill,
  .input--filled .input__control:-webkit-autofill:hover,
  .input--filled .input__control:-webkit-autofill:focus,
  .input--filled .input__control:-webkit-autofill:active {
    box-shadow: 0 0 0 var(--sl-input-height-large) var(--sl-input-filled-background-color) inset !important;
  }

  .input__control::placeholder {
    color: var(--sl-input-placeholder-color);
    user-select: none;
    -webkit-user-select: none;
  }

  .input:hover:not(.input--disabled) .input__control {
    color: var(--sl-input-color-hover);
  }

  .input__control:focus {
    outline: none;
  }

  .input__prefix,
  .input__suffix {
    display: inline-flex;
    flex: 0 0 auto;
    align-items: center;
    cursor: default;
  }

  .input__prefix ::slotted(sl-icon),
  .input__suffix ::slotted(sl-icon) {
    color: var(--sl-input-icon-color);
  }

  /*
   * Size modifiers
   */

  .input--small {
    border-radius: var(--sl-input-border-radius-small);
    font-size: var(--sl-input-font-size-small);
    height: var(--sl-input-height-small);
  }

  .input--small .input__control {
    height: calc(var(--sl-input-height-small) - var(--sl-input-border-width) * 2);
    padding: 0 var(--sl-input-spacing-small);
  }

  .input--small .input__clear,
  .input--small .input__password-toggle {
    width: calc(1em + var(--sl-input-spacing-small) * 2);
  }

  .input--small .input__prefix ::slotted(*) {
    margin-inline-start: var(--sl-input-spacing-small);
  }

  .input--small .input__suffix ::slotted(*) {
    margin-inline-end: var(--sl-input-spacing-small);
  }

  .input--medium {
    border-radius: var(--sl-input-border-radius-medium);
    font-size: var(--sl-input-font-size-medium);
    height: var(--sl-input-height-medium);
  }

  .input--medium .input__control {
    height: calc(var(--sl-input-height-medium) - var(--sl-input-border-width) * 2);
    padding: 0 var(--sl-input-spacing-medium);
  }

  .input--medium .input__clear,
  .input--medium .input__password-toggle {
    width: calc(1em + var(--sl-input-spacing-medium) * 2);
  }

  .input--medium .input__prefix ::slotted(*) {
    margin-inline-start: var(--sl-input-spacing-medium);
  }

  .input--medium .input__suffix ::slotted(*) {
    margin-inline-end: var(--sl-input-spacing-medium);
  }

  .input--large {
    border-radius: var(--sl-input-border-radius-large);
    font-size: var(--sl-input-font-size-large);
    height: var(--sl-input-height-large);
  }

  .input--large .input__control {
    height: calc(var(--sl-input-height-large) - var(--sl-input-border-width) * 2);
    padding: 0 var(--sl-input-spacing-large);
  }

  .input--large .input__clear,
  .input--large .input__password-toggle {
    width: calc(1em + var(--sl-input-spacing-large) * 2);
  }

  .input--large .input__prefix ::slotted(*) {
    margin-inline-start: var(--sl-input-spacing-large);
  }

  .input--large .input__suffix ::slotted(*) {
    margin-inline-end: var(--sl-input-spacing-large);
  }

  /*
   * Pill modifier
   */

  .input--pill.input--small {
    border-radius: var(--sl-input-height-small);
  }

  .input--pill.input--medium {
    border-radius: var(--sl-input-height-medium);
  }

  .input--pill.input--large {
    border-radius: var(--sl-input-height-large);
  }

  /*
   * Clearable + Password Toggle
   */

  .input__clear,
  .input__password-toggle {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    font-size: inherit;
    color: var(--sl-input-icon-color);
    border: none;
    background: none;
    padding: 0;
    transition: var(--sl-transition-fast) color;
    cursor: pointer;
  }

  .input__clear:hover,
  .input__password-toggle:hover {
    color: var(--sl-input-icon-color-hover);
  }

  .input__clear:focus,
  .input__password-toggle:focus {
    outline: none;
  }

  /* Don't show the browser's password toggle in Edge */
  ::-ms-reveal {
    display: none;
  }

  /* Hide the built-in number spinner */
  .input--no-spin-buttons input[type='number']::-webkit-outer-spin-button,
  .input--no-spin-buttons input[type='number']::-webkit-inner-spin-button {
    -webkit-appearance: none;
    display: none;
  }

  .input--no-spin-buttons input[type='number'] {
    -moz-appearance: textfield;
  }
`, SlInput = class extends ShoelaceElement {
  constructor() {
    super(...arguments), this.formControlController = new FormControlController(this, {
      assumeInteractionOn: ["sl-blur", "sl-input"]
    }), this.hasSlotController = new HasSlotController(this, "help-text", "label"), this.localize = new LocalizeController(this), this.hasFocus = !1, this.title = "", this.__numberInput = Object.assign(document.createElement("input"), { type: "number" }), this.__dateInput = Object.assign(document.createElement("input"), { type: "date" }), this.type = "text", this.name = "", this.value = "", this.defaultValue = "", this.size = "medium", this.filled = !1, this.pill = !1, this.label = "", this.helpText = "", this.clearable = !1, this.disabled = !1, this.placeholder = "", this.readonly = !1, this.passwordToggle = !1, this.passwordVisible = !1, this.noSpinButtons = !1, this.form = "", this.required = !1, this.spellcheck = !0;
  }
  //
  // NOTE: We use an in-memory input for these getters/setters instead of the one in the template because the properties
  // can be set before the component is rendered.
  //
  /**
   * Gets or sets the current value as a `Date` object. Returns `null` if the value can't be converted. This will use the native `<input type="{{type}}">` implementation and may result in an error.
   */
  get valueAsDate() {
    var C;
    return this.__dateInput.type = this.type, this.__dateInput.value = this.value, ((C = this.input) == null ? void 0 : C.valueAsDate) || this.__dateInput.valueAsDate;
  }
  set valueAsDate(C) {
    this.__dateInput.type = this.type, this.__dateInput.valueAsDate = C, this.value = this.__dateInput.value;
  }
  /** Gets or sets the current value as a number. Returns `NaN` if the value can't be converted. */
  get valueAsNumber() {
    var C;
    return this.__numberInput.value = this.value, ((C = this.input) == null ? void 0 : C.valueAsNumber) || this.__numberInput.valueAsNumber;
  }
  set valueAsNumber(C) {
    this.__numberInput.valueAsNumber = C, this.value = this.__numberInput.value;
  }
  /** Gets the validity state object */
  get validity() {
    return this.input.validity;
  }
  /** Gets the validation message */
  get validationMessage() {
    return this.input.validationMessage;
  }
  firstUpdated() {
    this.formControlController.updateValidity();
  }
  handleBlur() {
    this.hasFocus = !1, this.emit("sl-blur");
  }
  handleChange() {
    this.value = this.input.value, this.emit("sl-change");
  }
  handleClearClick(C) {
    C.preventDefault(), this.value !== "" && (this.value = "", this.emit("sl-clear"), this.emit("sl-input"), this.emit("sl-change")), this.input.focus();
  }
  handleFocus() {
    this.hasFocus = !0, this.emit("sl-focus");
  }
  handleInput() {
    this.value = this.input.value, this.formControlController.updateValidity(), this.emit("sl-input");
  }
  handleInvalid(C) {
    this.formControlController.setValidity(!1), this.formControlController.emitInvalidEvent(C);
  }
  handleKeyDown(C) {
    const L = C.metaKey || C.ctrlKey || C.shiftKey || C.altKey;
    C.key === "Enter" && !L && setTimeout(() => {
      !C.defaultPrevented && !C.isComposing && this.formControlController.submit();
    });
  }
  handlePasswordToggle() {
    this.passwordVisible = !this.passwordVisible;
  }
  handleDisabledChange() {
    this.formControlController.setValidity(this.disabled);
  }
  handleStepChange() {
    this.input.step = String(this.step), this.formControlController.updateValidity();
  }
  async handleValueChange() {
    await this.updateComplete, this.formControlController.updateValidity();
  }
  /** Sets focus on the input. */
  focus(C) {
    this.input.focus(C);
  }
  /** Removes focus from the input. */
  blur() {
    this.input.blur();
  }
  /** Selects all the text in the input. */
  select() {
    this.input.select();
  }
  /** Sets the start and end positions of the text selection (0-based). */
  setSelectionRange(C, L, A = "none") {
    this.input.setSelectionRange(C, L, A);
  }
  /** Replaces a range of text with a new string. */
  setRangeText(C, L, A, W = "preserve") {
    const X = L ?? this.input.selectionStart, J = A ?? this.input.selectionEnd;
    this.input.setRangeText(C, X, J, W), this.value !== this.input.value && (this.value = this.input.value);
  }
  /** Displays the browser picker for an input element (only works if the browser supports it for the input type). */
  showPicker() {
    "showPicker" in HTMLInputElement.prototype && this.input.showPicker();
  }
  /** Increments the value of a numeric input type by the value of the step attribute. */
  stepUp() {
    this.input.stepUp(), this.value !== this.input.value && (this.value = this.input.value);
  }
  /** Decrements the value of a numeric input type by the value of the step attribute. */
  stepDown() {
    this.input.stepDown(), this.value !== this.input.value && (this.value = this.input.value);
  }
  /** Checks for validity but does not show a validation message. Returns `true` when valid and `false` when invalid. */
  checkValidity() {
    return this.input.checkValidity();
  }
  /** Gets the associated form, if one exists. */
  getForm() {
    return this.formControlController.getForm();
  }
  /** Checks for validity and shows the browser's validation message if the control is invalid. */
  reportValidity() {
    return this.input.reportValidity();
  }
  /** Sets a custom validation message. Pass an empty string to restore validity. */
  setCustomValidity(C) {
    this.input.setCustomValidity(C), this.formControlController.updateValidity();
  }
  render() {
    const C = this.hasSlotController.test("label"), L = this.hasSlotController.test("help-text"), A = this.label ? !0 : !!C, W = this.helpText ? !0 : !!L, J = this.clearable && !this.disabled && !this.readonly && (typeof this.value == "number" || this.value.length > 0);
    return ke$1`
      <div
        part="form-control"
        class=${Rt({
      "form-control": !0,
      "form-control--small": this.size === "small",
      "form-control--medium": this.size === "medium",
      "form-control--large": this.size === "large",
      "form-control--has-label": A,
      "form-control--has-help-text": W
    })}
      >
        <label
          part="form-control-label"
          class="form-control__label"
          for="input"
          aria-hidden=${A ? "false" : "true"}
        >
          <slot name="label">${this.label}</slot>
        </label>

        <div part="form-control-input" class="form-control-input">
          <div
            part="base"
            class=${Rt({
      input: !0,
      // Sizes
      "input--small": this.size === "small",
      "input--medium": this.size === "medium",
      "input--large": this.size === "large",
      // States
      "input--pill": this.pill,
      "input--standard": !this.filled,
      "input--filled": this.filled,
      "input--disabled": this.disabled,
      "input--focused": this.hasFocus,
      "input--empty": !this.value,
      "input--no-spin-buttons": this.noSpinButtons
    })}
          >
            <span part="prefix" class="input__prefix">
              <slot name="prefix"></slot>
            </span>

            <input
              part="input"
              id="input"
              class="input__control"
              type=${this.type === "password" && this.passwordVisible ? "text" : this.type}
              title=${this.title}
              name=${to(this.name)}
              ?disabled=${this.disabled}
              ?readonly=${this.readonly}
              ?required=${this.required}
              placeholder=${to(this.placeholder)}
              minlength=${to(this.minlength)}
              maxlength=${to(this.maxlength)}
              min=${to(this.min)}
              max=${to(this.max)}
              step=${to(this.step)}
              .value=${Ft(this.value)}
              autocapitalize=${to(this.autocapitalize)}
              autocomplete=${to(this.autocomplete)}
              autocorrect=${to(this.autocorrect)}
              ?autofocus=${this.autofocus}
              spellcheck=${this.spellcheck}
              pattern=${to(this.pattern)}
              enterkeyhint=${to(this.enterkeyhint)}
              inputmode=${to(this.inputmode)}
              aria-describedby="help-text"
              @change=${this.handleChange}
              @input=${this.handleInput}
              @invalid=${this.handleInvalid}
              @keydown=${this.handleKeyDown}
              @focus=${this.handleFocus}
              @blur=${this.handleBlur}
            />

            ${J ? ke$1`
                  <button
                    part="clear-button"
                    class="input__clear"
                    type="button"
                    aria-label=${this.localize.term("clearEntry")}
                    @click=${this.handleClearClick}
                    tabindex="-1"
                  >
                    <slot name="clear-icon">
                      <sl-icon name="x-circle-fill" library="system"></sl-icon>
                    </slot>
                  </button>
                ` : ""}
            ${this.passwordToggle && !this.disabled ? ke$1`
                  <button
                    part="password-toggle-button"
                    class="input__password-toggle"
                    type="button"
                    aria-label=${this.localize.term(this.passwordVisible ? "hidePassword" : "showPassword")}
                    @click=${this.handlePasswordToggle}
                    tabindex="-1"
                  >
                    ${this.passwordVisible ? ke$1`
                          <slot name="show-password-icon">
                            <sl-icon name="eye-slash" library="system"></sl-icon>
                          </slot>
                        ` : ke$1`
                          <slot name="hide-password-icon">
                            <sl-icon name="eye" library="system"></sl-icon>
                          </slot>
                        `}
                  </button>
                ` : ""}

            <span part="suffix" class="input__suffix">
              <slot name="suffix"></slot>
            </span>
          </div>
        </div>

        <div
          part="form-control-help-text"
          id="help-text"
          class="form-control__help-text"
          aria-hidden=${W ? "false" : "true"}
        >
          <slot name="help-text">${this.helpText}</slot>
        </div>
      </div>
    `;
  }
};
SlInput.styles = [component_styles_default, form_control_styles_default, input_styles_default];
SlInput.dependencies = { "sl-icon": SlIcon };
__decorateClass$e([
  e$6(".input__control")
], SlInput.prototype, "input", 2);
__decorateClass$e([
  r$3()
], SlInput.prototype, "hasFocus", 2);
__decorateClass$e([
  n$1()
], SlInput.prototype, "title", 2);
__decorateClass$e([
  n$1({ reflect: !0 })
], SlInput.prototype, "type", 2);
__decorateClass$e([
  n$1()
], SlInput.prototype, "name", 2);
__decorateClass$e([
  n$1()
], SlInput.prototype, "value", 2);
__decorateClass$e([
  defaultValue()
], SlInput.prototype, "defaultValue", 2);
__decorateClass$e([
  n$1({ reflect: !0 })
], SlInput.prototype, "size", 2);
__decorateClass$e([
  n$1({ type: Boolean, reflect: !0 })
], SlInput.prototype, "filled", 2);
__decorateClass$e([
  n$1({ type: Boolean, reflect: !0 })
], SlInput.prototype, "pill", 2);
__decorateClass$e([
  n$1()
], SlInput.prototype, "label", 2);
__decorateClass$e([
  n$1({ attribute: "help-text" })
], SlInput.prototype, "helpText", 2);
__decorateClass$e([
  n$1({ type: Boolean })
], SlInput.prototype, "clearable", 2);
__decorateClass$e([
  n$1({ type: Boolean, reflect: !0 })
], SlInput.prototype, "disabled", 2);
__decorateClass$e([
  n$1()
], SlInput.prototype, "placeholder", 2);
__decorateClass$e([
  n$1({ type: Boolean, reflect: !0 })
], SlInput.prototype, "readonly", 2);
__decorateClass$e([
  n$1({ attribute: "password-toggle", type: Boolean })
], SlInput.prototype, "passwordToggle", 2);
__decorateClass$e([
  n$1({ attribute: "password-visible", type: Boolean })
], SlInput.prototype, "passwordVisible", 2);
__decorateClass$e([
  n$1({ attribute: "no-spin-buttons", type: Boolean })
], SlInput.prototype, "noSpinButtons", 2);
__decorateClass$e([
  n$1({ reflect: !0 })
], SlInput.prototype, "form", 2);
__decorateClass$e([
  n$1({ type: Boolean, reflect: !0 })
], SlInput.prototype, "required", 2);
__decorateClass$e([
  n$1()
], SlInput.prototype, "pattern", 2);
__decorateClass$e([
  n$1({ type: Number })
], SlInput.prototype, "minlength", 2);
__decorateClass$e([
  n$1({ type: Number })
], SlInput.prototype, "maxlength", 2);
__decorateClass$e([
  n$1()
], SlInput.prototype, "min", 2);
__decorateClass$e([
  n$1()
], SlInput.prototype, "max", 2);
__decorateClass$e([
  n$1()
], SlInput.prototype, "step", 2);
__decorateClass$e([
  n$1()
], SlInput.prototype, "autocapitalize", 2);
__decorateClass$e([
  n$1()
], SlInput.prototype, "autocorrect", 2);
__decorateClass$e([
  n$1()
], SlInput.prototype, "autocomplete", 2);
__decorateClass$e([
  n$1({ type: Boolean })
], SlInput.prototype, "autofocus", 2);
__decorateClass$e([
  n$1()
], SlInput.prototype, "enterkeyhint", 2);
__decorateClass$e([
  n$1({
    type: Boolean,
    converter: {
      // Allow "true|false" attribute values but keep the property boolean
      fromAttribute: (C) => !(!C || C === "false"),
      toAttribute: (C) => C ? "true" : "false"
    }
  })
], SlInput.prototype, "spellcheck", 2);
__decorateClass$e([
  n$1()
], SlInput.prototype, "inputmode", 2);
__decorateClass$e([
  watch("disabled", { waitUntilFirstUpdate: !0 })
], SlInput.prototype, "handleDisabledChange", 1);
__decorateClass$e([
  watch("step", { waitUntilFirstUpdate: !0 })
], SlInput.prototype, "handleStepChange", 1);
__decorateClass$e([
  watch("value", { waitUntilFirstUpdate: !0 })
], SlInput.prototype, "handleValueChange", 1);
SlInput.define("sl-input");
var menu_label_styles_default = i$5`
  :host {
    display: block;
  }

  .menu-label {
    display: inline-block;
    font-family: var(--sl-font-sans);
    font-size: var(--sl-font-size-small);
    font-weight: var(--sl-font-weight-semibold);
    line-height: var(--sl-line-height-normal);
    letter-spacing: var(--sl-letter-spacing-normal);
    color: var(--sl-color-neutral-500);
    padding: var(--sl-spacing-2x-small) var(--sl-spacing-x-large);
    user-select: none;
    -webkit-user-select: none;
  }
`, SlMenuLabel = class extends ShoelaceElement {
  render() {
    return ke$1` <slot part="base" class="menu-label"></slot> `;
  }
};
SlMenuLabel.styles = [component_styles_default, menu_label_styles_default];
SlMenuLabel.define("sl-menu-label");
var image_comparer_styles_default = i$5`
  :host {
    --divider-width: 2px;
    --handle-size: 2.5rem;

    display: inline-block;
    position: relative;
  }

  .image-comparer {
    max-width: 100%;
    max-height: 100%;
    overflow: hidden;
  }

  .image-comparer__before,
  .image-comparer__after {
    display: block;
    pointer-events: none;
  }

  .image-comparer__before::slotted(img),
  .image-comparer__after::slotted(img),
  .image-comparer__before::slotted(svg),
  .image-comparer__after::slotted(svg) {
    display: block;
    max-width: 100% !important;
    height: auto;
  }

  .image-comparer__after {
    position: absolute;
    top: 0;
    left: 0;
    height: 100%;
    width: 100%;
  }

  .image-comparer__divider {
    display: flex;
    align-items: center;
    justify-content: center;
    position: absolute;
    top: 0;
    width: var(--divider-width);
    height: 100%;
    background-color: var(--sl-color-neutral-0);
    translate: calc(var(--divider-width) / -2);
    cursor: ew-resize;
  }

  .image-comparer__handle {
    display: flex;
    align-items: center;
    justify-content: center;
    position: absolute;
    top: calc(50% - (var(--handle-size) / 2));
    width: var(--handle-size);
    height: var(--handle-size);
    background-color: var(--sl-color-neutral-0);
    border-radius: var(--sl-border-radius-circle);
    font-size: calc(var(--handle-size) * 0.5);
    color: var(--sl-color-neutral-700);
    cursor: inherit;
    z-index: 10;
  }

  .image-comparer__handle:focus-visible {
    outline: var(--sl-focus-ring);
    outline-offset: var(--sl-focus-ring-offset);
  }
`, SlImageComparer = class extends ShoelaceElement {
  constructor() {
    super(...arguments), this.position = 50;
  }
  handleDrag(C) {
    const { width: L } = this.base.getBoundingClientRect(), A = this.matches(":dir(rtl)");
    C.preventDefault(), drag(this.base, {
      onMove: (W) => {
        this.position = parseFloat(clamp(W / L * 100, 0, 100).toFixed(2)), A && (this.position = 100 - this.position);
      },
      initialEvent: C
    });
  }
  handleKeyDown(C) {
    const L = this.matches(":dir(ltr)"), A = this.matches(":dir(rtl)");
    if (["ArrowLeft", "ArrowRight", "Home", "End"].includes(C.key)) {
      const W = C.shiftKey ? 10 : 1;
      let X = this.position;
      C.preventDefault(), (L && C.key === "ArrowLeft" || A && C.key === "ArrowRight") && (X -= W), (L && C.key === "ArrowRight" || A && C.key === "ArrowLeft") && (X += W), C.key === "Home" && (X = 0), C.key === "End" && (X = 100), X = clamp(X, 0, 100), this.position = X;
    }
  }
  handlePositionChange() {
    this.emit("sl-change");
  }
  render() {
    const C = this.matches(":dir(rtl)");
    return ke$1`
      <div
        part="base"
        id="image-comparer"
        class=${Rt({
      "image-comparer": !0,
      "image-comparer--rtl": C
    })}
        @keydown=${this.handleKeyDown}
      >
        <div class="image-comparer__image">
          <div part="before" class="image-comparer__before">
            <slot name="before"></slot>
          </div>

          <div
            part="after"
            class="image-comparer__after"
            style=${se({
      clipPath: C ? `inset(0 0 0 ${100 - this.position}%)` : `inset(0 ${100 - this.position}% 0 0)`
    })}
          >
            <slot name="after"></slot>
          </div>
        </div>

        <div
          part="divider"
          class="image-comparer__divider"
          style=${se({
      left: C ? `${100 - this.position}%` : `${this.position}%`
    })}
          @mousedown=${this.handleDrag}
          @touchstart=${this.handleDrag}
        >
          <div
            part="handle"
            class="image-comparer__handle"
            role="scrollbar"
            aria-valuenow=${this.position}
            aria-valuemin="0"
            aria-valuemax="100"
            aria-controls="image-comparer"
            tabindex="0"
          >
            <slot name="handle">
              <sl-icon library="system" name="grip-vertical"></sl-icon>
            </slot>
          </div>
        </div>
      </div>
    `;
  }
};
SlImageComparer.styles = [component_styles_default, image_comparer_styles_default];
SlImageComparer.scopedElement = { "sl-icon": SlIcon };
__decorateClass$e([
  e$6(".image-comparer")
], SlImageComparer.prototype, "base", 2);
__decorateClass$e([
  e$6(".image-comparer__handle")
], SlImageComparer.prototype, "handle", 2);
__decorateClass$e([
  n$1({ type: Number, reflect: !0 })
], SlImageComparer.prototype, "position", 2);
__decorateClass$e([
  watch("position", { waitUntilFirstUpdate: !0 })
], SlImageComparer.prototype, "handlePositionChange", 1);
SlImageComparer.define("sl-image-comparer");
var menu_styles_default = i$5`
  :host {
    display: block;
    position: relative;
    background: var(--sl-panel-background-color);
    border: solid var(--sl-panel-border-width) var(--sl-panel-border-color);
    border-radius: var(--sl-border-radius-medium);
    padding: var(--sl-spacing-x-small) 0;
    overflow: auto;
    overscroll-behavior: none;
  }

  ::slotted(sl-divider) {
    --spacing: var(--sl-spacing-x-small);
  }
`, SlMenu = class extends ShoelaceElement {
  connectedCallback() {
    super.connectedCallback(), this.setAttribute("role", "menu");
  }
  handleClick(C) {
    const L = ["menuitem", "menuitemcheckbox"], A = C.composedPath(), W = A.find((oe) => {
      var ne;
      return L.includes(((ne = oe == null ? void 0 : oe.getAttribute) == null ? void 0 : ne.call(oe, "role")) || "");
    });
    if (!W || A.find((oe) => {
      var ne;
      return ((ne = oe == null ? void 0 : oe.getAttribute) == null ? void 0 : ne.call(oe, "role")) === "menu";
    }) !== this)
      return;
    const te = W;
    te.type === "checkbox" && (te.checked = !te.checked), this.emit("sl-select", { detail: { item: te } });
  }
  handleKeyDown(C) {
    if (C.key === "Enter" || C.key === " ") {
      const L = this.getCurrentItem();
      C.preventDefault(), C.stopPropagation(), L == null || L.click();
    } else if (["ArrowDown", "ArrowUp", "Home", "End"].includes(C.key)) {
      const L = this.getAllItems(), A = this.getCurrentItem();
      let W = A ? L.indexOf(A) : 0;
      L.length > 0 && (C.preventDefault(), C.stopPropagation(), C.key === "ArrowDown" ? W++ : C.key === "ArrowUp" ? W-- : C.key === "Home" ? W = 0 : C.key === "End" && (W = L.length - 1), W < 0 && (W = L.length - 1), W > L.length - 1 && (W = 0), this.setCurrentItem(L[W]), L[W].focus());
    }
  }
  handleMouseDown(C) {
    const L = C.target;
    this.isMenuItem(L) && this.setCurrentItem(L);
  }
  handleSlotChange() {
    const C = this.getAllItems();
    C.length > 0 && this.setCurrentItem(C[0]);
  }
  isMenuItem(C) {
    var L;
    return C.tagName.toLowerCase() === "sl-menu-item" || ["menuitem", "menuitemcheckbox", "menuitemradio"].includes((L = C.getAttribute("role")) != null ? L : "");
  }
  /** @internal Gets all slotted menu items, ignoring dividers, headers, and other elements. */
  getAllItems() {
    return [...this.defaultSlot.assignedElements({ flatten: !0 })].filter((C) => !(C.inert || !this.isMenuItem(C)));
  }
  /**
   * @internal Gets the current menu item, which is the menu item that has `tabindex="0"` within the roving tab index.
   * The menu item may or may not have focus, but for keyboard interaction purposes it's considered the "active" item.
   */
  getCurrentItem() {
    return this.getAllItems().find((C) => C.getAttribute("tabindex") === "0");
  }
  /**
   * @internal Sets the current menu item to the specified element. This sets `tabindex="0"` on the target element and
   * `tabindex="-1"` to all other items. This method must be called prior to setting focus on a menu item.
   */
  setCurrentItem(C) {
    this.getAllItems().forEach((A) => {
      A.setAttribute("tabindex", A === C ? "0" : "-1");
    });
  }
  render() {
    return ke$1`
      <slot
        @slotchange=${this.handleSlotChange}
        @click=${this.handleClick}
        @keydown=${this.handleKeyDown}
        @mousedown=${this.handleMouseDown}
      ></slot>
    `;
  }
};
SlMenu.styles = [component_styles_default, menu_styles_default];
__decorateClass$e([
  e$6("slot")
], SlMenu.prototype, "defaultSlot", 2);
SlMenu.define("sl-menu");
var includeFiles = /* @__PURE__ */ new Map();
function requestInclude(C, L = "cors") {
  const A = includeFiles.get(C);
  if (A !== void 0)
    return Promise.resolve(A);
  const W = fetch(C, { mode: L }).then(async (X) => {
    const J = {
      ok: X.ok,
      status: X.status,
      html: await X.text()
    };
    return includeFiles.set(C, J), J;
  });
  return includeFiles.set(C, W), W;
}
var include_styles_default = i$5`
  :host {
    display: block;
  }
`, SlInclude = class extends ShoelaceElement {
  constructor() {
    super(...arguments), this.mode = "cors", this.allowScripts = !1;
  }
  executeScript(C) {
    const L = document.createElement("script");
    [...C.attributes].forEach((A) => L.setAttribute(A.name, A.value)), L.textContent = C.textContent, C.parentNode.replaceChild(L, C);
  }
  async handleSrcChange() {
    try {
      const C = this.src, L = await requestInclude(C, this.mode);
      if (C !== this.src)
        return;
      if (!L.ok) {
        this.emit("sl-error", { detail: { status: L.status } });
        return;
      }
      this.innerHTML = L.html, this.allowScripts && [...this.querySelectorAll("script")].forEach((A) => this.executeScript(A)), this.emit("sl-load");
    } catch {
      this.emit("sl-error", { detail: { status: -1 } });
    }
  }
  render() {
    return ke$1`<slot></slot>`;
  }
};
SlInclude.styles = [component_styles_default, include_styles_default];
__decorateClass$e([
  n$1()
], SlInclude.prototype, "src", 2);
__decorateClass$e([
  n$1()
], SlInclude.prototype, "mode", 2);
__decorateClass$e([
  n$1({ attribute: "allow-scripts", type: Boolean })
], SlInclude.prototype, "allowScripts", 2);
__decorateClass$e([
  watch("src")
], SlInclude.prototype, "handleSrcChange", 1);
SlInclude.define("sl-include");
SlIcon.define("sl-icon");
SlIconButton.define("sl-icon-button");
var SlFormatBytes = class extends ShoelaceElement {
  constructor() {
    super(...arguments), this.localize = new LocalizeController(this), this.value = 0, this.unit = "byte", this.display = "short";
  }
  render() {
    if (isNaN(this.value))
      return "";
    const C = ["", "kilo", "mega", "giga", "tera"], L = ["", "kilo", "mega", "giga", "tera", "peta"], A = this.unit === "bit" ? C : L, W = Math.max(0, Math.min(Math.floor(Math.log10(this.value) / 3), A.length - 1)), X = A[W] + this.unit, J = parseFloat((this.value / Math.pow(1e3, W)).toPrecision(3));
    return this.localize.number(J, {
      style: "unit",
      unit: X,
      unitDisplay: this.display
    });
  }
};
__decorateClass$e([
  n$1({ type: Number })
], SlFormatBytes.prototype, "value", 2);
__decorateClass$e([
  n$1()
], SlFormatBytes.prototype, "unit", 2);
__decorateClass$e([
  n$1()
], SlFormatBytes.prototype, "display", 2);
SlFormatBytes.define("sl-format-bytes");
var SlFormatDate = class extends ShoelaceElement {
  constructor() {
    super(...arguments), this.localize = new LocalizeController(this), this.date = /* @__PURE__ */ new Date(), this.hourFormat = "auto";
  }
  render() {
    const C = new Date(this.date), L = this.hourFormat === "auto" ? void 0 : this.hourFormat === "12";
    if (!isNaN(C.getMilliseconds()))
      return ke$1`
      <time datetime=${C.toISOString()}>
        ${this.localize.date(C, {
        weekday: this.weekday,
        era: this.era,
        year: this.year,
        month: this.month,
        day: this.day,
        hour: this.hour,
        minute: this.minute,
        second: this.second,
        timeZoneName: this.timeZoneName,
        timeZone: this.timeZone,
        hour12: L
      })}
      </time>
    `;
  }
};
__decorateClass$e([
  n$1()
], SlFormatDate.prototype, "date", 2);
__decorateClass$e([
  n$1()
], SlFormatDate.prototype, "weekday", 2);
__decorateClass$e([
  n$1()
], SlFormatDate.prototype, "era", 2);
__decorateClass$e([
  n$1()
], SlFormatDate.prototype, "year", 2);
__decorateClass$e([
  n$1()
], SlFormatDate.prototype, "month", 2);
__decorateClass$e([
  n$1()
], SlFormatDate.prototype, "day", 2);
__decorateClass$e([
  n$1()
], SlFormatDate.prototype, "hour", 2);
__decorateClass$e([
  n$1()
], SlFormatDate.prototype, "minute", 2);
__decorateClass$e([
  n$1()
], SlFormatDate.prototype, "second", 2);
__decorateClass$e([
  n$1({ attribute: "time-zone-name" })
], SlFormatDate.prototype, "timeZoneName", 2);
__decorateClass$e([
  n$1({ attribute: "time-zone" })
], SlFormatDate.prototype, "timeZone", 2);
__decorateClass$e([
  n$1({ attribute: "hour-format" })
], SlFormatDate.prototype, "hourFormat", 2);
SlFormatDate.define("sl-format-date");
var SlFormatNumber = class extends ShoelaceElement {
  constructor() {
    super(...arguments), this.localize = new LocalizeController(this), this.value = 0, this.type = "decimal", this.noGrouping = !1, this.currency = "USD", this.currencyDisplay = "symbol";
  }
  render() {
    return isNaN(this.value) ? "" : this.localize.number(this.value, {
      style: this.type,
      currency: this.currency,
      currencyDisplay: this.currencyDisplay,
      useGrouping: !this.noGrouping,
      minimumIntegerDigits: this.minimumIntegerDigits,
      minimumFractionDigits: this.minimumFractionDigits,
      maximumFractionDigits: this.maximumFractionDigits,
      minimumSignificantDigits: this.minimumSignificantDigits,
      maximumSignificantDigits: this.maximumSignificantDigits
    });
  }
};
__decorateClass$e([
  n$1({ type: Number })
], SlFormatNumber.prototype, "value", 2);
__decorateClass$e([
  n$1()
], SlFormatNumber.prototype, "type", 2);
__decorateClass$e([
  n$1({ attribute: "no-grouping", type: Boolean })
], SlFormatNumber.prototype, "noGrouping", 2);
__decorateClass$e([
  n$1()
], SlFormatNumber.prototype, "currency", 2);
__decorateClass$e([
  n$1({ attribute: "currency-display" })
], SlFormatNumber.prototype, "currencyDisplay", 2);
__decorateClass$e([
  n$1({ attribute: "minimum-integer-digits", type: Number })
], SlFormatNumber.prototype, "minimumIntegerDigits", 2);
__decorateClass$e([
  n$1({ attribute: "minimum-fraction-digits", type: Number })
], SlFormatNumber.prototype, "minimumFractionDigits", 2);
__decorateClass$e([
  n$1({ attribute: "maximum-fraction-digits", type: Number })
], SlFormatNumber.prototype, "maximumFractionDigits", 2);
__decorateClass$e([
  n$1({ attribute: "minimum-significant-digits", type: Number })
], SlFormatNumber.prototype, "minimumSignificantDigits", 2);
__decorateClass$e([
  n$1({ attribute: "maximum-significant-digits", type: Number })
], SlFormatNumber.prototype, "maximumSignificantDigits", 2);
SlFormatNumber.define("sl-format-number");
var divider_styles_default = i$5`
  :host {
    --color: var(--sl-panel-border-color);
    --width: var(--sl-panel-border-width);
    --spacing: var(--sl-spacing-medium);
  }

  :host(:not([vertical])) {
    display: block;
    border-top: solid var(--width) var(--color);
    margin: var(--spacing) 0;
  }

  :host([vertical]) {
    display: inline-block;
    height: 100%;
    border-left: solid var(--width) var(--color);
    margin: 0 var(--spacing);
  }
`, SlDivider = class extends ShoelaceElement {
  constructor() {
    super(...arguments), this.vertical = !1;
  }
  connectedCallback() {
    super.connectedCallback(), this.setAttribute("role", "separator");
  }
  handleVerticalChange() {
    this.setAttribute("aria-orientation", this.vertical ? "vertical" : "horizontal");
  }
};
SlDivider.styles = [component_styles_default, divider_styles_default];
__decorateClass$e([
  n$1({ type: Boolean, reflect: !0 })
], SlDivider.prototype, "vertical", 2);
__decorateClass$e([
  watch("vertical")
], SlDivider.prototype, "handleVerticalChange", 1);
SlDivider.define("sl-divider");
var drawer_styles_default = i$5`
  :host {
    --size: 25rem;
    --header-spacing: var(--sl-spacing-large);
    --body-spacing: var(--sl-spacing-large);
    --footer-spacing: var(--sl-spacing-large);

    display: contents;
  }

  .drawer {
    top: 0;
    inset-inline-start: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
    overflow: hidden;
  }

  .drawer--contained {
    position: absolute;
    z-index: initial;
  }

  .drawer--fixed {
    position: fixed;
    z-index: var(--sl-z-index-drawer);
  }

  .drawer__panel {
    position: absolute;
    display: flex;
    flex-direction: column;
    z-index: 2;
    max-width: 100%;
    max-height: 100%;
    background-color: var(--sl-panel-background-color);
    box-shadow: var(--sl-shadow-x-large);
    overflow: auto;
    pointer-events: all;
  }

  .drawer__panel:focus {
    outline: none;
  }

  .drawer--top .drawer__panel {
    top: 0;
    inset-inline-end: auto;
    bottom: auto;
    inset-inline-start: 0;
    width: 100%;
    height: var(--size);
  }

  .drawer--end .drawer__panel {
    top: 0;
    inset-inline-end: 0;
    bottom: auto;
    inset-inline-start: auto;
    width: var(--size);
    height: 100%;
  }

  .drawer--bottom .drawer__panel {
    top: auto;
    inset-inline-end: auto;
    bottom: 0;
    inset-inline-start: 0;
    width: 100%;
    height: var(--size);
  }

  .drawer--start .drawer__panel {
    top: 0;
    inset-inline-end: auto;
    bottom: auto;
    inset-inline-start: 0;
    width: var(--size);
    height: 100%;
  }

  .drawer__header {
    display: flex;
  }

  .drawer__title {
    flex: 1 1 auto;
    font: inherit;
    font-size: var(--sl-font-size-large);
    line-height: var(--sl-line-height-dense);
    padding: var(--header-spacing);
    margin: 0;
  }

  .drawer__header-actions {
    flex-shrink: 0;
    display: flex;
    flex-wrap: wrap;
    justify-content: end;
    gap: var(--sl-spacing-2x-small);
    padding: 0 var(--header-spacing);
  }

  .drawer__header-actions sl-icon-button,
  .drawer__header-actions ::slotted(sl-icon-button) {
    flex: 0 0 auto;
    display: flex;
    align-items: center;
    font-size: var(--sl-font-size-medium);
  }

  .drawer__body {
    flex: 1 1 auto;
    display: block;
    padding: var(--body-spacing);
    overflow: auto;
    -webkit-overflow-scrolling: touch;
  }

  .drawer__footer {
    text-align: right;
    padding: var(--footer-spacing);
  }

  .drawer__footer ::slotted(sl-button:not(:last-of-type)) {
    margin-inline-end: var(--sl-spacing-x-small);
  }

  .drawer:not(.drawer--has-footer) .drawer__footer {
    display: none;
  }

  .drawer__overlay {
    display: block;
    position: fixed;
    top: 0;
    right: 0;
    bottom: 0;
    left: 0;
    background-color: var(--sl-overlay-background-color);
    pointer-events: all;
  }

  .drawer--contained .drawer__overlay {
    display: none;
  }

  @media (forced-colors: active) {
    .drawer__panel {
      border: solid 1px var(--sl-color-neutral-0);
    }
  }
`, computedStyleMap = /* @__PURE__ */ new WeakMap();
function getCachedComputedStyle(C) {
  let L = computedStyleMap.get(C);
  return L || (L = window.getComputedStyle(C, null), computedStyleMap.set(C, L)), L;
}
function isVisible(C) {
  if (typeof C.checkVisibility == "function")
    return C.checkVisibility({ checkOpacity: !1, checkVisibilityCSS: !0 });
  const L = getCachedComputedStyle(C);
  return L.visibility !== "hidden" && L.display !== "none";
}
function isOverflowingAndTabbable(C) {
  const L = getCachedComputedStyle(C), { overflowY: A, overflowX: W } = L;
  return A === "scroll" || W === "scroll" ? !0 : A !== "auto" || W !== "auto" ? !1 : C.scrollHeight > C.clientHeight && A === "auto" || C.scrollWidth > C.clientWidth && W === "auto";
}
function isTabbable(C) {
  const L = C.tagName.toLowerCase(), A = Number(C.getAttribute("tabindex"));
  return C.hasAttribute("tabindex") && (isNaN(A) || A <= -1) || C.hasAttribute("disabled") || C.closest("[inert]") || L === "input" && C.getAttribute("type") === "radio" && !C.hasAttribute("checked") || !isVisible(C) ? !1 : (L === "audio" || L === "video") && C.hasAttribute("controls") || C.hasAttribute("tabindex") || C.hasAttribute("contenteditable") && C.getAttribute("contenteditable") !== "false" || [
    "button",
    "input",
    "select",
    "textarea",
    "a",
    "audio",
    "video",
    "summary",
    "iframe"
  ].includes(L) ? !0 : isOverflowingAndTabbable(C);
}
function getTabbableBoundary(C) {
  var L, A;
  const W = getTabbableElements(C), X = (L = W[0]) != null ? L : null, J = (A = W[W.length - 1]) != null ? A : null;
  return { start: X, end: J };
}
function getSlottedChildrenOutsideRootElement(C, L) {
  var A;
  return ((A = C.getRootNode({ composed: !0 })) == null ? void 0 : A.host) !== L;
}
function getTabbableElements(C) {
  const L = /* @__PURE__ */ new WeakMap(), A = [];
  function W(X) {
    if (X instanceof Element) {
      if (X.hasAttribute("inert") || X.closest("[inert]") || L.has(X))
        return;
      L.set(X, !0), !A.includes(X) && isTabbable(X) && A.push(X), X instanceof HTMLSlotElement && getSlottedChildrenOutsideRootElement(X, C) && X.assignedElements({ flatten: !0 }).forEach((J) => {
        W(J);
      }), X.shadowRoot !== null && X.shadowRoot.mode === "open" && W(X.shadowRoot);
    }
    for (const J of X.children)
      W(J);
  }
  return W(C), A.sort((X, J) => {
    const te = Number(X.getAttribute("tabindex")) || 0;
    return (Number(J.getAttribute("tabindex")) || 0) - te;
  });
}
function* activeElements(C = document.activeElement) {
  C != null && (yield C, "shadowRoot" in C && C.shadowRoot && C.shadowRoot.mode !== "closed" && (yield* __yieldStar(activeElements(C.shadowRoot.activeElement))));
}
function getDeepestActiveElement() {
  return [...activeElements()].pop();
}
var activeModals = [], Modal = class {
  constructor(C) {
    this.tabDirection = "forward", this.handleFocusIn = () => {
      this.isActive() && this.checkFocus();
    }, this.handleKeyDown = (L) => {
      var A;
      if (L.key !== "Tab" || this.isExternalActivated || !this.isActive())
        return;
      const W = getDeepestActiveElement();
      if (this.previousFocus = W, this.previousFocus && this.possiblyHasTabbableChildren(this.previousFocus))
        return;
      L.shiftKey ? this.tabDirection = "backward" : this.tabDirection = "forward";
      const X = getTabbableElements(this.element);
      let J = X.findIndex((oe) => oe === W);
      this.previousFocus = this.currentFocus;
      const te = this.tabDirection === "forward" ? 1 : -1;
      for (; ; ) {
        J + te >= X.length ? J = 0 : J + te < 0 ? J = X.length - 1 : J += te, this.previousFocus = this.currentFocus;
        const oe = (
          /** @type {HTMLElement} */
          X[J]
        );
        if (this.tabDirection === "backward" && this.previousFocus && this.possiblyHasTabbableChildren(this.previousFocus) || oe && this.possiblyHasTabbableChildren(oe))
          return;
        L.preventDefault(), this.currentFocus = oe, (A = this.currentFocus) == null || A.focus({ preventScroll: !1 });
        const ne = [...activeElements()];
        if (ne.includes(this.currentFocus) || !ne.includes(this.previousFocus))
          break;
      }
      setTimeout(() => this.checkFocus());
    }, this.handleKeyUp = () => {
      this.tabDirection = "forward";
    }, this.element = C, this.elementsWithTabbableControls = ["iframe"];
  }
  /** Activates focus trapping. */
  activate() {
    activeModals.push(this.element), document.addEventListener("focusin", this.handleFocusIn), document.addEventListener("keydown", this.handleKeyDown), document.addEventListener("keyup", this.handleKeyUp);
  }
  /** Deactivates focus trapping. */
  deactivate() {
    activeModals = activeModals.filter((C) => C !== this.element), this.currentFocus = null, document.removeEventListener("focusin", this.handleFocusIn), document.removeEventListener("keydown", this.handleKeyDown), document.removeEventListener("keyup", this.handleKeyUp);
  }
  /** Determines if this modal element is currently active or not. */
  isActive() {
    return activeModals[activeModals.length - 1] === this.element;
  }
  /** Activates external modal behavior and temporarily disables focus trapping. */
  activateExternal() {
    this.isExternalActivated = !0;
  }
  /** Deactivates external modal behavior and re-enables focus trapping. */
  deactivateExternal() {
    this.isExternalActivated = !1;
  }
  checkFocus() {
    if (this.isActive() && !this.isExternalActivated) {
      const C = getTabbableElements(this.element);
      if (!this.element.matches(":focus-within")) {
        const L = C[0], A = C[C.length - 1], W = this.tabDirection === "forward" ? L : A;
        typeof (W == null ? void 0 : W.focus) == "function" && (this.currentFocus = W, W.focus({ preventScroll: !1 }));
      }
    }
  }
  possiblyHasTabbableChildren(C) {
    return this.elementsWithTabbableControls.includes(C.tagName.toLowerCase()) || C.hasAttribute("controls");
  }
};
function uppercaseFirstLetter(C) {
  return C.charAt(0).toUpperCase() + C.slice(1);
}
var SlDrawer = class extends ShoelaceElement {
  constructor() {
    super(...arguments), this.hasSlotController = new HasSlotController(this, "footer"), this.localize = new LocalizeController(this), this.modal = new Modal(this), this.open = !1, this.label = "", this.placement = "end", this.contained = !1, this.noHeader = !1, this.handleDocumentKeyDown = (C) => {
      this.contained || C.key === "Escape" && this.modal.isActive() && this.open && (C.stopImmediatePropagation(), this.requestClose("keyboard"));
    };
  }
  firstUpdated() {
    this.drawer.hidden = !this.open, this.open && (this.addOpenListeners(), this.contained || (this.modal.activate(), lockBodyScrolling(this)));
  }
  disconnectedCallback() {
    var C;
    super.disconnectedCallback(), unlockBodyScrolling(this), (C = this.closeWatcher) == null || C.destroy();
  }
  requestClose(C) {
    if (this.emit("sl-request-close", {
      cancelable: !0,
      detail: { source: C }
    }).defaultPrevented) {
      const A = getAnimation(this, "drawer.denyClose", { dir: this.localize.dir() });
      animateTo(this.panel, A.keyframes, A.options);
      return;
    }
    this.hide();
  }
  addOpenListeners() {
    var C;
    "CloseWatcher" in window ? ((C = this.closeWatcher) == null || C.destroy(), this.contained || (this.closeWatcher = new CloseWatcher(), this.closeWatcher.onclose = () => this.requestClose("keyboard"))) : document.addEventListener("keydown", this.handleDocumentKeyDown);
  }
  removeOpenListeners() {
    var C;
    document.removeEventListener("keydown", this.handleDocumentKeyDown), (C = this.closeWatcher) == null || C.destroy();
  }
  async handleOpenChange() {
    if (this.open) {
      this.emit("sl-show"), this.addOpenListeners(), this.originalTrigger = document.activeElement, this.contained || (this.modal.activate(), lockBodyScrolling(this));
      const C = this.querySelector("[autofocus]");
      C && C.removeAttribute("autofocus"), await Promise.all([stopAnimations(this.drawer), stopAnimations(this.overlay)]), this.drawer.hidden = !1, requestAnimationFrame(() => {
        this.emit("sl-initial-focus", { cancelable: !0 }).defaultPrevented || (C ? C.focus({ preventScroll: !0 }) : this.panel.focus({ preventScroll: !0 })), C && C.setAttribute("autofocus", "");
      });
      const L = getAnimation(this, `drawer.show${uppercaseFirstLetter(this.placement)}`, {
        dir: this.localize.dir()
      }), A = getAnimation(this, "drawer.overlay.show", { dir: this.localize.dir() });
      await Promise.all([
        animateTo(this.panel, L.keyframes, L.options),
        animateTo(this.overlay, A.keyframes, A.options)
      ]), this.emit("sl-after-show");
    } else {
      this.emit("sl-hide"), this.removeOpenListeners(), this.contained || (this.modal.deactivate(), unlockBodyScrolling(this)), await Promise.all([stopAnimations(this.drawer), stopAnimations(this.overlay)]);
      const C = getAnimation(this, `drawer.hide${uppercaseFirstLetter(this.placement)}`, {
        dir: this.localize.dir()
      }), L = getAnimation(this, "drawer.overlay.hide", { dir: this.localize.dir() });
      await Promise.all([
        animateTo(this.overlay, L.keyframes, L.options).then(() => {
          this.overlay.hidden = !0;
        }),
        animateTo(this.panel, C.keyframes, C.options).then(() => {
          this.panel.hidden = !0;
        })
      ]), this.drawer.hidden = !0, this.overlay.hidden = !1, this.panel.hidden = !1;
      const A = this.originalTrigger;
      typeof (A == null ? void 0 : A.focus) == "function" && setTimeout(() => A.focus()), this.emit("sl-after-hide");
    }
  }
  handleNoModalChange() {
    this.open && !this.contained && (this.modal.activate(), lockBodyScrolling(this)), this.open && this.contained && (this.modal.deactivate(), unlockBodyScrolling(this));
  }
  /** Shows the drawer. */
  async show() {
    if (!this.open)
      return this.open = !0, waitForEvent(this, "sl-after-show");
  }
  /** Hides the drawer */
  async hide() {
    if (this.open)
      return this.open = !1, waitForEvent(this, "sl-after-hide");
  }
  render() {
    return ke$1`
      <div
        part="base"
        class=${Rt({
      drawer: !0,
      "drawer--open": this.open,
      "drawer--top": this.placement === "top",
      "drawer--end": this.placement === "end",
      "drawer--bottom": this.placement === "bottom",
      "drawer--start": this.placement === "start",
      "drawer--contained": this.contained,
      "drawer--fixed": !this.contained,
      "drawer--rtl": this.localize.dir() === "rtl",
      "drawer--has-footer": this.hasSlotController.test("footer")
    })}
      >
        <div part="overlay" class="drawer__overlay" @click=${() => this.requestClose("overlay")} tabindex="-1"></div>

        <div
          part="panel"
          class="drawer__panel"
          role="dialog"
          aria-modal="true"
          aria-hidden=${this.open ? "false" : "true"}
          aria-label=${to(this.noHeader ? this.label : void 0)}
          aria-labelledby=${to(this.noHeader ? void 0 : "title")}
          tabindex="0"
        >
          ${this.noHeader ? "" : ke$1`
                <header part="header" class="drawer__header">
                  <h2 part="title" class="drawer__title" id="title">
                    <!-- If there's no label, use an invisible character to prevent the header from collapsing -->
                    <slot name="label"> ${this.label.length > 0 ? this.label : "\uFEFF"} </slot>
                  </h2>
                  <div part="header-actions" class="drawer__header-actions">
                    <slot name="header-actions"></slot>
                    <sl-icon-button
                      part="close-button"
                      exportparts="base:close-button__base"
                      class="drawer__close"
                      name="x-lg"
                      label=${this.localize.term("close")}
                      library="system"
                      @click=${() => this.requestClose("close-button")}
                    ></sl-icon-button>
                  </div>
                </header>
              `}

          <slot part="body" class="drawer__body"></slot>

          <footer part="footer" class="drawer__footer">
            <slot name="footer"></slot>
          </footer>
        </div>
      </div>
    `;
  }
};
SlDrawer.styles = [component_styles_default, drawer_styles_default];
SlDrawer.dependencies = { "sl-icon-button": SlIconButton };
__decorateClass$e([
  e$6(".drawer")
], SlDrawer.prototype, "drawer", 2);
__decorateClass$e([
  e$6(".drawer__panel")
], SlDrawer.prototype, "panel", 2);
__decorateClass$e([
  e$6(".drawer__overlay")
], SlDrawer.prototype, "overlay", 2);
__decorateClass$e([
  n$1({ type: Boolean, reflect: !0 })
], SlDrawer.prototype, "open", 2);
__decorateClass$e([
  n$1({ reflect: !0 })
], SlDrawer.prototype, "label", 2);
__decorateClass$e([
  n$1({ reflect: !0 })
], SlDrawer.prototype, "placement", 2);
__decorateClass$e([
  n$1({ type: Boolean, reflect: !0 })
], SlDrawer.prototype, "contained", 2);
__decorateClass$e([
  n$1({ attribute: "no-header", type: Boolean, reflect: !0 })
], SlDrawer.prototype, "noHeader", 2);
__decorateClass$e([
  watch("open", { waitUntilFirstUpdate: !0 })
], SlDrawer.prototype, "handleOpenChange", 1);
__decorateClass$e([
  watch("contained", { waitUntilFirstUpdate: !0 })
], SlDrawer.prototype, "handleNoModalChange", 1);
setDefaultAnimation("drawer.showTop", {
  keyframes: [
    { opacity: 0, translate: "0 -100%" },
    { opacity: 1, translate: "0 0" }
  ],
  options: { duration: 250, easing: "ease" }
});
setDefaultAnimation("drawer.hideTop", {
  keyframes: [
    { opacity: 1, translate: "0 0" },
    { opacity: 0, translate: "0 -100%" }
  ],
  options: { duration: 250, easing: "ease" }
});
setDefaultAnimation("drawer.showEnd", {
  keyframes: [
    { opacity: 0, translate: "100%" },
    { opacity: 1, translate: "0" }
  ],
  rtlKeyframes: [
    { opacity: 0, translate: "-100%" },
    { opacity: 1, translate: "0" }
  ],
  options: { duration: 250, easing: "ease" }
});
setDefaultAnimation("drawer.hideEnd", {
  keyframes: [
    { opacity: 1, translate: "0" },
    { opacity: 0, translate: "100%" }
  ],
  rtlKeyframes: [
    { opacity: 1, translate: "0" },
    { opacity: 0, translate: "-100%" }
  ],
  options: { duration: 250, easing: "ease" }
});
setDefaultAnimation("drawer.showBottom", {
  keyframes: [
    { opacity: 0, translate: "0 100%" },
    { opacity: 1, translate: "0 0" }
  ],
  options: { duration: 250, easing: "ease" }
});
setDefaultAnimation("drawer.hideBottom", {
  keyframes: [
    { opacity: 1, translate: "0 0" },
    { opacity: 0, translate: "0 100%" }
  ],
  options: { duration: 250, easing: "ease" }
});
setDefaultAnimation("drawer.showStart", {
  keyframes: [
    { opacity: 0, translate: "-100%" },
    { opacity: 1, translate: "0" }
  ],
  rtlKeyframes: [
    { opacity: 0, translate: "100%" },
    { opacity: 1, translate: "0" }
  ],
  options: { duration: 250, easing: "ease" }
});
setDefaultAnimation("drawer.hideStart", {
  keyframes: [
    { opacity: 1, translate: "0" },
    { opacity: 0, translate: "-100%" }
  ],
  rtlKeyframes: [
    { opacity: 1, translate: "0" },
    { opacity: 0, translate: "100%" }
  ],
  options: { duration: 250, easing: "ease" }
});
setDefaultAnimation("drawer.denyClose", {
  keyframes: [{ scale: 1 }, { scale: 1.01 }, { scale: 1 }],
  options: { duration: 250 }
});
setDefaultAnimation("drawer.overlay.show", {
  keyframes: [{ opacity: 0 }, { opacity: 1 }],
  options: { duration: 250 }
});
setDefaultAnimation("drawer.overlay.hide", {
  keyframes: [{ opacity: 1 }, { opacity: 0 }],
  options: { duration: 250 }
});
SlDrawer.define("sl-drawer");
var dropdown_styles_default = i$5`
  :host {
    display: inline-block;
  }

  .dropdown::part(popup) {
    z-index: var(--sl-z-index-dropdown);
  }

  .dropdown[data-current-placement^='top']::part(popup) {
    transform-origin: bottom;
  }

  .dropdown[data-current-placement^='bottom']::part(popup) {
    transform-origin: top;
  }

  .dropdown[data-current-placement^='left']::part(popup) {
    transform-origin: right;
  }

  .dropdown[data-current-placement^='right']::part(popup) {
    transform-origin: left;
  }

  .dropdown__trigger {
    display: block;
  }

  .dropdown__panel {
    font-family: var(--sl-font-sans);
    font-size: var(--sl-font-size-medium);
    font-weight: var(--sl-font-weight-normal);
    box-shadow: var(--sl-shadow-large);
    border-radius: var(--sl-border-radius-medium);
    pointer-events: none;
  }

  .dropdown--open .dropdown__panel {
    display: block;
    pointer-events: all;
  }

  /* When users slot a menu, make sure it conforms to the popup's auto-size */
  ::slotted(sl-menu) {
    max-width: var(--auto-size-available-width) !important;
    max-height: var(--auto-size-available-height) !important;
  }
`, SlDropdown = class extends ShoelaceElement {
  constructor() {
    super(...arguments), this.localize = new LocalizeController(this), this.open = !1, this.placement = "bottom-start", this.disabled = !1, this.stayOpenOnSelect = !1, this.distance = 0, this.skidding = 0, this.hoist = !1, this.sync = void 0, this.handleKeyDown = (C) => {
      this.open && C.key === "Escape" && (C.stopPropagation(), this.hide(), this.focusOnTrigger());
    }, this.handleDocumentKeyDown = (C) => {
      var L;
      if (C.key === "Escape" && this.open && !this.closeWatcher) {
        C.stopPropagation(), this.focusOnTrigger(), this.hide();
        return;
      }
      if (C.key === "Tab") {
        if (this.open && ((L = document.activeElement) == null ? void 0 : L.tagName.toLowerCase()) === "sl-menu-item") {
          C.preventDefault(), this.hide(), this.focusOnTrigger();
          return;
        }
        setTimeout(() => {
          var A, W, X;
          const J = ((A = this.containingElement) == null ? void 0 : A.getRootNode()) instanceof ShadowRoot ? (X = (W = document.activeElement) == null ? void 0 : W.shadowRoot) == null ? void 0 : X.activeElement : document.activeElement;
          (!this.containingElement || (J == null ? void 0 : J.closest(this.containingElement.tagName.toLowerCase())) !== this.containingElement) && this.hide();
        });
      }
    }, this.handleDocumentMouseDown = (C) => {
      const L = C.composedPath();
      this.containingElement && !L.includes(this.containingElement) && this.hide();
    }, this.handlePanelSelect = (C) => {
      const L = C.target;
      !this.stayOpenOnSelect && L.tagName.toLowerCase() === "sl-menu" && (this.hide(), this.focusOnTrigger());
    };
  }
  connectedCallback() {
    super.connectedCallback(), this.containingElement || (this.containingElement = this);
  }
  firstUpdated() {
    this.panel.hidden = !this.open, this.open && (this.addOpenListeners(), this.popup.active = !0);
  }
  disconnectedCallback() {
    super.disconnectedCallback(), this.removeOpenListeners(), this.hide();
  }
  focusOnTrigger() {
    const C = this.trigger.assignedElements({ flatten: !0 })[0];
    typeof (C == null ? void 0 : C.focus) == "function" && C.focus();
  }
  getMenu() {
    return this.panel.assignedElements({ flatten: !0 }).find((C) => C.tagName.toLowerCase() === "sl-menu");
  }
  handleTriggerClick() {
    this.open ? this.hide() : (this.show(), this.focusOnTrigger());
  }
  async handleTriggerKeyDown(C) {
    if ([" ", "Enter"].includes(C.key)) {
      C.preventDefault(), this.handleTriggerClick();
      return;
    }
    const L = this.getMenu();
    if (L) {
      const A = L.getAllItems(), W = A[0], X = A[A.length - 1];
      ["ArrowDown", "ArrowUp", "Home", "End"].includes(C.key) && (C.preventDefault(), this.open || (this.show(), await this.updateComplete), A.length > 0 && this.updateComplete.then(() => {
        (C.key === "ArrowDown" || C.key === "Home") && (L.setCurrentItem(W), W.focus()), (C.key === "ArrowUp" || C.key === "End") && (L.setCurrentItem(X), X.focus());
      }));
    }
  }
  handleTriggerKeyUp(C) {
    C.key === " " && C.preventDefault();
  }
  handleTriggerSlotChange() {
    this.updateAccessibleTrigger();
  }
  //
  // Slotted triggers can be arbitrary content, but we need to link them to the dropdown panel with `aria-haspopup` and
  // `aria-expanded`. These must be applied to the "accessible trigger" (the tabbable portion of the trigger element
  // that gets slotted in) so screen readers will understand them. The accessible trigger could be the slotted element,
  // a child of the slotted element, or an element in the slotted element's shadow root.
  //
  // For example, the accessible trigger of an <sl-button> is a <button> located inside its shadow root.
  //
  // To determine this, we assume the first tabbable element in the trigger slot is the "accessible trigger."
  //
  updateAccessibleTrigger() {
    const L = this.trigger.assignedElements({ flatten: !0 }).find((W) => getTabbableBoundary(W).start);
    let A;
    if (L) {
      switch (L.tagName.toLowerCase()) {
        case "sl-button":
        case "sl-icon-button":
          A = L.button;
          break;
        default:
          A = L;
      }
      A.setAttribute("aria-haspopup", "true"), A.setAttribute("aria-expanded", this.open ? "true" : "false");
    }
  }
  /** Shows the dropdown panel. */
  async show() {
    if (!this.open)
      return this.open = !0, waitForEvent(this, "sl-after-show");
  }
  /** Hides the dropdown panel */
  async hide() {
    if (this.open)
      return this.open = !1, waitForEvent(this, "sl-after-hide");
  }
  /**
   * Instructs the dropdown menu to reposition. Useful when the position or size of the trigger changes when the menu
   * is activated.
   */
  reposition() {
    this.popup.reposition();
  }
  addOpenListeners() {
    var C;
    this.panel.addEventListener("sl-select", this.handlePanelSelect), "CloseWatcher" in window ? ((C = this.closeWatcher) == null || C.destroy(), this.closeWatcher = new CloseWatcher(), this.closeWatcher.onclose = () => {
      this.hide(), this.focusOnTrigger();
    }) : this.panel.addEventListener("keydown", this.handleKeyDown), document.addEventListener("keydown", this.handleDocumentKeyDown), document.addEventListener("mousedown", this.handleDocumentMouseDown);
  }
  removeOpenListeners() {
    var C;
    this.panel && (this.panel.removeEventListener("sl-select", this.handlePanelSelect), this.panel.removeEventListener("keydown", this.handleKeyDown)), document.removeEventListener("keydown", this.handleDocumentKeyDown), document.removeEventListener("mousedown", this.handleDocumentMouseDown), (C = this.closeWatcher) == null || C.destroy();
  }
  async handleOpenChange() {
    if (this.disabled) {
      this.open = !1;
      return;
    }
    if (this.updateAccessibleTrigger(), this.open) {
      this.emit("sl-show"), this.addOpenListeners(), await stopAnimations(this), this.panel.hidden = !1, this.popup.active = !0;
      const { keyframes: C, options: L } = getAnimation(this, "dropdown.show", { dir: this.localize.dir() });
      await animateTo(this.popup.popup, C, L), this.emit("sl-after-show");
    } else {
      this.emit("sl-hide"), this.removeOpenListeners(), await stopAnimations(this);
      const { keyframes: C, options: L } = getAnimation(this, "dropdown.hide", { dir: this.localize.dir() });
      await animateTo(this.popup.popup, C, L), this.panel.hidden = !0, this.popup.active = !1, this.emit("sl-after-hide");
    }
  }
  render() {
    return ke$1`
      <sl-popup
        part="base"
        exportparts="popup:base__popup"
        id="dropdown"
        placement=${this.placement}
        distance=${this.distance}
        skidding=${this.skidding}
        strategy=${this.hoist ? "fixed" : "absolute"}
        flip
        shift
        auto-size="vertical"
        auto-size-padding="10"
        sync=${to(this.sync ? this.sync : void 0)}
        class=${Rt({
      dropdown: !0,
      "dropdown--open": this.open
    })}
      >
        <slot
          name="trigger"
          slot="anchor"
          part="trigger"
          class="dropdown__trigger"
          @click=${this.handleTriggerClick}
          @keydown=${this.handleTriggerKeyDown}
          @keyup=${this.handleTriggerKeyUp}
          @slotchange=${this.handleTriggerSlotChange}
        ></slot>

        <div aria-hidden=${this.open ? "false" : "true"} aria-labelledby="dropdown">
          <slot part="panel" class="dropdown__panel"></slot>
        </div>
      </sl-popup>
    `;
  }
};
SlDropdown.styles = [component_styles_default, dropdown_styles_default];
SlDropdown.dependencies = { "sl-popup": SlPopup };
__decorateClass$e([
  e$6(".dropdown")
], SlDropdown.prototype, "popup", 2);
__decorateClass$e([
  e$6(".dropdown__trigger")
], SlDropdown.prototype, "trigger", 2);
__decorateClass$e([
  e$6(".dropdown__panel")
], SlDropdown.prototype, "panel", 2);
__decorateClass$e([
  n$1({ type: Boolean, reflect: !0 })
], SlDropdown.prototype, "open", 2);
__decorateClass$e([
  n$1({ reflect: !0 })
], SlDropdown.prototype, "placement", 2);
__decorateClass$e([
  n$1({ type: Boolean, reflect: !0 })
], SlDropdown.prototype, "disabled", 2);
__decorateClass$e([
  n$1({ attribute: "stay-open-on-select", type: Boolean, reflect: !0 })
], SlDropdown.prototype, "stayOpenOnSelect", 2);
__decorateClass$e([
  n$1({ attribute: !1 })
], SlDropdown.prototype, "containingElement", 2);
__decorateClass$e([
  n$1({ type: Number })
], SlDropdown.prototype, "distance", 2);
__decorateClass$e([
  n$1({ type: Number })
], SlDropdown.prototype, "skidding", 2);
__decorateClass$e([
  n$1({ type: Boolean })
], SlDropdown.prototype, "hoist", 2);
__decorateClass$e([
  n$1({ reflect: !0 })
], SlDropdown.prototype, "sync", 2);
__decorateClass$e([
  watch("open", { waitUntilFirstUpdate: !0 })
], SlDropdown.prototype, "handleOpenChange", 1);
setDefaultAnimation("dropdown.show", {
  keyframes: [
    { opacity: 0, scale: 0.9 },
    { opacity: 1, scale: 1 }
  ],
  options: { duration: 100, easing: "ease" }
});
setDefaultAnimation("dropdown.hide", {
  keyframes: [
    { opacity: 1, scale: 1 },
    { opacity: 0, scale: 0.9 }
  ],
  options: { duration: 100, easing: "ease" }
});
SlDropdown.define("sl-dropdown");
var copy_button_styles_default = i$5`
  :host {
    --error-color: var(--sl-color-danger-600);
    --success-color: var(--sl-color-success-600);

    display: inline-block;
  }

  .copy-button__button {
    flex: 0 0 auto;
    display: flex;
    align-items: center;
    background: none;
    border: none;
    border-radius: var(--sl-border-radius-medium);
    font-size: inherit;
    color: inherit;
    padding: var(--sl-spacing-x-small);
    cursor: pointer;
    transition: var(--sl-transition-x-fast) color;
  }

  .copy-button--success .copy-button__button {
    color: var(--success-color);
  }

  .copy-button--error .copy-button__button {
    color: var(--error-color);
  }

  .copy-button__button:focus-visible {
    outline: var(--sl-focus-ring);
    outline-offset: var(--sl-focus-ring-offset);
  }

  .copy-button__button[disabled] {
    opacity: 0.5;
    cursor: not-allowed !important;
  }

  slot {
    display: inline-flex;
  }
`, SlCopyButton = class extends ShoelaceElement {
  constructor() {
    super(...arguments), this.localize = new LocalizeController(this), this.isCopying = !1, this.status = "rest", this.value = "", this.from = "", this.disabled = !1, this.copyLabel = "", this.successLabel = "", this.errorLabel = "", this.feedbackDuration = 1e3, this.tooltipPlacement = "top", this.hoist = !1;
  }
  async handleCopy() {
    if (this.disabled || this.isCopying)
      return;
    this.isCopying = !0;
    let C = this.value;
    if (this.from) {
      const L = this.getRootNode(), A = this.from.includes("."), W = this.from.includes("[") && this.from.includes("]");
      let X = this.from, J = "";
      A ? [X, J] = this.from.trim().split(".") : W && ([X, J] = this.from.trim().replace(/\]$/, "").split("["));
      const te = "getElementById" in L ? L.getElementById(X) : null;
      te ? W ? C = te.getAttribute(J) || "" : A ? C = te[J] || "" : C = te.textContent || "" : (this.showStatus("error"), this.emit("sl-error"));
    }
    if (!C)
      this.showStatus("error"), this.emit("sl-error");
    else
      try {
        await navigator.clipboard.writeText(C), this.showStatus("success"), this.emit("sl-copy", {
          detail: {
            value: C
          }
        });
      } catch {
        this.showStatus("error"), this.emit("sl-error");
      }
  }
  async showStatus(C) {
    const L = this.copyLabel || this.localize.term("copy"), A = this.successLabel || this.localize.term("copied"), W = this.errorLabel || this.localize.term("error"), X = C === "success" ? this.successIcon : this.errorIcon, J = getAnimation(this, "copy.in", { dir: "ltr" }), te = getAnimation(this, "copy.out", { dir: "ltr" });
    this.tooltip.content = C === "success" ? A : W, await this.copyIcon.animate(te.keyframes, te.options).finished, this.copyIcon.hidden = !0, this.status = C, X.hidden = !1, await X.animate(J.keyframes, J.options).finished, setTimeout(async () => {
      await X.animate(te.keyframes, te.options).finished, X.hidden = !0, this.status = "rest", this.copyIcon.hidden = !1, await this.copyIcon.animate(J.keyframes, J.options).finished, this.tooltip.content = L, this.isCopying = !1;
    }, this.feedbackDuration);
  }
  render() {
    const C = this.copyLabel || this.localize.term("copy");
    return ke$1`
      <sl-tooltip
        class=${Rt({
      "copy-button": !0,
      "copy-button--success": this.status === "success",
      "copy-button--error": this.status === "error"
    })}
        content=${C}
        placement=${this.tooltipPlacement}
        ?disabled=${this.disabled}
        ?hoist=${this.hoist}
        exportparts="
          base:tooltip__base,
          base__popup:tooltip__base__popup,
          base__arrow:tooltip__base__arrow,
          body:tooltip__body
        "
      >
        <button
          class="copy-button__button"
          part="button"
          type="button"
          ?disabled=${this.disabled}
          @click=${this.handleCopy}
        >
          <slot part="copy-icon" name="copy-icon">
            <sl-icon library="system" name="copy"></sl-icon>
          </slot>
          <slot part="success-icon" name="success-icon" hidden>
            <sl-icon library="system" name="check"></sl-icon>
          </slot>
          <slot part="error-icon" name="error-icon" hidden>
            <sl-icon library="system" name="x-lg"></sl-icon>
          </slot>
        </button>
      </sl-tooltip>
    `;
  }
};
SlCopyButton.styles = [component_styles_default, copy_button_styles_default];
SlCopyButton.dependencies = {
  "sl-icon": SlIcon,
  "sl-tooltip": SlTooltip
};
__decorateClass$e([
  e$6('slot[name="copy-icon"]')
], SlCopyButton.prototype, "copyIcon", 2);
__decorateClass$e([
  e$6('slot[name="success-icon"]')
], SlCopyButton.prototype, "successIcon", 2);
__decorateClass$e([
  e$6('slot[name="error-icon"]')
], SlCopyButton.prototype, "errorIcon", 2);
__decorateClass$e([
  e$6("sl-tooltip")
], SlCopyButton.prototype, "tooltip", 2);
__decorateClass$e([
  r$3()
], SlCopyButton.prototype, "isCopying", 2);
__decorateClass$e([
  r$3()
], SlCopyButton.prototype, "status", 2);
__decorateClass$e([
  n$1()
], SlCopyButton.prototype, "value", 2);
__decorateClass$e([
  n$1()
], SlCopyButton.prototype, "from", 2);
__decorateClass$e([
  n$1({ type: Boolean, reflect: !0 })
], SlCopyButton.prototype, "disabled", 2);
__decorateClass$e([
  n$1({ attribute: "copy-label" })
], SlCopyButton.prototype, "copyLabel", 2);
__decorateClass$e([
  n$1({ attribute: "success-label" })
], SlCopyButton.prototype, "successLabel", 2);
__decorateClass$e([
  n$1({ attribute: "error-label" })
], SlCopyButton.prototype, "errorLabel", 2);
__decorateClass$e([
  n$1({ attribute: "feedback-duration", type: Number })
], SlCopyButton.prototype, "feedbackDuration", 2);
__decorateClass$e([
  n$1({ attribute: "tooltip-placement" })
], SlCopyButton.prototype, "tooltipPlacement", 2);
__decorateClass$e([
  n$1({ type: Boolean })
], SlCopyButton.prototype, "hoist", 2);
setDefaultAnimation("copy.in", {
  keyframes: [
    { scale: ".25", opacity: ".25" },
    { scale: "1", opacity: "1" }
  ],
  options: { duration: 100 }
});
setDefaultAnimation("copy.out", {
  keyframes: [
    { scale: "1", opacity: "1" },
    { scale: ".25", opacity: "0" }
  ],
  options: { duration: 100 }
});
SlCopyButton.define("sl-copy-button");
var details_styles_default = i$5`
  :host {
    display: block;
  }

  .details {
    border: solid 1px var(--sl-color-neutral-200);
    border-radius: var(--sl-border-radius-medium);
    background-color: var(--sl-color-neutral-0);
    overflow-anchor: none;
  }

  .details--disabled {
    opacity: 0.5;
  }

  .details__header {
    display: flex;
    align-items: center;
    border-radius: inherit;
    padding: var(--sl-spacing-medium);
    user-select: none;
    -webkit-user-select: none;
    cursor: pointer;
  }

  .details__header::-webkit-details-marker {
    display: none;
  }

  .details__header:focus {
    outline: none;
  }

  .details__header:focus-visible {
    outline: var(--sl-focus-ring);
    outline-offset: calc(1px + var(--sl-focus-ring-offset));
  }

  .details--disabled .details__header {
    cursor: not-allowed;
  }

  .details--disabled .details__header:focus-visible {
    outline: none;
    box-shadow: none;
  }

  .details__summary {
    flex: 1 1 auto;
    display: flex;
    align-items: center;
  }

  .details__summary-icon {
    flex: 0 0 auto;
    display: flex;
    align-items: center;
    transition: var(--sl-transition-medium) rotate ease;
  }

  .details--open .details__summary-icon {
    rotate: 90deg;
  }

  .details--open.details--rtl .details__summary-icon {
    rotate: -90deg;
  }

  .details--open slot[name='expand-icon'],
  .details:not(.details--open) slot[name='collapse-icon'] {
    display: none;
  }

  .details__body {
    overflow: hidden;
  }

  .details__content {
    display: block;
    padding: var(--sl-spacing-medium);
  }
`, SlDetails = class extends ShoelaceElement {
  constructor() {
    super(...arguments), this.localize = new LocalizeController(this), this.open = !1, this.disabled = !1;
  }
  firstUpdated() {
    this.body.style.height = this.open ? "auto" : "0", this.open && (this.details.open = !0), this.detailsObserver = new MutationObserver((C) => {
      for (const L of C)
        L.type === "attributes" && L.attributeName === "open" && (this.details.open ? this.show() : this.hide());
    }), this.detailsObserver.observe(this.details, { attributes: !0 });
  }
  disconnectedCallback() {
    super.disconnectedCallback(), this.detailsObserver.disconnect();
  }
  handleSummaryClick(C) {
    C.preventDefault(), this.disabled || (this.open ? this.hide() : this.show(), this.header.focus());
  }
  handleSummaryKeyDown(C) {
    (C.key === "Enter" || C.key === " ") && (C.preventDefault(), this.open ? this.hide() : this.show()), (C.key === "ArrowUp" || C.key === "ArrowLeft") && (C.preventDefault(), this.hide()), (C.key === "ArrowDown" || C.key === "ArrowRight") && (C.preventDefault(), this.show());
  }
  async handleOpenChange() {
    if (this.open) {
      if (this.details.open = !0, this.emit("sl-show", { cancelable: !0 }).defaultPrevented) {
        this.open = !1, this.details.open = !1;
        return;
      }
      await stopAnimations(this.body);
      const { keyframes: L, options: A } = getAnimation(this, "details.show", { dir: this.localize.dir() });
      await animateTo(this.body, shimKeyframesHeightAuto(L, this.body.scrollHeight), A), this.body.style.height = "auto", this.emit("sl-after-show");
    } else {
      if (this.emit("sl-hide", { cancelable: !0 }).defaultPrevented) {
        this.details.open = !0, this.open = !0;
        return;
      }
      await stopAnimations(this.body);
      const { keyframes: L, options: A } = getAnimation(this, "details.hide", { dir: this.localize.dir() });
      await animateTo(this.body, shimKeyframesHeightAuto(L, this.body.scrollHeight), A), this.body.style.height = "auto", this.details.open = !1, this.emit("sl-after-hide");
    }
  }
  /** Shows the details. */
  async show() {
    if (!(this.open || this.disabled))
      return this.open = !0, waitForEvent(this, "sl-after-show");
  }
  /** Hides the details */
  async hide() {
    if (!(!this.open || this.disabled))
      return this.open = !1, waitForEvent(this, "sl-after-hide");
  }
  render() {
    const C = this.matches(":dir(rtl)");
    return ke$1`
      <details
        part="base"
        class=${Rt({
      details: !0,
      "details--open": this.open,
      "details--disabled": this.disabled,
      "details--rtl": C
    })}
      >
        <summary
          part="header"
          id="header"
          class="details__header"
          role="button"
          aria-expanded=${this.open ? "true" : "false"}
          aria-controls="content"
          aria-disabled=${this.disabled ? "true" : "false"}
          tabindex=${this.disabled ? "-1" : "0"}
          @click=${this.handleSummaryClick}
          @keydown=${this.handleSummaryKeyDown}
        >
          <slot name="summary" part="summary" class="details__summary">${this.summary}</slot>

          <span part="summary-icon" class="details__summary-icon">
            <slot name="expand-icon">
              <sl-icon library="system" name=${C ? "chevron-left" : "chevron-right"}></sl-icon>
            </slot>
            <slot name="collapse-icon">
              <sl-icon library="system" name=${C ? "chevron-left" : "chevron-right"}></sl-icon>
            </slot>
          </span>
        </summary>

        <div class="details__body" role="region" aria-labelledby="header">
          <slot part="content" id="content" class="details__content"></slot>
        </div>
      </details>
    `;
  }
};
SlDetails.styles = [component_styles_default, details_styles_default];
SlDetails.dependencies = {
  "sl-icon": SlIcon
};
__decorateClass$e([
  e$6(".details")
], SlDetails.prototype, "details", 2);
__decorateClass$e([
  e$6(".details__header")
], SlDetails.prototype, "header", 2);
__decorateClass$e([
  e$6(".details__body")
], SlDetails.prototype, "body", 2);
__decorateClass$e([
  e$6(".details__expand-icon-slot")
], SlDetails.prototype, "expandIconSlot", 2);
__decorateClass$e([
  n$1({ type: Boolean, reflect: !0 })
], SlDetails.prototype, "open", 2);
__decorateClass$e([
  n$1()
], SlDetails.prototype, "summary", 2);
__decorateClass$e([
  n$1({ type: Boolean, reflect: !0 })
], SlDetails.prototype, "disabled", 2);
__decorateClass$e([
  watch("open", { waitUntilFirstUpdate: !0 })
], SlDetails.prototype, "handleOpenChange", 1);
setDefaultAnimation("details.show", {
  keyframes: [
    { height: "0", opacity: "0" },
    { height: "auto", opacity: "1" }
  ],
  options: { duration: 250, easing: "linear" }
});
setDefaultAnimation("details.hide", {
  keyframes: [
    { height: "auto", opacity: "1" },
    { height: "0", opacity: "0" }
  ],
  options: { duration: 250, easing: "linear" }
});
SlDetails.define("sl-details");
var dialog_styles_default = i$5`
  :host {
    --width: 31rem;
    --header-spacing: var(--sl-spacing-large);
    --body-spacing: var(--sl-spacing-large);
    --footer-spacing: var(--sl-spacing-large);

    display: contents;
  }

  .dialog {
    display: flex;
    align-items: center;
    justify-content: center;
    position: fixed;
    top: 0;
    right: 0;
    bottom: 0;
    left: 0;
    z-index: var(--sl-z-index-dialog);
  }

  .dialog__panel {
    display: flex;
    flex-direction: column;
    z-index: 2;
    width: var(--width);
    max-width: calc(100% - var(--sl-spacing-2x-large));
    max-height: calc(100% - var(--sl-spacing-2x-large));
    background-color: var(--sl-panel-background-color);
    border-radius: var(--sl-border-radius-medium);
    box-shadow: var(--sl-shadow-x-large);
  }

  .dialog__panel:focus {
    outline: none;
  }

  /* Ensure there's enough vertical padding for phones that don't update vh when chrome appears (e.g. iPhone) */
  @media screen and (max-width: 420px) {
    .dialog__panel {
      max-height: 80vh;
    }
  }

  .dialog--open .dialog__panel {
    display: flex;
    opacity: 1;
  }

  .dialog__header {
    flex: 0 0 auto;
    display: flex;
  }

  .dialog__title {
    flex: 1 1 auto;
    font: inherit;
    font-size: var(--sl-font-size-large);
    line-height: var(--sl-line-height-dense);
    padding: var(--header-spacing);
    margin: 0;
  }

  .dialog__header-actions {
    flex-shrink: 0;
    display: flex;
    flex-wrap: wrap;
    justify-content: end;
    gap: var(--sl-spacing-2x-small);
    padding: 0 var(--header-spacing);
  }

  .dialog__header-actions sl-icon-button,
  .dialog__header-actions ::slotted(sl-icon-button) {
    flex: 0 0 auto;
    display: flex;
    align-items: center;
    font-size: var(--sl-font-size-medium);
  }

  .dialog__body {
    flex: 1 1 auto;
    display: block;
    padding: var(--body-spacing);
    overflow: auto;
    -webkit-overflow-scrolling: touch;
  }

  .dialog__footer {
    flex: 0 0 auto;
    text-align: right;
    padding: var(--footer-spacing);
  }

  .dialog__footer ::slotted(sl-button:not(:first-of-type)) {
    margin-inline-start: var(--sl-spacing-x-small);
  }

  .dialog:not(.dialog--has-footer) .dialog__footer {
    display: none;
  }

  .dialog__overlay {
    position: fixed;
    top: 0;
    right: 0;
    bottom: 0;
    left: 0;
    background-color: var(--sl-overlay-background-color);
  }

  @media (forced-colors: active) {
    .dialog__panel {
      border: solid 1px var(--sl-color-neutral-0);
    }
  }
`, SlDialog = class extends ShoelaceElement {
  constructor() {
    super(...arguments), this.hasSlotController = new HasSlotController(this, "footer"), this.localize = new LocalizeController(this), this.modal = new Modal(this), this.open = !1, this.label = "", this.noHeader = !1, this.handleDocumentKeyDown = (C) => {
      C.key === "Escape" && this.modal.isActive() && this.open && (C.stopPropagation(), this.requestClose("keyboard"));
    };
  }
  firstUpdated() {
    this.dialog.hidden = !this.open, this.open && (this.addOpenListeners(), this.modal.activate(), lockBodyScrolling(this));
  }
  disconnectedCallback() {
    var C;
    super.disconnectedCallback(), this.modal.deactivate(), unlockBodyScrolling(this), (C = this.closeWatcher) == null || C.destroy();
  }
  requestClose(C) {
    if (this.emit("sl-request-close", {
      cancelable: !0,
      detail: { source: C }
    }).defaultPrevented) {
      const A = getAnimation(this, "dialog.denyClose", { dir: this.localize.dir() });
      animateTo(this.panel, A.keyframes, A.options);
      return;
    }
    this.hide();
  }
  addOpenListeners() {
    var C;
    "CloseWatcher" in window ? ((C = this.closeWatcher) == null || C.destroy(), this.closeWatcher = new CloseWatcher(), this.closeWatcher.onclose = () => this.requestClose("keyboard")) : document.addEventListener("keydown", this.handleDocumentKeyDown);
  }
  removeOpenListeners() {
    var C;
    (C = this.closeWatcher) == null || C.destroy(), document.removeEventListener("keydown", this.handleDocumentKeyDown);
  }
  async handleOpenChange() {
    if (this.open) {
      this.emit("sl-show"), this.addOpenListeners(), this.originalTrigger = document.activeElement, this.modal.activate(), lockBodyScrolling(this);
      const C = this.querySelector("[autofocus]");
      C && C.removeAttribute("autofocus"), await Promise.all([stopAnimations(this.dialog), stopAnimations(this.overlay)]), this.dialog.hidden = !1, requestAnimationFrame(() => {
        this.emit("sl-initial-focus", { cancelable: !0 }).defaultPrevented || (C ? C.focus({ preventScroll: !0 }) : this.panel.focus({ preventScroll: !0 })), C && C.setAttribute("autofocus", "");
      });
      const L = getAnimation(this, "dialog.show", { dir: this.localize.dir() }), A = getAnimation(this, "dialog.overlay.show", { dir: this.localize.dir() });
      await Promise.all([
        animateTo(this.panel, L.keyframes, L.options),
        animateTo(this.overlay, A.keyframes, A.options)
      ]), this.emit("sl-after-show");
    } else {
      this.emit("sl-hide"), this.removeOpenListeners(), this.modal.deactivate(), await Promise.all([stopAnimations(this.dialog), stopAnimations(this.overlay)]);
      const C = getAnimation(this, "dialog.hide", { dir: this.localize.dir() }), L = getAnimation(this, "dialog.overlay.hide", { dir: this.localize.dir() });
      await Promise.all([
        animateTo(this.overlay, L.keyframes, L.options).then(() => {
          this.overlay.hidden = !0;
        }),
        animateTo(this.panel, C.keyframes, C.options).then(() => {
          this.panel.hidden = !0;
        })
      ]), this.dialog.hidden = !0, this.overlay.hidden = !1, this.panel.hidden = !1, unlockBodyScrolling(this);
      const A = this.originalTrigger;
      typeof (A == null ? void 0 : A.focus) == "function" && setTimeout(() => A.focus()), this.emit("sl-after-hide");
    }
  }
  /** Shows the dialog. */
  async show() {
    if (!this.open)
      return this.open = !0, waitForEvent(this, "sl-after-show");
  }
  /** Hides the dialog */
  async hide() {
    if (this.open)
      return this.open = !1, waitForEvent(this, "sl-after-hide");
  }
  render() {
    return ke$1`
      <div
        part="base"
        class=${Rt({
      dialog: !0,
      "dialog--open": this.open,
      "dialog--has-footer": this.hasSlotController.test("footer")
    })}
      >
        <div part="overlay" class="dialog__overlay" @click=${() => this.requestClose("overlay")} tabindex="-1"></div>

        <div
          part="panel"
          class="dialog__panel"
          role="dialog"
          aria-modal="true"
          aria-hidden=${this.open ? "false" : "true"}
          aria-label=${to(this.noHeader ? this.label : void 0)}
          aria-labelledby=${to(this.noHeader ? void 0 : "title")}
          tabindex="-1"
        >
          ${this.noHeader ? "" : ke$1`
                <header part="header" class="dialog__header">
                  <h2 part="title" class="dialog__title" id="title">
                    <slot name="label"> ${this.label.length > 0 ? this.label : "\uFEFF"} </slot>
                  </h2>
                  <div part="header-actions" class="dialog__header-actions">
                    <slot name="header-actions"></slot>
                    <sl-icon-button
                      part="close-button"
                      exportparts="base:close-button__base"
                      class="dialog__close"
                      name="x-lg"
                      label=${this.localize.term("close")}
                      library="system"
                      @click="${() => this.requestClose("close-button")}"
                    ></sl-icon-button>
                  </div>
                </header>
              `}
          ${""}
          <div part="body" class="dialog__body" tabindex="-1"><slot></slot></div>

          <footer part="footer" class="dialog__footer">
            <slot name="footer"></slot>
          </footer>
        </div>
      </div>
    `;
  }
};
SlDialog.styles = [component_styles_default, dialog_styles_default];
SlDialog.dependencies = {
  "sl-icon-button": SlIconButton
};
__decorateClass$e([
  e$6(".dialog")
], SlDialog.prototype, "dialog", 2);
__decorateClass$e([
  e$6(".dialog__panel")
], SlDialog.prototype, "panel", 2);
__decorateClass$e([
  e$6(".dialog__overlay")
], SlDialog.prototype, "overlay", 2);
__decorateClass$e([
  n$1({ type: Boolean, reflect: !0 })
], SlDialog.prototype, "open", 2);
__decorateClass$e([
  n$1({ reflect: !0 })
], SlDialog.prototype, "label", 2);
__decorateClass$e([
  n$1({ attribute: "no-header", type: Boolean, reflect: !0 })
], SlDialog.prototype, "noHeader", 2);
__decorateClass$e([
  watch("open", { waitUntilFirstUpdate: !0 })
], SlDialog.prototype, "handleOpenChange", 1);
setDefaultAnimation("dialog.show", {
  keyframes: [
    { opacity: 0, scale: 0.8 },
    { opacity: 1, scale: 1 }
  ],
  options: { duration: 250, easing: "ease" }
});
setDefaultAnimation("dialog.hide", {
  keyframes: [
    { opacity: 1, scale: 1 },
    { opacity: 0, scale: 0.8 }
  ],
  options: { duration: 250, easing: "ease" }
});
setDefaultAnimation("dialog.denyClose", {
  keyframes: [{ scale: 1 }, { scale: 1.02 }, { scale: 1 }],
  options: { duration: 250 }
});
setDefaultAnimation("dialog.overlay.show", {
  keyframes: [{ opacity: 0 }, { opacity: 1 }],
  options: { duration: 250 }
});
setDefaultAnimation("dialog.overlay.hide", {
  keyframes: [{ opacity: 1 }, { opacity: 0 }],
  options: { duration: 250 }
});
SlDialog.define("sl-dialog");
SlCheckbox.define("sl-checkbox");
var color_picker_styles_default = i$5`
  :host {
    --grid-width: 280px;
    --grid-height: 200px;
    --grid-handle-size: 16px;
    --slider-height: 15px;
    --slider-handle-size: 17px;
    --swatch-size: 25px;

    display: inline-block;
  }

  .color-picker {
    width: var(--grid-width);
    font-family: var(--sl-font-sans);
    font-size: var(--sl-font-size-medium);
    font-weight: var(--sl-font-weight-normal);
    color: var(--color);
    background-color: var(--sl-panel-background-color);
    border-radius: var(--sl-border-radius-medium);
    user-select: none;
    -webkit-user-select: none;
  }

  .color-picker--inline {
    border: solid var(--sl-panel-border-width) var(--sl-panel-border-color);
  }

  .color-picker--inline:focus-visible {
    outline: var(--sl-focus-ring);
    outline-offset: var(--sl-focus-ring-offset);
  }

  .color-picker__grid {
    position: relative;
    height: var(--grid-height);
    background-image: linear-gradient(to bottom, rgba(0, 0, 0, 0) 0%, rgba(0, 0, 0, 1) 100%),
      linear-gradient(to right, #fff 0%, rgba(255, 255, 255, 0) 100%);
    border-top-left-radius: var(--sl-border-radius-medium);
    border-top-right-radius: var(--sl-border-radius-medium);
    cursor: crosshair;
    forced-color-adjust: none;
  }

  .color-picker__grid-handle {
    position: absolute;
    width: var(--grid-handle-size);
    height: var(--grid-handle-size);
    border-radius: 50%;
    box-shadow: 0 0 0 1px rgba(0, 0, 0, 0.25);
    border: solid 2px white;
    margin-top: calc(var(--grid-handle-size) / -2);
    margin-left: calc(var(--grid-handle-size) / -2);
    transition: var(--sl-transition-fast) scale;
  }

  .color-picker__grid-handle--dragging {
    cursor: none;
    scale: 1.5;
  }

  .color-picker__grid-handle:focus-visible {
    outline: var(--sl-focus-ring);
  }

  .color-picker__controls {
    padding: var(--sl-spacing-small);
    display: flex;
    align-items: center;
  }

  .color-picker__sliders {
    flex: 1 1 auto;
  }

  .color-picker__slider {
    position: relative;
    height: var(--slider-height);
    border-radius: var(--sl-border-radius-pill);
    box-shadow: inset 0 0 0 1px rgba(0, 0, 0, 0.2);
    forced-color-adjust: none;
  }

  .color-picker__slider:not(:last-of-type) {
    margin-bottom: var(--sl-spacing-small);
  }

  .color-picker__slider-handle {
    position: absolute;
    top: calc(50% - var(--slider-handle-size) / 2);
    width: var(--slider-handle-size);
    height: var(--slider-handle-size);
    background-color: white;
    border-radius: 50%;
    box-shadow: 0 0 0 1px rgba(0, 0, 0, 0.25);
    margin-left: calc(var(--slider-handle-size) / -2);
  }

  .color-picker__slider-handle:focus-visible {
    outline: var(--sl-focus-ring);
  }

  .color-picker__hue {
    background-image: linear-gradient(
      to right,
      rgb(255, 0, 0) 0%,
      rgb(255, 255, 0) 17%,
      rgb(0, 255, 0) 33%,
      rgb(0, 255, 255) 50%,
      rgb(0, 0, 255) 67%,
      rgb(255, 0, 255) 83%,
      rgb(255, 0, 0) 100%
    );
  }

  .color-picker__alpha .color-picker__alpha-gradient {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    border-radius: inherit;
  }

  .color-picker__preview {
    flex: 0 0 auto;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    position: relative;
    width: 2.25rem;
    height: 2.25rem;
    border: none;
    border-radius: var(--sl-border-radius-circle);
    background: none;
    margin-left: var(--sl-spacing-small);
    cursor: copy;
    forced-color-adjust: none;
  }

  .color-picker__preview:before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    border-radius: inherit;
    box-shadow: inset 0 0 0 1px rgba(0, 0, 0, 0.2);

    /* We use a custom property in lieu of currentColor because of https://bugs.webkit.org/show_bug.cgi?id=216780 */
    background-color: var(--preview-color);
  }

  .color-picker__preview:focus-visible {
    outline: var(--sl-focus-ring);
    outline-offset: var(--sl-focus-ring-offset);
  }

  .color-picker__preview-color {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    border: solid 1px rgba(0, 0, 0, 0.125);
  }

  .color-picker__preview-color--copied {
    animation: pulse 0.75s;
  }

  @keyframes pulse {
    0% {
      box-shadow: 0 0 0 0 var(--sl-color-primary-500);
    }
    70% {
      box-shadow: 0 0 0 0.5rem transparent;
    }
    100% {
      box-shadow: 0 0 0 0 transparent;
    }
  }

  .color-picker__user-input {
    display: flex;
    padding: 0 var(--sl-spacing-small) var(--sl-spacing-small) var(--sl-spacing-small);
  }

  .color-picker__user-input sl-input {
    min-width: 0; /* fix input width in Safari */
    flex: 1 1 auto;
  }

  .color-picker__user-input sl-button-group {
    margin-left: var(--sl-spacing-small);
  }

  .color-picker__user-input sl-button {
    min-width: 3.25rem;
    max-width: 3.25rem;
    font-size: 1rem;
  }

  .color-picker__swatches {
    display: grid;
    grid-template-columns: repeat(8, 1fr);
    grid-gap: 0.5rem;
    justify-items: center;
    border-top: solid 1px var(--sl-color-neutral-200);
    padding: var(--sl-spacing-small);
    forced-color-adjust: none;
  }

  .color-picker__swatch {
    position: relative;
    width: var(--swatch-size);
    height: var(--swatch-size);
    border-radius: var(--sl-border-radius-small);
  }

  .color-picker__swatch .color-picker__swatch-color {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    border: solid 1px rgba(0, 0, 0, 0.125);
    border-radius: inherit;
    cursor: pointer;
  }

  .color-picker__swatch:focus-visible {
    outline: var(--sl-focus-ring);
    outline-offset: var(--sl-focus-ring-offset);
  }

  .color-picker__transparent-bg {
    background-image: linear-gradient(45deg, var(--sl-color-neutral-300) 25%, transparent 25%),
      linear-gradient(45deg, transparent 75%, var(--sl-color-neutral-300) 75%),
      linear-gradient(45deg, transparent 75%, var(--sl-color-neutral-300) 75%),
      linear-gradient(45deg, var(--sl-color-neutral-300) 25%, transparent 25%);
    background-size: 10px 10px;
    background-position:
      0 0,
      0 0,
      -5px -5px,
      5px 5px;
  }

  .color-picker--disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }

  .color-picker--disabled .color-picker__grid,
  .color-picker--disabled .color-picker__grid-handle,
  .color-picker--disabled .color-picker__slider,
  .color-picker--disabled .color-picker__slider-handle,
  .color-picker--disabled .color-picker__preview,
  .color-picker--disabled .color-picker__swatch,
  .color-picker--disabled .color-picker__swatch-color {
    pointer-events: none;
  }

  /*
   * Color dropdown
   */

  .color-dropdown::part(panel) {
    max-height: none;
    background-color: var(--sl-panel-background-color);
    border: solid var(--sl-panel-border-width) var(--sl-panel-border-color);
    border-radius: var(--sl-border-radius-medium);
    overflow: visible;
  }

  .color-dropdown__trigger {
    display: inline-block;
    position: relative;
    background-color: transparent;
    border: none;
    cursor: pointer;
    forced-color-adjust: none;
  }

  .color-dropdown__trigger.color-dropdown__trigger--small {
    width: var(--sl-input-height-small);
    height: var(--sl-input-height-small);
    border-radius: var(--sl-border-radius-circle);
  }

  .color-dropdown__trigger.color-dropdown__trigger--medium {
    width: var(--sl-input-height-medium);
    height: var(--sl-input-height-medium);
    border-radius: var(--sl-border-radius-circle);
  }

  .color-dropdown__trigger.color-dropdown__trigger--large {
    width: var(--sl-input-height-large);
    height: var(--sl-input-height-large);
    border-radius: var(--sl-border-radius-circle);
  }

  .color-dropdown__trigger:before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    border-radius: inherit;
    background-color: currentColor;
    box-shadow:
      inset 0 0 0 2px var(--sl-input-border-color),
      inset 0 0 0 4px var(--sl-color-neutral-0);
  }

  .color-dropdown__trigger--empty:before {
    background-color: transparent;
  }

  .color-dropdown__trigger:focus-visible {
    outline: none;
  }

  .color-dropdown__trigger:focus-visible:not(.color-dropdown__trigger--disabled) {
    outline: var(--sl-focus-ring);
    outline-offset: var(--sl-focus-ring-offset);
  }

  .color-dropdown__trigger.color-dropdown__trigger--disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }
`, SlButton = class extends ShoelaceElement {
  constructor() {
    super(...arguments), this.formControlController = new FormControlController(this, {
      assumeInteractionOn: ["click"]
    }), this.hasSlotController = new HasSlotController(this, "[default]", "prefix", "suffix"), this.localize = new LocalizeController(this), this.hasFocus = !1, this.invalid = !1, this.title = "", this.variant = "default", this.size = "medium", this.caret = !1, this.disabled = !1, this.loading = !1, this.outline = !1, this.pill = !1, this.circle = !1, this.type = "button", this.name = "", this.value = "", this.href = "", this.rel = "noreferrer noopener";
  }
  /** Gets the validity state object */
  get validity() {
    return this.isButton() ? this.button.validity : validValidityState;
  }
  /** Gets the validation message */
  get validationMessage() {
    return this.isButton() ? this.button.validationMessage : "";
  }
  firstUpdated() {
    this.isButton() && this.formControlController.updateValidity();
  }
  handleBlur() {
    this.hasFocus = !1, this.emit("sl-blur");
  }
  handleFocus() {
    this.hasFocus = !0, this.emit("sl-focus");
  }
  handleClick() {
    this.type === "submit" && this.formControlController.submit(this), this.type === "reset" && this.formControlController.reset(this);
  }
  handleInvalid(C) {
    this.formControlController.setValidity(!1), this.formControlController.emitInvalidEvent(C);
  }
  isButton() {
    return !this.href;
  }
  isLink() {
    return !!this.href;
  }
  handleDisabledChange() {
    this.isButton() && this.formControlController.setValidity(this.disabled);
  }
  /** Simulates a click on the button. */
  click() {
    this.button.click();
  }
  /** Sets focus on the button. */
  focus(C) {
    this.button.focus(C);
  }
  /** Removes focus from the button. */
  blur() {
    this.button.blur();
  }
  /** Checks for validity but does not show a validation message. Returns `true` when valid and `false` when invalid. */
  checkValidity() {
    return this.isButton() ? this.button.checkValidity() : !0;
  }
  /** Gets the associated form, if one exists. */
  getForm() {
    return this.formControlController.getForm();
  }
  /** Checks for validity and shows the browser's validation message if the control is invalid. */
  reportValidity() {
    return this.isButton() ? this.button.reportValidity() : !0;
  }
  /** Sets a custom validation message. Pass an empty string to restore validity. */
  setCustomValidity(C) {
    this.isButton() && (this.button.setCustomValidity(C), this.formControlController.updateValidity());
  }
  render() {
    const C = this.isLink(), L = C ? er`a` : er`button`;
    return ke`
      <${L}
        part="base"
        class=${Rt({
      button: !0,
      "button--default": this.variant === "default",
      "button--primary": this.variant === "primary",
      "button--success": this.variant === "success",
      "button--neutral": this.variant === "neutral",
      "button--warning": this.variant === "warning",
      "button--danger": this.variant === "danger",
      "button--text": this.variant === "text",
      "button--small": this.size === "small",
      "button--medium": this.size === "medium",
      "button--large": this.size === "large",
      "button--caret": this.caret,
      "button--circle": this.circle,
      "button--disabled": this.disabled,
      "button--focused": this.hasFocus,
      "button--loading": this.loading,
      "button--standard": !this.outline,
      "button--outline": this.outline,
      "button--pill": this.pill,
      "button--rtl": this.localize.dir() === "rtl",
      "button--has-label": this.hasSlotController.test("[default]"),
      "button--has-prefix": this.hasSlotController.test("prefix"),
      "button--has-suffix": this.hasSlotController.test("suffix")
    })}
        ?disabled=${to(C ? void 0 : this.disabled)}
        type=${to(C ? void 0 : this.type)}
        title=${this.title}
        name=${to(C ? void 0 : this.name)}
        value=${to(C ? void 0 : this.value)}
        href=${to(C ? this.href : void 0)}
        target=${to(C ? this.target : void 0)}
        download=${to(C ? this.download : void 0)}
        rel=${to(C ? this.rel : void 0)}
        role=${to(C ? void 0 : "button")}
        aria-disabled=${this.disabled ? "true" : "false"}
        tabindex=${this.disabled ? "-1" : "0"}
        @blur=${this.handleBlur}
        @focus=${this.handleFocus}
        @invalid=${this.isButton() ? this.handleInvalid : null}
        @click=${this.handleClick}
      >
        <slot name="prefix" part="prefix" class="button__prefix"></slot>
        <slot part="label" class="button__label"></slot>
        <slot name="suffix" part="suffix" class="button__suffix"></slot>
        ${this.caret ? ke` <sl-icon part="caret" class="button__caret" library="system" name="caret"></sl-icon> ` : ""}
        ${this.loading ? ke`<sl-spinner part="spinner"></sl-spinner>` : ""}
      </${L}>
    `;
  }
};
SlButton.styles = [component_styles_default, button_styles_default];
SlButton.dependencies = {
  "sl-icon": SlIcon,
  "sl-spinner": SlSpinner
};
__decorateClass$e([
  e$6(".button")
], SlButton.prototype, "button", 2);
__decorateClass$e([
  r$3()
], SlButton.prototype, "hasFocus", 2);
__decorateClass$e([
  r$3()
], SlButton.prototype, "invalid", 2);
__decorateClass$e([
  n$1()
], SlButton.prototype, "title", 2);
__decorateClass$e([
  n$1({ reflect: !0 })
], SlButton.prototype, "variant", 2);
__decorateClass$e([
  n$1({ reflect: !0 })
], SlButton.prototype, "size", 2);
__decorateClass$e([
  n$1({ type: Boolean, reflect: !0 })
], SlButton.prototype, "caret", 2);
__decorateClass$e([
  n$1({ type: Boolean, reflect: !0 })
], SlButton.prototype, "disabled", 2);
__decorateClass$e([
  n$1({ type: Boolean, reflect: !0 })
], SlButton.prototype, "loading", 2);
__decorateClass$e([
  n$1({ type: Boolean, reflect: !0 })
], SlButton.prototype, "outline", 2);
__decorateClass$e([
  n$1({ type: Boolean, reflect: !0 })
], SlButton.prototype, "pill", 2);
__decorateClass$e([
  n$1({ type: Boolean, reflect: !0 })
], SlButton.prototype, "circle", 2);
__decorateClass$e([
  n$1()
], SlButton.prototype, "type", 2);
__decorateClass$e([
  n$1()
], SlButton.prototype, "name", 2);
__decorateClass$e([
  n$1()
], SlButton.prototype, "value", 2);
__decorateClass$e([
  n$1()
], SlButton.prototype, "href", 2);
__decorateClass$e([
  n$1()
], SlButton.prototype, "target", 2);
__decorateClass$e([
  n$1()
], SlButton.prototype, "rel", 2);
__decorateClass$e([
  n$1()
], SlButton.prototype, "download", 2);
__decorateClass$e([
  n$1()
], SlButton.prototype, "form", 2);
__decorateClass$e([
  n$1({ attribute: "formaction" })
], SlButton.prototype, "formAction", 2);
__decorateClass$e([
  n$1({ attribute: "formenctype" })
], SlButton.prototype, "formEnctype", 2);
__decorateClass$e([
  n$1({ attribute: "formmethod" })
], SlButton.prototype, "formMethod", 2);
__decorateClass$e([
  n$1({ attribute: "formnovalidate", type: Boolean })
], SlButton.prototype, "formNoValidate", 2);
__decorateClass$e([
  n$1({ attribute: "formtarget" })
], SlButton.prototype, "formTarget", 2);
__decorateClass$e([
  watch("disabled", { waitUntilFirstUpdate: !0 })
], SlButton.prototype, "handleDisabledChange", 1);
function bound01(C, L) {
  isOnePointZero(C) && (C = "100%");
  const A = isPercentage(C);
  return C = L === 360 ? C : Math.min(L, Math.max(0, parseFloat(C))), A && (C = parseInt(String(C * L), 10) / 100), Math.abs(C - L) < 1e-6 ? 1 : (L === 360 ? C = (C < 0 ? C % L + L : C % L) / parseFloat(String(L)) : C = C % L / parseFloat(String(L)), C);
}
function clamp01(C) {
  return Math.min(1, Math.max(0, C));
}
function isOnePointZero(C) {
  return typeof C == "string" && C.indexOf(".") !== -1 && parseFloat(C) === 1;
}
function isPercentage(C) {
  return typeof C == "string" && C.indexOf("%") !== -1;
}
function boundAlpha(C) {
  return C = parseFloat(C), (isNaN(C) || C < 0 || C > 1) && (C = 1), C;
}
function convertToPercentage(C) {
  return Number(C) <= 1 ? `${Number(C) * 100}%` : C;
}
function pad2(C) {
  return C.length === 1 ? "0" + C : String(C);
}
function rgbToRgb(C, L, A) {
  return {
    r: bound01(C, 255) * 255,
    g: bound01(L, 255) * 255,
    b: bound01(A, 255) * 255
  };
}
function rgbToHsl(C, L, A) {
  C = bound01(C, 255), L = bound01(L, 255), A = bound01(A, 255);
  const W = Math.max(C, L, A), X = Math.min(C, L, A);
  let J = 0, te = 0;
  const oe = (W + X) / 2;
  if (W === X)
    te = 0, J = 0;
  else {
    const ne = W - X;
    switch (te = oe > 0.5 ? ne / (2 - W - X) : ne / (W + X), W) {
      case C:
        J = (L - A) / ne + (L < A ? 6 : 0);
        break;
      case L:
        J = (A - C) / ne + 2;
        break;
      case A:
        J = (C - L) / ne + 4;
        break;
    }
    J /= 6;
  }
  return { h: J, s: te, l: oe };
}
function hue2rgb(C, L, A) {
  return A < 0 && (A += 1), A > 1 && (A -= 1), A < 1 / 6 ? C + (L - C) * (6 * A) : A < 1 / 2 ? L : A < 2 / 3 ? C + (L - C) * (2 / 3 - A) * 6 : C;
}
function hslToRgb(C, L, A) {
  let W, X, J;
  if (C = bound01(C, 360), L = bound01(L, 100), A = bound01(A, 100), L === 0)
    X = A, J = A, W = A;
  else {
    const te = A < 0.5 ? A * (1 + L) : A + L - A * L, oe = 2 * A - te;
    W = hue2rgb(oe, te, C + 1 / 3), X = hue2rgb(oe, te, C), J = hue2rgb(oe, te, C - 1 / 3);
  }
  return { r: W * 255, g: X * 255, b: J * 255 };
}
function rgbToHsv(C, L, A) {
  C = bound01(C, 255), L = bound01(L, 255), A = bound01(A, 255);
  const W = Math.max(C, L, A), X = Math.min(C, L, A);
  let J = 0;
  const te = W, oe = W - X, ne = W === 0 ? 0 : oe / W;
  if (W === X)
    J = 0;
  else {
    switch (W) {
      case C:
        J = (L - A) / oe + (L < A ? 6 : 0);
        break;
      case L:
        J = (A - C) / oe + 2;
        break;
      case A:
        J = (C - L) / oe + 4;
        break;
    }
    J /= 6;
  }
  return { h: J, s: ne, v: te };
}
function hsvToRgb(C, L, A) {
  C = bound01(C, 360) * 6, L = bound01(L, 100), A = bound01(A, 100);
  const W = Math.floor(C), X = C - W, J = A * (1 - L), te = A * (1 - X * L), oe = A * (1 - (1 - X) * L), ne = W % 6, re = [A, te, J, J, oe, A][ne], ce = [oe, A, A, te, J, J][ne], ue = [J, J, oe, A, A, te][ne];
  return { r: re * 255, g: ce * 255, b: ue * 255 };
}
function rgbToHex(C, L, A, W) {
  const X = [
    pad2(Math.round(C).toString(16)),
    pad2(Math.round(L).toString(16)),
    pad2(Math.round(A).toString(16))
  ];
  return W && X[0].startsWith(X[0].charAt(1)) && X[1].startsWith(X[1].charAt(1)) && X[2].startsWith(X[2].charAt(1)) ? X[0].charAt(0) + X[1].charAt(0) + X[2].charAt(0) : X.join("");
}
function rgbaToHex(C, L, A, W, X) {
  const J = [
    pad2(Math.round(C).toString(16)),
    pad2(Math.round(L).toString(16)),
    pad2(Math.round(A).toString(16)),
    pad2(convertDecimalToHex(W))
  ];
  return X && J[0].startsWith(J[0].charAt(1)) && J[1].startsWith(J[1].charAt(1)) && J[2].startsWith(J[2].charAt(1)) && J[3].startsWith(J[3].charAt(1)) ? J[0].charAt(0) + J[1].charAt(0) + J[2].charAt(0) + J[3].charAt(0) : J.join("");
}
function cmykToRgb(C, L, A, W) {
  const X = C / 100, J = L / 100, te = A / 100, oe = W / 100, ne = 255 * (1 - X) * (1 - oe), re = 255 * (1 - J) * (1 - oe), ce = 255 * (1 - te) * (1 - oe);
  return { r: ne, g: re, b: ce };
}
function rgbToCmyk(C, L, A) {
  let W = 1 - C / 255, X = 1 - L / 255, J = 1 - A / 255, te = Math.min(W, X, J);
  return te === 1 ? (W = 0, X = 0, J = 0) : (W = (W - te) / (1 - te) * 100, X = (X - te) / (1 - te) * 100, J = (J - te) / (1 - te) * 100), te *= 100, {
    c: Math.round(W),
    m: Math.round(X),
    y: Math.round(J),
    k: Math.round(te)
  };
}
function convertDecimalToHex(C) {
  return Math.round(parseFloat(C) * 255).toString(16);
}
function convertHexToDecimal(C) {
  return parseIntFromHex(C) / 255;
}
function parseIntFromHex(C) {
  return parseInt(C, 16);
}
function numberInputToObject(C) {
  return {
    r: C >> 16,
    g: (C & 65280) >> 8,
    b: C & 255
  };
}
const names = {
  aliceblue: "#f0f8ff",
  antiquewhite: "#faebd7",
  aqua: "#00ffff",
  aquamarine: "#7fffd4",
  azure: "#f0ffff",
  beige: "#f5f5dc",
  bisque: "#ffe4c4",
  black: "#000000",
  blanchedalmond: "#ffebcd",
  blue: "#0000ff",
  blueviolet: "#8a2be2",
  brown: "#a52a2a",
  burlywood: "#deb887",
  cadetblue: "#5f9ea0",
  chartreuse: "#7fff00",
  chocolate: "#d2691e",
  coral: "#ff7f50",
  cornflowerblue: "#6495ed",
  cornsilk: "#fff8dc",
  crimson: "#dc143c",
  cyan: "#00ffff",
  darkblue: "#00008b",
  darkcyan: "#008b8b",
  darkgoldenrod: "#b8860b",
  darkgray: "#a9a9a9",
  darkgreen: "#006400",
  darkgrey: "#a9a9a9",
  darkkhaki: "#bdb76b",
  darkmagenta: "#8b008b",
  darkolivegreen: "#556b2f",
  darkorange: "#ff8c00",
  darkorchid: "#9932cc",
  darkred: "#8b0000",
  darksalmon: "#e9967a",
  darkseagreen: "#8fbc8f",
  darkslateblue: "#483d8b",
  darkslategray: "#2f4f4f",
  darkslategrey: "#2f4f4f",
  darkturquoise: "#00ced1",
  darkviolet: "#9400d3",
  deeppink: "#ff1493",
  deepskyblue: "#00bfff",
  dimgray: "#696969",
  dimgrey: "#696969",
  dodgerblue: "#1e90ff",
  firebrick: "#b22222",
  floralwhite: "#fffaf0",
  forestgreen: "#228b22",
  fuchsia: "#ff00ff",
  gainsboro: "#dcdcdc",
  ghostwhite: "#f8f8ff",
  goldenrod: "#daa520",
  gold: "#ffd700",
  gray: "#808080",
  green: "#008000",
  greenyellow: "#adff2f",
  grey: "#808080",
  honeydew: "#f0fff0",
  hotpink: "#ff69b4",
  indianred: "#cd5c5c",
  indigo: "#4b0082",
  ivory: "#fffff0",
  khaki: "#f0e68c",
  lavenderblush: "#fff0f5",
  lavender: "#e6e6fa",
  lawngreen: "#7cfc00",
  lemonchiffon: "#fffacd",
  lightblue: "#add8e6",
  lightcoral: "#f08080",
  lightcyan: "#e0ffff",
  lightgoldenrodyellow: "#fafad2",
  lightgray: "#d3d3d3",
  lightgreen: "#90ee90",
  lightgrey: "#d3d3d3",
  lightpink: "#ffb6c1",
  lightsalmon: "#ffa07a",
  lightseagreen: "#20b2aa",
  lightskyblue: "#87cefa",
  lightslategray: "#778899",
  lightslategrey: "#778899",
  lightsteelblue: "#b0c4de",
  lightyellow: "#ffffe0",
  lime: "#00ff00",
  limegreen: "#32cd32",
  linen: "#faf0e6",
  magenta: "#ff00ff",
  maroon: "#800000",
  mediumaquamarine: "#66cdaa",
  mediumblue: "#0000cd",
  mediumorchid: "#ba55d3",
  mediumpurple: "#9370db",
  mediumseagreen: "#3cb371",
  mediumslateblue: "#7b68ee",
  mediumspringgreen: "#00fa9a",
  mediumturquoise: "#48d1cc",
  mediumvioletred: "#c71585",
  midnightblue: "#191970",
  mintcream: "#f5fffa",
  mistyrose: "#ffe4e1",
  moccasin: "#ffe4b5",
  navajowhite: "#ffdead",
  navy: "#000080",
  oldlace: "#fdf5e6",
  olive: "#808000",
  olivedrab: "#6b8e23",
  orange: "#ffa500",
  orangered: "#ff4500",
  orchid: "#da70d6",
  palegoldenrod: "#eee8aa",
  palegreen: "#98fb98",
  paleturquoise: "#afeeee",
  palevioletred: "#db7093",
  papayawhip: "#ffefd5",
  peachpuff: "#ffdab9",
  peru: "#cd853f",
  pink: "#ffc0cb",
  plum: "#dda0dd",
  powderblue: "#b0e0e6",
  purple: "#800080",
  rebeccapurple: "#663399",
  red: "#ff0000",
  rosybrown: "#bc8f8f",
  royalblue: "#4169e1",
  saddlebrown: "#8b4513",
  salmon: "#fa8072",
  sandybrown: "#f4a460",
  seagreen: "#2e8b57",
  seashell: "#fff5ee",
  sienna: "#a0522d",
  silver: "#c0c0c0",
  skyblue: "#87ceeb",
  slateblue: "#6a5acd",
  slategray: "#708090",
  slategrey: "#708090",
  snow: "#fffafa",
  springgreen: "#00ff7f",
  steelblue: "#4682b4",
  tan: "#d2b48c",
  teal: "#008080",
  thistle: "#d8bfd8",
  tomato: "#ff6347",
  turquoise: "#40e0d0",
  violet: "#ee82ee",
  wheat: "#f5deb3",
  white: "#ffffff",
  whitesmoke: "#f5f5f5",
  yellow: "#ffff00",
  yellowgreen: "#9acd32"
};
function inputToRGB(C) {
  let L = { r: 0, g: 0, b: 0 }, A = 1, W = null, X = null, J = null, te = !1, oe = !1;
  return typeof C == "string" && (C = stringInputToObject(C)), typeof C == "object" && (isValidCSSUnit(C.r) && isValidCSSUnit(C.g) && isValidCSSUnit(C.b) ? (L = rgbToRgb(C.r, C.g, C.b), te = !0, oe = String(C.r).substr(-1) === "%" ? "prgb" : "rgb") : isValidCSSUnit(C.h) && isValidCSSUnit(C.s) && isValidCSSUnit(C.v) ? (W = convertToPercentage(C.s), X = convertToPercentage(C.v), L = hsvToRgb(C.h, W, X), te = !0, oe = "hsv") : isValidCSSUnit(C.h) && isValidCSSUnit(C.s) && isValidCSSUnit(C.l) ? (W = convertToPercentage(C.s), J = convertToPercentage(C.l), L = hslToRgb(C.h, W, J), te = !0, oe = "hsl") : isValidCSSUnit(C.c) && isValidCSSUnit(C.m) && isValidCSSUnit(C.y) && isValidCSSUnit(C.k) && (L = cmykToRgb(C.c, C.m, C.y, C.k), te = !0, oe = "cmyk"), Object.prototype.hasOwnProperty.call(C, "a") && (A = C.a)), A = boundAlpha(A), {
    ok: te,
    format: C.format || oe,
    r: Math.min(255, Math.max(L.r, 0)),
    g: Math.min(255, Math.max(L.g, 0)),
    b: Math.min(255, Math.max(L.b, 0)),
    a: A
  };
}
const CSS_INTEGER = "[-\\+]?\\d+%?", CSS_NUMBER = "[-\\+]?\\d*\\.\\d+%?", CSS_UNIT = "(?:" + CSS_NUMBER + ")|(?:" + CSS_INTEGER + ")", PERMISSIVE_MATCH3 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?", PERMISSIVE_MATCH4 = (
  // eslint-disable-next-line prettier/prettier
  "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?"
), matchers = {
  CSS_UNIT: new RegExp(CSS_UNIT),
  rgb: new RegExp("rgb" + PERMISSIVE_MATCH3),
  rgba: new RegExp("rgba" + PERMISSIVE_MATCH4),
  hsl: new RegExp("hsl" + PERMISSIVE_MATCH3),
  hsla: new RegExp("hsla" + PERMISSIVE_MATCH4),
  hsv: new RegExp("hsv" + PERMISSIVE_MATCH3),
  hsva: new RegExp("hsva" + PERMISSIVE_MATCH4),
  cmyk: new RegExp("cmyk" + PERMISSIVE_MATCH4),
  hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
  hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
  hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
  hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
};
function stringInputToObject(C) {
  if (C = C.trim().toLowerCase(), C.length === 0)
    return !1;
  let L = !1;
  if (names[C])
    C = names[C], L = !0;
  else if (C === "transparent")
    return { r: 0, g: 0, b: 0, a: 0, format: "name" };
  let A = matchers.rgb.exec(C);
  return A ? { r: A[1], g: A[2], b: A[3] } : (A = matchers.rgba.exec(C), A ? { r: A[1], g: A[2], b: A[3], a: A[4] } : (A = matchers.hsl.exec(C), A ? { h: A[1], s: A[2], l: A[3] } : (A = matchers.hsla.exec(C), A ? { h: A[1], s: A[2], l: A[3], a: A[4] } : (A = matchers.hsv.exec(C), A ? { h: A[1], s: A[2], v: A[3] } : (A = matchers.hsva.exec(C), A ? { h: A[1], s: A[2], v: A[3], a: A[4] } : (A = matchers.cmyk.exec(C), A ? {
    c: A[1],
    m: A[2],
    y: A[3],
    k: A[4]
  } : (A = matchers.hex8.exec(C), A ? {
    r: parseIntFromHex(A[1]),
    g: parseIntFromHex(A[2]),
    b: parseIntFromHex(A[3]),
    a: convertHexToDecimal(A[4]),
    format: L ? "name" : "hex8"
  } : (A = matchers.hex6.exec(C), A ? {
    r: parseIntFromHex(A[1]),
    g: parseIntFromHex(A[2]),
    b: parseIntFromHex(A[3]),
    format: L ? "name" : "hex"
  } : (A = matchers.hex4.exec(C), A ? {
    r: parseIntFromHex(A[1] + A[1]),
    g: parseIntFromHex(A[2] + A[2]),
    b: parseIntFromHex(A[3] + A[3]),
    a: convertHexToDecimal(A[4] + A[4]),
    format: L ? "name" : "hex8"
  } : (A = matchers.hex3.exec(C), A ? {
    r: parseIntFromHex(A[1] + A[1]),
    g: parseIntFromHex(A[2] + A[2]),
    b: parseIntFromHex(A[3] + A[3]),
    format: L ? "name" : "hex"
  } : !1))))))))));
}
function isValidCSSUnit(C) {
  return typeof C == "number" ? !Number.isNaN(C) : matchers.CSS_UNIT.test(C);
}
class TinyColor {
  constructor(L = "", A = {}) {
    if (L instanceof TinyColor)
      return L;
    typeof L == "number" && (L = numberInputToObject(L)), this.originalInput = L;
    const W = inputToRGB(L);
    this.originalInput = L, this.r = W.r, this.g = W.g, this.b = W.b, this.a = W.a, this.roundA = Math.round(100 * this.a) / 100, this.format = A.format ?? W.format, this.gradientType = A.gradientType, this.r < 1 && (this.r = Math.round(this.r)), this.g < 1 && (this.g = Math.round(this.g)), this.b < 1 && (this.b = Math.round(this.b)), this.isValid = W.ok;
  }
  isDark() {
    return this.getBrightness() < 128;
  }
  isLight() {
    return !this.isDark();
  }
  /**
   * Returns the perceived brightness of the color, from 0-255.
   */
  getBrightness() {
    const L = this.toRgb();
    return (L.r * 299 + L.g * 587 + L.b * 114) / 1e3;
  }
  /**
   * Returns the perceived luminance of a color, from 0-1.
   */
  getLuminance() {
    const L = this.toRgb();
    let A, W, X;
    const J = L.r / 255, te = L.g / 255, oe = L.b / 255;
    return J <= 0.03928 ? A = J / 12.92 : A = Math.pow((J + 0.055) / 1.055, 2.4), te <= 0.03928 ? W = te / 12.92 : W = Math.pow((te + 0.055) / 1.055, 2.4), oe <= 0.03928 ? X = oe / 12.92 : X = Math.pow((oe + 0.055) / 1.055, 2.4), 0.2126 * A + 0.7152 * W + 0.0722 * X;
  }
  /**
   * Returns the alpha value of a color, from 0-1.
   */
  getAlpha() {
    return this.a;
  }
  /**
   * Sets the alpha value on the current color.
   *
   * @param alpha - The new alpha value. The accepted range is 0-1.
   */
  setAlpha(L) {
    return this.a = boundAlpha(L), this.roundA = Math.round(100 * this.a) / 100, this;
  }
  /**
   * Returns whether the color is monochrome.
   */
  isMonochrome() {
    const { s: L } = this.toHsl();
    return L === 0;
  }
  /**
   * Returns the object as a HSVA object.
   */
  toHsv() {
    const L = rgbToHsv(this.r, this.g, this.b);
    return { h: L.h * 360, s: L.s, v: L.v, a: this.a };
  }
  /**
   * Returns the hsva values interpolated into a string with the following format:
   * "hsva(xxx, xxx, xxx, xx)".
   */
  toHsvString() {
    const L = rgbToHsv(this.r, this.g, this.b), A = Math.round(L.h * 360), W = Math.round(L.s * 100), X = Math.round(L.v * 100);
    return this.a === 1 ? `hsv(${A}, ${W}%, ${X}%)` : `hsva(${A}, ${W}%, ${X}%, ${this.roundA})`;
  }
  /**
   * Returns the object as a HSLA object.
   */
  toHsl() {
    const L = rgbToHsl(this.r, this.g, this.b);
    return { h: L.h * 360, s: L.s, l: L.l, a: this.a };
  }
  /**
   * Returns the hsla values interpolated into a string with the following format:
   * "hsla(xxx, xxx, xxx, xx)".
   */
  toHslString() {
    const L = rgbToHsl(this.r, this.g, this.b), A = Math.round(L.h * 360), W = Math.round(L.s * 100), X = Math.round(L.l * 100);
    return this.a === 1 ? `hsl(${A}, ${W}%, ${X}%)` : `hsla(${A}, ${W}%, ${X}%, ${this.roundA})`;
  }
  /**
   * Returns the hex value of the color.
   * @param allow3Char will shorten hex value to 3 char if possible
   */
  toHex(L = !1) {
    return rgbToHex(this.r, this.g, this.b, L);
  }
  /**
   * Returns the hex value of the color -with a # prefixed.
   * @param allow3Char will shorten hex value to 3 char if possible
   */
  toHexString(L = !1) {
    return "#" + this.toHex(L);
  }
  /**
   * Returns the hex 8 value of the color.
   * @param allow4Char will shorten hex value to 4 char if possible
   */
  toHex8(L = !1) {
    return rgbaToHex(this.r, this.g, this.b, this.a, L);
  }
  /**
   * Returns the hex 8 value of the color -with a # prefixed.
   * @param allow4Char will shorten hex value to 4 char if possible
   */
  toHex8String(L = !1) {
    return "#" + this.toHex8(L);
  }
  /**
   * Returns the shorter hex value of the color depends on its alpha -with a # prefixed.
   * @param allowShortChar will shorten hex value to 3 or 4 char if possible
   */
  toHexShortString(L = !1) {
    return this.a === 1 ? this.toHexString(L) : this.toHex8String(L);
  }
  /**
   * Returns the object as a RGBA object.
   */
  toRgb() {
    return {
      r: Math.round(this.r),
      g: Math.round(this.g),
      b: Math.round(this.b),
      a: this.a
    };
  }
  /**
   * Returns the RGBA values interpolated into a string with the following format:
   * "RGBA(xxx, xxx, xxx, xx)".
   */
  toRgbString() {
    const L = Math.round(this.r), A = Math.round(this.g), W = Math.round(this.b);
    return this.a === 1 ? `rgb(${L}, ${A}, ${W})` : `rgba(${L}, ${A}, ${W}, ${this.roundA})`;
  }
  /**
   * Returns the object as a RGBA object.
   */
  toPercentageRgb() {
    const L = (A) => `${Math.round(bound01(A, 255) * 100)}%`;
    return {
      r: L(this.r),
      g: L(this.g),
      b: L(this.b),
      a: this.a
    };
  }
  /**
   * Returns the RGBA relative values interpolated into a string
   */
  toPercentageRgbString() {
    const L = (A) => Math.round(bound01(A, 255) * 100);
    return this.a === 1 ? `rgb(${L(this.r)}%, ${L(this.g)}%, ${L(this.b)}%)` : `rgba(${L(this.r)}%, ${L(this.g)}%, ${L(this.b)}%, ${this.roundA})`;
  }
  toCmyk() {
    return {
      ...rgbToCmyk(this.r, this.g, this.b)
    };
  }
  toCmykString() {
    const { c: L, m: A, y: W, k: X } = rgbToCmyk(this.r, this.g, this.b);
    return `cmyk(${L}, ${A}, ${W}, ${X})`;
  }
  /**
   * The 'real' name of the color -if there is one.
   */
  toName() {
    if (this.a === 0)
      return "transparent";
    if (this.a < 1)
      return !1;
    const L = "#" + rgbToHex(this.r, this.g, this.b, !1);
    for (const [A, W] of Object.entries(names))
      if (L === W)
        return A;
    return !1;
  }
  toString(L) {
    const A = !!L;
    L = L ?? this.format;
    let W = !1;
    const X = this.a < 1 && this.a >= 0;
    return !A && X && (L.startsWith("hex") || L === "name") ? L === "name" && this.a === 0 ? this.toName() : this.toRgbString() : (L === "rgb" && (W = this.toRgbString()), L === "prgb" && (W = this.toPercentageRgbString()), (L === "hex" || L === "hex6") && (W = this.toHexString()), L === "hex3" && (W = this.toHexString(!0)), L === "hex4" && (W = this.toHex8String(!0)), L === "hex8" && (W = this.toHex8String()), L === "name" && (W = this.toName()), L === "hsl" && (W = this.toHslString()), L === "hsv" && (W = this.toHsvString()), L === "cmyk" && (W = this.toCmykString()), W || this.toHexString());
  }
  toNumber() {
    return (Math.round(this.r) << 16) + (Math.round(this.g) << 8) + Math.round(this.b);
  }
  clone() {
    return new TinyColor(this.toString());
  }
  /**
   * Lighten the color a given amount. Providing 100 will always return white.
   * @param amount - valid between 1-100
   */
  lighten(L = 10) {
    const A = this.toHsl();
    return A.l += L / 100, A.l = clamp01(A.l), new TinyColor(A);
  }
  /**
   * Brighten the color a given amount, from 0 to 100.
   * @param amount - valid between 1-100
   */
  brighten(L = 10) {
    const A = this.toRgb();
    return A.r = Math.max(0, Math.min(255, A.r - Math.round(255 * -(L / 100)))), A.g = Math.max(0, Math.min(255, A.g - Math.round(255 * -(L / 100)))), A.b = Math.max(0, Math.min(255, A.b - Math.round(255 * -(L / 100)))), new TinyColor(A);
  }
  /**
   * Darken the color a given amount, from 0 to 100.
   * Providing 100 will always return black.
   * @param amount - valid between 1-100
   */
  darken(L = 10) {
    const A = this.toHsl();
    return A.l -= L / 100, A.l = clamp01(A.l), new TinyColor(A);
  }
  /**
   * Mix the color with pure white, from 0 to 100.
   * Providing 0 will do nothing, providing 100 will always return white.
   * @param amount - valid between 1-100
   */
  tint(L = 10) {
    return this.mix("white", L);
  }
  /**
   * Mix the color with pure black, from 0 to 100.
   * Providing 0 will do nothing, providing 100 will always return black.
   * @param amount - valid between 1-100
   */
  shade(L = 10) {
    return this.mix("black", L);
  }
  /**
   * Desaturate the color a given amount, from 0 to 100.
   * Providing 100 will is the same as calling greyscale
   * @param amount - valid between 1-100
   */
  desaturate(L = 10) {
    const A = this.toHsl();
    return A.s -= L / 100, A.s = clamp01(A.s), new TinyColor(A);
  }
  /**
   * Saturate the color a given amount, from 0 to 100.
   * @param amount - valid between 1-100
   */
  saturate(L = 10) {
    const A = this.toHsl();
    return A.s += L / 100, A.s = clamp01(A.s), new TinyColor(A);
  }
  /**
   * Completely desaturates a color into greyscale.
   * Same as calling `desaturate(100)`
   */
  greyscale() {
    return this.desaturate(100);
  }
  /**
   * Spin takes a positive or negative amount within [-360, 360] indicating the change of hue.
   * Values outside of this range will be wrapped into this range.
   */
  spin(L) {
    const A = this.toHsl(), W = (A.h + L) % 360;
    return A.h = W < 0 ? 360 + W : W, new TinyColor(A);
  }
  /**
   * Mix the current color a given amount with another color, from 0 to 100.
   * 0 means no mixing (return current color).
   */
  mix(L, A = 50) {
    const W = this.toRgb(), X = new TinyColor(L).toRgb(), J = A / 100, te = {
      r: (X.r - W.r) * J + W.r,
      g: (X.g - W.g) * J + W.g,
      b: (X.b - W.b) * J + W.b,
      a: (X.a - W.a) * J + W.a
    };
    return new TinyColor(te);
  }
  analogous(L = 6, A = 30) {
    const W = this.toHsl(), X = 360 / A, J = [this];
    for (W.h = (W.h - (X * L >> 1) + 720) % 360; --L; )
      W.h = (W.h + X) % 360, J.push(new TinyColor(W));
    return J;
  }
  /**
   * taken from https://github.com/infusion/jQuery-xcolor/blob/master/jquery.xcolor.js
   */
  complement() {
    const L = this.toHsl();
    return L.h = (L.h + 180) % 360, new TinyColor(L);
  }
  monochromatic(L = 6) {
    const A = this.toHsv(), { h: W } = A, { s: X } = A;
    let { v: J } = A;
    const te = [], oe = 1 / L;
    for (; L--; )
      te.push(new TinyColor({ h: W, s: X, v: J })), J = (J + oe) % 1;
    return te;
  }
  splitcomplement() {
    const L = this.toHsl(), { h: A } = L;
    return [
      this,
      new TinyColor({ h: (A + 72) % 360, s: L.s, l: L.l }),
      new TinyColor({ h: (A + 216) % 360, s: L.s, l: L.l })
    ];
  }
  /**
   * Compute how the color would appear on a background
   */
  onBackground(L) {
    const A = this.toRgb(), W = new TinyColor(L).toRgb(), X = A.a + W.a * (1 - A.a);
    return new TinyColor({
      r: (A.r * A.a + W.r * W.a * (1 - A.a)) / X,
      g: (A.g * A.a + W.g * W.a * (1 - A.a)) / X,
      b: (A.b * A.a + W.b * W.a * (1 - A.a)) / X,
      a: X
    });
  }
  /**
   * Alias for `polyad(3)`
   */
  triad() {
    return this.polyad(3);
  }
  /**
   * Alias for `polyad(4)`
   */
  tetrad() {
    return this.polyad(4);
  }
  /**
   * Get polyad colors, like (for 1, 2, 3, 4, 5, 6, 7, 8, etc...)
   * monad, dyad, triad, tetrad, pentad, hexad, heptad, octad, etc...
   */
  polyad(L) {
    const A = this.toHsl(), { h: W } = A, X = [this], J = 360 / L;
    for (let te = 1; te < L; te++)
      X.push(new TinyColor({ h: (W + te * J) % 360, s: A.s, l: A.l }));
    return X;
  }
  /**
   * compare color vs current color
   */
  equals(L) {
    const A = new TinyColor(L);
    return this.format === "cmyk" || A.format === "cmyk" ? this.toCmykString() === A.toCmykString() : this.toRgbString() === A.toRgbString();
  }
}
var hasEyeDropper = "EyeDropper" in window, SlColorPicker = class extends ShoelaceElement {
  constructor() {
    super(), this.formControlController = new FormControlController(this), this.isSafeValue = !1, this.localize = new LocalizeController(this), this.hasFocus = !1, this.isDraggingGridHandle = !1, this.isEmpty = !1, this.inputValue = "", this.hue = 0, this.saturation = 100, this.brightness = 100, this.alpha = 100, this.value = "", this.defaultValue = "", this.label = "", this.format = "hex", this.inline = !1, this.size = "medium", this.noFormatToggle = !1, this.name = "", this.disabled = !1, this.hoist = !1, this.opacity = !1, this.uppercase = !1, this.swatches = "", this.form = "", this.required = !1, this.handleFocusIn = () => {
      this.hasFocus = !0, this.emit("sl-focus");
    }, this.handleFocusOut = () => {
      this.hasFocus = !1, this.emit("sl-blur");
    }, this.addEventListener("focusin", this.handleFocusIn), this.addEventListener("focusout", this.handleFocusOut);
  }
  /** Gets the validity state object */
  get validity() {
    return this.input.validity;
  }
  /** Gets the validation message */
  get validationMessage() {
    return this.input.validationMessage;
  }
  firstUpdated() {
    this.input.updateComplete.then(() => {
      this.formControlController.updateValidity();
    });
  }
  handleCopy() {
    this.input.select(), document.execCommand("copy"), this.previewButton.focus(), this.previewButton.classList.add("color-picker__preview-color--copied"), this.previewButton.addEventListener("animationend", () => {
      this.previewButton.classList.remove("color-picker__preview-color--copied");
    });
  }
  handleFormatToggle() {
    const C = ["hex", "rgb", "hsl", "hsv"], L = (C.indexOf(this.format) + 1) % C.length;
    this.format = C[L], this.setColor(this.value), this.emit("sl-change"), this.emit("sl-input");
  }
  handleAlphaDrag(C) {
    const L = this.shadowRoot.querySelector(".color-picker__slider.color-picker__alpha"), A = L.querySelector(".color-picker__slider-handle"), { width: W } = L.getBoundingClientRect();
    let X = this.value, J = this.value;
    A.focus(), C.preventDefault(), drag(L, {
      onMove: (te) => {
        this.alpha = clamp(te / W * 100, 0, 100), this.syncValues(), this.value !== J && (J = this.value, this.emit("sl-input"));
      },
      onStop: () => {
        this.value !== X && (X = this.value, this.emit("sl-change"));
      },
      initialEvent: C
    });
  }
  handleHueDrag(C) {
    const L = this.shadowRoot.querySelector(".color-picker__slider.color-picker__hue"), A = L.querySelector(".color-picker__slider-handle"), { width: W } = L.getBoundingClientRect();
    let X = this.value, J = this.value;
    A.focus(), C.preventDefault(), drag(L, {
      onMove: (te) => {
        this.hue = clamp(te / W * 360, 0, 360), this.syncValues(), this.value !== J && (J = this.value, this.emit("sl-input"));
      },
      onStop: () => {
        this.value !== X && (X = this.value, this.emit("sl-change"));
      },
      initialEvent: C
    });
  }
  handleGridDrag(C) {
    const L = this.shadowRoot.querySelector(".color-picker__grid"), A = L.querySelector(".color-picker__grid-handle"), { width: W, height: X } = L.getBoundingClientRect();
    let J = this.value, te = this.value;
    A.focus(), C.preventDefault(), this.isDraggingGridHandle = !0, drag(L, {
      onMove: (oe, ne) => {
        this.saturation = clamp(oe / W * 100, 0, 100), this.brightness = clamp(100 - ne / X * 100, 0, 100), this.syncValues(), this.value !== te && (te = this.value, this.emit("sl-input"));
      },
      onStop: () => {
        this.isDraggingGridHandle = !1, this.value !== J && (J = this.value, this.emit("sl-change"));
      },
      initialEvent: C
    });
  }
  handleAlphaKeyDown(C) {
    const L = C.shiftKey ? 10 : 1, A = this.value;
    C.key === "ArrowLeft" && (C.preventDefault(), this.alpha = clamp(this.alpha - L, 0, 100), this.syncValues()), C.key === "ArrowRight" && (C.preventDefault(), this.alpha = clamp(this.alpha + L, 0, 100), this.syncValues()), C.key === "Home" && (C.preventDefault(), this.alpha = 0, this.syncValues()), C.key === "End" && (C.preventDefault(), this.alpha = 100, this.syncValues()), this.value !== A && (this.emit("sl-change"), this.emit("sl-input"));
  }
  handleHueKeyDown(C) {
    const L = C.shiftKey ? 10 : 1, A = this.value;
    C.key === "ArrowLeft" && (C.preventDefault(), this.hue = clamp(this.hue - L, 0, 360), this.syncValues()), C.key === "ArrowRight" && (C.preventDefault(), this.hue = clamp(this.hue + L, 0, 360), this.syncValues()), C.key === "Home" && (C.preventDefault(), this.hue = 0, this.syncValues()), C.key === "End" && (C.preventDefault(), this.hue = 360, this.syncValues()), this.value !== A && (this.emit("sl-change"), this.emit("sl-input"));
  }
  handleGridKeyDown(C) {
    const L = C.shiftKey ? 10 : 1, A = this.value;
    C.key === "ArrowLeft" && (C.preventDefault(), this.saturation = clamp(this.saturation - L, 0, 100), this.syncValues()), C.key === "ArrowRight" && (C.preventDefault(), this.saturation = clamp(this.saturation + L, 0, 100), this.syncValues()), C.key === "ArrowUp" && (C.preventDefault(), this.brightness = clamp(this.brightness + L, 0, 100), this.syncValues()), C.key === "ArrowDown" && (C.preventDefault(), this.brightness = clamp(this.brightness - L, 0, 100), this.syncValues()), this.value !== A && (this.emit("sl-change"), this.emit("sl-input"));
  }
  handleInputChange(C) {
    const L = C.target, A = this.value;
    C.stopPropagation(), this.input.value ? (this.setColor(L.value), L.value = this.value) : this.value = "", this.value !== A && (this.emit("sl-change"), this.emit("sl-input"));
  }
  handleInputInput(C) {
    this.formControlController.updateValidity(), C.stopPropagation();
  }
  handleInputKeyDown(C) {
    if (C.key === "Enter") {
      const L = this.value;
      this.input.value ? (this.setColor(this.input.value), this.input.value = this.value, this.value !== L && (this.emit("sl-change"), this.emit("sl-input")), setTimeout(() => this.input.select())) : this.hue = 0;
    }
  }
  handleInputInvalid(C) {
    this.formControlController.setValidity(!1), this.formControlController.emitInvalidEvent(C);
  }
  handleTouchMove(C) {
    C.preventDefault();
  }
  parseColor(C) {
    const L = new TinyColor(C);
    if (!L.isValid)
      return null;
    const A = L.toHsl(), W = {
      h: A.h,
      s: A.s * 100,
      l: A.l * 100,
      a: A.a
    }, X = L.toRgb(), J = L.toHexString(), te = L.toHex8String(), oe = L.toHsv(), ne = {
      h: oe.h,
      s: oe.s * 100,
      v: oe.v * 100,
      a: oe.a
    };
    return {
      hsl: {
        h: W.h,
        s: W.s,
        l: W.l,
        string: this.setLetterCase(`hsl(${Math.round(W.h)}, ${Math.round(W.s)}%, ${Math.round(W.l)}%)`)
      },
      hsla: {
        h: W.h,
        s: W.s,
        l: W.l,
        a: W.a,
        string: this.setLetterCase(
          `hsla(${Math.round(W.h)}, ${Math.round(W.s)}%, ${Math.round(W.l)}%, ${W.a.toFixed(2).toString()})`
        )
      },
      hsv: {
        h: ne.h,
        s: ne.s,
        v: ne.v,
        string: this.setLetterCase(`hsv(${Math.round(ne.h)}, ${Math.round(ne.s)}%, ${Math.round(ne.v)}%)`)
      },
      hsva: {
        h: ne.h,
        s: ne.s,
        v: ne.v,
        a: ne.a,
        string: this.setLetterCase(
          `hsva(${Math.round(ne.h)}, ${Math.round(ne.s)}%, ${Math.round(ne.v)}%, ${ne.a.toFixed(2).toString()})`
        )
      },
      rgb: {
        r: X.r,
        g: X.g,
        b: X.b,
        string: this.setLetterCase(`rgb(${Math.round(X.r)}, ${Math.round(X.g)}, ${Math.round(X.b)})`)
      },
      rgba: {
        r: X.r,
        g: X.g,
        b: X.b,
        a: X.a,
        string: this.setLetterCase(
          `rgba(${Math.round(X.r)}, ${Math.round(X.g)}, ${Math.round(X.b)}, ${X.a.toFixed(2).toString()})`
        )
      },
      hex: this.setLetterCase(J),
      hexa: this.setLetterCase(te)
    };
  }
  setColor(C) {
    const L = this.parseColor(C);
    return L === null ? !1 : (this.hue = L.hsva.h, this.saturation = L.hsva.s, this.brightness = L.hsva.v, this.alpha = this.opacity ? L.hsva.a * 100 : 100, this.syncValues(), !0);
  }
  setLetterCase(C) {
    return typeof C != "string" ? "" : this.uppercase ? C.toUpperCase() : C.toLowerCase();
  }
  async syncValues() {
    const C = this.parseColor(
      `hsva(${this.hue}, ${this.saturation}%, ${this.brightness}%, ${this.alpha / 100})`
    );
    C !== null && (this.format === "hsl" ? this.inputValue = this.opacity ? C.hsla.string : C.hsl.string : this.format === "rgb" ? this.inputValue = this.opacity ? C.rgba.string : C.rgb.string : this.format === "hsv" ? this.inputValue = this.opacity ? C.hsva.string : C.hsv.string : this.inputValue = this.opacity ? C.hexa : C.hex, this.isSafeValue = !0, this.value = this.inputValue, await this.updateComplete, this.isSafeValue = !1);
  }
  handleAfterHide() {
    this.previewButton.classList.remove("color-picker__preview-color--copied");
  }
  handleEyeDropper() {
    if (!hasEyeDropper)
      return;
    new EyeDropper().open().then((L) => {
      const A = this.value;
      this.setColor(L.sRGBHex), this.value !== A && (this.emit("sl-change"), this.emit("sl-input"));
    }).catch(() => {
    });
  }
  selectSwatch(C) {
    const L = this.value;
    this.disabled || (this.setColor(C), this.value !== L && (this.emit("sl-change"), this.emit("sl-input")));
  }
  /** Generates a hex string from HSV values. Hue must be 0-360. All other arguments must be 0-100. */
  getHexString(C, L, A, W = 100) {
    const X = new TinyColor(`hsva(${C}, ${L}%, ${A}%, ${W / 100})`);
    return X.isValid ? X.toHex8String() : "";
  }
  // Prevents nested components from leaking events
  stopNestedEventPropagation(C) {
    C.stopImmediatePropagation();
  }
  handleFormatChange() {
    this.syncValues();
  }
  handleOpacityChange() {
    this.alpha = 100;
  }
  handleValueChange(C, L) {
    if (this.isEmpty = !L, L || (this.hue = 0, this.saturation = 0, this.brightness = 100, this.alpha = 100), !this.isSafeValue) {
      const A = this.parseColor(L);
      A !== null ? (this.inputValue = this.value, this.hue = A.hsva.h, this.saturation = A.hsva.s, this.brightness = A.hsva.v, this.alpha = A.hsva.a * 100, this.syncValues()) : this.inputValue = C ?? "";
    }
  }
  /** Sets focus on the color picker. */
  focus(C) {
    this.inline ? this.base.focus(C) : this.trigger.focus(C);
  }
  /** Removes focus from the color picker. */
  blur() {
    var C;
    const L = this.inline ? this.base : this.trigger;
    this.hasFocus && (L.focus({ preventScroll: !0 }), L.blur()), (C = this.dropdown) != null && C.open && this.dropdown.hide();
  }
  /** Returns the current value as a string in the specified format. */
  getFormattedValue(C = "hex") {
    const L = this.parseColor(
      `hsva(${this.hue}, ${this.saturation}%, ${this.brightness}%, ${this.alpha / 100})`
    );
    if (L === null)
      return "";
    switch (C) {
      case "hex":
        return L.hex;
      case "hexa":
        return L.hexa;
      case "rgb":
        return L.rgb.string;
      case "rgba":
        return L.rgba.string;
      case "hsl":
        return L.hsl.string;
      case "hsla":
        return L.hsla.string;
      case "hsv":
        return L.hsv.string;
      case "hsva":
        return L.hsva.string;
      default:
        return "";
    }
  }
  /** Checks for validity but does not show a validation message. Returns `true` when valid and `false` when invalid. */
  checkValidity() {
    return this.input.checkValidity();
  }
  /** Gets the associated form, if one exists. */
  getForm() {
    return this.formControlController.getForm();
  }
  /** Checks for validity and shows the browser's validation message if the control is invalid. */
  reportValidity() {
    return !this.inline && !this.validity.valid ? (this.dropdown.show(), this.addEventListener("sl-after-show", () => this.input.reportValidity(), { once: !0 }), this.disabled || this.formControlController.emitInvalidEvent(), !1) : this.input.reportValidity();
  }
  /** Sets a custom validation message. Pass an empty string to restore validity. */
  setCustomValidity(C) {
    this.input.setCustomValidity(C), this.formControlController.updateValidity();
  }
  render() {
    const C = this.saturation, L = 100 - this.brightness, A = Array.isArray(this.swatches) ? this.swatches : this.swatches.split(";").filter((X) => X.trim() !== ""), W = ke$1`
      <div
        part="base"
        class=${Rt({
      "color-picker": !0,
      "color-picker--inline": this.inline,
      "color-picker--disabled": this.disabled,
      "color-picker--focused": this.hasFocus
    })}
        aria-disabled=${this.disabled ? "true" : "false"}
        aria-labelledby="label"
        tabindex=${this.inline ? "0" : "-1"}
      >
        ${this.inline ? ke$1`
              <sl-visually-hidden id="label">
                <slot name="label">${this.label}</slot>
              </sl-visually-hidden>
            ` : null}

        <div
          part="grid"
          class="color-picker__grid"
          style=${se({ backgroundColor: this.getHexString(this.hue, 100, 100) })}
          @pointerdown=${this.handleGridDrag}
          @touchmove=${this.handleTouchMove}
        >
          <span
            part="grid-handle"
            class=${Rt({
      "color-picker__grid-handle": !0,
      "color-picker__grid-handle--dragging": this.isDraggingGridHandle
    })}
            style=${se({
      top: `${L}%`,
      left: `${C}%`,
      backgroundColor: this.getHexString(this.hue, this.saturation, this.brightness, this.alpha)
    })}
            role="application"
            aria-label="HSV"
            tabindex=${to(this.disabled ? void 0 : "0")}
            @keydown=${this.handleGridKeyDown}
          ></span>
        </div>

        <div class="color-picker__controls">
          <div class="color-picker__sliders">
            <div
              part="slider hue-slider"
              class="color-picker__hue color-picker__slider"
              @pointerdown=${this.handleHueDrag}
              @touchmove=${this.handleTouchMove}
            >
              <span
                part="slider-handle hue-slider-handle"
                class="color-picker__slider-handle"
                style=${se({
      left: `${this.hue === 0 ? 0 : 100 / (360 / this.hue)}%`
    })}
                role="slider"
                aria-label="hue"
                aria-orientation="horizontal"
                aria-valuemin="0"
                aria-valuemax="360"
                aria-valuenow=${`${Math.round(this.hue)}`}
                tabindex=${to(this.disabled ? void 0 : "0")}
                @keydown=${this.handleHueKeyDown}
              ></span>
            </div>

            ${this.opacity ? ke$1`
                  <div
                    part="slider opacity-slider"
                    class="color-picker__alpha color-picker__slider color-picker__transparent-bg"
                    @pointerdown="${this.handleAlphaDrag}"
                    @touchmove=${this.handleTouchMove}
                  >
                    <div
                      class="color-picker__alpha-gradient"
                      style=${se({
      backgroundImage: `linear-gradient(
                          to right,
                          ${this.getHexString(this.hue, this.saturation, this.brightness, 0)} 0%,
                          ${this.getHexString(this.hue, this.saturation, this.brightness, 100)} 100%
                        )`
    })}
                    ></div>
                    <span
                      part="slider-handle opacity-slider-handle"
                      class="color-picker__slider-handle"
                      style=${se({
      left: `${this.alpha}%`
    })}
                      role="slider"
                      aria-label="alpha"
                      aria-orientation="horizontal"
                      aria-valuemin="0"
                      aria-valuemax="100"
                      aria-valuenow=${Math.round(this.alpha)}
                      tabindex=${to(this.disabled ? void 0 : "0")}
                      @keydown=${this.handleAlphaKeyDown}
                    ></span>
                  </div>
                ` : ""}
          </div>

          <button
            type="button"
            part="preview"
            class="color-picker__preview color-picker__transparent-bg"
            aria-label=${this.localize.term("copy")}
            style=${se({
      "--preview-color": this.getHexString(this.hue, this.saturation, this.brightness, this.alpha)
    })}
            @click=${this.handleCopy}
          ></button>
        </div>

        <div class="color-picker__user-input" aria-live="polite">
          <sl-input
            part="input"
            type="text"
            name=${this.name}
            autocomplete="off"
            autocorrect="off"
            autocapitalize="off"
            spellcheck="false"
            value=${this.isEmpty ? "" : this.inputValue}
            ?required=${this.required}
            ?disabled=${this.disabled}
            aria-label=${this.localize.term("currentValue")}
            @keydown=${this.handleInputKeyDown}
            @sl-change=${this.handleInputChange}
            @sl-input=${this.handleInputInput}
            @sl-invalid=${this.handleInputInvalid}
            @sl-blur=${this.stopNestedEventPropagation}
            @sl-focus=${this.stopNestedEventPropagation}
          ></sl-input>

          <sl-button-group>
            ${this.noFormatToggle ? "" : ke$1`
                  <sl-button
                    part="format-button"
                    aria-label=${this.localize.term("toggleColorFormat")}
                    exportparts="
                      base:format-button__base,
                      prefix:format-button__prefix,
                      label:format-button__label,
                      suffix:format-button__suffix,
                      caret:format-button__caret
                    "
                    @click=${this.handleFormatToggle}
                    @sl-blur=${this.stopNestedEventPropagation}
                    @sl-focus=${this.stopNestedEventPropagation}
                  >
                    ${this.setLetterCase(this.format)}
                  </sl-button>
                `}
            ${hasEyeDropper ? ke$1`
                  <sl-button
                    part="eye-dropper-button"
                    exportparts="
                      base:eye-dropper-button__base,
                      prefix:eye-dropper-button__prefix,
                      label:eye-dropper-button__label,
                      suffix:eye-dropper-button__suffix,
                      caret:eye-dropper-button__caret
                    "
                    @click=${this.handleEyeDropper}
                    @sl-blur=${this.stopNestedEventPropagation}
                    @sl-focus=${this.stopNestedEventPropagation}
                  >
                    <sl-icon
                      library="system"
                      name="eyedropper"
                      label=${this.localize.term("selectAColorFromTheScreen")}
                    ></sl-icon>
                  </sl-button>
                ` : ""}
          </sl-button-group>
        </div>

        ${A.length > 0 ? ke$1`
              <div part="swatches" class="color-picker__swatches">
                ${A.map((X) => {
      const J = this.parseColor(X);
      return J ? ke$1`
                    <div
                      part="swatch"
                      class="color-picker__swatch color-picker__transparent-bg"
                      tabindex=${to(this.disabled ? void 0 : "0")}
                      role="button"
                      aria-label=${X}
                      @click=${() => this.selectSwatch(X)}
                      @keydown=${(te) => !this.disabled && te.key === "Enter" && this.setColor(J.hexa)}
                    >
                      <div
                        class="color-picker__swatch-color"
                        style=${se({ backgroundColor: J.hexa })}
                      ></div>
                    </div>
                  ` : (console.error(`Unable to parse swatch color: "${X}"`, this), "");
    })}
              </div>
            ` : ""}
      </div>
    `;
    return this.inline ? W : ke$1`
      <sl-dropdown
        class="color-dropdown"
        aria-disabled=${this.disabled ? "true" : "false"}
        .containing-element=${this}
        ?disabled=${this.disabled}
        ?hoist=${this.hoist}
        @sl-after-hide=${this.handleAfterHide}
      >
        <button
          part="trigger"
          slot="trigger"
          class=${Rt({
      "color-dropdown__trigger": !0,
      "color-dropdown__trigger--disabled": this.disabled,
      "color-dropdown__trigger--small": this.size === "small",
      "color-dropdown__trigger--medium": this.size === "medium",
      "color-dropdown__trigger--large": this.size === "large",
      "color-dropdown__trigger--empty": this.isEmpty,
      "color-dropdown__trigger--focused": this.hasFocus,
      "color-picker__transparent-bg": !0
    })}
          style=${se({
      color: this.getHexString(this.hue, this.saturation, this.brightness, this.alpha)
    })}
          type="button"
        >
          <sl-visually-hidden>
            <slot name="label">${this.label}</slot>
          </sl-visually-hidden>
        </button>
        ${W}
      </sl-dropdown>
    `;
  }
};
SlColorPicker.styles = [component_styles_default, color_picker_styles_default];
SlColorPicker.dependencies = {
  "sl-button-group": SlButtonGroup,
  "sl-button": SlButton,
  "sl-dropdown": SlDropdown,
  "sl-icon": SlIcon,
  "sl-input": SlInput,
  "sl-visually-hidden": SlVisuallyHidden
};
__decorateClass$e([
  e$6('[part~="base"]')
], SlColorPicker.prototype, "base", 2);
__decorateClass$e([
  e$6('[part~="input"]')
], SlColorPicker.prototype, "input", 2);
__decorateClass$e([
  e$6(".color-dropdown")
], SlColorPicker.prototype, "dropdown", 2);
__decorateClass$e([
  e$6('[part~="preview"]')
], SlColorPicker.prototype, "previewButton", 2);
__decorateClass$e([
  e$6('[part~="trigger"]')
], SlColorPicker.prototype, "trigger", 2);
__decorateClass$e([
  r$3()
], SlColorPicker.prototype, "hasFocus", 2);
__decorateClass$e([
  r$3()
], SlColorPicker.prototype, "isDraggingGridHandle", 2);
__decorateClass$e([
  r$3()
], SlColorPicker.prototype, "isEmpty", 2);
__decorateClass$e([
  r$3()
], SlColorPicker.prototype, "inputValue", 2);
__decorateClass$e([
  r$3()
], SlColorPicker.prototype, "hue", 2);
__decorateClass$e([
  r$3()
], SlColorPicker.prototype, "saturation", 2);
__decorateClass$e([
  r$3()
], SlColorPicker.prototype, "brightness", 2);
__decorateClass$e([
  r$3()
], SlColorPicker.prototype, "alpha", 2);
__decorateClass$e([
  n$1()
], SlColorPicker.prototype, "value", 2);
__decorateClass$e([
  defaultValue()
], SlColorPicker.prototype, "defaultValue", 2);
__decorateClass$e([
  n$1()
], SlColorPicker.prototype, "label", 2);
__decorateClass$e([
  n$1()
], SlColorPicker.prototype, "format", 2);
__decorateClass$e([
  n$1({ type: Boolean, reflect: !0 })
], SlColorPicker.prototype, "inline", 2);
__decorateClass$e([
  n$1({ reflect: !0 })
], SlColorPicker.prototype, "size", 2);
__decorateClass$e([
  n$1({ attribute: "no-format-toggle", type: Boolean })
], SlColorPicker.prototype, "noFormatToggle", 2);
__decorateClass$e([
  n$1()
], SlColorPicker.prototype, "name", 2);
__decorateClass$e([
  n$1({ type: Boolean, reflect: !0 })
], SlColorPicker.prototype, "disabled", 2);
__decorateClass$e([
  n$1({ type: Boolean })
], SlColorPicker.prototype, "hoist", 2);
__decorateClass$e([
  n$1({ type: Boolean })
], SlColorPicker.prototype, "opacity", 2);
__decorateClass$e([
  n$1({ type: Boolean })
], SlColorPicker.prototype, "uppercase", 2);
__decorateClass$e([
  n$1()
], SlColorPicker.prototype, "swatches", 2);
__decorateClass$e([
  n$1({ reflect: !0 })
], SlColorPicker.prototype, "form", 2);
__decorateClass$e([
  n$1({ type: Boolean, reflect: !0 })
], SlColorPicker.prototype, "required", 2);
__decorateClass$e([
  t$3({ passive: !1 })
], SlColorPicker.prototype, "handleTouchMove", 1);
__decorateClass$e([
  watch("format", { waitUntilFirstUpdate: !0 })
], SlColorPicker.prototype, "handleFormatChange", 1);
__decorateClass$e([
  watch("opacity", { waitUntilFirstUpdate: !0 })
], SlColorPicker.prototype, "handleOpacityChange", 1);
__decorateClass$e([
  watch("value")
], SlColorPicker.prototype, "handleValueChange", 1);
SlColorPicker.define("sl-color-picker");
var card_styles_default = i$5`
  :host {
    --border-color: var(--sl-color-neutral-200);
    --border-radius: var(--sl-border-radius-medium);
    --border-width: 1px;
    --padding: var(--sl-spacing-large);

    display: inline-block;
  }

  .card {
    display: flex;
    flex-direction: column;
    background-color: var(--sl-panel-background-color);
    box-shadow: var(--sl-shadow-x-small);
    border: solid var(--border-width) var(--border-color);
    border-radius: var(--border-radius);
  }

  .card__image {
    display: flex;
    border-top-left-radius: var(--border-radius);
    border-top-right-radius: var(--border-radius);
    margin: calc(-1 * var(--border-width));
    overflow: hidden;
  }

  .card__image::slotted(img) {
    display: block;
    width: 100%;
  }

  .card:not(.card--has-image) .card__image {
    display: none;
  }

  .card__header {
    display: block;
    border-bottom: solid var(--border-width) var(--border-color);
    padding: calc(var(--padding) / 2) var(--padding);
  }

  .card:not(.card--has-header) .card__header {
    display: none;
  }

  .card:not(.card--has-image) .card__header {
    border-top-left-radius: var(--border-radius);
    border-top-right-radius: var(--border-radius);
  }

  .card__body {
    display: block;
    padding: var(--padding);
  }

  .card--has-footer .card__footer {
    display: block;
    border-top: solid var(--border-width) var(--border-color);
    padding: var(--padding);
  }

  .card:not(.card--has-footer) .card__footer {
    display: none;
  }
`, SlCard = class extends ShoelaceElement {
  constructor() {
    super(...arguments), this.hasSlotController = new HasSlotController(this, "footer", "header", "image");
  }
  render() {
    return ke$1`
      <div
        part="base"
        class=${Rt({
      card: !0,
      "card--has-footer": this.hasSlotController.test("footer"),
      "card--has-image": this.hasSlotController.test("image"),
      "card--has-header": this.hasSlotController.test("header")
    })}
      >
        <slot name="image" part="image" class="card__image"></slot>
        <slot name="header" part="header" class="card__header"></slot>
        <slot part="body" class="card__body"></slot>
        <slot name="footer" part="footer" class="card__footer"></slot>
      </div>
    `;
  }
};
SlCard.styles = [component_styles_default, card_styles_default];
SlCard.define("sl-card");
var AutoplayController = class {
  constructor(C, L) {
    this.timerId = 0, this.activeInteractions = 0, this.paused = !1, this.stopped = !0, this.pause = () => {
      this.activeInteractions++ || (this.paused = !0, this.host.requestUpdate());
    }, this.resume = () => {
      --this.activeInteractions || (this.paused = !1, this.host.requestUpdate());
    }, C.addController(this), this.host = C, this.tickCallback = L;
  }
  hostConnected() {
    this.host.addEventListener("mouseenter", this.pause), this.host.addEventListener("mouseleave", this.resume), this.host.addEventListener("focusin", this.pause), this.host.addEventListener("focusout", this.resume), this.host.addEventListener("touchstart", this.pause, { passive: !0 }), this.host.addEventListener("touchend", this.resume);
  }
  hostDisconnected() {
    this.stop(), this.host.removeEventListener("mouseenter", this.pause), this.host.removeEventListener("mouseleave", this.resume), this.host.removeEventListener("focusin", this.pause), this.host.removeEventListener("focusout", this.resume), this.host.removeEventListener("touchstart", this.pause), this.host.removeEventListener("touchend", this.resume);
  }
  start(C) {
    this.stop(), this.stopped = !1, this.timerId = window.setInterval(() => {
      this.paused || this.tickCallback();
    }, C);
  }
  stop() {
    clearInterval(this.timerId), this.stopped = !0, this.host.requestUpdate();
  }
}, carousel_styles_default = i$5`
  :host {
    --slide-gap: var(--sl-spacing-medium, 1rem);
    --aspect-ratio: 16 / 9;
    --scroll-hint: 0px;

    display: flex;
  }

  .carousel {
    display: grid;
    grid-template-columns: min-content 1fr min-content;
    grid-template-rows: 1fr min-content;
    grid-template-areas:
      '. slides .'
      '. pagination .';
    gap: var(--sl-spacing-medium);
    align-items: center;
    min-height: 100%;
    min-width: 100%;
    position: relative;
  }

  .carousel__pagination {
    grid-area: pagination;
    display: flex;
    flex-wrap: wrap;
    justify-content: center;
    gap: var(--sl-spacing-small);
  }

  .carousel__slides {
    grid-area: slides;

    display: grid;
    height: 100%;
    width: 100%;
    align-items: center;
    justify-items: center;
    overflow: auto;
    overscroll-behavior-x: contain;
    scrollbar-width: none;
    aspect-ratio: calc(var(--aspect-ratio) * var(--slides-per-page));
    border-radius: var(--sl-border-radius-small);

    --slide-size: calc((100% - (var(--slides-per-page) - 1) * var(--slide-gap)) / var(--slides-per-page));
  }

  @media (prefers-reduced-motion) {
    :where(.carousel__slides) {
      scroll-behavior: auto;
    }
  }

  .carousel__slides--horizontal {
    grid-auto-flow: column;
    grid-auto-columns: var(--slide-size);
    grid-auto-rows: 100%;
    column-gap: var(--slide-gap);
    scroll-snap-type: x mandatory;
    scroll-padding-inline: var(--scroll-hint);
    padding-inline: var(--scroll-hint);
    overflow-y: hidden;
  }

  .carousel__slides--vertical {
    grid-auto-flow: row;
    grid-auto-columns: 100%;
    grid-auto-rows: var(--slide-size);
    row-gap: var(--slide-gap);
    scroll-snap-type: y mandatory;
    scroll-padding-block: var(--scroll-hint);
    padding-block: var(--scroll-hint);
    overflow-x: hidden;
  }

  .carousel__slides--dragging {
  }

  :host([vertical]) ::slotted(sl-carousel-item) {
    height: 100%;
  }

  .carousel__slides::-webkit-scrollbar {
    display: none;
  }

  .carousel__navigation {
    grid-area: navigation;
    display: contents;
    font-size: var(--sl-font-size-x-large);
  }

  .carousel__navigation-button {
    flex: 0 0 auto;
    display: flex;
    align-items: center;
    background: none;
    border: none;
    border-radius: var(--sl-border-radius-small);
    font-size: inherit;
    color: var(--sl-color-neutral-600);
    padding: var(--sl-spacing-x-small);
    cursor: pointer;
    transition: var(--sl-transition-medium) color;
    appearance: none;
  }

  .carousel__navigation-button--disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }

  .carousel__navigation-button--disabled::part(base) {
    pointer-events: none;
  }

  .carousel__navigation-button--previous {
    grid-column: 1;
    grid-row: 1;
  }

  .carousel__navigation-button--next {
    grid-column: 3;
    grid-row: 1;
  }

  .carousel__pagination-item {
    display: block;
    cursor: pointer;
    background: none;
    border: 0;
    border-radius: var(--sl-border-radius-circle);
    width: var(--sl-spacing-small);
    height: var(--sl-spacing-small);
    background-color: var(--sl-color-neutral-300);
    padding: 0;
    margin: 0;
  }

  .carousel__pagination-item--active {
    background-color: var(--sl-color-neutral-700);
    transform: scale(1.2);
  }

  /* Focus styles */
  .carousel__slides:focus-visible,
  .carousel__navigation-button:focus-visible,
  .carousel__pagination-item:focus-visible {
    outline: var(--sl-focus-ring);
    outline-offset: var(--sl-focus-ring-offset);
  }
`;
/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
function* oo$1(C, L) {
  if (C !== void 0) {
    let A = 0;
    for (const W of C) yield L(W, A++);
  }
}
/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
function* oo(C, L, A = 1) {
  const W = L === void 0 ? 0 : C;
  L ?? (L = C);
  for (let X = W; A > 0 ? X < L : L < X; X += A) yield X;
}
var debounce = (C, L) => {
  let A = 0;
  return function(...W) {
    window.clearTimeout(A), A = window.setTimeout(() => {
      C.call(this, ...W);
    }, L);
  };
}, decorate = (C, L, A) => {
  const W = C[L];
  C[L] = function(...X) {
    W.call(this, ...X), A.call(this, W, ...X);
  };
}, isSupported = "onscrollend" in window;
if (!isSupported) {
  const C = /* @__PURE__ */ new Set(), L = /* @__PURE__ */ new WeakMap(), A = (X) => {
    for (const J of X.changedTouches)
      C.add(J.identifier);
  }, W = (X) => {
    for (const J of X.changedTouches)
      C.delete(J.identifier);
  };
  document.addEventListener("touchstart", A, !0), document.addEventListener("touchend", W, !0), document.addEventListener("touchcancel", W, !0), decorate(EventTarget.prototype, "addEventListener", function(X, J) {
    if (J !== "scrollend")
      return;
    const te = debounce(() => {
      C.size ? te() : this.dispatchEvent(new Event("scrollend"));
    }, 100);
    X.call(this, "scroll", te, { passive: !0 }), L.set(this, te);
  }), decorate(EventTarget.prototype, "removeEventListener", function(X, J) {
    if (J !== "scrollend")
      return;
    const te = L.get(this);
    te && X.call(this, "scroll", te, { passive: !0 });
  });
}
var SlCarousel = class extends ShoelaceElement {
  constructor() {
    super(...arguments), this.loop = !1, this.navigation = !1, this.pagination = !1, this.autoplay = !1, this.autoplayInterval = 3e3, this.slidesPerPage = 1, this.slidesPerMove = 1, this.orientation = "horizontal", this.mouseDragging = !1, this.activeSlide = 0, this.scrolling = !1, this.dragging = !1, this.autoplayController = new AutoplayController(this, () => this.next()), this.localize = new LocalizeController(this), this.handleMouseDrag = (C) => {
      this.dragging || (this.scrollContainer.style.setProperty("scroll-snap-type", "none"), this.dragging = !0), this.scrollContainer.scrollBy({
        left: -C.movementX,
        top: -C.movementY,
        behavior: "instant"
      });
    }, this.handleMouseDragEnd = () => {
      const C = this.scrollContainer;
      document.removeEventListener("pointermove", this.handleMouseDrag, { capture: !0 });
      const L = C.scrollLeft, A = C.scrollTop;
      C.style.removeProperty("scroll-snap-type"), C.style.setProperty("overflow", "hidden");
      const W = C.scrollLeft, X = C.scrollTop;
      C.style.removeProperty("overflow"), C.style.setProperty("scroll-snap-type", "none"), C.scrollTo({ left: L, top: A, behavior: "instant" }), requestAnimationFrame(async () => {
        (L !== W || A !== X) && (C.scrollTo({
          left: W,
          top: X,
          behavior: prefersReducedMotion() ? "auto" : "smooth"
        }), await waitForEvent(C, "scrollend")), C.style.removeProperty("scroll-snap-type"), this.dragging = !1, this.handleScrollEnd();
      });
    }, this.handleSlotChange = (C) => {
      C.some(
        (A) => [...A.addedNodes, ...A.removedNodes].some(
          (W) => this.isCarouselItem(W) && !W.hasAttribute("data-clone")
        )
      ) && this.initializeSlides(), this.requestUpdate();
    };
  }
  connectedCallback() {
    super.connectedCallback(), this.setAttribute("role", "region"), this.setAttribute("aria-label", this.localize.term("carousel"));
  }
  disconnectedCallback() {
    super.disconnectedCallback(), this.mutationObserver.disconnect();
  }
  firstUpdated() {
    this.initializeSlides(), this.mutationObserver = new MutationObserver(this.handleSlotChange), this.mutationObserver.observe(this, {
      childList: !0,
      subtree: !0
    });
  }
  willUpdate(C) {
    (C.has("slidesPerMove") || C.has("slidesPerPage")) && (this.slidesPerMove = Math.min(this.slidesPerMove, this.slidesPerPage));
  }
  getPageCount() {
    const C = this.getSlides().length, { slidesPerPage: L, slidesPerMove: A, loop: W } = this, X = W ? C / A : (C - L) / A + 1;
    return Math.ceil(X);
  }
  getCurrentPage() {
    return Math.ceil(this.activeSlide / this.slidesPerMove);
  }
  canScrollNext() {
    return this.loop || this.getCurrentPage() < this.getPageCount() - 1;
  }
  canScrollPrev() {
    return this.loop || this.getCurrentPage() > 0;
  }
  /** @internal Gets all carousel items. */
  getSlides({ excludeClones: C = !0 } = {}) {
    return [...this.children].filter(
      (L) => this.isCarouselItem(L) && (!C || !L.hasAttribute("data-clone"))
    );
  }
  handleKeyDown(C) {
    if (["ArrowLeft", "ArrowRight", "ArrowUp", "ArrowDown", "Home", "End"].includes(C.key)) {
      const L = C.target, A = this.matches(":dir(rtl)"), W = L.closest('[part~="pagination-item"]') !== null, X = C.key === "ArrowDown" || !A && C.key === "ArrowRight" || A && C.key === "ArrowLeft", J = C.key === "ArrowUp" || !A && C.key === "ArrowLeft" || A && C.key === "ArrowRight";
      C.preventDefault(), J && this.previous(), X && this.next(), C.key === "Home" && this.goToSlide(0), C.key === "End" && this.goToSlide(this.getSlides().length - 1), W && this.updateComplete.then(() => {
        var te;
        const oe = (te = this.shadowRoot) == null ? void 0 : te.querySelector(
          '[part~="pagination-item--active"]'
        );
        oe && oe.focus();
      });
    }
  }
  handleMouseDragStart(C) {
    this.mouseDragging && C.button === 0 && (C.preventDefault(), document.addEventListener("pointermove", this.handleMouseDrag, { capture: !0, passive: !0 }), document.addEventListener("pointerup", this.handleMouseDragEnd, { capture: !0, once: !0 }));
  }
  handleScroll() {
    this.scrolling = !0;
  }
  /** @internal Synchronizes the slides with the IntersectionObserver API. */
  synchronizeSlides() {
    const C = new IntersectionObserver(
      (L) => {
        C.disconnect();
        for (const W of L) {
          const X = W.target;
          X.toggleAttribute("inert", !W.isIntersecting), X.classList.toggle("--in-view", W.isIntersecting), X.setAttribute("aria-hidden", W.isIntersecting ? "false" : "true");
        }
        const A = L.find((W) => W.isIntersecting);
        if (A)
          if (this.loop && A.target.hasAttribute("data-clone")) {
            const W = Number(A.target.getAttribute("data-clone"));
            this.goToSlide(W, "instant");
          } else {
            const X = this.getSlides().indexOf(A.target);
            this.activeSlide = Math.ceil(X / this.slidesPerMove) * this.slidesPerMove;
          }
      },
      {
        root: this.scrollContainer,
        threshold: 0.6
      }
    );
    this.getSlides({ excludeClones: !1 }).forEach((L) => {
      C.observe(L);
    });
  }
  handleScrollEnd() {
    !this.scrolling || this.dragging || (this.synchronizeSlides(), this.scrolling = !1);
  }
  isCarouselItem(C) {
    return C instanceof Element && C.tagName.toLowerCase() === "sl-carousel-item";
  }
  initializeSlides() {
    this.getSlides({ excludeClones: !1 }).forEach((C, L) => {
      C.classList.remove("--in-view"), C.classList.remove("--is-active"), C.setAttribute("aria-label", this.localize.term("slideNum", L + 1)), C.hasAttribute("data-clone") && C.remove();
    }), this.updateSlidesSnap(), this.loop && this.createClones(), this.synchronizeSlides(), this.goToSlide(this.activeSlide, "auto");
  }
  createClones() {
    const C = this.getSlides(), L = this.slidesPerPage, A = C.slice(-L), W = C.slice(0, L);
    A.reverse().forEach((X, J) => {
      const te = X.cloneNode(!0);
      te.setAttribute("data-clone", String(C.length - J - 1)), this.prepend(te);
    }), W.forEach((X, J) => {
      const te = X.cloneNode(!0);
      te.setAttribute("data-clone", String(J)), this.append(te);
    });
  }
  handelSlideChange() {
    const C = this.getSlides();
    C.forEach((L, A) => {
      L.classList.toggle("--is-active", A === this.activeSlide);
    }), this.hasUpdated && this.emit("sl-slide-change", {
      detail: {
        index: this.activeSlide,
        slide: C[this.activeSlide]
      }
    });
  }
  updateSlidesSnap() {
    const C = this.getSlides(), L = this.slidesPerMove;
    C.forEach((A, W) => {
      (W + L) % L === 0 ? A.style.removeProperty("scroll-snap-align") : A.style.setProperty("scroll-snap-align", "none");
    });
  }
  handleAutoplayChange() {
    this.autoplayController.stop(), this.autoplay && this.autoplayController.start(this.autoplayInterval);
  }
  /**
   * Move the carousel backward by `slides-per-move` slides.
   *
   * @param behavior - The behavior used for scrolling.
   */
  previous(C = "smooth") {
    this.goToSlide(this.activeSlide - this.slidesPerMove, C);
  }
  /**
   * Move the carousel forward by `slides-per-move` slides.
   *
   * @param behavior - The behavior used for scrolling.
   */
  next(C = "smooth") {
    this.goToSlide(this.activeSlide + this.slidesPerMove, C);
  }
  /**
   * Scrolls the carousel to the slide specified by `index`.
   *
   * @param index - The slide index.
   * @param behavior - The behavior used for scrolling.
   */
  goToSlide(C, L = "smooth") {
    const { slidesPerPage: A, loop: W } = this, X = this.getSlides(), J = this.getSlides({ excludeClones: !1 });
    if (!X.length)
      return;
    const te = W ? (C + X.length) % X.length : clamp(C, 0, X.length - 1);
    this.activeSlide = te;
    const oe = clamp(C + (W ? A : 0), 0, J.length - 1), ne = J[oe];
    this.scrollToSlide(ne, prefersReducedMotion() ? "auto" : L);
  }
  scrollToSlide(C, L = "smooth") {
    const A = this.scrollContainer, W = A.getBoundingClientRect(), X = C.getBoundingClientRect(), J = X.left - W.left, te = X.top - W.top;
    A.scrollTo({
      left: J + A.scrollLeft,
      top: te + A.scrollTop,
      behavior: L
    });
  }
  render() {
    const { slidesPerMove: C, scrolling: L } = this, A = this.getPageCount(), W = this.getCurrentPage(), X = this.canScrollPrev(), J = this.canScrollNext(), te = this.matches(":dir(ltr)");
    return ke$1`
      <div part="base" class="carousel">
        <div
          id="scroll-container"
          part="scroll-container"
          class="${Rt({
      carousel__slides: !0,
      "carousel__slides--horizontal": this.orientation === "horizontal",
      "carousel__slides--vertical": this.orientation === "vertical",
      "carousel__slides--dragging": this.dragging
    })}"
          style="--slides-per-page: ${this.slidesPerPage};"
          aria-busy="${L ? "true" : "false"}"
          aria-atomic="true"
          tabindex="0"
          @keydown=${this.handleKeyDown}
          @mousedown="${this.handleMouseDragStart}"
          @scroll="${this.handleScroll}"
          @scrollend=${this.handleScrollEnd}
        >
          <slot></slot>
        </div>

        ${this.navigation ? ke$1`
              <div part="navigation" class="carousel__navigation">
                <button
                  part="navigation-button navigation-button--previous"
                  class="${Rt({
      "carousel__navigation-button": !0,
      "carousel__navigation-button--previous": !0,
      "carousel__navigation-button--disabled": !X
    })}"
                  aria-label="${this.localize.term("previousSlide")}"
                  aria-controls="scroll-container"
                  aria-disabled="${X ? "false" : "true"}"
                  @click=${X ? () => this.previous() : null}
                >
                  <slot name="previous-icon">
                    <sl-icon library="system" name="${te ? "chevron-left" : "chevron-right"}"></sl-icon>
                  </slot>
                </button>

                <button
                  part="navigation-button navigation-button--next"
                  class=${Rt({
      "carousel__navigation-button": !0,
      "carousel__navigation-button--next": !0,
      "carousel__navigation-button--disabled": !J
    })}
                  aria-label="${this.localize.term("nextSlide")}"
                  aria-controls="scroll-container"
                  aria-disabled="${J ? "false" : "true"}"
                  @click=${J ? () => this.next() : null}
                >
                  <slot name="next-icon">
                    <sl-icon library="system" name="${te ? "chevron-right" : "chevron-left"}"></sl-icon>
                  </slot>
                </button>
              </div>
            ` : ""}
        ${this.pagination ? ke$1`
              <div part="pagination" role="tablist" class="carousel__pagination" aria-controls="scroll-container">
                ${oo$1(oo(A), (oe) => {
      const ne = oe === W;
      return ke$1`
                    <button
                      part="pagination-item ${ne ? "pagination-item--active" : ""}"
                      class="${Rt({
        "carousel__pagination-item": !0,
        "carousel__pagination-item--active": ne
      })}"
                      role="tab"
                      aria-selected="${ne ? "true" : "false"}"
                      aria-label="${this.localize.term("goToSlide", oe + 1, A)}"
                      tabindex=${ne ? "0" : "-1"}
                      @click=${() => this.goToSlide(oe * C)}
                      @keydown=${this.handleKeyDown}
                    ></button>
                  `;
    })}
              </div>
            ` : ""}
      </div>
    `;
  }
};
SlCarousel.styles = [component_styles_default, carousel_styles_default];
SlCarousel.dependencies = { "sl-icon": SlIcon };
__decorateClass$e([
  n$1({ type: Boolean, reflect: !0 })
], SlCarousel.prototype, "loop", 2);
__decorateClass$e([
  n$1({ type: Boolean, reflect: !0 })
], SlCarousel.prototype, "navigation", 2);
__decorateClass$e([
  n$1({ type: Boolean, reflect: !0 })
], SlCarousel.prototype, "pagination", 2);
__decorateClass$e([
  n$1({ type: Boolean, reflect: !0 })
], SlCarousel.prototype, "autoplay", 2);
__decorateClass$e([
  n$1({ type: Number, attribute: "autoplay-interval" })
], SlCarousel.prototype, "autoplayInterval", 2);
__decorateClass$e([
  n$1({ type: Number, attribute: "slides-per-page" })
], SlCarousel.prototype, "slidesPerPage", 2);
__decorateClass$e([
  n$1({ type: Number, attribute: "slides-per-move" })
], SlCarousel.prototype, "slidesPerMove", 2);
__decorateClass$e([
  n$1()
], SlCarousel.prototype, "orientation", 2);
__decorateClass$e([
  n$1({ type: Boolean, reflect: !0, attribute: "mouse-dragging" })
], SlCarousel.prototype, "mouseDragging", 2);
__decorateClass$e([
  e$6(".carousel__slides")
], SlCarousel.prototype, "scrollContainer", 2);
__decorateClass$e([
  e$6(".carousel__pagination")
], SlCarousel.prototype, "paginationContainer", 2);
__decorateClass$e([
  r$3()
], SlCarousel.prototype, "activeSlide", 2);
__decorateClass$e([
  r$3()
], SlCarousel.prototype, "scrolling", 2);
__decorateClass$e([
  r$3()
], SlCarousel.prototype, "dragging", 2);
__decorateClass$e([
  t$3({ passive: !0 })
], SlCarousel.prototype, "handleScroll", 1);
__decorateClass$e([
  watch("loop", { waitUntilFirstUpdate: !0 }),
  watch("slidesPerPage", { waitUntilFirstUpdate: !0 })
], SlCarousel.prototype, "initializeSlides", 1);
__decorateClass$e([
  watch("activeSlide")
], SlCarousel.prototype, "handelSlideChange", 1);
__decorateClass$e([
  watch("slidesPerMove")
], SlCarousel.prototype, "updateSlidesSnap", 1);
__decorateClass$e([
  watch("autoplay")
], SlCarousel.prototype, "handleAutoplayChange", 1);
SlCarousel.define("sl-carousel");
var carousel_item_styles_default = i$5`
  :host {
    --aspect-ratio: inherit;

    display: flex;
    align-items: center;
    justify-content: center;
    flex-direction: column;
    width: 100%;
    max-height: 100%;
    aspect-ratio: var(--aspect-ratio);
    scroll-snap-align: start;
    scroll-snap-stop: always;
  }

  ::slotted(img) {
    width: 100% !important;
    height: 100% !important;
    object-fit: cover;
  }
`, SlCarouselItem = class extends ShoelaceElement {
  connectedCallback() {
    super.connectedCallback(), this.setAttribute("role", "group");
  }
  render() {
    return ke$1` <slot></slot> `;
  }
};
SlCarouselItem.styles = [component_styles_default, carousel_item_styles_default];
SlCarouselItem.define("sl-carousel-item");
SlButton.define("sl-button");
SlButtonGroup.define("sl-button-group");
var breadcrumb_styles_default = i$5`
  .breadcrumb {
    display: flex;
    align-items: center;
    flex-wrap: wrap;
  }
`, SlBreadcrumb = class extends ShoelaceElement {
  constructor() {
    super(...arguments), this.localize = new LocalizeController(this), this.separatorDir = this.localize.dir(), this.label = "";
  }
  // Generates a clone of the separator element to use for each breadcrumb item
  getSeparator() {
    const L = this.separatorSlot.assignedElements({ flatten: !0 })[0].cloneNode(!0);
    return [L, ...L.querySelectorAll("[id]")].forEach((A) => A.removeAttribute("id")), L.setAttribute("data-default", ""), L.slot = "separator", L;
  }
  handleSlotChange() {
    const C = [...this.defaultSlot.assignedElements({ flatten: !0 })].filter(
      (L) => L.tagName.toLowerCase() === "sl-breadcrumb-item"
    );
    C.forEach((L, A) => {
      const W = L.querySelector('[slot="separator"]');
      W === null ? L.append(this.getSeparator()) : W.hasAttribute("data-default") && W.replaceWith(this.getSeparator()), A === C.length - 1 ? L.setAttribute("aria-current", "page") : L.removeAttribute("aria-current");
    });
  }
  render() {
    return this.separatorDir !== this.localize.dir() && (this.separatorDir = this.localize.dir(), this.updateComplete.then(() => this.handleSlotChange())), ke$1`
      <nav part="base" class="breadcrumb" aria-label=${this.label}>
        <slot @slotchange=${this.handleSlotChange}></slot>
      </nav>

      <span hidden aria-hidden="true">
        <slot name="separator">
          <sl-icon name=${this.localize.dir() === "rtl" ? "chevron-left" : "chevron-right"} library="system"></sl-icon>
        </slot>
      </span>
    `;
  }
};
SlBreadcrumb.styles = [component_styles_default, breadcrumb_styles_default];
SlBreadcrumb.dependencies = { "sl-icon": SlIcon };
__decorateClass$e([
  e$6("slot")
], SlBreadcrumb.prototype, "defaultSlot", 2);
__decorateClass$e([
  e$6('slot[name="separator"]')
], SlBreadcrumb.prototype, "separatorSlot", 2);
__decorateClass$e([
  n$1()
], SlBreadcrumb.prototype, "label", 2);
SlBreadcrumb.define("sl-breadcrumb");
var badge_styles_default = i$5`
  :host {
    display: inline-flex;
  }

  .badge {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    font-size: max(12px, 0.75em);
    font-weight: var(--sl-font-weight-semibold);
    letter-spacing: var(--sl-letter-spacing-normal);
    line-height: 1;
    border-radius: var(--sl-border-radius-small);
    border: solid 1px var(--sl-color-neutral-0);
    white-space: nowrap;
    padding: 0.35em 0.6em;
    user-select: none;
    -webkit-user-select: none;
    cursor: inherit;
  }

  /* Variant modifiers */
  .badge--primary {
    background-color: var(--sl-color-primary-600);
    color: var(--sl-color-neutral-0);
  }

  .badge--success {
    background-color: var(--sl-color-success-600);
    color: var(--sl-color-neutral-0);
  }

  .badge--neutral {
    background-color: var(--sl-color-neutral-600);
    color: var(--sl-color-neutral-0);
  }

  .badge--warning {
    background-color: var(--sl-color-warning-600);
    color: var(--sl-color-neutral-0);
  }

  .badge--danger {
    background-color: var(--sl-color-danger-600);
    color: var(--sl-color-neutral-0);
  }

  /* Pill modifier */
  .badge--pill {
    border-radius: var(--sl-border-radius-pill);
  }

  /* Pulse modifier */
  .badge--pulse {
    animation: pulse 1.5s infinite;
  }

  .badge--pulse.badge--primary {
    --pulse-color: var(--sl-color-primary-600);
  }

  .badge--pulse.badge--success {
    --pulse-color: var(--sl-color-success-600);
  }

  .badge--pulse.badge--neutral {
    --pulse-color: var(--sl-color-neutral-600);
  }

  .badge--pulse.badge--warning {
    --pulse-color: var(--sl-color-warning-600);
  }

  .badge--pulse.badge--danger {
    --pulse-color: var(--sl-color-danger-600);
  }

  @keyframes pulse {
    0% {
      box-shadow: 0 0 0 0 var(--pulse-color);
    }
    70% {
      box-shadow: 0 0 0 0.5rem transparent;
    }
    100% {
      box-shadow: 0 0 0 0 transparent;
    }
  }
`, SlBadge = class extends ShoelaceElement {
  constructor() {
    super(...arguments), this.variant = "primary", this.pill = !1, this.pulse = !1;
  }
  render() {
    return ke$1`
      <span
        part="base"
        class=${Rt({
      badge: !0,
      "badge--primary": this.variant === "primary",
      "badge--success": this.variant === "success",
      "badge--neutral": this.variant === "neutral",
      "badge--warning": this.variant === "warning",
      "badge--danger": this.variant === "danger",
      "badge--pill": this.pill,
      "badge--pulse": this.pulse
    })}
        role="status"
      >
        <slot></slot>
      </span>
    `;
  }
};
SlBadge.styles = [component_styles_default, badge_styles_default];
__decorateClass$e([
  n$1({ reflect: !0 })
], SlBadge.prototype, "variant", 2);
__decorateClass$e([
  n$1({ type: Boolean, reflect: !0 })
], SlBadge.prototype, "pill", 2);
__decorateClass$e([
  n$1({ type: Boolean, reflect: !0 })
], SlBadge.prototype, "pulse", 2);
SlBadge.define("sl-badge");
var breadcrumb_item_styles_default = i$5`
  :host {
    display: inline-flex;
  }

  .breadcrumb-item {
    display: inline-flex;
    align-items: center;
    font-family: var(--sl-font-sans);
    font-size: var(--sl-font-size-small);
    font-weight: var(--sl-font-weight-semibold);
    color: var(--sl-color-neutral-600);
    line-height: var(--sl-line-height-normal);
    white-space: nowrap;
  }

  .breadcrumb-item__label {
    display: inline-block;
    font-family: inherit;
    font-size: inherit;
    font-weight: inherit;
    line-height: inherit;
    text-decoration: none;
    color: inherit;
    background: none;
    border: none;
    border-radius: var(--sl-border-radius-medium);
    padding: 0;
    margin: 0;
    cursor: pointer;
    transition: var(--sl-transition-fast) --color;
  }

  :host(:not(:last-of-type)) .breadcrumb-item__label {
    color: var(--sl-color-primary-600);
  }

  :host(:not(:last-of-type)) .breadcrumb-item__label:hover {
    color: var(--sl-color-primary-500);
  }

  :host(:not(:last-of-type)) .breadcrumb-item__label:active {
    color: var(--sl-color-primary-600);
  }

  .breadcrumb-item__label:focus {
    outline: none;
  }

  .breadcrumb-item__label:focus-visible {
    outline: var(--sl-focus-ring);
    outline-offset: var(--sl-focus-ring-offset);
  }

  .breadcrumb-item__prefix,
  .breadcrumb-item__suffix {
    display: none;
    flex: 0 0 auto;
    display: flex;
    align-items: center;
  }

  .breadcrumb-item--has-prefix .breadcrumb-item__prefix {
    display: inline-flex;
    margin-inline-end: var(--sl-spacing-x-small);
  }

  .breadcrumb-item--has-suffix .breadcrumb-item__suffix {
    display: inline-flex;
    margin-inline-start: var(--sl-spacing-x-small);
  }

  :host(:last-of-type) .breadcrumb-item__separator {
    display: none;
  }

  .breadcrumb-item__separator {
    display: inline-flex;
    align-items: center;
    margin: 0 var(--sl-spacing-x-small);
    user-select: none;
    -webkit-user-select: none;
  }
`, SlBreadcrumbItem = class extends ShoelaceElement {
  constructor() {
    super(...arguments), this.hasSlotController = new HasSlotController(this, "prefix", "suffix"), this.rel = "noreferrer noopener";
  }
  render() {
    const C = !!this.href;
    return ke$1`
      <div
        part="base"
        class=${Rt({
      "breadcrumb-item": !0,
      "breadcrumb-item--has-prefix": this.hasSlotController.test("prefix"),
      "breadcrumb-item--has-suffix": this.hasSlotController.test("suffix")
    })}
      >
        <span part="prefix" class="breadcrumb-item__prefix">
          <slot name="prefix"></slot>
        </span>

        ${C ? ke$1`
              <a
                part="label"
                class="breadcrumb-item__label breadcrumb-item__label--link"
                href="${this.href}"
                target="${to(this.target ? this.target : void 0)}"
                rel=${to(this.target ? this.rel : void 0)}
              >
                <slot></slot>
              </a>
            ` : ke$1`
              <button part="label" type="button" class="breadcrumb-item__label breadcrumb-item__label--button">
                <slot></slot>
              </button>
            `}

        <span part="suffix" class="breadcrumb-item__suffix">
          <slot name="suffix"></slot>
        </span>

        <span part="separator" class="breadcrumb-item__separator" aria-hidden="true">
          <slot name="separator"></slot>
        </span>
      </div>
    `;
  }
};
SlBreadcrumbItem.styles = [component_styles_default, breadcrumb_item_styles_default];
__decorateClass$e([
  n$1()
], SlBreadcrumbItem.prototype, "href", 2);
__decorateClass$e([
  n$1()
], SlBreadcrumbItem.prototype, "target", 2);
__decorateClass$e([
  n$1()
], SlBreadcrumbItem.prototype, "rel", 2);
SlBreadcrumbItem.define("sl-breadcrumb-item");
var avatar_styles_default = i$5`
  :host {
    display: inline-block;

    --size: 3rem;
  }

  .avatar {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    position: relative;
    width: var(--size);
    height: var(--size);
    background-color: var(--sl-color-neutral-400);
    font-family: var(--sl-font-sans);
    font-size: calc(var(--size) * 0.5);
    font-weight: var(--sl-font-weight-normal);
    color: var(--sl-color-neutral-0);
    user-select: none;
    -webkit-user-select: none;
    vertical-align: middle;
  }

  .avatar--circle,
  .avatar--circle .avatar__image {
    border-radius: var(--sl-border-radius-circle);
  }

  .avatar--rounded,
  .avatar--rounded .avatar__image {
    border-radius: var(--sl-border-radius-medium);
  }

  .avatar--square {
    border-radius: 0;
  }

  .avatar__icon {
    display: flex;
    align-items: center;
    justify-content: center;
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
  }

  .avatar__initials {
    line-height: 1;
    text-transform: uppercase;
  }

  .avatar__image {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    object-fit: cover;
    overflow: hidden;
  }
`, SlAvatar = class extends ShoelaceElement {
  constructor() {
    super(...arguments), this.hasError = !1, this.image = "", this.label = "", this.initials = "", this.loading = "eager", this.shape = "circle";
  }
  handleImageChange() {
    this.hasError = !1;
  }
  handleImageLoadError() {
    this.hasError = !0, this.emit("sl-error");
  }
  render() {
    const C = ke$1`
      <img
        part="image"
        class="avatar__image"
        src="${this.image}"
        loading="${this.loading}"
        alt=""
        @error="${this.handleImageLoadError}"
      />
    `;
    let L = ke$1``;
    return this.initials ? L = ke$1`<div part="initials" class="avatar__initials">${this.initials}</div>` : L = ke$1`
        <div part="icon" class="avatar__icon" aria-hidden="true">
          <slot name="icon">
            <sl-icon name="person-fill" library="system"></sl-icon>
          </slot>
        </div>
      `, ke$1`
      <div
        part="base"
        class=${Rt({
      avatar: !0,
      "avatar--circle": this.shape === "circle",
      "avatar--rounded": this.shape === "rounded",
      "avatar--square": this.shape === "square"
    })}
        role="img"
        aria-label=${this.label}
      >
        ${this.image && !this.hasError ? C : L}
      </div>
    `;
  }
};
SlAvatar.styles = [component_styles_default, avatar_styles_default];
SlAvatar.dependencies = {
  "sl-icon": SlIcon
};
__decorateClass$e([
  r$3()
], SlAvatar.prototype, "hasError", 2);
__decorateClass$e([
  n$1()
], SlAvatar.prototype, "image", 2);
__decorateClass$e([
  n$1()
], SlAvatar.prototype, "label", 2);
__decorateClass$e([
  n$1()
], SlAvatar.prototype, "initials", 2);
__decorateClass$e([
  n$1()
], SlAvatar.prototype, "loading", 2);
__decorateClass$e([
  n$1({ reflect: !0 })
], SlAvatar.prototype, "shape", 2);
__decorateClass$e([
  watch("image")
], SlAvatar.prototype, "handleImageChange", 1);
SlAvatar.define("sl-avatar");
var animation_styles_default = i$5`
  :host {
    display: contents;
  }
`;
const bounce = [
  { offset: 0, easing: "cubic-bezier(0.215, 0.61, 0.355, 1)", transform: "translate3d(0, 0, 0)" },
  { offset: 0.2, easing: "cubic-bezier(0.215, 0.61, 0.355, 1)", transform: "translate3d(0, 0, 0)" },
  { offset: 0.4, easing: "cubic-bezier(0.755, 0.05, 0.855, 0.06)", transform: "translate3d(0, -30px, 0) scaleY(1.1)" },
  { offset: 0.43, easing: "cubic-bezier(0.755, 0.05, 0.855, 0.06)", transform: "translate3d(0, -30px, 0) scaleY(1.1)" },
  { offset: 0.53, easing: "cubic-bezier(0.215, 0.61, 0.355, 1)", transform: "translate3d(0, 0, 0)" },
  { offset: 0.7, easing: "cubic-bezier(0.755, 0.05, 0.855, 0.06)", transform: "translate3d(0, -15px, 0) scaleY(1.05)" },
  {
    offset: 0.8,
    "transition-timing-function": "cubic-bezier(0.215, 0.61, 0.355, 1)",
    transform: "translate3d(0, 0, 0) scaleY(0.95)"
  },
  { offset: 0.9, transform: "translate3d(0, -4px, 0) scaleY(1.02)" },
  { offset: 1, easing: "cubic-bezier(0.215, 0.61, 0.355, 1)", transform: "translate3d(0, 0, 0)" }
], flash = [
  { offset: 0, opacity: "1" },
  { offset: 0.25, opacity: "0" },
  { offset: 0.5, opacity: "1" },
  { offset: 0.75, opacity: "0" },
  { offset: 1, opacity: "1" }
], headShake = [
  { offset: 0, transform: "translateX(0)" },
  { offset: 0.065, transform: "translateX(-6px) rotateY(-9deg)" },
  { offset: 0.185, transform: "translateX(5px) rotateY(7deg)" },
  { offset: 0.315, transform: "translateX(-3px) rotateY(-5deg)" },
  { offset: 0.435, transform: "translateX(2px) rotateY(3deg)" },
  { offset: 0.5, transform: "translateX(0)" }
], heartBeat = [
  { offset: 0, transform: "scale(1)" },
  { offset: 0.14, transform: "scale(1.3)" },
  { offset: 0.28, transform: "scale(1)" },
  { offset: 0.42, transform: "scale(1.3)" },
  { offset: 0.7, transform: "scale(1)" }
], jello = [
  { offset: 0, transform: "translate3d(0, 0, 0)" },
  { offset: 0.111, transform: "translate3d(0, 0, 0)" },
  { offset: 0.222, transform: "skewX(-12.5deg) skewY(-12.5deg)" },
  { offset: 0.33299999999999996, transform: "skewX(6.25deg) skewY(6.25deg)" },
  { offset: 0.444, transform: "skewX(-3.125deg) skewY(-3.125deg)" },
  { offset: 0.555, transform: "skewX(1.5625deg) skewY(1.5625deg)" },
  { offset: 0.6659999999999999, transform: "skewX(-0.78125deg) skewY(-0.78125deg)" },
  { offset: 0.777, transform: "skewX(0.390625deg) skewY(0.390625deg)" },
  { offset: 0.888, transform: "skewX(-0.1953125deg) skewY(-0.1953125deg)" },
  { offset: 1, transform: "translate3d(0, 0, 0)" }
], pulse = [
  { offset: 0, transform: "scale3d(1, 1, 1)" },
  { offset: 0.5, transform: "scale3d(1.05, 1.05, 1.05)" },
  { offset: 1, transform: "scale3d(1, 1, 1)" }
], rubberBand = [
  { offset: 0, transform: "scale3d(1, 1, 1)" },
  { offset: 0.3, transform: "scale3d(1.25, 0.75, 1)" },
  { offset: 0.4, transform: "scale3d(0.75, 1.25, 1)" },
  { offset: 0.5, transform: "scale3d(1.15, 0.85, 1)" },
  { offset: 0.65, transform: "scale3d(0.95, 1.05, 1)" },
  { offset: 0.75, transform: "scale3d(1.05, 0.95, 1)" },
  { offset: 1, transform: "scale3d(1, 1, 1)" }
], shake = [
  { offset: 0, transform: "translate3d(0, 0, 0)" },
  { offset: 0.1, transform: "translate3d(-10px, 0, 0)" },
  { offset: 0.2, transform: "translate3d(10px, 0, 0)" },
  { offset: 0.3, transform: "translate3d(-10px, 0, 0)" },
  { offset: 0.4, transform: "translate3d(10px, 0, 0)" },
  { offset: 0.5, transform: "translate3d(-10px, 0, 0)" },
  { offset: 0.6, transform: "translate3d(10px, 0, 0)" },
  { offset: 0.7, transform: "translate3d(-10px, 0, 0)" },
  { offset: 0.8, transform: "translate3d(10px, 0, 0)" },
  { offset: 0.9, transform: "translate3d(-10px, 0, 0)" },
  { offset: 1, transform: "translate3d(0, 0, 0)" }
], shakeX = [
  { offset: 0, transform: "translate3d(0, 0, 0)" },
  { offset: 0.1, transform: "translate3d(-10px, 0, 0)" },
  { offset: 0.2, transform: "translate3d(10px, 0, 0)" },
  { offset: 0.3, transform: "translate3d(-10px, 0, 0)" },
  { offset: 0.4, transform: "translate3d(10px, 0, 0)" },
  { offset: 0.5, transform: "translate3d(-10px, 0, 0)" },
  { offset: 0.6, transform: "translate3d(10px, 0, 0)" },
  { offset: 0.7, transform: "translate3d(-10px, 0, 0)" },
  { offset: 0.8, transform: "translate3d(10px, 0, 0)" },
  { offset: 0.9, transform: "translate3d(-10px, 0, 0)" },
  { offset: 1, transform: "translate3d(0, 0, 0)" }
], shakeY = [
  { offset: 0, transform: "translate3d(0, 0, 0)" },
  { offset: 0.1, transform: "translate3d(0, -10px, 0)" },
  { offset: 0.2, transform: "translate3d(0, 10px, 0)" },
  { offset: 0.3, transform: "translate3d(0, -10px, 0)" },
  { offset: 0.4, transform: "translate3d(0, 10px, 0)" },
  { offset: 0.5, transform: "translate3d(0, -10px, 0)" },
  { offset: 0.6, transform: "translate3d(0, 10px, 0)" },
  { offset: 0.7, transform: "translate3d(0, -10px, 0)" },
  { offset: 0.8, transform: "translate3d(0, 10px, 0)" },
  { offset: 0.9, transform: "translate3d(0, -10px, 0)" },
  { offset: 1, transform: "translate3d(0, 0, 0)" }
], swing = [
  { offset: 0.2, transform: "rotate3d(0, 0, 1, 15deg)" },
  { offset: 0.4, transform: "rotate3d(0, 0, 1, -10deg)" },
  { offset: 0.6, transform: "rotate3d(0, 0, 1, 5deg)" },
  { offset: 0.8, transform: "rotate3d(0, 0, 1, -5deg)" },
  { offset: 1, transform: "rotate3d(0, 0, 1, 0deg)" }
], tada = [
  { offset: 0, transform: "scale3d(1, 1, 1)" },
  { offset: 0.1, transform: "scale3d(0.9, 0.9, 0.9) rotate3d(0, 0, 1, -3deg)" },
  { offset: 0.2, transform: "scale3d(0.9, 0.9, 0.9) rotate3d(0, 0, 1, -3deg)" },
  { offset: 0.3, transform: "scale3d(1.1, 1.1, 1.1) rotate3d(0, 0, 1, 3deg)" },
  { offset: 0.4, transform: "scale3d(1.1, 1.1, 1.1) rotate3d(0, 0, 1, -3deg)" },
  { offset: 0.5, transform: "scale3d(1.1, 1.1, 1.1) rotate3d(0, 0, 1, 3deg)" },
  { offset: 0.6, transform: "scale3d(1.1, 1.1, 1.1) rotate3d(0, 0, 1, -3deg)" },
  { offset: 0.7, transform: "scale3d(1.1, 1.1, 1.1) rotate3d(0, 0, 1, 3deg)" },
  { offset: 0.8, transform: "scale3d(1.1, 1.1, 1.1) rotate3d(0, 0, 1, -3deg)" },
  { offset: 0.9, transform: "scale3d(1.1, 1.1, 1.1) rotate3d(0, 0, 1, 3deg)" },
  { offset: 1, transform: "scale3d(1, 1, 1)" }
], wobble = [
  { offset: 0, transform: "translate3d(0, 0, 0)" },
  { offset: 0.15, transform: "translate3d(-25%, 0, 0) rotate3d(0, 0, 1, -5deg)" },
  { offset: 0.3, transform: "translate3d(20%, 0, 0) rotate3d(0, 0, 1, 3deg)" },
  { offset: 0.45, transform: "translate3d(-15%, 0, 0) rotate3d(0, 0, 1, -3deg)" },
  { offset: 0.6, transform: "translate3d(10%, 0, 0) rotate3d(0, 0, 1, 2deg)" },
  { offset: 0.75, transform: "translate3d(-5%, 0, 0) rotate3d(0, 0, 1, -1deg)" },
  { offset: 1, transform: "translate3d(0, 0, 0)" }
], backInDown = [
  { offset: 0, transform: "translateY(-1200px) scale(0.7)", opacity: "0.7" },
  { offset: 0.8, transform: "translateY(0px) scale(0.7)", opacity: "0.7" },
  { offset: 1, transform: "scale(1)", opacity: "1" }
], backInLeft = [
  { offset: 0, transform: "translateX(-2000px) scale(0.7)", opacity: "0.7" },
  { offset: 0.8, transform: "translateX(0px) scale(0.7)", opacity: "0.7" },
  { offset: 1, transform: "scale(1)", opacity: "1" }
], backInRight = [
  { offset: 0, transform: "translateX(2000px) scale(0.7)", opacity: "0.7" },
  { offset: 0.8, transform: "translateX(0px) scale(0.7)", opacity: "0.7" },
  { offset: 1, transform: "scale(1)", opacity: "1" }
], backInUp = [
  { offset: 0, transform: "translateY(1200px) scale(0.7)", opacity: "0.7" },
  { offset: 0.8, transform: "translateY(0px) scale(0.7)", opacity: "0.7" },
  { offset: 1, transform: "scale(1)", opacity: "1" }
], backOutDown = [
  { offset: 0, transform: "scale(1)", opacity: "1" },
  { offset: 0.2, transform: "translateY(0px) scale(0.7)", opacity: "0.7" },
  { offset: 1, transform: "translateY(700px) scale(0.7)", opacity: "0.7" }
], backOutLeft = [
  { offset: 0, transform: "scale(1)", opacity: "1" },
  { offset: 0.2, transform: "translateX(0px) scale(0.7)", opacity: "0.7" },
  { offset: 1, transform: "translateX(-2000px) scale(0.7)", opacity: "0.7" }
], backOutRight = [
  { offset: 0, transform: "scale(1)", opacity: "1" },
  { offset: 0.2, transform: "translateX(0px) scale(0.7)", opacity: "0.7" },
  { offset: 1, transform: "translateX(2000px) scale(0.7)", opacity: "0.7" }
], backOutUp = [
  { offset: 0, transform: "scale(1)", opacity: "1" },
  { offset: 0.2, transform: "translateY(0px) scale(0.7)", opacity: "0.7" },
  { offset: 1, transform: "translateY(-700px) scale(0.7)", opacity: "0.7" }
], bounceIn = [
  { offset: 0, opacity: "0", transform: "scale3d(0.3, 0.3, 0.3)" },
  { offset: 0, easing: "cubic-bezier(0.215, 0.61, 0.355, 1)" },
  { offset: 0.2, transform: "scale3d(1.1, 1.1, 1.1)" },
  { offset: 0.2, easing: "cubic-bezier(0.215, 0.61, 0.355, 1)" },
  { offset: 0.4, transform: "scale3d(0.9, 0.9, 0.9)" },
  { offset: 0.4, easing: "cubic-bezier(0.215, 0.61, 0.355, 1)" },
  { offset: 0.6, opacity: "1", transform: "scale3d(1.03, 1.03, 1.03)" },
  { offset: 0.6, easing: "cubic-bezier(0.215, 0.61, 0.355, 1)" },
  { offset: 0.8, transform: "scale3d(0.97, 0.97, 0.97)" },
  { offset: 0.8, easing: "cubic-bezier(0.215, 0.61, 0.355, 1)" },
  { offset: 1, opacity: "1", transform: "scale3d(1, 1, 1)" },
  { offset: 1, easing: "cubic-bezier(0.215, 0.61, 0.355, 1)" }
], bounceInDown = [
  { offset: 0, opacity: "0", transform: "translate3d(0, -3000px, 0) scaleY(3)" },
  { offset: 0, easing: "cubic-bezier(0.215, 0.61, 0.355, 1)" },
  { offset: 0.6, opacity: "1", transform: "translate3d(0, 25px, 0) scaleY(0.9)" },
  { offset: 0.6, easing: "cubic-bezier(0.215, 0.61, 0.355, 1)" },
  { offset: 0.75, transform: "translate3d(0, -10px, 0) scaleY(0.95)" },
  { offset: 0.75, easing: "cubic-bezier(0.215, 0.61, 0.355, 1)" },
  { offset: 0.9, transform: "translate3d(0, 5px, 0) scaleY(0.985)" },
  { offset: 0.9, easing: "cubic-bezier(0.215, 0.61, 0.355, 1)" },
  { offset: 1, transform: "translate3d(0, 0, 0)" },
  { offset: 1, easing: "cubic-bezier(0.215, 0.61, 0.355, 1)" }
], bounceInLeft = [
  { offset: 0, opacity: "0", transform: "translate3d(-3000px, 0, 0) scaleX(3)" },
  { offset: 0, easing: "cubic-bezier(0.215, 0.61, 0.355, 1)" },
  { offset: 0.6, opacity: "1", transform: "translate3d(25px, 0, 0) scaleX(1)" },
  { offset: 0.6, easing: "cubic-bezier(0.215, 0.61, 0.355, 1)" },
  { offset: 0.75, transform: "translate3d(-10px, 0, 0) scaleX(0.98)" },
  { offset: 0.75, easing: "cubic-bezier(0.215, 0.61, 0.355, 1)" },
  { offset: 0.9, transform: "translate3d(5px, 0, 0) scaleX(0.995)" },
  { offset: 0.9, easing: "cubic-bezier(0.215, 0.61, 0.355, 1)" },
  { offset: 1, transform: "translate3d(0, 0, 0)" },
  { offset: 1, easing: "cubic-bezier(0.215, 0.61, 0.355, 1)" }
], bounceInRight = [
  { offset: 0, opacity: "0", transform: "translate3d(3000px, 0, 0) scaleX(3)" },
  { offset: 0, easing: "cubic-bezier(0.215, 0.61, 0.355, 1)" },
  { offset: 0.6, opacity: "1", transform: "translate3d(-25px, 0, 0) scaleX(1)" },
  { offset: 0.6, easing: "cubic-bezier(0.215, 0.61, 0.355, 1)" },
  { offset: 0.75, transform: "translate3d(10px, 0, 0) scaleX(0.98)" },
  { offset: 0.75, easing: "cubic-bezier(0.215, 0.61, 0.355, 1)" },
  { offset: 0.9, transform: "translate3d(-5px, 0, 0) scaleX(0.995)" },
  { offset: 0.9, easing: "cubic-bezier(0.215, 0.61, 0.355, 1)" },
  { offset: 1, transform: "translate3d(0, 0, 0)" },
  { offset: 1, easing: "cubic-bezier(0.215, 0.61, 0.355, 1)" }
], bounceInUp = [
  { offset: 0, opacity: "0", transform: "translate3d(0, 3000px, 0) scaleY(5)" },
  { offset: 0, easing: "cubic-bezier(0.215, 0.61, 0.355, 1)" },
  { offset: 0.6, opacity: "1", transform: "translate3d(0, -20px, 0) scaleY(0.9)" },
  { offset: 0.6, easing: "cubic-bezier(0.215, 0.61, 0.355, 1)" },
  { offset: 0.75, transform: "translate3d(0, 10px, 0) scaleY(0.95)" },
  { offset: 0.75, easing: "cubic-bezier(0.215, 0.61, 0.355, 1)" },
  { offset: 0.9, transform: "translate3d(0, -5px, 0) scaleY(0.985)" },
  { offset: 0.9, easing: "cubic-bezier(0.215, 0.61, 0.355, 1)" },
  { offset: 1, transform: "translate3d(0, 0, 0)" },
  { offset: 1, easing: "cubic-bezier(0.215, 0.61, 0.355, 1)" }
], bounceOut = [
  { offset: 0.2, transform: "scale3d(0.9, 0.9, 0.9)" },
  { offset: 0.5, opacity: "1", transform: "scale3d(1.1, 1.1, 1.1)" },
  { offset: 0.55, opacity: "1", transform: "scale3d(1.1, 1.1, 1.1)" },
  { offset: 1, opacity: "0", transform: "scale3d(0.3, 0.3, 0.3)" }
], bounceOutDown = [
  { offset: 0.2, transform: "translate3d(0, 10px, 0) scaleY(0.985)" },
  { offset: 0.4, opacity: "1", transform: "translate3d(0, -20px, 0) scaleY(0.9)" },
  { offset: 0.45, opacity: "1", transform: "translate3d(0, -20px, 0) scaleY(0.9)" },
  { offset: 1, opacity: "0", transform: "translate3d(0, 2000px, 0) scaleY(3)" }
], bounceOutLeft = [
  { offset: 0.2, opacity: "1", transform: "translate3d(20px, 0, 0) scaleX(0.9)" },
  { offset: 1, opacity: "0", transform: "translate3d(-2000px, 0, 0) scaleX(2)" }
], bounceOutRight = [
  { offset: 0.2, opacity: "1", transform: "translate3d(-20px, 0, 0) scaleX(0.9)" },
  { offset: 1, opacity: "0", transform: "translate3d(2000px, 0, 0) scaleX(2)" }
], bounceOutUp = [
  { offset: 0.2, transform: "translate3d(0, -10px, 0) scaleY(0.985)" },
  { offset: 0.4, opacity: "1", transform: "translate3d(0, 20px, 0) scaleY(0.9)" },
  { offset: 0.45, opacity: "1", transform: "translate3d(0, 20px, 0) scaleY(0.9)" },
  { offset: 1, opacity: "0", transform: "translate3d(0, -2000px, 0) scaleY(3)" }
], fadeIn = [
  { offset: 0, opacity: "0" },
  { offset: 1, opacity: "1" }
], fadeInBottomLeft = [
  { offset: 0, opacity: "0", transform: "translate3d(-100%, 100%, 0)" },
  { offset: 1, opacity: "1", transform: "translate3d(0, 0, 0)" }
], fadeInBottomRight = [
  { offset: 0, opacity: "0", transform: "translate3d(100%, 100%, 0)" },
  { offset: 1, opacity: "1", transform: "translate3d(0, 0, 0)" }
], fadeInDown = [
  { offset: 0, opacity: "0", transform: "translate3d(0, -100%, 0)" },
  { offset: 1, opacity: "1", transform: "translate3d(0, 0, 0)" }
], fadeInDownBig = [
  { offset: 0, opacity: "0", transform: "translate3d(0, -2000px, 0)" },
  { offset: 1, opacity: "1", transform: "translate3d(0, 0, 0)" }
], fadeInLeft = [
  { offset: 0, opacity: "0", transform: "translate3d(-100%, 0, 0)" },
  { offset: 1, opacity: "1", transform: "translate3d(0, 0, 0)" }
], fadeInLeftBig = [
  { offset: 0, opacity: "0", transform: "translate3d(-2000px, 0, 0)" },
  { offset: 1, opacity: "1", transform: "translate3d(0, 0, 0)" }
], fadeInRight = [
  { offset: 0, opacity: "0", transform: "translate3d(100%, 0, 0)" },
  { offset: 1, opacity: "1", transform: "translate3d(0, 0, 0)" }
], fadeInRightBig = [
  { offset: 0, opacity: "0", transform: "translate3d(2000px, 0, 0)" },
  { offset: 1, opacity: "1", transform: "translate3d(0, 0, 0)" }
], fadeInTopLeft = [
  { offset: 0, opacity: "0", transform: "translate3d(-100%, -100%, 0)" },
  { offset: 1, opacity: "1", transform: "translate3d(0, 0, 0)" }
], fadeInTopRight = [
  { offset: 0, opacity: "0", transform: "translate3d(100%, -100%, 0)" },
  { offset: 1, opacity: "1", transform: "translate3d(0, 0, 0)" }
], fadeInUp = [
  { offset: 0, opacity: "0", transform: "translate3d(0, 100%, 0)" },
  { offset: 1, opacity: "1", transform: "translate3d(0, 0, 0)" }
], fadeInUpBig = [
  { offset: 0, opacity: "0", transform: "translate3d(0, 2000px, 0)" },
  { offset: 1, opacity: "1", transform: "translate3d(0, 0, 0)" }
], fadeOut = [
  { offset: 0, opacity: "1" },
  { offset: 1, opacity: "0" }
], fadeOutBottomLeft = [
  { offset: 0, opacity: "1", transform: "translate3d(0, 0, 0)" },
  { offset: 1, opacity: "0", transform: "translate3d(-100%, 100%, 0)" }
], fadeOutBottomRight = [
  { offset: 0, opacity: "1", transform: "translate3d(0, 0, 0)" },
  { offset: 1, opacity: "0", transform: "translate3d(100%, 100%, 0)" }
], fadeOutDown = [
  { offset: 0, opacity: "1" },
  { offset: 1, opacity: "0", transform: "translate3d(0, 100%, 0)" }
], fadeOutDownBig = [
  { offset: 0, opacity: "1" },
  { offset: 1, opacity: "0", transform: "translate3d(0, 2000px, 0)" }
], fadeOutLeft = [
  { offset: 0, opacity: "1" },
  { offset: 1, opacity: "0", transform: "translate3d(-100%, 0, 0)" }
], fadeOutLeftBig = [
  { offset: 0, opacity: "1" },
  { offset: 1, opacity: "0", transform: "translate3d(-2000px, 0, 0)" }
], fadeOutRight = [
  { offset: 0, opacity: "1" },
  { offset: 1, opacity: "0", transform: "translate3d(100%, 0, 0)" }
], fadeOutRightBig = [
  { offset: 0, opacity: "1" },
  { offset: 1, opacity: "0", transform: "translate3d(2000px, 0, 0)" }
], fadeOutTopLeft = [
  { offset: 0, opacity: "1", transform: "translate3d(0, 0, 0)" },
  { offset: 1, opacity: "0", transform: "translate3d(-100%, -100%, 0)" }
], fadeOutTopRight = [
  { offset: 0, opacity: "1", transform: "translate3d(0, 0, 0)" },
  { offset: 1, opacity: "0", transform: "translate3d(100%, -100%, 0)" }
], fadeOutUp = [
  { offset: 0, opacity: "1" },
  { offset: 1, opacity: "0", transform: "translate3d(0, -100%, 0)" }
], fadeOutUpBig = [
  { offset: 0, opacity: "1" },
  { offset: 1, opacity: "0", transform: "translate3d(0, -2000px, 0)" }
], flip = [
  {
    offset: 0,
    transform: "perspective(400px) scale3d(1, 1, 1) translate3d(0, 0, 0) rotate3d(0, 1, 0, -360deg)",
    easing: "ease-out"
  },
  {
    offset: 0.4,
    transform: `perspective(400px) scale3d(1, 1, 1) translate3d(0, 0, 150px)
      rotate3d(0, 1, 0, -190deg)`,
    easing: "ease-out"
  },
  {
    offset: 0.5,
    transform: `perspective(400px) scale3d(1, 1, 1) translate3d(0, 0, 150px)
      rotate3d(0, 1, 0, -170deg)`,
    easing: "ease-in"
  },
  {
    offset: 0.8,
    transform: `perspective(400px) scale3d(0.95, 0.95, 0.95) translate3d(0, 0, 0)
      rotate3d(0, 1, 0, 0deg)`,
    easing: "ease-in"
  },
  {
    offset: 1,
    transform: "perspective(400px) scale3d(1, 1, 1) translate3d(0, 0, 0) rotate3d(0, 1, 0, 0deg)",
    easing: "ease-in"
  }
], flipInX = [
  { offset: 0, transform: "perspective(400px) rotate3d(1, 0, 0, 90deg)", easing: "ease-in", opacity: "0" },
  { offset: 0.4, transform: "perspective(400px) rotate3d(1, 0, 0, -20deg)", easing: "ease-in" },
  { offset: 0.6, transform: "perspective(400px) rotate3d(1, 0, 0, 10deg)", opacity: "1" },
  { offset: 0.8, transform: "perspective(400px) rotate3d(1, 0, 0, -5deg)" },
  { offset: 1, transform: "perspective(400px)" }
], flipInY = [
  { offset: 0, transform: "perspective(400px) rotate3d(0, 1, 0, 90deg)", easing: "ease-in", opacity: "0" },
  { offset: 0.4, transform: "perspective(400px) rotate3d(0, 1, 0, -20deg)", easing: "ease-in" },
  { offset: 0.6, transform: "perspective(400px) rotate3d(0, 1, 0, 10deg)", opacity: "1" },
  { offset: 0.8, transform: "perspective(400px) rotate3d(0, 1, 0, -5deg)" },
  { offset: 1, transform: "perspective(400px)" }
], flipOutX = [
  { offset: 0, transform: "perspective(400px)" },
  { offset: 0.3, transform: "perspective(400px) rotate3d(1, 0, 0, -20deg)", opacity: "1" },
  { offset: 1, transform: "perspective(400px) rotate3d(1, 0, 0, 90deg)", opacity: "0" }
], flipOutY = [
  { offset: 0, transform: "perspective(400px)" },
  { offset: 0.3, transform: "perspective(400px) rotate3d(0, 1, 0, -15deg)", opacity: "1" },
  { offset: 1, transform: "perspective(400px) rotate3d(0, 1, 0, 90deg)", opacity: "0" }
], lightSpeedInLeft = [
  { offset: 0, transform: "translate3d(-100%, 0, 0) skewX(30deg)", opacity: "0" },
  { offset: 0.6, transform: "skewX(-20deg)", opacity: "1" },
  { offset: 0.8, transform: "skewX(5deg)" },
  { offset: 1, transform: "translate3d(0, 0, 0)" }
], lightSpeedInRight = [
  { offset: 0, transform: "translate3d(100%, 0, 0) skewX(-30deg)", opacity: "0" },
  { offset: 0.6, transform: "skewX(20deg)", opacity: "1" },
  { offset: 0.8, transform: "skewX(-5deg)" },
  { offset: 1, transform: "translate3d(0, 0, 0)" }
], lightSpeedOutLeft = [
  { offset: 0, opacity: "1" },
  { offset: 1, transform: "translate3d(-100%, 0, 0) skewX(-30deg)", opacity: "0" }
], lightSpeedOutRight = [
  { offset: 0, opacity: "1" },
  { offset: 1, transform: "translate3d(100%, 0, 0) skewX(30deg)", opacity: "0" }
], rotateIn = [
  { offset: 0, transform: "rotate3d(0, 0, 1, -200deg)", opacity: "0" },
  { offset: 1, transform: "translate3d(0, 0, 0)", opacity: "1" }
], rotateInDownLeft = [
  { offset: 0, transform: "rotate3d(0, 0, 1, -45deg)", opacity: "0" },
  { offset: 1, transform: "translate3d(0, 0, 0)", opacity: "1" }
], rotateInDownRight = [
  { offset: 0, transform: "rotate3d(0, 0, 1, 45deg)", opacity: "0" },
  { offset: 1, transform: "translate3d(0, 0, 0)", opacity: "1" }
], rotateInUpLeft = [
  { offset: 0, transform: "rotate3d(0, 0, 1, 45deg)", opacity: "0" },
  { offset: 1, transform: "translate3d(0, 0, 0)", opacity: "1" }
], rotateInUpRight = [
  { offset: 0, transform: "rotate3d(0, 0, 1, -90deg)", opacity: "0" },
  { offset: 1, transform: "translate3d(0, 0, 0)", opacity: "1" }
], rotateOut = [
  { offset: 0, opacity: "1" },
  { offset: 1, transform: "rotate3d(0, 0, 1, 200deg)", opacity: "0" }
], rotateOutDownLeft = [
  { offset: 0, opacity: "1" },
  { offset: 1, transform: "rotate3d(0, 0, 1, 45deg)", opacity: "0" }
], rotateOutDownRight = [
  { offset: 0, opacity: "1" },
  { offset: 1, transform: "rotate3d(0, 0, 1, -45deg)", opacity: "0" }
], rotateOutUpLeft = [
  { offset: 0, opacity: "1" },
  { offset: 1, transform: "rotate3d(0, 0, 1, -45deg)", opacity: "0" }
], rotateOutUpRight = [
  { offset: 0, opacity: "1" },
  { offset: 1, transform: "rotate3d(0, 0, 1, 90deg)", opacity: "0" }
], slideInDown = [
  { offset: 0, transform: "translate3d(0, -100%, 0)", visibility: "visible" },
  { offset: 1, transform: "translate3d(0, 0, 0)" }
], slideInLeft = [
  { offset: 0, transform: "translate3d(-100%, 0, 0)", visibility: "visible" },
  { offset: 1, transform: "translate3d(0, 0, 0)" }
], slideInRight = [
  { offset: 0, transform: "translate3d(100%, 0, 0)", visibility: "visible" },
  { offset: 1, transform: "translate3d(0, 0, 0)" }
], slideInUp = [
  { offset: 0, transform: "translate3d(0, 100%, 0)", visibility: "visible" },
  { offset: 1, transform: "translate3d(0, 0, 0)" }
], slideOutDown = [
  { offset: 0, transform: "translate3d(0, 0, 0)" },
  { offset: 1, visibility: "hidden", transform: "translate3d(0, 100%, 0)" }
], slideOutLeft = [
  { offset: 0, transform: "translate3d(0, 0, 0)" },
  { offset: 1, visibility: "hidden", transform: "translate3d(-100%, 0, 0)" }
], slideOutRight = [
  { offset: 0, transform: "translate3d(0, 0, 0)" },
  { offset: 1, visibility: "hidden", transform: "translate3d(100%, 0, 0)" }
], slideOutUp = [
  { offset: 0, transform: "translate3d(0, 0, 0)" },
  { offset: 1, visibility: "hidden", transform: "translate3d(0, -100%, 0)" }
], hinge = [
  { offset: 0, easing: "ease-in-out" },
  { offset: 0.2, transform: "rotate3d(0, 0, 1, 80deg)", easing: "ease-in-out" },
  { offset: 0.4, transform: "rotate3d(0, 0, 1, 60deg)", easing: "ease-in-out", opacity: "1" },
  { offset: 0.6, transform: "rotate3d(0, 0, 1, 80deg)", easing: "ease-in-out" },
  { offset: 0.8, transform: "rotate3d(0, 0, 1, 60deg)", easing: "ease-in-out", opacity: "1" },
  { offset: 1, transform: "translate3d(0, 700px, 0)", opacity: "0" }
], jackInTheBox = [
  { offset: 0, opacity: "0", transform: "scale(0.1) rotate(30deg)", "transform-origin": "center bottom" },
  { offset: 0.5, transform: "rotate(-10deg)" },
  { offset: 0.7, transform: "rotate(3deg)" },
  { offset: 1, opacity: "1", transform: "scale(1)" }
], rollIn = [
  { offset: 0, opacity: "0", transform: "translate3d(-100%, 0, 0) rotate3d(0, 0, 1, -120deg)" },
  { offset: 1, opacity: "1", transform: "translate3d(0, 0, 0)" }
], rollOut = [
  { offset: 0, opacity: "1" },
  { offset: 1, opacity: "0", transform: "translate3d(100%, 0, 0) rotate3d(0, 0, 1, 120deg)" }
], zoomIn = [
  { offset: 0, opacity: "0", transform: "scale3d(0.3, 0.3, 0.3)" },
  { offset: 0.5, opacity: "1" }
], zoomInDown = [
  {
    offset: 0,
    opacity: "0",
    transform: "scale3d(0.1, 0.1, 0.1) translate3d(0, -1000px, 0)",
    easing: "cubic-bezier(0.55, 0.055, 0.675, 0.19)"
  },
  {
    offset: 0.6,
    opacity: "1",
    transform: "scale3d(0.475, 0.475, 0.475) translate3d(0, 60px, 0)",
    easing: "cubic-bezier(0.175, 0.885, 0.32, 1)"
  }
], zoomInLeft = [
  {
    offset: 0,
    opacity: "0",
    transform: "scale3d(0.1, 0.1, 0.1) translate3d(-1000px, 0, 0)",
    easing: "cubic-bezier(0.55, 0.055, 0.675, 0.19)"
  },
  {
    offset: 0.6,
    opacity: "1",
    transform: "scale3d(0.475, 0.475, 0.475) translate3d(10px, 0, 0)",
    easing: "cubic-bezier(0.175, 0.885, 0.32, 1)"
  }
], zoomInRight = [
  {
    offset: 0,
    opacity: "0",
    transform: "scale3d(0.1, 0.1, 0.1) translate3d(1000px, 0, 0)",
    easing: "cubic-bezier(0.55, 0.055, 0.675, 0.19)"
  },
  {
    offset: 0.6,
    opacity: "1",
    transform: "scale3d(0.475, 0.475, 0.475) translate3d(-10px, 0, 0)",
    easing: "cubic-bezier(0.175, 0.885, 0.32, 1)"
  }
], zoomInUp = [
  {
    offset: 0,
    opacity: "0",
    transform: "scale3d(0.1, 0.1, 0.1) translate3d(0, 1000px, 0)",
    easing: "cubic-bezier(0.55, 0.055, 0.675, 0.19)"
  },
  {
    offset: 0.6,
    opacity: "1",
    transform: "scale3d(0.475, 0.475, 0.475) translate3d(0, -60px, 0)",
    easing: "cubic-bezier(0.175, 0.885, 0.32, 1)"
  }
], zoomOut = [
  { offset: 0, opacity: "1" },
  { offset: 0.5, opacity: "0", transform: "scale3d(0.3, 0.3, 0.3)" },
  { offset: 1, opacity: "0" }
], zoomOutDown = [
  {
    offset: 0.4,
    opacity: "1",
    transform: "scale3d(0.475, 0.475, 0.475) translate3d(0, -60px, 0)",
    easing: "cubic-bezier(0.55, 0.055, 0.675, 0.19)"
  },
  {
    offset: 1,
    opacity: "0",
    transform: "scale3d(0.1, 0.1, 0.1) translate3d(0, 2000px, 0)",
    easing: "cubic-bezier(0.175, 0.885, 0.32, 1)"
  }
], zoomOutLeft = [
  { offset: 0.4, opacity: "1", transform: "scale3d(0.475, 0.475, 0.475) translate3d(42px, 0, 0)" },
  { offset: 1, opacity: "0", transform: "scale(0.1) translate3d(-2000px, 0, 0)" }
], zoomOutRight = [
  { offset: 0.4, opacity: "1", transform: "scale3d(0.475, 0.475, 0.475) translate3d(-42px, 0, 0)" },
  { offset: 1, opacity: "0", transform: "scale(0.1) translate3d(2000px, 0, 0)" }
], zoomOutUp = [
  {
    offset: 0.4,
    opacity: "1",
    transform: "scale3d(0.475, 0.475, 0.475) translate3d(0, 60px, 0)",
    easing: "cubic-bezier(0.55, 0.055, 0.675, 0.19)"
  },
  {
    offset: 1,
    opacity: "0",
    transform: "scale3d(0.1, 0.1, 0.1) translate3d(0, -2000px, 0)",
    easing: "cubic-bezier(0.175, 0.885, 0.32, 1)"
  }
], easings = {
  linear: "linear",
  ease: "ease",
  easeIn: "ease-in",
  easeOut: "ease-out",
  easeInOut: "ease-in-out",
  easeInSine: "cubic-bezier(0.47, 0, 0.745, 0.715)",
  easeOutSine: "cubic-bezier(0.39, 0.575, 0.565, 1)",
  easeInOutSine: "cubic-bezier(0.445, 0.05, 0.55, 0.95)",
  easeInQuad: "cubic-bezier(0.55, 0.085, 0.68, 0.53)",
  easeOutQuad: "cubic-bezier(0.25, 0.46, 0.45, 0.94)",
  easeInOutQuad: "cubic-bezier(0.455, 0.03, 0.515, 0.955)",
  easeInCubic: "cubic-bezier(0.55, 0.055, 0.675, 0.19)",
  easeOutCubic: "cubic-bezier(0.215, 0.61, 0.355, 1)",
  easeInOutCubic: "cubic-bezier(0.645, 0.045, 0.355, 1)",
  easeInQuart: "cubic-bezier(0.895, 0.03, 0.685, 0.22)",
  easeOutQuart: "cubic-bezier(0.165, 0.84, 0.44, 1)",
  easeInOutQuart: "cubic-bezier(0.77, 0, 0.175, 1)",
  easeInQuint: "cubic-bezier(0.755, 0.05, 0.855, 0.06)",
  easeOutQuint: "cubic-bezier(0.23, 1, 0.32, 1)",
  easeInOutQuint: "cubic-bezier(0.86, 0, 0.07, 1)",
  easeInExpo: "cubic-bezier(0.95, 0.05, 0.795, 0.035)",
  easeOutExpo: "cubic-bezier(0.19, 1, 0.22, 1)",
  easeInOutExpo: "cubic-bezier(1, 0, 0, 1)",
  easeInCirc: "cubic-bezier(0.6, 0.04, 0.98, 0.335)",
  easeOutCirc: "cubic-bezier(0.075, 0.82, 0.165, 1)",
  easeInOutCirc: "cubic-bezier(0.785, 0.135, 0.15, 0.86)",
  easeInBack: "cubic-bezier(0.6, -0.28, 0.735, 0.045)",
  easeOutBack: "cubic-bezier(0.175, 0.885, 0.32, 1.275)",
  easeInOutBack: "cubic-bezier(0.68, -0.55, 0.265, 1.55)"
}, animations = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  backInDown,
  backInLeft,
  backInRight,
  backInUp,
  backOutDown,
  backOutLeft,
  backOutRight,
  backOutUp,
  bounce,
  bounceIn,
  bounceInDown,
  bounceInLeft,
  bounceInRight,
  bounceInUp,
  bounceOut,
  bounceOutDown,
  bounceOutLeft,
  bounceOutRight,
  bounceOutUp,
  easings,
  fadeIn,
  fadeInBottomLeft,
  fadeInBottomRight,
  fadeInDown,
  fadeInDownBig,
  fadeInLeft,
  fadeInLeftBig,
  fadeInRight,
  fadeInRightBig,
  fadeInTopLeft,
  fadeInTopRight,
  fadeInUp,
  fadeInUpBig,
  fadeOut,
  fadeOutBottomLeft,
  fadeOutBottomRight,
  fadeOutDown,
  fadeOutDownBig,
  fadeOutLeft,
  fadeOutLeftBig,
  fadeOutRight,
  fadeOutRightBig,
  fadeOutTopLeft,
  fadeOutTopRight,
  fadeOutUp,
  fadeOutUpBig,
  flash,
  flip,
  flipInX,
  flipInY,
  flipOutX,
  flipOutY,
  headShake,
  heartBeat,
  hinge,
  jackInTheBox,
  jello,
  lightSpeedInLeft,
  lightSpeedInRight,
  lightSpeedOutLeft,
  lightSpeedOutRight,
  pulse,
  rollIn,
  rollOut,
  rotateIn,
  rotateInDownLeft,
  rotateInDownRight,
  rotateInUpLeft,
  rotateInUpRight,
  rotateOut,
  rotateOutDownLeft,
  rotateOutDownRight,
  rotateOutUpLeft,
  rotateOutUpRight,
  rubberBand,
  shake,
  shakeX,
  shakeY,
  slideInDown,
  slideInLeft,
  slideInRight,
  slideInUp,
  slideOutDown,
  slideOutLeft,
  slideOutRight,
  slideOutUp,
  swing,
  tada,
  wobble,
  zoomIn,
  zoomInDown,
  zoomInLeft,
  zoomInRight,
  zoomInUp,
  zoomOut,
  zoomOutDown,
  zoomOutLeft,
  zoomOutRight,
  zoomOutUp
}, Symbol.toStringTag, { value: "Module" }));
var SlAnimation = class extends ShoelaceElement {
  constructor() {
    super(...arguments), this.hasStarted = !1, this.name = "none", this.play = !1, this.delay = 0, this.direction = "normal", this.duration = 1e3, this.easing = "linear", this.endDelay = 0, this.fill = "auto", this.iterations = 1 / 0, this.iterationStart = 0, this.playbackRate = 1, this.handleAnimationFinish = () => {
      this.play = !1, this.hasStarted = !1, this.emit("sl-finish");
    }, this.handleAnimationCancel = () => {
      this.play = !1, this.hasStarted = !1, this.emit("sl-cancel");
    };
  }
  /** Gets and sets the current animation time. */
  get currentTime() {
    var C, L;
    return (L = (C = this.animation) == null ? void 0 : C.currentTime) != null ? L : 0;
  }
  set currentTime(C) {
    this.animation && (this.animation.currentTime = C);
  }
  connectedCallback() {
    super.connectedCallback(), this.createAnimation();
  }
  disconnectedCallback() {
    super.disconnectedCallback(), this.destroyAnimation();
  }
  handleSlotChange() {
    this.destroyAnimation(), this.createAnimation();
  }
  async createAnimation() {
    var C, L;
    const A = (C = easings[this.easing]) != null ? C : this.easing, W = (L = this.keyframes) != null ? L : animations[this.name], J = (await this.defaultSlot).assignedElements()[0];
    return !J || !W ? !1 : (this.destroyAnimation(), this.animation = J.animate(W, {
      delay: this.delay,
      direction: this.direction,
      duration: this.duration,
      easing: A,
      endDelay: this.endDelay,
      fill: this.fill,
      iterationStart: this.iterationStart,
      iterations: this.iterations
    }), this.animation.playbackRate = this.playbackRate, this.animation.addEventListener("cancel", this.handleAnimationCancel), this.animation.addEventListener("finish", this.handleAnimationFinish), this.play ? (this.hasStarted = !0, this.emit("sl-start")) : this.animation.pause(), !0);
  }
  destroyAnimation() {
    this.animation && (this.animation.cancel(), this.animation.removeEventListener("cancel", this.handleAnimationCancel), this.animation.removeEventListener("finish", this.handleAnimationFinish), this.hasStarted = !1);
  }
  handleAnimationChange() {
    this.hasUpdated && this.createAnimation();
  }
  handlePlayChange() {
    return this.animation ? (this.play && !this.hasStarted && (this.hasStarted = !0, this.emit("sl-start")), this.play ? this.animation.play() : this.animation.pause(), !0) : !1;
  }
  handlePlaybackRateChange() {
    this.animation && (this.animation.playbackRate = this.playbackRate);
  }
  /** Clears all keyframe effects caused by this animation and aborts its playback. */
  cancel() {
    var C;
    (C = this.animation) == null || C.cancel();
  }
  /** Sets the playback time to the end of the animation corresponding to the current playback direction. */
  finish() {
    var C;
    (C = this.animation) == null || C.finish();
  }
  render() {
    return ke$1` <slot @slotchange=${this.handleSlotChange}></slot> `;
  }
};
SlAnimation.styles = [component_styles_default, animation_styles_default];
__decorateClass$e([
  r$1("slot")
], SlAnimation.prototype, "defaultSlot", 2);
__decorateClass$e([
  n$1()
], SlAnimation.prototype, "name", 2);
__decorateClass$e([
  n$1({ type: Boolean, reflect: !0 })
], SlAnimation.prototype, "play", 2);
__decorateClass$e([
  n$1({ type: Number })
], SlAnimation.prototype, "delay", 2);
__decorateClass$e([
  n$1()
], SlAnimation.prototype, "direction", 2);
__decorateClass$e([
  n$1({ type: Number })
], SlAnimation.prototype, "duration", 2);
__decorateClass$e([
  n$1()
], SlAnimation.prototype, "easing", 2);
__decorateClass$e([
  n$1({ attribute: "end-delay", type: Number })
], SlAnimation.prototype, "endDelay", 2);
__decorateClass$e([
  n$1()
], SlAnimation.prototype, "fill", 2);
__decorateClass$e([
  n$1({ type: Number })
], SlAnimation.prototype, "iterations", 2);
__decorateClass$e([
  n$1({ attribute: "iteration-start", type: Number })
], SlAnimation.prototype, "iterationStart", 2);
__decorateClass$e([
  n$1({ attribute: !1 })
], SlAnimation.prototype, "keyframes", 2);
__decorateClass$e([
  n$1({ attribute: "playback-rate", type: Number })
], SlAnimation.prototype, "playbackRate", 2);
__decorateClass$e([
  watch([
    "name",
    "delay",
    "direction",
    "duration",
    "easing",
    "endDelay",
    "fill",
    "iterations",
    "iterationsStart",
    "keyframes"
  ])
], SlAnimation.prototype, "handleAnimationChange", 1);
__decorateClass$e([
  watch("play")
], SlAnimation.prototype, "handlePlayChange", 1);
__decorateClass$e([
  watch("playbackRate")
], SlAnimation.prototype, "handlePlaybackRateChange", 1);
SlAnimation.define("sl-animation");
var alert_styles_default = i$5`
  :host {
    display: contents;

    /* For better DX, we'll reset the margin here so the base part can inherit it */
    margin: 0;
  }

  .alert {
    position: relative;
    display: flex;
    align-items: stretch;
    background-color: var(--sl-panel-background-color);
    border: solid var(--sl-panel-border-width) var(--sl-panel-border-color);
    border-top-width: calc(var(--sl-panel-border-width) * 3);
    border-radius: var(--sl-border-radius-medium);
    font-family: var(--sl-font-sans);
    font-size: var(--sl-font-size-small);
    font-weight: var(--sl-font-weight-normal);
    line-height: 1.6;
    color: var(--sl-color-neutral-700);
    margin: inherit;
  }

  .alert:not(.alert--has-icon) .alert__icon,
  .alert:not(.alert--closable) .alert__close-button {
    display: none;
  }

  .alert__icon {
    flex: 0 0 auto;
    display: flex;
    align-items: center;
    font-size: var(--sl-font-size-large);
    padding-inline-start: var(--sl-spacing-large);
  }

  .alert--primary {
    border-top-color: var(--sl-color-primary-600);
  }

  .alert--primary .alert__icon {
    color: var(--sl-color-primary-600);
  }

  .alert--success {
    border-top-color: var(--sl-color-success-600);
  }

  .alert--success .alert__icon {
    color: var(--sl-color-success-600);
  }

  .alert--neutral {
    border-top-color: var(--sl-color-neutral-600);
  }

  .alert--neutral .alert__icon {
    color: var(--sl-color-neutral-600);
  }

  .alert--warning {
    border-top-color: var(--sl-color-warning-600);
  }

  .alert--warning .alert__icon {
    color: var(--sl-color-warning-600);
  }

  .alert--danger {
    border-top-color: var(--sl-color-danger-600);
  }

  .alert--danger .alert__icon {
    color: var(--sl-color-danger-600);
  }

  .alert__message {
    flex: 1 1 auto;
    display: block;
    padding: var(--sl-spacing-large);
    overflow: hidden;
  }

  .alert__close-button {
    flex: 0 0 auto;
    display: flex;
    align-items: center;
    font-size: var(--sl-font-size-medium);
    padding-inline-end: var(--sl-spacing-medium);
  }
`, toastStack = Object.assign(document.createElement("div"), { className: "sl-toast-stack" }), SlAlert = class extends ShoelaceElement {
  constructor() {
    super(...arguments), this.hasSlotController = new HasSlotController(this, "icon", "suffix"), this.localize = new LocalizeController(this), this.open = !1, this.closable = !1, this.variant = "primary", this.duration = 1 / 0;
  }
  firstUpdated() {
    this.base.hidden = !this.open;
  }
  restartAutoHide() {
    clearTimeout(this.autoHideTimeout), this.open && this.duration < 1 / 0 && (this.autoHideTimeout = window.setTimeout(() => this.hide(), this.duration));
  }
  handleCloseClick() {
    this.hide();
  }
  handleMouseMove() {
    this.restartAutoHide();
  }
  async handleOpenChange() {
    if (this.open) {
      this.emit("sl-show"), this.duration < 1 / 0 && this.restartAutoHide(), await stopAnimations(this.base), this.base.hidden = !1;
      const { keyframes: C, options: L } = getAnimation(this, "alert.show", { dir: this.localize.dir() });
      await animateTo(this.base, C, L), this.emit("sl-after-show");
    } else {
      this.emit("sl-hide"), clearTimeout(this.autoHideTimeout), await stopAnimations(this.base);
      const { keyframes: C, options: L } = getAnimation(this, "alert.hide", { dir: this.localize.dir() });
      await animateTo(this.base, C, L), this.base.hidden = !0, this.emit("sl-after-hide");
    }
  }
  handleDurationChange() {
    this.restartAutoHide();
  }
  /** Shows the alert. */
  async show() {
    if (!this.open)
      return this.open = !0, waitForEvent(this, "sl-after-show");
  }
  /** Hides the alert */
  async hide() {
    if (this.open)
      return this.open = !1, waitForEvent(this, "sl-after-hide");
  }
  /**
   * Displays the alert as a toast notification. This will move the alert out of its position in the DOM and, when
   * dismissed, it will be removed from the DOM completely. By storing a reference to the alert, you can reuse it by
   * calling this method again. The returned promise will resolve after the alert is hidden.
   */
  async toast() {
    return new Promise((C) => {
      toastStack.parentElement === null && document.body.append(toastStack), toastStack.appendChild(this), requestAnimationFrame(() => {
        this.clientWidth, this.show();
      }), this.addEventListener(
        "sl-after-hide",
        () => {
          toastStack.removeChild(this), C(), toastStack.querySelector("sl-alert") === null && toastStack.remove();
        },
        { once: !0 }
      );
    });
  }
  render() {
    return ke$1`
      <div
        part="base"
        class=${Rt({
      alert: !0,
      "alert--open": this.open,
      "alert--closable": this.closable,
      "alert--has-icon": this.hasSlotController.test("icon"),
      "alert--primary": this.variant === "primary",
      "alert--success": this.variant === "success",
      "alert--neutral": this.variant === "neutral",
      "alert--warning": this.variant === "warning",
      "alert--danger": this.variant === "danger"
    })}
        role="alert"
        aria-hidden=${this.open ? "false" : "true"}
        @mousemove=${this.handleMouseMove}
      >
        <div part="icon" class="alert__icon">
          <slot name="icon"></slot>
        </div>

        <div part="message" class="alert__message" aria-live="polite">
          <slot></slot>
        </div>

        ${this.closable ? ke$1`
              <sl-icon-button
                part="close-button"
                exportparts="base:close-button__base"
                class="alert__close-button"
                name="x-lg"
                library="system"
                label=${this.localize.term("close")}
                @click=${this.handleCloseClick}
              ></sl-icon-button>
            ` : ""}
      </div>
    `;
  }
};
SlAlert.styles = [component_styles_default, alert_styles_default];
SlAlert.dependencies = { "sl-icon-button": SlIconButton };
__decorateClass$e([
  e$6('[part~="base"]')
], SlAlert.prototype, "base", 2);
__decorateClass$e([
  n$1({ type: Boolean, reflect: !0 })
], SlAlert.prototype, "open", 2);
__decorateClass$e([
  n$1({ type: Boolean, reflect: !0 })
], SlAlert.prototype, "closable", 2);
__decorateClass$e([
  n$1({ reflect: !0 })
], SlAlert.prototype, "variant", 2);
__decorateClass$e([
  n$1({ type: Number })
], SlAlert.prototype, "duration", 2);
__decorateClass$e([
  watch("open", { waitUntilFirstUpdate: !0 })
], SlAlert.prototype, "handleOpenChange", 1);
__decorateClass$e([
  watch("duration")
], SlAlert.prototype, "handleDurationChange", 1);
setDefaultAnimation("alert.show", {
  keyframes: [
    { opacity: 0, scale: 0.8 },
    { opacity: 1, scale: 1 }
  ],
  options: { duration: 250, easing: "ease" }
});
setDefaultAnimation("alert.hide", {
  keyframes: [
    { opacity: 1, scale: 1 },
    { opacity: 0, scale: 0.8 }
  ],
  options: { duration: 250, easing: "ease" }
});
SlAlert.define("sl-alert");
var animated_image_styles_default = i$5`
  :host {
    --control-box-size: 3rem;
    --icon-size: calc(var(--control-box-size) * 0.625);

    display: inline-flex;
    position: relative;
    cursor: pointer;
  }

  img {
    display: block;
    width: 100%;
    height: 100%;
  }

  img[aria-hidden='true'] {
    display: none;
  }

  .animated-image__control-box {
    display: flex;
    position: absolute;
    align-items: center;
    justify-content: center;
    top: calc(50% - var(--control-box-size) / 2);
    right: calc(50% - var(--control-box-size) / 2);
    width: var(--control-box-size);
    height: var(--control-box-size);
    font-size: var(--icon-size);
    background: none;
    border: solid 2px currentColor;
    background-color: rgb(0 0 0 /50%);
    border-radius: var(--sl-border-radius-circle);
    color: white;
    pointer-events: none;
    transition: var(--sl-transition-fast) opacity;
  }

  :host([play]:hover) .animated-image__control-box {
    opacity: 1;
  }

  :host([play]:not(:hover)) .animated-image__control-box {
    opacity: 0;
  }

  :host([play]) slot[name='play-icon'],
  :host(:not([play])) slot[name='pause-icon'] {
    display: none;
  }
`, SlAnimatedImage = class extends ShoelaceElement {
  constructor() {
    super(...arguments), this.isLoaded = !1;
  }
  handleClick() {
    this.play = !this.play;
  }
  handleLoad() {
    const C = document.createElement("canvas"), { width: L, height: A } = this.animatedImage;
    C.width = L, C.height = A, C.getContext("2d").drawImage(this.animatedImage, 0, 0, L, A), this.frozenFrame = C.toDataURL("image/gif"), this.isLoaded || (this.emit("sl-load"), this.isLoaded = !0);
  }
  handleError() {
    this.emit("sl-error");
  }
  handlePlayChange() {
    this.play && (this.animatedImage.src = "", this.animatedImage.src = this.src);
  }
  handleSrcChange() {
    this.isLoaded = !1;
  }
  render() {
    return ke$1`
      <div class="animated-image">
        <img
          class="animated-image__animated"
          src=${this.src}
          alt=${this.alt}
          crossorigin="anonymous"
          aria-hidden=${this.play ? "false" : "true"}
          @click=${this.handleClick}
          @load=${this.handleLoad}
          @error=${this.handleError}
        />

        ${this.isLoaded ? ke$1`
              <img
                class="animated-image__frozen"
                src=${this.frozenFrame}
                alt=${this.alt}
                aria-hidden=${this.play ? "true" : "false"}
                @click=${this.handleClick}
              />

              <div part="control-box" class="animated-image__control-box">
                <slot name="play-icon"><sl-icon name="play-fill" library="system"></sl-icon></slot>
                <slot name="pause-icon"><sl-icon name="pause-fill" library="system"></sl-icon></slot>
              </div>
            ` : ""}
      </div>
    `;
  }
};
SlAnimatedImage.styles = [component_styles_default, animated_image_styles_default];
SlAnimatedImage.dependencies = { "sl-icon": SlIcon };
__decorateClass$e([
  e$6(".animated-image__animated")
], SlAnimatedImage.prototype, "animatedImage", 2);
__decorateClass$e([
  r$3()
], SlAnimatedImage.prototype, "frozenFrame", 2);
__decorateClass$e([
  r$3()
], SlAnimatedImage.prototype, "isLoaded", 2);
__decorateClass$e([
  n$1()
], SlAnimatedImage.prototype, "src", 2);
__decorateClass$e([
  n$1()
], SlAnimatedImage.prototype, "alt", 2);
__decorateClass$e([
  n$1({ type: Boolean, reflect: !0 })
], SlAnimatedImage.prototype, "play", 2);
__decorateClass$e([
  watch("play", { waitUntilFirstUpdate: !0 })
], SlAnimatedImage.prototype, "handlePlayChange", 1);
__decorateClass$e([
  watch("src")
], SlAnimatedImage.prototype, "handleSrcChange", 1);
SlAnimatedImage.define("sl-animated-image");
function userAgentPolyfill() {
  var J;
  const C = ((J = navigator.userAgent.split(" ").pop()) == null ? void 0 : J.split("/")) ?? [], L = !!navigator.maxTouchPoints, A = navigator.platform, X = { MacIntel: L ? "iOS" : "macOS", Win32: "Windows", iPhone: "iOS", iPad: "iOS" };
  return {
    brands: [{ brand: (C == null ? void 0 : C[0]) ?? "", version: (C == null ? void 0 : C[1]) ?? "" }],
    mobile: L || /Android|iPhone|iPad|Mobi/i.test(navigator.userAgent),
    platform: X[A] ?? A
  };
}
const polyfill = navigator.userAgentData ?? userAgentPolyfill();
Object.defineProperty(navigator, "userAgentData", {
  get: () => polyfill
});
/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
let s$4 = class extends Event {
  constructor(L, A, W) {
    super("context-request", { bubbles: !0, composed: !0 }), this.context = L, this.callback = A, this.subscribe = W ?? !1;
  }
};
/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
function n(C) {
  return C;
}
/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
let s$3 = class {
  constructor(L, A, W, X) {
    if (this.subscribe = !1, this.provided = !1, this.value = void 0, this.t = (J, te) => {
      this.unsubscribe && (this.unsubscribe !== te && (this.provided = !1, this.unsubscribe()), this.subscribe || this.unsubscribe()), this.value = J, this.host.requestUpdate(), this.provided && !this.subscribe || (this.provided = !0, this.callback && this.callback(J, te)), this.unsubscribe = te;
    }, this.host = L, A.context !== void 0) {
      const J = A;
      this.context = J.context, this.callback = J.callback, this.subscribe = J.subscribe ?? !1;
    } else this.context = A, this.callback = W, this.subscribe = X ?? !1;
    this.host.addController(this);
  }
  hostConnected() {
    this.dispatchRequest();
  }
  hostDisconnected() {
    this.unsubscribe && (this.unsubscribe(), this.unsubscribe = void 0);
  }
  dispatchRequest() {
    this.host.dispatchEvent(new s$4(this.context, this.t, this.subscribe));
  }
};
/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
let s$2 = class {
  get value() {
    return this.o;
  }
  set value(L) {
    this.setValue(L);
  }
  setValue(L, A = !1) {
    const W = A || !Object.is(L, this.o);
    this.o = L, W && this.updateObservers();
  }
  constructor(L) {
    this.subscriptions = /* @__PURE__ */ new Map(), this.updateObservers = () => {
      for (const [A, { disposer: W }] of this.subscriptions) A(this.o, W);
    }, L !== void 0 && (this.value = L);
  }
  addCallback(L, A, W) {
    if (!W) return void L(this.value);
    this.subscriptions.has(L) || this.subscriptions.set(L, { disposer: () => {
      this.subscriptions.delete(L);
    }, consumerHost: A });
    const { disposer: X } = this.subscriptions.get(L);
    L(this.value, X);
  }
  clearCallbacks() {
    this.subscriptions.clear();
  }
};
/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
let e$3 = class extends Event {
  constructor(L) {
    super("context-provider", { bubbles: !0, composed: !0 }), this.context = L;
  }
}, i$2 = class extends s$2 {
  constructor(L, A, W) {
    var X, J;
    super(A.context !== void 0 ? A.initialValue : W), this.onContextRequest = (te) => {
      const oe = te.composedPath()[0];
      te.context === this.context && oe !== this.host && (te.stopPropagation(), this.addCallback(te.callback, oe, te.subscribe));
    }, this.onProviderRequest = (te) => {
      const oe = te.composedPath()[0];
      if (te.context !== this.context || oe === this.host) return;
      const ne = /* @__PURE__ */ new Set();
      for (const [re, { consumerHost: ce }] of this.subscriptions) ne.has(re) || (ne.add(re), ce.dispatchEvent(new s$4(this.context, re, !0)));
      te.stopPropagation();
    }, this.host = L, A.context !== void 0 ? this.context = A.context : this.context = A, this.attachListeners(), (J = (X = this.host).addController) == null || J.call(X, this);
  }
  attachListeners() {
    this.host.addEventListener("context-request", this.onContextRequest), this.host.addEventListener("context-provider", this.onProviderRequest);
  }
  hostConnected() {
    this.host.dispatchEvent(new e$3(this.context));
  }
};
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
function e$2({ context: C }) {
  return (L, A) => {
    const W = /* @__PURE__ */ new WeakMap();
    if (typeof A == "object") return A.addInitializer(function() {
      W.set(this, new i$2(this, { context: C }));
    }), { get() {
      return L.get.call(this);
    }, set(X) {
      var J;
      return (J = W.get(this)) == null || J.setValue(X), L.set.call(this, X);
    }, init(X) {
      var J;
      return (J = W.get(this)) == null || J.setValue(X), X;
    } };
    {
      L.constructor.addInitializer((te) => {
        W.set(te, new i$2(te, { context: C }));
      });
      const X = Object.getOwnPropertyDescriptor(L, A);
      let J;
      if (X === void 0) {
        const te = /* @__PURE__ */ new WeakMap();
        J = { get() {
          return te.get(this);
        }, set(oe) {
          W.get(this).setValue(oe), te.set(this, oe);
        }, configurable: !0, enumerable: !0 };
      } else {
        const te = X.set;
        J = { ...X, set(oe) {
          W.get(this).setValue(oe), te == null || te.call(this, oe);
        } };
      }
      return void Object.defineProperty(L, A, J);
    }
  };
}
/**
 * @license
 * Copyright 2022 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
function c$1({ context: C, subscribe: L }) {
  return (A, W) => {
    typeof W == "object" ? W.addInitializer(function() {
      new s$3(this, { context: C, callback: (X) => {
        A.set.call(this, X);
      }, subscribe: L });
    }) : A.constructor.addInitializer((X) => {
      new s$3(X, { context: C, callback: (J) => {
        X[W] = J;
      }, subscribe: L });
    });
  };
}
var __defProp$d = Object.defineProperty, __decorateClass$d = (C, L, A, W) => {
  for (var X = void 0, J = C.length - 1, te; J >= 0; J--)
    (te = C[J]) && (X = te(L, A, X) || X);
  return X && __defProp$d(L, A, X), X;
};
const rootContext = Symbol("rootContext");
class LoggerImplementation extends h$1 {
  doThing() {
    var L;
    (L = this.logger) == null || L.log("Hello, world!");
  }
}
__decorateClass$d([
  c$1({ context: rootContext, subscribe: !0 }),
  n$1({ attribute: !1 })
], LoggerImplementation.prototype, "logger");
class ReactiveController {
  constructor(L) {
    this.host = L, this.host.addController(this);
  }
  hostConnected() {
    if (!this.host.shadowRoot)
      throw new Error("Shadow root not found");
    this.host.shadowRoot.addEventListener("slotchange", (L) => this.handleSlotChange(L));
  }
  hostDisconnected() {
    if (!this.host.shadowRoot)
      throw new Error("Shadow root not found");
    this.host.shadowRoot.removeEventListener("slotchange", (L) => this.handleSlotChange(L));
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  handleSlotChange(L) {
    this.host.requestUpdate();
  }
}
const theming = '@import"https://fonts.googleapis.com/css2?family=Roboto:ital,wght@0,100;0,300;0,400;0,500;0,700;0,900;1,100;1,300;1,400;1,500;1,700;1,900&display=swap";:root,:host,.sl-theme-light{color-scheme:light;--sl-color-gray-50: hsl(0 0% 97.5%);--sl-color-gray-100: hsl(240 4.8% 95.9%);--sl-color-gray-200: hsl(240 5.9% 90%);--sl-color-gray-300: hsl(240 4.9% 83.9%);--sl-color-gray-400: hsl(240 5% 64.9%);--sl-color-gray-500: hsl(240 3.8% 46.1%);--sl-color-gray-600: hsl(240 5.2% 33.9%);--sl-color-gray-700: hsl(240 5.3% 26.1%);--sl-color-gray-800: hsl(240 3.7% 15.9%);--sl-color-gray-900: hsl(240 5.9% 10%);--sl-color-gray-950: hsl(240 7.3% 8%);--sl-color-red-50: hsl(0 85.7% 97.3%);--sl-color-red-100: hsl(0 93.3% 94.1%);--sl-color-red-200: hsl(0 96.3% 89.4%);--sl-color-red-300: hsl(0 93.5% 81.8%);--sl-color-red-400: hsl(0 90.6% 70.8%);--sl-color-red-500: hsl(0 84.2% 60.2%);--sl-color-red-600: hsl(0 72.2% 50.6%);--sl-color-red-700: hsl(0 73.7% 41.8%);--sl-color-red-800: hsl(0 70% 35.3%);--sl-color-red-900: hsl(0 62.8% 30.6%);--sl-color-red-950: hsl(0 60% 19.6%);--sl-color-orange-50: hsl(33.3 100% 96.5%);--sl-color-orange-100: hsl(34.3 100% 91.8%);--sl-color-orange-200: hsl(32.1 97.7% 83.1%);--sl-color-orange-300: hsl(30.7 97.2% 72.4%);--sl-color-orange-400: hsl(27 96% 61%);--sl-color-orange-500: hsl(24.6 95% 53.1%);--sl-color-orange-600: hsl(20.5 90.2% 48.2%);--sl-color-orange-700: hsl(17.5 88.3% 40.4%);--sl-color-orange-800: hsl(15 79.1% 33.7%);--sl-color-orange-900: hsl(15.3 74.6% 27.8%);--sl-color-orange-950: hsl(15.2 69.1% 19%);--sl-color-amber-50: hsl(48 100% 96.1%);--sl-color-amber-100: hsl(48 96.5% 88.8%);--sl-color-amber-200: hsl(48 96.6% 76.7%);--sl-color-amber-300: hsl(45.9 96.7% 64.5%);--sl-color-amber-400: hsl(43.3 96.4% 56.3%);--sl-color-amber-500: hsl(37.7 92.1% 50.2%);--sl-color-amber-600: hsl(32.1 94.6% 43.7%);--sl-color-amber-700: hsl(26 90.5% 37.1%);--sl-color-amber-800: hsl(22.7 82.5% 31.4%);--sl-color-amber-900: hsl(21.7 77.8% 26.5%);--sl-color-amber-950: hsl(22.9 74.1% 16.7%);--sl-color-yellow-50: hsl(54.5 91.7% 95.3%);--sl-color-yellow-100: hsl(54.9 96.7% 88%);--sl-color-yellow-200: hsl(52.8 98.3% 76.9%);--sl-color-yellow-300: hsl(50.4 97.8% 63.5%);--sl-color-yellow-400: hsl(47.9 95.8% 53.1%);--sl-color-yellow-500: hsl(45.4 93.4% 47.5%);--sl-color-yellow-600: hsl(40.6 96.1% 40.4%);--sl-color-yellow-700: hsl(35.5 91.7% 32.9%);--sl-color-yellow-800: hsl(31.8 81% 28.8%);--sl-color-yellow-900: hsl(28.4 72.5% 25.7%);--sl-color-yellow-950: hsl(33.1 69% 13.9%);--sl-color-lime-50: hsl(78.3 92% 95.1%);--sl-color-lime-100: hsl(79.6 89.1% 89.2%);--sl-color-lime-200: hsl(80.9 88.5% 79.6%);--sl-color-lime-300: hsl(82 84.5% 67.1%);--sl-color-lime-400: hsl(82.7 78% 55.5%);--sl-color-lime-500: hsl(83.7 80.5% 44.3%);--sl-color-lime-600: hsl(84.8 85.2% 34.5%);--sl-color-lime-700: hsl(85.9 78.4% 27.3%);--sl-color-lime-800: hsl(86.3 69% 22.7%);--sl-color-lime-900: hsl(87.6 61.2% 20.2%);--sl-color-lime-950: hsl(86.5 60.6% 13.9%);--sl-color-green-50: hsl(138.5 76.5% 96.7%);--sl-color-green-100: hsl(140.6 84.2% 92.5%);--sl-color-green-200: hsl(141 78.9% 85.1%);--sl-color-green-300: hsl(141.7 76.6% 73.1%);--sl-color-green-400: hsl(141.9 69.2% 58%);--sl-color-green-500: hsl(142.1 70.6% 45.3%);--sl-color-green-600: hsl(142.1 76.2% 36.3%);--sl-color-green-700: hsl(142.4 71.8% 29.2%);--sl-color-green-800: hsl(142.8 64.2% 24.1%);--sl-color-green-900: hsl(143.8 61.2% 20.2%);--sl-color-green-950: hsl(144.3 60.7% 12%);--sl-color-emerald-50: hsl(151.8 81% 95.9%);--sl-color-emerald-100: hsl(149.3 80.4% 90%);--sl-color-emerald-200: hsl(152.4 76% 80.4%);--sl-color-emerald-300: hsl(156.2 71.6% 66.9%);--sl-color-emerald-400: hsl(158.1 64.4% 51.6%);--sl-color-emerald-500: hsl(160.1 84.1% 39.4%);--sl-color-emerald-600: hsl(161.4 93.5% 30.4%);--sl-color-emerald-700: hsl(162.9 93.5% 24.3%);--sl-color-emerald-800: hsl(163.1 88.1% 19.8%);--sl-color-emerald-900: hsl(164.2 85.7% 16.5%);--sl-color-emerald-950: hsl(164.3 87.5% 9.4%);--sl-color-teal-50: hsl(166.2 76.5% 96.7%);--sl-color-teal-100: hsl(167.2 85.5% 89.2%);--sl-color-teal-200: hsl(168.4 83.8% 78.2%);--sl-color-teal-300: hsl(170.6 76.9% 64.3%);--sl-color-teal-400: hsl(172.5 66% 50.4%);--sl-color-teal-500: hsl(173.4 80.4% 40%);--sl-color-teal-600: hsl(174.7 83.9% 31.6%);--sl-color-teal-700: hsl(175.3 77.4% 26.1%);--sl-color-teal-800: hsl(176.1 69.4% 21.8%);--sl-color-teal-900: hsl(175.9 60.8% 19%);--sl-color-teal-950: hsl(176.5 58.6% 11.4%);--sl-color-cyan-50: hsl(183.2 100% 96.3%);--sl-color-cyan-100: hsl(185.1 95.9% 90.4%);--sl-color-cyan-200: hsl(186.2 93.5% 81.8%);--sl-color-cyan-300: hsl(187 92.4% 69%);--sl-color-cyan-400: hsl(187.9 85.7% 53.3%);--sl-color-cyan-500: hsl(188.7 94.5% 42.7%);--sl-color-cyan-600: hsl(191.6 91.4% 36.5%);--sl-color-cyan-700: hsl(192.9 82.3% 31%);--sl-color-cyan-800: hsl(194.4 69.6% 27.1%);--sl-color-cyan-900: hsl(196.4 63.6% 23.7%);--sl-color-cyan-950: hsl(196.8 61% 16.1%);--sl-color-sky-50: hsl(204 100% 97.1%);--sl-color-sky-100: hsl(204 93.8% 93.7%);--sl-color-sky-200: hsl(200.6 94.4% 86.1%);--sl-color-sky-300: hsl(199.4 95.5% 73.9%);--sl-color-sky-400: hsl(198.4 93.2% 59.6%);--sl-color-sky-500: hsl(198.6 88.7% 48.4%);--sl-color-sky-600: hsl(200.4 98% 39.4%);--sl-color-sky-700: hsl(201.3 96.3% 32.2%);--sl-color-sky-800: hsl(201 90% 27.5%);--sl-color-sky-900: hsl(202 80.3% 23.9%);--sl-color-sky-950: hsl(202.3 73.8% 16.5%);--sl-color-blue-50: hsl(213.8 100% 96.9%);--sl-color-blue-100: hsl(214.3 94.6% 92.7%);--sl-color-blue-200: hsl(213.3 96.9% 87.3%);--sl-color-blue-300: hsl(211.7 96.4% 78.4%);--sl-color-blue-400: hsl(213.1 93.9% 67.8%);--sl-color-blue-500: hsl(217.2 91.2% 59.8%);--sl-color-blue-600: hsl(221.2 83.2% 53.3%);--sl-color-blue-700: hsl(224.3 76.3% 48%);--sl-color-blue-800: hsl(225.9 70.7% 40.2%);--sl-color-blue-900: hsl(224.4 64.3% 32.9%);--sl-color-blue-950: hsl(226.2 55.3% 18.4%);--sl-color-indigo-50: hsl(225.9 100% 96.7%);--sl-color-indigo-100: hsl(226.5 100% 93.9%);--sl-color-indigo-200: hsl(228 96.5% 88.8%);--sl-color-indigo-300: hsl(229.7 93.5% 81.8%);--sl-color-indigo-400: hsl(234.5 89.5% 73.9%);--sl-color-indigo-500: hsl(238.7 83.5% 66.7%);--sl-color-indigo-600: hsl(243.4 75.4% 58.6%);--sl-color-indigo-700: hsl(244.5 57.9% 50.6%);--sl-color-indigo-800: hsl(243.7 54.5% 41.4%);--sl-color-indigo-900: hsl(242.2 47.4% 34.3%);--sl-color-indigo-950: hsl(243.5 43.6% 22.9%);--sl-color-violet-50: hsl(250 100% 97.6%);--sl-color-violet-100: hsl(251.4 91.3% 95.5%);--sl-color-violet-200: hsl(250.5 95.2% 91.8%);--sl-color-violet-300: hsl(252.5 94.7% 85.1%);--sl-color-violet-400: hsl(255.1 91.7% 76.3%);--sl-color-violet-500: hsl(258.3 89.5% 66.3%);--sl-color-violet-600: hsl(262.1 83.3% 57.8%);--sl-color-violet-700: hsl(263.4 70% 50.4%);--sl-color-violet-800: hsl(263.4 69.3% 42.2%);--sl-color-violet-900: hsl(263.5 67.4% 34.9%);--sl-color-violet-950: hsl(265.1 61.5% 21.4%);--sl-color-purple-50: hsl(270 100% 98%);--sl-color-purple-100: hsl(268.7 100% 95.5%);--sl-color-purple-200: hsl(268.6 100% 91.8%);--sl-color-purple-300: hsl(269.2 97.4% 85.1%);--sl-color-purple-400: hsl(270 95.2% 75.3%);--sl-color-purple-500: hsl(270.7 91% 65.1%);--sl-color-purple-600: hsl(271.5 81.3% 55.9%);--sl-color-purple-700: hsl(272.1 71.7% 47.1%);--sl-color-purple-800: hsl(272.9 67.2% 39.4%);--sl-color-purple-900: hsl(273.6 65.6% 32%);--sl-color-purple-950: hsl(276 59.5% 16.5%);--sl-color-fuchsia-50: hsl(289.1 100% 97.8%);--sl-color-fuchsia-100: hsl(287 100% 95.5%);--sl-color-fuchsia-200: hsl(288.3 95.8% 90.6%);--sl-color-fuchsia-300: hsl(291.1 93.1% 82.9%);--sl-color-fuchsia-400: hsl(292 91.4% 72.5%);--sl-color-fuchsia-500: hsl(292.2 84.1% 60.6%);--sl-color-fuchsia-600: hsl(293.4 69.5% 48.8%);--sl-color-fuchsia-700: hsl(294.7 72.4% 39.8%);--sl-color-fuchsia-800: hsl(295.4 70.2% 32.9%);--sl-color-fuchsia-900: hsl(296.7 63.6% 28%);--sl-color-fuchsia-950: hsl(297.1 56.8% 14.5%);--sl-color-pink-50: hsl(327.3 73.3% 97.1%);--sl-color-pink-100: hsl(325.7 77.8% 94.7%);--sl-color-pink-200: hsl(325.9 84.6% 89.8%);--sl-color-pink-300: hsl(327.4 87.1% 81.8%);--sl-color-pink-400: hsl(328.6 85.5% 70.2%);--sl-color-pink-500: hsl(330.4 81.2% 60.4%);--sl-color-pink-600: hsl(333.3 71.4% 50.6%);--sl-color-pink-700: hsl(335.1 77.6% 42%);--sl-color-pink-800: hsl(335.8 74.4% 35.3%);--sl-color-pink-900: hsl(335.9 69% 30.4%);--sl-color-pink-950: hsl(336.2 65.4% 15.9%);--sl-color-rose-50: hsl(355.7 100% 97.3%);--sl-color-rose-100: hsl(355.6 100% 94.7%);--sl-color-rose-200: hsl(352.7 96.1% 90%);--sl-color-rose-300: hsl(352.6 95.7% 81.8%);--sl-color-rose-400: hsl(351.3 94.5% 71.4%);--sl-color-rose-500: hsl(349.7 89.2% 60.2%);--sl-color-rose-600: hsl(346.8 77.2% 49.8%);--sl-color-rose-700: hsl(345.3 82.7% 40.8%);--sl-color-rose-800: hsl(343.4 79.7% 34.7%);--sl-color-rose-900: hsl(341.5 75.5% 30.4%);--sl-color-rose-950: hsl(341.3 70.1% 17.1%);--sl-color-primary-50: var(--sl-color-sky-50);--sl-color-primary-100: var(--sl-color-sky-100);--sl-color-primary-200: var(--sl-color-sky-200);--sl-color-primary-300: var(--sl-color-sky-300);--sl-color-primary-400: var(--sl-color-sky-400);--sl-color-primary-500: var(--sl-color-sky-500);--sl-color-primary-600: var(--sl-color-sky-600);--sl-color-primary-700: var(--sl-color-sky-700);--sl-color-primary-800: var(--sl-color-sky-800);--sl-color-primary-900: var(--sl-color-sky-900);--sl-color-primary-950: var(--sl-color-sky-950);--sl-color-success-50: var(--sl-color-green-50);--sl-color-success-100: var(--sl-color-green-100);--sl-color-success-200: var(--sl-color-green-200);--sl-color-success-300: var(--sl-color-green-300);--sl-color-success-400: var(--sl-color-green-400);--sl-color-success-500: var(--sl-color-green-500);--sl-color-success-600: var(--sl-color-green-600);--sl-color-success-700: var(--sl-color-green-700);--sl-color-success-800: var(--sl-color-green-800);--sl-color-success-900: var(--sl-color-green-900);--sl-color-success-950: var(--sl-color-green-950);--sl-color-warning-50: var(--sl-color-amber-50);--sl-color-warning-100: var(--sl-color-amber-100);--sl-color-warning-200: var(--sl-color-amber-200);--sl-color-warning-300: var(--sl-color-amber-300);--sl-color-warning-400: var(--sl-color-amber-400);--sl-color-warning-500: var(--sl-color-amber-500);--sl-color-warning-600: var(--sl-color-amber-600);--sl-color-warning-700: var(--sl-color-amber-700);--sl-color-warning-800: var(--sl-color-amber-800);--sl-color-warning-900: var(--sl-color-amber-900);--sl-color-warning-950: var(--sl-color-amber-950);--sl-color-danger-50: var(--sl-color-red-50);--sl-color-danger-100: var(--sl-color-red-100);--sl-color-danger-200: var(--sl-color-red-200);--sl-color-danger-300: var(--sl-color-red-300);--sl-color-danger-400: var(--sl-color-red-400);--sl-color-danger-500: var(--sl-color-red-500);--sl-color-danger-600: var(--sl-color-red-600);--sl-color-danger-700: var(--sl-color-red-700);--sl-color-danger-800: var(--sl-color-red-800);--sl-color-danger-900: var(--sl-color-red-900);--sl-color-danger-950: var(--sl-color-red-950);--sl-color-neutral-50: var(--sl-color-gray-50);--sl-color-neutral-100: var(--sl-color-gray-100);--sl-color-neutral-200: var(--sl-color-gray-200);--sl-color-neutral-300: var(--sl-color-gray-300);--sl-color-neutral-400: var(--sl-color-gray-400);--sl-color-neutral-500: var(--sl-color-gray-500);--sl-color-neutral-600: var(--sl-color-gray-600);--sl-color-neutral-700: var(--sl-color-gray-700);--sl-color-neutral-800: var(--sl-color-gray-800);--sl-color-neutral-900: var(--sl-color-gray-900);--sl-color-neutral-950: var(--sl-color-gray-950);--sl-color-neutral-0: hsl(0, 0%, 100%);--sl-color-neutral-1000: hsl(0, 0%, 0%);--sl-border-radius-small: .1875rem;--sl-border-radius-medium: .25rem;--sl-border-radius-large: .5rem;--sl-border-radius-x-large: 1rem;--sl-border-radius-circle: 50%;--sl-border-radius-pill: 9999px;--sl-shadow-x-small: 0 1px 2px hsl(240 3.8% 46.1% / 6%);--sl-shadow-small: 0 1px 2px hsl(240 3.8% 46.1% / 12%);--sl-shadow-medium: 0 2px 4px hsl(240 3.8% 46.1% / 12%);--sl-shadow-large: 0 2px 8px hsl(240 3.8% 46.1% / 12%);--sl-shadow-x-large: 0 4px 16px hsl(240 3.8% 46.1% / 12%);--sl-spacing-3x-small: .125rem;--sl-spacing-2x-small: .25rem;--sl-spacing-x-small: .5rem;--sl-spacing-small: .75rem;--sl-spacing-medium: 1rem;--sl-spacing-large: 1.25rem;--sl-spacing-x-large: 1.75rem;--sl-spacing-2x-large: 2.25rem;--sl-spacing-3x-large: 3rem;--sl-spacing-4x-large: 4.5rem;--sl-transition-x-slow: 1s;--sl-transition-slow: .5s;--sl-transition-medium: .25s;--sl-transition-fast: .15s;--sl-transition-x-fast: 50ms;--sl-font-mono: SFMono-Regular, Consolas, "Liberation Mono", Menlo, monospace;--sl-font-sans: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";--sl-font-serif: Georgia, "Times New Roman", serif;--sl-font-size-2x-small: .625rem;--sl-font-size-x-small: .75rem;--sl-font-size-small: .875rem;--sl-font-size-medium: 1rem;--sl-font-size-large: 1.25rem;--sl-font-size-x-large: 1.5rem;--sl-font-size-2x-large: 2.25rem;--sl-font-size-3x-large: 3rem;--sl-font-size-4x-large: 4.5rem;--sl-font-weight-light: 300;--sl-font-weight-normal: 400;--sl-font-weight-semibold: 500;--sl-font-weight-bold: 700;--sl-letter-spacing-denser: -.03em;--sl-letter-spacing-dense: -.015em;--sl-letter-spacing-normal: normal;--sl-letter-spacing-loose: .075em;--sl-letter-spacing-looser: .15em;--sl-line-height-denser: 1;--sl-line-height-dense: 1.4;--sl-line-height-normal: 1.8;--sl-line-height-loose: 2.2;--sl-line-height-looser: 2.6;--sl-focus-ring-color: var(--sl-color-primary-600);--sl-focus-ring-style: solid;--sl-focus-ring-width: 3px;--sl-focus-ring: var(--sl-focus-ring-style) var(--sl-focus-ring-width) var(--sl-focus-ring-color);--sl-focus-ring-offset: 1px;--sl-button-font-size-small: var(--sl-font-size-x-small);--sl-button-font-size-medium: var(--sl-font-size-small);--sl-button-font-size-large: var(--sl-font-size-medium);--sl-input-height-small: 1.875rem;--sl-input-height-medium: 2.5rem;--sl-input-height-large: 3.125rem;--sl-input-background-color: var(--sl-color-neutral-0);--sl-input-background-color-hover: var(--sl-input-background-color);--sl-input-background-color-focus: var(--sl-input-background-color);--sl-input-background-color-disabled: var(--sl-color-neutral-100);--sl-input-border-color: var(--sl-color-neutral-300);--sl-input-border-color-hover: var(--sl-color-neutral-400);--sl-input-border-color-focus: var(--sl-color-primary-500);--sl-input-border-color-disabled: var(--sl-color-neutral-300);--sl-input-border-width: 1px;--sl-input-required-content: "*";--sl-input-required-content-offset: -2px;--sl-input-required-content-color: var(--sl-input-label-color);--sl-input-border-radius-small: var(--sl-border-radius-medium);--sl-input-border-radius-medium: var(--sl-border-radius-medium);--sl-input-border-radius-large: var(--sl-border-radius-medium);--sl-input-font-family: var(--sl-font-sans);--sl-input-font-weight: var(--sl-font-weight-normal);--sl-input-font-size-small: var(--sl-font-size-small);--sl-input-font-size-medium: var(--sl-font-size-medium);--sl-input-font-size-large: var(--sl-font-size-large);--sl-input-letter-spacing: var(--sl-letter-spacing-normal);--sl-input-color: var(--sl-color-neutral-700);--sl-input-color-hover: var(--sl-color-neutral-700);--sl-input-color-focus: var(--sl-color-neutral-700);--sl-input-color-disabled: var(--sl-color-neutral-900);--sl-input-icon-color: var(--sl-color-neutral-500);--sl-input-icon-color-hover: var(--sl-color-neutral-600);--sl-input-icon-color-focus: var(--sl-color-neutral-600);--sl-input-placeholder-color: var(--sl-color-neutral-500);--sl-input-placeholder-color-disabled: var(--sl-color-neutral-600);--sl-input-spacing-small: var(--sl-spacing-small);--sl-input-spacing-medium: var(--sl-spacing-medium);--sl-input-spacing-large: var(--sl-spacing-large);--sl-input-focus-ring-color: hsl(198.6 88.7% 48.4% / 40%);--sl-input-focus-ring-offset: 0;--sl-input-filled-background-color: var(--sl-color-neutral-100);--sl-input-filled-background-color-hover: var(--sl-color-neutral-100);--sl-input-filled-background-color-focus: var(--sl-color-neutral-100);--sl-input-filled-background-color-disabled: var(--sl-color-neutral-100);--sl-input-filled-color: var(--sl-color-neutral-800);--sl-input-filled-color-hover: var(--sl-color-neutral-800);--sl-input-filled-color-focus: var(--sl-color-neutral-700);--sl-input-filled-color-disabled: var(--sl-color-neutral-800);--sl-input-label-font-size-small: var(--sl-font-size-small);--sl-input-label-font-size-medium: var(--sl-font-size-medium);--sl-input-label-font-size-large: var(--sl-font-size-large);--sl-input-label-color: inherit;--sl-input-help-text-font-size-small: var(--sl-font-size-x-small);--sl-input-help-text-font-size-medium: var(--sl-font-size-small);--sl-input-help-text-font-size-large: var(--sl-font-size-medium);--sl-input-help-text-color: var(--sl-color-neutral-500);--sl-toggle-size-small: .875rem;--sl-toggle-size-medium: 1.125rem;--sl-toggle-size-large: 1.375rem;--sl-overlay-background-color: hsl(240 3.8% 46.1% / 33%);--sl-panel-background-color: var(--sl-color-neutral-0);--sl-panel-border-color: var(--sl-color-neutral-200);--sl-panel-border-width: 1px;--sl-tooltip-border-radius: var(--sl-border-radius-medium);--sl-tooltip-background-color: var(--sl-color-neutral-800);--sl-tooltip-color: var(--sl-color-neutral-0);--sl-tooltip-font-family: var(--sl-font-sans);--sl-tooltip-font-weight: var(--sl-font-weight-normal);--sl-tooltip-font-size: var(--sl-font-size-small);--sl-tooltip-line-height: var(--sl-line-height-dense);--sl-tooltip-padding: var(--sl-spacing-2x-small) var(--sl-spacing-x-small);--sl-tooltip-arrow-size: 6px;--sl-z-index-drawer: 700;--sl-z-index-dialog: 800;--sl-z-index-dropdown: 900;--sl-z-index-toast: 950;--sl-z-index-tooltip: 1000}@supports (scrollbar-gutter: stable){.sl-scroll-lock{scrollbar-gutter:var(--sl-scroll-lock-gutter)!important}.sl-scroll-lock body{overflow:hidden!important}}@supports not (scrollbar-gutter: stable){.sl-scroll-lock body{padding-right:var(--sl-scroll-lock-size)!important;overflow:hidden!important}}.sl-toast-stack{position:fixed;top:0;inset-inline-end:0;z-index:var(--sl-z-index-toast);width:28rem;max-width:100%;max-height:100%;overflow:auto}.sl-toast-stack sl-alert{margin:var(--sl-spacing-medium)}.sl-toast-stack sl-alert::part(base){box-shadow:var(--sl-shadow-large)}:host:fullscreen::backdrop{background-color:var(--oe-background-color)}:host,:root{--oe-theme-hue: 247deg;--oe-theme-saturation: 87%;--oe-theme-lightness: 54%;--oe-background-color: hsl(var(--oe-theme-hue), var(--oe-theme-saturation), 100%);--oe-font-color: hsl( var(--oe-theme-hue), calc(var(--oe-theme-saturation) - 50%), calc(var(--oe-theme-lightness) - 90%) );--oe-border-rounding: 6px;--oe-border-color: hsl(var(--oe-theme-hue), var(--oe-theme-saturation), calc(var(--oe-theme-lightness) - 10%));--oe-border-width: 2px;--oe-box-shadow: 1px 1px 1px currentcolor;--oe-backdrop-shadow: 3px 3px 4px;--oe-font-family: "Roboto", sans-serif;--oe-font-size: 11px;--oe-animation-time: .3s;--oe-spacing: .6em;--oe-primary-color: hsl(var(--oe-theme-hue), var(--oe-theme-saturation), var(--oe-theme-lightness));--oe-secondary-color: hsl(var(--oe-theme-hue), var(--oe-theme-saturation), calc(var(--oe-theme-lightness) + 25%));--oe-accent-color: hsl(var(--oe-theme-hue), var(--oe-theme-saturation), calc(var(--oe-theme-lightness) + 20%));--oe-info-color: hsl(207deg, calc(var(--oe-theme-saturation) + 45%), calc(var(--oe-theme-lightness) + 15%));--oe-warning-color: color-mix(in srgb, hsl(67, 80%, 46%) 85%, var(--oe-background-color));--oe-danger-color: color-mix(in srgb, hsl(0deg, 80%, 46%) 85%, var(--oe-background-color));--oe-selected-color: hsl( var(--oe-theme-hue), var(--oe-theme-saturation), max(calc(var(--oe-theme-lightness) + 25%), 90%) );--oe-panel-color: hsl( var(--oe-theme-hue), var(--oe-theme-saturation), max(calc(var(--oe-theme-lightness) + 43%), 96%) );--oe-font-color-lighter: color-mix(in srgb, var(--oe-font-color) 10%, var(--oe-background-color));--oe-panel-color-lighter: color-mix(in srgb, var(--oe-panel-color) 1%, var(--oe-background-color));--oe-mobile-breakpoint: 600px}*{font-family:var(--oe-font-family);font-weight:400}sl-icon{display:flex;font-size:calc(var(--oe-font-size) * 1.2);justify-items:center;align-items:center;padding:var(--oe-spacing)}sl-icon.large-icon{font-size:calc(var(--oe-font-size) * 1.5);padding:0}button:disabled,input:disabled{filter:grayscale(100%);opacity:.5;cursor:not-allowed}kbd{position:relative;display:inline-block;color:var(--oe-font-color);font-family:Courier New,Courier,monospace;text-align:center;font-weight:700;padding:.2rem;padding-left:.5em;padding-right:.5em;z-index:0;margin-top:.2rem;margin:.5rem;width:-moz-max-content;width:max-content}kbd:before{content:"";position:absolute;top:0;left:0;width:100%;height:100%;border-radius:.13em;background:radial-gradient(circle farthest-corner at top right,#ededed,#c8c8c8);box-shadow:.13em .13em 0 .1em #0003;z-index:-1}kbd:after{content:"";position:absolute;top:-.065em;left:-.065em;width:100%;height:100%;padding:.13em;border-radius:.15em;background:radial-gradient(circle farthest-corner at bottom right,#cacaca,#cacaca);box-shadow:.065em .065em .13em .13em #00000080;z-index:-2}a{text-decoration:underline;color:var(--oe-font-color)}a:hover{text-decoration:none}hr{border:0;height:1px;background-color:var(--oe-font-color-lighter)}dialog{position:relative;box-shadow:var(--oe-box-shadow);border:var(--oe-border-width) solid var(--oe-selected-color);min-width:70%;max-width:80%;max-height:100%;background-color:var(--oe-background-color);border-radius:var(--oe-border-rounding);padding:2rem;animation:fade-in .6s forwards}dialog dialog[open]{animation:fade-in .6s forwards}@media (max-width: 600px){dialog{max-width:100%;padding:1rem}}p{margin-top:.5rem;font-size:1rem;color:var(--oe-font-color)}input:not([type=checkbox],[type=radio]),textarea,select{box-shadow:0 0 0 1px var(--oe-secondary-color)}input:not([type=checkbox],[type=radio]):focus,textarea:focus,select:focus{box-shadow:0 0 0 2px var(--oe-selected-color)}input,textarea,select{font-size:1rem;padding:var(--oe-spacing);border:none;border-radius:var(--oe-border-rounding);background-color:var(--oe-panel-color-lighter);color:var(--oe-font-color)}input:focus,textarea:focus,select:focus{outline:none;border-color:var(--oe-selected-color);background-color:var(--oe-background-color)}input[type=number]{-moz-appearance:textfield;-webkit-appearance:none;appearance:textfield}input[type=range]{padding:0}input[type=checkbox],input[type=radio]{position:relative;accent-color:var(--oe-primary-color);width:1.2rem;height:1.2rem}label:has(input){display:flex;align-items:center;gap:var(--oe-spacing)}input[type=file]{position:relative;padding:.5rem;border:none}input[type=file]::file-selector-button{border:none;border-radius:var(--oe-border-rounding);color:var(--oe-font-color);font-weight:700;background-color:var(--oe-panel-color);padding:.5rem}button{--background-color: var(--oe-panel-color);--border: none;--ripple-color: color-mix(in srgb, var(--background-color) 90%, black);border:var(--border);border-radius:var(--oe-border-rounding);margin:.1rem;font-size:1em;max-width:-moz-max-content;max-width:max-content;padding:var(--oe-spacing);background-color:var(--background-color);transition:background var(--oe-animation-time),border var(--oe-animation-time);cursor:pointer}button:not(:disabled,.disabled){box-shadow:var(--oe-box-shadow)}button:hover:not(:disabled,.disabled){background:var(--background-color) radial-gradient(circle,transparent 1%,var(--background-color) 1%) center/15000%}button:active:not(:disabled,.disabled){background-color:var(--ripple-color);background-size:100%;transition:background 0s}button:focus{outline:var(--oe-border-width) solid var(--oe-selected-color)}.hidden{display:none}.disabled{filter:grayscale(100%);opacity:.5;cursor:not-allowed}.oe-btn-primary{border:var(--oe-border-width) solid var(--oe-primary-color)}.oe-btn-secondary{border:var(--oe-border-width) solid var(--oe-secondary-color)}.oe-btn-info{--border: var(--oe-border-width) solid var(--oe-info-color)}.oe-btn-danger{--background-color: var(--oe-danger-color);color:#fff}@keyframes fade-in{0%{opacity:0}to{opacity:1}}', AbstractComponent = (C) => {
  class L extends C {
    constructor(...W) {
      super(W), this.reactiveController = new ReactiveController(this);
    }
    static finalizeStyles(W) {
      const X = r$6(theming);
      let J = [X];
      return Array.isArray(W) ? J = [X, ...W] : W !== void 0 && (J = [X, W]), super.finalizeStyles(J);
    }
    // TODO: find out if we have to explicitly call hostConnected and hostDisconnected
    connectedCallback() {
      super.connectedCallback(), this.reactiveController.hostConnected();
    }
    disconnectedCallback() {
      super.disconnectedCallback(), this.reactiveController.hostDisconnected();
    }
  }
  return L;
}, axesStyles = ":host{position:relative;display:inline-block!important;width:100%}#wrapped-element{position:relative;padding-left:2rem;padding-bottom:1.5rem}svg{position:absolute;width:100%;height:100%;overflow:visible;z-index:1}svg line{shape-rendering:crispEdges}svg text{fill:var(--oe-font-color);stroke:none;font:11px sans-serif}svg g{stroke:currentColor}.grid-line{stroke-width:1;opacity:.4}:host::part(tick),:host::part(grid){color:#add8e6}";
var i$1 = Symbol.for("preact-signals");
function t() {
  if (s$1 > 1)
    s$1--;
  else {
    for (var C, L = !1; h !== void 0; ) {
      var A = h;
      for (h = void 0, f++; A !== void 0; ) {
        var W = A.o;
        if (A.o = void 0, A.f &= -3, !(8 & A.f) && c(A)) try {
          A.c();
        } catch (X) {
          L || (C = X, L = !0);
        }
        A = W;
      }
    }
    if (f = 0, s$1--, L) throw C;
  }
}
var o = void 0, h = void 0, s$1 = 0, f = 0, v = 0;
function e$1(C) {
  if (o !== void 0) {
    var L = C.n;
    if (L === void 0 || L.t !== o)
      return L = { i: 0, S: C, p: o.s, n: void 0, t: o, e: void 0, x: void 0, r: L }, o.s !== void 0 && (o.s.n = L), o.s = L, C.n = L, 32 & o.f && C.S(L), L;
    if (L.i === -1)
      return L.i = 0, L.n !== void 0 && (L.n.p = L.p, L.p !== void 0 && (L.p.n = L.n), L.p = o.s, L.n = void 0, o.s.n = L, o.s = L), L;
  }
}
function u(C) {
  this.v = C, this.i = 0, this.n = void 0, this.t = void 0;
}
u.prototype.brand = i$1;
u.prototype.h = function() {
  return !0;
};
u.prototype.S = function(C) {
  this.t !== C && C.e === void 0 && (C.x = this.t, this.t !== void 0 && (this.t.e = C), this.t = C);
};
u.prototype.U = function(C) {
  if (this.t !== void 0) {
    var L = C.e, A = C.x;
    L !== void 0 && (L.x = A, C.e = void 0), A !== void 0 && (A.e = L, C.x = void 0), C === this.t && (this.t = A);
  }
};
u.prototype.subscribe = function(C) {
  var L = this;
  return E(function() {
    var A = L.value, W = o;
    o = void 0;
    try {
      C(A);
    } finally {
      o = W;
    }
  });
};
u.prototype.valueOf = function() {
  return this.value;
};
u.prototype.toString = function() {
  return this.value + "";
};
u.prototype.toJSON = function() {
  return this.value;
};
u.prototype.peek = function() {
  var C = o;
  o = void 0;
  try {
    return this.value;
  } finally {
    o = C;
  }
};
Object.defineProperty(u.prototype, "value", { get: function() {
  var C = e$1(this);
  return C !== void 0 && (C.i = this.i), this.v;
}, set: function(C) {
  if (C !== this.v) {
    if (f > 100) throw new Error("Cycle detected");
    this.v = C, this.i++, v++, s$1++;
    try {
      for (var L = this.t; L !== void 0; L = L.x) L.t.N();
    } finally {
      t();
    }
  }
} });
function d(C) {
  return new u(C);
}
function c(C) {
  for (var L = C.s; L !== void 0; L = L.n) if (L.S.i !== L.i || !L.S.h() || L.S.i !== L.i) return !0;
  return !1;
}
function a(C) {
  for (var L = C.s; L !== void 0; L = L.n) {
    var A = L.S.n;
    if (A !== void 0 && (L.r = A), L.S.n = L, L.i = -1, L.n === void 0) {
      C.s = L;
      break;
    }
  }
}
function l(C) {
  for (var L = C.s, A = void 0; L !== void 0; ) {
    var W = L.p;
    L.i === -1 ? (L.S.U(L), W !== void 0 && (W.n = L.n), L.n !== void 0 && (L.n.p = W)) : A = L, L.S.n = L.r, L.r !== void 0 && (L.r = void 0), L = W;
  }
  C.s = A;
}
function y(C) {
  u.call(this, void 0), this.x = C, this.s = void 0, this.g = v - 1, this.f = 4;
}
(y.prototype = new u()).h = function() {
  if (this.f &= -3, 1 & this.f) return !1;
  if ((36 & this.f) == 32 || (this.f &= -5, this.g === v)) return !0;
  if (this.g = v, this.f |= 1, this.i > 0 && !c(this))
    return this.f &= -2, !0;
  var C = o;
  try {
    a(this), o = this;
    var L = this.x();
    (16 & this.f || this.v !== L || this.i === 0) && (this.v = L, this.f &= -17, this.i++);
  } catch (A) {
    this.v = A, this.f |= 16, this.i++;
  }
  return o = C, l(this), this.f &= -2, !0;
};
y.prototype.S = function(C) {
  if (this.t === void 0) {
    this.f |= 36;
    for (var L = this.s; L !== void 0; L = L.n) L.S.S(L);
  }
  u.prototype.S.call(this, C);
};
y.prototype.U = function(C) {
  if (this.t !== void 0 && (u.prototype.U.call(this, C), this.t === void 0)) {
    this.f &= -33;
    for (var L = this.s; L !== void 0; L = L.n) L.S.U(L);
  }
};
y.prototype.N = function() {
  if (!(2 & this.f)) {
    this.f |= 6;
    for (var C = this.t; C !== void 0; C = C.x) C.t.N();
  }
};
Object.defineProperty(y.prototype, "value", { get: function() {
  if (1 & this.f) throw new Error("Cycle detected");
  var C = e$1(this);
  if (this.h(), C !== void 0 && (C.i = this.i), 16 & this.f) throw this.v;
  return this.v;
} });
function w(C) {
  return new y(C);
}
function _(C) {
  var L = C.u;
  if (C.u = void 0, typeof L == "function") {
    s$1++;
    var A = o;
    o = void 0;
    try {
      L();
    } catch (W) {
      throw C.f &= -2, C.f |= 8, g$2(C), W;
    } finally {
      o = A, t();
    }
  }
}
function g$2(C) {
  for (var L = C.s; L !== void 0; L = L.n) L.S.U(L);
  C.x = void 0, C.s = void 0, _(C);
}
function p(C) {
  if (o !== this) throw new Error("Out-of-order effect");
  l(this), o = C, this.f &= -2, 8 & this.f && g$2(this), t();
}
function b(C) {
  this.x = C, this.u = void 0, this.s = void 0, this.o = void 0, this.f = 32;
}
b.prototype.c = function() {
  var C = this.S();
  try {
    if (8 & this.f || this.x === void 0) return;
    var L = this.x();
    typeof L == "function" && (this.u = L);
  } finally {
    C();
  }
};
b.prototype.S = function() {
  if (1 & this.f) throw new Error("Cycle detected");
  this.f |= 1, this.f &= -9, _(this), a(this), s$1++;
  var C = o;
  return o = this, p.bind(this, C);
};
b.prototype.N = function() {
  2 & this.f || (this.f |= 2, this.o = h, h = this);
};
b.prototype.d = function() {
  this.f |= 8, 1 & this.f || g$2(this);
};
function E(C) {
  var L = new b(C);
  try {
    L.c();
  } catch (A) {
    throw L.d(), A;
  }
  return L.d.bind(L);
}
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
function e(C) {
  return class extends C {
    performUpdate() {
      var L;
      if (this.isUpdatePending === !1) return;
      (L = this._$Oo) === null || L === void 0 || L.call(this);
      let A = !0;
      this._$Oo = E(() => {
        A ? (A = !1, super.performUpdate()) : this.requestUpdate();
      });
    }
    connectedCallback() {
      super.connectedCallback(), this.requestUpdate();
    }
    disconnectedCallback() {
      var L;
      super.disconnectedCallback(), (L = this._$Oo) === null || L === void 0 || L.call(this);
    }
  };
}
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const s = e$4(class extends $t {
  render(C) {
    var L;
    if (C !== this._$Oi) {
      (L = this._$Oo) === null || L === void 0 || L.call(this), this._$Oi = C;
      let A = !0;
      this._$Oo = C.subscribe((W) => {
        A === !1 && this.setValue(W);
      }), A = !1;
    }
    return C.peek();
  }
  disconnected() {
    var C;
    (C = this._$Oo) === null || C === void 0 || C.call(this);
  }
  reconnected() {
    var C;
    this._$Oo = (C = this._$Oi) === null || C === void 0 ? void 0 : C.subscribe((L) => {
      this.setValue(L);
    });
  }
}), booleanConverter = (C) => C !== null && C !== "false", tagArrayConverter = (C) => C === null ? [] : C.split(",").map((L) => ({ text: L.trim() })), tagConverter = (C) => C === null ? { text: "" } : { text: C }, callbackConverter = (C) => typeof C == "string" ? new Function(C) : C, enumConverter = (C) => (L) => {
  const A = L.toLowerCase(), W = Object.keys(C).find((X) => X.toLowerCase() === A);
  if (W)
    return C[W];
};
function queryDeeplyAssignedElement(C) {
  return (L, A) => {
    Object.defineProperty(L, A, {
      get() {
        var te;
        const X = `slot${C.slot ?? ""}`, J = (te = this.renderRoot) == null ? void 0 : te.querySelectorAll(X);
        for (const oe of J) {
          const ne = oe.assignedElements();
          for (const re of ne) {
            if (re.matches(C.selector))
              return re;
            const ce = re.querySelector(C.selector);
            if (ce !== null)
              return ce;
          }
        }
        return null;
      }
    });
  };
}
function queryParentElement(C) {
  const L = (A) => {
    var W;
    return A.matches(C.selector) ? A : A.parentElement ? L(A.parentElement) : (W = A.getRootNode()) != null && W.host ? L(A.getRootNode().host) : null;
  };
  return (A, W) => {
    Object.defineProperty(A, W, {
      get() {
        const J = C.root ?? this;
        return L(J);
      }
    });
  };
}
function required() {
  return (C, L) => {
    const A = C.updated;
    C.updated = function(W) {
      if (this[L] === void 0)
        throw new Error(`Property ${L} is required by ${C.constructor.name} but is not set.`);
      A == null || A.call(this, W);
    };
  };
}
function hertzToMHertz(C) {
  return C / 1e3;
}
var __defProp$c = Object.defineProperty, __getOwnPropDesc$c = Object.getOwnPropertyDescriptor, __decorateClass$c = (C, L, A, W) => {
  for (var X = W > 1 ? void 0 : W ? __getOwnPropDesc$c(L, A) : L, J = C.length - 1, te; J >= 0; J--)
    (te = C[J]) && (X = (W ? te(L, A, X) : te(X)) || X);
  return W && X && __defProp$c(L, A, X), X;
};
let AxesComponent = class extends e(AbstractComponent(h$1)) {
  constructor() {
    super(...arguments), this.xTitle = "Time (Seconds)", this.yTitle = "Frequency (KHz)", this.showXTitle = !0, this.showYTitle = !0, this.showXAxis = !0, this.showYAxis = !0, this.showXGrid = !0, this.showYGrid = !0, this.visible = !0;
  }
  // because label padding is a relative fraction, we need to calculate the
  // actual pixel value of the padding
  get labelPadding() {
    const C = this.emUnitFontSize;
    return {
      width: C.width * AxesComponent.labelPadding,
      height: C.height * AxesComponent.labelPadding
    };
  }
  get tickSize() {
    const C = this.emUnitFontSize;
    return {
      width: C.width * AxesComponent.tickSize,
      height: C.height * AxesComponent.tickSize
    };
  }
  get titleOffset() {
    const C = this.emUnitFontSize;
    return {
      width: C.width * AxesComponent.titleOffset,
      height: C.height * AxesComponent.titleOffset
    };
  }
  firstUpdated() {
    this.emUnitFontSize = this.calculateFontSize("M");
  }
  handleSlotChange() {
    this.spectrogram.unitConverters && (this.unitConverter = this.spectrogram.unitConverters.value, this.unitConverter.canvasSize.subscribe(this.handleCanvasResize));
  }
  handleCanvasResize(C) {
    if (this != null && this.wrappedElement) {
      const { width: L, height: A } = C;
      this.wrappedElement.style.width = `${L}px`, this.wrappedElement.style.height = `${A}px`;
    }
  }
  // because querying the DOM for the font size will cause a repaint and reflow
  // we calculate the value once using a canvas
  calculateFontSize(C) {
    const A = document.createElement("canvas").getContext("2d");
    A.font = "var(--oe-font-size) var(--oe-font-family)";
    const W = A.measureText(C), X = W.width, J = W.actualBoundingBoxAscent + W.actualBoundingBoxDescent;
    return { width: X, height: J };
  }
  createGridLinesTemplate(C, L, A) {
    const W = (oe) => {
      const ne = this.unitConverter.scaleX.value(oe);
      return Oe`<line
        x1="${ne}"
        x2="${ne}"
        y1="0"
        y2="${A.height}"
        class="grid-line"
      ></line>`;
    }, X = (oe) => {
      const ne = this.unitConverter.scaleY.value(oe);
      return Oe`<line
        x1="0"
        x2="${A.width}"
        y1="${ne}"
        y2="${ne}"
        class="grid-line"
      ></line>`;
    }, J = Oe`${C.map(
      (oe, ne) => Oe`${ne > 0 && ne < C.length - 1 ? W(oe) : D}`
    )}`, te = Oe`${L.map(
      (oe, ne) => Oe`${ne > 0 && ne < L.length - 1 ? X(oe) : D}`
    )}`;
    return Oe`
      <g g part = "grid" >
        ${this.showXGrid ? Oe`<g part="x-grid">${J}</g>` : D}
        ${this.showYGrid ? Oe`<g part="y-grid">${te}</g>` : D}
      </g>
    `;
  }
  // TODO: We should probably refactor this so that we only calculate the font size
  // once per each unique length of strings
  createAxisLabelsTemplate(C, L, A) {
    const W = this.calculateFontSize(this.xTitle), X = this.calculateFontSize(this.yTitle), J = Math.max(...L.map(hertzToMHertz)).toFixed(1), te = this.calculateFontSize(J), oe = W.height + te.height + this.tickSize.height + this.titleOffset.height, ne = X.height + te.width, re = (me) => {
      const Me = this.unitConverter.scaleX.value(me), he = A.height + this.tickSize.height, ge = A.height;
      return Oe`
        <g>
          <line
            part="x-tick"
            x = "${Me}"
            y1 = "${ge}"
            y2 = "${ge + this.tickSize.height}"
          ></line>
          <text
            part="x-label"
            text-anchor="middle"
            dominant-baseline="end"
            x="${Me}"
            y="${he + this.tickSize.height}"
          >
            ${me.toFixed(1)}
          </text>
      </g>
      `;
    }, ce = (me) => {
      const Me = -this.tickSize, he = this.unitConverter.scaleY.value(me), ge = hertzToMHertz(me);
      return Oe`<g>
        <line
          part="y-tick"
          x1="${Me}"
          x2="${Me + this.tickSize.width}"
          y="${he}"
        ></line>
        <text
          part="y-label"
          text-anchor="end"
          dominant-baseline="middle"
          x="${Me - this.labelPadding.width}"
          y="${he}"
        >
          ${ge.toFixed(1)}
        </text>
      </g>`;
    }, ue = this.showXAxis ? Oe`${C.map((me) => re(me))}` : D, de = this.showYAxis ? Oe`${L.map((me) => ce(me))}` : D, be = this.showXTitle ? Oe`
      <text
        part="title x-title"
        x="${A.width / 2}"
        y="${A.height + oe}"
        text-anchor="middle"
        font-family="sans-serif"
      >
        ${this.xTitle}
      </text>
    ` : D, pe = this.showYTitle ? Oe`
      <text
        part="title y-title"
        x="-${ne}"
        y="${A.height / 2}"
        transform="rotate(270, -${ne}, ${A.height / 2})"
        text-anchor="middle"
        font-family="sans-serif"
      >
        ${this.yTitle}
      </text>
    ` : D;
    return Oe`
      <g part="tick">
        <g part="x-ticks">
          ${ue}
          ${be}
        </g>

        <g part="y-ticks">
          ${de}
          ${pe}
        </g>
      </g>
    `;
  }
  xValues() {
    const C = this.xStepOverride || this.calculateStep(
      this.unitConverter.temporalDomain.value,
      this.unitConverter.temporalRange.value,
      this.unitConverter.scaleX.value,
      "width"
    );
    return this.generateAxisValues(
      this.unitConverter.renderWindow.value.startOffset,
      this.unitConverter.renderWindow.value.endOffset,
      C,
      this.unitConverter.scaleX.value
    );
  }
  yValues() {
    const C = this.yStepOverride || this.calculateStep(
      this.unitConverter.frequencyDomain.value,
      this.unitConverter.frequencyRange.value,
      this.unitConverter.scaleY.value,
      "height"
    );
    return this.generateAxisValues(
      this.unitConverter.renderWindow.value.lowFrequency,
      this.unitConverter.renderWindow.value.highFrequency,
      C,
      this.unitConverter.scaleY.value,
      !1
    );
  }
  willFitStep(C, L, A, W, X, J) {
    const te = W * AxesComponent.labelPadding;
    if (!J) {
      const ue = A[1] - A[0];
      return Math.ceil(ue / C) * (W + te) < L;
    }
    const re = this.generateAxisValues(A[0], A[1], C, X, !1).slice(-2).map((ue) => X(ue));
    return re[0] - re[1] > W + te;
  }
  // the calculate step function will use a binary search to find the largest
  // "nice" factor that will fit the axis
  calculateStep(C, L, A, W) {
    const X = [50, 20, 10, 5, 2, 1, 0.5, 0.2, 0.1, 0.05, 0.02], te = this.calculateFontSize("0.0")[W] + this.labelPadding[W], oe = C[1] - C[0], ne = Math.abs(L[1] - L[0]), re = oe / 2 + C[0], ce = Math.pow(10, Math.floor(Math.log10(re)));
    for (const ue of X) {
      const de = ce / ue;
      if (this.willFitStep(
        de,
        ne,
        C,
        te,
        A,
        W === "height" ? this.unitConverter.melScale.value : !1
      ))
        return de;
    }
    return ce;
  }
  generateAxisValues(C, L, A, W, X = !0) {
    const J = [];
    for (let pe = C; pe < L; pe += A)
      J.push(pe);
    if (!X)
      return J;
    const te = J.at(-1) ?? 0, oe = L, ne = W(te), re = W(oe), ce = Math.abs(ne - re), ue = this.emUnitFontSize, de = ue.width * AxesComponent.labelPadding;
    return ce < ue.width + de && J.length > 0 && J.pop(), J.push(L), J;
  }
  axesTemplate() {
    const C = this.xValues(), L = this.yValues(), A = this.unitConverter.canvasSize.value, W = this.createGridLinesTemplate(C, L, A), X = this.createAxisLabelsTemplate(C, L, A);
    return ke$1`<svg>${W} ${X}</svg>`;
  }
  render() {
    return ke$1`
      <div id="wrapped-element">
        ${this.visible && this.unitConverter ? this.axesTemplate() : D}
        <slot @slotchange="${this.handleSlotChange}"></slot>
      </div>
    `;
  }
};
AxesComponent.styles = r$6(axesStyles);
AxesComponent.labelPadding = 0.25;
AxesComponent.tickSize = 0.75;
AxesComponent.titleOffset = 0.25;
AxesComponent.fontCanvas = document.createElement("canvas");
__decorateClass$c([
  n$1({ attribute: "x-step", type: Number, reflect: !0 })
], AxesComponent.prototype, "xStepOverride", 2);
__decorateClass$c([
  n$1({ attribute: "y-step", type: Number, reflect: !0 })
], AxesComponent.prototype, "yStepOverride", 2);
__decorateClass$c([
  n$1({ attribute: "x-title", type: String, reflect: !0 })
], AxesComponent.prototype, "xTitle", 2);
__decorateClass$c([
  n$1({ attribute: "y-title", type: String, reflect: !0 })
], AxesComponent.prototype, "yTitle", 2);
__decorateClass$c([
  n$1({ attribute: "x-title-visible", converter: booleanConverter })
], AxesComponent.prototype, "showXTitle", 2);
__decorateClass$c([
  n$1({ attribute: "y-title-visible", converter: booleanConverter })
], AxesComponent.prototype, "showYTitle", 2);
__decorateClass$c([
  n$1({ attribute: "x-axis", converter: booleanConverter })
], AxesComponent.prototype, "showXAxis", 2);
__decorateClass$c([
  n$1({ attribute: "y-axis", converter: booleanConverter })
], AxesComponent.prototype, "showYAxis", 2);
__decorateClass$c([
  n$1({ attribute: "x-grid", converter: booleanConverter })
], AxesComponent.prototype, "showXGrid", 2);
__decorateClass$c([
  n$1({ attribute: "y-grid", converter: booleanConverter })
], AxesComponent.prototype, "showYGrid", 2);
__decorateClass$c([
  n$1({ type: Boolean, converter: booleanConverter })
], AxesComponent.prototype, "visible", 2);
__decorateClass$c([
  queryDeeplyAssignedElement({ selector: "oe-spectrogram" })
], AxesComponent.prototype, "spectrogram", 2);
__decorateClass$c([
  e$6("#wrapped-element")
], AxesComponent.prototype, "wrappedElement", 2);
AxesComponent = __decorateClass$c([
  t$4("oe-axes")
], AxesComponent);
const sinc = (C) => Math.sin(Math.PI * C) / (Math.PI * C), bessi0 = (C) => {
  const L = Math.abs(C);
  if (L < 3.75) {
    const A = C / 3.75 * (C / 3.75);
    return 1 + A * (3.5156229 + A * (3.0899424 + A * (1.2067492 + A * (0.2659732 + A * (0.0360768 + A * 45813e-7)))));
  } else {
    const A = 3.75 / L;
    return Math.exp(L) / Math.sqrt(L) * (0.39894228 + A * (0.01328592 + A * (225319e-8 + A * (-157565e-8 + A * (916281e-8 + A * (-0.02057706 + A * (0.02635537 + A * (-0.01647633 + A * 392377e-8))))))));
  }
}, windows = {
  hann: (C, L) => 0.5 - 0.5 * Math.cos(2 * Math.PI * C / (L - 1)),
  hamming: (C, L) => 0.54 - 0.46 * Math.cos(2 * Math.PI * C / (L - 1)),
  cosine: (C, L) => Math.sin(Math.PI * C / (L - 1)),
  lanczos: (C, L) => sinc(2 * C / (L - 1) - 1),
  gaussian: (C, L, A = 0.4) => Math.pow(Math.E, -0.5 * Math.pow((C - (L - 1) / 2) / (A * (L - 1) / 2), 2)),
  tukey: (C, L, A = 0.5) => C < 0.5 * A * (L - 1) ? 0.5 * (1 + Math.cos(Math.PI * (2 * C / (A * (L - 1)) - 1))) : C < (1 - 0.5 * A) * (L - 1) ? 1 : 0.5 * (1 + Math.cos(Math.PI * (2 * C / (A * (L - 1)) + 1 - 2 / A))),
  blackman: (C, L) => 0.42 - 0.5 * Math.cos(2 * Math.PI * C / (L - 1)) + 0.08 * Math.cos(4 * Math.PI * C / (L - 1)),
  exact_blackman: (C, L) => 0.4243801 - 0.4973406 * Math.cos(2 * Math.PI * C / (L - 1)) + 0.0782793 * Math.cos(4 * Math.PI * C / (L - 1)),
  kaiser: (C, L, A = 3) => bessi0(Math.PI * A * Math.sqrt(1 - Math.pow(2 * C / (L - 1) - 1, 2))) / bessi0(Math.PI * A),
  nuttall: (C, L) => 0.355768 - 0.487396 * Math.cos(2 * Math.PI * C / (L - 1)) + 0.144232 * Math.cos(4 * Math.PI * C / (L - 1)) - 0.012604 * Math.cos(6 * Math.PI * C / (L - 1)),
  blackman_harris: (C, L) => 0.35875 - 0.48829 * Math.cos(2 * Math.PI * C / (L - 1)) + 0.14128 * Math.cos(4 * Math.PI * C / (L - 1)) - 0.01168 * Math.cos(6 * Math.PI * C / (L - 1)),
  blackman_nuttall: (C, L) => 0.3635819 - 0.3635819 * Math.cos(2 * Math.PI * C / (L - 1)) + 0.1365995 * Math.cos(4 * Math.PI * C / (L - 1)) - 0.0106411 * Math.cos(6 * Math.PI * C / (L - 1)),
  flat_top: (C, L) => 1 - 1.93 * Math.cos(2 * Math.PI * C / (L - 1)) + 1.29 * Math.cos(4 * Math.PI * C / (L - 1)) - 0.388 * Math.cos(6 * Math.PI * C / (L - 1)) + 0.032 * Math.cos(8 * Math.PI * C / (L - 1))
}, applyWindowFunction = (C, L, A) => {
  const W = C.length;
  for (let X = 0; X < W; ++X)
    C[X] *= L(X, W, A);
  return C;
}, create_window_function = (C) => (L, A) => applyWindowFunction(L, windows[C], A), hann = create_window_function("hann"), hamming = create_window_function("hamming"), cosine = create_window_function("cosine"), lanczos = create_window_function("lanczos"), gaussian = create_window_function("gaussian"), tukey = create_window_function("tukey"), blackman = create_window_function("blackman"), exact_blackman = create_window_function("exact_blackman"), kaiser = create_window_function("kaiser"), nuttall = create_window_function("nuttall"), blackman_harris = create_window_function("blackman_harris"), blackman_nuttall = create_window_function("blackman_nuttall"), flat_top = create_window_function("flat_top"), windowFunctions = /* @__PURE__ */ new Map([
  ["hann", hann],
  ["hamming", hamming],
  ["cosine", cosine],
  ["lanczos", lanczos],
  ["gaussian", gaussian],
  ["tukey", tukey],
  ["blackman", blackman],
  ["exact_blackman", exact_blackman],
  ["kaiser", kaiser],
  ["nuttall", nuttall],
  ["blackman_harris", blackman_harris],
  ["blackman_nuttall", blackman_nuttall],
  ["flat_top", flat_top]
]), limit = (C, L = 0, A = 1) => min$3(max$4(L, C), A), clip_rgb = (C) => {
  C._clipped = !1, C._unclipped = C.slice(0);
  for (let L = 0; L <= 3; L++)
    L < 3 ? ((C[L] < 0 || C[L] > 255) && (C._clipped = !0), C[L] = limit(C[L], 0, 255)) : L === 3 && (C[L] = limit(C[L], 0, 1));
  return C;
}, classToType = {};
for (let C of [
  "Boolean",
  "Number",
  "String",
  "Function",
  "Array",
  "Date",
  "RegExp",
  "Undefined",
  "Null"
])
  classToType[`[object ${C}]`] = C.toLowerCase();
function type$2(C) {
  return classToType[Object.prototype.toString.call(C)] || "object";
}
const unpack = (C, L = null) => C.length >= 3 ? Array.prototype.slice.call(C) : type$2(C[0]) == "object" && L ? L.split("").filter((A) => C[0][A] !== void 0).map((A) => C[0][A]) : C[0], last = (C) => {
  if (C.length < 2) return null;
  const L = C.length - 1;
  return type$2(C[L]) == "string" ? C[L].toLowerCase() : null;
}, { PI: PI$2, min: min$3, max: max$4 } = Math, TWOPI = PI$2 * 2, PITHIRD = PI$2 / 3, DEG2RAD = PI$2 / 180, RAD2DEG = 180 / PI$2, input = {
  format: {},
  autodetect: []
};
class Color {
  constructor(...L) {
    const A = this;
    if (type$2(L[0]) === "object" && L[0].constructor && L[0].constructor === this.constructor)
      return L[0];
    let W = last(L), X = !1;
    if (!W) {
      X = !0, input.sorted || (input.autodetect = input.autodetect.sort((J, te) => te.p - J.p), input.sorted = !0);
      for (let J of input.autodetect)
        if (W = J.test(...L), W) break;
    }
    if (input.format[W]) {
      const J = input.format[W].apply(
        null,
        X ? L : L.slice(0, -1)
      );
      A._rgb = clip_rgb(J);
    } else
      throw new Error("unknown format: " + L);
    A._rgb.length === 3 && A._rgb.push(1);
  }
  toString() {
    return type$2(this.hex) == "function" ? this.hex() : `[${this._rgb.join(",")}]`;
  }
}
const version = "2.6.0", chroma = (...C) => new chroma.Color(...C);
chroma.Color = Color;
chroma.version = version;
const cmyk2rgb = (...C) => {
  C = unpack(C, "cmyk");
  const [L, A, W, X] = C, J = C.length > 4 ? C[4] : 1;
  return X === 1 ? [0, 0, 0, J] : [
    L >= 1 ? 0 : 255 * (1 - L) * (1 - X),
    // r
    A >= 1 ? 0 : 255 * (1 - A) * (1 - X),
    // g
    W >= 1 ? 0 : 255 * (1 - W) * (1 - X),
    // b
    J
  ];
}, { max: max$3 } = Math, rgb2cmyk = (...C) => {
  let [L, A, W] = unpack(C, "rgb");
  L = L / 255, A = A / 255, W = W / 255;
  const X = 1 - max$3(L, max$3(A, W)), J = X < 1 ? 1 / (1 - X) : 0, te = (1 - L - X) * J, oe = (1 - A - X) * J, ne = (1 - W - X) * J;
  return [te, oe, ne, X];
};
Color.prototype.cmyk = function() {
  return rgb2cmyk(this._rgb);
};
chroma.cmyk = (...C) => new Color(...C, "cmyk");
input.format.cmyk = cmyk2rgb;
input.autodetect.push({
  p: 2,
  test: (...C) => {
    if (C = unpack(C, "cmyk"), type$2(C) === "array" && C.length === 4)
      return "cmyk";
  }
});
const rnd = (C) => Math.round(C * 100) / 100, hsl2css = (...C) => {
  const L = unpack(C, "hsla");
  let A = last(C) || "lsa";
  return L[0] = rnd(L[0] || 0), L[1] = rnd(L[1] * 100) + "%", L[2] = rnd(L[2] * 100) + "%", A === "hsla" || L.length > 3 && L[3] < 1 ? (L[3] = L.length > 3 ? L[3] : 1, A = "hsla") : L.length = 3, `${A}(${L.join(",")})`;
}, rgb2hsl$1 = (...C) => {
  C = unpack(C, "rgba");
  let [L, A, W] = C;
  L /= 255, A /= 255, W /= 255;
  const X = min$3(L, A, W), J = max$4(L, A, W), te = (J + X) / 2;
  let oe, ne;
  return J === X ? (oe = 0, ne = Number.NaN) : oe = te < 0.5 ? (J - X) / (J + X) : (J - X) / (2 - J - X), L == J ? ne = (A - W) / (J - X) : A == J ? ne = 2 + (W - L) / (J - X) : W == J && (ne = 4 + (L - A) / (J - X)), ne *= 60, ne < 0 && (ne += 360), C.length > 3 && C[3] !== void 0 ? [ne, oe, te, C[3]] : [ne, oe, te];
}, { round: round$6 } = Math, rgb2css = (...C) => {
  const L = unpack(C, "rgba");
  let A = last(C) || "rgb";
  return A.substr(0, 3) == "hsl" ? hsl2css(rgb2hsl$1(L), A) : (L[0] = round$6(L[0]), L[1] = round$6(L[1]), L[2] = round$6(L[2]), (A === "rgba" || L.length > 3 && L[3] < 1) && (L[3] = L.length > 3 ? L[3] : 1, A = "rgba"), `${A}(${L.slice(0, A === "rgb" ? 3 : 4).join(",")})`);
}, { round: round$5 } = Math, hsl2rgb = (...C) => {
  C = unpack(C, "hsl");
  const [L, A, W] = C;
  let X, J, te;
  if (A === 0)
    X = J = te = W * 255;
  else {
    const oe = [0, 0, 0], ne = [0, 0, 0], re = W < 0.5 ? W * (1 + A) : W + A - W * A, ce = 2 * W - re, ue = L / 360;
    oe[0] = ue + 1 / 3, oe[1] = ue, oe[2] = ue - 1 / 3;
    for (let de = 0; de < 3; de++)
      oe[de] < 0 && (oe[de] += 1), oe[de] > 1 && (oe[de] -= 1), 6 * oe[de] < 1 ? ne[de] = ce + (re - ce) * 6 * oe[de] : 2 * oe[de] < 1 ? ne[de] = re : 3 * oe[de] < 2 ? ne[de] = ce + (re - ce) * (2 / 3 - oe[de]) * 6 : ne[de] = ce;
    [X, J, te] = [round$5(ne[0] * 255), round$5(ne[1] * 255), round$5(ne[2] * 255)];
  }
  return C.length > 3 ? [X, J, te, C[3]] : [X, J, te, 1];
}, RE_RGB = /^rgb\(\s*(-?\d+),\s*(-?\d+)\s*,\s*(-?\d+)\s*\)$/, RE_RGBA = /^rgba\(\s*(-?\d+),\s*(-?\d+)\s*,\s*(-?\d+)\s*,\s*([01]|[01]?\.\d+)\)$/, RE_RGB_PCT = /^rgb\(\s*(-?\d+(?:\.\d+)?)%,\s*(-?\d+(?:\.\d+)?)%\s*,\s*(-?\d+(?:\.\d+)?)%\s*\)$/, RE_RGBA_PCT = /^rgba\(\s*(-?\d+(?:\.\d+)?)%,\s*(-?\d+(?:\.\d+)?)%\s*,\s*(-?\d+(?:\.\d+)?)%\s*,\s*([01]|[01]?\.\d+)\)$/, RE_HSL = /^hsl\(\s*(-?\d+(?:\.\d+)?),\s*(-?\d+(?:\.\d+)?)%\s*,\s*(-?\d+(?:\.\d+)?)%\s*\)$/, RE_HSLA = /^hsla\(\s*(-?\d+(?:\.\d+)?),\s*(-?\d+(?:\.\d+)?)%\s*,\s*(-?\d+(?:\.\d+)?)%\s*,\s*([01]|[01]?\.\d+)\)$/, { round: round$4 } = Math, css2rgb = (C) => {
  C = C.toLowerCase().trim();
  let L;
  if (input.format.named)
    try {
      return input.format.named(C);
    } catch {
    }
  if (L = C.match(RE_RGB)) {
    const A = L.slice(1, 4);
    for (let W = 0; W < 3; W++)
      A[W] = +A[W];
    return A[3] = 1, A;
  }
  if (L = C.match(RE_RGBA)) {
    const A = L.slice(1, 5);
    for (let W = 0; W < 4; W++)
      A[W] = +A[W];
    return A;
  }
  if (L = C.match(RE_RGB_PCT)) {
    const A = L.slice(1, 4);
    for (let W = 0; W < 3; W++)
      A[W] = round$4(A[W] * 2.55);
    return A[3] = 1, A;
  }
  if (L = C.match(RE_RGBA_PCT)) {
    const A = L.slice(1, 5);
    for (let W = 0; W < 3; W++)
      A[W] = round$4(A[W] * 2.55);
    return A[3] = +A[3], A;
  }
  if (L = C.match(RE_HSL)) {
    const A = L.slice(1, 4);
    A[1] *= 0.01, A[2] *= 0.01;
    const W = hsl2rgb(A);
    return W[3] = 1, W;
  }
  if (L = C.match(RE_HSLA)) {
    const A = L.slice(1, 4);
    A[1] *= 0.01, A[2] *= 0.01;
    const W = hsl2rgb(A);
    return W[3] = +L[4], W;
  }
};
css2rgb.test = (C) => RE_RGB.test(C) || RE_RGBA.test(C) || RE_RGB_PCT.test(C) || RE_RGBA_PCT.test(C) || RE_HSL.test(C) || RE_HSLA.test(C);
Color.prototype.css = function(C) {
  return rgb2css(this._rgb, C);
};
chroma.css = (...C) => new Color(...C, "css");
input.format.css = css2rgb;
input.autodetect.push({
  p: 5,
  test: (C, ...L) => {
    if (!L.length && type$2(C) === "string" && css2rgb.test(C))
      return "css";
  }
});
input.format.gl = (...C) => {
  const L = unpack(C, "rgba");
  return L[0] *= 255, L[1] *= 255, L[2] *= 255, L;
};
chroma.gl = (...C) => new Color(...C, "gl");
Color.prototype.gl = function() {
  const C = this._rgb;
  return [C[0] / 255, C[1] / 255, C[2] / 255, C[3]];
};
const { floor: floor$3 } = Math, hcg2rgb = (...C) => {
  C = unpack(C, "hcg");
  let [L, A, W] = C, X, J, te;
  W = W * 255;
  const oe = A * 255;
  if (A === 0)
    X = J = te = W;
  else {
    L === 360 && (L = 0), L > 360 && (L -= 360), L < 0 && (L += 360), L /= 60;
    const ne = floor$3(L), re = L - ne, ce = W * (1 - A), ue = ce + oe * (1 - re), de = ce + oe * re, be = ce + oe;
    switch (ne) {
      case 0:
        [X, J, te] = [be, de, ce];
        break;
      case 1:
        [X, J, te] = [ue, be, ce];
        break;
      case 2:
        [X, J, te] = [ce, be, de];
        break;
      case 3:
        [X, J, te] = [ce, ue, be];
        break;
      case 4:
        [X, J, te] = [de, ce, be];
        break;
      case 5:
        [X, J, te] = [be, ce, ue];
        break;
    }
  }
  return [X, J, te, C.length > 3 ? C[3] : 1];
}, rgb2hcg = (...C) => {
  const [L, A, W] = unpack(C, "rgb"), X = min$3(L, A, W), J = max$4(L, A, W), te = J - X, oe = te * 100 / 255, ne = X / (255 - te) * 100;
  let re;
  return te === 0 ? re = Number.NaN : (L === J && (re = (A - W) / te), A === J && (re = 2 + (W - L) / te), W === J && (re = 4 + (L - A) / te), re *= 60, re < 0 && (re += 360)), [re, oe, ne];
};
Color.prototype.hcg = function() {
  return rgb2hcg(this._rgb);
};
chroma.hcg = (...C) => new Color(...C, "hcg");
input.format.hcg = hcg2rgb;
input.autodetect.push({
  p: 1,
  test: (...C) => {
    if (C = unpack(C, "hcg"), type$2(C) === "array" && C.length === 3)
      return "hcg";
  }
});
const RE_HEX = /^#?([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/, RE_HEXA = /^#?([A-Fa-f0-9]{8}|[A-Fa-f0-9]{4})$/, hex2rgb = (C) => {
  if (C.match(RE_HEX)) {
    (C.length === 4 || C.length === 7) && (C = C.substr(1)), C.length === 3 && (C = C.split(""), C = C[0] + C[0] + C[1] + C[1] + C[2] + C[2]);
    const L = parseInt(C, 16), A = L >> 16, W = L >> 8 & 255, X = L & 255;
    return [A, W, X, 1];
  }
  if (C.match(RE_HEXA)) {
    (C.length === 5 || C.length === 9) && (C = C.substr(1)), C.length === 4 && (C = C.split(""), C = C[0] + C[0] + C[1] + C[1] + C[2] + C[2] + C[3] + C[3]);
    const L = parseInt(C, 16), A = L >> 24 & 255, W = L >> 16 & 255, X = L >> 8 & 255, J = Math.round((L & 255) / 255 * 100) / 100;
    return [A, W, X, J];
  }
  throw new Error(`unknown hex color: ${C}`);
}, { round: round$3 } = Math, rgb2hex = (...C) => {
  let [L, A, W, X] = unpack(C, "rgba"), J = last(C) || "auto";
  X === void 0 && (X = 1), J === "auto" && (J = X < 1 ? "rgba" : "rgb"), L = round$3(L), A = round$3(A), W = round$3(W);
  let oe = "000000" + (L << 16 | A << 8 | W).toString(16);
  oe = oe.substr(oe.length - 6);
  let ne = "0" + round$3(X * 255).toString(16);
  switch (ne = ne.substr(ne.length - 2), J.toLowerCase()) {
    case "rgba":
      return `#${oe}${ne}`;
    case "argb":
      return `#${ne}${oe}`;
    default:
      return `#${oe}`;
  }
};
Color.prototype.hex = function(C) {
  return rgb2hex(this._rgb, C);
};
chroma.hex = (...C) => new Color(...C, "hex");
input.format.hex = hex2rgb;
input.autodetect.push({
  p: 4,
  test: (C, ...L) => {
    if (!L.length && type$2(C) === "string" && [3, 4, 5, 6, 7, 8, 9].indexOf(C.length) >= 0)
      return "hex";
  }
});
const { cos: cos$4 } = Math, hsi2rgb = (...C) => {
  C = unpack(C, "hsi");
  let [L, A, W] = C, X, J, te;
  return isNaN(L) && (L = 0), isNaN(A) && (A = 0), L > 360 && (L -= 360), L < 0 && (L += 360), L /= 360, L < 1 / 3 ? (te = (1 - A) / 3, X = (1 + A * cos$4(TWOPI * L) / cos$4(PITHIRD - TWOPI * L)) / 3, J = 1 - (te + X)) : L < 2 / 3 ? (L -= 1 / 3, X = (1 - A) / 3, J = (1 + A * cos$4(TWOPI * L) / cos$4(PITHIRD - TWOPI * L)) / 3, te = 1 - (X + J)) : (L -= 2 / 3, J = (1 - A) / 3, te = (1 + A * cos$4(TWOPI * L) / cos$4(PITHIRD - TWOPI * L)) / 3, X = 1 - (J + te)), X = limit(W * X * 3), J = limit(W * J * 3), te = limit(W * te * 3), [X * 255, J * 255, te * 255, C.length > 3 ? C[3] : 1];
}, { min: min$2, sqrt: sqrt$4, acos } = Math, rgb2hsi = (...C) => {
  let [L, A, W] = unpack(C, "rgb");
  L /= 255, A /= 255, W /= 255;
  let X;
  const J = min$2(L, A, W), te = (L + A + W) / 3, oe = te > 0 ? 1 - J / te : 0;
  return oe === 0 ? X = NaN : (X = (L - A + (L - W)) / 2, X /= sqrt$4((L - A) * (L - A) + (L - W) * (A - W)), X = acos(X), W > A && (X = TWOPI - X), X /= TWOPI), [X * 360, oe, te];
};
Color.prototype.hsi = function() {
  return rgb2hsi(this._rgb);
};
chroma.hsi = (...C) => new Color(...C, "hsi");
input.format.hsi = hsi2rgb;
input.autodetect.push({
  p: 2,
  test: (...C) => {
    if (C = unpack(C, "hsi"), type$2(C) === "array" && C.length === 3)
      return "hsi";
  }
});
Color.prototype.hsl = function() {
  return rgb2hsl$1(this._rgb);
};
chroma.hsl = (...C) => new Color(...C, "hsl");
input.format.hsl = hsl2rgb;
input.autodetect.push({
  p: 2,
  test: (...C) => {
    if (C = unpack(C, "hsl"), type$2(C) === "array" && C.length === 3)
      return "hsl";
  }
});
const { floor: floor$2 } = Math, hsv2rgb = (...C) => {
  C = unpack(C, "hsv");
  let [L, A, W] = C, X, J, te;
  if (W *= 255, A === 0)
    X = J = te = W;
  else {
    L === 360 && (L = 0), L > 360 && (L -= 360), L < 0 && (L += 360), L /= 60;
    const oe = floor$2(L), ne = L - oe, re = W * (1 - A), ce = W * (1 - A * ne), ue = W * (1 - A * (1 - ne));
    switch (oe) {
      case 0:
        [X, J, te] = [W, ue, re];
        break;
      case 1:
        [X, J, te] = [ce, W, re];
        break;
      case 2:
        [X, J, te] = [re, W, ue];
        break;
      case 3:
        [X, J, te] = [re, ce, W];
        break;
      case 4:
        [X, J, te] = [ue, re, W];
        break;
      case 5:
        [X, J, te] = [W, re, ce];
        break;
    }
  }
  return [X, J, te, C.length > 3 ? C[3] : 1];
}, { min: min$1, max: max$2 } = Math, rgb2hsl = (...C) => {
  C = unpack(C, "rgb");
  let [L, A, W] = C;
  const X = min$1(L, A, W), J = max$2(L, A, W), te = J - X;
  let oe, ne, re;
  return re = J / 255, J === 0 ? (oe = Number.NaN, ne = 0) : (ne = te / J, L === J && (oe = (A - W) / te), A === J && (oe = 2 + (W - L) / te), W === J && (oe = 4 + (L - A) / te), oe *= 60, oe < 0 && (oe += 360)), [oe, ne, re];
};
Color.prototype.hsv = function() {
  return rgb2hsl(this._rgb);
};
chroma.hsv = (...C) => new Color(...C, "hsv");
input.format.hsv = hsv2rgb;
input.autodetect.push({
  p: 2,
  test: (...C) => {
    if (C = unpack(C, "hsv"), type$2(C) === "array" && C.length === 3)
      return "hsv";
  }
});
const LAB_CONSTANTS = {
  // Corresponds roughly to RGB brighter/darker
  Kn: 18,
  // D65 standard referent
  Xn: 0.95047,
  Yn: 1,
  Zn: 1.08883,
  t0: 0.137931034,
  // 4 / 29
  t1: 0.206896552,
  // 6 / 29
  t2: 0.12841855,
  // 3 * t1 * t1
  t3: 8856452e-9
  // t1 * t1 * t1
}, { pow: pow$a } = Math, lab2rgb = (...C) => {
  C = unpack(C, "lab");
  const [L, A, W] = C;
  let X, J, te, oe, ne, re;
  return J = (L + 16) / 116, X = isNaN(A) ? J : J + A / 500, te = isNaN(W) ? J : J - W / 200, J = LAB_CONSTANTS.Yn * lab_xyz(J), X = LAB_CONSTANTS.Xn * lab_xyz(X), te = LAB_CONSTANTS.Zn * lab_xyz(te), oe = xyz_rgb(3.2404542 * X - 1.5371385 * J - 0.4985314 * te), ne = xyz_rgb(-0.969266 * X + 1.8760108 * J + 0.041556 * te), re = xyz_rgb(0.0556434 * X - 0.2040259 * J + 1.0572252 * te), [oe, ne, re, C.length > 3 ? C[3] : 1];
}, xyz_rgb = (C) => 255 * (C <= 304e-5 ? 12.92 * C : 1.055 * pow$a(C, 1 / 2.4) - 0.055), lab_xyz = (C) => C > LAB_CONSTANTS.t1 ? C * C * C : LAB_CONSTANTS.t2 * (C - LAB_CONSTANTS.t0), { pow: pow$9 } = Math, rgb2lab = (...C) => {
  const [L, A, W] = unpack(C, "rgb"), [X, J, te] = rgb2xyz(L, A, W), oe = 116 * J - 16;
  return [oe < 0 ? 0 : oe, 500 * (X - J), 200 * (J - te)];
}, rgb_xyz = (C) => (C /= 255) <= 0.04045 ? C / 12.92 : pow$9((C + 0.055) / 1.055, 2.4), xyz_lab = (C) => C > LAB_CONSTANTS.t3 ? pow$9(C, 1 / 3) : C / LAB_CONSTANTS.t2 + LAB_CONSTANTS.t0, rgb2xyz = (C, L, A) => {
  C = rgb_xyz(C), L = rgb_xyz(L), A = rgb_xyz(A);
  const W = xyz_lab(
    (0.4124564 * C + 0.3575761 * L + 0.1804375 * A) / LAB_CONSTANTS.Xn
  ), X = xyz_lab(
    (0.2126729 * C + 0.7151522 * L + 0.072175 * A) / LAB_CONSTANTS.Yn
  ), J = xyz_lab(
    (0.0193339 * C + 0.119192 * L + 0.9503041 * A) / LAB_CONSTANTS.Zn
  );
  return [W, X, J];
};
Color.prototype.lab = function() {
  return rgb2lab(this._rgb);
};
chroma.lab = (...C) => new Color(...C, "lab");
input.format.lab = lab2rgb;
input.autodetect.push({
  p: 2,
  test: (...C) => {
    if (C = unpack(C, "lab"), type$2(C) === "array" && C.length === 3)
      return "lab";
  }
});
const { sin: sin$3, cos: cos$3 } = Math, lch2lab = (...C) => {
  let [L, A, W] = unpack(C, "lch");
  return isNaN(W) && (W = 0), W = W * DEG2RAD, [L, cos$3(W) * A, sin$3(W) * A];
}, lch2rgb = (...C) => {
  C = unpack(C, "lch");
  const [L, A, W] = C, [X, J, te] = lch2lab(L, A, W), [oe, ne, re] = lab2rgb(X, J, te);
  return [oe, ne, re, C.length > 3 ? C[3] : 1];
}, hcl2rgb = (...C) => {
  const L = unpack(C, "hcl").reverse();
  return lch2rgb(...L);
}, { sqrt: sqrt$3, atan2: atan2$2, round: round$2 } = Math, lab2lch = (...C) => {
  const [L, A, W] = unpack(C, "lab"), X = sqrt$3(A * A + W * W);
  let J = (atan2$2(W, A) * RAD2DEG + 360) % 360;
  return round$2(X * 1e4) === 0 && (J = Number.NaN), [L, X, J];
}, rgb2lch = (...C) => {
  const [L, A, W] = unpack(C, "rgb"), [X, J, te] = rgb2lab(L, A, W);
  return lab2lch(X, J, te);
};
Color.prototype.lch = function() {
  return rgb2lch(this._rgb);
};
Color.prototype.hcl = function() {
  return rgb2lch(this._rgb).reverse();
};
chroma.lch = (...C) => new Color(...C, "lch");
chroma.hcl = (...C) => new Color(...C, "hcl");
input.format.lch = lch2rgb;
input.format.hcl = hcl2rgb;
["lch", "hcl"].forEach(
  (C) => input.autodetect.push({
    p: 2,
    test: (...L) => {
      if (L = unpack(L, C), type$2(L) === "array" && L.length === 3)
        return C;
    }
  })
);
const w3cx11 = {
  aliceblue: "#f0f8ff",
  antiquewhite: "#faebd7",
  aqua: "#00ffff",
  aquamarine: "#7fffd4",
  azure: "#f0ffff",
  beige: "#f5f5dc",
  bisque: "#ffe4c4",
  black: "#000000",
  blanchedalmond: "#ffebcd",
  blue: "#0000ff",
  blueviolet: "#8a2be2",
  brown: "#a52a2a",
  burlywood: "#deb887",
  cadetblue: "#5f9ea0",
  chartreuse: "#7fff00",
  chocolate: "#d2691e",
  coral: "#ff7f50",
  cornflowerblue: "#6495ed",
  cornsilk: "#fff8dc",
  crimson: "#dc143c",
  cyan: "#00ffff",
  darkblue: "#00008b",
  darkcyan: "#008b8b",
  darkgoldenrod: "#b8860b",
  darkgray: "#a9a9a9",
  darkgreen: "#006400",
  darkgrey: "#a9a9a9",
  darkkhaki: "#bdb76b",
  darkmagenta: "#8b008b",
  darkolivegreen: "#556b2f",
  darkorange: "#ff8c00",
  darkorchid: "#9932cc",
  darkred: "#8b0000",
  darksalmon: "#e9967a",
  darkseagreen: "#8fbc8f",
  darkslateblue: "#483d8b",
  darkslategray: "#2f4f4f",
  darkslategrey: "#2f4f4f",
  darkturquoise: "#00ced1",
  darkviolet: "#9400d3",
  deeppink: "#ff1493",
  deepskyblue: "#00bfff",
  dimgray: "#696969",
  dimgrey: "#696969",
  dodgerblue: "#1e90ff",
  firebrick: "#b22222",
  floralwhite: "#fffaf0",
  forestgreen: "#228b22",
  fuchsia: "#ff00ff",
  gainsboro: "#dcdcdc",
  ghostwhite: "#f8f8ff",
  gold: "#ffd700",
  goldenrod: "#daa520",
  gray: "#808080",
  green: "#008000",
  greenyellow: "#adff2f",
  grey: "#808080",
  honeydew: "#f0fff0",
  hotpink: "#ff69b4",
  indianred: "#cd5c5c",
  indigo: "#4b0082",
  ivory: "#fffff0",
  khaki: "#f0e68c",
  laserlemon: "#ffff54",
  lavender: "#e6e6fa",
  lavenderblush: "#fff0f5",
  lawngreen: "#7cfc00",
  lemonchiffon: "#fffacd",
  lightblue: "#add8e6",
  lightcoral: "#f08080",
  lightcyan: "#e0ffff",
  lightgoldenrod: "#fafad2",
  lightgoldenrodyellow: "#fafad2",
  lightgray: "#d3d3d3",
  lightgreen: "#90ee90",
  lightgrey: "#d3d3d3",
  lightpink: "#ffb6c1",
  lightsalmon: "#ffa07a",
  lightseagreen: "#20b2aa",
  lightskyblue: "#87cefa",
  lightslategray: "#778899",
  lightslategrey: "#778899",
  lightsteelblue: "#b0c4de",
  lightyellow: "#ffffe0",
  lime: "#00ff00",
  limegreen: "#32cd32",
  linen: "#faf0e6",
  magenta: "#ff00ff",
  maroon: "#800000",
  maroon2: "#7f0000",
  maroon3: "#b03060",
  mediumaquamarine: "#66cdaa",
  mediumblue: "#0000cd",
  mediumorchid: "#ba55d3",
  mediumpurple: "#9370db",
  mediumseagreen: "#3cb371",
  mediumslateblue: "#7b68ee",
  mediumspringgreen: "#00fa9a",
  mediumturquoise: "#48d1cc",
  mediumvioletred: "#c71585",
  midnightblue: "#191970",
  mintcream: "#f5fffa",
  mistyrose: "#ffe4e1",
  moccasin: "#ffe4b5",
  navajowhite: "#ffdead",
  navy: "#000080",
  oldlace: "#fdf5e6",
  olive: "#808000",
  olivedrab: "#6b8e23",
  orange: "#ffa500",
  orangered: "#ff4500",
  orchid: "#da70d6",
  palegoldenrod: "#eee8aa",
  palegreen: "#98fb98",
  paleturquoise: "#afeeee",
  palevioletred: "#db7093",
  papayawhip: "#ffefd5",
  peachpuff: "#ffdab9",
  peru: "#cd853f",
  pink: "#ffc0cb",
  plum: "#dda0dd",
  powderblue: "#b0e0e6",
  purple: "#800080",
  purple2: "#7f007f",
  purple3: "#a020f0",
  rebeccapurple: "#663399",
  red: "#ff0000",
  rosybrown: "#bc8f8f",
  royalblue: "#4169e1",
  saddlebrown: "#8b4513",
  salmon: "#fa8072",
  sandybrown: "#f4a460",
  seagreen: "#2e8b57",
  seashell: "#fff5ee",
  sienna: "#a0522d",
  silver: "#c0c0c0",
  skyblue: "#87ceeb",
  slateblue: "#6a5acd",
  slategray: "#708090",
  slategrey: "#708090",
  snow: "#fffafa",
  springgreen: "#00ff7f",
  steelblue: "#4682b4",
  tan: "#d2b48c",
  teal: "#008080",
  thistle: "#d8bfd8",
  tomato: "#ff6347",
  turquoise: "#40e0d0",
  violet: "#ee82ee",
  wheat: "#f5deb3",
  white: "#ffffff",
  whitesmoke: "#f5f5f5",
  yellow: "#ffff00",
  yellowgreen: "#9acd32"
};
Color.prototype.name = function() {
  const C = rgb2hex(this._rgb, "rgb");
  for (let L of Object.keys(w3cx11))
    if (w3cx11[L] === C) return L.toLowerCase();
  return C;
};
input.format.named = (C) => {
  if (C = C.toLowerCase(), w3cx11[C]) return hex2rgb(w3cx11[C]);
  throw new Error("unknown color name: " + C);
};
input.autodetect.push({
  p: 5,
  test: (C, ...L) => {
    if (!L.length && type$2(C) === "string" && w3cx11[C.toLowerCase()])
      return "named";
  }
});
const num2rgb = (C) => {
  if (type$2(C) == "number" && C >= 0 && C <= 16777215) {
    const L = C >> 16, A = C >> 8 & 255, W = C & 255;
    return [L, A, W, 1];
  }
  throw new Error("unknown num color: " + C);
}, rgb2num = (...C) => {
  const [L, A, W] = unpack(C, "rgb");
  return (L << 16) + (A << 8) + W;
};
Color.prototype.num = function() {
  return rgb2num(this._rgb);
};
chroma.num = (...C) => new Color(...C, "num");
input.format.num = num2rgb;
input.autodetect.push({
  p: 5,
  test: (...C) => {
    if (C.length === 1 && type$2(C[0]) === "number" && C[0] >= 0 && C[0] <= 16777215)
      return "num";
  }
});
const { round: round$1 } = Math;
Color.prototype.rgb = function(C = !0) {
  return C === !1 ? this._rgb.slice(0, 3) : this._rgb.slice(0, 3).map(round$1);
};
Color.prototype.rgba = function(C = !0) {
  return this._rgb.slice(0, 4).map((L, A) => A < 3 ? C === !1 ? L : round$1(L) : L);
};
chroma.rgb = (...C) => new Color(...C, "rgb");
input.format.rgb = (...C) => {
  const L = unpack(C, "rgba");
  return L[3] === void 0 && (L[3] = 1), L;
};
input.autodetect.push({
  p: 3,
  test: (...C) => {
    if (C = unpack(C, "rgba"), type$2(C) === "array" && (C.length === 3 || C.length === 4 && type$2(C[3]) == "number" && C[3] >= 0 && C[3] <= 1))
      return "rgb";
  }
});
const { log: log$1 } = Math, temperature2rgb = (C) => {
  const L = C / 100;
  let A, W, X;
  return L < 66 ? (A = 255, W = L < 6 ? 0 : -155.25485562709179 - 0.44596950469579133 * (W = L - 2) + 104.49216199393888 * log$1(W), X = L < 20 ? 0 : -254.76935184120902 + 0.8274096064007395 * (X = L - 10) + 115.67994401066147 * log$1(X)) : (A = 351.97690566805693 + 0.114206453784165 * (A = L - 55) - 40.25366309332127 * log$1(A), W = 325.4494125711974 + 0.07943456536662342 * (W = L - 50) - 28.0852963507957 * log$1(W), X = 255), [A, W, X, 1];
}, { round } = Math, rgb2temperature = (...C) => {
  const L = unpack(C, "rgb"), A = L[0], W = L[2];
  let X = 1e3, J = 4e4;
  const te = 0.4;
  let oe;
  for (; J - X > te; ) {
    oe = (J + X) * 0.5;
    const ne = temperature2rgb(oe);
    ne[2] / ne[0] >= W / A ? J = oe : X = oe;
  }
  return round(oe);
};
Color.prototype.temp = Color.prototype.kelvin = Color.prototype.temperature = function() {
  return rgb2temperature(this._rgb);
};
chroma.temp = chroma.kelvin = chroma.temperature = (...C) => new Color(...C, "temp");
input.format.temp = input.format.kelvin = input.format.temperature = temperature2rgb;
const { pow: pow$8, sign: sign$1 } = Math, oklab2rgb = (...C) => {
  C = unpack(C, "lab");
  const [L, A, W] = C, X = pow$8(L + 0.3963377774 * A + 0.2158037573 * W, 3), J = pow$8(L - 0.1055613458 * A - 0.0638541728 * W, 3), te = pow$8(L - 0.0894841775 * A - 1.291485548 * W, 3);
  return [
    255 * lrgb2rgb(4.0767416621 * X - 3.3077115913 * J + 0.2309699292 * te),
    255 * lrgb2rgb(-1.2684380046 * X + 2.6097574011 * J - 0.3413193965 * te),
    255 * lrgb2rgb(-0.0041960863 * X - 0.7034186147 * J + 1.707614701 * te),
    C.length > 3 ? C[3] : 1
  ];
};
function lrgb2rgb(C) {
  const L = Math.abs(C);
  return L > 31308e-7 ? (sign$1(C) || 1) * (1.055 * pow$8(L, 1 / 2.4) - 0.055) : C * 12.92;
}
const { cbrt, pow: pow$7, sign } = Math, rgb2oklab = (...C) => {
  const [L, A, W] = unpack(C, "rgb"), [X, J, te] = [
    rgb2lrgb(L / 255),
    rgb2lrgb(A / 255),
    rgb2lrgb(W / 255)
  ], oe = cbrt(0.4122214708 * X + 0.5363325363 * J + 0.0514459929 * te), ne = cbrt(0.2119034982 * X + 0.6806995451 * J + 0.1073969566 * te), re = cbrt(0.0883024619 * X + 0.2817188376 * J + 0.6299787005 * te);
  return [
    0.2104542553 * oe + 0.793617785 * ne - 0.0040720468 * re,
    1.9779984951 * oe - 2.428592205 * ne + 0.4505937099 * re,
    0.0259040371 * oe + 0.7827717662 * ne - 0.808675766 * re
  ];
};
function rgb2lrgb(C) {
  const L = Math.abs(C);
  return L < 0.04045 ? C / 12.92 : (sign(C) || 1) * pow$7((L + 0.055) / 1.055, 2.4);
}
Color.prototype.oklab = function() {
  return rgb2oklab(this._rgb);
};
chroma.oklab = (...C) => new Color(...C, "oklab");
input.format.oklab = oklab2rgb;
input.autodetect.push({
  p: 3,
  test: (...C) => {
    if (C = unpack(C, "oklab"), type$2(C) === "array" && C.length === 3)
      return "oklab";
  }
});
const oklch2rgb = (...C) => {
  C = unpack(C, "lch");
  const [L, A, W] = C, [X, J, te] = lch2lab(L, A, W), [oe, ne, re] = oklab2rgb(X, J, te);
  return [oe, ne, re, C.length > 3 ? C[3] : 1];
}, rgb2oklch = (...C) => {
  const [L, A, W] = unpack(C, "rgb"), [X, J, te] = rgb2oklab(L, A, W);
  return lab2lch(X, J, te);
};
Color.prototype.oklch = function() {
  return rgb2oklch(this._rgb);
};
chroma.oklch = (...C) => new Color(...C, "oklch");
input.format.oklch = oklch2rgb;
input.autodetect.push({
  p: 3,
  test: (...C) => {
    if (C = unpack(C, "oklch"), type$2(C) === "array" && C.length === 3)
      return "oklch";
  }
});
Color.prototype.alpha = function(C, L = !1) {
  return C !== void 0 && type$2(C) === "number" ? L ? (this._rgb[3] = C, this) : new Color([this._rgb[0], this._rgb[1], this._rgb[2], C], "rgb") : this._rgb[3];
};
Color.prototype.clipped = function() {
  return this._rgb._clipped || !1;
};
Color.prototype.darken = function(C = 1) {
  const L = this, A = L.lab();
  return A[0] -= LAB_CONSTANTS.Kn * C, new Color(A, "lab").alpha(L.alpha(), !0);
};
Color.prototype.brighten = function(C = 1) {
  return this.darken(-C);
};
Color.prototype.darker = Color.prototype.darken;
Color.prototype.brighter = Color.prototype.brighten;
Color.prototype.get = function(C) {
  const [L, A] = C.split("."), W = this[L]();
  if (A) {
    const X = L.indexOf(A) - (L.substr(0, 2) === "ok" ? 2 : 0);
    if (X > -1) return W[X];
    throw new Error(`unknown channel ${A} in mode ${L}`);
  } else
    return W;
};
const { pow: pow$6 } = Math, EPS = 1e-7, MAX_ITER = 20;
Color.prototype.luminance = function(C, L = "rgb") {
  if (C !== void 0 && type$2(C) === "number") {
    if (C === 0)
      return new Color([0, 0, 0, this._rgb[3]], "rgb");
    if (C === 1)
      return new Color([255, 255, 255, this._rgb[3]], "rgb");
    let A = this.luminance(), W = MAX_ITER;
    const X = (te, oe) => {
      const ne = te.interpolate(oe, 0.5, L), re = ne.luminance();
      return Math.abs(C - re) < EPS || !W-- ? ne : re > C ? X(te, ne) : X(ne, oe);
    }, J = (A > C ? X(new Color([0, 0, 0]), this) : X(this, new Color([255, 255, 255]))).rgb();
    return new Color([...J, this._rgb[3]]);
  }
  return rgb2luminance(...this._rgb.slice(0, 3));
};
const rgb2luminance = (C, L, A) => (C = luminance_x(C), L = luminance_x(L), A = luminance_x(A), 0.2126 * C + 0.7152 * L + 0.0722 * A), luminance_x = (C) => (C /= 255, C <= 0.03928 ? C / 12.92 : pow$6((C + 0.055) / 1.055, 2.4)), index$1 = {}, mix = (C, L, A = 0.5, ...W) => {
  let X = W[0] || "lrgb";
  if (!index$1[X] && !W.length && (X = Object.keys(index$1)[0]), !index$1[X])
    throw new Error(`interpolation mode ${X} is not defined`);
  return type$2(C) !== "object" && (C = new Color(C)), type$2(L) !== "object" && (L = new Color(L)), index$1[X](C, L, A).alpha(
    C.alpha() + A * (L.alpha() - C.alpha())
  );
};
Color.prototype.mix = Color.prototype.interpolate = function(C, L = 0.5, ...A) {
  return mix(this, C, L, ...A);
};
Color.prototype.premultiply = function(C = !1) {
  const L = this._rgb, A = L[3];
  return C ? (this._rgb = [L[0] * A, L[1] * A, L[2] * A, A], this) : new Color([L[0] * A, L[1] * A, L[2] * A, A], "rgb");
};
Color.prototype.saturate = function(C = 1) {
  const L = this, A = L.lch();
  return A[1] += LAB_CONSTANTS.Kn * C, A[1] < 0 && (A[1] = 0), new Color(A, "lch").alpha(L.alpha(), !0);
};
Color.prototype.desaturate = function(C = 1) {
  return this.saturate(-C);
};
Color.prototype.set = function(C, L, A = !1) {
  const [W, X] = C.split("."), J = this[W]();
  if (X) {
    const te = W.indexOf(X) - (W.substr(0, 2) === "ok" ? 2 : 0);
    if (te > -1) {
      if (type$2(L) == "string")
        switch (L.charAt(0)) {
          case "+":
            J[te] += +L;
            break;
          case "-":
            J[te] += +L;
            break;
          case "*":
            J[te] *= +L.substr(1);
            break;
          case "/":
            J[te] /= +L.substr(1);
            break;
          default:
            J[te] = +L;
        }
      else if (type$2(L) === "number")
        J[te] = L;
      else
        throw new Error("unsupported value for Color.set");
      const oe = new Color(J, W);
      return A ? (this._rgb = oe._rgb, this) : oe;
    }
    throw new Error(`unknown channel ${X} in mode ${W}`);
  } else
    return J;
};
Color.prototype.tint = function(C = 0.5, ...L) {
  return mix(this, "white", C, ...L);
};
Color.prototype.shade = function(C = 0.5, ...L) {
  return mix(this, "black", C, ...L);
};
const rgb = (C, L, A) => {
  const W = C._rgb, X = L._rgb;
  return new Color(
    W[0] + A * (X[0] - W[0]),
    W[1] + A * (X[1] - W[1]),
    W[2] + A * (X[2] - W[2]),
    "rgb"
  );
};
index$1.rgb = rgb;
const { sqrt: sqrt$2, pow: pow$5 } = Math, lrgb = (C, L, A) => {
  const [W, X, J] = C._rgb, [te, oe, ne] = L._rgb;
  return new Color(
    sqrt$2(pow$5(W, 2) * (1 - A) + pow$5(te, 2) * A),
    sqrt$2(pow$5(X, 2) * (1 - A) + pow$5(oe, 2) * A),
    sqrt$2(pow$5(J, 2) * (1 - A) + pow$5(ne, 2) * A),
    "rgb"
  );
};
index$1.lrgb = lrgb;
const lab = (C, L, A) => {
  const W = C.lab(), X = L.lab();
  return new Color(
    W[0] + A * (X[0] - W[0]),
    W[1] + A * (X[1] - W[1]),
    W[2] + A * (X[2] - W[2]),
    "lab"
  );
};
index$1.lab = lab;
const interpolate_hsx = (C, L, A, W) => {
  let X, J;
  W === "hsl" ? (X = C.hsl(), J = L.hsl()) : W === "hsv" ? (X = C.hsv(), J = L.hsv()) : W === "hcg" ? (X = C.hcg(), J = L.hcg()) : W === "hsi" ? (X = C.hsi(), J = L.hsi()) : W === "lch" || W === "hcl" ? (W = "hcl", X = C.hcl(), J = L.hcl()) : W === "oklch" && (X = C.oklch().reverse(), J = L.oklch().reverse());
  let te, oe, ne, re, ce, ue;
  (W.substr(0, 1) === "h" || W === "oklch") && ([te, ne, ce] = X, [oe, re, ue] = J);
  let de, be, pe, me;
  return !isNaN(te) && !isNaN(oe) ? (oe > te && oe - te > 180 ? me = oe - (te + 360) : oe < te && te - oe > 180 ? me = oe + 360 - te : me = oe - te, be = te + A * me) : isNaN(te) ? isNaN(oe) ? be = Number.NaN : (be = oe, (ce == 1 || ce == 0) && W != "hsv" && (de = re)) : (be = te, (ue == 1 || ue == 0) && W != "hsv" && (de = ne)), de === void 0 && (de = ne + A * (re - ne)), pe = ce + A * (ue - ce), W === "oklch" ? new Color([pe, de, be], W) : new Color([be, de, pe], W);
}, lch = (C, L, A) => interpolate_hsx(C, L, A, "lch");
index$1.lch = lch;
index$1.hcl = lch;
const num = (C, L, A) => {
  const W = C.num(), X = L.num();
  return new Color(W + A * (X - W), "num");
};
index$1.num = num;
const hcg = (C, L, A) => interpolate_hsx(C, L, A, "hcg");
index$1.hcg = hcg;
const hsi = (C, L, A) => interpolate_hsx(C, L, A, "hsi");
index$1.hsi = hsi;
const hsl = (C, L, A) => interpolate_hsx(C, L, A, "hsl");
index$1.hsl = hsl;
const hsv = (C, L, A) => interpolate_hsx(C, L, A, "hsv");
index$1.hsv = hsv;
const oklab = (C, L, A) => {
  const W = C.oklab(), X = L.oklab();
  return new Color(
    W[0] + A * (X[0] - W[0]),
    W[1] + A * (X[1] - W[1]),
    W[2] + A * (X[2] - W[2]),
    "oklab"
  );
};
index$1.oklab = oklab;
const oklch = (C, L, A) => interpolate_hsx(C, L, A, "oklch");
index$1.oklch = oklch;
const { pow: pow$4, sqrt: sqrt$1, PI: PI$1, cos: cos$2, sin: sin$2, atan2: atan2$1 } = Math, average = (C, L = "lrgb", A = null) => {
  const W = C.length;
  A || (A = Array.from(new Array(W)).map(() => 1));
  const X = W / A.reduce(function(ue, de) {
    return ue + de;
  });
  if (A.forEach((ue, de) => {
    A[de] *= X;
  }), C = C.map((ue) => new Color(ue)), L === "lrgb")
    return _average_lrgb(C, A);
  const J = C.shift(), te = J.get(L), oe = [];
  let ne = 0, re = 0;
  for (let ue = 0; ue < te.length; ue++)
    if (te[ue] = (te[ue] || 0) * A[0], oe.push(isNaN(te[ue]) ? 0 : A[0]), L.charAt(ue) === "h" && !isNaN(te[ue])) {
      const de = te[ue] / 180 * PI$1;
      ne += cos$2(de) * A[0], re += sin$2(de) * A[0];
    }
  let ce = J.alpha() * A[0];
  C.forEach((ue, de) => {
    const be = ue.get(L);
    ce += ue.alpha() * A[de + 1];
    for (let pe = 0; pe < te.length; pe++)
      if (!isNaN(be[pe]))
        if (oe[pe] += A[de + 1], L.charAt(pe) === "h") {
          const me = be[pe] / 180 * PI$1;
          ne += cos$2(me) * A[de + 1], re += sin$2(me) * A[de + 1];
        } else
          te[pe] += be[pe] * A[de + 1];
  });
  for (let ue = 0; ue < te.length; ue++)
    if (L.charAt(ue) === "h") {
      let de = atan2$1(re / oe[ue], ne / oe[ue]) / PI$1 * 180;
      for (; de < 0; ) de += 360;
      for (; de >= 360; ) de -= 360;
      te[ue] = de;
    } else
      te[ue] = te[ue] / oe[ue];
  return ce /= W, new Color(te, L).alpha(ce > 0.99999 ? 1 : ce, !0);
}, _average_lrgb = (C, L) => {
  const A = C.length, W = [0, 0, 0, 0];
  for (let X = 0; X < C.length; X++) {
    const J = C[X], te = L[X] / A, oe = J._rgb;
    W[0] += pow$4(oe[0], 2) * te, W[1] += pow$4(oe[1], 2) * te, W[2] += pow$4(oe[2], 2) * te, W[3] += oe[3] * te;
  }
  return W[0] = sqrt$1(W[0]), W[1] = sqrt$1(W[1]), W[2] = sqrt$1(W[2]), W[3] > 0.9999999 && (W[3] = 1), new Color(clip_rgb(W));
}, { pow: pow$3 } = Math;
function scale(C) {
  let L = "rgb", A = chroma("#ccc"), W = 0, X = [0, 1], J = [], te = [0, 0], oe = !1, ne = [], re = !1, ce = 0, ue = 1, de = !1, be = {}, pe = !0, me = 1;
  const Me = function(ve) {
    if (ve = ve || ["#fff", "#000"], ve && type$2(ve) === "string" && chroma.brewer && chroma.brewer[ve.toLowerCase()] && (ve = chroma.brewer[ve.toLowerCase()]), type$2(ve) === "array") {
      ve.length === 1 && (ve = [ve[0], ve[0]]), ve = ve.slice(0);
      for (let De = 0; De < ve.length; De++)
        ve[De] = chroma(ve[De]);
      J.length = 0;
      for (let De = 0; De < ve.length; De++)
        J.push(De / (ve.length - 1));
    }
    return Ae(), ne = ve;
  }, he = function(ve) {
    if (oe != null) {
      const De = oe.length - 1;
      let Ue = 0;
      for (; Ue < De && ve >= oe[Ue]; )
        Ue++;
      return Ue - 1;
    }
    return 0;
  };
  let ge = (ve) => ve, Ce = (ve) => ve;
  const Se = function(ve, De) {
    let Ue, Fe;
    if (De == null && (De = !1), isNaN(ve) || ve === null)
      return A;
    De ? Fe = ve : oe && oe.length > 2 ? Fe = he(ve) / (oe.length - 2) : ue !== ce ? Fe = (ve - ce) / (ue - ce) : Fe = 1, Fe = Ce(Fe), De || (Fe = ge(Fe)), me !== 1 && (Fe = pow$3(Fe, me)), Fe = te[0] + Fe * (1 - te[0] - te[1]), Fe = limit(Fe, 0, 1);
    const We = Math.floor(Fe * 1e4);
    if (pe && be[We])
      Ue = be[We];
    else {
      if (type$2(ne) === "array")
        for (let Ke = 0; Ke < J.length; Ke++) {
          const it = J[Ke];
          if (Fe <= it) {
            Ue = ne[Ke];
            break;
          }
          if (Fe >= it && Ke === J.length - 1) {
            Ue = ne[Ke];
            break;
          }
          if (Fe > it && Fe < J[Ke + 1]) {
            Fe = (Fe - it) / (J[Ke + 1] - it), Ue = chroma.interpolate(
              ne[Ke],
              ne[Ke + 1],
              Fe,
              L
            );
            break;
          }
        }
      else type$2(ne) === "function" && (Ue = ne(Fe));
      pe && (be[We] = Ue);
    }
    return Ue;
  };
  var Ae = () => be = {};
  Me(C);
  const Le = function(ve) {
    const De = chroma(Se(ve));
    return re && De[re] ? De[re]() : De;
  };
  return Le.classes = function(ve) {
    if (ve != null) {
      if (type$2(ve) === "array")
        oe = ve, X = [ve[0], ve[ve.length - 1]];
      else {
        const De = chroma.analyze(X);
        ve === 0 ? oe = [De.min, De.max] : oe = chroma.limits(De, "e", ve);
      }
      return Le;
    }
    return oe;
  }, Le.domain = function(ve) {
    if (!arguments.length)
      return X;
    ce = ve[0], ue = ve[ve.length - 1], J = [];
    const De = ne.length;
    if (ve.length === De && ce !== ue)
      for (let Ue of Array.from(ve))
        J.push((Ue - ce) / (ue - ce));
    else {
      for (let Ue = 0; Ue < De; Ue++)
        J.push(Ue / (De - 1));
      if (ve.length > 2) {
        const Ue = ve.map((We, Ke) => Ke / (ve.length - 1)), Fe = ve.map((We) => (We - ce) / (ue - ce));
        Fe.every((We, Ke) => Ue[Ke] === We) || (Ce = (We) => {
          if (We <= 0 || We >= 1) return We;
          let Ke = 0;
          for (; We >= Fe[Ke + 1]; ) Ke++;
          const it = (We - Fe[Ke]) / (Fe[Ke + 1] - Fe[Ke]);
          return Ue[Ke] + it * (Ue[Ke + 1] - Ue[Ke]);
        });
      }
    }
    return X = [ce, ue], Le;
  }, Le.mode = function(ve) {
    return arguments.length ? (L = ve, Ae(), Le) : L;
  }, Le.range = function(ve, De) {
    return Me(ve), Le;
  }, Le.out = function(ve) {
    return re = ve, Le;
  }, Le.spread = function(ve) {
    return arguments.length ? (W = ve, Le) : W;
  }, Le.correctLightness = function(ve) {
    return ve == null && (ve = !0), de = ve, Ae(), de ? ge = function(De) {
      const Ue = Se(0, !0).lab()[0], Fe = Se(1, !0).lab()[0], We = Ue > Fe;
      let Ke = Se(De, !0).lab()[0];
      const it = Ue + (Fe - Ue) * De;
      let Qe = Ke - it, vt = 0, Ct = 1, Tt = 20;
      for (; Math.abs(Qe) > 0.01 && Tt-- > 0; )
        (function() {
          return We && (Qe *= -1), Qe < 0 ? (vt = De, De += (Ct - De) * 0.5) : (Ct = De, De += (vt - De) * 0.5), Ke = Se(De, !0).lab()[0], Qe = Ke - it;
        })();
      return De;
    } : ge = (De) => De, Le;
  }, Le.padding = function(ve) {
    return ve != null ? (type$2(ve) === "number" && (ve = [ve, ve]), te = ve, Le) : te;
  }, Le.colors = function(ve, De) {
    arguments.length < 2 && (De = "hex");
    let Ue = [];
    if (arguments.length === 0)
      Ue = ne.slice(0);
    else if (ve === 1)
      Ue = [Le(0.5)];
    else if (ve > 1) {
      const Fe = X[0], We = X[1] - Fe;
      Ue = __range__(0, ve).map(
        (Ke) => Le(Fe + Ke / (ve - 1) * We)
      );
    } else {
      C = [];
      let Fe = [];
      if (oe && oe.length > 2)
        for (let We = 1, Ke = oe.length, it = 1 <= Ke; it ? We < Ke : We > Ke; it ? We++ : We--)
          Fe.push((oe[We - 1] + oe[We]) * 0.5);
      else
        Fe = X;
      Ue = Fe.map((We) => Le(We));
    }
    return chroma[De] && (Ue = Ue.map((Fe) => Fe[De]())), Ue;
  }, Le.cache = function(ve) {
    return ve != null ? (pe = ve, Le) : pe;
  }, Le.gamma = function(ve) {
    return ve != null ? (me = ve, Le) : me;
  }, Le.nodata = function(ve) {
    return ve != null ? (A = chroma(ve), Le) : A;
  }, Le;
}
function __range__(C, L, A) {
  let W = [], X = C < L, J = L;
  for (let te = C; X ? te < J : te > J; X ? te++ : te--)
    W.push(te);
  return W;
}
const binom_row = function(C) {
  let L = [1, 1];
  for (let A = 1; A < C; A++) {
    let W = [1];
    for (let X = 1; X <= L.length; X++)
      W[X] = (L[X] || 0) + L[X - 1];
    L = W;
  }
  return L;
}, bezier = function(C) {
  let L, A, W, X;
  if (C = C.map((J) => new Color(J)), C.length === 2)
    [A, W] = C.map((J) => J.lab()), L = function(J) {
      const te = [0, 1, 2].map((oe) => A[oe] + J * (W[oe] - A[oe]));
      return new Color(te, "lab");
    };
  else if (C.length === 3)
    [A, W, X] = C.map((J) => J.lab()), L = function(J) {
      const te = [0, 1, 2].map(
        (oe) => (1 - J) * (1 - J) * A[oe] + 2 * (1 - J) * J * W[oe] + J * J * X[oe]
      );
      return new Color(te, "lab");
    };
  else if (C.length === 4) {
    let J;
    [A, W, X, J] = C.map((te) => te.lab()), L = function(te) {
      const oe = [0, 1, 2].map(
        (ne) => (1 - te) * (1 - te) * (1 - te) * A[ne] + 3 * (1 - te) * (1 - te) * te * W[ne] + 3 * (1 - te) * te * te * X[ne] + te * te * te * J[ne]
      );
      return new Color(oe, "lab");
    };
  } else if (C.length >= 5) {
    let J, te, oe;
    J = C.map((ne) => ne.lab()), oe = C.length - 1, te = binom_row(oe), L = function(ne) {
      const re = 1 - ne, ce = [0, 1, 2].map(
        (ue) => J.reduce(
          (de, be, pe) => de + te[pe] * re ** (oe - pe) * ne ** pe * be[ue],
          0
        )
      );
      return new Color(ce, "lab");
    };
  } else
    throw new RangeError("No point in running bezier with only one color.");
  return L;
}, bezier$1 = (C) => {
  const L = bezier(C);
  return L.scale = () => scale(L), L;
}, blend = (C, L, A) => {
  if (!blend[A])
    throw new Error("unknown blend mode " + A);
  return blend[A](C, L);
}, blend_f = (C) => (L, A) => {
  const W = chroma(A).rgb(), X = chroma(L).rgb();
  return chroma.rgb(C(W, X));
}, each = (C) => (L, A) => {
  const W = [];
  return W[0] = C(L[0], A[0]), W[1] = C(L[1], A[1]), W[2] = C(L[2], A[2]), W;
}, normal = (C) => C, multiply = (C, L) => C * L / 255, darken = (C, L) => C > L ? L : C, lighten = (C, L) => C > L ? C : L, screen = (C, L) => 255 * (1 - (1 - C / 255) * (1 - L / 255)), overlay = (C, L) => L < 128 ? 2 * C * L / 255 : 255 * (1 - 2 * (1 - C / 255) * (1 - L / 255)), burn = (C, L) => 255 * (1 - (1 - L / 255) / (C / 255)), dodge = (C, L) => C === 255 ? 255 : (C = 255 * (L / 255) / (1 - C / 255), C > 255 ? 255 : C);
blend.normal = blend_f(each(normal));
blend.multiply = blend_f(each(multiply));
blend.screen = blend_f(each(screen));
blend.overlay = blend_f(each(overlay));
blend.darken = blend_f(each(darken));
blend.lighten = blend_f(each(lighten));
blend.dodge = blend_f(each(dodge));
blend.burn = blend_f(each(burn));
const { pow: pow$2, sin: sin$1, cos: cos$1 } = Math;
function cubehelix(C = 300, L = -1.5, A = 1, W = 1, X = [0, 1]) {
  let J = 0, te;
  type$2(X) === "array" ? te = X[1] - X[0] : (te = 0, X = [X, X]);
  const oe = function(ne) {
    const re = TWOPI * ((C + 120) / 360 + L * ne), ce = pow$2(X[0] + te * ne, W), de = (J !== 0 ? A[0] + ne * J : A) * ce * (1 - ce) / 2, be = cos$1(re), pe = sin$1(re), me = ce + de * (-0.14861 * be + 1.78277 * pe), Me = ce + de * (-0.29227 * be - 0.90649 * pe), he = ce + de * (1.97294 * be);
    return chroma(clip_rgb([me * 255, Me * 255, he * 255, 1]));
  };
  return oe.start = function(ne) {
    return ne == null ? C : (C = ne, oe);
  }, oe.rotations = function(ne) {
    return ne == null ? L : (L = ne, oe);
  }, oe.gamma = function(ne) {
    return ne == null ? W : (W = ne, oe);
  }, oe.hue = function(ne) {
    return ne == null ? A : (A = ne, type$2(A) === "array" ? (J = A[1] - A[0], J === 0 && (A = A[1])) : J = 0, oe);
  }, oe.lightness = function(ne) {
    return ne == null ? X : (type$2(ne) === "array" ? (X = ne, te = ne[1] - ne[0]) : (X = [ne, ne], te = 0), oe);
  }, oe.scale = () => chroma.scale(oe), oe.hue(A), oe;
}
const digits = "0123456789abcdef", { floor: floor$1, random } = Math, random$1 = () => {
  let C = "#";
  for (let L = 0; L < 6; L++)
    C += digits.charAt(floor$1(random() * 16));
  return new Color(C, "hex");
}, { log, pow: pow$1, floor, abs: abs$1 } = Math;
function analyze(C, L = null) {
  const A = {
    min: Number.MAX_VALUE,
    max: Number.MAX_VALUE * -1,
    sum: 0,
    values: [],
    count: 0
  };
  return type$2(C) === "object" && (C = Object.values(C)), C.forEach((W) => {
    L && type$2(W) === "object" && (W = W[L]), W != null && !isNaN(W) && (A.values.push(W), A.sum += W, W < A.min && (A.min = W), W > A.max && (A.max = W), A.count += 1);
  }), A.domain = [A.min, A.max], A.limits = (W, X) => limits(A, W, X), A;
}
function limits(C, L = "equal", A = 7) {
  type$2(C) == "array" && (C = analyze(C));
  const { min: W, max: X } = C, J = C.values.sort((oe, ne) => oe - ne);
  if (A === 1)
    return [W, X];
  const te = [];
  if (L.substr(0, 1) === "c" && (te.push(W), te.push(X)), L.substr(0, 1) === "e") {
    te.push(W);
    for (let oe = 1; oe < A; oe++)
      te.push(W + oe / A * (X - W));
    te.push(X);
  } else if (L.substr(0, 1) === "l") {
    if (W <= 0)
      throw new Error(
        "Logarithmic scales are only possible for values > 0"
      );
    const oe = Math.LOG10E * log(W), ne = Math.LOG10E * log(X);
    te.push(W);
    for (let re = 1; re < A; re++)
      te.push(pow$1(10, oe + re / A * (ne - oe)));
    te.push(X);
  } else if (L.substr(0, 1) === "q") {
    te.push(W);
    for (let oe = 1; oe < A; oe++) {
      const ne = (J.length - 1) * oe / A, re = floor(ne);
      if (re === ne)
        te.push(J[re]);
      else {
        const ce = ne - re;
        te.push(J[re] * (1 - ce) + J[re + 1] * ce);
      }
    }
    te.push(X);
  } else if (L.substr(0, 1) === "k") {
    let oe;
    const ne = J.length, re = new Array(ne), ce = new Array(A);
    let ue = !0, de = 0, be = null;
    be = [], be.push(W);
    for (let Me = 1; Me < A; Me++)
      be.push(W + Me / A * (X - W));
    for (be.push(X); ue; ) {
      for (let he = 0; he < A; he++)
        ce[he] = 0;
      for (let he = 0; he < ne; he++) {
        const ge = J[he];
        let Ce = Number.MAX_VALUE, Se;
        for (let Ae = 0; Ae < A; Ae++) {
          const Le = abs$1(be[Ae] - ge);
          Le < Ce && (Ce = Le, Se = Ae), ce[Se]++, re[he] = Se;
        }
      }
      const Me = new Array(A);
      for (let he = 0; he < A; he++)
        Me[he] = null;
      for (let he = 0; he < ne; he++)
        oe = re[he], Me[oe] === null ? Me[oe] = J[he] : Me[oe] += J[he];
      for (let he = 0; he < A; he++)
        Me[he] *= 1 / ce[he];
      ue = !1;
      for (let he = 0; he < A; he++)
        if (Me[he] !== be[he]) {
          ue = !0;
          break;
        }
      be = Me, de++, de > 200 && (ue = !1);
    }
    const pe = {};
    for (let Me = 0; Me < A; Me++)
      pe[Me] = [];
    for (let Me = 0; Me < ne; Me++)
      oe = re[Me], pe[oe].push(J[Me]);
    let me = [];
    for (let Me = 0; Me < A; Me++)
      me.push(pe[Me][0]), me.push(pe[Me][pe[Me].length - 1]);
    me = me.sort((Me, he) => Me - he), te.push(me[0]);
    for (let Me = 1; Me < me.length; Me += 2) {
      const he = me[Me];
      !isNaN(he) && te.indexOf(he) === -1 && te.push(he);
    }
  }
  return te;
}
const contrast = (C, L) => {
  C = new Color(C), L = new Color(L);
  const A = C.luminance(), W = L.luminance();
  return A > W ? (A + 0.05) / (W + 0.05) : (W + 0.05) / (A + 0.05);
}, { sqrt, pow, min, max: max$1, atan2, abs, cos, sin, exp, PI } = Math;
function deltaE(C, L, A = 1, W = 1, X = 1) {
  var J = function(Pe) {
    return 360 * Pe / (2 * PI);
  }, te = function(Pe) {
    return 2 * PI * Pe / 360;
  };
  C = new Color(C), L = new Color(L);
  const [oe, ne, re] = Array.from(C.lab()), [ce, ue, de] = Array.from(L.lab()), be = (oe + ce) / 2, pe = sqrt(pow(ne, 2) + pow(re, 2)), me = sqrt(pow(ue, 2) + pow(de, 2)), Me = (pe + me) / 2, he = 0.5 * (1 - sqrt(pow(Me, 7) / (pow(Me, 7) + pow(25, 7)))), ge = ne * (1 + he), Ce = ue * (1 + he), Se = sqrt(pow(ge, 2) + pow(re, 2)), Ae = sqrt(pow(Ce, 2) + pow(de, 2)), Le = (Se + Ae) / 2, ve = J(atan2(re, ge)), De = J(atan2(de, Ce)), Ue = ve >= 0 ? ve : ve + 360, Fe = De >= 0 ? De : De + 360, We = abs(Ue - Fe) > 180 ? (Ue + Fe + 360) / 2 : (Ue + Fe) / 2, Ke = 1 - 0.17 * cos(te(We - 30)) + 0.24 * cos(te(2 * We)) + 0.32 * cos(te(3 * We + 6)) - 0.2 * cos(te(4 * We - 63));
  let it = Fe - Ue;
  it = abs(it) <= 180 ? it : Fe <= Ue ? it + 360 : it - 360, it = 2 * sqrt(Se * Ae) * sin(te(it) / 2);
  const Qe = ce - oe, vt = Ae - Se, Ct = 1 + 0.015 * pow(be - 50, 2) / sqrt(20 + pow(be - 50, 2)), Tt = 1 + 0.045 * Le, St = 1 + 0.015 * Le * Ke, Je = 30 * exp(-pow((We - 275) / 25, 2)), qe = -(2 * sqrt(pow(Le, 7) / (pow(Le, 7) + pow(25, 7)))) * sin(2 * te(Je)), Ze = sqrt(
    pow(Qe / (A * Ct), 2) + pow(vt / (W * Tt), 2) + pow(it / (X * St), 2) + qe * (vt / (W * Tt)) * (it / (X * St))
  );
  return max$1(0, min(100, Ze));
}
function distance(C, L, A = "lab") {
  C = new Color(C), L = new Color(L);
  const W = C.get(A), X = L.get(A);
  let J = 0;
  for (let te in W) {
    const oe = (W[te] || 0) - (X[te] || 0);
    J += oe * oe;
  }
  return Math.sqrt(J);
}
const valid = (...C) => {
  try {
    return new Color(...C), !0;
  } catch {
    return !1;
  }
}, scales = {
  cool() {
    return scale([chroma.hsl(180, 1, 0.9), chroma.hsl(250, 0.7, 0.4)]);
  },
  hot() {
    return scale(["#000", "#f00", "#ff0", "#fff"]).mode(
      "rgb"
    );
  }
}, colorbrewer = {
  // sequential
  OrRd: ["#fff7ec", "#fee8c8", "#fdd49e", "#fdbb84", "#fc8d59", "#ef6548", "#d7301f", "#b30000", "#7f0000"],
  PuBu: ["#fff7fb", "#ece7f2", "#d0d1e6", "#a6bddb", "#74a9cf", "#3690c0", "#0570b0", "#045a8d", "#023858"],
  BuPu: ["#f7fcfd", "#e0ecf4", "#bfd3e6", "#9ebcda", "#8c96c6", "#8c6bb1", "#88419d", "#810f7c", "#4d004b"],
  Oranges: ["#fff5eb", "#fee6ce", "#fdd0a2", "#fdae6b", "#fd8d3c", "#f16913", "#d94801", "#a63603", "#7f2704"],
  BuGn: ["#f7fcfd", "#e5f5f9", "#ccece6", "#99d8c9", "#66c2a4", "#41ae76", "#238b45", "#006d2c", "#00441b"],
  YlOrBr: ["#ffffe5", "#fff7bc", "#fee391", "#fec44f", "#fe9929", "#ec7014", "#cc4c02", "#993404", "#662506"],
  YlGn: ["#ffffe5", "#f7fcb9", "#d9f0a3", "#addd8e", "#78c679", "#41ab5d", "#238443", "#006837", "#004529"],
  Reds: ["#fff5f0", "#fee0d2", "#fcbba1", "#fc9272", "#fb6a4a", "#ef3b2c", "#cb181d", "#a50f15", "#67000d"],
  RdPu: ["#fff7f3", "#fde0dd", "#fcc5c0", "#fa9fb5", "#f768a1", "#dd3497", "#ae017e", "#7a0177", "#49006a"],
  Greens: ["#f7fcf5", "#e5f5e0", "#c7e9c0", "#a1d99b", "#74c476", "#41ab5d", "#238b45", "#006d2c", "#00441b"],
  YlGnBu: ["#ffffd9", "#edf8b1", "#c7e9b4", "#7fcdbb", "#41b6c4", "#1d91c0", "#225ea8", "#253494", "#081d58"],
  Purples: ["#fcfbfd", "#efedf5", "#dadaeb", "#bcbddc", "#9e9ac8", "#807dba", "#6a51a3", "#54278f", "#3f007d"],
  GnBu: ["#f7fcf0", "#e0f3db", "#ccebc5", "#a8ddb5", "#7bccc4", "#4eb3d3", "#2b8cbe", "#0868ac", "#084081"],
  Greys: ["#ffffff", "#f0f0f0", "#d9d9d9", "#bdbdbd", "#969696", "#737373", "#525252", "#252525", "#000000"],
  YlOrRd: ["#ffffcc", "#ffeda0", "#fed976", "#feb24c", "#fd8d3c", "#fc4e2a", "#e31a1c", "#bd0026", "#800026"],
  PuRd: ["#f7f4f9", "#e7e1ef", "#d4b9da", "#c994c7", "#df65b0", "#e7298a", "#ce1256", "#980043", "#67001f"],
  Blues: ["#f7fbff", "#deebf7", "#c6dbef", "#9ecae1", "#6baed6", "#4292c6", "#2171b5", "#08519c", "#08306b"],
  PuBuGn: ["#fff7fb", "#ece2f0", "#d0d1e6", "#a6bddb", "#67a9cf", "#3690c0", "#02818a", "#016c59", "#014636"],
  Viridis: ["#440154", "#482777", "#3f4a8a", "#31678e", "#26838f", "#1f9d8a", "#6cce5a", "#b6de2b", "#fee825"],
  // diverging
  Spectral: ["#9e0142", "#d53e4f", "#f46d43", "#fdae61", "#fee08b", "#ffffbf", "#e6f598", "#abdda4", "#66c2a5", "#3288bd", "#5e4fa2"],
  RdYlGn: ["#a50026", "#d73027", "#f46d43", "#fdae61", "#fee08b", "#ffffbf", "#d9ef8b", "#a6d96a", "#66bd63", "#1a9850", "#006837"],
  RdBu: ["#67001f", "#b2182b", "#d6604d", "#f4a582", "#fddbc7", "#f7f7f7", "#d1e5f0", "#92c5de", "#4393c3", "#2166ac", "#053061"],
  PiYG: ["#8e0152", "#c51b7d", "#de77ae", "#f1b6da", "#fde0ef", "#f7f7f7", "#e6f5d0", "#b8e186", "#7fbc41", "#4d9221", "#276419"],
  PRGn: ["#40004b", "#762a83", "#9970ab", "#c2a5cf", "#e7d4e8", "#f7f7f7", "#d9f0d3", "#a6dba0", "#5aae61", "#1b7837", "#00441b"],
  RdYlBu: ["#a50026", "#d73027", "#f46d43", "#fdae61", "#fee090", "#ffffbf", "#e0f3f8", "#abd9e9", "#74add1", "#4575b4", "#313695"],
  BrBG: ["#543005", "#8c510a", "#bf812d", "#dfc27d", "#f6e8c3", "#f5f5f5", "#c7eae5", "#80cdc1", "#35978f", "#01665e", "#003c30"],
  RdGy: ["#67001f", "#b2182b", "#d6604d", "#f4a582", "#fddbc7", "#ffffff", "#e0e0e0", "#bababa", "#878787", "#4d4d4d", "#1a1a1a"],
  PuOr: ["#7f3b08", "#b35806", "#e08214", "#fdb863", "#fee0b6", "#f7f7f7", "#d8daeb", "#b2abd2", "#8073ac", "#542788", "#2d004b"],
  // qualitative
  Set2: ["#66c2a5", "#fc8d62", "#8da0cb", "#e78ac3", "#a6d854", "#ffd92f", "#e5c494", "#b3b3b3"],
  Accent: ["#7fc97f", "#beaed4", "#fdc086", "#ffff99", "#386cb0", "#f0027f", "#bf5b17", "#666666"],
  Set1: ["#e41a1c", "#377eb8", "#4daf4a", "#984ea3", "#ff7f00", "#ffff33", "#a65628", "#f781bf", "#999999"],
  Set3: ["#8dd3c7", "#ffffb3", "#bebada", "#fb8072", "#80b1d3", "#fdb462", "#b3de69", "#fccde5", "#d9d9d9", "#bc80bd", "#ccebc5", "#ffed6f"],
  Dark2: ["#1b9e77", "#d95f02", "#7570b3", "#e7298a", "#66a61e", "#e6ab02", "#a6761d", "#666666"],
  Paired: ["#a6cee3", "#1f78b4", "#b2df8a", "#33a02c", "#fb9a99", "#e31a1c", "#fdbf6f", "#ff7f00", "#cab2d6", "#6a3d9a", "#ffff99", "#b15928"],
  Pastel2: ["#b3e2cd", "#fdcdac", "#cbd5e8", "#f4cae4", "#e6f5c9", "#fff2ae", "#f1e2cc", "#cccccc"],
  Pastel1: ["#fbb4ae", "#b3cde3", "#ccebc5", "#decbe4", "#fed9a6", "#ffffcc", "#e5d8bd", "#fddaec", "#f2f2f2"]
};
for (let C of Object.keys(colorbrewer))
  colorbrewer[C.toLowerCase()] = colorbrewer[C];
Object.assign(chroma, {
  average,
  bezier: bezier$1,
  blend,
  cubehelix,
  mix,
  interpolate: mix,
  random: random$1,
  scale,
  analyze,
  contrast,
  deltaE,
  distance,
  limits,
  valid,
  scales,
  input,
  colors: w3cx11,
  brewer: colorbrewer
});
const roseus = [
  [4528e-6, 4341e-6, 4307e-6],
  [5625e-6, 6156e-6, 601e-5],
  [6628e-6, 8293e-6, 8161e-6],
  [7551e-6, 0.010738, 0.01079],
  [8382e-6, 0.013482, 0.013941],
  [9111e-6, 0.01652, 0.017662],
  [9727e-6, 0.019846, 0.022009],
  [0.010223, 0.023452, 0.027035],
  [0.010593, 0.027331, 0.032799],
  [0.010833, 0.031475, 0.039361],
  [0.010941, 0.035875, 0.046415],
  [0.010918, 0.04052, 0.053597],
  [0.010768, 0.045158, 0.060914],
  [0.010492, 0.049708, 0.068367],
  [0.010098, 0.054171, 0.075954],
  [9594e-6, 0.058549, 0.083672],
  [8989e-6, 0.06284, 0.091521],
  [8297e-6, 0.067046, 0.099499],
  [753e-5, 0.071165, 0.107603],
  [6704e-6, 0.075196, 0.11583],
  [5838e-6, 0.07914, 0.124178],
  [4949e-6, 0.082994, 0.132643],
  [4062e-6, 0.086758, 0.141223],
  [3198e-6, 0.09043, 0.149913],
  [2382e-6, 0.09401, 0.158711],
  [1643e-6, 0.097494, 0.167612],
  [1009e-6, 0.100883, 0.176612],
  [514e-6, 0.104174, 0.185704],
  [187e-6, 0.107366, 0.194886],
  [66e-6, 0.110457, 0.204151],
  [186e-6, 0.113445, 0.213496],
  [587e-6, 0.116329, 0.222914],
  [1309e-6, 0.119106, 0.232397],
  [2394e-6, 0.121776, 0.241942],
  [3886e-6, 0.124336, 0.251542],
  [5831e-6, 0.126784, 0.261189],
  [8276e-6, 0.12912, 0.270876],
  [0.011268, 0.131342, 0.280598],
  [0.014859, 0.133447, 0.290345],
  [0.0191, 0.135435, 0.300111],
  [0.024043, 0.137305, 0.309888],
  [0.029742, 0.139054, 0.319669],
  [0.036252, 0.140683, 0.329441],
  [0.043507, 0.142189, 0.339203],
  [0.050922, 0.143571, 0.348942],
  [0.058432, 0.144831, 0.358649],
  [0.066041, 0.145965, 0.368319],
  [0.073744, 0.146974, 0.377938],
  [0.081541, 0.147858, 0.387501],
  [0.089431, 0.148616, 0.396998],
  [0.097411, 0.149248, 0.406419],
  [0.105479, 0.149754, 0.415755],
  [0.113634, 0.150134, 0.424998],
  [0.121873, 0.150389, 0.434139],
  [0.130192, 0.150521, 0.443167],
  [0.138591, 0.150528, 0.452075],
  [0.147065, 0.150413, 0.460852],
  [0.155614, 0.150175, 0.469493],
  [0.164232, 0.149818, 0.477985],
  [0.172917, 0.149343, 0.486322],
  [0.181666, 0.148751, 0.494494],
  [0.190476, 0.148046, 0.502493],
  [0.199344, 0.147229, 0.510313],
  [0.208267, 0.146302, 0.517944],
  [0.217242, 0.145267, 0.52538],
  [0.226264, 0.144131, 0.532613],
  [0.235331, 0.142894, 0.539635],
  [0.24444, 0.141559, 0.546442],
  [0.253587, 0.140131, 0.553026],
  [0.262769, 0.138615, 0.559381],
  [0.271981, 0.137016, 0.5655],
  [0.281222, 0.135335, 0.571381],
  [0.290487, 0.133581, 0.577017],
  [0.299774, 0.131757, 0.582404],
  [0.30908, 0.129867, 0.587538],
  [0.318399, 0.12792, 0.592415],
  [0.32773, 0.125921, 0.597032],
  [0.337069, 0.123877, 0.601385],
  [0.346413, 0.121793, 0.605474],
  [0.355758, 0.119678, 0.609295],
  [0.365102, 0.11754, 0.612846],
  [0.374443, 0.115386, 0.616127],
  [0.383774, 0.113226, 0.619138],
  [0.393096, 0.111066, 0.621876],
  [0.402404, 0.108918, 0.624343],
  [0.411694, 0.106794, 0.62654],
  [0.420967, 0.104698, 0.628466],
  [0.430217, 0.102645, 0.630123],
  [0.439442, 0.100647, 0.631513],
  [0.448637, 0.098717, 0.632638],
  [0.457805, 0.096861, 0.633499],
  [0.46694, 0.095095, 0.6341],
  [0.47604, 0.093433, 0.634443],
  [0.485102, 0.091885, 0.634532],
  [0.494125, 0.090466, 0.63437],
  [0.503104, 0.08919, 0.633962],
  [0.512041, 0.088067, 0.633311],
  [0.520931, 0.087108, 0.63242],
  [0.529773, 0.086329, 0.631297],
  [0.538564, 0.085738, 0.629944],
  [0.547302, 0.085346, 0.628367],
  [0.555986, 0.085162, 0.626572],
  [0.564615, 0.08519, 0.624563],
  [0.573187, 0.085439, 0.622345],
  [0.581698, 0.085913, 0.619926],
  [0.590149, 0.086615, 0.617311],
  [0.598538, 0.087543, 0.614503],
  [0.606862, 0.0887, 0.611511],
  [0.61512, 0.090084, 0.608343],
  [0.623312, 0.09169, 0.605001],
  [0.631438, 0.093511, 0.601489],
  [0.639492, 0.095546, 0.597821],
  [0.647476, 0.097787, 0.593999],
  [0.655389, 0.100226, 0.590028],
  [0.66323, 0.102856, 0.585914],
  [0.670995, 0.105669, 0.581667],
  [0.678686, 0.108658, 0.577291],
  [0.686302, 0.111813, 0.57279],
  [0.69384, 0.115129, 0.568175],
  [0.7013, 0.118597, 0.563449],
  [0.708682, 0.122209, 0.558616],
  [0.715984, 0.125959, 0.553687],
  [0.723206, 0.12984, 0.548666],
  [0.730346, 0.133846, 0.543558],
  [0.737406, 0.13797, 0.538366],
  [0.744382, 0.142209, 0.533101],
  [0.751274, 0.146556, 0.527767],
  [0.758082, 0.151008, 0.522369],
  [0.764805, 0.155559, 0.516912],
  [0.771443, 0.160206, 0.511402],
  [0.777995, 0.164946, 0.505845],
  [0.784459, 0.169774, 0.500246],
  [0.790836, 0.174689, 0.494607],
  [0.797125, 0.179688, 0.488935],
  [0.803325, 0.184767, 0.483238],
  [0.809435, 0.189925, 0.477518],
  [0.815455, 0.19516, 0.471781],
  [0.821384, 0.200471, 0.466028],
  [0.827222, 0.205854, 0.460267],
  [0.832968, 0.211308, 0.454505],
  [0.838621, 0.216834, 0.448738],
  [0.844181, 0.222428, 0.442979],
  [0.849647, 0.22809, 0.43723],
  [0.855019, 0.233819, 0.431491],
  [0.860295, 0.239613, 0.425771],
  [0.865475, 0.245471, 0.420074],
  [0.870558, 0.251393, 0.414403],
  [0.875545, 0.25738, 0.408759],
  [0.880433, 0.263427, 0.403152],
  [0.885223, 0.269535, 0.397585],
  [0.889913, 0.275705, 0.392058],
  [0.894503, 0.281934, 0.386578],
  [0.898993, 0.288222, 0.381152],
  [0.903381, 0.294569, 0.375781],
  [0.907667, 0.300974, 0.370469],
  [0.911849, 0.307435, 0.365223],
  [0.915928, 0.313953, 0.360048],
  [0.919902, 0.320527, 0.354948],
  [0.923771, 0.327155, 0.349928],
  [0.927533, 0.333838, 0.344994],
  [0.931188, 0.340576, 0.340149],
  [0.934736, 0.347366, 0.335403],
  [0.938175, 0.354207, 0.330762],
  [0.941504, 0.361101, 0.326229],
  [0.944723, 0.368045, 0.321814],
  [0.947831, 0.375039, 0.317523],
  [0.950826, 0.382083, 0.313364],
  [0.953709, 0.389175, 0.309345],
  [0.956478, 0.396314, 0.305477],
  [0.959133, 0.403499, 0.301766],
  [0.961671, 0.410731, 0.298221],
  [0.964093, 0.418008, 0.294853],
  [0.966399, 0.425327, 0.291676],
  [0.968586, 0.43269, 0.288696],
  [0.970654, 0.440095, 0.285926],
  [0.972603, 0.44754, 0.28338],
  [0.974431, 0.455025, 0.281067],
  [0.976139, 0.462547, 0.279003],
  [0.977725, 0.470107, 0.277198],
  [0.979188, 0.477703, 0.275666],
  [0.980529, 0.485332, 0.274422],
  [0.981747, 0.492995, 0.273476],
  [0.98284, 0.50069, 0.272842],
  [0.983808, 0.508415, 0.272532],
  [0.984653, 0.516168, 0.27256],
  [0.985373, 0.523948, 0.272937],
  [0.985966, 0.531754, 0.273673],
  [0.986436, 0.539582, 0.274779],
  [0.98678, 0.547434, 0.276264],
  [0.986998, 0.555305, 0.278135],
  [0.987091, 0.563195, 0.280401],
  [0.987061, 0.5711, 0.283066],
  [0.986907, 0.579019, 0.286137],
  [0.986629, 0.58695, 0.289615],
  [0.986229, 0.594891, 0.293503],
  [0.985709, 0.602839, 0.297802],
  [0.985069, 0.610792, 0.302512],
  [0.98431, 0.618748, 0.307632],
  [0.983435, 0.626704, 0.313159],
  [0.982445, 0.634657, 0.319089],
  [0.981341, 0.642606, 0.32542],
  [0.98013, 0.650546, 0.332144],
  [0.978812, 0.658475, 0.339257],
  [0.977392, 0.666391, 0.346753],
  [0.97587, 0.67429, 0.354625],
  [0.974252, 0.68217, 0.362865],
  [0.972545, 0.690026, 0.371466],
  [0.97075, 0.697856, 0.380419],
  [0.968873, 0.705658, 0.389718],
  [0.966921, 0.713426, 0.399353],
  [0.964901, 0.721157, 0.409313],
  [0.962815, 0.728851, 0.419594],
  [0.960677, 0.7365, 0.430181],
  [0.95849, 0.744103, 0.44107],
  [0.956263, 0.751656, 0.452248],
  [0.954009, 0.759153, 0.463702],
  [0.951732, 0.766595, 0.475429],
  [0.949445, 0.773974, 0.487414],
  [0.947158, 0.781289, 0.499647],
  [0.944885, 0.788535, 0.512116],
  [0.942634, 0.795709, 0.524811],
  [0.940423, 0.802807, 0.537717],
  [0.938261, 0.809825, 0.550825],
  [0.936163, 0.81676, 0.564121],
  [0.934146, 0.823608, 0.577591],
  [0.932224, 0.830366, 0.59122],
  [0.930412, 0.837031, 0.604997],
  [0.928727, 0.843599, 0.618904],
  [0.927187, 0.850066, 0.632926],
  [0.925809, 0.856432, 0.647047],
  [0.92461, 0.862691, 0.661249],
  [0.923607, 0.868843, 0.675517],
  [0.92282, 0.874884, 0.689832],
  [0.922265, 0.880812, 0.704174],
  [0.921962, 0.886626, 0.718523],
  [0.92193, 0.892323, 0.732859],
  [0.922183, 0.897903, 0.747163],
  [0.922741, 0.903364, 0.76141],
  [0.92362, 0.908706, 0.77558],
  [0.924837, 0.913928, 0.789648],
  [0.926405, 0.919031, 0.80359],
  [0.92834, 0.924015, 0.817381],
  [0.930655, 0.928881, 0.830995],
  [0.93336, 0.933631, 0.844405],
  [0.936466, 0.938267, 0.857583],
  [0.939982, 0.942791, 0.870499],
  [0.943914, 0.947207, 0.883122],
  [0.948267, 0.951519, 0.895421],
  [0.953044, 0.955732, 0.907359],
  [0.958246, 0.959852, 0.918901],
  [0.963869, 0.963887, 0.930004],
  [0.969909, 0.967845, 0.940623],
  [0.976355, 0.971737, 0.950704],
  [0.983195, 0.97558, 0.960181],
  [0.990402, 0.979395, 0.968966],
  [0.99793, 0.983217, 0.97692]
], magmaColorScheme = [
  [113e-6, 36e-6, 1073e-6],
  [175e-6, 1e-4, 1419e-6],
  [254e-6, 178e-6, 1835e-6],
  [349e-6, 27e-5, 2319e-6],
  [461e-6, 375e-6, 2874e-6],
  [587e-6, 492e-6, 3499e-6],
  [73e-5, 621e-6, 4197e-6],
  [887e-6, 761e-6, 4973e-6],
  [1061e-6, 911e-6, 5829e-6],
  [125e-5, 1071e-6, 6768e-6],
  [1456e-6, 124e-5, 7795e-6],
  [1679e-6, 1418e-6, 8914e-6],
  [1919e-6, 1603e-6, 0.010128],
  [2177e-6, 1796e-6, 0.011441],
  [2453e-6, 1994e-6, 0.01286],
  [2749e-6, 2198e-6, 0.01439],
  [3066e-6, 2406e-6, 0.016033],
  [3404e-6, 2618e-6, 0.017795],
  [3764e-6, 2833e-6, 0.019682],
  [4148e-6, 305e-5, 0.021698],
  [4558e-6, 3267e-6, 0.023852],
  [4994e-6, 3484e-6, 0.026148],
  [5459e-6, 3699e-6, 0.028591],
  [5954e-6, 3911e-6, 0.031186],
  [6482e-6, 412e-5, 0.03394],
  [7044e-6, 4323e-6, 0.036857],
  [7643e-6, 4519e-6, 0.039944],
  [8282e-6, 4708e-6, 0.043205],
  [8963e-6, 4887e-6, 0.046645],
  [969e-5, 5054e-6, 0.050268],
  [0.010465, 521e-5, 0.054077],
  [0.011293, 5351e-6, 0.058074],
  [0.012176, 5476e-6, 0.062265],
  [0.01312, 5585e-6, 0.066648],
  [0.014128, 5675e-6, 0.071215],
  [0.015202, 5747e-6, 0.075963],
  [0.016349, 5798e-6, 0.080887],
  [0.017573, 5828e-6, 0.085982],
  [0.018877, 5837e-6, 0.091223],
  [0.020265, 5826e-6, 0.096599],
  [0.021741, 5794e-6, 0.10209],
  [0.023306, 5744e-6, 0.107662],
  [0.024965, 5676e-6, 0.113297],
  [0.026718, 5595e-6, 0.118949],
  [0.028565, 5503e-6, 0.124595],
  [0.030506, 5403e-6, 0.130187],
  [0.03254, 53e-4, 0.135695],
  [0.034663, 5199e-6, 0.141081],
  [0.036874, 5102e-6, 0.146314],
  [0.039169, 5015e-6, 0.151364],
  [0.041543, 4942e-6, 0.156211],
  [0.043994, 4885e-6, 0.160835],
  [0.046517, 4847e-6, 0.165227],
  [0.04911, 483e-5, 0.169379],
  [0.051769, 4837e-6, 0.173291],
  [0.054494, 4866e-6, 0.176965],
  [0.057281, 4921e-6, 0.180405],
  [0.06013, 4998e-6, 0.183622],
  [0.063038, 5101e-6, 0.186624],
  [0.066007, 5226e-6, 0.189422],
  [0.069036, 5375e-6, 0.192028],
  [0.072125, 5545e-6, 0.194453],
  [0.075276, 5735e-6, 0.196709],
  [0.078485, 5947e-6, 0.198807],
  [0.081757, 6177e-6, 0.200758],
  [0.085093, 6425e-6, 0.202571],
  [0.088491, 669e-5, 0.204259],
  [0.091954, 6971e-6, 0.205827],
  [0.095484, 7267e-6, 0.207284],
  [0.09908, 7577e-6, 0.20864],
  [0.102743, 7901e-6, 0.209901],
  [0.106476, 8237e-6, 0.211071],
  [0.110281, 8585e-6, 0.212158],
  [0.114157, 8944e-6, 0.213166],
  [0.118106, 9314e-6, 0.214103],
  [0.122129, 9693e-6, 0.21497],
  [0.126228, 0.010082, 0.21577],
  [0.130406, 0.010479, 0.21651],
  [0.134661, 0.010885, 0.217189],
  [0.138996, 0.011298, 0.217811],
  [0.143411, 0.011719, 0.218382],
  [0.147908, 0.012146, 0.2189],
  [0.15249, 0.01258, 0.219368],
  [0.157156, 0.013021, 0.219787],
  [0.161908, 0.013467, 0.220159],
  [0.166748, 0.013918, 0.220484],
  [0.171677, 0.014375, 0.220764],
  [0.176696, 0.014837, 0.221],
  [0.181806, 0.015304, 0.221192],
  [0.187009, 0.015775, 0.22134],
  [0.192304, 0.016251, 0.221446],
  [0.197694, 0.016731, 0.22151],
  [0.203181, 0.017215, 0.221531],
  [0.208765, 0.017704, 0.221509],
  [0.214447, 0.018196, 0.221445],
  [0.220228, 0.018692, 0.221337],
  [0.22611, 0.019191, 0.221188],
  [0.232094, 0.019695, 0.220995],
  [0.238181, 0.020202, 0.220758],
  [0.244371, 0.020712, 0.220479],
  [0.250666, 0.021227, 0.220155],
  [0.257066, 0.021744, 0.219786],
  [0.263573, 0.022266, 0.219373],
  [0.270188, 0.022792, 0.218914],
  [0.276911, 0.023321, 0.21841],
  [0.283742, 0.023855, 0.21786],
  [0.290684, 0.024392, 0.217263],
  [0.297737, 0.024934, 0.21662],
  [0.304899, 0.025481, 0.21593],
  [0.312174, 0.026032, 0.215192],
  [0.319561, 0.026589, 0.214406],
  [0.32706, 0.02715, 0.213571],
  [0.334672, 0.027718, 0.212689],
  [0.342398, 0.028291, 0.211756],
  [0.350236, 0.028871, 0.210775],
  [0.358188, 0.029457, 0.209746],
  [0.366253, 0.030051, 0.208666],
  [0.374431, 0.030652, 0.207537],
  [0.382722, 0.031262, 0.206358],
  [0.391124, 0.03188, 0.20513],
  [0.39964, 0.032508, 0.203853],
  [0.408266, 0.033146, 0.202526],
  [0.417003, 0.033795, 0.201149],
  [0.42585, 0.034456, 0.199724],
  [0.434804, 0.035129, 0.198251],
  [0.443867, 0.035816, 0.196729],
  [0.453035, 0.036517, 0.195159],
  [0.462306, 0.037233, 0.193542],
  [0.47168, 0.037966, 0.191878],
  [0.481154, 0.038717, 0.190169],
  [0.490727, 0.039487, 0.188414],
  [0.500393, 0.040278, 0.186615],
  [0.510152, 0.04109, 0.184773],
  [0.519998, 0.041926, 0.18289],
  [0.529931, 0.042788, 0.180966],
  [0.539944, 0.043677, 0.179003],
  [0.550036, 0.044595, 0.177002],
  [0.560198, 0.045544, 0.174966],
  [0.570429, 0.046526, 0.172896],
  [0.580721, 0.047545, 0.170794],
  [0.591071, 0.048601, 0.168659],
  [0.601471, 0.049699, 0.166497],
  [0.611913, 0.05084, 0.16431],
  [0.62239, 0.052029, 0.1621],
  [0.632894, 0.053268, 0.15987],
  [0.643418, 0.054561, 0.157625],
  [0.653951, 0.05591, 0.155366],
  [0.664485, 0.057321, 0.153094],
  [0.675009, 0.058796, 0.150816],
  [0.685511, 0.060341, 0.148536],
  [0.695979, 0.061961, 0.146259],
  [0.706404, 0.063659, 0.143989],
  [0.71677, 0.065439, 0.141727],
  [0.727065, 0.067309, 0.139482],
  [0.737275, 0.069273, 0.137259],
  [0.747385, 0.071335, 0.135064],
  [0.75738, 0.073502, 0.132901],
  [0.767244, 0.075779, 0.130777],
  [0.776965, 0.078171, 0.128699],
  [0.786526, 0.080686, 0.126673],
  [0.79591, 0.083327, 0.124705],
  [0.805107, 0.0861, 0.122803],
  [0.814097, 0.08901, 0.120974],
  [0.822871, 0.092063, 0.119224],
  [0.831414, 0.095262, 0.117561],
  [0.839717, 0.098613, 0.11599],
  [0.847768, 0.102117, 0.114518],
  [0.855559, 0.105779, 0.11315],
  [0.863086, 0.109601, 0.111894],
  [0.87034, 0.113586, 0.110753],
  [0.877319, 0.117735, 0.109731],
  [0.884023, 0.122048, 0.108834],
  [0.890452, 0.126525, 0.108066],
  [0.896606, 0.131167, 0.107427],
  [0.902487, 0.135973, 0.106921],
  [0.908101, 0.140943, 0.106548],
  [0.913454, 0.146074, 0.106311],
  [0.918557, 0.151363, 0.106212],
  [0.923411, 0.15681, 0.106249],
  [0.928026, 0.162413, 0.106422],
  [0.932408, 0.168171, 0.106731],
  [0.936567, 0.174079, 0.107175],
  [0.940511, 0.180137, 0.107754],
  [0.944249, 0.186343, 0.108466],
  [0.94779, 0.192692, 0.109312],
  [0.951145, 0.199185, 0.110289],
  [0.954318, 0.205818, 0.111398],
  [0.957321, 0.212589, 0.112635],
  [0.96016, 0.219497, 0.114002],
  [0.962841, 0.226539, 0.115497],
  [0.965373, 0.233716, 0.117119],
  [0.967761, 0.241026, 0.118867],
  [0.970011, 0.248466, 0.12074],
  [0.972126, 0.256037, 0.122738],
  [0.974112, 0.263739, 0.124859],
  [0.975973, 0.271571, 0.127106],
  [0.977712, 0.279532, 0.129475],
  [0.979358, 0.287613, 0.131969],
  [0.980903, 0.295819, 0.134585],
  [0.982339, 0.304154, 0.137326],
  [0.983665, 0.312616, 0.140189],
  [0.984885, 0.321209, 0.143178],
  [0.98603, 0.329919, 0.146289],
  [0.987102, 0.338749, 0.149524],
  [0.988071, 0.347711, 0.152885],
  [0.988939, 0.356803, 0.156372],
  [0.989748, 0.366014, 0.159984],
  [0.990495, 0.375343, 0.163723],
  [0.991142, 0.384808, 0.16759],
  [0.991696, 0.394403, 0.171587],
  [0.992237, 0.404106, 0.17571],
  [0.992679, 0.413943, 0.179965],
  [0.993019, 0.423922, 0.184356],
  [0.993363, 0.434002, 0.188871],
  [0.99361, 0.444222, 0.193526],
  [0.993764, 0.454583, 0.198319],
  [0.993925, 0.465047, 0.20324],
  [0.993984, 0.475655, 0.208306],
  [0.993984, 0.486395, 0.213512],
  [0.993962, 0.497253, 0.218855],
  [0.993835, 0.508261, 0.224348],
  [0.993705, 0.519382, 0.229979],
  [0.993502, 0.530643, 0.23576],
  [0.993232, 0.542044, 0.241694],
  [0.992958, 0.553562, 0.24777],
  [0.99257, 0.56524, 0.254011],
  [0.992217, 0.577024, 0.260393],
  [0.99176, 0.588964, 0.266942],
  [0.991291, 0.601031, 0.273646],
  [0.990771, 0.613238, 0.280513],
  [0.9902, 0.625588, 0.287546],
  [0.989622, 0.638064, 0.29474],
  [0.988959, 0.650699, 0.302111],
  [0.988326, 0.66345, 0.309641],
  [0.987588, 0.676368, 0.317361],
  [0.986906, 0.689394, 0.325236],
  [0.986103, 0.702599, 0.333311],
  [0.985379, 0.715907, 0.341539],
  [0.984533, 0.729393, 0.349974],
  [0.983769, 0.742985, 0.358568],
  [0.982888, 0.756759, 0.367372],
  [0.982098, 0.770638, 0.376336],
  [0.981195, 0.784698, 0.385516],
  [0.980395, 0.798864, 0.394853],
  [0.979491, 0.813211, 0.404407],
  [0.978682, 0.827671, 0.414126],
  [0.977795, 0.842306, 0.424058],
  [0.976987, 0.857061, 0.434156],
  [0.976132, 0.871983, 0.444463],
  [0.975331, 0.887041, 0.454945],
  [0.974524, 0.902258, 0.46562],
  [0.97374, 0.917622, 0.476481],
  [0.972992, 0.933133, 0.487521],
  [0.972227, 0.948813, 0.498754],
  [0.971547, 0.964629, 0.510149],
  [0.9708, 0.980633, 0.521749]
], infernoColorScheme = [
  [113e-6, 36e-6, 1073e-6],
  [175e-6, 98e-6, 1437e-6],
  [255e-6, 174e-6, 1876e-6],
  [352e-6, 263e-6, 2392e-6],
  [465e-6, 363e-6, 2984e-6],
  [594e-6, 475e-6, 3657e-6],
  [74e-5, 597e-6, 4415e-6],
  [903e-6, 729e-6, 5257e-6],
  [1083e-6, 869e-6, 6197e-6],
  [1282e-6, 1017e-6, 7231e-6],
  [1499e-6, 1171e-6, 8367e-6],
  [1737e-6, 1331e-6, 9613e-6],
  [1996e-6, 1496e-6, 0.010968],
  [2278e-6, 1664e-6, 0.012444],
  [2584e-6, 1835e-6, 0.014045],
  [2915e-6, 2006e-6, 0.015773],
  [3275e-6, 2178e-6, 0.017634],
  [3664e-6, 2347e-6, 0.019644],
  [4085e-6, 2513e-6, 0.021798],
  [4541e-6, 2676e-6, 0.024102],
  [5034e-6, 2832e-6, 0.026561],
  [5568e-6, 298e-5, 0.029187],
  [6146e-6, 3119e-6, 0.03198],
  [6772e-6, 3247e-6, 0.03494],
  [7448e-6, 3362e-6, 0.03807],
  [8179e-6, 3464e-6, 0.041369],
  [8969e-6, 355e-5, 0.044837],
  [9823e-6, 362e-5, 0.04847],
  [0.010744, 3672e-6, 0.05226],
  [0.011736, 3706e-6, 0.056199],
  [0.012805, 3721e-6, 0.060274],
  [0.013953, 3718e-6, 0.064468],
  [0.015183, 3697e-6, 0.06876],
  [0.016499, 3659e-6, 0.073128],
  [0.017902, 3606e-6, 0.077546],
  [0.019395, 354e-5, 0.081985],
  [0.020976, 3464e-6, 0.086417],
  [0.022647, 3381e-6, 0.09081],
  [0.024404, 3294e-6, 0.095133],
  [0.026247, 3206e-6, 0.09936],
  [0.028174, 3121e-6, 0.103467],
  [0.030182, 3042e-6, 0.107433],
  [0.032269, 2972e-6, 0.111241],
  [0.034431, 2913e-6, 0.114878],
  [0.036668, 2866e-6, 0.118337],
  [0.038975, 2834e-6, 0.121611],
  [0.041351, 2818e-6, 0.1247],
  [0.043796, 2818e-6, 0.127604],
  [0.046307, 2834e-6, 0.130327],
  [0.048884, 2868e-6, 0.132873],
  [0.051527, 2918e-6, 0.135248],
  [0.054235, 2985e-6, 0.137459],
  [0.057008, 3069e-6, 0.139512],
  [0.059845, 3168e-6, 0.141417],
  [0.062747, 3283e-6, 0.143179],
  [0.065714, 3412e-6, 0.144807],
  [0.068748, 3555e-6, 0.146306],
  [0.071849, 3712e-6, 0.147685],
  [0.075018, 3882e-6, 0.148948],
  [0.078255, 4064e-6, 0.150104],
  [0.081561, 4257e-6, 0.151156],
  [0.084937, 4462e-6, 0.15211],
  [0.088384, 4677e-6, 0.152972],
  [0.091903, 4902e-6, 0.153744],
  [0.095494, 5137e-6, 0.154432],
  [0.099159, 5381e-6, 0.155039],
  [0.102899, 5634e-6, 0.155568],
  [0.106714, 5895e-6, 0.156022],
  [0.110606, 6164e-6, 0.156405],
  [0.114576, 6441e-6, 0.156718],
  [0.118624, 6724e-6, 0.156964],
  [0.12275, 7016e-6, 0.157147],
  [0.126957, 7314e-6, 0.157266],
  [0.131244, 7618e-6, 0.157323],
  [0.135614, 7929e-6, 0.15732],
  [0.140067, 8246e-6, 0.157257],
  [0.144603, 8569e-6, 0.157137],
  [0.149223, 8898e-6, 0.156961],
  [0.15393, 9233e-6, 0.156727],
  [0.158722, 9574e-6, 0.15644],
  [0.163601, 992e-5, 0.156097],
  [0.168566, 0.010272, 0.155701],
  [0.173621, 0.01063, 0.155254],
  [0.178763, 0.010994, 0.154754],
  [0.183994, 0.011363, 0.154203],
  [0.189316, 0.011738, 0.153599],
  [0.194729, 0.012119, 0.152944],
  [0.200231, 0.012506, 0.15224],
  [0.205825, 0.012899, 0.151485],
  [0.211511, 0.013298, 0.150682],
  [0.217288, 0.013703, 0.149829],
  [0.223158, 0.014115, 0.148929],
  [0.229119, 0.014534, 0.14798],
  [0.235173, 0.01496, 0.146983],
  [0.241319, 0.015393, 0.14594],
  [0.247559, 0.015834, 0.14485],
  [0.25389, 0.016282, 0.143715],
  [0.260314, 0.016739, 0.142535],
  [0.26683, 0.017204, 0.14131],
  [0.273437, 0.017679, 0.140041],
  [0.280136, 0.018162, 0.13873],
  [0.286927, 0.018656, 0.137376],
  [0.293808, 0.01916, 0.135981],
  [0.300778, 0.019674, 0.134546],
  [0.307838, 0.0202, 0.133072],
  [0.314987, 0.020738, 0.131558],
  [0.322223, 0.021288, 0.130007],
  [0.329545, 0.021852, 0.128419],
  [0.336955, 0.022429, 0.126797],
  [0.344447, 0.023022, 0.125141],
  [0.352022, 0.023629, 0.123452],
  [0.359681, 0.024252, 0.121732],
  [0.367418, 0.024893, 0.119982],
  [0.375235, 0.025551, 0.118203],
  [0.383129, 0.026228, 0.116396],
  [0.391098, 0.026924, 0.114563],
  [0.399141, 0.027641, 0.112707],
  [0.407255, 0.02838, 0.110827],
  [0.415437, 0.029142, 0.108926],
  [0.423685, 0.029927, 0.107006],
  [0.431999, 0.030738, 0.105068],
  [0.440375, 0.031575, 0.103114],
  [0.448809, 0.032439, 0.101145],
  [0.457301, 0.033332, 0.099163],
  [0.465844, 0.034255, 0.097169],
  [0.474439, 0.03521, 0.095166],
  [0.483083, 0.036198, 0.093155],
  [0.491768, 0.03722, 0.091138],
  [0.500495, 0.038279, 0.089117],
  [0.50926, 0.039375, 0.087094],
  [0.518057, 0.04051, 0.08507],
  [0.526885, 0.041687, 0.083047],
  [0.535738, 0.042906, 0.081027],
  [0.544613, 0.044169, 0.07901],
  [0.553506, 0.045479, 0.077],
  [0.562413, 0.046837, 0.074997],
  [0.57133, 0.048245, 0.073003],
  [0.580252, 0.049705, 0.071019],
  [0.589175, 0.051219, 0.069048],
  [0.598092, 0.052789, 0.06709],
  [0.607003, 0.054418, 0.065148],
  [0.615901, 0.056106, 0.063222],
  [0.62478, 0.057857, 0.061314],
  [0.633638, 0.059672, 0.059424],
  [0.642468, 0.061553, 0.057555],
  [0.651266, 0.063504, 0.055708],
  [0.660028, 0.065525, 0.053882],
  [0.668748, 0.067619, 0.052081],
  [0.677423, 0.069788, 0.050303],
  [0.686046, 0.072036, 0.048551],
  [0.694614, 0.074363, 0.046825],
  [0.703119, 0.076772, 0.045126],
  [0.71156, 0.079266, 0.043455],
  [0.719932, 0.081846, 0.041811],
  [0.728229, 0.084515, 0.040197],
  [0.736446, 0.087275, 0.038612],
  [0.74458, 0.090128, 0.037057],
  [0.752624, 0.093077, 0.035531],
  [0.760578, 0.096123, 0.034037],
  [0.768434, 0.099269, 0.032573],
  [0.77619, 0.102517, 0.031141],
  [0.783839, 0.105869, 0.029739],
  [0.791382, 0.109328, 0.02837],
  [0.798809, 0.112894, 0.027031],
  [0.806122, 0.116571, 0.025725],
  [0.813314, 0.12036, 0.024451],
  [0.820382, 0.124263, 0.023209],
  [0.827324, 0.128282, 0.021998],
  [0.834135, 0.132419, 0.02082],
  [0.840812, 0.136677, 0.019674],
  [0.847353, 0.141056, 0.01856],
  [0.853755, 0.145559, 0.017478],
  [0.860012, 0.150187, 0.016429],
  [0.866125, 0.154942, 0.015412],
  [0.872091, 0.159827, 0.014428],
  [0.877907, 0.164842, 0.013477],
  [0.883568, 0.16999, 0.012558],
  [0.889075, 0.175271, 0.011673],
  [0.894422, 0.180688, 0.010821],
  [0.899612, 0.186243, 0.010003],
  [0.904638, 0.191936, 9219e-6],
  [0.909499, 0.19777, 847e-5],
  [0.914196, 0.203745, 7755e-6],
  [0.918724, 0.209865, 7076e-6],
  [0.923081, 0.216129, 6434e-6],
  [0.927266, 0.22254, 5828e-6],
  [0.931279, 0.229098, 526e-5],
  [0.935116, 0.235806, 4731e-6],
  [0.938776, 0.242666, 4242e-6],
  [0.942257, 0.249677, 3793e-6],
  [0.945558, 0.256843, 3386e-6],
  [0.948677, 0.264162, 3022e-6],
  [0.951613, 0.271639, 2704e-6],
  [0.954365, 0.279274, 2431e-6],
  [0.95693, 0.287067, 2207e-6],
  [0.959307, 0.295021, 2032e-6],
  [0.961498, 0.303137, 1909e-6],
  [0.963495, 0.311414, 184e-5],
  [0.965304, 0.319858, 1827e-6],
  [0.966918, 0.328465, 1873e-6],
  [0.96834, 0.337241, 1981e-6],
  [0.969568, 0.346184, 2153e-6],
  [0.970601, 0.355295, 2392e-6],
  [0.971435, 0.364576, 2702e-6],
  [0.972072, 0.374029, 3087e-6],
  [0.972513, 0.383654, 355e-5],
  [0.972753, 0.393453, 4095e-6],
  [0.972795, 0.403425, 4727e-6],
  [0.972636, 0.413571, 5451e-6],
  [0.972278, 0.423894, 6271e-6],
  [0.971719, 0.434391, 7193e-6],
  [0.970959, 0.445066, 8223e-6],
  [0.969997, 0.455918, 9368e-6],
  [0.968838, 0.466948, 0.010633],
  [0.967478, 0.478156, 0.012027],
  [0.965915, 0.489543, 0.013557],
  [0.964154, 0.501109, 0.015231],
  [0.962198, 0.51285, 0.01706],
  [0.960046, 0.524771, 0.019052],
  [0.957704, 0.536865, 0.021219],
  [0.955176, 0.549136, 0.023572],
  [0.952462, 0.561578, 0.026123],
  [0.94957, 0.574191, 0.028887],
  [0.946508, 0.586973, 0.031878],
  [0.943272, 0.599923, 0.035112],
  [0.939868, 0.613036, 0.038609],
  [0.936317, 0.626308, 0.042386],
  [0.932633, 0.639728, 0.046464],
  [0.928832, 0.653292, 0.050865],
  [0.924919, 0.666997, 0.055616],
  [0.920905, 0.680834, 0.060748],
  [0.916841, 0.694783, 0.066285],
  [0.912757, 0.708833, 0.072257],
  [0.908652, 0.722975, 0.078711],
  [0.904599, 0.737185, 0.085676],
  [0.900663, 0.751432, 0.093184],
  [0.896854, 0.765707, 0.101299],
  [0.893295, 0.779965, 0.110039],
  [0.890044, 0.794175, 0.119459],
  [0.887209, 0.808296, 0.129591],
  [0.8849, 0.822282, 0.140466],
  [0.883238, 0.836087, 0.152107],
  [0.882356, 0.849662, 0.16452],
  [0.882379, 0.862957, 0.177696],
  [0.883437, 0.875933, 0.191601],
  [0.885627, 0.888556, 0.206191],
  [0.889039, 0.900804, 0.221388],
  [0.893708, 0.912673, 0.237131],
  [0.899662, 0.924165, 0.253319],
  [0.90688, 0.9353, 0.269875],
  [0.915317, 0.946102, 0.286755],
  [0.924932, 0.956607, 0.303817],
  [0.935648, 0.966845, 0.321067],
  [0.947395, 0.976847, 0.33846],
  [0.960111, 0.986651, 0.355957],
  [0.973729, 0.996282, 0.373522]
], plasmaColorScheme = [
  [397e-5, 2307e-6, 0.240854],
  [5265e-6, 22e-4, 0.245991],
  [6614e-6, 2106e-6, 0.250921],
  [8016e-6, 2022e-6, 0.25567],
  [947e-5, 1948e-6, 0.260258],
  [0.010976, 1882e-6, 0.264704],
  [0.012532, 1823e-6, 0.26902],
  [0.014141, 1771e-6, 0.273222],
  [0.015803, 1723e-6, 0.277324],
  [0.017518, 1679e-6, 0.281334],
  [0.019288, 1637e-6, 0.285261],
  [0.021113, 1598e-6, 0.28911],
  [0.022993, 1561e-6, 0.292889],
  [0.024929, 1525e-6, 0.296601],
  [0.026921, 149e-5, 0.300251],
  [0.02897, 1455e-6, 0.303842],
  [0.031078, 1421e-6, 0.307376],
  [0.033244, 1386e-6, 0.310856],
  [0.035469, 135e-5, 0.314283],
  [0.037753, 1314e-6, 0.317659],
  [0.040098, 1277e-6, 0.320983],
  [0.042503, 1239e-6, 0.324257],
  [0.04497, 12e-4, 0.32748],
  [0.047499, 1159e-6, 0.330653],
  [0.050092, 1118e-6, 0.333773],
  [0.052748, 1074e-6, 0.336841],
  [0.055469, 103e-5, 0.339854],
  [0.058253, 984e-6, 0.342813],
  [0.061104, 937e-6, 0.345715],
  [0.06402, 889e-6, 0.348557],
  [0.067002, 84e-5, 0.35134],
  [0.070051, 79e-5, 0.354059],
  [0.073167, 74e-5, 0.356714],
  [0.076351, 689e-6, 0.3593],
  [0.079604, 638e-6, 0.361817],
  [0.082925, 586e-6, 0.364261],
  [0.086315, 535e-6, 0.366628],
  [0.089775, 485e-6, 0.368918],
  [0.093303, 435e-6, 0.371125],
  [0.096902, 386e-6, 0.373248],
  [0.100571, 339e-6, 0.375284],
  [0.10431, 294e-6, 0.377229],
  [0.108119, 251e-6, 0.37908],
  [0.111999, 211e-6, 0.380834],
  [0.115949, 174e-6, 0.382488],
  [0.11997, 14e-5, 0.384038],
  [0.124062, 111e-6, 0.385483],
  [0.128224, 86e-6, 0.386818],
  [0.132456, 66e-6, 0.38804],
  [0.136758, 52e-6, 0.389146],
  [0.141129, 45e-6, 0.390134],
  [0.14557, 44e-6, 0.391002],
  [0.15008, 5e-5, 0.391747],
  [0.154657, 64e-6, 0.392365],
  [0.159303, 87e-6, 0.392855],
  [0.164016, 119e-6, 0.393214],
  [0.168797, 161e-6, 0.39344],
  [0.173642, 213e-6, 0.393532],
  [0.178553, 277e-6, 0.393489],
  [0.183529, 352e-6, 0.393307],
  [0.188567, 439e-6, 0.392987],
  [0.193667, 54e-5, 0.392528],
  [0.198828, 655e-6, 0.39193],
  [0.20405, 784e-6, 0.391191],
  [0.20933, 928e-6, 0.390312],
  [0.214669, 1088e-6, 0.389291],
  [0.220064, 1264e-6, 0.38813],
  [0.225513, 1458e-6, 0.386831],
  [0.231017, 1669e-6, 0.385394],
  [0.236571, 1899e-6, 0.38382],
  [0.242176, 2148e-6, 0.382111],
  [0.24783, 2416e-6, 0.38027],
  [0.253532, 2705e-6, 0.378299],
  [0.259278, 3015e-6, 0.376199],
  [0.265068, 3346e-6, 0.373974],
  [0.270901, 37e-4, 0.371628],
  [0.276773, 4076e-6, 0.369163],
  [0.282684, 4476e-6, 0.366584],
  [0.288633, 4899e-6, 0.363893],
  [0.294616, 5347e-6, 0.361096],
  [0.300631, 5819e-6, 0.358197],
  [0.306678, 6317e-6, 0.355199],
  [0.312755, 684e-5, 0.352109],
  [0.318857, 739e-5, 0.348931],
  [0.324986, 7966e-6, 0.345671],
  [0.331139, 8569e-6, 0.342332],
  [0.337315, 92e-4, 0.33892],
  [0.343511, 9858e-6, 0.335442],
  [0.349725, 0.010545, 0.331902],
  [0.355957, 0.011259, 0.328305],
  [0.362204, 0.012003, 0.324656],
  [0.368464, 0.012776, 0.320962],
  [0.374737, 0.013578, 0.317226],
  [0.381022, 0.014409, 0.313455],
  [0.387316, 0.015271, 0.309653],
  [0.393617, 0.016162, 0.305825],
  [0.399925, 0.017084, 0.301977],
  [0.40624, 0.018036, 0.298113],
  [0.412559, 0.019019, 0.294236],
  [0.418882, 0.020034, 0.290351],
  [0.425206, 0.021079, 0.286464],
  [0.431532, 0.022155, 0.282578],
  [0.43786, 0.023264, 0.278696],
  [0.444187, 0.024403, 0.274821],
  [0.450512, 0.025575, 0.270958],
  [0.456837, 0.026779, 0.267109],
  [0.463158, 0.028016, 0.263278],
  [0.469476, 0.029285, 0.259465],
  [0.475791, 0.030586, 0.255676],
  [0.482103, 0.03192, 0.251912],
  [0.488408, 0.033288, 0.248174],
  [0.49471, 0.034688, 0.244465],
  [0.501006, 0.036122, 0.240788],
  [0.507297, 0.03759, 0.237144],
  [0.513581, 0.039092, 0.233532],
  [0.51986, 0.040627, 0.229955],
  [0.52613, 0.042197, 0.226414],
  [0.532396, 0.043802, 0.222909],
  [0.538654, 0.045441, 0.219443],
  [0.544905, 0.047116, 0.216014],
  [0.551147, 0.048826, 0.212623],
  [0.557384, 0.050571, 0.209271],
  [0.563613, 0.052353, 0.20596],
  [0.569832, 0.05417, 0.202688],
  [0.576044, 0.056025, 0.199457],
  [0.582248, 0.057916, 0.196264],
  [0.588443, 0.059844, 0.19311],
  [0.594629, 0.06181, 0.189997],
  [0.600808, 0.063814, 0.186921],
  [0.606976, 0.065856, 0.183885],
  [0.613135, 0.067937, 0.180887],
  [0.619284, 0.070057, 0.177927],
  [0.625425, 0.072217, 0.175006],
  [0.631553, 0.074417, 0.172121],
  [0.637672, 0.076657, 0.169274],
  [0.64378, 0.078939, 0.166463],
  [0.649878, 0.081262, 0.163687],
  [0.655963, 0.083627, 0.160946],
  [0.662034, 0.086035, 0.15824],
  [0.668093, 0.088486, 0.155567],
  [0.67414, 0.09098, 0.152929],
  [0.680172, 0.093519, 0.150324],
  [0.686191, 0.096103, 0.14775],
  [0.692192, 0.098733, 0.145209],
  [0.698178, 0.101409, 0.142698],
  [0.704148, 0.104131, 0.140218],
  [0.710101, 0.106902, 0.137768],
  [0.716034, 0.10972, 0.135348],
  [0.721947, 0.112588, 0.132957],
  [0.72784, 0.115507, 0.130594],
  [0.733713, 0.118475, 0.128259],
  [0.739562, 0.121495, 0.125951],
  [0.745388, 0.124567, 0.12367],
  [0.751189, 0.127692, 0.121416],
  [0.756964, 0.130872, 0.119188],
  [0.762713, 0.134107, 0.116986],
  [0.768432, 0.137397, 0.114809],
  [0.774121, 0.140743, 0.112657],
  [0.779778, 0.144147, 0.11053],
  [0.785403, 0.147611, 0.108426],
  [0.790993, 0.151134, 0.106347],
  [0.796548, 0.154717, 0.104291],
  [0.802065, 0.158362, 0.102259],
  [0.807543, 0.162071, 0.100249],
  [0.812979, 0.165843, 0.098264],
  [0.818375, 0.169679, 0.0963],
  [0.823724, 0.173581, 0.094359],
  [0.829026, 0.177551, 0.09244],
  [0.834282, 0.181589, 0.090543],
  [0.839487, 0.185696, 0.088668],
  [0.844639, 0.189874, 0.086816],
  [0.849738, 0.194124, 0.084984],
  [0.854782, 0.198447, 0.083175],
  [0.859769, 0.202843, 0.081387],
  [0.864693, 0.207316, 0.07962],
  [0.869555, 0.211865, 0.077876],
  [0.874354, 0.216492, 0.076152],
  [0.879086, 0.221198, 0.074449],
  [0.88375, 0.225984, 0.072769],
  [0.888342, 0.230852, 0.071109],
  [0.892864, 0.235804, 0.069472],
  [0.897309, 0.240839, 0.067855],
  [0.901676, 0.24596, 0.066259],
  [0.905962, 0.251168, 0.064685],
  [0.910167, 0.256465, 0.063132],
  [0.914289, 0.261851, 0.061601],
  [0.918325, 0.267328, 0.060092],
  [0.922272, 0.272897, 0.058605],
  [0.926126, 0.27856, 0.05714],
  [0.929889, 0.284319, 0.055695],
  [0.933555, 0.290173, 0.054273],
  [0.937121, 0.296127, 0.052873],
  [0.940587, 0.302179, 0.051495],
  [0.943951, 0.308332, 0.050139],
  [0.947213, 0.314587, 0.048806],
  [0.950363, 0.320946, 0.047496],
  [0.953407, 0.327409, 0.046209],
  [0.956336, 0.333978, 0.044944],
  [0.959154, 0.340656, 0.043704],
  [0.961853, 0.347442, 0.042486],
  [0.964431, 0.354342, 0.041292],
  [0.966887, 0.361352, 0.040121],
  [0.969217, 0.368476, 0.038975],
  [0.971423, 0.375715, 0.037854],
  [0.9735, 0.383071, 0.036757],
  [0.975446, 0.390546, 0.035685],
  [0.977256, 0.398139, 0.034639],
  [0.978931, 0.405854, 0.033619],
  [0.980469, 0.413691, 0.032625],
  [0.981864, 0.421652, 0.031658],
  [0.983116, 0.42974, 0.030717],
  [0.984222, 0.437954, 0.029805],
  [0.985178, 0.446296, 0.028921],
  [0.985985, 0.45477, 0.028065],
  [0.986637, 0.463374, 0.027239],
  [0.987136, 0.472112, 0.026442],
  [0.987475, 0.480984, 0.025676],
  [0.987653, 0.489994, 0.024941],
  [0.987672, 0.499141, 0.024238],
  [0.987522, 0.508427, 0.023568],
  [0.987206, 0.517852, 0.02293],
  [0.986723, 0.527422, 0.022327],
  [0.986069, 0.537133, 0.021759],
  [0.985236, 0.546993, 0.021226],
  [0.984224, 0.556999, 0.020728],
  [0.983034, 0.567154, 0.020268],
  [0.981665, 0.577457, 0.019847],
  [0.980118, 0.587912, 0.019464],
  [0.978388, 0.598517, 0.019121],
  [0.976475, 0.609274, 0.018819],
  [0.97437, 0.620191, 0.018558],
  [0.97207, 0.631264, 0.018338],
  [0.969584, 0.642495, 0.01816],
  [0.966916, 0.65388, 0.018026],
  [0.964057, 0.665425, 0.017935],
  [0.960991, 0.677139, 0.017886],
  [0.957742, 0.689008, 0.017881],
  [0.954316, 0.701035, 0.017919],
  [0.95067, 0.713238, 0.017996],
  [0.946853, 0.725598, 0.018115],
  [0.942844, 0.738124, 0.018271],
  [0.938644, 0.750818, 0.018461],
  [0.934272, 0.763673, 0.018683],
  [0.929709, 0.776698, 0.018928],
  [0.92498, 0.789886, 0.019191],
  [0.920097, 0.803236, 0.019462],
  [0.915034, 0.816759, 0.019726],
  [0.909848, 0.83044, 0.019968],
  [0.904543, 0.844275, 0.020164],
  [0.899144, 0.858266, 0.020284],
  [0.893678, 0.872406, 0.020285],
  [0.888202, 0.886683, 0.02011],
  [0.8828, 0.901076, 0.019682],
  [0.877627, 0.915542, 0.018894],
  [0.872878, 0.930029, 0.017594],
  [0.868931, 0.944416, 0.01559]
], turboColorScheme = [
  [0.18995, 0.07176, 0.23217],
  [0.19483, 0.08339, 0.26149],
  [0.19956, 0.09498, 0.29024],
  [0.20415, 0.10652, 0.31844],
  [0.2086, 0.11802, 0.34607],
  [0.21291, 0.12947, 0.37314],
  [0.21708, 0.14087, 0.39964],
  [0.22111, 0.15223, 0.42558],
  [0.225, 0.16354, 0.45096],
  [0.22875, 0.17481, 0.47578],
  [0.23236, 0.18603, 0.50004],
  [0.23582, 0.1972, 0.52373],
  [0.23915, 0.20833, 0.54686],
  [0.24234, 0.21941, 0.56942],
  [0.24539, 0.23044, 0.59142],
  [0.2483, 0.24143, 0.61286],
  [0.25107, 0.25237, 0.63374],
  [0.25369, 0.26327, 0.65406],
  [0.25618, 0.27412, 0.67381],
  [0.25853, 0.28492, 0.693],
  [0.26074, 0.29568, 0.71162],
  [0.2628, 0.30639, 0.72968],
  [0.26473, 0.31706, 0.74718],
  [0.26652, 0.32768, 0.76412],
  [0.26816, 0.33825, 0.7805],
  [0.26967, 0.34878, 0.79631],
  [0.27103, 0.35926, 0.81156],
  [0.27226, 0.3697, 0.82624],
  [0.27334, 0.38008, 0.84037],
  [0.27429, 0.39043, 0.85393],
  [0.27509, 0.40072, 0.86692],
  [0.27576, 0.41097, 0.87936],
  [0.27628, 0.42118, 0.89123],
  [0.27667, 0.43134, 0.90254],
  [0.27691, 0.44145, 0.91328],
  [0.27701, 0.45152, 0.92347],
  [0.27698, 0.46153, 0.93309],
  [0.2768, 0.47151, 0.94214],
  [0.27648, 0.48144, 0.95064],
  [0.27603, 0.49132, 0.95857],
  [0.27543, 0.50115, 0.96594],
  [0.27469, 0.51094, 0.97275],
  [0.27381, 0.52069, 0.97899],
  [0.27273, 0.5304, 0.98461],
  [0.27106, 0.54015, 0.9893],
  [0.26878, 0.54995, 0.99303],
  [0.26592, 0.55979, 0.99583],
  [0.26252, 0.56967, 0.99773],
  [0.25862, 0.57958, 0.99876],
  [0.25425, 0.5895, 0.99896],
  [0.24946, 0.59943, 0.99835],
  [0.24427, 0.60937, 0.99697],
  [0.23874, 0.61931, 0.99485],
  [0.23288, 0.62923, 0.99202],
  [0.22676, 0.63913, 0.98851],
  [0.22039, 0.64901, 0.98436],
  [0.21382, 0.65886, 0.97959],
  [0.20708, 0.66866, 0.97423],
  [0.20021, 0.67842, 0.96833],
  [0.19326, 0.68812, 0.9619],
  [0.18625, 0.69775, 0.95498],
  [0.17923, 0.70732, 0.94761],
  [0.17223, 0.7168, 0.93981],
  [0.16529, 0.7262, 0.93161],
  [0.15844, 0.73551, 0.92305],
  [0.15173, 0.74472, 0.91416],
  [0.14519, 0.75381, 0.90496],
  [0.13886, 0.76279, 0.8955],
  [0.13278, 0.77165, 0.8858],
  [0.12698, 0.78037, 0.8759],
  [0.12151, 0.78896, 0.86581],
  [0.11639, 0.7974, 0.85559],
  [0.11167, 0.80569, 0.84525],
  [0.10738, 0.81381, 0.83484],
  [0.10357, 0.82177, 0.82437],
  [0.10026, 0.82955, 0.81389],
  [0.0975, 0.83714, 0.80342],
  [0.09532, 0.84455, 0.79299],
  [0.09377, 0.85175, 0.78264],
  [0.09287, 0.85875, 0.7724],
  [0.09267, 0.86554, 0.7623],
  [0.0932, 0.87211, 0.75237],
  [0.09451, 0.87844, 0.74265],
  [0.09662, 0.88454, 0.73316],
  [0.09958, 0.8904, 0.72393],
  [0.10342, 0.896, 0.715],
  [0.10815, 0.90142, 0.70599],
  [0.11374, 0.90673, 0.69651],
  [0.12014, 0.91193, 0.6866],
  [0.12733, 0.91701, 0.67627],
  [0.13526, 0.92197, 0.66556],
  [0.14391, 0.9268, 0.65448],
  [0.15323, 0.93151, 0.64308],
  [0.16319, 0.93609, 0.63137],
  [0.17377, 0.94053, 0.61938],
  [0.18491, 0.94484, 0.60713],
  [0.19659, 0.94901, 0.59466],
  [0.20877, 0.95304, 0.58199],
  [0.22142, 0.95692, 0.56914],
  [0.23449, 0.96065, 0.55614],
  [0.24797, 0.96423, 0.54303],
  [0.2618, 0.96765, 0.52981],
  [0.27597, 0.97092, 0.51653],
  [0.29042, 0.97403, 0.50321],
  [0.30513, 0.97697, 0.48987],
  [0.32006, 0.97974, 0.47654],
  [0.33517, 0.98234, 0.46325],
  [0.35043, 0.98477, 0.45002],
  [0.36581, 0.98702, 0.43688],
  [0.38127, 0.98909, 0.42386],
  [0.39678, 0.99098, 0.41098],
  [0.41229, 0.99268, 0.39826],
  [0.42778, 0.99419, 0.38575],
  [0.44321, 0.99551, 0.37345],
  [0.45854, 0.99663, 0.3614],
  [0.47375, 0.99755, 0.34963],
  [0.48879, 0.99828, 0.33816],
  [0.50362, 0.99879, 0.32701],
  [0.51822, 0.9991, 0.31622],
  [0.53255, 0.99919, 0.30581],
  [0.54658, 0.99907, 0.29581],
  [0.56026, 0.99873, 0.28623],
  [0.57357, 0.99817, 0.27712],
  [0.58646, 0.99739, 0.26849],
  [0.59891, 0.99638, 0.26038],
  [0.61088, 0.99514, 0.2528],
  [0.62233, 0.99366, 0.24579],
  [0.63323, 0.99195, 0.23937],
  [0.64362, 0.98999, 0.23356],
  [0.65394, 0.98775, 0.22835],
  [0.66428, 0.98524, 0.2237],
  [0.67462, 0.98246, 0.2196],
  [0.68494, 0.97941, 0.21602],
  [0.69525, 0.9761, 0.21294],
  [0.70553, 0.97255, 0.21032],
  [0.71577, 0.96875, 0.20815],
  [0.72596, 0.9647, 0.2064],
  [0.7361, 0.96043, 0.20504],
  [0.74617, 0.95593, 0.20406],
  [0.75617, 0.95121, 0.20343],
  [0.76608, 0.94627, 0.20311],
  [0.77591, 0.94113, 0.2031],
  [0.78563, 0.93579, 0.20336],
  [0.79524, 0.93025, 0.20386],
  [0.80473, 0.92452, 0.20459],
  [0.8141, 0.91861, 0.20552],
  [0.82333, 0.91253, 0.20663],
  [0.83241, 0.90627, 0.20788],
  [0.84133, 0.89986, 0.20926],
  [0.8501, 0.89328, 0.21074],
  [0.85868, 0.88655, 0.2123],
  [0.86709, 0.87968, 0.21391],
  [0.8753, 0.87267, 0.21555],
  [0.88331, 0.86553, 0.21719],
  [0.89112, 0.85826, 0.2188],
  [0.8987, 0.85087, 0.22038],
  [0.90605, 0.84337, 0.22188],
  [0.91317, 0.83576, 0.22328],
  [0.92004, 0.82806, 0.22456],
  [0.92666, 0.82025, 0.2257],
  [0.93301, 0.81236, 0.22667],
  [0.93909, 0.80439, 0.22744],
  [0.94489, 0.79634, 0.228],
  [0.95039, 0.78823, 0.22831],
  [0.9556, 0.78005, 0.22836],
  [0.96049, 0.77181, 0.22811],
  [0.96507, 0.76352, 0.22754],
  [0.96931, 0.75519, 0.22663],
  [0.97323, 0.74682, 0.22536],
  [0.97679, 0.73842, 0.22369],
  [0.98, 0.73, 0.22161],
  [0.98289, 0.7214, 0.21918],
  [0.98549, 0.7125, 0.2165],
  [0.98781, 0.7033, 0.21358],
  [0.98986, 0.69382, 0.21043],
  [0.99163, 0.68408, 0.20706],
  [0.99314, 0.67408, 0.20348],
  [0.99438, 0.66386, 0.19971],
  [0.99535, 0.65341, 0.19577],
  [0.99607, 0.64277, 0.19165],
  [0.99654, 0.63193, 0.18738],
  [0.99675, 0.62093, 0.18297],
  [0.99672, 0.60977, 0.17842],
  [0.99644, 0.59846, 0.17376],
  [0.99593, 0.58703, 0.16899],
  [0.99517, 0.57549, 0.16412],
  [0.99419, 0.56386, 0.15918],
  [0.99297, 0.55214, 0.15417],
  [0.99153, 0.54036, 0.1491],
  [0.98987, 0.52854, 0.14398],
  [0.98799, 0.51667, 0.13883],
  [0.9859, 0.50479, 0.13367],
  [0.9836, 0.49291, 0.12849],
  [0.98108, 0.48104, 0.12332],
  [0.97837, 0.4692, 0.11817],
  [0.97545, 0.4574, 0.11305],
  [0.97234, 0.44565, 0.10797],
  [0.96904, 0.43399, 0.10294],
  [0.96555, 0.42241, 0.09798],
  [0.96187, 0.41093, 0.0931],
  [0.95801, 0.39958, 0.08831],
  [0.95398, 0.38836, 0.08362],
  [0.94977, 0.37729, 0.07905],
  [0.94538, 0.36638, 0.07461],
  [0.94084, 0.35566, 0.07031],
  [0.93612, 0.34513, 0.06616],
  [0.93125, 0.33482, 0.06218],
  [0.92623, 0.32473, 0.05837],
  [0.92105, 0.31489, 0.05475],
  [0.91572, 0.3053, 0.05134],
  [0.91024, 0.29599, 0.04814],
  [0.90463, 0.28696, 0.04516],
  [0.89888, 0.27824, 0.04243],
  [0.89298, 0.26981, 0.03993],
  [0.88691, 0.26152, 0.03753],
  [0.88066, 0.25334, 0.03521],
  [0.87422, 0.24526, 0.03297],
  [0.8676, 0.2373, 0.03082],
  [0.86079, 0.22945, 0.02875],
  [0.8538, 0.2217, 0.02677],
  [0.84662, 0.21407, 0.02487],
  [0.83926, 0.20654, 0.02305],
  [0.83172, 0.19912, 0.02131],
  [0.82399, 0.19182, 0.01966],
  [0.81608, 0.18462, 0.01809],
  [0.80799, 0.17753, 0.0166],
  [0.79971, 0.17055, 0.0152],
  [0.79125, 0.16368, 0.01387],
  [0.7826, 0.15693, 0.01264],
  [0.77377, 0.15028, 0.01148],
  [0.76476, 0.14374, 0.01041],
  [0.75556, 0.13731, 942e-5],
  [0.74617, 0.13098, 851e-5],
  [0.73661, 0.12477, 769e-5],
  [0.72686, 0.11867, 695e-5],
  [0.71692, 0.11268, 629e-5],
  [0.7068, 0.1068, 571e-5],
  [0.6965, 0.10102, 522e-5],
  [0.68602, 0.09536, 481e-5],
  [0.67535, 0.0898, 449e-5],
  [0.66449, 0.08436, 424e-5],
  [0.65345, 0.07902, 408e-5],
  [0.64223, 0.0738, 401e-5],
  [0.63082, 0.06868, 401e-5],
  [0.61923, 0.06367, 41e-4],
  [0.60746, 0.05878, 427e-5],
  [0.5955, 0.05399, 453e-5],
  [0.58336, 0.04931, 486e-5],
  [0.57103, 0.04474, 529e-5],
  [0.55852, 0.04028, 579e-5],
  [0.54583, 0.03593, 638e-5],
  [0.53295, 0.03169, 705e-5],
  [0.51989, 0.02756, 78e-4],
  [0.50664, 0.02354, 863e-5],
  [0.49321, 0.01963, 955e-5],
  [0.4796, 0.01583, 0.0105]
], viridisColorScheme = [
  [0.057951, 377e-6, 0.088657],
  [0.058604, 743e-6, 0.092022],
  [0.059229, 1132e-6, 0.095424],
  [0.059826, 1543e-6, 0.098863],
  [0.060395, 1979e-6, 0.102333],
  [0.060934, 2438e-6, 0.105834],
  [0.061443, 2922e-6, 0.10936],
  [0.061923, 3431e-6, 0.112909],
  [0.062371, 3967e-6, 0.11648],
  [0.062788, 4529e-6, 0.120065],
  [0.063173, 5118e-6, 0.123664],
  [0.063526, 5736e-6, 0.127274],
  [0.063846, 6381e-6, 0.130889],
  [0.064133, 7055e-6, 0.134506],
  [0.064386, 7759e-6, 0.138124],
  [0.064606, 8493e-6, 0.141736],
  [0.064791, 9258e-6, 0.14534],
  [0.064943, 0.010053, 0.148932],
  [0.06506, 0.01088, 0.152509],
  [0.065144, 0.011739, 0.156066],
  [0.065193, 0.012631, 0.1596],
  [0.065208, 0.013555, 0.163108],
  [0.065188, 0.014513, 0.166586],
  [0.065135, 0.015504, 0.17003],
  [0.065048, 0.016529, 0.173437],
  [0.064928, 0.017588, 0.176805],
  [0.064774, 0.018681, 0.180129],
  [0.064589, 0.019809, 0.183406],
  [0.06437, 0.020973, 0.186633],
  [0.064121, 0.022171, 0.189809],
  [0.06384, 0.023404, 0.192929],
  [0.063529, 0.024672, 0.195992],
  [0.063189, 0.025975, 0.198994],
  [0.06282, 0.027314, 0.201934],
  [0.062423, 0.028687, 0.20481],
  [0.062, 0.030096, 0.20762],
  [0.06155, 0.031539, 0.210362],
  [0.061076, 0.033018, 0.213034],
  [0.060577, 0.034531, 0.215638],
  [0.060057, 0.036078, 0.218168],
  [0.059514, 0.037659, 0.220627],
  [0.058951, 0.039274, 0.223013],
  [0.058368, 0.040922, 0.225324],
  [0.057768, 0.042604, 0.227563],
  [0.057151, 0.044318, 0.229728],
  [0.056518, 0.046064, 0.23182],
  [0.055871, 0.047842, 0.233837],
  [0.055211, 0.049653, 0.235782],
  [0.054539, 0.051494, 0.237655],
  [0.053857, 0.053365, 0.239456],
  [0.053165, 0.055267, 0.241188],
  [0.052466, 0.057198, 0.24285],
  [0.051759, 0.059159, 0.244443],
  [0.051046, 0.061148, 0.24597],
  [0.050329, 0.063166, 0.247431],
  [0.049609, 0.065212, 0.248828],
  [0.048886, 0.067284, 0.250163],
  [0.048162, 0.069384, 0.251439],
  [0.047438, 0.071511, 0.252653],
  [0.046715, 0.073663, 0.253812],
  [0.045992, 0.075841, 0.254915],
  [0.045273, 0.078045, 0.255964],
  [0.044557, 0.080273, 0.256962],
  [0.043846, 0.082526, 0.25791],
  [0.043139, 0.084803, 0.258811],
  [0.042438, 0.087104, 0.259666],
  [0.041743, 0.089429, 0.260477],
  [0.041055, 0.091777, 0.261245],
  [0.040374, 0.094148, 0.261972],
  [0.039702, 0.096542, 0.262661],
  [0.039037, 0.098959, 0.263313],
  [0.038382, 0.101398, 0.263929],
  [0.037736, 0.10386, 0.264512],
  [0.037099, 0.106344, 0.265063],
  [0.036472, 0.10885, 0.265583],
  [0.035855, 0.111378, 0.266076],
  [0.035249, 0.113928, 0.26654],
  [0.034653, 0.1165, 0.266978],
  [0.034067, 0.119093, 0.267391],
  [0.033492, 0.12171, 0.26778],
  [0.032927, 0.124348, 0.268147],
  [0.032373, 0.127008, 0.268493],
  [0.031829, 0.12969, 0.268817],
  [0.031296, 0.132394, 0.269123],
  [0.030773, 0.135121, 0.26941],
  [0.03026, 0.137871, 0.269678],
  [0.029758, 0.140643, 0.269929],
  [0.029265, 0.143438, 0.270163],
  [0.028781, 0.146257, 0.270381],
  [0.028308, 0.149099, 0.270584],
  [0.027843, 0.151964, 0.270771],
  [0.027387, 0.154853, 0.270943],
  [0.02694, 0.157767, 0.2711],
  [0.026501, 0.160704, 0.271243],
  [0.02607, 0.163666, 0.271371],
  [0.025648, 0.166653, 0.271485],
  [0.025232, 0.169666, 0.271584],
  [0.024824, 0.172704, 0.271669],
  [0.024423, 0.175767, 0.271738],
  [0.024028, 0.178857, 0.271793],
  [0.02364, 0.181974, 0.271833],
  [0.023257, 0.185117, 0.271856],
  [0.022881, 0.188288, 0.271863],
  [0.02251, 0.191486, 0.271855],
  [0.022144, 0.194713, 0.271828],
  [0.021784, 0.197967, 0.271784],
  [0.021428, 0.20125, 0.27172],
  [0.021077, 0.204563, 0.271638],
  [0.02073, 0.207904, 0.271536],
  [0.020388, 0.211275, 0.271412],
  [0.02005, 0.214676, 0.271267],
  [0.019716, 0.218107, 0.2711],
  [0.019387, 0.221569, 0.270909],
  [0.019062, 0.225062, 0.270695],
  [0.018741, 0.228585, 0.270456],
  [0.018425, 0.232141, 0.270189],
  [0.018113, 0.235728, 0.269896],
  [0.017806, 0.239348, 0.269574],
  [0.017504, 0.242998, 0.269222],
  [0.017207, 0.246682, 0.268841],
  [0.016916, 0.250399, 0.268426],
  [0.01663, 0.254148, 0.26798],
  [0.016352, 0.25793, 0.267501],
  [0.01608, 0.261746, 0.266987],
  [0.015816, 0.265594, 0.266436],
  [0.015559, 0.269476, 0.265849],
  [0.015312, 0.273392, 0.265224],
  [0.015074, 0.27734, 0.264559],
  [0.014846, 0.281323, 0.263854],
  [0.014629, 0.285339, 0.263107],
  [0.014425, 0.289389, 0.26232],
  [0.014234, 0.293472, 0.261488],
  [0.014058, 0.297589, 0.260613],
  [0.013896, 0.301738, 0.259692],
  [0.013751, 0.305921, 0.258725],
  [0.013624, 0.310137, 0.257711],
  [0.013516, 0.314387, 0.25665],
  [0.013429, 0.318668, 0.255539],
  [0.013364, 0.322982, 0.254381],
  [0.013322, 0.327328, 0.253173],
  [0.013306, 0.331706, 0.251913],
  [0.013317, 0.336116, 0.250602],
  [0.013356, 0.340556, 0.249239],
  [0.013427, 0.345028, 0.247824],
  [0.013529, 0.34953, 0.246357],
  [0.013667, 0.354061, 0.244837],
  [0.013841, 0.358623, 0.243264],
  [0.014054, 0.363213, 0.241636],
  [0.014308, 0.367831, 0.239956],
  [0.014605, 0.372476, 0.238221],
  [0.014948, 0.37715, 0.236432],
  [0.015339, 0.381849, 0.234589],
  [0.01578, 0.386576, 0.232692],
  [0.016275, 0.391326, 0.230742],
  [0.016825, 0.396101, 0.228738],
  [0.017434, 0.400899, 0.22668],
  [0.018104, 0.405721, 0.224569],
  [0.018839, 0.410564, 0.222406],
  [0.019641, 0.415427, 0.220191],
  [0.020512, 0.420312, 0.217923],
  [0.021457, 0.425216, 0.215605],
  [0.022479, 0.430137, 0.213236],
  [0.02358, 0.435077, 0.210818],
  [0.024764, 0.440032, 0.20835],
  [0.026034, 0.445004, 0.205835],
  [0.027394, 0.449988, 0.203271],
  [0.028847, 0.454985, 0.200662],
  [0.030396, 0.459995, 0.198008],
  [0.032046, 0.465016, 0.19531],
  [0.0338, 0.470046, 0.192569],
  [0.035662, 0.475083, 0.189786],
  [0.037636, 0.480128, 0.186964],
  [0.039725, 0.485178, 0.184101],
  [0.041933, 0.490234, 0.181201],
  [0.044266, 0.495291, 0.178265],
  [0.046725, 0.500351, 0.175294],
  [0.049317, 0.505412, 0.172291],
  [0.052044, 0.51047, 0.169257],
  [0.054912, 0.515526, 0.166192],
  [0.057924, 0.520578, 0.163099],
  [0.061085, 0.525624, 0.15998],
  [0.0644, 0.530664, 0.156835],
  [0.067873, 0.535693, 0.153669],
  [0.071508, 0.540713, 0.150482],
  [0.07531, 0.545721, 0.147277],
  [0.079283, 0.550717, 0.144055],
  [0.083433, 0.555697, 0.140819],
  [0.087764, 0.56066, 0.13757],
  [0.092281, 0.565604, 0.134309],
  [0.096989, 0.570529, 0.13104],
  [0.101893, 0.575431, 0.127766],
  [0.106996, 0.58031, 0.124487],
  [0.112305, 0.585164, 0.121207],
  [0.117824, 0.58999, 0.117928],
  [0.123558, 0.594789, 0.114652],
  [0.129511, 0.599556, 0.111381],
  [0.13569, 0.604294, 0.108118],
  [0.142099, 0.608994, 0.104864],
  [0.148743, 0.61366, 0.101623],
  [0.155627, 0.618288, 0.098396],
  [0.162755, 0.622878, 0.095187],
  [0.170133, 0.627427, 0.091997],
  [0.177764, 0.631934, 0.08883],
  [0.185654, 0.636396, 0.085689],
  [0.193807, 0.640814, 0.082573],
  [0.202228, 0.645183, 0.079488],
  [0.210921, 0.649503, 0.076436],
  [0.219891, 0.653773, 0.073418],
  [0.229143, 0.657992, 0.070438],
  [0.238679, 0.662158, 0.067497],
  [0.248505, 0.666268, 0.064598],
  [0.258623, 0.670321, 0.061745],
  [0.269037, 0.674319, 0.058939],
  [0.279751, 0.678259, 0.056184],
  [0.290765, 0.68214, 0.053482],
  [0.302085, 0.685959, 0.050835],
  [0.313712, 0.689719, 0.048246],
  [0.325648, 0.693417, 0.045718],
  [0.337896, 0.697053, 0.043253],
  [0.350455, 0.700627, 0.040853],
  [0.36333, 0.704139, 0.038521],
  [0.376517, 0.707588, 0.036261],
  [0.390019, 0.710975, 0.034073],
  [0.403835, 0.714298, 0.031961],
  [0.417964, 0.717561, 0.029928],
  [0.432405, 0.720763, 0.027975],
  [0.447156, 0.723903, 0.026105],
  [0.462213, 0.726986, 0.024321],
  [0.477577, 0.73001, 0.022625],
  [0.493243, 0.732978, 0.021019],
  [0.509206, 0.735891, 0.019506],
  [0.525461, 0.738751, 0.018088],
  [0.542004, 0.741563, 0.016767],
  [0.558831, 0.744325, 0.015547],
  [0.575932, 0.747041, 0.014427],
  [0.593305, 0.749717, 0.013413],
  [0.61094, 0.752351, 0.012504],
  [0.628828, 0.754949, 0.011704],
  [0.646966, 0.757514, 0.011015],
  [0.665344, 0.760049, 0.010438],
  [0.683952, 0.762557, 9977e-6],
  [0.702782, 0.765044, 9632e-6],
  [0.721825, 0.767511, 9406e-6],
  [0.741074, 0.769964, 9301e-6],
  [0.760518, 0.772406, 932e-5],
  [0.78015, 0.774839, 9463e-6],
  [0.799958, 0.77727, 9734e-6],
  [0.819936, 0.779699, 0.010134],
  [0.840064, 0.782139, 0.010666],
  [0.86034, 0.784586, 0.011331],
  [0.880758, 0.787046, 0.012132],
  [0.901311, 0.789521, 0.01307],
  [0.92199, 0.792017, 0.014148],
  [0.942786, 0.794535, 0.015368],
  [0.963693, 0.797078, 0.016732],
  [0.984708, 0.799651, 0.018243]
], gammaIIColorScheme = [
  [102, 255, 51],
  [255, 90, 0],
  [255, 255, 0]
], jetColorScheme = [
  [0, 0, 0.214041],
  [0, 0, 1],
  [0, 0.214041, 1],
  [0, 1, 1],
  [0.214041, 1, 0.214041],
  [1, 1, 0],
  [1, 0.214041, 0],
  [1, 0, 0],
  [0.214041, 0, 0]
], rgbMaxValue = 255;
function intensityToIndex(C) {
  return C < 0 ? 0 : C > 1 ? rgbMaxValue : Number.isNaN(C) ? 0 : Math.round(C * rgbMaxValue);
}
function precomputedRgb(C, L) {
  const A = intensityToIndex(L), W = C[A];
  return [W[0] * rgbMaxValue, W[1] * rgbMaxValue, W[2] * rgbMaxValue];
}
function makeScaler(C) {
  return (L) => C(L).rgb();
}
const roseusScale = precomputedRgb.bind(null, roseus), viridisScale = precomputedRgb.bind(null, viridisColorScheme), turboScale = precomputedRgb.bind(null, turboColorScheme), plasmaScale = precomputedRgb.bind(null, plasmaColorScheme), infernoScale = precomputedRgb.bind(null, infernoColorScheme), magmaScale = precomputedRgb.bind(null, magmaColorScheme), cubeHelixScale = makeScaler(chroma.cubehelix().scale()), gammaIIScale = makeScaler(chroma.scale(gammaIIColorScheme.map((C) => chroma.rgb(C[0], C[1], C[2]))).mode("lab")), jetScale = makeScaler(
  chroma.scale(jetColorScheme.map((C) => chroma.rgb(C[0] * 255, C[1] * 255, C[2] * 255))).mode("lrgb")
), colorScales = {
  grayscale: "Greys",
  blue: "Blues",
  green: "Greens",
  orange: "Oranges",
  purple: "Purples",
  red: "Reds",
  audacity: roseusScale,
  roseus: roseusScale,
  viridis: viridisScale,
  turbo: turboScale,
  plasma: plasmaScale,
  inferno: infernoScale,
  magma: magmaScale,
  cubeHelix: cubeHelixScale,
  gammaII: gammaIIScale,
  jet: jetScale,
  raven: jetScale
}, SPACE_KEY = " ", ENTER_KEY = "Enter", ESCAPE_KEY = "Escape", LEFT_ARROW_KEY = "ArrowLeft", RIGHT_ARROW_KEY = "ArrowRight", mediaControlsStyles = ":host{display:flex;position:relative;justify-content:center;width:-moz-fit-content;width:fit-content;margin:auto}sl-menu-item[checked]::part(base){background-color:var(--oe-selected-color);color:var(--oe-font-color)}sl-icon[name=play],sl-icon[name=pause]{--enlargement-factor: 1.5;font-size:calc(var(--oe-font-size) * var(--enlargement-factor));padding:calc(var(--oe-spacing) / var(--enlargement-factor))}.container{display:flex;position:relative;align-items:center;justify-content:center;margin-top:var(--oe-spacing);margin-bottom:var(--oe-spacing);color:var(--oe-font-color);width:-moz-fit-content;width:fit-content;background-color:var(--oe-background-color);border-radius:var(--oe-border-rounding);box-shadow:var(--oe-box-shadow);font-size:calc(var(--oe-font-size));overflow:hidden}.container>:hover{background-color:var(--oe-panel-color)}.container>*:not(:last-child){border-right:1px solid var(--oe-font-color-lighter)}";
var __defProp$b = Object.defineProperty, __getOwnPropDesc$b = Object.getOwnPropertyDescriptor, __decorateClass$b = (C, L, A, W) => {
  for (var X = W > 1 ? void 0 : W ? __getOwnPropDesc$b(L, A) : L, J = C.length - 1, te; J >= 0; J--)
    (te = C[J]) && (X = (W ? te(L, A, X) : te(X)) || X);
  return W && X && __defProp$b(L, A, X), X;
};
let MediaControlsComponent = class extends AbstractComponent(h$1) {
  constructor() {
    super(...arguments), this.visible = !0, this.for = "", this.playIconPosition = "default", this.logger = {
      log: console.log
    }, this.playHandler = this.handleUpdatePlaying.bind(this), this.keyDownHandler = this.handleKeyDown.bind(this);
  }
  disconnectedCallback() {
    var C;
    (C = this.spectrogramElement) == null || C.removeEventListener("play", this.playHandler), document.removeEventListener("keydown", this.keyDownHandler), super.disconnectedCallback();
  }
  toggleAudio(C = !1) {
    if (!this.spectrogramElement)
      throw new Error("No spectrogram element found");
    this.isSpectrogramPlaying() ? this.spectrogramElement.pause(C) : this.spectrogramElement.play(C);
  }
  isSpectrogramPlaying() {
    var C;
    return this.spectrogramElement ? !((C = this.spectrogramElement) != null && C.paused) : !1;
  }
  willUpdate(C) {
    var L, A, W;
    if (C.has("for")) {
      if ((L = this.spectrogramElement) == null || L.removeEventListener("play", this.playHandler), !this.for) {
        this.spectrogramElement = null;
        return;
      }
      if (document.addEventListener("keydown", this.keyDownHandler), this.spectrogramElement = (A = this.parentElement) == null ? void 0 : A.querySelector(`#${this.for}`), (W = this.spectrogramElement) == null || W.addEventListener("play", this.playHandler), !this.spectrogramElement)
        return;
      this.axesElement = MediaControlsComponent.recursiveAxesSearch(this.spectrogramElement);
    }
  }
  handleKeyDown(C) {
    C.key === SPACE_KEY && this.toggleAudio(!0);
  }
  handleUpdatePlaying() {
    this.logger.log(`Audio ${this.isSpectrogramPlaying() ? "playing" : "paused"} `), this.requestUpdate();
  }
  playIcon() {
    return ke$1`
      <slot name="play-icon" part="play-icon">
        <sl-icon name="play"></sl-icon>
      </slot>
    `;
  }
  pauseIcon() {
    return ke$1`
      <slot name="pause-icon" part="pause-icon">
        <sl-icon name="pause"></sl-icon>
      </slot>
    `;
  }
  selectSettingsTemplate(C, L, A, W) {
    return ke$1`
      <sl-menu-item>
        ${C}
        <sl-menu @sl-select="${W}" slot="submenu">
          ${L.map(
      (X) => ke$1`<sl-menu-item
                type="${X == A ? "checkbox" : "normal"}"
                value="${X}"
                ?checked=${X == A}
              >
                ${X}
              </sl-menu-item>`
    )}
        </sl-menu>
      </sl-menu-item>
    `;
  }
  additionalSettingsTemplate() {
    var J, te, oe, ne, re, ce;
    if (!this.spectrogramElement)
      return D;
    const C = this.spectrogramElement.possibleWindowSizes, L = this.spectrogramElement.possibleWindowOverlaps, A = this.spectrogramElement.spectrogramOptions, W = (ue) => (de) => {
      if (!this.spectrogramElement)
        throw new Error("No spectrogram element found");
      let be = ["windowSize", "windowOverlap"].includes(ue) ? Number(de.detail.item.value) : de.detail.item.value;
      ue === "melScale" && (be = be === "mel");
      const pe = this.spectrogramElement.spectrogramOptions;
      ue === "windowSize" && this.spectrogramElement && this.spectrogramElement.spectrogramOptions.windowOverlap >= be && (pe.windowOverlap = be / 2), this.spectrogramElement.spectrogramOptions = {
        ...pe,
        [ue]: be
      }, this.requestUpdate();
    }, X = (ue) => {
      if (!this.axesElement)
        throw new Error("No axes element found");
      const be = ue.detail.item.querySelector("input[type=checkbox]");
      if (!be)
        throw new Error("No checkbox element found");
      const pe = be.name, me = be.checked;
      this.axesElement[pe] = me;
    };
    return ke$1`
      <sl-dropdown title="Additional Settings" hoist>
        <a slot="trigger">
          <sl-icon name="gear"></sl-icon>
        </a>
        <sl-menu>
          ${this.selectSettingsTemplate(
      "Window Function",
      Array.from(windowFunctions.keys()),
      A.windowFunction,
      W("windowFunction")
    )}
          ${this.selectSettingsTemplate(
      "Window Size",
      C,
      A.windowSize,
      W("windowSize")
    )}
          ${this.selectSettingsTemplate(
      "Window Overlap",
      [0, ...L],
      A.windowOverlap,
      W("windowOverlap")
    )}
          ${this.selectSettingsTemplate(
      "Scale",
      ["linear", "mel"],
      A.melScale ? "mel" : "linear",
      W("melScale")
    )}
          <sl-menu-item>
            Axes
            <sl-menu @sl-select="${X}" slot="submenu">
              <sl-menu-item>
                <label>
                  <input type="checkbox" name="showXTitle" ?checked=${(J = this.axesElement) == null ? void 0 : J.showXTitle} />
                  X-Axis Title
                </label>
              </sl-menu-item>

              <sl-menu-item>
                <label>
                  <input type="checkbox" name="showYTitle" ?checked=${(te = this.axesElement) == null ? void 0 : te.showYTitle} />
                  Y-Axis Title
                </label>
              </sl-menu-item>

              <sl-menu-item>
                <label>
                  <input type="checkbox" name="showXAxis" ?checked=${(oe = this.axesElement) == null ? void 0 : oe.showXAxis} />
                  X-Axis Labels
                </label>
              </sl-menu-item>

              <sl-menu-item>
                <label>
                  <input type="checkbox" name="showYAxis" ?checked=${(ne = this.axesElement) == null ? void 0 : ne.showYAxis} />
                  Y-Axis Labels
                </label>
              </sl-menu-item>

              <sl-menu-item>
                <label>
                  <input type="checkbox" name="showXGrid" ?checked=${(re = this.axesElement) == null ? void 0 : re.showXGrid} />
                  X-Axis Grid Lines
                </label>
              </sl-menu-item>

              <sl-menu-item>
                <label>
                  <input type="checkbox" name="showYGrid" ?checked=${(ce = this.axesElement) == null ? void 0 : ce.showYGrid} />
                  Y-Axis Grid Lines
                </label>
              </sl-menu-item>
            </sl-menu>
          </sl-menu-item>
        </sl-menu>
      </sl-dropdown>
    `;
  }
  spectrogramSettingsTemplate() {
    var X;
    const C = (J) => {
      if (!this.spectrogramElement)
        throw new Error("No spectrogram element found");
      const te = J.detail.item.value, oe = this.spectrogramElement.spectrogramOptions;
      this.spectrogramElement.spectrogramOptions = {
        ...oe,
        colorMap: te
      }, this.requestUpdate();
    }, L = (J) => {
      if (!this.spectrogramElement)
        throw new Error("No spectrogram element found");
      const te = J.target.value, oe = J.target.name, ne = this.spectrogramElement.spectrogramOptions;
      this.spectrogramElement.spectrogramOptions = {
        ...ne,
        [oe]: Number(te)
      };
    }, A = Object.keys(colorScales), W = ((X = this.spectrogramElement) == null ? void 0 : X.spectrogramOptions.colorMap) ?? "grayscale";
    return ke$1`
      <sl-dropdown title="Colour" hoist>
        <a slot="trigger">
          <sl-icon name="palette"></sl-icon>
        </a>
        <sl-menu @sl-select="${C}">
          ${A.map(
      (J) => ke$1`<sl-menu-item
                value="${J}"
                type="${J == W ? "checkbox" : "normal"}"
                ?checked="${J == W}"
              >
                ${J}
              </sl-menu-item>`
    )}
        </sl-menu>
      </sl-dropdown>

      <sl-dropdown title="Brightness" hoist>
        <a slot="trigger">
          <sl-icon name="brightness-high"></sl-icon>
        </a>

        <sl-menu>
          <label>
            <input
              @change="${L}"
              name="brightness"
              type="range"
              min="-0.5"
              max="0.5"
              step="0.1"
              value="0"
            />
          </label>
        </sl-menu>
      </sl-dropdown>

      <sl-dropdown title="Contrast" hoist>
        <a slot="trigger">
          <sl-icon name="circle-half"></sl-icon>
        </a>

        <sl-menu>
          <label>
            <input @change="${L}" name="contrast" type="range" min="0" max="2" step="0.1" value="1" />
          </label>
        </sl-menu>
      </sl-dropdown>

      ${this.additionalSettingsTemplate()}
    `;
  }
  render() {
    return this.visible ? ke$1`
      <div class="container">
        <a id="action-button" @click="${() => this.toggleAudio(!1)}">
          ${this.isSpectrogramPlaying() ? this.pauseIcon() : this.playIcon()}
        </a>

        ${this.spectrogramSettingsTemplate()}
      </div>
    ` : D;
  }
};
MediaControlsComponent.styles = r$6(mediaControlsStyles);
MediaControlsComponent.recursiveAxesSearch = (C) => C instanceof AxesComponent ? C : C.parentElement ? MediaControlsComponent.recursiveAxesSearch(C.parentElement) : null;
__decorateClass$b([
  n$1({ type: Boolean, converter: booleanConverter })
], MediaControlsComponent.prototype, "visible", 2);
__decorateClass$b([
  n$1({ type: String })
], MediaControlsComponent.prototype, "for", 2);
__decorateClass$b([
  n$1({ type: String })
], MediaControlsComponent.prototype, "playIconPosition", 2);
__decorateClass$b([
  e$2({ context: rootContext })
], MediaControlsComponent.prototype, "logger", 2);
MediaControlsComponent = __decorateClass$b([
  t$4("oe-media-controls")
], MediaControlsComponent);
class RenderWindow {
  constructor(L, A, W, X) {
    this.startOffset = L, this.endOffset = A, this.lowFrequency = W, this.highFrequency = X;
  }
  // changes the render window to a DOM representation that can be used in the
  // window="" attribute of the oe-spectrogram component
  // format: x0, y0, x1, y1
  toDom() {
    return `${this.startOffset}, ${this.lowFrequency}, ${this.endOffset}, ${this.highFrequency}`;
  }
}
class AudioModel {
  constructor(L, A, W) {
    this.duration = L, this.sampleRate = A, this.originalAudioRecording = W;
  }
}
function hertzToMels(C) {
  return 1127 * Math.log(1 + C / 700);
}
const identityFunction = (C) => C;
class UnitConverter {
  constructor(L, A, W, X) {
    this.nyquist = w(() => this.audioModel.value.sampleRate / 2), this.frequencyInterpolator = w(() => this.melScale.value ? hertzToMels : (J) => J), this.temporalDomain = w(() => [
      this.renderWindow.value.startOffset,
      this.renderWindow.value.endOffset
    ]), this.frequencyDomain = w(() => [
      this.frequencyInterpolator.value(0),
      this.frequencyInterpolator.value(this.nyquist.value)
    ]), this.temporalRange = w(() => [0, this.canvasSize.value.width]), this.frequencyRange = w(() => [this.canvasSize.value.height, 0]), this.scaleX = w(
      () => this.linearScale(this.temporalDomain.value, this.temporalRange.value)
    ), this.scaleXInverse = w(
      () => this.inverseLinearScale(this.temporalDomain.value, this.temporalRange.value)
    ), this.scaleY = w(
      () => this.linearScale(this.frequencyDomain.value, this.frequencyRange.value, this.frequencyInterpolator.value)
    ), this.scaleYInverse = w(
      () => this.inverseLinearScale(this.frequencyDomain.value, this.frequencyRange.value, this.frequencyInterpolator.value)
    ), this.renderWindow = L, this.canvasSize = A, this.audioModel = W, this.melScale = X;
  }
  // TODO: I think passing in a scaleConverter here is a hack
  /**
   * @returns a function that converts a value to a pixel value
   */
  linearScale(L, A, W = identityFunction) {
    const X = this.calculateMagnitude(L, A);
    return (J) => W(J) * X + A[0];
  }
  /**
   * @returns a function that converts a pixel value to a value
   */
  inverseLinearScale(L, A, W = identityFunction) {
    const X = this.calculateMagnitude(L, A);
    return (J) => (W(J) - A[0]) / X;
  }
  /**
   * calculate the magnitude of a linear function using
   * (y_2 - y_1) / (x_2 - x_1)
   *
   * @returns the magnitude of the mathematical function
   */
  calculateMagnitude(L, A) {
    return L[1] === L[0] ? 0 : (A[1] - A[0]) / (L[1] - L[0]);
  }
}
const sr = class sr {
  constructor() {
  }
  static get instance() {
    return this._instance || (this._instance = new ResizeObserver((L) => {
      var A;
      for (const W of L)
        (A = this.callbacks.get(W.target)) == null || A(L, this._instance);
    })), this._instance;
  }
  static observe(L, A) {
    this.callbacks.set(L, A), this.instance.observe(L);
  }
  static unobserve(L) {
    this.instance.unobserve(L), this.callbacks.delete(L);
  }
};
sr.callbacks = /* @__PURE__ */ new WeakMap();
let OeResizeObserver = sr;
function sleep(C) {
  const L = secondsToMilliseconds(C);
  return new Promise((A) => setTimeout(A, L));
}
function secondsToMilliseconds(C) {
  return C * 1e3;
}
var STATE = /* @__PURE__ */ ((C) => (C[C.BUFFER_AVAILABLE = 0] = "BUFFER_AVAILABLE", C[C.BUFFER_WRITE_HEAD = 1] = "BUFFER_WRITE_HEAD", C[C.WORKER_STATE = 2] = "WORKER_STATE", C[C.GENERATION = 3] = "GENERATION", C[C.PROCESSOR_READY = 4] = "PROCESSOR_READY", C[C.PROCESSOR_COMPLETE = 5] = "PROCESSOR_COMPLETE", C))(STATE || {});
const INITIAL_GENERATION = -1;
class State {
  /**
   * Create a new SharedArrayBuffer that backs the state object.
   * @param fullBufferLength The number of samples after which the worker will be activated.
   */
  static createState() {
    const L = new SharedArrayBuffer(Object.keys(STATE).length / 2 * Int32Array.BYTES_PER_ELEMENT), A = new State(L);
    return A.processorReadyGeneration = INITIAL_GENERATION, A.processorCompleteGeneration = INITIAL_GENERATION, A;
  }
  constructor(L) {
    this.state = new Int32Array(L);
  }
  /**
   * Export the storage buffer for the state as a SharedArrayBuffer.
   */
  get stateBuffer() {
    return this.state.buffer;
  }
  get bufferAvailable() {
    return Atomics.load(
      this.state,
      0
      /* BUFFER_AVAILABLE */
    ) === 1;
  }
  /**
   * Notifies!
   */
  set bufferAvailable(L) {
    Atomics.store(this.state, 0, L), Atomics.notify(this.state, 0, L);
  }
  get bufferWriteHead() {
    return Atomics.load(
      this.state,
      1
      /* BUFFER_WRITE_HEAD */
    );
  }
  set bufferWriteHead(L) {
    Atomics.store(this.state, 1, L);
  }
  get workerNew() {
    return Atomics.load(
      this.state,
      2
      /* WORKER_STATE */
    ) === 0;
  }
  get workerIdle() {
    return Atomics.load(
      this.state,
      2
      /* WORKER_STATE */
    ) === 1;
  }
  get workerProcessing() {
    return Atomics.load(
      this.state,
      2
      /* WORKER_STATE */
    ) === 2;
  }
  set workerProcessing(L) {
    Atomics.store(this.state, 2, L), Atomics.notify(this.state, 2, L);
  }
  get generation() {
    return Atomics.load(
      this.state,
      3
      /* GENERATION */
    );
  }
  get processorReadyGeneration() {
    return Atomics.load(
      this.state,
      4
      /* PROCESSOR_READY */
    );
  }
  set processorReadyGeneration(L) {
    Atomics.store(this.state, 4, L);
  }
  get processorCompleteGeneration() {
    return Atomics.load(
      this.state,
      5
      /* PROCESSOR_COMPLETE */
    );
  }
  set processorCompleteGeneration(L) {
    Atomics.store(this.state, 5, L);
  }
  isProcessorReady(L) {
    return Atomics.load(
      this.state,
      4
      /* PROCESSOR_READY */
    ) === L;
  }
  isProcessorComplete(L) {
    return Atomics.load(
      this.state,
      5
      /* PROCESSOR_COMPLETE */
    ) === L;
  }
  /**
   * Called by the main thread when the processor has finished writing to the buffer.
   * The processor has no more samples to write. We trigger the buffer available state
   * to signal the worker to process the buffer.
   */
  processorComplete(L) {
    const A = this.processorCompleteGeneration;
    L > A && (this.processorCompleteGeneration = L), L === A + 1 && (this.bufferAvailable = 1);
  }
  /**
   * Called by the main thread when options have changed.
   * The generation is incremented.
   * The old processor should be discarded.
   * The worker should be updated.
   * @returns The new generation.
   */
  reset() {
    const A = Atomics.add(this.state, 3, 1) + 1;
    return this.bufferWriteHead = 0, this.bufferAvailable = 0, A;
  }
  matchesCurrentGeneration(L) {
    return Atomics.load(
      this.state,
      3
      /* GENERATION */
    ) === L;
  }
  /**
   * Called by the main thread when it is waiting for the processor to be ready.
   */
  async waitForProcessorReady(L) {
    for (; this.processorReadyGeneration < L; )
      await sleep(0);
    return this.matchesCurrentGeneration(L);
  }
  /**
   * Called by the main thread when it is waiting for the processor to be ready.
   */
  async waitForWorkerReady() {
    for (; this.workerNew; )
      await sleep(0);
  }
  async waitForWorkerIdle() {
    for (; !this.workerIdle; )
      await sleep(0);
  }
}
var commonjsGlobal = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function getDefaultExportFromCjs$1(C) {
  return C && C.__esModule && Object.prototype.hasOwnProperty.call(C, "default") ? C.default : C;
}
function getAugmentedNamespace(C) {
  if (C.__esModule) return C;
  var L = C.default;
  if (typeof L == "function") {
    var A = function W() {
      return this instanceof W ? Reflect.construct(L, arguments, this.constructor) : L.apply(this, arguments);
    };
    A.prototype = L.prototype;
  } else A = {};
  return Object.defineProperty(A, "__esModule", { value: !0 }), Object.keys(C).forEach(function(W) {
    var X = Object.getOwnPropertyDescriptor(C, W);
    Object.defineProperty(A, W, X.get ? X : {
      enumerable: !0,
      get: function() {
        return C[W];
      }
    });
  }), A;
}
var lib$3 = {};
function getDefaultExportFromCjs(C) {
  return C && C.__esModule && Object.prototype.hasOwnProperty.call(C, "default") ? C.default : C;
}
var browser$3 = { exports: {} }, process = browser$3.exports = {}, cachedSetTimeout, cachedClearTimeout;
function defaultSetTimout() {
  throw new Error("setTimeout has not been defined");
}
function defaultClearTimeout() {
  throw new Error("clearTimeout has not been defined");
}
(function() {
  try {
    typeof setTimeout == "function" ? cachedSetTimeout = setTimeout : cachedSetTimeout = defaultSetTimout;
  } catch {
    cachedSetTimeout = defaultSetTimout;
  }
  try {
    typeof clearTimeout == "function" ? cachedClearTimeout = clearTimeout : cachedClearTimeout = defaultClearTimeout;
  } catch {
    cachedClearTimeout = defaultClearTimeout;
  }
})();
function runTimeout(C) {
  if (cachedSetTimeout === setTimeout)
    return setTimeout(C, 0);
  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout)
    return cachedSetTimeout = setTimeout, setTimeout(C, 0);
  try {
    return cachedSetTimeout(C, 0);
  } catch {
    try {
      return cachedSetTimeout.call(null, C, 0);
    } catch {
      return cachedSetTimeout.call(this, C, 0);
    }
  }
}
function runClearTimeout(C) {
  if (cachedClearTimeout === clearTimeout)
    return clearTimeout(C);
  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout)
    return cachedClearTimeout = clearTimeout, clearTimeout(C);
  try {
    return cachedClearTimeout(C);
  } catch {
    try {
      return cachedClearTimeout.call(null, C);
    } catch {
      return cachedClearTimeout.call(this, C);
    }
  }
}
var queue = [], draining = !1, currentQueue, queueIndex = -1;
function cleanUpNextTick() {
  !draining || !currentQueue || (draining = !1, currentQueue.length ? queue = currentQueue.concat(queue) : queueIndex = -1, queue.length && drainQueue());
}
function drainQueue() {
  if (!draining) {
    var C = runTimeout(cleanUpNextTick);
    draining = !0;
    for (var L = queue.length; L; ) {
      for (currentQueue = queue, queue = []; ++queueIndex < L; )
        currentQueue && currentQueue[queueIndex].run();
      queueIndex = -1, L = queue.length;
    }
    currentQueue = null, draining = !1, runClearTimeout(C);
  }
}
process.nextTick = function(C) {
  var L = new Array(arguments.length - 1);
  if (arguments.length > 1)
    for (var A = 1; A < arguments.length; A++)
      L[A - 1] = arguments[A];
  queue.push(new Item(C, L)), queue.length === 1 && !draining && runTimeout(drainQueue);
};
function Item(C, L) {
  this.fun = C, this.array = L;
}
Item.prototype.run = function() {
  this.fun.apply(null, this.array);
};
process.title = "browser";
process.browser = !0;
process.env = {};
process.argv = [];
process.version = "";
process.versions = {};
function noop$2() {
}
process.on = noop$2;
process.addListener = noop$2;
process.once = noop$2;
process.off = noop$2;
process.removeListener = noop$2;
process.removeAllListeners = noop$2;
process.emit = noop$2;
process.prependListener = noop$2;
process.prependOnceListener = noop$2;
process.listeners = function(C) {
  return [];
};
process.binding = function(C) {
  throw new Error("process.binding is not supported");
};
process.cwd = function() {
  return "/";
};
process.chdir = function(C) {
  throw new Error("process.chdir is not supported");
};
process.umask = function() {
  return 0;
};
var browserExports$1 = browser$3.exports;
const process$1 = /* @__PURE__ */ getDefaultExportFromCjs(browserExports$1);
var browser$2 = { exports: {} }, ms, hasRequiredMs;
function requireMs() {
  if (hasRequiredMs) return ms;
  hasRequiredMs = 1;
  var C = 1e3, L = C * 60, A = L * 60, W = A * 24, X = W * 7, J = W * 365.25;
  ms = function(ce, ue) {
    ue = ue || {};
    var de = typeof ce;
    if (de === "string" && ce.length > 0)
      return te(ce);
    if (de === "number" && isFinite(ce))
      return ue.long ? ne(ce) : oe(ce);
    throw new Error(
      "val is not a non-empty string or a valid number. val=" + JSON.stringify(ce)
    );
  };
  function te(ce) {
    if (ce = String(ce), !(ce.length > 100)) {
      var ue = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        ce
      );
      if (ue) {
        var de = parseFloat(ue[1]), be = (ue[2] || "ms").toLowerCase();
        switch (be) {
          case "years":
          case "year":
          case "yrs":
          case "yr":
          case "y":
            return de * J;
          case "weeks":
          case "week":
          case "w":
            return de * X;
          case "days":
          case "day":
          case "d":
            return de * W;
          case "hours":
          case "hour":
          case "hrs":
          case "hr":
          case "h":
            return de * A;
          case "minutes":
          case "minute":
          case "mins":
          case "min":
          case "m":
            return de * L;
          case "seconds":
          case "second":
          case "secs":
          case "sec":
          case "s":
            return de * C;
          case "milliseconds":
          case "millisecond":
          case "msecs":
          case "msec":
          case "ms":
            return de;
          default:
            return;
        }
      }
    }
  }
  function oe(ce) {
    var ue = Math.abs(ce);
    return ue >= W ? Math.round(ce / W) + "d" : ue >= A ? Math.round(ce / A) + "h" : ue >= L ? Math.round(ce / L) + "m" : ue >= C ? Math.round(ce / C) + "s" : ce + "ms";
  }
  function ne(ce) {
    var ue = Math.abs(ce);
    return ue >= W ? re(ce, ue, W, "day") : ue >= A ? re(ce, ue, A, "hour") : ue >= L ? re(ce, ue, L, "minute") : ue >= C ? re(ce, ue, C, "second") : ce + " ms";
  }
  function re(ce, ue, de, be) {
    var pe = ue >= de * 1.5;
    return Math.round(ce / de) + " " + be + (pe ? "s" : "");
  }
  return ms;
}
function setup(C) {
  A.debug = A, A.default = A, A.coerce = ne, A.disable = J, A.enable = X, A.enabled = te, A.humanize = requireMs(), A.destroy = re, Object.keys(C).forEach((ce) => {
    A[ce] = C[ce];
  }), A.names = [], A.skips = [], A.formatters = {};
  function L(ce) {
    let ue = 0;
    for (let de = 0; de < ce.length; de++)
      ue = (ue << 5) - ue + ce.charCodeAt(de), ue |= 0;
    return A.colors[Math.abs(ue) % A.colors.length];
  }
  A.selectColor = L;
  function A(ce) {
    let ue, de = null, be, pe;
    function me(...Me) {
      if (!me.enabled)
        return;
      const he = me, ge = Number(/* @__PURE__ */ new Date()), Ce = ge - (ue || ge);
      he.diff = Ce, he.prev = ue, he.curr = ge, ue = ge, Me[0] = A.coerce(Me[0]), typeof Me[0] != "string" && Me.unshift("%O");
      let Se = 0;
      Me[0] = Me[0].replace(/%([a-zA-Z%])/g, (Le, ve) => {
        if (Le === "%%")
          return "%";
        Se++;
        const De = A.formatters[ve];
        if (typeof De == "function") {
          const Ue = Me[Se];
          Le = De.call(he, Ue), Me.splice(Se, 1), Se--;
        }
        return Le;
      }), A.formatArgs.call(he, Me), (he.log || A.log).apply(he, Me);
    }
    return me.namespace = ce, me.useColors = A.useColors(), me.color = A.selectColor(ce), me.extend = W, me.destroy = A.destroy, Object.defineProperty(me, "enabled", {
      enumerable: !0,
      configurable: !1,
      get: () => de !== null ? de : (be !== A.namespaces && (be = A.namespaces, pe = A.enabled(ce)), pe),
      set: (Me) => {
        de = Me;
      }
    }), typeof A.init == "function" && A.init(me), me;
  }
  function W(ce, ue) {
    const de = A(this.namespace + (typeof ue > "u" ? ":" : ue) + ce);
    return de.log = this.log, de;
  }
  function X(ce) {
    A.save(ce), A.namespaces = ce, A.names = [], A.skips = [];
    let ue;
    const de = (typeof ce == "string" ? ce : "").split(/[\s,]+/), be = de.length;
    for (ue = 0; ue < be; ue++)
      de[ue] && (ce = de[ue].replace(/\*/g, ".*?"), ce[0] === "-" ? A.skips.push(new RegExp("^" + ce.slice(1) + "$")) : A.names.push(new RegExp("^" + ce + "$")));
  }
  function J() {
    const ce = [
      ...A.names.map(oe),
      ...A.skips.map(oe).map((ue) => "-" + ue)
    ].join(",");
    return A.enable(""), ce;
  }
  function te(ce) {
    if (ce[ce.length - 1] === "*")
      return !0;
    let ue, de;
    for (ue = 0, de = A.skips.length; ue < de; ue++)
      if (A.skips[ue].test(ce))
        return !1;
    for (ue = 0, de = A.names.length; ue < de; ue++)
      if (A.names[ue].test(ce))
        return !0;
    return !1;
  }
  function oe(ce) {
    return ce.toString().substring(2, ce.toString().length - 2).replace(/\.\*\?$/, "*");
  }
  function ne(ce) {
    return ce instanceof Error ? ce.stack || ce.message : ce;
  }
  function re() {
    console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
  }
  return A.enable(A.load()), A;
}
var common$3 = setup;
(function(C, L) {
  L.formatArgs = W, L.save = X, L.load = J, L.useColors = A, L.storage = te(), L.destroy = /* @__PURE__ */ (() => {
    let ne = !1;
    return () => {
      ne || (ne = !0, console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."));
    };
  })(), L.colors = [
    "#0000CC",
    "#0000FF",
    "#0033CC",
    "#0033FF",
    "#0066CC",
    "#0066FF",
    "#0099CC",
    "#0099FF",
    "#00CC00",
    "#00CC33",
    "#00CC66",
    "#00CC99",
    "#00CCCC",
    "#00CCFF",
    "#3300CC",
    "#3300FF",
    "#3333CC",
    "#3333FF",
    "#3366CC",
    "#3366FF",
    "#3399CC",
    "#3399FF",
    "#33CC00",
    "#33CC33",
    "#33CC66",
    "#33CC99",
    "#33CCCC",
    "#33CCFF",
    "#6600CC",
    "#6600FF",
    "#6633CC",
    "#6633FF",
    "#66CC00",
    "#66CC33",
    "#9900CC",
    "#9900FF",
    "#9933CC",
    "#9933FF",
    "#99CC00",
    "#99CC33",
    "#CC0000",
    "#CC0033",
    "#CC0066",
    "#CC0099",
    "#CC00CC",
    "#CC00FF",
    "#CC3300",
    "#CC3333",
    "#CC3366",
    "#CC3399",
    "#CC33CC",
    "#CC33FF",
    "#CC6600",
    "#CC6633",
    "#CC9900",
    "#CC9933",
    "#CCCC00",
    "#CCCC33",
    "#FF0000",
    "#FF0033",
    "#FF0066",
    "#FF0099",
    "#FF00CC",
    "#FF00FF",
    "#FF3300",
    "#FF3333",
    "#FF3366",
    "#FF3399",
    "#FF33CC",
    "#FF33FF",
    "#FF6600",
    "#FF6633",
    "#FF9900",
    "#FF9933",
    "#FFCC00",
    "#FFCC33"
  ];
  function A() {
    if (typeof window < "u" && window.process && (window.process.type === "renderer" || window.process.__nwjs))
      return !0;
    if (typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/))
      return !1;
    let ne;
    return typeof document < "u" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
    typeof window < "u" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    typeof navigator < "u" && navigator.userAgent && (ne = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(ne[1], 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
    typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
  }
  function W(ne) {
    if (ne[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + ne[0] + (this.useColors ? "%c " : " ") + "+" + C.exports.humanize(this.diff), !this.useColors)
      return;
    const re = "color: " + this.color;
    ne.splice(1, 0, re, "color: inherit");
    let ce = 0, ue = 0;
    ne[0].replace(/%[a-zA-Z%]/g, (de) => {
      de !== "%%" && (ce++, de === "%c" && (ue = ce));
    }), ne.splice(ue, 0, re);
  }
  L.log = console.debug || console.log || (() => {
  });
  function X(ne) {
    try {
      ne ? L.storage.setItem("debug", ne) : L.storage.removeItem("debug");
    } catch {
    }
  }
  function J() {
    let ne;
    try {
      ne = L.storage.getItem("debug");
    } catch {
    }
    return !ne && typeof process$1 < "u" && "env" in process$1 && (ne = process$1.env.DEBUG), ne;
  }
  function te() {
    try {
      return localStorage;
    } catch {
    }
  }
  C.exports = common$3(L);
  const { formatters: oe } = C.exports;
  oe.j = function(ne) {
    try {
      return JSON.stringify(ne);
    } catch (re) {
      return "[UnexpectedJSONParseError]: " + re.message;
    }
  };
})(browser$2, browser$2.exports);
var browserExports = browser$2.exports, core$2 = {}, core$1 = {}, ReadStreamTokenizer$1 = {}, buffer = {}, base64Js = {};
base64Js.byteLength = byteLength;
base64Js.toByteArray = toByteArray;
base64Js.fromByteArray = fromByteArray;
var lookup = [], revLookup = [], Arr = typeof Uint8Array < "u" ? Uint8Array : Array, code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (var i = 0, len = code.length; i < len; ++i)
  lookup[i] = code[i], revLookup[code.charCodeAt(i)] = i;
revLookup[45] = 62;
revLookup[95] = 63;
function getLens(C) {
  var L = C.length;
  if (L % 4 > 0)
    throw new Error("Invalid string. Length must be a multiple of 4");
  var A = C.indexOf("=");
  A === -1 && (A = L);
  var W = A === L ? 0 : 4 - A % 4;
  return [A, W];
}
function byteLength(C) {
  var L = getLens(C), A = L[0], W = L[1];
  return (A + W) * 3 / 4 - W;
}
function _byteLength(C, L, A) {
  return (L + A) * 3 / 4 - A;
}
function toByteArray(C) {
  var L, A = getLens(C), W = A[0], X = A[1], J = new Arr(_byteLength(C, W, X)), te = 0, oe = X > 0 ? W - 4 : W, ne;
  for (ne = 0; ne < oe; ne += 4)
    L = revLookup[C.charCodeAt(ne)] << 18 | revLookup[C.charCodeAt(ne + 1)] << 12 | revLookup[C.charCodeAt(ne + 2)] << 6 | revLookup[C.charCodeAt(ne + 3)], J[te++] = L >> 16 & 255, J[te++] = L >> 8 & 255, J[te++] = L & 255;
  return X === 2 && (L = revLookup[C.charCodeAt(ne)] << 2 | revLookup[C.charCodeAt(ne + 1)] >> 4, J[te++] = L & 255), X === 1 && (L = revLookup[C.charCodeAt(ne)] << 10 | revLookup[C.charCodeAt(ne + 1)] << 4 | revLookup[C.charCodeAt(ne + 2)] >> 2, J[te++] = L >> 8 & 255, J[te++] = L & 255), J;
}
function tripletToBase64(C) {
  return lookup[C >> 18 & 63] + lookup[C >> 12 & 63] + lookup[C >> 6 & 63] + lookup[C & 63];
}
function encodeChunk(C, L, A) {
  for (var W, X = [], J = L; J < A; J += 3)
    W = (C[J] << 16 & 16711680) + (C[J + 1] << 8 & 65280) + (C[J + 2] & 255), X.push(tripletToBase64(W));
  return X.join("");
}
function fromByteArray(C) {
  for (var L, A = C.length, W = A % 3, X = [], J = 16383, te = 0, oe = A - W; te < oe; te += J)
    X.push(encodeChunk(C, te, te + J > oe ? oe : te + J));
  return W === 1 ? (L = C[A - 1], X.push(
    lookup[L >> 2] + lookup[L << 4 & 63] + "=="
  )) : W === 2 && (L = (C[A - 2] << 8) + C[A - 1], X.push(
    lookup[L >> 10] + lookup[L >> 4 & 63] + lookup[L << 2 & 63] + "="
  )), X.join("");
}
var ieee754$1 = {};
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
ieee754$1.read = function(C, L, A, W, X) {
  var J, te, oe = X * 8 - W - 1, ne = (1 << oe) - 1, re = ne >> 1, ce = -7, ue = A ? X - 1 : 0, de = A ? -1 : 1, be = C[L + ue];
  for (ue += de, J = be & (1 << -ce) - 1, be >>= -ce, ce += oe; ce > 0; J = J * 256 + C[L + ue], ue += de, ce -= 8)
    ;
  for (te = J & (1 << -ce) - 1, J >>= -ce, ce += W; ce > 0; te = te * 256 + C[L + ue], ue += de, ce -= 8)
    ;
  if (J === 0)
    J = 1 - re;
  else {
    if (J === ne)
      return te ? NaN : (be ? -1 : 1) * (1 / 0);
    te = te + Math.pow(2, W), J = J - re;
  }
  return (be ? -1 : 1) * te * Math.pow(2, J - W);
};
ieee754$1.write = function(C, L, A, W, X, J) {
  var te, oe, ne, re = J * 8 - X - 1, ce = (1 << re) - 1, ue = ce >> 1, de = X === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, be = W ? 0 : J - 1, pe = W ? 1 : -1, me = L < 0 || L === 0 && 1 / L < 0 ? 1 : 0;
  for (L = Math.abs(L), isNaN(L) || L === 1 / 0 ? (oe = isNaN(L) ? 1 : 0, te = ce) : (te = Math.floor(Math.log(L) / Math.LN2), L * (ne = Math.pow(2, -te)) < 1 && (te--, ne *= 2), te + ue >= 1 ? L += de / ne : L += de * Math.pow(2, 1 - ue), L * ne >= 2 && (te++, ne /= 2), te + ue >= ce ? (oe = 0, te = ce) : te + ue >= 1 ? (oe = (L * ne - 1) * Math.pow(2, X), te = te + ue) : (oe = L * Math.pow(2, ue - 1) * Math.pow(2, X), te = 0)); X >= 8; C[A + be] = oe & 255, be += pe, oe /= 256, X -= 8)
    ;
  for (te = te << X | oe, re += X; re > 0; C[A + be] = te & 255, be += pe, te /= 256, re -= 8)
    ;
  C[A + be - pe] |= me * 128;
};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
(function(C) {
  const L = base64Js, A = ieee754$1, W = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
  C.Buffer = ce, C.SlowBuffer = Ae, C.INSPECT_MAX_BYTES = 50;
  const X = 2147483647;
  C.kMaxLength = X;
  const { Uint8Array: J, ArrayBuffer: te, SharedArrayBuffer: oe } = globalThis;
  ce.TYPED_ARRAY_SUPPORT = ne(), !ce.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error(
    "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
  );
  function ne() {
    try {
      const ze = new J(1), ye = { foo: function() {
        return 42;
      } };
      return Object.setPrototypeOf(ye, J.prototype), Object.setPrototypeOf(ze, ye), ze.foo() === 42;
    } catch {
      return !1;
    }
  }
  Object.defineProperty(ce.prototype, "parent", {
    enumerable: !0,
    get: function() {
      if (ce.isBuffer(this))
        return this.buffer;
    }
  }), Object.defineProperty(ce.prototype, "offset", {
    enumerable: !0,
    get: function() {
      if (ce.isBuffer(this))
        return this.byteOffset;
    }
  });
  function re(ze) {
    if (ze > X)
      throw new RangeError('The value "' + ze + '" is invalid for option "size"');
    const ye = new J(ze);
    return Object.setPrototypeOf(ye, ce.prototype), ye;
  }
  function ce(ze, ye, we) {
    if (typeof ze == "number") {
      if (typeof ye == "string")
        throw new TypeError(
          'The "string" argument must be of type string. Received type number'
        );
      return pe(ze);
    }
    return ue(ze, ye, we);
  }
  ce.poolSize = 8192;
  function ue(ze, ye, we) {
    if (typeof ze == "string")
      return me(ze, ye);
    if (te.isView(ze))
      return he(ze);
    if (ze == null)
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof ze
      );
    if (Et(ze, te) || ze && Et(ze.buffer, te) || typeof oe < "u" && (Et(ze, oe) || ze && Et(ze.buffer, oe)))
      return ge(ze, ye, we);
    if (typeof ze == "number")
      throw new TypeError(
        'The "value" argument must not be of type number. Received type number'
      );
    const Ge = ze.valueOf && ze.valueOf();
    if (Ge != null && Ge !== ze)
      return ce.from(Ge, ye, we);
    const tt = Ce(ze);
    if (tt) return tt;
    if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof ze[Symbol.toPrimitive] == "function")
      return ce.from(ze[Symbol.toPrimitive]("string"), ye, we);
    throw new TypeError(
      "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof ze
    );
  }
  ce.from = function(ze, ye, we) {
    return ue(ze, ye, we);
  }, Object.setPrototypeOf(ce.prototype, J.prototype), Object.setPrototypeOf(ce, J);
  function de(ze) {
    if (typeof ze != "number")
      throw new TypeError('"size" argument must be of type number');
    if (ze < 0)
      throw new RangeError('The value "' + ze + '" is invalid for option "size"');
  }
  function be(ze, ye, we) {
    return de(ze), ze <= 0 ? re(ze) : ye !== void 0 ? typeof we == "string" ? re(ze).fill(ye, we) : re(ze).fill(ye) : re(ze);
  }
  ce.alloc = function(ze, ye, we) {
    return be(ze, ye, we);
  };
  function pe(ze) {
    return de(ze), re(ze < 0 ? 0 : Se(ze) | 0);
  }
  ce.allocUnsafe = function(ze) {
    return pe(ze);
  }, ce.allocUnsafeSlow = function(ze) {
    return pe(ze);
  };
  function me(ze, ye) {
    if ((typeof ye != "string" || ye === "") && (ye = "utf8"), !ce.isEncoding(ye))
      throw new TypeError("Unknown encoding: " + ye);
    const we = Le(ze, ye) | 0;
    let Ge = re(we);
    const tt = Ge.write(ze, ye);
    return tt !== we && (Ge = Ge.slice(0, tt)), Ge;
  }
  function Me(ze) {
    const ye = ze.length < 0 ? 0 : Se(ze.length) | 0, we = re(ye);
    for (let Ge = 0; Ge < ye; Ge += 1)
      we[Ge] = ze[Ge] & 255;
    return we;
  }
  function he(ze) {
    if (Et(ze, J)) {
      const ye = new J(ze);
      return ge(ye.buffer, ye.byteOffset, ye.byteLength);
    }
    return Me(ze);
  }
  function ge(ze, ye, we) {
    if (ye < 0 || ze.byteLength < ye)
      throw new RangeError('"offset" is outside of buffer bounds');
    if (ze.byteLength < ye + (we || 0))
      throw new RangeError('"length" is outside of buffer bounds');
    let Ge;
    return ye === void 0 && we === void 0 ? Ge = new J(ze) : we === void 0 ? Ge = new J(ze, ye) : Ge = new J(ze, ye, we), Object.setPrototypeOf(Ge, ce.prototype), Ge;
  }
  function Ce(ze) {
    if (ce.isBuffer(ze)) {
      const ye = Se(ze.length) | 0, we = re(ye);
      return we.length === 0 || ze.copy(we, 0, 0, ye), we;
    }
    if (ze.length !== void 0)
      return typeof ze.length != "number" || Dt(ze.length) ? re(0) : Me(ze);
    if (ze.type === "Buffer" && Array.isArray(ze.data))
      return Me(ze.data);
  }
  function Se(ze) {
    if (ze >= X)
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + X.toString(16) + " bytes");
    return ze | 0;
  }
  function Ae(ze) {
    return +ze != ze && (ze = 0), ce.alloc(+ze);
  }
  ce.isBuffer = function(ye) {
    return ye != null && ye._isBuffer === !0 && ye !== ce.prototype;
  }, ce.compare = function(ye, we) {
    if (Et(ye, J) && (ye = ce.from(ye, ye.offset, ye.byteLength)), Et(we, J) && (we = ce.from(we, we.offset, we.byteLength)), !ce.isBuffer(ye) || !ce.isBuffer(we))
      throw new TypeError(
        'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
      );
    if (ye === we) return 0;
    let Ge = ye.length, tt = we.length;
    for (let Mt = 0, Nt = Math.min(Ge, tt); Mt < Nt; ++Mt)
      if (ye[Mt] !== we[Mt]) {
        Ge = ye[Mt], tt = we[Mt];
        break;
      }
    return Ge < tt ? -1 : tt < Ge ? 1 : 0;
  }, ce.isEncoding = function(ye) {
    switch (String(ye).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return !0;
      default:
        return !1;
    }
  }, ce.concat = function(ye, we) {
    if (!Array.isArray(ye))
      throw new TypeError('"list" argument must be an Array of Buffers');
    if (ye.length === 0)
      return ce.alloc(0);
    let Ge;
    if (we === void 0)
      for (we = 0, Ge = 0; Ge < ye.length; ++Ge)
        we += ye[Ge].length;
    const tt = ce.allocUnsafe(we);
    let Mt = 0;
    for (Ge = 0; Ge < ye.length; ++Ge) {
      let Nt = ye[Ge];
      if (Et(Nt, J))
        Mt + Nt.length > tt.length ? (ce.isBuffer(Nt) || (Nt = ce.from(Nt)), Nt.copy(tt, Mt)) : J.prototype.set.call(
          tt,
          Nt,
          Mt
        );
      else if (ce.isBuffer(Nt))
        Nt.copy(tt, Mt);
      else
        throw new TypeError('"list" argument must be an Array of Buffers');
      Mt += Nt.length;
    }
    return tt;
  };
  function Le(ze, ye) {
    if (ce.isBuffer(ze))
      return ze.length;
    if (te.isView(ze) || Et(ze, te))
      return ze.byteLength;
    if (typeof ze != "string")
      throw new TypeError(
        'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof ze
      );
    const we = ze.length, Ge = arguments.length > 2 && arguments[2] === !0;
    if (!Ge && we === 0) return 0;
    let tt = !1;
    for (; ; )
      switch (ye) {
        case "ascii":
        case "latin1":
        case "binary":
          return we;
        case "utf8":
        case "utf-8":
          return Xt(ze).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return we * 2;
        case "hex":
          return we >>> 1;
        case "base64":
          return xt(ze).length;
        default:
          if (tt)
            return Ge ? -1 : Xt(ze).length;
          ye = ("" + ye).toLowerCase(), tt = !0;
      }
  }
  ce.byteLength = Le;
  function ve(ze, ye, we) {
    let Ge = !1;
    if ((ye === void 0 || ye < 0) && (ye = 0), ye > this.length || ((we === void 0 || we > this.length) && (we = this.length), we <= 0) || (we >>>= 0, ye >>>= 0, we <= ye))
      return "";
    for (ze || (ze = "utf8"); ; )
      switch (ze) {
        case "hex":
          return Ze(this, ye, we);
        case "utf8":
        case "utf-8":
          return Tt(this, ye, we);
        case "ascii":
          return He(this, ye, we);
        case "latin1":
        case "binary":
          return qe(this, ye, we);
        case "base64":
          return Ct(this, ye, we);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return Pe(this, ye, we);
        default:
          if (Ge) throw new TypeError("Unknown encoding: " + ze);
          ze = (ze + "").toLowerCase(), Ge = !0;
      }
  }
  ce.prototype._isBuffer = !0;
  function De(ze, ye, we) {
    const Ge = ze[ye];
    ze[ye] = ze[we], ze[we] = Ge;
  }
  ce.prototype.swap16 = function() {
    const ye = this.length;
    if (ye % 2 !== 0)
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    for (let we = 0; we < ye; we += 2)
      De(this, we, we + 1);
    return this;
  }, ce.prototype.swap32 = function() {
    const ye = this.length;
    if (ye % 4 !== 0)
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    for (let we = 0; we < ye; we += 4)
      De(this, we, we + 3), De(this, we + 1, we + 2);
    return this;
  }, ce.prototype.swap64 = function() {
    const ye = this.length;
    if (ye % 8 !== 0)
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    for (let we = 0; we < ye; we += 8)
      De(this, we, we + 7), De(this, we + 1, we + 6), De(this, we + 2, we + 5), De(this, we + 3, we + 4);
    return this;
  }, ce.prototype.toString = function() {
    const ye = this.length;
    return ye === 0 ? "" : arguments.length === 0 ? Tt(this, 0, ye) : ve.apply(this, arguments);
  }, ce.prototype.toLocaleString = ce.prototype.toString, ce.prototype.equals = function(ye) {
    if (!ce.isBuffer(ye)) throw new TypeError("Argument must be a Buffer");
    return this === ye ? !0 : ce.compare(this, ye) === 0;
  }, ce.prototype.inspect = function() {
    let ye = "";
    const we = C.INSPECT_MAX_BYTES;
    return ye = this.toString("hex", 0, we).replace(/(.{2})/g, "$1 ").trim(), this.length > we && (ye += " ... "), "<Buffer " + ye + ">";
  }, W && (ce.prototype[W] = ce.prototype.inspect), ce.prototype.compare = function(ye, we, Ge, tt, Mt) {
    if (Et(ye, J) && (ye = ce.from(ye, ye.offset, ye.byteLength)), !ce.isBuffer(ye))
      throw new TypeError(
        'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof ye
      );
    if (we === void 0 && (we = 0), Ge === void 0 && (Ge = ye ? ye.length : 0), tt === void 0 && (tt = 0), Mt === void 0 && (Mt = this.length), we < 0 || Ge > ye.length || tt < 0 || Mt > this.length)
      throw new RangeError("out of range index");
    if (tt >= Mt && we >= Ge)
      return 0;
    if (tt >= Mt)
      return -1;
    if (we >= Ge)
      return 1;
    if (we >>>= 0, Ge >>>= 0, tt >>>= 0, Mt >>>= 0, this === ye) return 0;
    let Nt = Mt - tt, Bt = Ge - we;
    const Vt = Math.min(Nt, Bt), Gt = this.slice(tt, Mt), Ht = ye.slice(we, Ge);
    for (let Yt = 0; Yt < Vt; ++Yt)
      if (Gt[Yt] !== Ht[Yt]) {
        Nt = Gt[Yt], Bt = Ht[Yt];
        break;
      }
    return Nt < Bt ? -1 : Bt < Nt ? 1 : 0;
  };
  function Ue(ze, ye, we, Ge, tt) {
    if (ze.length === 0) return -1;
    if (typeof we == "string" ? (Ge = we, we = 0) : we > 2147483647 ? we = 2147483647 : we < -2147483648 && (we = -2147483648), we = +we, Dt(we) && (we = tt ? 0 : ze.length - 1), we < 0 && (we = ze.length + we), we >= ze.length) {
      if (tt) return -1;
      we = ze.length - 1;
    } else if (we < 0)
      if (tt) we = 0;
      else return -1;
    if (typeof ye == "string" && (ye = ce.from(ye, Ge)), ce.isBuffer(ye))
      return ye.length === 0 ? -1 : Fe(ze, ye, we, Ge, tt);
    if (typeof ye == "number")
      return ye = ye & 255, typeof J.prototype.indexOf == "function" ? tt ? J.prototype.indexOf.call(ze, ye, we) : J.prototype.lastIndexOf.call(ze, ye, we) : Fe(ze, [ye], we, Ge, tt);
    throw new TypeError("val must be string, number or Buffer");
  }
  function Fe(ze, ye, we, Ge, tt) {
    let Mt = 1, Nt = ze.length, Bt = ye.length;
    if (Ge !== void 0 && (Ge = String(Ge).toLowerCase(), Ge === "ucs2" || Ge === "ucs-2" || Ge === "utf16le" || Ge === "utf-16le")) {
      if (ze.length < 2 || ye.length < 2)
        return -1;
      Mt = 2, Nt /= 2, Bt /= 2, we /= 2;
    }
    function Vt(Ht, Yt) {
      return Mt === 1 ? Ht[Yt] : Ht.readUInt16BE(Yt * Mt);
    }
    let Gt;
    if (tt) {
      let Ht = -1;
      for (Gt = we; Gt < Nt; Gt++)
        if (Vt(ze, Gt) === Vt(ye, Ht === -1 ? 0 : Gt - Ht)) {
          if (Ht === -1 && (Ht = Gt), Gt - Ht + 1 === Bt) return Ht * Mt;
        } else
          Ht !== -1 && (Gt -= Gt - Ht), Ht = -1;
    } else
      for (we + Bt > Nt && (we = Nt - Bt), Gt = we; Gt >= 0; Gt--) {
        let Ht = !0;
        for (let Yt = 0; Yt < Bt; Yt++)
          if (Vt(ze, Gt + Yt) !== Vt(ye, Yt)) {
            Ht = !1;
            break;
          }
        if (Ht) return Gt;
      }
    return -1;
  }
  ce.prototype.includes = function(ye, we, Ge) {
    return this.indexOf(ye, we, Ge) !== -1;
  }, ce.prototype.indexOf = function(ye, we, Ge) {
    return Ue(this, ye, we, Ge, !0);
  }, ce.prototype.lastIndexOf = function(ye, we, Ge) {
    return Ue(this, ye, we, Ge, !1);
  };
  function We(ze, ye, we, Ge) {
    we = Number(we) || 0;
    const tt = ze.length - we;
    Ge ? (Ge = Number(Ge), Ge > tt && (Ge = tt)) : Ge = tt;
    const Mt = ye.length;
    Ge > Mt / 2 && (Ge = Mt / 2);
    let Nt;
    for (Nt = 0; Nt < Ge; ++Nt) {
      const Bt = parseInt(ye.substr(Nt * 2, 2), 16);
      if (Dt(Bt)) return Nt;
      ze[we + Nt] = Bt;
    }
    return Nt;
  }
  function Ke(ze, ye, we, Ge) {
    return Lt(Xt(ye, ze.length - we), ze, we, Ge);
  }
  function it(ze, ye, we, Ge) {
    return Lt(tr(ye), ze, we, Ge);
  }
  function Qe(ze, ye, we, Ge) {
    return Lt(xt(ye), ze, we, Ge);
  }
  function vt(ze, ye, we, Ge) {
    return Lt(Wt(ye, ze.length - we), ze, we, Ge);
  }
  ce.prototype.write = function(ye, we, Ge, tt) {
    if (we === void 0)
      tt = "utf8", Ge = this.length, we = 0;
    else if (Ge === void 0 && typeof we == "string")
      tt = we, Ge = this.length, we = 0;
    else if (isFinite(we))
      we = we >>> 0, isFinite(Ge) ? (Ge = Ge >>> 0, tt === void 0 && (tt = "utf8")) : (tt = Ge, Ge = void 0);
    else
      throw new Error(
        "Buffer.write(string, encoding, offset[, length]) is no longer supported"
      );
    const Mt = this.length - we;
    if ((Ge === void 0 || Ge > Mt) && (Ge = Mt), ye.length > 0 && (Ge < 0 || we < 0) || we > this.length)
      throw new RangeError("Attempt to write outside buffer bounds");
    tt || (tt = "utf8");
    let Nt = !1;
    for (; ; )
      switch (tt) {
        case "hex":
          return We(this, ye, we, Ge);
        case "utf8":
        case "utf-8":
          return Ke(this, ye, we, Ge);
        case "ascii":
        case "latin1":
        case "binary":
          return it(this, ye, we, Ge);
        case "base64":
          return Qe(this, ye, we, Ge);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return vt(this, ye, we, Ge);
        default:
          if (Nt) throw new TypeError("Unknown encoding: " + tt);
          tt = ("" + tt).toLowerCase(), Nt = !0;
      }
  }, ce.prototype.toJSON = function() {
    return {
      type: "Buffer",
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function Ct(ze, ye, we) {
    return ye === 0 && we === ze.length ? L.fromByteArray(ze) : L.fromByteArray(ze.slice(ye, we));
  }
  function Tt(ze, ye, we) {
    we = Math.min(ze.length, we);
    const Ge = [];
    let tt = ye;
    for (; tt < we; ) {
      const Mt = ze[tt];
      let Nt = null, Bt = Mt > 239 ? 4 : Mt > 223 ? 3 : Mt > 191 ? 2 : 1;
      if (tt + Bt <= we) {
        let Vt, Gt, Ht, Yt;
        switch (Bt) {
          case 1:
            Mt < 128 && (Nt = Mt);
            break;
          case 2:
            Vt = ze[tt + 1], (Vt & 192) === 128 && (Yt = (Mt & 31) << 6 | Vt & 63, Yt > 127 && (Nt = Yt));
            break;
          case 3:
            Vt = ze[tt + 1], Gt = ze[tt + 2], (Vt & 192) === 128 && (Gt & 192) === 128 && (Yt = (Mt & 15) << 12 | (Vt & 63) << 6 | Gt & 63, Yt > 2047 && (Yt < 55296 || Yt > 57343) && (Nt = Yt));
            break;
          case 4:
            Vt = ze[tt + 1], Gt = ze[tt + 2], Ht = ze[tt + 3], (Vt & 192) === 128 && (Gt & 192) === 128 && (Ht & 192) === 128 && (Yt = (Mt & 15) << 18 | (Vt & 63) << 12 | (Gt & 63) << 6 | Ht & 63, Yt > 65535 && Yt < 1114112 && (Nt = Yt));
        }
      }
      Nt === null ? (Nt = 65533, Bt = 1) : Nt > 65535 && (Nt -= 65536, Ge.push(Nt >>> 10 & 1023 | 55296), Nt = 56320 | Nt & 1023), Ge.push(Nt), tt += Bt;
    }
    return Je(Ge);
  }
  const St = 4096;
  function Je(ze) {
    const ye = ze.length;
    if (ye <= St)
      return String.fromCharCode.apply(String, ze);
    let we = "", Ge = 0;
    for (; Ge < ye; )
      we += String.fromCharCode.apply(
        String,
        ze.slice(Ge, Ge += St)
      );
    return we;
  }
  function He(ze, ye, we) {
    let Ge = "";
    we = Math.min(ze.length, we);
    for (let tt = ye; tt < we; ++tt)
      Ge += String.fromCharCode(ze[tt] & 127);
    return Ge;
  }
  function qe(ze, ye, we) {
    let Ge = "";
    we = Math.min(ze.length, we);
    for (let tt = ye; tt < we; ++tt)
      Ge += String.fromCharCode(ze[tt]);
    return Ge;
  }
  function Ze(ze, ye, we) {
    const Ge = ze.length;
    (!ye || ye < 0) && (ye = 0), (!we || we < 0 || we > Ge) && (we = Ge);
    let tt = "";
    for (let Mt = ye; Mt < we; ++Mt)
      tt += Pt[ze[Mt]];
    return tt;
  }
  function Pe(ze, ye, we) {
    const Ge = ze.slice(ye, we);
    let tt = "";
    for (let Mt = 0; Mt < Ge.length - 1; Mt += 2)
      tt += String.fromCharCode(Ge[Mt] + Ge[Mt + 1] * 256);
    return tt;
  }
  ce.prototype.slice = function(ye, we) {
    const Ge = this.length;
    ye = ~~ye, we = we === void 0 ? Ge : ~~we, ye < 0 ? (ye += Ge, ye < 0 && (ye = 0)) : ye > Ge && (ye = Ge), we < 0 ? (we += Ge, we < 0 && (we = 0)) : we > Ge && (we = Ge), we < ye && (we = ye);
    const tt = this.subarray(ye, we);
    return Object.setPrototypeOf(tt, ce.prototype), tt;
  };
  function Ye(ze, ye, we) {
    if (ze % 1 !== 0 || ze < 0) throw new RangeError("offset is not uint");
    if (ze + ye > we) throw new RangeError("Trying to access beyond buffer length");
  }
  ce.prototype.readUintLE = ce.prototype.readUIntLE = function(ye, we, Ge) {
    ye = ye >>> 0, we = we >>> 0, Ge || Ye(ye, we, this.length);
    let tt = this[ye], Mt = 1, Nt = 0;
    for (; ++Nt < we && (Mt *= 256); )
      tt += this[ye + Nt] * Mt;
    return tt;
  }, ce.prototype.readUintBE = ce.prototype.readUIntBE = function(ye, we, Ge) {
    ye = ye >>> 0, we = we >>> 0, Ge || Ye(ye, we, this.length);
    let tt = this[ye + --we], Mt = 1;
    for (; we > 0 && (Mt *= 256); )
      tt += this[ye + --we] * Mt;
    return tt;
  }, ce.prototype.readUint8 = ce.prototype.readUInt8 = function(ye, we) {
    return ye = ye >>> 0, we || Ye(ye, 1, this.length), this[ye];
  }, ce.prototype.readUint16LE = ce.prototype.readUInt16LE = function(ye, we) {
    return ye = ye >>> 0, we || Ye(ye, 2, this.length), this[ye] | this[ye + 1] << 8;
  }, ce.prototype.readUint16BE = ce.prototype.readUInt16BE = function(ye, we) {
    return ye = ye >>> 0, we || Ye(ye, 2, this.length), this[ye] << 8 | this[ye + 1];
  }, ce.prototype.readUint32LE = ce.prototype.readUInt32LE = function(ye, we) {
    return ye = ye >>> 0, we || Ye(ye, 4, this.length), (this[ye] | this[ye + 1] << 8 | this[ye + 2] << 16) + this[ye + 3] * 16777216;
  }, ce.prototype.readUint32BE = ce.prototype.readUInt32BE = function(ye, we) {
    return ye = ye >>> 0, we || Ye(ye, 4, this.length), this[ye] * 16777216 + (this[ye + 1] << 16 | this[ye + 2] << 8 | this[ye + 3]);
  }, ce.prototype.readBigUInt64LE = zt(function(ye) {
    ye = ye >>> 0, jt(ye, "offset");
    const we = this[ye], Ge = this[ye + 7];
    (we === void 0 || Ge === void 0) && Ot(ye, this.length - 8);
    const tt = we + this[++ye] * 2 ** 8 + this[++ye] * 2 ** 16 + this[++ye] * 2 ** 24, Mt = this[++ye] + this[++ye] * 2 ** 8 + this[++ye] * 2 ** 16 + Ge * 2 ** 24;
    return BigInt(tt) + (BigInt(Mt) << BigInt(32));
  }), ce.prototype.readBigUInt64BE = zt(function(ye) {
    ye = ye >>> 0, jt(ye, "offset");
    const we = this[ye], Ge = this[ye + 7];
    (we === void 0 || Ge === void 0) && Ot(ye, this.length - 8);
    const tt = we * 2 ** 24 + this[++ye] * 2 ** 16 + this[++ye] * 2 ** 8 + this[++ye], Mt = this[++ye] * 2 ** 24 + this[++ye] * 2 ** 16 + this[++ye] * 2 ** 8 + Ge;
    return (BigInt(tt) << BigInt(32)) + BigInt(Mt);
  }), ce.prototype.readIntLE = function(ye, we, Ge) {
    ye = ye >>> 0, we = we >>> 0, Ge || Ye(ye, we, this.length);
    let tt = this[ye], Mt = 1, Nt = 0;
    for (; ++Nt < we && (Mt *= 256); )
      tt += this[ye + Nt] * Mt;
    return Mt *= 128, tt >= Mt && (tt -= Math.pow(2, 8 * we)), tt;
  }, ce.prototype.readIntBE = function(ye, we, Ge) {
    ye = ye >>> 0, we = we >>> 0, Ge || Ye(ye, we, this.length);
    let tt = we, Mt = 1, Nt = this[ye + --tt];
    for (; tt > 0 && (Mt *= 256); )
      Nt += this[ye + --tt] * Mt;
    return Mt *= 128, Nt >= Mt && (Nt -= Math.pow(2, 8 * we)), Nt;
  }, ce.prototype.readInt8 = function(ye, we) {
    return ye = ye >>> 0, we || Ye(ye, 1, this.length), this[ye] & 128 ? (255 - this[ye] + 1) * -1 : this[ye];
  }, ce.prototype.readInt16LE = function(ye, we) {
    ye = ye >>> 0, we || Ye(ye, 2, this.length);
    const Ge = this[ye] | this[ye + 1] << 8;
    return Ge & 32768 ? Ge | 4294901760 : Ge;
  }, ce.prototype.readInt16BE = function(ye, we) {
    ye = ye >>> 0, we || Ye(ye, 2, this.length);
    const Ge = this[ye + 1] | this[ye] << 8;
    return Ge & 32768 ? Ge | 4294901760 : Ge;
  }, ce.prototype.readInt32LE = function(ye, we) {
    return ye = ye >>> 0, we || Ye(ye, 4, this.length), this[ye] | this[ye + 1] << 8 | this[ye + 2] << 16 | this[ye + 3] << 24;
  }, ce.prototype.readInt32BE = function(ye, we) {
    return ye = ye >>> 0, we || Ye(ye, 4, this.length), this[ye] << 24 | this[ye + 1] << 16 | this[ye + 2] << 8 | this[ye + 3];
  }, ce.prototype.readBigInt64LE = zt(function(ye) {
    ye = ye >>> 0, jt(ye, "offset");
    const we = this[ye], Ge = this[ye + 7];
    (we === void 0 || Ge === void 0) && Ot(ye, this.length - 8);
    const tt = this[ye + 4] + this[ye + 5] * 2 ** 8 + this[ye + 6] * 2 ** 16 + (Ge << 24);
    return (BigInt(tt) << BigInt(32)) + BigInt(we + this[++ye] * 2 ** 8 + this[++ye] * 2 ** 16 + this[++ye] * 2 ** 24);
  }), ce.prototype.readBigInt64BE = zt(function(ye) {
    ye = ye >>> 0, jt(ye, "offset");
    const we = this[ye], Ge = this[ye + 7];
    (we === void 0 || Ge === void 0) && Ot(ye, this.length - 8);
    const tt = (we << 24) + // Overflow
    this[++ye] * 2 ** 16 + this[++ye] * 2 ** 8 + this[++ye];
    return (BigInt(tt) << BigInt(32)) + BigInt(this[++ye] * 2 ** 24 + this[++ye] * 2 ** 16 + this[++ye] * 2 ** 8 + Ge);
  }), ce.prototype.readFloatLE = function(ye, we) {
    return ye = ye >>> 0, we || Ye(ye, 4, this.length), A.read(this, ye, !0, 23, 4);
  }, ce.prototype.readFloatBE = function(ye, we) {
    return ye = ye >>> 0, we || Ye(ye, 4, this.length), A.read(this, ye, !1, 23, 4);
  }, ce.prototype.readDoubleLE = function(ye, we) {
    return ye = ye >>> 0, we || Ye(ye, 8, this.length), A.read(this, ye, !0, 52, 8);
  }, ce.prototype.readDoubleBE = function(ye, we) {
    return ye = ye >>> 0, we || Ye(ye, 8, this.length), A.read(this, ye, !1, 52, 8);
  };
  function ot(ze, ye, we, Ge, tt, Mt) {
    if (!ce.isBuffer(ze)) throw new TypeError('"buffer" argument must be a Buffer instance');
    if (ye > tt || ye < Mt) throw new RangeError('"value" argument is out of bounds');
    if (we + Ge > ze.length) throw new RangeError("Index out of range");
  }
  ce.prototype.writeUintLE = ce.prototype.writeUIntLE = function(ye, we, Ge, tt) {
    if (ye = +ye, we = we >>> 0, Ge = Ge >>> 0, !tt) {
      const Bt = Math.pow(2, 8 * Ge) - 1;
      ot(this, ye, we, Ge, Bt, 0);
    }
    let Mt = 1, Nt = 0;
    for (this[we] = ye & 255; ++Nt < Ge && (Mt *= 256); )
      this[we + Nt] = ye / Mt & 255;
    return we + Ge;
  }, ce.prototype.writeUintBE = ce.prototype.writeUIntBE = function(ye, we, Ge, tt) {
    if (ye = +ye, we = we >>> 0, Ge = Ge >>> 0, !tt) {
      const Bt = Math.pow(2, 8 * Ge) - 1;
      ot(this, ye, we, Ge, Bt, 0);
    }
    let Mt = Ge - 1, Nt = 1;
    for (this[we + Mt] = ye & 255; --Mt >= 0 && (Nt *= 256); )
      this[we + Mt] = ye / Nt & 255;
    return we + Ge;
  }, ce.prototype.writeUint8 = ce.prototype.writeUInt8 = function(ye, we, Ge) {
    return ye = +ye, we = we >>> 0, Ge || ot(this, ye, we, 1, 255, 0), this[we] = ye & 255, we + 1;
  }, ce.prototype.writeUint16LE = ce.prototype.writeUInt16LE = function(ye, we, Ge) {
    return ye = +ye, we = we >>> 0, Ge || ot(this, ye, we, 2, 65535, 0), this[we] = ye & 255, this[we + 1] = ye >>> 8, we + 2;
  }, ce.prototype.writeUint16BE = ce.prototype.writeUInt16BE = function(ye, we, Ge) {
    return ye = +ye, we = we >>> 0, Ge || ot(this, ye, we, 2, 65535, 0), this[we] = ye >>> 8, this[we + 1] = ye & 255, we + 2;
  }, ce.prototype.writeUint32LE = ce.prototype.writeUInt32LE = function(ye, we, Ge) {
    return ye = +ye, we = we >>> 0, Ge || ot(this, ye, we, 4, 4294967295, 0), this[we + 3] = ye >>> 24, this[we + 2] = ye >>> 16, this[we + 1] = ye >>> 8, this[we] = ye & 255, we + 4;
  }, ce.prototype.writeUint32BE = ce.prototype.writeUInt32BE = function(ye, we, Ge) {
    return ye = +ye, we = we >>> 0, Ge || ot(this, ye, we, 4, 4294967295, 0), this[we] = ye >>> 24, this[we + 1] = ye >>> 16, this[we + 2] = ye >>> 8, this[we + 3] = ye & 255, we + 4;
  };
  function Be(ze, ye, we, Ge, tt) {
    It(ye, Ge, tt, ze, we, 7);
    let Mt = Number(ye & BigInt(4294967295));
    ze[we++] = Mt, Mt = Mt >> 8, ze[we++] = Mt, Mt = Mt >> 8, ze[we++] = Mt, Mt = Mt >> 8, ze[we++] = Mt;
    let Nt = Number(ye >> BigInt(32) & BigInt(4294967295));
    return ze[we++] = Nt, Nt = Nt >> 8, ze[we++] = Nt, Nt = Nt >> 8, ze[we++] = Nt, Nt = Nt >> 8, ze[we++] = Nt, we;
  }
  function Ve(ze, ye, we, Ge, tt) {
    It(ye, Ge, tt, ze, we, 7);
    let Mt = Number(ye & BigInt(4294967295));
    ze[we + 7] = Mt, Mt = Mt >> 8, ze[we + 6] = Mt, Mt = Mt >> 8, ze[we + 5] = Mt, Mt = Mt >> 8, ze[we + 4] = Mt;
    let Nt = Number(ye >> BigInt(32) & BigInt(4294967295));
    return ze[we + 3] = Nt, Nt = Nt >> 8, ze[we + 2] = Nt, Nt = Nt >> 8, ze[we + 1] = Nt, Nt = Nt >> 8, ze[we] = Nt, we + 8;
  }
  ce.prototype.writeBigUInt64LE = zt(function(ye, we = 0) {
    return Be(this, ye, we, BigInt(0), BigInt("0xffffffffffffffff"));
  }), ce.prototype.writeBigUInt64BE = zt(function(ye, we = 0) {
    return Ve(this, ye, we, BigInt(0), BigInt("0xffffffffffffffff"));
  }), ce.prototype.writeIntLE = function(ye, we, Ge, tt) {
    if (ye = +ye, we = we >>> 0, !tt) {
      const Vt = Math.pow(2, 8 * Ge - 1);
      ot(this, ye, we, Ge, Vt - 1, -Vt);
    }
    let Mt = 0, Nt = 1, Bt = 0;
    for (this[we] = ye & 255; ++Mt < Ge && (Nt *= 256); )
      ye < 0 && Bt === 0 && this[we + Mt - 1] !== 0 && (Bt = 1), this[we + Mt] = (ye / Nt >> 0) - Bt & 255;
    return we + Ge;
  }, ce.prototype.writeIntBE = function(ye, we, Ge, tt) {
    if (ye = +ye, we = we >>> 0, !tt) {
      const Vt = Math.pow(2, 8 * Ge - 1);
      ot(this, ye, we, Ge, Vt - 1, -Vt);
    }
    let Mt = Ge - 1, Nt = 1, Bt = 0;
    for (this[we + Mt] = ye & 255; --Mt >= 0 && (Nt *= 256); )
      ye < 0 && Bt === 0 && this[we + Mt + 1] !== 0 && (Bt = 1), this[we + Mt] = (ye / Nt >> 0) - Bt & 255;
    return we + Ge;
  }, ce.prototype.writeInt8 = function(ye, we, Ge) {
    return ye = +ye, we = we >>> 0, Ge || ot(this, ye, we, 1, 127, -128), ye < 0 && (ye = 255 + ye + 1), this[we] = ye & 255, we + 1;
  }, ce.prototype.writeInt16LE = function(ye, we, Ge) {
    return ye = +ye, we = we >>> 0, Ge || ot(this, ye, we, 2, 32767, -32768), this[we] = ye & 255, this[we + 1] = ye >>> 8, we + 2;
  }, ce.prototype.writeInt16BE = function(ye, we, Ge) {
    return ye = +ye, we = we >>> 0, Ge || ot(this, ye, we, 2, 32767, -32768), this[we] = ye >>> 8, this[we + 1] = ye & 255, we + 2;
  }, ce.prototype.writeInt32LE = function(ye, we, Ge) {
    return ye = +ye, we = we >>> 0, Ge || ot(this, ye, we, 4, 2147483647, -2147483648), this[we] = ye & 255, this[we + 1] = ye >>> 8, this[we + 2] = ye >>> 16, this[we + 3] = ye >>> 24, we + 4;
  }, ce.prototype.writeInt32BE = function(ye, we, Ge) {
    return ye = +ye, we = we >>> 0, Ge || ot(this, ye, we, 4, 2147483647, -2147483648), ye < 0 && (ye = 4294967295 + ye + 1), this[we] = ye >>> 24, this[we + 1] = ye >>> 16, this[we + 2] = ye >>> 8, this[we + 3] = ye & 255, we + 4;
  }, ce.prototype.writeBigInt64LE = zt(function(ye, we = 0) {
    return Be(this, ye, we, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  }), ce.prototype.writeBigInt64BE = zt(function(ye, we = 0) {
    return Ve(this, ye, we, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  function fe(ze, ye, we, Ge, tt, Mt) {
    if (we + Ge > ze.length) throw new RangeError("Index out of range");
    if (we < 0) throw new RangeError("Index out of range");
  }
  function _e(ze, ye, we, Ge, tt) {
    return ye = +ye, we = we >>> 0, tt || fe(ze, ye, we, 4), A.write(ze, ye, we, Ge, 23, 4), we + 4;
  }
  ce.prototype.writeFloatLE = function(ye, we, Ge) {
    return _e(this, ye, we, !0, Ge);
  }, ce.prototype.writeFloatBE = function(ye, we, Ge) {
    return _e(this, ye, we, !1, Ge);
  };
  function je(ze, ye, we, Ge, tt) {
    return ye = +ye, we = we >>> 0, tt || fe(ze, ye, we, 8), A.write(ze, ye, we, Ge, 52, 8), we + 8;
  }
  ce.prototype.writeDoubleLE = function(ye, we, Ge) {
    return je(this, ye, we, !0, Ge);
  }, ce.prototype.writeDoubleBE = function(ye, we, Ge) {
    return je(this, ye, we, !1, Ge);
  }, ce.prototype.copy = function(ye, we, Ge, tt) {
    if (!ce.isBuffer(ye)) throw new TypeError("argument should be a Buffer");
    if (Ge || (Ge = 0), !tt && tt !== 0 && (tt = this.length), we >= ye.length && (we = ye.length), we || (we = 0), tt > 0 && tt < Ge && (tt = Ge), tt === Ge || ye.length === 0 || this.length === 0) return 0;
    if (we < 0)
      throw new RangeError("targetStart out of bounds");
    if (Ge < 0 || Ge >= this.length) throw new RangeError("Index out of range");
    if (tt < 0) throw new RangeError("sourceEnd out of bounds");
    tt > this.length && (tt = this.length), ye.length - we < tt - Ge && (tt = ye.length - we + Ge);
    const Mt = tt - Ge;
    return this === ye && typeof J.prototype.copyWithin == "function" ? this.copyWithin(we, Ge, tt) : J.prototype.set.call(
      ye,
      this.subarray(Ge, tt),
      we
    ), Mt;
  }, ce.prototype.fill = function(ye, we, Ge, tt) {
    if (typeof ye == "string") {
      if (typeof we == "string" ? (tt = we, we = 0, Ge = this.length) : typeof Ge == "string" && (tt = Ge, Ge = this.length), tt !== void 0 && typeof tt != "string")
        throw new TypeError("encoding must be a string");
      if (typeof tt == "string" && !ce.isEncoding(tt))
        throw new TypeError("Unknown encoding: " + tt);
      if (ye.length === 1) {
        const Nt = ye.charCodeAt(0);
        (tt === "utf8" && Nt < 128 || tt === "latin1") && (ye = Nt);
      }
    } else typeof ye == "number" ? ye = ye & 255 : typeof ye == "boolean" && (ye = Number(ye));
    if (we < 0 || this.length < we || this.length < Ge)
      throw new RangeError("Out of range index");
    if (Ge <= we)
      return this;
    we = we >>> 0, Ge = Ge === void 0 ? this.length : Ge >>> 0, ye || (ye = 0);
    let Mt;
    if (typeof ye == "number")
      for (Mt = we; Mt < Ge; ++Mt)
        this[Mt] = ye;
    else {
      const Nt = ce.isBuffer(ye) ? ye : ce.from(ye, tt), Bt = Nt.length;
      if (Bt === 0)
        throw new TypeError('The value "' + ye + '" is invalid for argument "value"');
      for (Mt = 0; Mt < Ge - we; ++Mt)
        this[Mt + we] = Nt[Mt % Bt];
    }
    return this;
  };
  const Ne = {};
  function Ie(ze, ye, we) {
    Ne[ze] = class extends we {
      constructor() {
        super(), Object.defineProperty(this, "message", {
          value: ye.apply(this, arguments),
          writable: !0,
          configurable: !0
        }), this.name = `${this.name} [${ze}]`, this.stack, delete this.name;
      }
      get code() {
        return ze;
      }
      set code(tt) {
        Object.defineProperty(this, "code", {
          configurable: !0,
          enumerable: !0,
          value: tt,
          writable: !0
        });
      }
      toString() {
        return `${this.name} [${ze}]: ${this.message}`;
      }
    };
  }
  Ie(
    "ERR_BUFFER_OUT_OF_BOUNDS",
    function(ze) {
      return ze ? `${ze} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
    },
    RangeError
  ), Ie(
    "ERR_INVALID_ARG_TYPE",
    function(ze, ye) {
      return `The "${ze}" argument must be of type number. Received type ${typeof ye}`;
    },
    TypeError
  ), Ie(
    "ERR_OUT_OF_RANGE",
    function(ze, ye, we) {
      let Ge = `The value of "${ze}" is out of range.`, tt = we;
      return Number.isInteger(we) && Math.abs(we) > 2 ** 32 ? tt = Xe(String(we)) : typeof we == "bigint" && (tt = String(we), (we > BigInt(2) ** BigInt(32) || we < -(BigInt(2) ** BigInt(32))) && (tt = Xe(tt)), tt += "n"), Ge += ` It must be ${ye}. Received ${tt}`, Ge;
    },
    RangeError
  );
  function Xe(ze) {
    let ye = "", we = ze.length;
    const Ge = ze[0] === "-" ? 1 : 0;
    for (; we >= Ge + 4; we -= 3)
      ye = `_${ze.slice(we - 3, we)}${ye}`;
    return `${ze.slice(0, we)}${ye}`;
  }
  function ft(ze, ye, we) {
    jt(ye, "offset"), (ze[ye] === void 0 || ze[ye + we] === void 0) && Ot(ye, ze.length - (we + 1));
  }
  function It(ze, ye, we, Ge, tt, Mt) {
    if (ze > we || ze < ye) {
      const Nt = typeof ye == "bigint" ? "n" : "";
      let Bt;
      throw ye === 0 || ye === BigInt(0) ? Bt = `>= 0${Nt} and < 2${Nt} ** ${(Mt + 1) * 8}${Nt}` : Bt = `>= -(2${Nt} ** ${(Mt + 1) * 8 - 1}${Nt}) and < 2 ** ${(Mt + 1) * 8 - 1}${Nt}`, new Ne.ERR_OUT_OF_RANGE("value", Bt, ze);
    }
    ft(Ge, tt, Mt);
  }
  function jt(ze, ye) {
    if (typeof ze != "number")
      throw new Ne.ERR_INVALID_ARG_TYPE(ye, "number", ze);
  }
  function Ot(ze, ye, we) {
    throw Math.floor(ze) !== ze ? (jt(ze, we), new Ne.ERR_OUT_OF_RANGE("offset", "an integer", ze)) : ye < 0 ? new Ne.ERR_BUFFER_OUT_OF_BOUNDS() : new Ne.ERR_OUT_OF_RANGE(
      "offset",
      `>= 0 and <= ${ye}`,
      ze
    );
  }
  const Ut = /[^+/0-9A-Za-z-_]/g;
  function kt(ze) {
    if (ze = ze.split("=")[0], ze = ze.trim().replace(Ut, ""), ze.length < 2) return "";
    for (; ze.length % 4 !== 0; )
      ze = ze + "=";
    return ze;
  }
  function Xt(ze, ye) {
    ye = ye || 1 / 0;
    let we;
    const Ge = ze.length;
    let tt = null;
    const Mt = [];
    for (let Nt = 0; Nt < Ge; ++Nt) {
      if (we = ze.charCodeAt(Nt), we > 55295 && we < 57344) {
        if (!tt) {
          if (we > 56319) {
            (ye -= 3) > -1 && Mt.push(239, 191, 189);
            continue;
          } else if (Nt + 1 === Ge) {
            (ye -= 3) > -1 && Mt.push(239, 191, 189);
            continue;
          }
          tt = we;
          continue;
        }
        if (we < 56320) {
          (ye -= 3) > -1 && Mt.push(239, 191, 189), tt = we;
          continue;
        }
        we = (tt - 55296 << 10 | we - 56320) + 65536;
      } else tt && (ye -= 3) > -1 && Mt.push(239, 191, 189);
      if (tt = null, we < 128) {
        if ((ye -= 1) < 0) break;
        Mt.push(we);
      } else if (we < 2048) {
        if ((ye -= 2) < 0) break;
        Mt.push(
          we >> 6 | 192,
          we & 63 | 128
        );
      } else if (we < 65536) {
        if ((ye -= 3) < 0) break;
        Mt.push(
          we >> 12 | 224,
          we >> 6 & 63 | 128,
          we & 63 | 128
        );
      } else if (we < 1114112) {
        if ((ye -= 4) < 0) break;
        Mt.push(
          we >> 18 | 240,
          we >> 12 & 63 | 128,
          we >> 6 & 63 | 128,
          we & 63 | 128
        );
      } else
        throw new Error("Invalid code point");
    }
    return Mt;
  }
  function tr(ze) {
    const ye = [];
    for (let we = 0; we < ze.length; ++we)
      ye.push(ze.charCodeAt(we) & 255);
    return ye;
  }
  function Wt(ze, ye) {
    let we, Ge, tt;
    const Mt = [];
    for (let Nt = 0; Nt < ze.length && !((ye -= 2) < 0); ++Nt)
      we = ze.charCodeAt(Nt), Ge = we >> 8, tt = we % 256, Mt.push(tt), Mt.push(Ge);
    return Mt;
  }
  function xt(ze) {
    return L.toByteArray(kt(ze));
  }
  function Lt(ze, ye, we, Ge) {
    let tt;
    for (tt = 0; tt < Ge && !(tt + we >= ye.length || tt >= ze.length); ++tt)
      ye[tt + we] = ze[tt];
    return tt;
  }
  function Et(ze, ye) {
    return ze instanceof ye || ze != null && ze.constructor != null && ze.constructor.name != null && ze.constructor.name === ye.name;
  }
  function Dt(ze) {
    return ze !== ze;
  }
  const Pt = function() {
    const ze = "0123456789abcdef", ye = new Array(256);
    for (let we = 0; we < 16; ++we) {
      const Ge = we * 16;
      for (let tt = 0; tt < 16; ++tt)
        ye[Ge + tt] = ze[we] + ze[tt];
    }
    return ye;
  }();
  function zt(ze) {
    return typeof BigInt > "u" ? At : ze;
  }
  function At() {
    throw new Error("BigInt not supported");
  }
})(buffer);
const Buffer = buffer.Buffer, Blob$1 = buffer.Blob, BlobOptions = buffer.BlobOptions, Buffer$1 = buffer.Buffer, File$1 = buffer.File, FileOptions = buffer.FileOptions, INSPECT_MAX_BYTES = buffer.INSPECT_MAX_BYTES, SlowBuffer = buffer.SlowBuffer, TranscodeEncoding = buffer.TranscodeEncoding, atob$1 = buffer.atob, btoa = buffer.btoa, constants = buffer.constants, isAscii = buffer.isAscii, isUtf8 = buffer.isUtf8, kMaxLength = buffer.kMaxLength, kStringMaxLength = buffer.kStringMaxLength, resolveObjectURL = buffer.resolveObjectURL, transcode = buffer.transcode, dist = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Blob: Blob$1,
  BlobOptions,
  Buffer: Buffer$1,
  File: File$1,
  FileOptions,
  INSPECT_MAX_BYTES,
  SlowBuffer,
  TranscodeEncoding,
  atob: atob$1,
  btoa,
  constants,
  default: Buffer,
  isAscii,
  isUtf8,
  kMaxLength,
  kStringMaxLength,
  resolveObjectURL,
  transcode
}, Symbol.toStringTag, { value: "Module" }));
var AbstractTokenizer$1 = {}, lib$2 = {}, EndOfFileStream = {};
(function(C) {
  Object.defineProperty(C, "__esModule", { value: !0 }), C.EndOfStreamError = C.defaultMessages = void 0, C.defaultMessages = "End-Of-Stream";
  class L extends Error {
    constructor() {
      super(C.defaultMessages);
    }
  }
  C.EndOfStreamError = L;
})(EndOfFileStream);
var StreamReader$1 = {}, Deferred$1 = {};
Object.defineProperty(Deferred$1, "__esModule", { value: !0 });
Deferred$1.Deferred = void 0;
class Deferred {
  constructor() {
    this.resolve = () => null, this.reject = () => null, this.promise = new Promise((L, A) => {
      this.reject = A, this.resolve = L;
    });
  }
}
Deferred$1.Deferred = Deferred;
(function(C) {
  Object.defineProperty(C, "__esModule", { value: !0 }), C.StreamReader = C.EndOfStreamError = void 0;
  const L = EndOfFileStream, A = Deferred$1;
  var W = EndOfFileStream;
  Object.defineProperty(C, "EndOfStreamError", { enumerable: !0, get: function() {
    return W.EndOfStreamError;
  } });
  const X = 1 * 1024 * 1024;
  class J {
    constructor(oe) {
      if (this.s = oe, this.deferred = null, this.endOfStream = !1, this.peekQueue = [], !oe.read || !oe.once)
        throw new Error("Expected an instance of stream.Readable");
      this.s.once("end", () => this.reject(new L.EndOfStreamError())), this.s.once("error", (ne) => this.reject(ne)), this.s.once("close", () => this.reject(new Error("Stream closed")));
    }
    /**
     * Read ahead (peek) from stream. Subsequent read or peeks will return the same data
     * @param uint8Array - Uint8Array (or Buffer) to store data read from stream in
     * @param offset - Offset target
     * @param length - Number of bytes to read
     * @returns Number of bytes peeked
     */
    async peek(oe, ne, re) {
      const ce = await this.read(oe, ne, re);
      return this.peekQueue.push(oe.subarray(ne, ne + ce)), ce;
    }
    /**
     * Read chunk from stream
     * @param buffer - Target Uint8Array (or Buffer) to store data read from stream in
     * @param offset - Offset target
     * @param length - Number of bytes to read
     * @returns Number of bytes read
     */
    async read(oe, ne, re) {
      if (re === 0)
        return 0;
      if (this.peekQueue.length === 0 && this.endOfStream)
        throw new L.EndOfStreamError();
      let ce = re, ue = 0;
      for (; this.peekQueue.length > 0 && ce > 0; ) {
        const de = this.peekQueue.pop();
        if (!de)
          throw new Error("peekData should be defined");
        const be = Math.min(de.length, ce);
        oe.set(de.subarray(0, be), ne + ue), ue += be, ce -= be, be < de.length && this.peekQueue.push(de.subarray(be));
      }
      for (; ce > 0 && !this.endOfStream; ) {
        const de = Math.min(ce, X), be = await this.readFromStream(oe, ne + ue, de);
        if (ue += be, be < de)
          break;
        ce -= be;
      }
      return ue;
    }
    /**
     * Read chunk from stream
     * @param buffer Target Uint8Array (or Buffer) to store data read from stream in
     * @param offset Offset target
     * @param length Number of bytes to read
     * @returns Number of bytes read
     */
    async readFromStream(oe, ne, re) {
      const ce = this.s.read(re);
      if (ce)
        return oe.set(ce, ne), ce.length;
      {
        const ue = {
          buffer: oe,
          offset: ne,
          length: re,
          deferred: new A.Deferred()
        };
        return this.deferred = ue.deferred, this.s.once("readable", () => {
          this.readDeferred(ue);
        }), ue.deferred.promise;
      }
    }
    /**
     * Process deferred read request
     * @param request Deferred read request
     */
    readDeferred(oe) {
      const ne = this.s.read(oe.length);
      ne ? (oe.buffer.set(ne, oe.offset), oe.deferred.resolve(ne.length), this.deferred = null) : this.s.once("readable", () => {
        this.readDeferred(oe);
      });
    }
    reject(oe) {
      this.endOfStream = !0, this.deferred && (this.deferred.reject(oe), this.deferred = null);
    }
  }
  C.StreamReader = J;
})(StreamReader$1);
(function(C) {
  Object.defineProperty(C, "__esModule", { value: !0 }), C.StreamReader = C.EndOfStreamError = void 0;
  var L = EndOfFileStream;
  Object.defineProperty(C, "EndOfStreamError", { enumerable: !0, get: function() {
    return L.EndOfStreamError;
  } });
  var A = StreamReader$1;
  Object.defineProperty(C, "StreamReader", { enumerable: !0, get: function() {
    return A.StreamReader;
  } });
})(lib$2);
Object.defineProperty(AbstractTokenizer$1, "__esModule", { value: !0 });
AbstractTokenizer$1.AbstractTokenizer = void 0;
const peek_readable_1$2 = lib$2;
class AbstractTokenizer {
  constructor(L) {
    this.position = 0, this.numBuffer = new Uint8Array(8), this.fileInfo = L || {};
  }
  /**
   * Read a token from the tokenizer-stream
   * @param token - The token to read
   * @param position - If provided, the desired position in the tokenizer-stream
   * @returns Promise with token data
   */
  async readToken(L, A = this.position) {
    const W = Buffer.alloc(L.len);
    if (await this.readBuffer(W, { position: A }) < L.len)
      throw new peek_readable_1$2.EndOfStreamError();
    return L.get(W, 0);
  }
  /**
   * Peek a token from the tokenizer-stream.
   * @param token - Token to peek from the tokenizer-stream.
   * @param position - Offset where to begin reading within the file. If position is null, data will be read from the current file position.
   * @returns Promise with token data
   */
  async peekToken(L, A = this.position) {
    const W = Buffer.alloc(L.len);
    if (await this.peekBuffer(W, { position: A }) < L.len)
      throw new peek_readable_1$2.EndOfStreamError();
    return L.get(W, 0);
  }
  /**
   * Read a numeric token from the stream
   * @param token - Numeric token
   * @returns Promise with number
   */
  async readNumber(L) {
    if (await this.readBuffer(this.numBuffer, { length: L.len }) < L.len)
      throw new peek_readable_1$2.EndOfStreamError();
    return L.get(this.numBuffer, 0);
  }
  /**
   * Read a numeric token from the stream
   * @param token - Numeric token
   * @returns Promise with number
   */
  async peekNumber(L) {
    if (await this.peekBuffer(this.numBuffer, { length: L.len }) < L.len)
      throw new peek_readable_1$2.EndOfStreamError();
    return L.get(this.numBuffer, 0);
  }
  /**
   * Ignore number of bytes, advances the pointer in under tokenizer-stream.
   * @param length - Number of bytes to ignore
   * @return resolves the number of bytes ignored, equals length if this available, otherwise the number of bytes available
   */
  async ignore(L) {
    if (this.fileInfo.size !== void 0) {
      const A = this.fileInfo.size - this.position;
      if (L > A)
        return this.position += A, A;
    }
    return this.position += L, L;
  }
  async close() {
  }
  normalizeOptions(L, A) {
    if (A && A.position !== void 0 && A.position < this.position)
      throw new Error("`options.position` must be equal or greater than `tokenizer.position`");
    return A ? {
      mayBeLess: A.mayBeLess === !0,
      offset: A.offset ? A.offset : 0,
      length: A.length ? A.length : L.length - (A.offset ? A.offset : 0),
      position: A.position ? A.position : this.position
    } : {
      mayBeLess: !1,
      offset: 0,
      length: L.length,
      position: this.position
    };
  }
}
AbstractTokenizer$1.AbstractTokenizer = AbstractTokenizer;
Object.defineProperty(ReadStreamTokenizer$1, "__esModule", { value: !0 });
ReadStreamTokenizer$1.ReadStreamTokenizer = void 0;
const AbstractTokenizer_1$1 = AbstractTokenizer$1, peek_readable_1$1 = lib$2, maxBufferSize = 256e3;
class ReadStreamTokenizer extends AbstractTokenizer_1$1.AbstractTokenizer {
  constructor(L, A) {
    super(A), this.streamReader = new peek_readable_1$1.StreamReader(L);
  }
  /**
   * Get file information, an HTTP-client may implement this doing a HEAD request
   * @return Promise with file information
   */
  async getFileInfo() {
    return this.fileInfo;
  }
  /**
   * Read buffer from tokenizer
   * @param uint8Array - Target Uint8Array to fill with data read from the tokenizer-stream
   * @param options - Read behaviour options
   * @returns Promise with number of bytes read
   */
  async readBuffer(L, A) {
    const W = this.normalizeOptions(L, A), X = W.position - this.position;
    if (X > 0)
      return await this.ignore(X), this.readBuffer(L, A);
    if (X < 0)
      throw new Error("`options.position` must be equal or greater than `tokenizer.position`");
    if (W.length === 0)
      return 0;
    const J = await this.streamReader.read(L, W.offset, W.length);
    if (this.position += J, (!A || !A.mayBeLess) && J < W.length)
      throw new peek_readable_1$1.EndOfStreamError();
    return J;
  }
  /**
   * Peek (read ahead) buffer from tokenizer
   * @param uint8Array - Uint8Array (or Buffer) to write data to
   * @param options - Read behaviour options
   * @returns Promise with number of bytes peeked
   */
  async peekBuffer(L, A) {
    const W = this.normalizeOptions(L, A);
    let X = 0;
    if (W.position) {
      const J = W.position - this.position;
      if (J > 0) {
        const te = new Uint8Array(W.length + J);
        return X = await this.peekBuffer(te, { mayBeLess: W.mayBeLess }), L.set(te.subarray(J), W.offset), X - J;
      } else if (J < 0)
        throw new Error("Cannot peek from a negative offset in a stream");
    }
    if (W.length > 0) {
      try {
        X = await this.streamReader.peek(L, W.offset, W.length);
      } catch (J) {
        if (A && A.mayBeLess && J instanceof peek_readable_1$1.EndOfStreamError)
          return 0;
        throw J;
      }
      if (!W.mayBeLess && X < W.length)
        throw new peek_readable_1$1.EndOfStreamError();
    }
    return X;
  }
  async ignore(L) {
    const A = Math.min(maxBufferSize, L), W = new Uint8Array(A);
    let X = 0;
    for (; X < L; ) {
      const J = L - X, te = await this.readBuffer(W, { length: Math.min(A, J) });
      if (te < 0)
        return te;
      X += te;
    }
    return X;
  }
}
ReadStreamTokenizer$1.ReadStreamTokenizer = ReadStreamTokenizer;
var BufferTokenizer$1 = {};
Object.defineProperty(BufferTokenizer$1, "__esModule", { value: !0 });
BufferTokenizer$1.BufferTokenizer = void 0;
const peek_readable_1 = lib$2, AbstractTokenizer_1 = AbstractTokenizer$1;
class BufferTokenizer extends AbstractTokenizer_1.AbstractTokenizer {
  /**
   * Construct BufferTokenizer
   * @param uint8Array - Uint8Array to tokenize
   * @param fileInfo - Pass additional file information to the tokenizer
   */
  constructor(L, A) {
    super(A), this.uint8Array = L, this.fileInfo.size = this.fileInfo.size ? this.fileInfo.size : L.length;
  }
  /**
   * Read buffer from tokenizer
   * @param uint8Array - Uint8Array to tokenize
   * @param options - Read behaviour options
   * @returns {Promise<number>}
   */
  async readBuffer(L, A) {
    if (A && A.position) {
      if (A.position < this.position)
        throw new Error("`options.position` must be equal or greater than `tokenizer.position`");
      this.position = A.position;
    }
    const W = await this.peekBuffer(L, A);
    return this.position += W, W;
  }
  /**
   * Peek (read ahead) buffer from tokenizer
   * @param uint8Array
   * @param options - Read behaviour options
   * @returns {Promise<number>}
   */
  async peekBuffer(L, A) {
    const W = this.normalizeOptions(L, A), X = Math.min(this.uint8Array.length - W.position, W.length);
    if (!W.mayBeLess && X < W.length)
      throw new peek_readable_1.EndOfStreamError();
    return L.set(this.uint8Array.subarray(W.position, W.position + X), W.offset), X;
  }
  async close() {
  }
}
BufferTokenizer$1.BufferTokenizer = BufferTokenizer;
(function(C) {
  Object.defineProperty(C, "__esModule", { value: !0 }), C.fromBuffer = C.fromStream = C.EndOfStreamError = void 0;
  const L = ReadStreamTokenizer$1, A = BufferTokenizer$1;
  var W = lib$2;
  Object.defineProperty(C, "EndOfStreamError", { enumerable: !0, get: function() {
    return W.EndOfStreamError;
  } });
  function X(te, oe) {
    return oe = oe || {}, new L.ReadStreamTokenizer(te, oe);
  }
  C.fromStream = X;
  function J(te, oe) {
    return new A.BufferTokenizer(te, oe);
  }
  C.fromBuffer = J;
})(core$1);
var ParserFactory$1 = {}, lib$1 = {}, ieee754 = {};
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
ieee754.read = function(C, L, A, W, X) {
  var J, te, oe = X * 8 - W - 1, ne = (1 << oe) - 1, re = ne >> 1, ce = -7, ue = A ? X - 1 : 0, de = A ? -1 : 1, be = C[L + ue];
  for (ue += de, J = be & (1 << -ce) - 1, be >>= -ce, ce += oe; ce > 0; J = J * 256 + C[L + ue], ue += de, ce -= 8)
    ;
  for (te = J & (1 << -ce) - 1, J >>= -ce, ce += W; ce > 0; te = te * 256 + C[L + ue], ue += de, ce -= 8)
    ;
  if (J === 0)
    J = 1 - re;
  else {
    if (J === ne)
      return te ? NaN : (be ? -1 : 1) * (1 / 0);
    te = te + Math.pow(2, W), J = J - re;
  }
  return (be ? -1 : 1) * te * Math.pow(2, J - W);
};
ieee754.write = function(C, L, A, W, X, J) {
  var te, oe, ne, re = J * 8 - X - 1, ce = (1 << re) - 1, ue = ce >> 1, de = X === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, be = W ? 0 : J - 1, pe = W ? 1 : -1, me = L < 0 || L === 0 && 1 / L < 0 ? 1 : 0;
  for (L = Math.abs(L), isNaN(L) || L === 1 / 0 ? (oe = isNaN(L) ? 1 : 0, te = ce) : (te = Math.floor(Math.log(L) / Math.LN2), L * (ne = Math.pow(2, -te)) < 1 && (te--, ne *= 2), te + ue >= 1 ? L += de / ne : L += de * Math.pow(2, 1 - ue), L * ne >= 2 && (te++, ne /= 2), te + ue >= ce ? (oe = 0, te = ce) : te + ue >= 1 ? (oe = (L * ne - 1) * Math.pow(2, X), te = te + ue) : (oe = L * Math.pow(2, ue - 1) * Math.pow(2, X), te = 0)); X >= 8; C[A + be] = oe & 255, be += pe, oe /= 256, X -= 8)
    ;
  for (te = te << X | oe, re += X; re > 0; C[A + be] = te & 255, be += pe, te /= 256, re -= 8)
    ;
  C[A + be - pe] |= me * 128;
};
(function(C) {
  Object.defineProperty(C, "__esModule", { value: !0 }), C.AnsiStringType = C.StringType = C.BufferType = C.Uint8ArrayType = C.IgnoreType = C.Float80_LE = C.Float80_BE = C.Float64_LE = C.Float64_BE = C.Float32_LE = C.Float32_BE = C.Float16_LE = C.Float16_BE = C.INT64_BE = C.UINT64_BE = C.INT64_LE = C.UINT64_LE = C.INT32_LE = C.INT32_BE = C.INT24_BE = C.INT24_LE = C.INT16_LE = C.INT16_BE = C.INT8 = C.UINT32_BE = C.UINT32_LE = C.UINT24_BE = C.UINT24_LE = C.UINT16_BE = C.UINT16_LE = C.UINT8 = void 0;
  const L = ieee754;
  function A(ne) {
    return new DataView(ne.buffer, ne.byteOffset);
  }
  C.UINT8 = {
    len: 1,
    get(ne, re) {
      return A(ne).getUint8(re);
    },
    put(ne, re, ce) {
      return A(ne).setUint8(re, ce), re + 1;
    }
  }, C.UINT16_LE = {
    len: 2,
    get(ne, re) {
      return A(ne).getUint16(re, !0);
    },
    put(ne, re, ce) {
      return A(ne).setUint16(re, ce, !0), re + 2;
    }
  }, C.UINT16_BE = {
    len: 2,
    get(ne, re) {
      return A(ne).getUint16(re);
    },
    put(ne, re, ce) {
      return A(ne).setUint16(re, ce), re + 2;
    }
  }, C.UINT24_LE = {
    len: 3,
    get(ne, re) {
      const ce = A(ne);
      return ce.getUint8(re) + (ce.getUint16(re + 1, !0) << 8);
    },
    put(ne, re, ce) {
      const ue = A(ne);
      return ue.setUint8(re, ce & 255), ue.setUint16(re + 1, ce >> 8, !0), re + 3;
    }
  }, C.UINT24_BE = {
    len: 3,
    get(ne, re) {
      const ce = A(ne);
      return (ce.getUint16(re) << 8) + ce.getUint8(re + 2);
    },
    put(ne, re, ce) {
      const ue = A(ne);
      return ue.setUint16(re, ce >> 8), ue.setUint8(re + 2, ce & 255), re + 3;
    }
  }, C.UINT32_LE = {
    len: 4,
    get(ne, re) {
      return A(ne).getUint32(re, !0);
    },
    put(ne, re, ce) {
      return A(ne).setUint32(re, ce, !0), re + 4;
    }
  }, C.UINT32_BE = {
    len: 4,
    get(ne, re) {
      return A(ne).getUint32(re);
    },
    put(ne, re, ce) {
      return A(ne).setUint32(re, ce), re + 4;
    }
  }, C.INT8 = {
    len: 1,
    get(ne, re) {
      return A(ne).getInt8(re);
    },
    put(ne, re, ce) {
      return A(ne).setInt8(re, ce), re + 1;
    }
  }, C.INT16_BE = {
    len: 2,
    get(ne, re) {
      return A(ne).getInt16(re);
    },
    put(ne, re, ce) {
      return A(ne).setInt16(re, ce), re + 2;
    }
  }, C.INT16_LE = {
    len: 2,
    get(ne, re) {
      return A(ne).getInt16(re, !0);
    },
    put(ne, re, ce) {
      return A(ne).setInt16(re, ce, !0), re + 2;
    }
  }, C.INT24_LE = {
    len: 3,
    get(ne, re) {
      const ce = C.UINT24_LE.get(ne, re);
      return ce > 8388607 ? ce - 16777216 : ce;
    },
    put(ne, re, ce) {
      const ue = A(ne);
      return ue.setUint8(re, ce & 255), ue.setUint16(re + 1, ce >> 8, !0), re + 3;
    }
  }, C.INT24_BE = {
    len: 3,
    get(ne, re) {
      const ce = C.UINT24_BE.get(ne, re);
      return ce > 8388607 ? ce - 16777216 : ce;
    },
    put(ne, re, ce) {
      const ue = A(ne);
      return ue.setUint16(re, ce >> 8), ue.setUint8(re + 2, ce & 255), re + 3;
    }
  }, C.INT32_BE = {
    len: 4,
    get(ne, re) {
      return A(ne).getInt32(re);
    },
    put(ne, re, ce) {
      return A(ne).setInt32(re, ce), re + 4;
    }
  }, C.INT32_LE = {
    len: 4,
    get(ne, re) {
      return A(ne).getInt32(re, !0);
    },
    put(ne, re, ce) {
      return A(ne).setInt32(re, ce, !0), re + 4;
    }
  }, C.UINT64_LE = {
    len: 8,
    get(ne, re) {
      return A(ne).getBigUint64(re, !0);
    },
    put(ne, re, ce) {
      return A(ne).setBigUint64(re, ce, !0), re + 8;
    }
  }, C.INT64_LE = {
    len: 8,
    get(ne, re) {
      return A(ne).getBigInt64(re, !0);
    },
    put(ne, re, ce) {
      return A(ne).setBigInt64(re, ce, !0), re + 8;
    }
  }, C.UINT64_BE = {
    len: 8,
    get(ne, re) {
      return A(ne).getBigUint64(re);
    },
    put(ne, re, ce) {
      return A(ne).setBigUint64(re, ce), re + 8;
    }
  }, C.INT64_BE = {
    len: 8,
    get(ne, re) {
      return A(ne).getBigInt64(re);
    },
    put(ne, re, ce) {
      return A(ne).setBigInt64(re, ce), re + 8;
    }
  }, C.Float16_BE = {
    len: 2,
    get(ne, re) {
      return L.read(ne, re, !1, 10, this.len);
    },
    put(ne, re, ce) {
      return L.write(ne, ce, re, !1, 10, this.len), re + this.len;
    }
  }, C.Float16_LE = {
    len: 2,
    get(ne, re) {
      return L.read(ne, re, !0, 10, this.len);
    },
    put(ne, re, ce) {
      return L.write(ne, ce, re, !0, 10, this.len), re + this.len;
    }
  }, C.Float32_BE = {
    len: 4,
    get(ne, re) {
      return A(ne).getFloat32(re);
    },
    put(ne, re, ce) {
      return A(ne).setFloat32(re, ce), re + 4;
    }
  }, C.Float32_LE = {
    len: 4,
    get(ne, re) {
      return A(ne).getFloat32(re, !0);
    },
    put(ne, re, ce) {
      return A(ne).setFloat32(re, ce, !0), re + 4;
    }
  }, C.Float64_BE = {
    len: 8,
    get(ne, re) {
      return A(ne).getFloat64(re);
    },
    put(ne, re, ce) {
      return A(ne).setFloat64(re, ce), re + 8;
    }
  }, C.Float64_LE = {
    len: 8,
    get(ne, re) {
      return A(ne).getFloat64(re, !0);
    },
    put(ne, re, ce) {
      return A(ne).setFloat64(re, ce, !0), re + 8;
    }
  }, C.Float80_BE = {
    len: 10,
    get(ne, re) {
      return L.read(ne, re, !1, 63, this.len);
    },
    put(ne, re, ce) {
      return L.write(ne, ce, re, !1, 63, this.len), re + this.len;
    }
  }, C.Float80_LE = {
    len: 10,
    get(ne, re) {
      return L.read(ne, re, !0, 63, this.len);
    },
    put(ne, re, ce) {
      return L.write(ne, ce, re, !0, 63, this.len), re + this.len;
    }
  };
  class W {
    /**
     * @param len number of bytes to ignore
     */
    constructor(re) {
      this.len = re;
    }
    // ToDo: don't read, but skip data
    get(re, ce) {
    }
  }
  C.IgnoreType = W;
  class X {
    constructor(re) {
      this.len = re;
    }
    get(re, ce) {
      return re.subarray(ce, ce + this.len);
    }
  }
  C.Uint8ArrayType = X;
  class J {
    constructor(re) {
      this.len = re;
    }
    get(re, ce) {
      return Buffer.from(re.subarray(ce, ce + this.len));
    }
  }
  C.BufferType = J;
  class te {
    constructor(re, ce) {
      this.len = re, this.encoding = ce;
    }
    get(re, ce) {
      return Buffer.from(re).toString(this.encoding, ce, ce + this.len);
    }
  }
  C.StringType = te;
  class oe {
    constructor(re) {
      this.len = re;
    }
    static decode(re, ce, ue) {
      let de = "";
      for (let be = ce; be < ue; ++be)
        de += oe.codePointToString(oe.singleByteDecoder(re[be]));
      return de;
    }
    static inRange(re, ce, ue) {
      return ce <= re && re <= ue;
    }
    static codePointToString(re) {
      return re <= 65535 ? String.fromCharCode(re) : (re -= 65536, String.fromCharCode((re >> 10) + 55296, (re & 1023) + 56320));
    }
    static singleByteDecoder(re) {
      if (oe.inRange(re, 0, 127))
        return re;
      const ce = oe.windows1252[re - 128];
      if (ce === null)
        throw Error("invaliding encoding");
      return ce;
    }
    get(re, ce = 0) {
      return oe.decode(re, ce, ce + this.len);
    }
  }
  C.AnsiStringType = oe, oe.windows1252 = [
    8364,
    129,
    8218,
    402,
    8222,
    8230,
    8224,
    8225,
    710,
    8240,
    352,
    8249,
    338,
    141,
    381,
    143,
    144,
    8216,
    8217,
    8220,
    8221,
    8226,
    8211,
    8212,
    732,
    8482,
    353,
    8250,
    339,
    157,
    382,
    376,
    160,
    161,
    162,
    163,
    164,
    165,
    166,
    167,
    168,
    169,
    170,
    171,
    172,
    173,
    174,
    175,
    176,
    177,
    178,
    179,
    180,
    181,
    182,
    183,
    184,
    185,
    186,
    187,
    188,
    189,
    190,
    191,
    192,
    193,
    194,
    195,
    196,
    197,
    198,
    199,
    200,
    201,
    202,
    203,
    204,
    205,
    206,
    207,
    208,
    209,
    210,
    211,
    212,
    213,
    214,
    215,
    216,
    217,
    218,
    219,
    220,
    221,
    222,
    223,
    224,
    225,
    226,
    227,
    228,
    229,
    230,
    231,
    232,
    233,
    234,
    235,
    236,
    237,
    238,
    239,
    240,
    241,
    242,
    243,
    244,
    245,
    246,
    247,
    248,
    249,
    250,
    251,
    252,
    253,
    254,
    255
  ];
})(lib$1);
var util$c = {};
util$c.stringToBytes = (C) => [...C].map((L) => L.charCodeAt(0));
util$c.tarHeaderChecksumMatches = (C, L = 0) => {
  const A = parseInt(C.toString("utf8", 148, 154).replace(/\0.*$/, "").trim(), 8);
  if (isNaN(A))
    return !1;
  let W = 8 * 32;
  for (let X = L; X < L + 148; X++)
    W += C[X];
  for (let X = L + 156; X < L + 512; X++)
    W += C[X];
  return A === W;
};
util$c.uint32SyncSafeToken = {
  get: (C, L) => C[L + 3] & 127 | C[L + 2] << 7 | C[L + 1] << 14 | C[L] << 21,
  len: 4
};
var supported$1 = {
  extensions: [
    "jpg",
    "png",
    "apng",
    "gif",
    "webp",
    "flif",
    "xcf",
    "cr2",
    "cr3",
    "orf",
    "arw",
    "dng",
    "nef",
    "rw2",
    "raf",
    "tif",
    "bmp",
    "icns",
    "jxr",
    "psd",
    "indd",
    "zip",
    "tar",
    "rar",
    "gz",
    "bz2",
    "7z",
    "dmg",
    "mp4",
    "mid",
    "mkv",
    "webm",
    "mov",
    "avi",
    "mpg",
    "mp2",
    "mp3",
    "m4a",
    "oga",
    "ogg",
    "ogv",
    "opus",
    "flac",
    "wav",
    "spx",
    "amr",
    "pdf",
    "epub",
    "exe",
    "swf",
    "rtf",
    "wasm",
    "woff",
    "woff2",
    "eot",
    "ttf",
    "otf",
    "ico",
    "flv",
    "ps",
    "xz",
    "sqlite",
    "nes",
    "crx",
    "xpi",
    "cab",
    "deb",
    "ar",
    "rpm",
    "Z",
    "lz",
    "cfb",
    "mxf",
    "mts",
    "blend",
    "bpg",
    "docx",
    "pptx",
    "xlsx",
    "3gp",
    "3g2",
    "jp2",
    "jpm",
    "jpx",
    "mj2",
    "aif",
    "qcp",
    "odt",
    "ods",
    "odp",
    "xml",
    "mobi",
    "heic",
    "cur",
    "ktx",
    "ape",
    "wv",
    "dcm",
    "ics",
    "glb",
    "pcap",
    "dsf",
    "lnk",
    "alias",
    "voc",
    "ac3",
    "m4v",
    "m4p",
    "m4b",
    "f4v",
    "f4p",
    "f4b",
    "f4a",
    "mie",
    "asf",
    "ogm",
    "ogx",
    "mpc",
    "arrow",
    "shp",
    "aac",
    "mp1",
    "it",
    "s3m",
    "xm",
    "ai",
    "skp",
    "avif",
    "eps",
    "lzh",
    "pgp",
    "asar",
    "stl",
    "chm",
    "3mf",
    "zst",
    "jxl",
    "vcf"
  ],
  mimeTypes: [
    "image/jpeg",
    "image/png",
    "image/gif",
    "image/webp",
    "image/flif",
    "image/x-xcf",
    "image/x-canon-cr2",
    "image/x-canon-cr3",
    "image/tiff",
    "image/bmp",
    "image/vnd.ms-photo",
    "image/vnd.adobe.photoshop",
    "application/x-indesign",
    "application/epub+zip",
    "application/x-xpinstall",
    "application/vnd.oasis.opendocument.text",
    "application/vnd.oasis.opendocument.spreadsheet",
    "application/vnd.oasis.opendocument.presentation",
    "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
    "application/vnd.openxmlformats-officedocument.presentationml.presentation",
    "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
    "application/zip",
    "application/x-tar",
    "application/x-rar-compressed",
    "application/gzip",
    "application/x-bzip2",
    "application/x-7z-compressed",
    "application/x-apple-diskimage",
    "application/x-apache-arrow",
    "video/mp4",
    "audio/midi",
    "video/x-matroska",
    "video/webm",
    "video/quicktime",
    "video/vnd.avi",
    "audio/vnd.wave",
    "audio/qcelp",
    "audio/x-ms-asf",
    "video/x-ms-asf",
    "application/vnd.ms-asf",
    "video/mpeg",
    "video/3gpp",
    "audio/mpeg",
    "audio/mp4",
    // RFC 4337
    "audio/opus",
    "video/ogg",
    "audio/ogg",
    "application/ogg",
    "audio/x-flac",
    "audio/ape",
    "audio/wavpack",
    "audio/amr",
    "application/pdf",
    "application/x-msdownload",
    "application/x-shockwave-flash",
    "application/rtf",
    "application/wasm",
    "font/woff",
    "font/woff2",
    "application/vnd.ms-fontobject",
    "font/ttf",
    "font/otf",
    "image/x-icon",
    "video/x-flv",
    "application/postscript",
    "application/eps",
    "application/x-xz",
    "application/x-sqlite3",
    "application/x-nintendo-nes-rom",
    "application/x-google-chrome-extension",
    "application/vnd.ms-cab-compressed",
    "application/x-deb",
    "application/x-unix-archive",
    "application/x-rpm",
    "application/x-compress",
    "application/x-lzip",
    "application/x-cfb",
    "application/x-mie",
    "application/mxf",
    "video/mp2t",
    "application/x-blender",
    "image/bpg",
    "image/jp2",
    "image/jpx",
    "image/jpm",
    "image/mj2",
    "audio/aiff",
    "application/xml",
    "application/x-mobipocket-ebook",
    "image/heif",
    "image/heif-sequence",
    "image/heic",
    "image/heic-sequence",
    "image/icns",
    "image/ktx",
    "application/dicom",
    "audio/x-musepack",
    "text/calendar",
    "text/vcard",
    "model/gltf-binary",
    "application/vnd.tcpdump.pcap",
    "audio/x-dsf",
    // Non-standard
    "application/x.ms.shortcut",
    // Invented by us
    "application/x.apple.alias",
    // Invented by us
    "audio/x-voc",
    "audio/vnd.dolby.dd-raw",
    "audio/x-m4a",
    "image/apng",
    "image/x-olympus-orf",
    "image/x-sony-arw",
    "image/x-adobe-dng",
    "image/x-nikon-nef",
    "image/x-panasonic-rw2",
    "image/x-fujifilm-raf",
    "video/x-m4v",
    "video/3gpp2",
    "application/x-esri-shape",
    "audio/aac",
    "audio/x-it",
    "audio/x-s3m",
    "audio/x-xm",
    "video/MP1S",
    "video/MP2P",
    "application/vnd.sketchup.skp",
    "image/avif",
    "application/x-lzh-compressed",
    "application/pgp-encrypted",
    "application/x-asar",
    "model/stl",
    "application/vnd.ms-htmlhelp",
    "model/3mf",
    "image/jxl",
    "application/zstd"
  ]
};
const Token$s = lib$1, strtok3$5 = core$1, {
  stringToBytes,
  tarHeaderChecksumMatches,
  uint32SyncSafeToken
} = util$c, supported = supported$1, minimumBytes = 4100;
async function fromStream(C) {
  const L = await strtok3$5.fromStream(C);
  try {
    return await fromTokenizer(L);
  } finally {
    await L.close();
  }
}
async function fromBuffer(C) {
  if (!(C instanceof Uint8Array || C instanceof ArrayBuffer || Buffer.isBuffer(C)))
    throw new TypeError(`Expected the \`input\` argument to be of type \`Uint8Array\` or \`Buffer\` or \`ArrayBuffer\`, got \`${typeof C}\``);
  const L = C instanceof Buffer ? C : Buffer.from(C);
  if (!(L && L.length > 1))
    return;
  const A = strtok3$5.fromBuffer(L);
  return fromTokenizer(A);
}
function _check(C, L, A) {
  A = {
    offset: 0,
    ...A
  };
  for (const [W, X] of L.entries())
    if (A.mask) {
      if (X !== (A.mask[W] & C[W + A.offset]))
        return !1;
    } else if (X !== C[W + A.offset])
      return !1;
  return !0;
}
async function fromTokenizer(C) {
  try {
    return _fromTokenizer(C);
  } catch (L) {
    if (!(L instanceof strtok3$5.EndOfStreamError))
      throw L;
  }
}
async function _fromTokenizer(C) {
  let L = Buffer.alloc(minimumBytes);
  const A = 12, W = (J, te) => _check(L, J, te), X = (J, te) => W(stringToBytes(J), te);
  if (C.fileInfo.size || (C.fileInfo.size = Number.MAX_SAFE_INTEGER), await C.peekBuffer(L, { length: A, mayBeLess: !0 }), W([66, 77]))
    return {
      ext: "bmp",
      mime: "image/bmp"
    };
  if (W([11, 119]))
    return {
      ext: "ac3",
      mime: "audio/vnd.dolby.dd-raw"
    };
  if (W([120, 1]))
    return {
      ext: "dmg",
      mime: "application/x-apple-diskimage"
    };
  if (W([77, 90]))
    return {
      ext: "exe",
      mime: "application/x-msdownload"
    };
  if (W([37, 33]))
    return await C.peekBuffer(L, { length: 24, mayBeLess: !0 }), X("PS-Adobe-", { offset: 2 }) && X(" EPSF-", { offset: 14 }) ? {
      ext: "eps",
      mime: "application/eps"
    } : {
      ext: "ps",
      mime: "application/postscript"
    };
  if (W([31, 160]) || W([31, 157]))
    return {
      ext: "Z",
      mime: "application/x-compress"
    };
  if (W([255, 216, 255]))
    return {
      ext: "jpg",
      mime: "image/jpeg"
    };
  if (W([73, 73, 188]))
    return {
      ext: "jxr",
      mime: "image/vnd.ms-photo"
    };
  if (W([31, 139, 8]))
    return {
      ext: "gz",
      mime: "application/gzip"
    };
  if (W([66, 90, 104]))
    return {
      ext: "bz2",
      mime: "application/x-bzip2"
    };
  if (X("ID3")) {
    await C.ignore(6);
    const J = await C.readToken(uint32SyncSafeToken);
    return C.position + J > C.fileInfo.size ? {
      ext: "mp3",
      mime: "audio/mpeg"
    } : (await C.ignore(J), fromTokenizer(C));
  }
  if (X("MP+"))
    return {
      ext: "mpc",
      mime: "audio/x-musepack"
    };
  if ((L[0] === 67 || L[0] === 70) && W([87, 83], { offset: 1 }))
    return {
      ext: "swf",
      mime: "application/x-shockwave-flash"
    };
  if (W([71, 73, 70]))
    return {
      ext: "gif",
      mime: "image/gif"
    };
  if (X("FLIF"))
    return {
      ext: "flif",
      mime: "image/flif"
    };
  if (X("8BPS"))
    return {
      ext: "psd",
      mime: "image/vnd.adobe.photoshop"
    };
  if (X("WEBP", { offset: 8 }))
    return {
      ext: "webp",
      mime: "image/webp"
    };
  if (X("MPCK"))
    return {
      ext: "mpc",
      mime: "audio/x-musepack"
    };
  if (X("FORM"))
    return {
      ext: "aif",
      mime: "audio/aiff"
    };
  if (X("icns", { offset: 0 }))
    return {
      ext: "icns",
      mime: "image/icns"
    };
  if (W([80, 75, 3, 4])) {
    try {
      for (; C.position + 30 < C.fileInfo.size; ) {
        await C.readBuffer(L, { length: 30 });
        const J = {
          compressedSize: L.readUInt32LE(18),
          uncompressedSize: L.readUInt32LE(22),
          filenameLength: L.readUInt16LE(26),
          extraFieldLength: L.readUInt16LE(28)
        };
        if (J.filename = await C.readToken(new Token$s.StringType(J.filenameLength, "utf-8")), await C.ignore(J.extraFieldLength), J.filename === "META-INF/mozilla.rsa")
          return {
            ext: "xpi",
            mime: "application/x-xpinstall"
          };
        if (J.filename.endsWith(".rels") || J.filename.endsWith(".xml"))
          switch (J.filename.split("/")[0]) {
            case "_rels":
              break;
            case "word":
              return {
                ext: "docx",
                mime: "application/vnd.openxmlformats-officedocument.wordprocessingml.document"
              };
            case "ppt":
              return {
                ext: "pptx",
                mime: "application/vnd.openxmlformats-officedocument.presentationml.presentation"
              };
            case "xl":
              return {
                ext: "xlsx",
                mime: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
              };
            default:
              break;
          }
        if (J.filename.startsWith("xl/"))
          return {
            ext: "xlsx",
            mime: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
          };
        if (J.filename.startsWith("3D/") && J.filename.endsWith(".model"))
          return {
            ext: "3mf",
            mime: "model/3mf"
          };
        if (J.filename === "mimetype" && J.compressedSize === J.uncompressedSize)
          switch (await C.readToken(new Token$s.StringType(J.compressedSize, "utf-8"))) {
            case "application/epub+zip":
              return {
                ext: "epub",
                mime: "application/epub+zip"
              };
            case "application/vnd.oasis.opendocument.text":
              return {
                ext: "odt",
                mime: "application/vnd.oasis.opendocument.text"
              };
            case "application/vnd.oasis.opendocument.spreadsheet":
              return {
                ext: "ods",
                mime: "application/vnd.oasis.opendocument.spreadsheet"
              };
            case "application/vnd.oasis.opendocument.presentation":
              return {
                ext: "odp",
                mime: "application/vnd.oasis.opendocument.presentation"
              };
            default:
          }
        if (J.compressedSize === 0) {
          let te = -1;
          for (; te < 0 && C.position < C.fileInfo.size; )
            await C.peekBuffer(L, { mayBeLess: !0 }), te = L.indexOf("504B0304", 0, "hex"), await C.ignore(te >= 0 ? te : L.length);
        } else
          await C.ignore(J.compressedSize);
      }
    } catch (J) {
      if (!(J instanceof strtok3$5.EndOfStreamError))
        throw J;
    }
    return {
      ext: "zip",
      mime: "application/zip"
    };
  }
  if (X("OggS")) {
    await C.ignore(28);
    const J = Buffer.alloc(8);
    return await C.readBuffer(J), _check(J, [79, 112, 117, 115, 72, 101, 97, 100]) ? {
      ext: "opus",
      mime: "audio/opus"
    } : _check(J, [128, 116, 104, 101, 111, 114, 97]) ? {
      ext: "ogv",
      mime: "video/ogg"
    } : _check(J, [1, 118, 105, 100, 101, 111, 0]) ? {
      ext: "ogm",
      mime: "video/ogg"
    } : _check(J, [127, 70, 76, 65, 67]) ? {
      ext: "oga",
      mime: "audio/ogg"
    } : _check(J, [83, 112, 101, 101, 120, 32, 32]) ? {
      ext: "spx",
      mime: "audio/ogg"
    } : _check(J, [1, 118, 111, 114, 98, 105, 115]) ? {
      ext: "ogg",
      mime: "audio/ogg"
    } : {
      ext: "ogx",
      mime: "application/ogg"
    };
  }
  if (W([80, 75]) && (L[2] === 3 || L[2] === 5 || L[2] === 7) && (L[3] === 4 || L[3] === 6 || L[3] === 8))
    return {
      ext: "zip",
      mime: "application/zip"
    };
  if (X("ftyp", { offset: 4 }) && L[8] & 96) {
    const J = L.toString("binary", 8, 12).replace("\0", " ").trim();
    switch (J) {
      case "avif":
        return { ext: "avif", mime: "image/avif" };
      case "mif1":
        return { ext: "heic", mime: "image/heif" };
      case "msf1":
        return { ext: "heic", mime: "image/heif-sequence" };
      case "heic":
      case "heix":
        return { ext: "heic", mime: "image/heic" };
      case "hevc":
      case "hevx":
        return { ext: "heic", mime: "image/heic-sequence" };
      case "qt":
        return { ext: "mov", mime: "video/quicktime" };
      case "M4V":
      case "M4VH":
      case "M4VP":
        return { ext: "m4v", mime: "video/x-m4v" };
      case "M4P":
        return { ext: "m4p", mime: "video/mp4" };
      case "M4B":
        return { ext: "m4b", mime: "audio/mp4" };
      case "M4A":
        return { ext: "m4a", mime: "audio/x-m4a" };
      case "F4V":
        return { ext: "f4v", mime: "video/mp4" };
      case "F4P":
        return { ext: "f4p", mime: "video/mp4" };
      case "F4A":
        return { ext: "f4a", mime: "audio/mp4" };
      case "F4B":
        return { ext: "f4b", mime: "audio/mp4" };
      case "crx":
        return { ext: "cr3", mime: "image/x-canon-cr3" };
      default:
        return J.startsWith("3g") ? J.startsWith("3g2") ? { ext: "3g2", mime: "video/3gpp2" } : { ext: "3gp", mime: "video/3gpp" } : { ext: "mp4", mime: "video/mp4" };
    }
  }
  if (X("MThd"))
    return {
      ext: "mid",
      mime: "audio/midi"
    };
  if (X("wOFF") && (W([0, 1, 0, 0], { offset: 4 }) || X("OTTO", { offset: 4 })))
    return {
      ext: "woff",
      mime: "font/woff"
    };
  if (X("wOF2") && (W([0, 1, 0, 0], { offset: 4 }) || X("OTTO", { offset: 4 })))
    return {
      ext: "woff2",
      mime: "font/woff2"
    };
  if (W([212, 195, 178, 161]) || W([161, 178, 195, 212]))
    return {
      ext: "pcap",
      mime: "application/vnd.tcpdump.pcap"
    };
  if (X("DSD "))
    return {
      ext: "dsf",
      mime: "audio/x-dsf"
      // Non-standard
    };
  if (X("LZIP"))
    return {
      ext: "lz",
      mime: "application/x-lzip"
    };
  if (X("fLaC"))
    return {
      ext: "flac",
      mime: "audio/x-flac"
    };
  if (W([66, 80, 71, 251]))
    return {
      ext: "bpg",
      mime: "image/bpg"
    };
  if (X("wvpk"))
    return {
      ext: "wv",
      mime: "audio/wavpack"
    };
  if (X("%PDF")) {
    await C.ignore(1350);
    const J = 10 * 1024 * 1024, te = Buffer.alloc(Math.min(J, C.fileInfo.size));
    return await C.readBuffer(te, { mayBeLess: !0 }), te.includes(Buffer.from("AIPrivateData")) ? {
      ext: "ai",
      mime: "application/postscript"
    } : {
      ext: "pdf",
      mime: "application/pdf"
    };
  }
  if (W([0, 97, 115, 109]))
    return {
      ext: "wasm",
      mime: "application/wasm"
    };
  if (W([73, 73, 42, 0]))
    return X("CR", { offset: 8 }) ? {
      ext: "cr2",
      mime: "image/x-canon-cr2"
    } : W([28, 0, 254, 0], { offset: 8 }) || W([31, 0, 11, 0], { offset: 8 }) ? {
      ext: "nef",
      mime: "image/x-nikon-nef"
    } : W([8, 0, 0, 0], { offset: 4 }) && (W([45, 0, 254, 0], { offset: 8 }) || W([39, 0, 254, 0], { offset: 8 })) ? {
      ext: "dng",
      mime: "image/x-adobe-dng"
    } : (L = Buffer.alloc(24), await C.peekBuffer(L), (W([16, 251, 134, 1], { offset: 4 }) || W([8, 0, 0, 0], { offset: 4 })) && // This pattern differentiates ARW from other TIFF-ish file types:
    W([0, 254, 0, 4, 0, 1, 0, 0, 0, 1, 0, 0, 0, 3, 1], { offset: 9 }) ? {
      ext: "arw",
      mime: "image/x-sony-arw"
    } : {
      ext: "tif",
      mime: "image/tiff"
    });
  if (W([77, 77, 0, 42]))
    return {
      ext: "tif",
      mime: "image/tiff"
    };
  if (X("MAC "))
    return {
      ext: "ape",
      mime: "audio/ape"
    };
  if (W([26, 69, 223, 163])) {
    async function J() {
      const ce = await C.peekNumber(Token$s.UINT8);
      let ue = 128, de = 0;
      for (; !(ce & ue) && ue !== 0; )
        ++de, ue >>= 1;
      const be = Buffer.alloc(de + 1);
      return await C.readBuffer(be), be;
    }
    async function te() {
      const ce = await J(), ue = await J();
      ue[0] ^= 128 >> ue.length - 1;
      const de = Math.min(6, ue.length);
      return {
        id: ce.readUIntBE(0, ce.length),
        len: ue.readUIntBE(ue.length - de, de)
      };
    }
    async function oe(ce, ue) {
      for (; ue > 0; ) {
        const de = await te();
        if (de.id === 17026)
          return C.readToken(new Token$s.StringType(de.len, "utf-8"));
        await C.ignore(de.len), --ue;
      }
    }
    const ne = await te();
    switch (await oe(1, ne.len)) {
      case "webm":
        return {
          ext: "webm",
          mime: "video/webm"
        };
      case "matroska":
        return {
          ext: "mkv",
          mime: "video/x-matroska"
        };
      default:
        return;
    }
  }
  if (W([82, 73, 70, 70])) {
    if (W([65, 86, 73], { offset: 8 }))
      return {
        ext: "avi",
        mime: "video/vnd.avi"
      };
    if (W([87, 65, 86, 69], { offset: 8 }))
      return {
        ext: "wav",
        mime: "audio/vnd.wave"
      };
    if (W([81, 76, 67, 77], { offset: 8 }))
      return {
        ext: "qcp",
        mime: "audio/qcelp"
      };
  }
  if (X("SQLi"))
    return {
      ext: "sqlite",
      mime: "application/x-sqlite3"
    };
  if (W([78, 69, 83, 26]))
    return {
      ext: "nes",
      mime: "application/x-nintendo-nes-rom"
    };
  if (X("Cr24"))
    return {
      ext: "crx",
      mime: "application/x-google-chrome-extension"
    };
  if (X("MSCF") || X("ISc("))
    return {
      ext: "cab",
      mime: "application/vnd.ms-cab-compressed"
    };
  if (W([237, 171, 238, 219]))
    return {
      ext: "rpm",
      mime: "application/x-rpm"
    };
  if (W([197, 208, 211, 198]))
    return {
      ext: "eps",
      mime: "application/eps"
    };
  if (W([40, 181, 47, 253]))
    return {
      ext: "zst",
      mime: "application/zstd"
    };
  if (W([79, 84, 84, 79, 0]))
    return {
      ext: "otf",
      mime: "font/otf"
    };
  if (X("#!AMR"))
    return {
      ext: "amr",
      mime: "audio/amr"
    };
  if (X("{\\rtf"))
    return {
      ext: "rtf",
      mime: "application/rtf"
    };
  if (W([70, 76, 86, 1]))
    return {
      ext: "flv",
      mime: "video/x-flv"
    };
  if (X("IMPM"))
    return {
      ext: "it",
      mime: "audio/x-it"
    };
  if (X("-lh0-", { offset: 2 }) || X("-lh1-", { offset: 2 }) || X("-lh2-", { offset: 2 }) || X("-lh3-", { offset: 2 }) || X("-lh4-", { offset: 2 }) || X("-lh5-", { offset: 2 }) || X("-lh6-", { offset: 2 }) || X("-lh7-", { offset: 2 }) || X("-lzs-", { offset: 2 }) || X("-lz4-", { offset: 2 }) || X("-lz5-", { offset: 2 }) || X("-lhd-", { offset: 2 }))
    return {
      ext: "lzh",
      mime: "application/x-lzh-compressed"
    };
  if (W([0, 0, 1, 186])) {
    if (W([33], { offset: 4, mask: [241] }))
      return {
        ext: "mpg",
        // May also be .ps, .mpeg
        mime: "video/MP1S"
      };
    if (W([68], { offset: 4, mask: [196] }))
      return {
        ext: "mpg",
        // May also be .mpg, .m2p, .vob or .sub
        mime: "video/MP2P"
      };
  }
  if (X("ITSF"))
    return {
      ext: "chm",
      mime: "application/vnd.ms-htmlhelp"
    };
  if (W([253, 55, 122, 88, 90, 0]))
    return {
      ext: "xz",
      mime: "application/x-xz"
    };
  if (X("<?xml "))
    return {
      ext: "xml",
      mime: "application/xml"
    };
  if (W([55, 122, 188, 175, 39, 28]))
    return {
      ext: "7z",
      mime: "application/x-7z-compressed"
    };
  if (W([82, 97, 114, 33, 26, 7]) && (L[6] === 0 || L[6] === 1))
    return {
      ext: "rar",
      mime: "application/x-rar-compressed"
    };
  if (X("solid "))
    return {
      ext: "stl",
      mime: "model/stl"
    };
  if (X("BLENDER"))
    return {
      ext: "blend",
      mime: "application/x-blender"
    };
  if (X("!<arch>"))
    return await C.ignore(8), await C.readToken(new Token$s.StringType(13, "ascii")) === "debian-binary" ? {
      ext: "deb",
      mime: "application/x-deb"
    } : {
      ext: "ar",
      mime: "application/x-unix-archive"
    };
  if (W([137, 80, 78, 71, 13, 10, 26, 10])) {
    await C.ignore(8);
    async function J() {
      return {
        length: await C.readToken(Token$s.INT32_BE),
        type: await C.readToken(new Token$s.StringType(4, "binary"))
      };
    }
    do {
      const te = await J();
      if (te.length < 0)
        return;
      switch (te.type) {
        case "IDAT":
          return {
            ext: "png",
            mime: "image/png"
          };
        case "acTL":
          return {
            ext: "apng",
            mime: "image/apng"
          };
        default:
          await C.ignore(te.length + 4);
      }
    } while (C.position + 8 < C.fileInfo.size);
    return {
      ext: "png",
      mime: "image/png"
    };
  }
  if (W([65, 82, 82, 79, 87, 49, 0, 0]))
    return {
      ext: "arrow",
      mime: "application/x-apache-arrow"
    };
  if (W([103, 108, 84, 70, 2, 0, 0, 0]))
    return {
      ext: "glb",
      mime: "model/gltf-binary"
    };
  if (W([102, 114, 101, 101], { offset: 4 }) || // `free`
  W([109, 100, 97, 116], { offset: 4 }) || // `mdat` MJPEG
  W([109, 111, 111, 118], { offset: 4 }) || // `moov`
  W([119, 105, 100, 101], { offset: 4 }))
    return {
      ext: "mov",
      mime: "video/quicktime"
    };
  if (W([73, 73, 82, 79, 8, 0, 0, 0, 24]))
    return {
      ext: "orf",
      mime: "image/x-olympus-orf"
    };
  if (X("gimp xcf "))
    return {
      ext: "xcf",
      mime: "image/x-xcf"
    };
  if (W([73, 73, 85, 0, 24, 0, 0, 0, 136, 231, 116, 216]))
    return {
      ext: "rw2",
      mime: "image/x-panasonic-rw2"
    };
  if (W([48, 38, 178, 117, 142, 102, 207, 17, 166, 217])) {
    async function J() {
      const te = Buffer.alloc(16);
      return await C.readBuffer(te), {
        id: te,
        size: Number(await C.readToken(Token$s.UINT64_LE))
      };
    }
    for (await C.ignore(30); C.position + 24 < C.fileInfo.size; ) {
      const te = await J();
      let oe = te.size - 24;
      if (_check(te.id, [145, 7, 220, 183, 183, 169, 207, 17, 142, 230, 0, 192, 12, 32, 83, 101])) {
        const ne = Buffer.alloc(16);
        if (oe -= await C.readBuffer(ne), _check(ne, [64, 158, 105, 248, 77, 91, 207, 17, 168, 253, 0, 128, 95, 92, 68, 43]))
          return {
            ext: "asf",
            mime: "audio/x-ms-asf"
          };
        if (_check(ne, [192, 239, 25, 188, 77, 91, 207, 17, 168, 253, 0, 128, 95, 92, 68, 43]))
          return {
            ext: "asf",
            mime: "video/x-ms-asf"
          };
        break;
      }
      await C.ignore(oe);
    }
    return {
      ext: "asf",
      mime: "application/vnd.ms-asf"
    };
  }
  if (W([171, 75, 84, 88, 32, 49, 49, 187, 13, 10, 26, 10]))
    return {
      ext: "ktx",
      mime: "image/ktx"
    };
  if ((W([126, 16, 4]) || W([126, 24, 4])) && W([48, 77, 73, 69], { offset: 4 }))
    return {
      ext: "mie",
      mime: "application/x-mie"
    };
  if (W([39, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], { offset: 2 }))
    return {
      ext: "shp",
      mime: "application/x-esri-shape"
    };
  if (W([0, 0, 0, 12, 106, 80, 32, 32, 13, 10, 135, 10]))
    switch (await C.ignore(20), await C.readToken(new Token$s.StringType(4, "ascii"))) {
      case "jp2 ":
        return {
          ext: "jp2",
          mime: "image/jp2"
        };
      case "jpx ":
        return {
          ext: "jpx",
          mime: "image/jpx"
        };
      case "jpm ":
        return {
          ext: "jpm",
          mime: "image/jpm"
        };
      case "mjp2":
        return {
          ext: "mj2",
          mime: "image/mj2"
        };
      default:
        return;
    }
  if (W([255, 10]) || W([0, 0, 0, 12, 74, 88, 76, 32, 13, 10, 135, 10]))
    return {
      ext: "jxl",
      mime: "image/jxl"
    };
  if (W([0, 0, 1, 186]) || W([0, 0, 1, 179]))
    return {
      ext: "mpg",
      mime: "video/mpeg"
    };
  if (W([0, 1, 0, 0, 0]))
    return {
      ext: "ttf",
      mime: "font/ttf"
    };
  if (W([0, 0, 1, 0]))
    return {
      ext: "ico",
      mime: "image/x-icon"
    };
  if (W([0, 0, 2, 0]))
    return {
      ext: "cur",
      mime: "image/x-icon"
    };
  if (W([208, 207, 17, 224, 161, 177, 26, 225]))
    return {
      ext: "cfb",
      mime: "application/x-cfb"
    };
  if (await C.peekBuffer(L, { length: Math.min(256, C.fileInfo.size), mayBeLess: !0 }), X("BEGIN:")) {
    if (X("VCARD", { offset: 6 }))
      return {
        ext: "vcf",
        mime: "text/vcard"
      };
    if (X("VCALENDAR", { offset: 6 }))
      return {
        ext: "ics",
        mime: "text/calendar"
      };
  }
  if (X("FUJIFILMCCD-RAW"))
    return {
      ext: "raf",
      mime: "image/x-fujifilm-raf"
    };
  if (X("Extended Module:"))
    return {
      ext: "xm",
      mime: "audio/x-xm"
    };
  if (X("Creative Voice File"))
    return {
      ext: "voc",
      mime: "audio/x-voc"
    };
  if (W([4, 0, 0, 0]) && L.length >= 16) {
    const J = L.readUInt32LE(12);
    if (J > 12 && L.length >= J + 16)
      try {
        const te = L.slice(16, J + 16).toString();
        if (JSON.parse(te).files)
          return {
            ext: "asar",
            mime: "application/x-asar"
          };
      } catch {
      }
  }
  if (W([6, 14, 43, 52, 2, 5, 1, 1, 13, 1, 2, 1, 1, 2]))
    return {
      ext: "mxf",
      mime: "application/mxf"
    };
  if (X("SCRM", { offset: 44 }))
    return {
      ext: "s3m",
      mime: "audio/x-s3m"
    };
  if (W([71], { offset: 4 }) && (W([71], { offset: 192 }) || W([71], { offset: 196 })))
    return {
      ext: "mts",
      mime: "video/mp2t"
    };
  if (W([66, 79, 79, 75, 77, 79, 66, 73], { offset: 60 }))
    return {
      ext: "mobi",
      mime: "application/x-mobipocket-ebook"
    };
  if (W([68, 73, 67, 77], { offset: 128 }))
    return {
      ext: "dcm",
      mime: "application/dicom"
    };
  if (W([76, 0, 0, 0, 1, 20, 2, 0, 0, 0, 0, 0, 192, 0, 0, 0, 0, 0, 0, 70]))
    return {
      ext: "lnk",
      mime: "application/x.ms.shortcut"
      // Invented by us
    };
  if (W([98, 111, 111, 107, 0, 0, 0, 0, 109, 97, 114, 107, 0, 0, 0, 0]))
    return {
      ext: "alias",
      mime: "application/x.apple.alias"
      // Invented by us
    };
  if (W([76, 80], { offset: 34 }) && (W([0, 0, 1], { offset: 8 }) || W([1, 0, 2], { offset: 8 }) || W([2, 0, 2], { offset: 8 })))
    return {
      ext: "eot",
      mime: "application/vnd.ms-fontobject"
    };
  if (W([6, 6, 237, 245, 216, 29, 70, 229, 189, 49, 239, 231, 254, 116, 183, 29]))
    return {
      ext: "indd",
      mime: "application/x-indesign"
    };
  if (await C.peekBuffer(L, { length: Math.min(512, C.fileInfo.size), mayBeLess: !0 }), tarHeaderChecksumMatches(L))
    return {
      ext: "tar",
      mime: "application/x-tar"
    };
  if (W([255, 254, 255, 14, 83, 0, 107, 0, 101, 0, 116, 0, 99, 0, 104, 0, 85, 0, 112, 0, 32, 0, 77, 0, 111, 0, 100, 0, 101, 0, 108, 0]))
    return {
      ext: "skp",
      mime: "application/vnd.sketchup.skp"
    };
  if (X("-----BEGIN PGP MESSAGE-----"))
    return {
      ext: "pgp",
      mime: "application/pgp-encrypted"
    };
  if (L.length >= 2 && W([255, 224], { offset: 0, mask: [255, 224] })) {
    if (W([16], { offset: 1, mask: [22] }))
      return W([8], { offset: 1, mask: [8] }) ? {
        ext: "aac",
        mime: "audio/aac"
      } : {
        ext: "aac",
        mime: "audio/aac"
      };
    if (W([2], { offset: 1, mask: [6] }))
      return {
        ext: "mp3",
        mime: "audio/mpeg"
      };
    if (W([4], { offset: 1, mask: [6] }))
      return {
        ext: "mp2",
        mime: "audio/mpeg"
      };
    if (W([6], { offset: 1, mask: [6] }))
      return {
        ext: "mp1",
        mime: "audio/mpeg"
      };
  }
}
const stream = (readableStream) => new Promise((resolve, reject) => {
  const stream = eval("require")("stream");
  readableStream.on("error", reject), readableStream.once("readable", async () => {
    const C = new stream.PassThrough();
    let L;
    stream.pipeline ? L = stream.pipeline(readableStream, C, () => {
    }) : L = readableStream.pipe(C);
    const A = readableStream.read(minimumBytes) || readableStream.read() || Buffer.alloc(0);
    try {
      const W = await fromBuffer(A);
      C.fileType = W;
    } catch (W) {
      reject(W);
    }
    resolve(L);
  });
}), fileType = {
  fromStream,
  fromTokenizer,
  fromBuffer,
  stream
};
Object.defineProperty(fileType, "extensions", {
  get() {
    return new Set(supported.extensions);
  }
});
Object.defineProperty(fileType, "mimeTypes", {
  get() {
    return new Set(supported.mimeTypes);
  }
});
var core = fileType, contentType = {};
/*!
 * content-type
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var PARAM_REGEXP = /; *([!#$%&'*+.^_`|~0-9A-Za-z-]+) *= *("(?:[\u000b\u0020\u0021\u0023-\u005b\u005d-\u007e\u0080-\u00ff]|\\[\u000b\u0020-\u00ff])*"|[!#$%&'*+.^_`|~0-9A-Za-z-]+) */g, TEXT_REGEXP = /^[\u000b\u0020-\u007e\u0080-\u00ff]+$/, TOKEN_REGEXP = /^[!#$%&'*+.^_`|~0-9A-Za-z-]+$/, QESC_REGEXP = /\\([\u000b\u0020-\u00ff])/g, QUOTE_REGEXP = /([\\"])/g, TYPE_REGEXP$1 = /^[!#$%&'*+.^_`|~0-9A-Za-z-]+\/[!#$%&'*+.^_`|~0-9A-Za-z-]+$/;
contentType.format = format$1;
contentType.parse = parse$2;
function format$1(C) {
  if (!C || typeof C != "object")
    throw new TypeError("argument obj is required");
  var L = C.parameters, A = C.type;
  if (!A || !TYPE_REGEXP$1.test(A))
    throw new TypeError("invalid type");
  var W = A;
  if (L && typeof L == "object")
    for (var X, J = Object.keys(L).sort(), te = 0; te < J.length; te++) {
      if (X = J[te], !TOKEN_REGEXP.test(X))
        throw new TypeError("invalid parameter name");
      W += "; " + X + "=" + qstring(L[X]);
    }
  return W;
}
function parse$2(C) {
  if (!C)
    throw new TypeError("argument string is required");
  var L = typeof C == "object" ? getcontenttype(C) : C;
  if (typeof L != "string")
    throw new TypeError("argument string is required to be a string");
  var A = L.indexOf(";"), W = A !== -1 ? L.slice(0, A).trim() : L.trim();
  if (!TYPE_REGEXP$1.test(W))
    throw new TypeError("invalid media type");
  var X = new ContentType$1(W.toLowerCase());
  if (A !== -1) {
    var J, te, oe;
    for (PARAM_REGEXP.lastIndex = A; te = PARAM_REGEXP.exec(L); ) {
      if (te.index !== A)
        throw new TypeError("invalid parameter format");
      A += te[0].length, J = te[1].toLowerCase(), oe = te[2], oe.charCodeAt(0) === 34 && (oe = oe.slice(1, -1), oe.indexOf("\\") !== -1 && (oe = oe.replace(QESC_REGEXP, "$1"))), X.parameters[J] = oe;
    }
    if (A !== L.length)
      throw new TypeError("invalid parameter format");
  }
  return X;
}
function getcontenttype(C) {
  var L;
  if (typeof C.getHeader == "function" ? L = C.getHeader("content-type") : typeof C.headers == "object" && (L = C.headers && C.headers["content-type"]), typeof L != "string")
    throw new TypeError("content-type header is missing from object");
  return L;
}
function qstring(C) {
  var L = String(C);
  if (TOKEN_REGEXP.test(L))
    return L;
  if (L.length > 0 && !TEXT_REGEXP.test(L))
    throw new TypeError("invalid parameter value");
  return '"' + L.replace(QUOTE_REGEXP, "\\$1") + '"';
}
function ContentType$1(C) {
  this.parameters = /* @__PURE__ */ Object.create(null), this.type = C;
}
var mediaTyper = {};
/*!
 * media-typer
 * Copyright(c) 2014-2017 Douglas Christopher Wilson
 * MIT Licensed
 */
var SUBTYPE_NAME_REGEXP = /^[A-Za-z0-9][A-Za-z0-9!#$&^_.-]{0,126}$/, TYPE_NAME_REGEXP = /^[A-Za-z0-9][A-Za-z0-9!#$&^_-]{0,126}$/, TYPE_REGEXP = /^ *([A-Za-z0-9][A-Za-z0-9!#$&^_-]{0,126})\/([A-Za-z0-9][A-Za-z0-9!#$&^_.+-]{0,126}) *$/;
mediaTyper.format = format;
mediaTyper.parse = parse$1;
mediaTyper.test = test$1;
function format(C) {
  if (!C || typeof C != "object")
    throw new TypeError("argument obj is required");
  var L = C.subtype, A = C.suffix, W = C.type;
  if (!W || !TYPE_NAME_REGEXP.test(W))
    throw new TypeError("invalid type");
  if (!L || !SUBTYPE_NAME_REGEXP.test(L))
    throw new TypeError("invalid subtype");
  var X = W + "/" + L;
  if (A) {
    if (!TYPE_NAME_REGEXP.test(A))
      throw new TypeError("invalid suffix");
    X += "+" + A;
  }
  return X;
}
function test$1(C) {
  if (!C)
    throw new TypeError("argument string is required");
  if (typeof C != "string")
    throw new TypeError("argument string is required to be a string");
  return TYPE_REGEXP.test(C.toLowerCase());
}
function parse$1(C) {
  if (!C)
    throw new TypeError("argument string is required");
  if (typeof C != "string")
    throw new TypeError("argument string is required to be a string");
  var L = TYPE_REGEXP.exec(C.toLowerCase());
  if (!L)
    throw new TypeError("invalid media type");
  var A = L[1], W = L[2], X, J = W.lastIndexOf("+");
  return J !== -1 && (X = W.substr(J + 1), W = W.substr(0, J)), new MediaType(A, W, X);
}
function MediaType(C, L, A) {
  this.type = C, this.subtype = L, this.suffix = A;
}
var MetadataCollector$1 = {}, type$1 = {}, types$1 = {};
(function(C) {
  Object.defineProperty(C, "__esModule", { value: !0 }), C.TrackType = C.TargetType = C.DataType = void 0, function(L) {
    L[L.string = 0] = "string", L[L.uint = 1] = "uint", L[L.uid = 2] = "uid", L[L.bool = 3] = "bool", L[L.binary = 4] = "binary", L[L.float = 5] = "float";
  }(C.DataType || (C.DataType = {})), function(L) {
    L[L.shot = 10] = "shot", L[L.scene = 20] = "scene", L[L.track = 30] = "track", L[L.part = 40] = "part", L[L.album = 50] = "album", L[L.edition = 60] = "edition", L[L.collection = 70] = "collection";
  }(C.TargetType || (C.TargetType = {})), function(L) {
    L[L.video = 1] = "video", L[L.audio = 2] = "audio", L[L.complex = 3] = "complex", L[L.logo = 4] = "logo", L[L.subtitle = 17] = "subtitle", L[L.button = 18] = "button", L[L.control = 32] = "control";
  }(C.TrackType || (C.TrackType = {}));
})(types$1);
(function(C) {
  Object.defineProperty(C, "__esModule", { value: !0 }), C.TrackType = void 0;
  var L = types$1;
  Object.defineProperty(C, "TrackType", { enumerable: !0, get: function() {
    return L.TrackType;
  } });
})(type$1);
var GenericTagTypes = {};
(function(C) {
  Object.defineProperty(C, "__esModule", { value: !0 }), C.isUnique = C.isSingleton = C.commonTags = void 0, C.commonTags = {
    year: { multiple: !1 },
    track: { multiple: !1 },
    disk: { multiple: !1 },
    title: { multiple: !1 },
    artist: { multiple: !1 },
    artists: { multiple: !0, unique: !0 },
    albumartist: { multiple: !1 },
    album: { multiple: !1 },
    date: { multiple: !1 },
    originaldate: { multiple: !1 },
    originalyear: { multiple: !1 },
    comment: { multiple: !0, unique: !1 },
    genre: { multiple: !0, unique: !0 },
    picture: { multiple: !0, unique: !0 },
    composer: { multiple: !0, unique: !0 },
    lyrics: { multiple: !0, unique: !1 },
    albumsort: { multiple: !1, unique: !0 },
    titlesort: { multiple: !1, unique: !0 },
    work: { multiple: !1, unique: !0 },
    artistsort: { multiple: !1, unique: !0 },
    albumartistsort: { multiple: !1, unique: !0 },
    composersort: { multiple: !1, unique: !0 },
    lyricist: { multiple: !0, unique: !0 },
    writer: { multiple: !0, unique: !0 },
    conductor: { multiple: !0, unique: !0 },
    remixer: { multiple: !0, unique: !0 },
    arranger: { multiple: !0, unique: !0 },
    engineer: { multiple: !0, unique: !0 },
    producer: { multiple: !0, unique: !0 },
    technician: { multiple: !0, unique: !0 },
    djmixer: { multiple: !0, unique: !0 },
    mixer: { multiple: !0, unique: !0 },
    label: { multiple: !0, unique: !0 },
    grouping: { multiple: !1 },
    subtitle: { multiple: !0 },
    discsubtitle: { multiple: !1 },
    totaltracks: { multiple: !1 },
    totaldiscs: { multiple: !1 },
    compilation: { multiple: !1 },
    rating: { multiple: !0 },
    bpm: { multiple: !1 },
    mood: { multiple: !1 },
    media: { multiple: !1 },
    catalognumber: { multiple: !0, unique: !0 },
    tvShow: { multiple: !1 },
    tvShowSort: { multiple: !1 },
    tvSeason: { multiple: !1 },
    tvEpisode: { multiple: !1 },
    tvEpisodeId: { multiple: !1 },
    tvNetwork: { multiple: !1 },
    podcast: { multiple: !1 },
    podcasturl: { multiple: !1 },
    releasestatus: { multiple: !1 },
    releasetype: { multiple: !0 },
    releasecountry: { multiple: !1 },
    script: { multiple: !1 },
    language: { multiple: !1 },
    copyright: { multiple: !1 },
    license: { multiple: !1 },
    encodedby: { multiple: !1 },
    encodersettings: { multiple: !1 },
    gapless: { multiple: !1 },
    barcode: { multiple: !1 },
    isrc: { multiple: !0 },
    asin: { multiple: !1 },
    musicbrainz_recordingid: { multiple: !1 },
    musicbrainz_trackid: { multiple: !1 },
    musicbrainz_albumid: { multiple: !1 },
    musicbrainz_artistid: { multiple: !0 },
    musicbrainz_albumartistid: { multiple: !0 },
    musicbrainz_releasegroupid: { multiple: !1 },
    musicbrainz_workid: { multiple: !1 },
    musicbrainz_trmid: { multiple: !1 },
    musicbrainz_discid: { multiple: !1 },
    acoustid_id: { multiple: !1 },
    acoustid_fingerprint: { multiple: !1 },
    musicip_puid: { multiple: !1 },
    musicip_fingerprint: { multiple: !1 },
    website: { multiple: !1 },
    "performer:instrument": { multiple: !0, unique: !0 },
    averageLevel: { multiple: !1 },
    peakLevel: { multiple: !1 },
    notes: { multiple: !0, unique: !1 },
    key: { multiple: !1 },
    originalalbum: { multiple: !1 },
    originalartist: { multiple: !1 },
    discogs_artist_id: { multiple: !0, unique: !0 },
    discogs_release_id: { multiple: !1 },
    discogs_label_id: { multiple: !1 },
    discogs_master_release_id: { multiple: !1 },
    discogs_votes: { multiple: !1 },
    discogs_rating: { multiple: !1 },
    replaygain_track_peak: { multiple: !1 },
    replaygain_track_gain: { multiple: !1 },
    replaygain_album_peak: { multiple: !1 },
    replaygain_album_gain: { multiple: !1 },
    replaygain_track_minmax: { multiple: !1 },
    replaygain_album_minmax: { multiple: !1 },
    replaygain_undo: { multiple: !1 },
    description: { multiple: !0 },
    longDescription: { multiple: !1 },
    category: { multiple: !0 },
    hdVideo: { multiple: !1 },
    keywords: { multiple: !0 },
    movement: { multiple: !1 },
    movementIndex: { multiple: !1 },
    movementTotal: { multiple: !1 },
    podcastId: { multiple: !1 },
    showMovement: { multiple: !1 },
    stik: { multiple: !1 }
  };
  function L(W) {
    return C.commonTags.hasOwnProperty(W) && !C.commonTags[W].multiple;
  }
  C.isSingleton = L;
  function A(W) {
    return !C.commonTags[W].multiple || C.commonTags[W].unique;
  }
  C.isUnique = A;
})(GenericTagTypes);
var CombinedTagMapper$1 = {}, ID3v1TagMap = {}, GenericTagMapper = {};
Object.defineProperty(GenericTagMapper, "__esModule", { value: !0 });
GenericTagMapper.CommonTagMapper = void 0;
class CommonTagMapper {
  static toIntOrNull(L) {
    const A = parseInt(L, 10);
    return isNaN(A) ? null : A;
  }
  // TODO: a string of 1of1 would fail to be converted
  // converts 1/10 to no : 1, of : 10
  // or 1 to no : 1, of : 0
  static normalizeTrack(L) {
    const A = L.toString().split("/");
    return {
      no: parseInt(A[0], 10) || null,
      of: parseInt(A[1], 10) || null
    };
  }
  constructor(L, A) {
    this.tagTypes = L, this.tagMap = A;
  }
  /**
   * Process and set common tags
   * write common tags to
   * @param tag Native tag
   * @param warnings Register warnings
   * @return common name
   */
  mapGenericTag(L, A) {
    L = { id: L.id, value: L.value }, this.postMap(L, A);
    const W = this.getCommonName(L.id);
    return W ? { id: W, value: L.value } : null;
  }
  /**
   * Convert native tag key to common tag key
   * @tag  Native header tag
   * @return common tag name (alias)
   */
  getCommonName(L) {
    return this.tagMap[L];
  }
  /**
   * Handle post mapping exceptions / correction
   * @param tag Tag e.g. {"©alb", "Buena Vista Social Club")
   * @param warnings Used to register warnings
   */
  postMap(L, A) {
  }
}
CommonTagMapper.maxRatingScore = 1;
GenericTagMapper.CommonTagMapper = CommonTagMapper;
Object.defineProperty(ID3v1TagMap, "__esModule", { value: !0 });
ID3v1TagMap.ID3v1TagMapper = void 0;
const GenericTagMapper_1$6 = GenericTagMapper, id3v1TagMap = {
  title: "title",
  artist: "artist",
  album: "album",
  year: "year",
  comment: "comment",
  track: "track",
  genre: "genre"
};
class ID3v1TagMapper extends GenericTagMapper_1$6.CommonTagMapper {
  constructor() {
    super(["ID3v1"], id3v1TagMap);
  }
}
ID3v1TagMap.ID3v1TagMapper = ID3v1TagMapper;
var ID3v24TagMapper$1 = {}, CaseInsensitiveTagMap$1 = {};
Object.defineProperty(CaseInsensitiveTagMap$1, "__esModule", { value: !0 });
CaseInsensitiveTagMap$1.CaseInsensitiveTagMap = void 0;
const GenericTagMapper_1$5 = GenericTagMapper;
class CaseInsensitiveTagMap extends GenericTagMapper_1$5.CommonTagMapper {
  constructor(L, A) {
    const W = {};
    for (const X of Object.keys(A))
      W[X.toUpperCase()] = A[X];
    super(L, W);
  }
  /**
   * @tag  Native header tag
   * @return common tag name (alias)
   */
  getCommonName(L) {
    return this.tagMap[L.toUpperCase()];
  }
}
CaseInsensitiveTagMap$1.CaseInsensitiveTagMap = CaseInsensitiveTagMap;
var Util = {};
Object.defineProperty(Util, "__esModule", { value: !0 });
Util.toRatio = Util.dbToRatio = Util.ratioToDb = Util.a2hex = Util.isBitSet = Util.getBitAllignedNumber = Util.stripNulls = Util.decodeString = Util.trimRightNull = Util.findZero = Util.getBit = void 0;
function getBit(C, L, A) {
  return (C[L] & 1 << A) !== 0;
}
Util.getBit = getBit;
function findZero(C, L, A, W) {
  let X = L;
  if (W === "utf16le") {
    for (; C[X] !== 0 || C[X + 1] !== 0; ) {
      if (X >= A)
        return A;
      X += 2;
    }
    return X;
  } else {
    for (; C[X] !== 0; ) {
      if (X >= A)
        return A;
      X++;
    }
    return X;
  }
}
Util.findZero = findZero;
function trimRightNull(C) {
  const L = C.indexOf("\0");
  return L === -1 ? C : C.substr(0, L);
}
Util.trimRightNull = trimRightNull;
function swapBytes(C) {
  const L = C.length;
  if (L & 1)
    throw new Error("Buffer length must be even");
  for (let A = 0; A < L; A += 2) {
    const W = C[A];
    C[A] = C[A + 1], C[A + 1] = W;
  }
  return C;
}
function decodeString(C, L) {
  if (C[0] === 255 && C[1] === 254)
    return decodeString(C.subarray(2), L);
  if (L === "utf16le" && C[0] === 254 && C[1] === 255) {
    if (C.length & 1)
      throw new Error("Expected even number of octets for 16-bit unicode string");
    return decodeString(swapBytes(C), L);
  }
  return Buffer.from(C).toString(L);
}
Util.decodeString = decodeString;
function stripNulls(C) {
  return C = C.replace(/^\x00+/g, ""), C = C.replace(/\x00+$/g, ""), C;
}
Util.stripNulls = stripNulls;
function getBitAllignedNumber(C, L, A, W) {
  const X = L + ~~(A / 8), J = A % 8;
  let te = C[X];
  te &= 255 >> J;
  const oe = 8 - J, ne = W - oe;
  return ne < 0 ? te >>= 8 - J - W : ne > 0 && (te <<= ne, te |= getBitAllignedNumber(C, L, A + oe, ne)), te;
}
Util.getBitAllignedNumber = getBitAllignedNumber;
function isBitSet(C, L, A) {
  return getBitAllignedNumber(C, L, A, 1) === 1;
}
Util.isBitSet = isBitSet;
function a2hex(C) {
  const L = [];
  for (let A = 0, W = C.length; A < W; A++) {
    const X = Number(C.charCodeAt(A)).toString(16);
    L.push(X.length === 1 ? "0" + X : X);
  }
  return L.join(" ");
}
Util.a2hex = a2hex;
function ratioToDb(C) {
  return 10 * Math.log10(C);
}
Util.ratioToDb = ratioToDb;
function dbToRatio(C) {
  return Math.pow(10, C / 10);
}
Util.dbToRatio = dbToRatio;
function toRatio(C) {
  const L = C.split(" ").map((A) => A.trim().toLowerCase());
  if (L.length >= 1) {
    const A = parseFloat(L[0]);
    return L.length === 2 && L[1] === "db" ? {
      dB: A,
      ratio: dbToRatio(A)
    } : {
      dB: ratioToDb(A),
      ratio: A
    };
  }
}
Util.toRatio = toRatio;
Object.defineProperty(ID3v24TagMapper$1, "__esModule", { value: !0 });
ID3v24TagMapper$1.ID3v24TagMapper = void 0;
const GenericTagMapper_1$4 = GenericTagMapper, CaseInsensitiveTagMap_1$2 = CaseInsensitiveTagMap$1, util$b = Util, id3v24TagMap = {
  // id3v2.3
  TIT2: "title",
  TPE1: "artist",
  "TXXX:Artists": "artists",
  TPE2: "albumartist",
  TALB: "album",
  TDRV: "date",
  /**
   * Original release year
   */
  TORY: "originalyear",
  TPOS: "disk",
  TCON: "genre",
  APIC: "picture",
  TCOM: "composer",
  "USLT:description": "lyrics",
  TSOA: "albumsort",
  TSOT: "titlesort",
  TOAL: "originalalbum",
  TSOP: "artistsort",
  TSO2: "albumartistsort",
  TSOC: "composersort",
  TEXT: "lyricist",
  "TXXX:Writer": "writer",
  TPE3: "conductor",
  // 'IPLS:instrument': 'performer:instrument', // ToDo
  TPE4: "remixer",
  "IPLS:arranger": "arranger",
  "IPLS:engineer": "engineer",
  "IPLS:producer": "producer",
  "IPLS:DJ-mix": "djmixer",
  "IPLS:mix": "mixer",
  TPUB: "label",
  TIT1: "grouping",
  TIT3: "subtitle",
  TRCK: "track",
  TCMP: "compilation",
  POPM: "rating",
  TBPM: "bpm",
  TMED: "media",
  "TXXX:CATALOGNUMBER": "catalognumber",
  "TXXX:MusicBrainz Album Status": "releasestatus",
  "TXXX:MusicBrainz Album Type": "releasetype",
  /**
   * Release country as documented: https://picard.musicbrainz.org/docs/mappings/#cite_note-0
   */
  "TXXX:MusicBrainz Album Release Country": "releasecountry",
  /**
   * Release country as implemented // ToDo: report
   */
  "TXXX:RELEASECOUNTRY": "releasecountry",
  "TXXX:SCRIPT": "script",
  TLAN: "language",
  TCOP: "copyright",
  WCOP: "license",
  TENC: "encodedby",
  TSSE: "encodersettings",
  "TXXX:BARCODE": "barcode",
  "TXXX:ISRC": "isrc",
  TSRC: "isrc",
  "TXXX:ASIN": "asin",
  "TXXX:originalyear": "originalyear",
  "UFID:http://musicbrainz.org": "musicbrainz_recordingid",
  "TXXX:MusicBrainz Release Track Id": "musicbrainz_trackid",
  "TXXX:MusicBrainz Album Id": "musicbrainz_albumid",
  "TXXX:MusicBrainz Artist Id": "musicbrainz_artistid",
  "TXXX:MusicBrainz Album Artist Id": "musicbrainz_albumartistid",
  "TXXX:MusicBrainz Release Group Id": "musicbrainz_releasegroupid",
  "TXXX:MusicBrainz Work Id": "musicbrainz_workid",
  "TXXX:MusicBrainz TRM Id": "musicbrainz_trmid",
  "TXXX:MusicBrainz Disc Id": "musicbrainz_discid",
  "TXXX:ACOUSTID_ID": "acoustid_id",
  "TXXX:Acoustid Id": "acoustid_id",
  "TXXX:Acoustid Fingerprint": "acoustid_fingerprint",
  "TXXX:MusicIP PUID": "musicip_puid",
  "TXXX:MusicMagic Fingerprint": "musicip_fingerprint",
  WOAR: "website",
  // id3v2.4
  // ToDo: In same sequence as defined at http://id3.org/id3v2.4.0-frames
  TDRC: "date",
  TYER: "year",
  TDOR: "originaldate",
  // 'TMCL:instrument': 'performer:instrument',
  "TIPL:arranger": "arranger",
  "TIPL:engineer": "engineer",
  "TIPL:producer": "producer",
  "TIPL:DJ-mix": "djmixer",
  "TIPL:mix": "mixer",
  TMOO: "mood",
  // additional mappings:
  SYLT: "lyrics",
  TSST: "discsubtitle",
  TKEY: "key",
  COMM: "comment",
  TOPE: "originalartist",
  // Windows Media Player
  "PRIV:AverageLevel": "averageLevel",
  "PRIV:PeakLevel": "peakLevel",
  // Discogs
  "TXXX:DISCOGS_ARTIST_ID": "discogs_artist_id",
  "TXXX:DISCOGS_ARTISTS": "artists",
  "TXXX:DISCOGS_ARTIST_NAME": "artists",
  "TXXX:DISCOGS_ALBUM_ARTISTS": "albumartist",
  "TXXX:DISCOGS_CATALOG": "catalognumber",
  "TXXX:DISCOGS_COUNTRY": "releasecountry",
  "TXXX:DISCOGS_DATE": "originaldate",
  "TXXX:DISCOGS_LABEL": "label",
  "TXXX:DISCOGS_LABEL_ID": "discogs_label_id",
  "TXXX:DISCOGS_MASTER_RELEASE_ID": "discogs_master_release_id",
  "TXXX:DISCOGS_RATING": "discogs_rating",
  "TXXX:DISCOGS_RELEASED": "date",
  "TXXX:DISCOGS_RELEASE_ID": "discogs_release_id",
  "TXXX:DISCOGS_VOTES": "discogs_votes",
  "TXXX:CATALOGID": "catalognumber",
  "TXXX:STYLE": "genre",
  "TXXX:REPLAYGAIN_TRACK_PEAK": "replaygain_track_peak",
  "TXXX:REPLAYGAIN_TRACK_GAIN": "replaygain_track_gain",
  "TXXX:REPLAYGAIN_ALBUM_PEAK": "replaygain_album_peak",
  "TXXX:REPLAYGAIN_ALBUM_GAIN": "replaygain_album_gain",
  "TXXX:MP3GAIN_MINMAX": "replaygain_track_minmax",
  "TXXX:MP3GAIN_ALBUM_MINMAX": "replaygain_album_minmax",
  "TXXX:MP3GAIN_UNDO": "replaygain_undo",
  MVNM: "movement",
  MVIN: "movementIndex",
  PCST: "podcast",
  TCAT: "category",
  TDES: "description",
  TDRL: "date",
  TGID: "podcastId",
  TKWD: "keywords",
  WFED: "podcasturl"
};
class ID3v24TagMapper extends CaseInsensitiveTagMap_1$2.CaseInsensitiveTagMap {
  static toRating(L) {
    return {
      source: L.email,
      rating: L.rating > 0 ? (L.rating - 1) / 254 * GenericTagMapper_1$4.CommonTagMapper.maxRatingScore : void 0
    };
  }
  constructor() {
    super(["ID3v2.3", "ID3v2.4"], id3v24TagMap);
  }
  /**
   * Handle post mapping exceptions / correction
   * @param tag to post map
   * @param warnings Wil be used to register (collect) warnings
   * @return Common value e.g. "Buena Vista Social Club"
   */
  postMap(L, A) {
    switch (L.id) {
      case "UFID":
        L.value.owner_identifier === "http://musicbrainz.org" && (L.id += ":" + L.value.owner_identifier, L.value = util$b.decodeString(L.value.identifier, "latin1"));
        break;
      case "PRIV":
        switch (L.value.owner_identifier) {
          case "AverageLevel":
          case "PeakValue":
            L.id += ":" + L.value.owner_identifier, L.value = L.value.data.length === 4 ? L.value.data.readUInt32LE(0) : null, L.value === null && A.addWarning("Failed to parse PRIV:PeakValue");
            break;
          default:
            A.addWarning(`Unknown PRIV owner-identifier: ${L.value.owner_identifier}`);
        }
        break;
      case "COMM":
        L.value = L.value ? L.value.text : null;
        break;
      case "POPM":
        L.value = ID3v24TagMapper.toRating(L.value);
        break;
    }
  }
}
ID3v24TagMapper$1.ID3v24TagMapper = ID3v24TagMapper;
var AsfTagMapper$1 = {};
Object.defineProperty(AsfTagMapper$1, "__esModule", { value: !0 });
AsfTagMapper$1.AsfTagMapper = void 0;
const GenericTagMapper_1$3 = GenericTagMapper, asfTagMap = {
  Title: "title",
  Author: "artist",
  "WM/AlbumArtist": "albumartist",
  "WM/AlbumTitle": "album",
  "WM/Year": "date",
  "WM/OriginalReleaseTime": "originaldate",
  "WM/OriginalReleaseYear": "originalyear",
  Description: "comment",
  "WM/TrackNumber": "track",
  "WM/PartOfSet": "disk",
  "WM/Genre": "genre",
  "WM/Composer": "composer",
  "WM/Lyrics": "lyrics",
  "WM/AlbumSortOrder": "albumsort",
  "WM/TitleSortOrder": "titlesort",
  "WM/ArtistSortOrder": "artistsort",
  "WM/AlbumArtistSortOrder": "albumartistsort",
  "WM/ComposerSortOrder": "composersort",
  "WM/Writer": "lyricist",
  "WM/Conductor": "conductor",
  "WM/ModifiedBy": "remixer",
  "WM/Engineer": "engineer",
  "WM/Producer": "producer",
  "WM/DJMixer": "djmixer",
  "WM/Mixer": "mixer",
  "WM/Publisher": "label",
  "WM/ContentGroupDescription": "grouping",
  "WM/SubTitle": "subtitle",
  "WM/SetSubTitle": "discsubtitle",
  // 'WM/PartOfSet': 'totaldiscs',
  "WM/IsCompilation": "compilation",
  "WM/SharedUserRating": "rating",
  "WM/BeatsPerMinute": "bpm",
  "WM/Mood": "mood",
  "WM/Media": "media",
  "WM/CatalogNo": "catalognumber",
  "MusicBrainz/Album Status": "releasestatus",
  "MusicBrainz/Album Type": "releasetype",
  "MusicBrainz/Album Release Country": "releasecountry",
  "WM/Script": "script",
  "WM/Language": "language",
  Copyright: "copyright",
  LICENSE: "license",
  "WM/EncodedBy": "encodedby",
  "WM/EncodingSettings": "encodersettings",
  "WM/Barcode": "barcode",
  "WM/ISRC": "isrc",
  "MusicBrainz/Track Id": "musicbrainz_recordingid",
  "MusicBrainz/Release Track Id": "musicbrainz_trackid",
  "MusicBrainz/Album Id": "musicbrainz_albumid",
  "MusicBrainz/Artist Id": "musicbrainz_artistid",
  "MusicBrainz/Album Artist Id": "musicbrainz_albumartistid",
  "MusicBrainz/Release Group Id": "musicbrainz_releasegroupid",
  "MusicBrainz/Work Id": "musicbrainz_workid",
  "MusicBrainz/TRM Id": "musicbrainz_trmid",
  "MusicBrainz/Disc Id": "musicbrainz_discid",
  "Acoustid/Id": "acoustid_id",
  "Acoustid/Fingerprint": "acoustid_fingerprint",
  "MusicIP/PUID": "musicip_puid",
  "WM/ARTISTS": "artists",
  "WM/InitialKey": "key",
  ASIN: "asin",
  "WM/Work": "work",
  "WM/AuthorURL": "website",
  "WM/Picture": "picture"
};
class AsfTagMapper extends GenericTagMapper_1$3.CommonTagMapper {
  static toRating(L) {
    return {
      rating: parseFloat(L + 1) / 5
    };
  }
  constructor() {
    super(["asf"], asfTagMap);
  }
  postMap(L) {
    switch (L.id) {
      case "WM/SharedUserRating":
        const A = L.id.split(":");
        L.value = AsfTagMapper.toRating(L.value), L.id = A[0];
        break;
    }
  }
}
AsfTagMapper$1.AsfTagMapper = AsfTagMapper;
var ID3v22TagMapper = {};
(function(C) {
  Object.defineProperty(C, "__esModule", { value: !0 }), C.ID3v22TagMapper = C.id3v22TagMap = void 0;
  const L = CaseInsensitiveTagMap$1;
  C.id3v22TagMap = {
    TT2: "title",
    TP1: "artist",
    TP2: "albumartist",
    TAL: "album",
    TYE: "year",
    COM: "comment",
    TRK: "track",
    TPA: "disk",
    TCO: "genre",
    PIC: "picture",
    TCM: "composer",
    TOR: "originaldate",
    TOT: "originalalbum",
    TXT: "lyricist",
    TP3: "conductor",
    TPB: "label",
    TT1: "grouping",
    TT3: "subtitle",
    TLA: "language",
    TCR: "copyright",
    WCP: "license",
    TEN: "encodedby",
    TSS: "encodersettings",
    WAR: "website",
    "COM:iTunPGAP": "gapless",
    PCS: "podcast",
    TCP: "compilation",
    TDR: "date",
    TS2: "albumartistsort",
    TSA: "albumsort",
    TSC: "composersort",
    TSP: "artistsort",
    TST: "titlesort",
    WFD: "podcasturl",
    TBP: "bpm"
  };
  class A extends L.CaseInsensitiveTagMap {
    constructor() {
      super(["ID3v2.2"], C.id3v22TagMap);
    }
  }
  C.ID3v22TagMapper = A;
})(ID3v22TagMapper);
var APEv2TagMapper$1 = {};
Object.defineProperty(APEv2TagMapper$1, "__esModule", { value: !0 });
APEv2TagMapper$1.APEv2TagMapper = void 0;
const CaseInsensitiveTagMap_1$1 = CaseInsensitiveTagMap$1, apev2TagMap = {
  Title: "title",
  Artist: "artist",
  Artists: "artists",
  "Album Artist": "albumartist",
  Album: "album",
  Year: "date",
  Originalyear: "originalyear",
  Originaldate: "originaldate",
  Comment: "comment",
  Track: "track",
  Disc: "disk",
  DISCNUMBER: "disk",
  Genre: "genre",
  "Cover Art (Front)": "picture",
  "Cover Art (Back)": "picture",
  Composer: "composer",
  Lyrics: "lyrics",
  ALBUMSORT: "albumsort",
  TITLESORT: "titlesort",
  WORK: "work",
  ARTISTSORT: "artistsort",
  ALBUMARTISTSORT: "albumartistsort",
  COMPOSERSORT: "composersort",
  Lyricist: "lyricist",
  Writer: "writer",
  Conductor: "conductor",
  // 'Performer=artist (instrument)': 'performer:instrument',
  MixArtist: "remixer",
  Arranger: "arranger",
  Engineer: "engineer",
  Producer: "producer",
  DJMixer: "djmixer",
  Mixer: "mixer",
  Label: "label",
  Grouping: "grouping",
  Subtitle: "subtitle",
  DiscSubtitle: "discsubtitle",
  Compilation: "compilation",
  BPM: "bpm",
  Mood: "mood",
  Media: "media",
  CatalogNumber: "catalognumber",
  MUSICBRAINZ_ALBUMSTATUS: "releasestatus",
  MUSICBRAINZ_ALBUMTYPE: "releasetype",
  RELEASECOUNTRY: "releasecountry",
  Script: "script",
  Language: "language",
  Copyright: "copyright",
  LICENSE: "license",
  EncodedBy: "encodedby",
  EncoderSettings: "encodersettings",
  Barcode: "barcode",
  ISRC: "isrc",
  ASIN: "asin",
  musicbrainz_trackid: "musicbrainz_recordingid",
  musicbrainz_releasetrackid: "musicbrainz_trackid",
  MUSICBRAINZ_ALBUMID: "musicbrainz_albumid",
  MUSICBRAINZ_ARTISTID: "musicbrainz_artistid",
  MUSICBRAINZ_ALBUMARTISTID: "musicbrainz_albumartistid",
  MUSICBRAINZ_RELEASEGROUPID: "musicbrainz_releasegroupid",
  MUSICBRAINZ_WORKID: "musicbrainz_workid",
  MUSICBRAINZ_TRMID: "musicbrainz_trmid",
  MUSICBRAINZ_DISCID: "musicbrainz_discid",
  Acoustid_Id: "acoustid_id",
  ACOUSTID_FINGERPRINT: "acoustid_fingerprint",
  MUSICIP_PUID: "musicip_puid",
  Weblink: "website",
  REPLAYGAIN_TRACK_GAIN: "replaygain_track_gain",
  REPLAYGAIN_TRACK_PEAK: "replaygain_track_peak",
  MP3GAIN_MINMAX: "replaygain_track_minmax",
  MP3GAIN_UNDO: "replaygain_undo"
};
class APEv2TagMapper extends CaseInsensitiveTagMap_1$1.CaseInsensitiveTagMap {
  constructor() {
    super(["APEv2"], apev2TagMap);
  }
}
APEv2TagMapper$1.APEv2TagMapper = APEv2TagMapper;
var MP4TagMapper = {};
(function(C) {
  Object.defineProperty(C, "__esModule", { value: !0 }), C.MP4TagMapper = C.tagType = void 0;
  const L = CaseInsensitiveTagMap$1, A = {
    "©nam": "title",
    "©ART": "artist",
    aART: "albumartist",
    /**
     * ToDo: Album artist seems to be stored here while Picard documentation says: aART
     */
    "----:com.apple.iTunes:Band": "albumartist",
    "©alb": "album",
    "©day": "date",
    "©cmt": "comment",
    "©com": "comment",
    trkn: "track",
    disk: "disk",
    "©gen": "genre",
    covr: "picture",
    "©wrt": "composer",
    "©lyr": "lyrics",
    soal: "albumsort",
    sonm: "titlesort",
    soar: "artistsort",
    soaa: "albumartistsort",
    soco: "composersort",
    "----:com.apple.iTunes:LYRICIST": "lyricist",
    "----:com.apple.iTunes:CONDUCTOR": "conductor",
    "----:com.apple.iTunes:REMIXER": "remixer",
    "----:com.apple.iTunes:ENGINEER": "engineer",
    "----:com.apple.iTunes:PRODUCER": "producer",
    "----:com.apple.iTunes:DJMIXER": "djmixer",
    "----:com.apple.iTunes:MIXER": "mixer",
    "----:com.apple.iTunes:LABEL": "label",
    "©grp": "grouping",
    "----:com.apple.iTunes:SUBTITLE": "subtitle",
    "----:com.apple.iTunes:DISCSUBTITLE": "discsubtitle",
    cpil: "compilation",
    tmpo: "bpm",
    "----:com.apple.iTunes:MOOD": "mood",
    "----:com.apple.iTunes:MEDIA": "media",
    "----:com.apple.iTunes:CATALOGNUMBER": "catalognumber",
    tvsh: "tvShow",
    tvsn: "tvSeason",
    tves: "tvEpisode",
    sosn: "tvShowSort",
    tven: "tvEpisodeId",
    tvnn: "tvNetwork",
    pcst: "podcast",
    purl: "podcasturl",
    "----:com.apple.iTunes:MusicBrainz Album Status": "releasestatus",
    "----:com.apple.iTunes:MusicBrainz Album Type": "releasetype",
    "----:com.apple.iTunes:MusicBrainz Album Release Country": "releasecountry",
    "----:com.apple.iTunes:SCRIPT": "script",
    "----:com.apple.iTunes:LANGUAGE": "language",
    cprt: "copyright",
    "©cpy": "copyright",
    "----:com.apple.iTunes:LICENSE": "license",
    "©too": "encodedby",
    pgap: "gapless",
    "----:com.apple.iTunes:BARCODE": "barcode",
    "----:com.apple.iTunes:ISRC": "isrc",
    "----:com.apple.iTunes:ASIN": "asin",
    "----:com.apple.iTunes:NOTES": "comment",
    "----:com.apple.iTunes:MusicBrainz Track Id": "musicbrainz_recordingid",
    "----:com.apple.iTunes:MusicBrainz Release Track Id": "musicbrainz_trackid",
    "----:com.apple.iTunes:MusicBrainz Album Id": "musicbrainz_albumid",
    "----:com.apple.iTunes:MusicBrainz Artist Id": "musicbrainz_artistid",
    "----:com.apple.iTunes:MusicBrainz Album Artist Id": "musicbrainz_albumartistid",
    "----:com.apple.iTunes:MusicBrainz Release Group Id": "musicbrainz_releasegroupid",
    "----:com.apple.iTunes:MusicBrainz Work Id": "musicbrainz_workid",
    "----:com.apple.iTunes:MusicBrainz TRM Id": "musicbrainz_trmid",
    "----:com.apple.iTunes:MusicBrainz Disc Id": "musicbrainz_discid",
    "----:com.apple.iTunes:Acoustid Id": "acoustid_id",
    "----:com.apple.iTunes:Acoustid Fingerprint": "acoustid_fingerprint",
    "----:com.apple.iTunes:MusicIP PUID": "musicip_puid",
    "----:com.apple.iTunes:fingerprint": "musicip_fingerprint",
    "----:com.apple.iTunes:replaygain_track_gain": "replaygain_track_gain",
    "----:com.apple.iTunes:replaygain_track_peak": "replaygain_track_peak",
    "----:com.apple.iTunes:replaygain_album_gain": "replaygain_album_gain",
    "----:com.apple.iTunes:replaygain_album_peak": "replaygain_album_peak",
    "----:com.apple.iTunes:replaygain_track_minmax": "replaygain_track_minmax",
    "----:com.apple.iTunes:replaygain_album_minmax": "replaygain_album_minmax",
    "----:com.apple.iTunes:replaygain_undo": "replaygain_undo",
    // Additional mappings:
    gnre: "genre",
    "----:com.apple.iTunes:ALBUMARTISTSORT": "albumartistsort",
    "----:com.apple.iTunes:ARTISTS": "artists",
    "----:com.apple.iTunes:ORIGINALDATE": "originaldate",
    "----:com.apple.iTunes:ORIGINALYEAR": "originalyear",
    // '----:com.apple.iTunes:PERFORMER': 'performer'
    desc: "description",
    ldes: "longDescription",
    "©mvn": "movement",
    "©mvi": "movementIndex",
    "©mvc": "movementTotal",
    "©wrk": "work",
    catg: "category",
    egid: "podcastId",
    hdvd: "hdVideo",
    keyw: "keywords",
    shwm: "showMovement",
    stik: "stik",
    rate: "rating"
  };
  C.tagType = "iTunes";
  class W extends L.CaseInsensitiveTagMap {
    constructor() {
      super([C.tagType], A);
    }
    postMap(J, te) {
      switch (J.id) {
        case "rate":
          J.value = {
            source: void 0,
            rating: parseFloat(J.value) / 100
          };
          break;
      }
    }
  }
  C.MP4TagMapper = W;
})(MP4TagMapper);
var VorbisTagMapper$1 = {};
Object.defineProperty(VorbisTagMapper$1, "__esModule", { value: !0 });
VorbisTagMapper$1.VorbisTagMapper = void 0;
const GenericTagMapper_1$2 = GenericTagMapper, vorbisTagMap = {
  TITLE: "title",
  ARTIST: "artist",
  ARTISTS: "artists",
  ALBUMARTIST: "albumartist",
  "ALBUM ARTIST": "albumartist",
  ALBUM: "album",
  DATE: "date",
  ORIGINALDATE: "originaldate",
  ORIGINALYEAR: "originalyear",
  COMMENT: "comment",
  TRACKNUMBER: "track",
  DISCNUMBER: "disk",
  GENRE: "genre",
  METADATA_BLOCK_PICTURE: "picture",
  COMPOSER: "composer",
  LYRICS: "lyrics",
  ALBUMSORT: "albumsort",
  TITLESORT: "titlesort",
  WORK: "work",
  ARTISTSORT: "artistsort",
  ALBUMARTISTSORT: "albumartistsort",
  COMPOSERSORT: "composersort",
  LYRICIST: "lyricist",
  WRITER: "writer",
  CONDUCTOR: "conductor",
  // 'PERFORMER=artist (instrument)': 'performer:instrument', // ToDo
  REMIXER: "remixer",
  ARRANGER: "arranger",
  ENGINEER: "engineer",
  PRODUCER: "producer",
  DJMIXER: "djmixer",
  MIXER: "mixer",
  LABEL: "label",
  GROUPING: "grouping",
  SUBTITLE: "subtitle",
  DISCSUBTITLE: "discsubtitle",
  TRACKTOTAL: "totaltracks",
  DISCTOTAL: "totaldiscs",
  COMPILATION: "compilation",
  RATING: "rating",
  BPM: "bpm",
  KEY: "key",
  MOOD: "mood",
  MEDIA: "media",
  CATALOGNUMBER: "catalognumber",
  RELEASESTATUS: "releasestatus",
  RELEASETYPE: "releasetype",
  RELEASECOUNTRY: "releasecountry",
  SCRIPT: "script",
  LANGUAGE: "language",
  COPYRIGHT: "copyright",
  LICENSE: "license",
  ENCODEDBY: "encodedby",
  ENCODERSETTINGS: "encodersettings",
  BARCODE: "barcode",
  ISRC: "isrc",
  ASIN: "asin",
  MUSICBRAINZ_TRACKID: "musicbrainz_recordingid",
  MUSICBRAINZ_RELEASETRACKID: "musicbrainz_trackid",
  MUSICBRAINZ_ALBUMID: "musicbrainz_albumid",
  MUSICBRAINZ_ARTISTID: "musicbrainz_artistid",
  MUSICBRAINZ_ALBUMARTISTID: "musicbrainz_albumartistid",
  MUSICBRAINZ_RELEASEGROUPID: "musicbrainz_releasegroupid",
  MUSICBRAINZ_WORKID: "musicbrainz_workid",
  MUSICBRAINZ_TRMID: "musicbrainz_trmid",
  MUSICBRAINZ_DISCID: "musicbrainz_discid",
  ACOUSTID_ID: "acoustid_id",
  ACOUSTID_ID_FINGERPRINT: "acoustid_fingerprint",
  MUSICIP_PUID: "musicip_puid",
  // 'FINGERPRINT=MusicMagic Fingerprint {fingerprint}': 'musicip_fingerprint', // ToDo
  WEBSITE: "website",
  NOTES: "notes",
  TOTALTRACKS: "totaltracks",
  TOTALDISCS: "totaldiscs",
  // Discogs
  DISCOGS_ARTIST_ID: "discogs_artist_id",
  DISCOGS_ARTISTS: "artists",
  DISCOGS_ARTIST_NAME: "artists",
  DISCOGS_ALBUM_ARTISTS: "albumartist",
  DISCOGS_CATALOG: "catalognumber",
  DISCOGS_COUNTRY: "releasecountry",
  DISCOGS_DATE: "originaldate",
  DISCOGS_LABEL: "label",
  DISCOGS_LABEL_ID: "discogs_label_id",
  DISCOGS_MASTER_RELEASE_ID: "discogs_master_release_id",
  DISCOGS_RATING: "discogs_rating",
  DISCOGS_RELEASED: "date",
  DISCOGS_RELEASE_ID: "discogs_release_id",
  DISCOGS_VOTES: "discogs_votes",
  CATALOGID: "catalognumber",
  STYLE: "genre",
  //
  REPLAYGAIN_TRACK_GAIN: "replaygain_track_gain",
  REPLAYGAIN_TRACK_PEAK: "replaygain_track_peak",
  REPLAYGAIN_ALBUM_GAIN: "replaygain_album_gain",
  REPLAYGAIN_ALBUM_PEAK: "replaygain_album_peak",
  // To Sure if these (REPLAYGAIN_MINMAX, REPLAYGAIN_ALBUM_MINMAX & REPLAYGAIN_UNDO) are used for Vorbis:
  REPLAYGAIN_MINMAX: "replaygain_track_minmax",
  REPLAYGAIN_ALBUM_MINMAX: "replaygain_album_minmax",
  REPLAYGAIN_UNDO: "replaygain_undo"
};
class VorbisTagMapper extends GenericTagMapper_1$2.CommonTagMapper {
  static toRating(L, A, W) {
    return {
      source: L && L.toLowerCase(),
      rating: parseFloat(A) / W * GenericTagMapper_1$2.CommonTagMapper.maxRatingScore
    };
  }
  constructor() {
    super(["vorbis"], vorbisTagMap);
  }
  postMap(L) {
    if (L.id === "RATING")
      L.value = VorbisTagMapper.toRating(void 0, L.value, 100);
    else if (L.id.indexOf("RATING:") === 0) {
      const A = L.id.split(":");
      L.value = VorbisTagMapper.toRating(A[1], L.value, 1), L.id = A[0];
    }
  }
}
VorbisTagMapper$1.VorbisTagMapper = VorbisTagMapper;
var RiffInfoTagMap = {};
(function(C) {
  Object.defineProperty(C, "__esModule", { value: !0 }), C.RiffInfoTagMapper = C.riffInfoTagMap = void 0;
  const L = GenericTagMapper;
  C.riffInfoTagMap = {
    IART: "artist",
    ICRD: "date",
    INAM: "title",
    TITL: "title",
    IPRD: "album",
    ITRK: "track",
    IPRT: "track",
    COMM: "comment",
    ICMT: "comment",
    ICNT: "releasecountry",
    GNRE: "genre",
    IWRI: "writer",
    RATE: "rating",
    YEAR: "year",
    ISFT: "encodedby",
    CODE: "encodedby",
    TURL: "website",
    IGNR: "genre",
    IENG: "engineer",
    ITCH: "technician",
    IMED: "media",
    IRPD: "album"
    // Product, where the file was intended for
  };
  class A extends L.CommonTagMapper {
    constructor() {
      super(["exif"], C.riffInfoTagMap);
    }
  }
  C.RiffInfoTagMapper = A;
})(RiffInfoTagMap);
var MatroskaTagMapper$1 = {};
Object.defineProperty(MatroskaTagMapper$1, "__esModule", { value: !0 });
MatroskaTagMapper$1.MatroskaTagMapper = void 0;
const CaseInsensitiveTagMap_1 = CaseInsensitiveTagMap$1, ebmlTagMap = {
  "segment:title": "title",
  "album:ARTIST": "albumartist",
  "album:ARTISTSORT": "albumartistsort",
  "album:TITLE": "album",
  "album:DATE_RECORDED": "originaldate",
  "album:PART_NUMBER": "disk",
  "album:TOTAL_PARTS": "totaltracks",
  "track:ARTIST": "artist",
  "track:ARTISTSORT": "artistsort",
  "track:TITLE": "title",
  "track:PART_NUMBER": "track",
  "track:MUSICBRAINZ_TRACKID": "musicbrainz_recordingid",
  "track:MUSICBRAINZ_ALBUMID": "musicbrainz_albumid",
  "track:MUSICBRAINZ_ARTISTID": "musicbrainz_artistid",
  "track:PUBLISHER": "label",
  "track:GENRE": "genre",
  "track:ENCODER": "encodedby",
  "track:ENCODER_OPTIONS": "encodersettings",
  "edition:TOTAL_PARTS": "totaldiscs",
  picture: "picture"
};
class MatroskaTagMapper extends CaseInsensitiveTagMap_1.CaseInsensitiveTagMap {
  constructor() {
    super(["matroska"], ebmlTagMap);
  }
}
MatroskaTagMapper$1.MatroskaTagMapper = MatroskaTagMapper;
var AiffTagMap = {};
Object.defineProperty(AiffTagMap, "__esModule", { value: !0 });
AiffTagMap.AiffTagMapper = void 0;
const GenericTagMapper_1$1 = GenericTagMapper, tagMap = {
  NAME: "title",
  AUTH: "artist",
  "(c) ": "copyright",
  ANNO: "comment"
};
class AiffTagMapper extends GenericTagMapper_1$1.CommonTagMapper {
  constructor() {
    super(["AIFF"], tagMap);
  }
}
AiffTagMap.AiffTagMapper = AiffTagMapper;
Object.defineProperty(CombinedTagMapper$1, "__esModule", { value: !0 });
CombinedTagMapper$1.CombinedTagMapper = void 0;
const ID3v1TagMap_1 = ID3v1TagMap, ID3v24TagMapper_1 = ID3v24TagMapper$1, AsfTagMapper_1 = AsfTagMapper$1, ID3v22TagMapper_1 = ID3v22TagMapper, APEv2TagMapper_1 = APEv2TagMapper$1, MP4TagMapper_1 = MP4TagMapper, VorbisTagMapper_1 = VorbisTagMapper$1, RiffInfoTagMap_1 = RiffInfoTagMap, MatroskaTagMapper_1 = MatroskaTagMapper$1, AiffTagMap_1 = AiffTagMap;
class CombinedTagMapper {
  constructor() {
    this.tagMappers = {}, [
      new ID3v1TagMap_1.ID3v1TagMapper(),
      new ID3v22TagMapper_1.ID3v22TagMapper(),
      new ID3v24TagMapper_1.ID3v24TagMapper(),
      new MP4TagMapper_1.MP4TagMapper(),
      new MP4TagMapper_1.MP4TagMapper(),
      new VorbisTagMapper_1.VorbisTagMapper(),
      new APEv2TagMapper_1.APEv2TagMapper(),
      new AsfTagMapper_1.AsfTagMapper(),
      new RiffInfoTagMap_1.RiffInfoTagMapper(),
      new MatroskaTagMapper_1.MatroskaTagMapper(),
      new AiffTagMap_1.AiffTagMapper()
    ].forEach((L) => {
      this.registerTagMapper(L);
    });
  }
  /**
   * Convert native to generic (common) tags
   * @param tagType Originating tag format
   * @param tag     Native tag to map to a generic tag id
   * @param warnings
   * @return Generic tag result (output of this function)
   */
  mapTag(L, A, W) {
    if (this.tagMappers[L])
      return this.tagMappers[L].mapGenericTag(A, W);
    throw new Error("No generic tag mapper defined for tag-format: " + L);
  }
  registerTagMapper(L) {
    for (const A of L.tagTypes)
      this.tagMappers[A] = L;
  }
}
CombinedTagMapper$1.CombinedTagMapper = CombinedTagMapper;
Object.defineProperty(MetadataCollector$1, "__esModule", { value: !0 });
MetadataCollector$1.joinArtists = MetadataCollector$1.MetadataCollector = void 0;
const type_1$2 = type$1, debug_1$n = browserExports, GenericTagTypes_1 = GenericTagTypes, CombinedTagMapper_1 = CombinedTagMapper$1, GenericTagMapper_1 = GenericTagMapper, Util_1$1 = Util, FileType$1 = core, debug$n = (0, debug_1$n.default)("music-metadata:collector"), TagPriority = ["matroska", "APEv2", "vorbis", "ID3v2.4", "ID3v2.3", "ID3v2.2", "exif", "asf", "iTunes", "AIFF", "ID3v1"];
class MetadataCollector {
  constructor(L) {
    this.opts = L, this.format = {
      tagTypes: [],
      trackInfo: []
    }, this.native = {}, this.common = {
      track: { no: null, of: null },
      disk: { no: null, of: null },
      movementIndex: {}
    }, this.quality = {
      warnings: []
    }, this.commonOrigin = {}, this.originPriority = {}, this.tagMapper = new CombinedTagMapper_1.CombinedTagMapper();
    let A = 1;
    for (const W of TagPriority)
      this.originPriority[W] = A++;
    this.originPriority.artificial = 500, this.originPriority.id3v1 = 600;
  }
  /**
   * @returns {boolean} true if one or more tags have been found
   */
  hasAny() {
    return Object.keys(this.native).length > 0;
  }
  addStreamInfo(L) {
    debug$n(`streamInfo: type=${type_1$2.TrackType[L.type]}, codec=${L.codecName}`), this.format.trackInfo.push(L);
  }
  setFormat(L, A) {
    debug$n(`format: ${L} = ${A}`), this.format[L] = A, this.opts.observer && this.opts.observer({ metadata: this, tag: { type: "format", id: L, value: A } });
  }
  addTag(L, A, W) {
    debug$n(`tag ${L}.${A} = ${W}`), this.native[L] || (this.format.tagTypes.push(L), this.native[L] = []), this.native[L].push({ id: A, value: W }), this.toCommon(L, A, W);
  }
  addWarning(L) {
    this.quality.warnings.push({ message: L });
  }
  postMap(L, A) {
    switch (A.id) {
      case "artist":
        if (this.commonOrigin.artist === this.originPriority[L])
          return this.postMap("artificial", { id: "artists", value: A.value });
        this.common.artists || this.setGenericTag("artificial", { id: "artists", value: A.value });
        break;
      case "artists":
        if ((!this.common.artist || this.commonOrigin.artist === this.originPriority.artificial) && (!this.common.artists || this.common.artists.indexOf(A.value) === -1)) {
          const te = (this.common.artists || []).concat([A.value]), ne = { id: "artist", value: joinArtists(te) };
          this.setGenericTag("artificial", ne);
        }
        break;
      case "picture":
        this.postFixPicture(A.value).then((te) => {
          te !== null && (A.value = te, this.setGenericTag(L, A));
        });
        return;
      case "totaltracks":
        this.common.track.of = GenericTagMapper_1.CommonTagMapper.toIntOrNull(A.value);
        return;
      case "totaldiscs":
        this.common.disk.of = GenericTagMapper_1.CommonTagMapper.toIntOrNull(A.value);
        return;
      case "movementTotal":
        this.common.movementIndex.of = GenericTagMapper_1.CommonTagMapper.toIntOrNull(A.value);
        return;
      case "track":
      case "disk":
      case "movementIndex":
        const W = this.common[A.id].of;
        this.common[A.id] = GenericTagMapper_1.CommonTagMapper.normalizeTrack(A.value), this.common[A.id].of = W ?? this.common[A.id].of;
        return;
      case "bpm":
      case "year":
      case "originalyear":
        A.value = parseInt(A.value, 10);
        break;
      case "date":
        const X = parseInt(A.value.substr(0, 4), 10);
        isNaN(X) || (this.common.year = X);
        break;
      case "discogs_label_id":
      case "discogs_release_id":
      case "discogs_master_release_id":
      case "discogs_artist_id":
      case "discogs_votes":
        A.value = typeof A.value == "string" ? parseInt(A.value, 10) : A.value;
        break;
      case "replaygain_track_gain":
      case "replaygain_track_peak":
      case "replaygain_album_gain":
      case "replaygain_album_peak":
        A.value = (0, Util_1$1.toRatio)(A.value);
        break;
      case "replaygain_track_minmax":
        A.value = A.value.split(",").map((te) => parseInt(te, 10));
        break;
      case "replaygain_undo":
        const J = A.value.split(",").map((te) => parseInt(te, 10));
        A.value = {
          leftChannel: J[0],
          rightChannel: J[1]
        };
        break;
      case "gapless":
      case "compilation":
      case "podcast":
      case "showMovement":
        A.value = A.value === "1" || A.value === 1;
        break;
      case "isrc":
        if (this.common[A.id] && this.common[A.id].indexOf(A.value) !== -1)
          return;
        break;
    }
    A.value !== null && this.setGenericTag(L, A);
  }
  /**
   * Convert native tags to common tags
   * @returns {IAudioMetadata} Native + common tags
   */
  toCommonMetadata() {
    return {
      format: this.format,
      native: this.native,
      quality: this.quality,
      common: this.common
    };
  }
  /**
   * Fix some common issues with picture object
   * @param picture Picture
   */
  async postFixPicture(L) {
    if (L.data && L.data.length > 0) {
      if (!L.format) {
        const A = await FileType$1.fromBuffer(L.data);
        if (A)
          L.format = A.mime;
        else
          return null;
      }
      switch (L.format = L.format.toLocaleLowerCase(), L.format) {
        case "image/jpg":
          L.format = "image/jpeg";
      }
      return L;
    }
    return this.addWarning("Empty picture tag found"), null;
  }
  /**
   * Convert native tag to common tags
   */
  toCommon(L, A, W) {
    const X = { id: A, value: W }, J = this.tagMapper.mapTag(L, X, this);
    J && this.postMap(L, J);
  }
  /**
   * Set generic tag
   */
  setGenericTag(L, A) {
    debug$n(`common.${A.id} = ${A.value}`);
    const W = this.commonOrigin[A.id] || 1e3, X = this.originPriority[L];
    if ((0, GenericTagTypes_1.isSingleton)(A.id))
      if (X <= W)
        this.common[A.id] = A.value, this.commonOrigin[A.id] = X;
      else
        return debug$n(`Ignore native tag (singleton): ${L}.${A.id} = ${A.value}`);
    else if (X === W)
      !(0, GenericTagTypes_1.isUnique)(A.id) || this.common[A.id].indexOf(A.value) === -1 ? this.common[A.id].push(A.value) : debug$n(`Ignore duplicate value: ${L}.${A.id} = ${A.value}`);
    else if (X < W)
      this.common[A.id] = [A.value], this.commonOrigin[A.id] = X;
    else
      return debug$n(`Ignore native tag (list): ${L}.${A.id} = ${A.value}`);
    this.opts.observer && this.opts.observer({ metadata: this, tag: { type: "common", id: A.id, value: A.value } });
  }
}
MetadataCollector$1.MetadataCollector = MetadataCollector;
function joinArtists(C) {
  return C.length > 2 ? C.slice(0, C.length - 1).join(", ") + " & " + C[C.length - 1] : C.join(" & ");
}
MetadataCollector$1.joinArtists = joinArtists;
var AiffParser = {}, ID3v2Parser$1 = {}, FrameParser$1 = {}, ID3v2Token = {};
(function(C) {
  Object.defineProperty(C, "__esModule", { value: !0 }), C.TextEncodingToken = C.ExtendedHeader = C.ID3v2Header = C.UINT32SYNCSAFE = C.AttachedPictureType = void 0;
  const L = lib$1, A = Util;
  (function(W) {
    W[W.Other = 0] = "Other", W[W["32x32 pixels 'file icon' (PNG only)"] = 1] = "32x32 pixels 'file icon' (PNG only)", W[W["Other file icon"] = 2] = "Other file icon", W[W["Cover (front)"] = 3] = "Cover (front)", W[W["Cover (back)"] = 4] = "Cover (back)", W[W["Leaflet page"] = 5] = "Leaflet page", W[W["Media (e.g. label side of CD)"] = 6] = "Media (e.g. label side of CD)", W[W["Lead artist/lead performer/soloist"] = 7] = "Lead artist/lead performer/soloist", W[W["Artist/performer"] = 8] = "Artist/performer", W[W.Conductor = 9] = "Conductor", W[W["Band/Orchestra"] = 10] = "Band/Orchestra", W[W.Composer = 11] = "Composer", W[W["Lyricist/text writer"] = 12] = "Lyricist/text writer", W[W["Recording Location"] = 13] = "Recording Location", W[W["During recording"] = 14] = "During recording", W[W["During performance"] = 15] = "During performance", W[W["Movie/video screen capture"] = 16] = "Movie/video screen capture", W[W["A bright coloured fish"] = 17] = "A bright coloured fish", W[W.Illustration = 18] = "Illustration", W[W["Band/artist logotype"] = 19] = "Band/artist logotype", W[W["Publisher/Studio logotype"] = 20] = "Publisher/Studio logotype";
  })(C.AttachedPictureType || (C.AttachedPictureType = {})), C.UINT32SYNCSAFE = {
    get: (W, X) => W[X + 3] & 127 | W[X + 2] << 7 | W[X + 1] << 14 | W[X] << 21,
    len: 4
  }, C.ID3v2Header = {
    len: 10,
    get: (W, X) => ({
      // ID3v2/file identifier   "ID3"
      fileIdentifier: new L.StringType(3, "ascii").get(W, X),
      // ID3v2 versionIndex
      version: {
        major: L.INT8.get(W, X + 3),
        revision: L.INT8.get(W, X + 4)
      },
      // ID3v2 flags
      flags: {
        // Unsynchronisation
        unsynchronisation: A.getBit(W, X + 5, 7),
        // Extended header
        isExtendedHeader: A.getBit(W, X + 5, 6),
        // Experimental indicator
        expIndicator: A.getBit(W, X + 5, 5),
        footer: A.getBit(W, X + 5, 4)
      },
      size: C.UINT32SYNCSAFE.get(W, X + 6)
    })
  }, C.ExtendedHeader = {
    len: 10,
    get: (W, X) => ({
      // Extended header size
      size: L.UINT32_BE.get(W, X),
      // Extended Flags
      extendedFlags: L.UINT16_BE.get(W, X + 4),
      // Size of padding
      sizeOfPadding: L.UINT32_BE.get(W, X + 6),
      // CRC data present
      crcDataPresent: A.getBit(W, X + 4, 31)
    })
  }, C.TextEncodingToken = {
    len: 1,
    get: (W, X) => {
      switch (W[X]) {
        case 0:
          return { encoding: "latin1" };
        case 1:
          return { encoding: "utf16le", bom: !0 };
        case 2:
          return { encoding: "utf16le", bom: !1 };
        case 3:
          return { encoding: "utf8", bom: !1 };
        default:
          return { encoding: "utf8", bom: !1 };
      }
    }
  };
})(ID3v2Token);
var ID3v1Parser = {}, BasicParser$1 = {};
Object.defineProperty(BasicParser$1, "__esModule", { value: !0 });
BasicParser$1.BasicParser = void 0;
class BasicParser {
  /**
   * Initialize parser with output (metadata), input (tokenizer) & parsing options (options).
   * @param {INativeMetadataCollector} metadata Output
   * @param {ITokenizer} tokenizer Input
   * @param {IOptions} options Parsing options
   */
  init(L, A, W) {
    return this.metadata = L, this.tokenizer = A, this.options = W, this;
  }
}
BasicParser$1.BasicParser = BasicParser;
var APEv2Parser$1 = {}, APEv2Token = {}, FourCC = {};
(function(C) {
  Object.defineProperty(C, "__esModule", { value: !0 }), C.FourCcToken = void 0;
  const L = Util, A = /^[\x21-\x7e©][\x20-\x7e\x00()]{3}/;
  C.FourCcToken = {
    len: 4,
    get: (W, X) => {
      const J = W.toString("binary", X, X + C.FourCcToken.len);
      if (!J.match(A))
        throw new Error(`FourCC contains invalid characters: ${L.a2hex(J)} "${J}"`);
      return J;
    },
    put: (W, X, J) => {
      const te = Buffer.from(J, "binary");
      if (te.length !== 4)
        throw new Error("Invalid length");
      return te.copy(W, X);
    }
  };
})(FourCC);
(function(C) {
  Object.defineProperty(C, "__esModule", { value: !0 }), C.isBitSet = C.parseTagFlags = C.TagField = C.TagItemHeader = C.TagFooter = C.Header = C.DescriptorParser = C.DataType = void 0;
  const L = lib$1, A = FourCC;
  (function(te) {
    te[te.text_utf8 = 0] = "text_utf8", te[te.binary = 1] = "binary", te[te.external_info = 2] = "external_info", te[te.reserved = 3] = "reserved";
  })(C.DataType || (C.DataType = {})), C.DescriptorParser = {
    len: 52,
    get: (te, oe) => ({
      // should equal 'MAC '
      ID: A.FourCcToken.get(te, oe),
      // versionIndex number * 1000 (3.81 = 3810) (remember that 4-byte alignment causes this to take 4-bytes)
      version: L.UINT32_LE.get(te, oe + 4) / 1e3,
      // the number of descriptor bytes (allows later expansion of this header)
      descriptorBytes: L.UINT32_LE.get(te, oe + 8),
      // the number of header APE_HEADER bytes
      headerBytes: L.UINT32_LE.get(te, oe + 12),
      // the number of header APE_HEADER bytes
      seekTableBytes: L.UINT32_LE.get(te, oe + 16),
      // the number of header data bytes (from original file)
      headerDataBytes: L.UINT32_LE.get(te, oe + 20),
      // the number of bytes of APE frame data
      apeFrameDataBytes: L.UINT32_LE.get(te, oe + 24),
      // the high order number of APE frame data bytes
      apeFrameDataBytesHigh: L.UINT32_LE.get(te, oe + 28),
      // the terminating data of the file (not including tag data)
      terminatingDataBytes: L.UINT32_LE.get(te, oe + 32),
      // the MD5 hash of the file (see notes for usage... it's a little tricky)
      fileMD5: new L.Uint8ArrayType(16).get(te, oe + 36)
    })
  }, C.Header = {
    len: 24,
    get: (te, oe) => ({
      // the compression level (see defines I.E. COMPRESSION_LEVEL_FAST)
      compressionLevel: L.UINT16_LE.get(te, oe),
      // any format flags (for future use)
      formatFlags: L.UINT16_LE.get(te, oe + 2),
      // the number of audio blocks in one frame
      blocksPerFrame: L.UINT32_LE.get(te, oe + 4),
      // the number of audio blocks in the final frame
      finalFrameBlocks: L.UINT32_LE.get(te, oe + 8),
      // the total number of frames
      totalFrames: L.UINT32_LE.get(te, oe + 12),
      // the bits per sample (typically 16)
      bitsPerSample: L.UINT16_LE.get(te, oe + 16),
      // the number of channels (1 or 2)
      channel: L.UINT16_LE.get(te, oe + 18),
      // the sample rate (typically 44100)
      sampleRate: L.UINT32_LE.get(te, oe + 20)
    })
  }, C.TagFooter = {
    len: 32,
    get: (te, oe) => ({
      // should equal 'APETAGEX'
      ID: new L.StringType(8, "ascii").get(te, oe),
      // equals CURRENT_APE_TAG_VERSION
      version: L.UINT32_LE.get(te, oe + 8),
      // the complete size of the tag, including this footer (excludes header)
      size: L.UINT32_LE.get(te, oe + 12),
      // the number of fields in the tag
      fields: L.UINT32_LE.get(te, oe + 16),
      // reserved for later use (must be zero),
      flags: X(L.UINT32_LE.get(te, oe + 20))
    })
  }, C.TagItemHeader = {
    len: 8,
    get: (te, oe) => ({
      // Length of assigned value in bytes
      size: L.UINT32_LE.get(te, oe),
      // reserved for later use (must be zero),
      flags: X(L.UINT32_LE.get(te, oe + 4))
    })
  };
  const W = (te) => new L.Uint8ArrayType(te.size - C.TagFooter.len);
  C.TagField = W;
  function X(te) {
    return {
      containsHeader: J(te, 31),
      containsFooter: J(te, 30),
      isHeader: J(te, 31),
      readOnly: J(te, 0),
      dataType: (te & 6) >> 1
    };
  }
  C.parseTagFlags = X;
  function J(te, oe) {
    return (te & 1 << oe) !== 0;
  }
  C.isBitSet = J;
})(APEv2Token);
Object.defineProperty(APEv2Parser$1, "__esModule", { value: !0 });
APEv2Parser$1.APEv2Parser = void 0;
const debug_1$m = browserExports, strtok3$4 = core$1, token_types_1$2 = lib$1, util$a = Util, BasicParser_1$b = BasicParser$1, APEv2Token_1 = APEv2Token, debug$m = (0, debug_1$m.default)("music-metadata:parser:APEv2"), tagFormat$1 = "APEv2", preamble = "APETAGEX";
class APEv2Parser extends BasicParser_1$b.BasicParser {
  constructor() {
    super(...arguments), this.ape = {};
  }
  static tryParseApeHeader(L, A, W) {
    const X = new APEv2Parser();
    return X.init(L, A, W), X.tryParseApeHeader();
  }
  /**
   * Calculate the media file duration
   * @param ah ApeHeader
   * @return {number} duration in seconds
   */
  static calculateDuration(L) {
    let A = L.totalFrames > 1 ? L.blocksPerFrame * (L.totalFrames - 1) : 0;
    return A += L.finalFrameBlocks, A / L.sampleRate;
  }
  /**
   * Calculates the APEv1 / APEv2 first field offset
   * @param reader
   * @param offset
   */
  static async findApeFooterOffset(L, A) {
    const W = Buffer.alloc(APEv2Token_1.TagFooter.len);
    await L.randomRead(W, 0, APEv2Token_1.TagFooter.len, A - APEv2Token_1.TagFooter.len);
    const X = APEv2Token_1.TagFooter.get(W, 0);
    if (X.ID === "APETAGEX")
      return debug$m(`APE footer header at offset=${A}`), { footer: X, offset: A - X.size };
  }
  static parseTagFooter(L, A, W) {
    const X = APEv2Token_1.TagFooter.get(A, A.length - APEv2Token_1.TagFooter.len);
    if (X.ID !== preamble)
      throw new Error("Unexpected APEv2 Footer ID preamble value.");
    strtok3$4.fromBuffer(A);
    const J = new APEv2Parser();
    return J.init(L, strtok3$4.fromBuffer(A), W), J.parseTags(X);
  }
  /**
   * Parse APEv1 / APEv2 header if header signature found
   */
  async tryParseApeHeader() {
    if (this.tokenizer.fileInfo.size && this.tokenizer.fileInfo.size - this.tokenizer.position < APEv2Token_1.TagFooter.len) {
      debug$m("No APEv2 header found, end-of-file reached");
      return;
    }
    const L = await this.tokenizer.peekToken(APEv2Token_1.TagFooter);
    if (L.ID === preamble)
      return await this.tokenizer.ignore(APEv2Token_1.TagFooter.len), this.parseTags(L);
    if (debug$m(`APEv2 header not found at offset=${this.tokenizer.position}`), this.tokenizer.fileInfo.size) {
      const A = this.tokenizer.fileInfo.size - this.tokenizer.position, W = Buffer.alloc(A);
      return await this.tokenizer.readBuffer(W), APEv2Parser.parseTagFooter(this.metadata, W, this.options);
    }
  }
  async parse() {
    const L = await this.tokenizer.readToken(APEv2Token_1.DescriptorParser);
    if (L.ID !== "MAC ")
      throw new Error("Unexpected descriptor ID");
    this.ape.descriptor = L;
    const A = L.descriptorBytes - APEv2Token_1.DescriptorParser.len, W = await (A > 0 ? this.parseDescriptorExpansion(A) : this.parseHeader());
    return await this.tokenizer.ignore(W.forwardBytes), this.tryParseApeHeader();
  }
  async parseTags(L) {
    const A = Buffer.alloc(256);
    let W = L.size - APEv2Token_1.TagFooter.len;
    debug$m(`Parse APE tags at offset=${this.tokenizer.position}, size=${W}`);
    for (let X = 0; X < L.fields; X++) {
      if (W < APEv2Token_1.TagItemHeader.len) {
        this.metadata.addWarning(`APEv2 Tag-header: ${L.fields - X} items remaining, but no more tag data to read.`);
        break;
      }
      const J = await this.tokenizer.readToken(APEv2Token_1.TagItemHeader);
      W -= APEv2Token_1.TagItemHeader.len + J.size, await this.tokenizer.peekBuffer(A, { length: Math.min(A.length, W) });
      let te = util$a.findZero(A, 0, A.length);
      const oe = await this.tokenizer.readToken(new token_types_1$2.StringType(te, "ascii"));
      switch (await this.tokenizer.ignore(1), W -= oe.length + 1, J.flags.dataType) {
        case APEv2Token_1.DataType.text_utf8: {
          const re = (await this.tokenizer.readToken(new token_types_1$2.StringType(J.size, "utf8"))).split(/\x00/g);
          for (const ce of re)
            this.metadata.addTag(tagFormat$1, oe, ce);
          break;
        }
        case APEv2Token_1.DataType.binary:
          if (this.options.skipCovers)
            await this.tokenizer.ignore(J.size);
          else {
            const ne = Buffer.alloc(J.size);
            await this.tokenizer.readBuffer(ne), te = util$a.findZero(ne, 0, ne.length);
            const re = ne.toString("utf8", 0, te), ce = Buffer.from(ne.slice(te + 1));
            this.metadata.addTag(tagFormat$1, oe, {
              description: re,
              data: ce
            });
          }
          break;
        case APEv2Token_1.DataType.external_info:
          debug$m(`Ignore external info ${oe}`), await this.tokenizer.ignore(J.size);
          break;
        case APEv2Token_1.DataType.reserved:
          debug$m(`Ignore external info ${oe}`), this.metadata.addWarning(`APEv2 header declares a reserved datatype for "${oe}"`), await this.tokenizer.ignore(J.size);
          break;
      }
    }
  }
  async parseDescriptorExpansion(L) {
    return await this.tokenizer.ignore(L), this.parseHeader();
  }
  async parseHeader() {
    const L = await this.tokenizer.readToken(APEv2Token_1.Header);
    return this.metadata.setFormat("lossless", !0), this.metadata.setFormat("container", "Monkey's Audio"), this.metadata.setFormat("bitsPerSample", L.bitsPerSample), this.metadata.setFormat("sampleRate", L.sampleRate), this.metadata.setFormat("numberOfChannels", L.channel), this.metadata.setFormat("duration", APEv2Parser.calculateDuration(L)), {
      forwardBytes: this.ape.descriptor.seekTableBytes + this.ape.descriptor.headerDataBytes + this.ape.descriptor.apeFrameDataBytes + this.ape.descriptor.terminatingDataBytes
    };
  }
}
APEv2Parser$1.APEv2Parser = APEv2Parser;
(function(C) {
  Object.defineProperty(C, "__esModule", { value: !0 }), C.hasID3v1Header = C.ID3v1Parser = C.Genres = void 0;
  const L = browserExports, A = lib$1, W = Util, X = BasicParser$1, J = APEv2Parser$1, te = (0, L.default)("music-metadata:parser:ID3v1");
  C.Genres = [
    "Blues",
    "Classic Rock",
    "Country",
    "Dance",
    "Disco",
    "Funk",
    "Grunge",
    "Hip-Hop",
    "Jazz",
    "Metal",
    "New Age",
    "Oldies",
    "Other",
    "Pop",
    "R&B",
    "Rap",
    "Reggae",
    "Rock",
    "Techno",
    "Industrial",
    "Alternative",
    "Ska",
    "Death Metal",
    "Pranks",
    "Soundtrack",
    "Euro-Techno",
    "Ambient",
    "Trip-Hop",
    "Vocal",
    "Jazz+Funk",
    "Fusion",
    "Trance",
    "Classical",
    "Instrumental",
    "Acid",
    "House",
    "Game",
    "Sound Clip",
    "Gospel",
    "Noise",
    "Alt. Rock",
    "Bass",
    "Soul",
    "Punk",
    "Space",
    "Meditative",
    "Instrumental Pop",
    "Instrumental Rock",
    "Ethnic",
    "Gothic",
    "Darkwave",
    "Techno-Industrial",
    "Electronic",
    "Pop-Folk",
    "Eurodance",
    "Dream",
    "Southern Rock",
    "Comedy",
    "Cult",
    "Gangsta Rap",
    "Top 40",
    "Christian Rap",
    "Pop/Funk",
    "Jungle",
    "Native American",
    "Cabaret",
    "New Wave",
    "Psychedelic",
    "Rave",
    "Showtunes",
    "Trailer",
    "Lo-Fi",
    "Tribal",
    "Acid Punk",
    "Acid Jazz",
    "Polka",
    "Retro",
    "Musical",
    "Rock & Roll",
    "Hard Rock",
    "Folk",
    "Folk/Rock",
    "National Folk",
    "Swing",
    "Fast-Fusion",
    "Bebob",
    "Latin",
    "Revival",
    "Celtic",
    "Bluegrass",
    "Avantgarde",
    "Gothic Rock",
    "Progressive Rock",
    "Psychedelic Rock",
    "Symphonic Rock",
    "Slow Rock",
    "Big Band",
    "Chorus",
    "Easy Listening",
    "Acoustic",
    "Humour",
    "Speech",
    "Chanson",
    "Opera",
    "Chamber Music",
    "Sonata",
    "Symphony",
    "Booty Bass",
    "Primus",
    "Porn Groove",
    "Satire",
    "Slow Jam",
    "Club",
    "Tango",
    "Samba",
    "Folklore",
    "Ballad",
    "Power Ballad",
    "Rhythmic Soul",
    "Freestyle",
    "Duet",
    "Punk Rock",
    "Drum Solo",
    "A Cappella",
    "Euro-House",
    "Dance Hall",
    "Goa",
    "Drum & Bass",
    "Club-House",
    "Hardcore",
    "Terror",
    "Indie",
    "BritPop",
    "Negerpunk",
    "Polsk Punk",
    "Beat",
    "Christian Gangsta Rap",
    "Heavy Metal",
    "Black Metal",
    "Crossover",
    "Contemporary Christian",
    "Christian Rock",
    "Merengue",
    "Salsa",
    "Thrash Metal",
    "Anime",
    "JPop",
    "Synthpop",
    "Abstract",
    "Art Rock",
    "Baroque",
    "Bhangra",
    "Big Beat",
    "Breakbeat",
    "Chillout",
    "Downtempo",
    "Dub",
    "EBM",
    "Eclectic",
    "Electro",
    "Electroclash",
    "Emo",
    "Experimental",
    "Garage",
    "Global",
    "IDM",
    "Illbient",
    "Industro-Goth",
    "Jam Band",
    "Krautrock",
    "Leftfield",
    "Lounge",
    "Math Rock",
    "New Romantic",
    "Nu-Breakz",
    "Post-Punk",
    "Post-Rock",
    "Psytrance",
    "Shoegaze",
    "Space Rock",
    "Trop Rock",
    "World Music",
    "Neoclassical",
    "Audiobook",
    "Audio Theatre",
    "Neue Deutsche Welle",
    "Podcast",
    "Indie Rock",
    "G-Funk",
    "Dubstep",
    "Garage Rock",
    "Psybient"
  ];
  const oe = {
    len: 128,
    /**
     * @param buf Buffer possibly holding the 128 bytes ID3v1.1 metadata header
     * @param off Offset in buffer in bytes
     * @returns ID3v1.1 header if first 3 bytes equals 'TAG', otherwise null is returned
     */
    get: (ue, de) => {
      const be = new ne(3).get(ue, de);
      return be === "TAG" ? {
        header: be,
        title: new ne(30).get(ue, de + 3),
        artist: new ne(30).get(ue, de + 33),
        album: new ne(30).get(ue, de + 63),
        year: new ne(4).get(ue, de + 93),
        comment: new ne(28).get(ue, de + 97),
        // ID3v1.1 separator for track
        zeroByte: A.UINT8.get(ue, de + 127),
        // track: ID3v1.1 field added by Michael Mutschler
        track: A.UINT8.get(ue, de + 126),
        genre: A.UINT8.get(ue, de + 127)
      } : null;
    }
  };
  class ne extends A.StringType {
    constructor(de) {
      super(de, "binary");
    }
    get(de, be) {
      let pe = super.get(de, be);
      return pe = W.trimRightNull(pe), pe = pe.trim(), pe.length > 0 ? pe : void 0;
    }
  }
  class re extends X.BasicParser {
    static getGenre(de) {
      if (de < C.Genres.length)
        return C.Genres[de];
    }
    async parse() {
      if (!this.tokenizer.fileInfo.size) {
        te("Skip checking for ID3v1 because the file-size is unknown");
        return;
      }
      if (this.options.apeHeader) {
        this.tokenizer.ignore(this.options.apeHeader.offset - this.tokenizer.position);
        const pe = new J.APEv2Parser();
        pe.init(this.metadata, this.tokenizer, this.options), await pe.parseTags(this.options.apeHeader.footer);
      }
      const de = this.tokenizer.fileInfo.size - oe.len;
      if (this.tokenizer.position > de) {
        te("Already consumed the last 128 bytes");
        return;
      }
      const be = await this.tokenizer.readToken(oe, de);
      if (be) {
        te("ID3v1 header found at: pos=%s", this.tokenizer.fileInfo.size - oe.len);
        for (const me of ["title", "artist", "album", "comment", "track", "year"])
          be[me] && be[me] !== "" && this.addTag(me, be[me]);
        const pe = re.getGenre(be.genre);
        pe && this.addTag("genre", pe);
      } else
        te("ID3v1 header not found at: pos=%s", this.tokenizer.fileInfo.size - oe.len);
    }
    addTag(de, be) {
      this.metadata.addTag("ID3v1", de, be);
    }
  }
  C.ID3v1Parser = re;
  async function ce(ue) {
    if (ue.fileSize >= 128) {
      const de = Buffer.alloc(3);
      return await ue.randomRead(de, 0, de.length, ue.fileSize - 128), de.toString("binary") === "TAG";
    }
    return !1;
  }
  C.hasID3v1Header = ce;
})(ID3v1Parser);
Object.defineProperty(FrameParser$1, "__esModule", { value: !0 });
FrameParser$1.FrameParser = FrameParser$1.parseGenre = void 0;
const debug_1$l = browserExports, Token$r = lib$1, util$9 = Util, ID3v2Token_1$3 = ID3v2Token, ID3v1Parser_1$3 = ID3v1Parser, debug$l = (0, debug_1$l.default)("music-metadata:id3v2:frame-parser"), defaultEnc = "latin1";
function parseGenre(C) {
  const L = [];
  let A, W = "";
  for (const X of C)
    if (typeof A == "string")
      if (X === "(" && A === "")
        W += "(", A = void 0;
      else if (X === ")") {
        W !== "" && (L.push(W), W = "");
        const J = parseGenreCode(A);
        J && L.push(J), A = void 0;
      } else
        A += X;
    else X === "(" ? A = "" : W += X;
  return W && (L.length === 0 && W.match(/^\d*$/) && (W = ID3v1Parser_1$3.Genres[W]), L.push(W)), L;
}
FrameParser$1.parseGenre = parseGenre;
function parseGenreCode(C) {
  if (C === "RX")
    return "Remix";
  if (C === "CR")
    return "Cover";
  if (C.match(/^\d*$/))
    return ID3v1Parser_1$3.Genres[C];
}
class FrameParser {
  /**
   * Create id3v2 frame parser
   * @param major - Major version, e.g. (4) for  id3v2.4
   * @param warningCollector - Used to collect decode issue
   */
  constructor(L, A) {
    this.major = L, this.warningCollector = A;
  }
  readData(L, A, W) {
    if (L.length === 0) {
      this.warningCollector.addWarning(`id3v2.${this.major} header has empty tag type=${A}`);
      return;
    }
    const { encoding: X, bom: J } = ID3v2Token_1$3.TextEncodingToken.get(L, 0), te = L.length;
    let oe = 0, ne = [];
    const re = FrameParser.getNullTerminatorLength(X);
    let ce;
    const ue = {};
    switch (debug$l(`Parsing tag type=${A}, encoding=${X}, bom=${J}`), A !== "TXXX" && A[0] === "T" ? "T*" : A) {
      case "T*":
      case "IPLS":
      case "MVIN":
      case "MVNM":
      case "PCS":
      case "PCST":
        let de;
        try {
          de = util$9.decodeString(L.slice(1), X).replace(/\x00+$/, "");
        } catch (me) {
          this.warningCollector.addWarning(`id3v2.${this.major} type=${A} header has invalid string value: ${me.message}`);
        }
        switch (A) {
          case "TMCL":
          case "TIPL":
          case "IPLS":
            ne = this.splitValue(A, de), ne = FrameParser.functionList(ne);
            break;
          case "TRK":
          case "TRCK":
          case "TPOS":
            ne = de;
            break;
          case "TCOM":
          case "TEXT":
          case "TOLY":
          case "TOPE":
          case "TPE1":
          case "TSRC":
            ne = this.splitValue(A, de);
            break;
          case "TCO":
          case "TCON":
            ne = this.splitValue(A, de).map((me) => parseGenre(me)).reduce((me, Me) => me.concat(Me), []);
            break;
          case "PCS":
          case "PCST":
            ne = this.major >= 4 ? this.splitValue(A, de) : [de], ne = Array.isArray(ne) && ne[0] === "" ? 1 : 0;
            break;
          default:
            ne = this.major >= 4 ? this.splitValue(A, de) : [de];
        }
        break;
      case "TXXX":
        ne = FrameParser.readIdentifierAndData(L, oe + 1, te, X), ne = {
          description: ne.id,
          text: this.splitValue(A, util$9.decodeString(ne.data, X).replace(/\x00+$/, ""))
        };
        break;
      case "PIC":
      case "APIC":
        if (W) {
          const me = {};
          switch (oe += 1, this.major) {
            case 2:
              me.format = util$9.decodeString(L.slice(oe, oe + 3), "latin1"), oe += 3;
              break;
            case 3:
            case 4:
              ce = util$9.findZero(L, oe, te, defaultEnc), me.format = util$9.decodeString(L.slice(oe, ce), defaultEnc), oe = ce + 1;
              break;
            default:
              throw new Error("Warning: unexpected major versionIndex: " + this.major);
          }
          me.format = FrameParser.fixPictureMimeType(me.format), me.type = ID3v2Token_1$3.AttachedPictureType[L[oe]], oe += 1, ce = util$9.findZero(L, oe, te, X), me.description = util$9.decodeString(L.slice(oe, ce), X), oe = ce + re, me.data = Buffer.from(L.slice(oe, te)), ne = me;
        }
        break;
      case "CNT":
      case "PCNT":
        ne = Token$r.UINT32_BE.get(L, 0);
        break;
      case "SYLT":
        for (oe += 7, ne = []; oe < te; ) {
          const me = L.slice(oe, oe = util$9.findZero(L, oe, te, X));
          oe += 5, ne.push(util$9.decodeString(me, X));
        }
        break;
      case "ULT":
      case "USLT":
      case "COM":
      case "COMM":
        oe += 1, ue.language = util$9.decodeString(L.slice(oe, oe + 3), defaultEnc), oe += 3, ce = util$9.findZero(L, oe, te, X), ue.description = util$9.decodeString(L.slice(oe, ce), X), oe = ce + re, ue.text = util$9.decodeString(L.slice(oe, te), X).replace(/\x00+$/, ""), ne = [ue];
        break;
      case "UFID":
        ne = FrameParser.readIdentifierAndData(L, oe, te, defaultEnc), ne = { owner_identifier: ne.id, identifier: ne.data };
        break;
      case "PRIV":
        ne = FrameParser.readIdentifierAndData(L, oe, te, defaultEnc), ne = { owner_identifier: ne.id, data: ne.data };
        break;
      case "POPM":
        ce = util$9.findZero(L, oe, te, defaultEnc);
        const be = util$9.decodeString(L.slice(oe, ce), defaultEnc);
        oe = ce + 1;
        const pe = te - oe;
        ne = {
          email: be,
          rating: Token$r.UINT8.get(L, oe),
          counter: pe >= 5 ? Token$r.UINT32_BE.get(L, oe + 1) : void 0
        };
        break;
      case "GEOB": {
        ce = util$9.findZero(L, oe + 1, te, X);
        const me = util$9.decodeString(L.slice(oe + 1, ce), defaultEnc);
        oe = ce + 1, ce = util$9.findZero(L, oe, te - oe, X);
        const Me = util$9.decodeString(L.slice(oe, ce), defaultEnc);
        oe = ce + 1, ce = util$9.findZero(L, oe, te - oe, X);
        const he = util$9.decodeString(L.slice(oe, ce), defaultEnc);
        ne = {
          type: me,
          filename: Me,
          description: he,
          data: L.slice(oe + 1, te)
        };
        break;
      }
      case "WCOM":
      case "WCOP":
      case "WOAF":
      case "WOAR":
      case "WOAS":
      case "WORS":
      case "WPAY":
      case "WPUB":
        ne = util$9.decodeString(L.slice(oe, ce), defaultEnc);
        break;
      case "WXXX": {
        ce = util$9.findZero(L, oe + 1, te, X);
        const me = util$9.decodeString(L.slice(oe + 1, ce), X);
        oe = ce + (X === "utf16le" ? 2 : 1), ne = { description: me, url: util$9.decodeString(L.slice(oe, te), defaultEnc) };
        break;
      }
      case "WFD":
      case "WFED":
        ne = util$9.decodeString(L.slice(oe + 1, util$9.findZero(L, oe + 1, te, X)), X);
        break;
      case "MCDI": {
        ne = L.slice(0, te);
        break;
      }
      default:
        debug$l("Warning: unsupported id3v2-tag-type: " + A);
        break;
    }
    return ne;
  }
  static fixPictureMimeType(L) {
    switch (L = L.toLocaleLowerCase(), L) {
      case "jpg":
        return "image/jpeg";
      case "png":
        return "image/png";
    }
    return L;
  }
  /**
   * Converts TMCL (Musician credits list) or TIPL (Involved people list)
   * @param entries
   */
  static functionList(L) {
    const A = {};
    for (let W = 0; W + 1 < L.length; W += 2) {
      const X = L[W + 1].split(",");
      A[L[W]] = A.hasOwnProperty(L[W]) ? A[L[W]].concat(X) : X;
    }
    return A;
  }
  /**
   * id3v2.4 defines that multiple T* values are separated by 0x00
   * id3v2.3 defines that TCOM, TEXT, TOLY, TOPE & TPE1 values are separated by /
   * @param tag - Tag name
   * @param text - Concatenated tag value
   * @returns Split tag value
   */
  splitValue(L, A) {
    let W;
    return this.major < 4 ? (W = A.split(/\x00/g), W.length > 1 ? this.warningCollector.addWarning(`ID3v2.${this.major} ${L} uses non standard null-separator.`) : W = A.split(/\//g)) : W = A.split(/\x00/g), FrameParser.trimArray(W);
  }
  static trimArray(L) {
    return L.map((A) => A.replace(/\x00+$/, "").trim());
  }
  static readIdentifierAndData(L, A, W, X) {
    const J = util$9.findZero(L, A, W, X), te = util$9.decodeString(L.slice(A, J), X);
    return A = J + FrameParser.getNullTerminatorLength(X), { id: te, data: L.slice(A, W) };
  }
  static getNullTerminatorLength(L) {
    return L === "utf16le" ? 2 : 1;
  }
}
FrameParser$1.FrameParser = FrameParser;
Object.defineProperty(ID3v2Parser$1, "__esModule", { value: !0 });
ID3v2Parser$1.ID3v2Parser = void 0;
const Token$q = lib$1, util$8 = Util, FrameParser_1 = FrameParser$1, ID3v2Token_1$2 = ID3v2Token;
class ID3v2Parser {
  static removeUnsyncBytes(L) {
    let A = 0, W = 0;
    for (; A < L.length - 1; )
      A !== W && (L[W] = L[A]), A += L[A] === 255 && L[A + 1] === 0 ? 2 : 1, W++;
    return A < L.length && (L[W++] = L[A]), L.slice(0, W);
  }
  static getFrameHeaderLength(L) {
    switch (L) {
      case 2:
        return 6;
      case 3:
      case 4:
        return 10;
      default:
        throw new Error("header versionIndex is incorrect");
    }
  }
  static readFrameFlags(L) {
    return {
      status: {
        tag_alter_preservation: util$8.getBit(L, 0, 6),
        file_alter_preservation: util$8.getBit(L, 0, 5),
        read_only: util$8.getBit(L, 0, 4)
      },
      format: {
        grouping_identity: util$8.getBit(L, 1, 7),
        compression: util$8.getBit(L, 1, 3),
        encryption: util$8.getBit(L, 1, 2),
        unsynchronisation: util$8.getBit(L, 1, 1),
        data_length_indicator: util$8.getBit(L, 1, 0)
      }
    };
  }
  static readFrameData(L, A, W, X, J) {
    const te = new FrameParser_1.FrameParser(W, J);
    switch (W) {
      case 2:
        return te.readData(L, A.id, X);
      case 3:
      case 4:
        return A.flags.format.unsynchronisation && (L = ID3v2Parser.removeUnsyncBytes(L)), A.flags.format.data_length_indicator && (L = L.slice(4, L.length)), te.readData(L, A.id, X);
      default:
        throw new Error("Unexpected majorVer: " + W);
    }
  }
  /**
   * Create a combined tag key, of tag & description
   * @param tag e.g.: COM
   * @param description e.g. iTunPGAP
   * @returns string e.g. COM:iTunPGAP
   */
  static makeDescriptionTagName(L, A) {
    return L + (A ? ":" + A : "");
  }
  async parse(L, A, W) {
    this.tokenizer = A, this.metadata = L, this.options = W;
    const X = await this.tokenizer.readToken(ID3v2Token_1$2.ID3v2Header);
    if (X.fileIdentifier !== "ID3")
      throw new Error("expected ID3-header file-identifier 'ID3' was not found");
    return this.id3Header = X, this.headerType = "ID3v2." + X.version.major, X.flags.isExtendedHeader ? this.parseExtendedHeader() : this.parseId3Data(X.size);
  }
  async parseExtendedHeader() {
    const L = await this.tokenizer.readToken(ID3v2Token_1$2.ExtendedHeader), A = L.size - ID3v2Token_1$2.ExtendedHeader.len;
    return A > 0 ? this.parseExtendedHeaderData(A, L.size) : this.parseId3Data(this.id3Header.size - L.size);
  }
  async parseExtendedHeaderData(L, A) {
    return await this.tokenizer.ignore(L), this.parseId3Data(this.id3Header.size - A);
  }
  async parseId3Data(L) {
    const A = await this.tokenizer.readToken(new Token$q.Uint8ArrayType(L));
    for (const W of this.parseMetadata(A))
      if (W.id === "TXXX") {
        if (W.value)
          for (const X of W.value.text)
            this.addTag(ID3v2Parser.makeDescriptionTagName(W.id, W.value.description), X);
      } else if (W.id === "COM")
        for (const X of W.value)
          this.addTag(ID3v2Parser.makeDescriptionTagName(W.id, X.description), X.text);
      else if (W.id === "COMM")
        for (const X of W.value)
          this.addTag(ID3v2Parser.makeDescriptionTagName(W.id, X.description), X);
      else if (Array.isArray(W.value))
        for (const X of W.value)
          this.addTag(W.id, X);
      else
        this.addTag(W.id, W.value);
  }
  addTag(L, A) {
    this.metadata.addTag(this.headerType, L, A);
  }
  parseMetadata(L) {
    let A = 0;
    const W = [];
    for (; A !== L.length; ) {
      const X = ID3v2Parser.getFrameHeaderLength(this.id3Header.version.major);
      if (A + X > L.length) {
        this.metadata.addWarning("Illegal ID3v2 tag length");
        break;
      }
      const J = L.slice(A, A += X), te = this.readFrameHeader(J, this.id3Header.version.major), oe = L.slice(A, A += te.length), ne = ID3v2Parser.readFrameData(oe, te, this.id3Header.version.major, !this.options.skipCovers, this.metadata);
      ne && W.push({ id: te.id, value: ne });
    }
    return W;
  }
  readFrameHeader(L, A) {
    let W;
    switch (A) {
      case 2:
        W = {
          id: Buffer.from(L.slice(0, 3)).toString("ascii"),
          length: Token$q.UINT24_BE.get(L, 3)
        }, W.id.match(/[A-Z0-9]{3}/g) || this.metadata.addWarning(`Invalid ID3v2.${this.id3Header.version.major} frame-header-ID: ${W.id}`);
        break;
      case 3:
      case 4:
        W = {
          id: Buffer.from(L.slice(0, 4)).toString("ascii"),
          length: (A === 4 ? ID3v2Token_1$2.UINT32SYNCSAFE : Token$q.UINT32_BE).get(L, 4),
          flags: ID3v2Parser.readFrameFlags(L.slice(8, 10))
        }, W.id.match(/[A-Z0-9]{4}/g) || this.metadata.addWarning(`Invalid ID3v2.${this.id3Header.version.major} frame-header-ID: ${W.id}`);
        break;
      default:
        throw new Error("Unexpected majorVer: " + A);
    }
    return W;
  }
}
ID3v2Parser$1.ID3v2Parser = ID3v2Parser;
var AiffToken$1 = {};
Object.defineProperty(AiffToken$1, "__esModule", { value: !0 });
AiffToken$1.Common = void 0;
const Token$p = lib$1, FourCC_1$a = FourCC;
class Common {
  constructor(L, A) {
    this.isAifc = A;
    const W = A ? 22 : 18;
    if (L.chunkSize < W)
      throw new Error(`COMMON CHUNK size should always be at least ${W}`);
    this.len = L.chunkSize;
  }
  get(L, A) {
    const W = L.readUInt16BE(A + 8) - 16398, X = L.readUInt16BE(A + 8 + 2), J = {
      numChannels: L.readUInt16BE(A),
      numSampleFrames: L.readUInt32BE(A + 2),
      sampleSize: L.readUInt16BE(A + 6),
      sampleRate: W < 0 ? X >> Math.abs(W) : X << W
    };
    if (this.isAifc) {
      if (J.compressionType = FourCC_1$a.FourCcToken.get(L, A + 18), this.len > 22) {
        const te = L.readInt8(A + 22);
        if (te > 0) {
          const oe = (te + 1) % 2;
          if (23 + te + oe === this.len)
            J.compressionName = new Token$p.StringType(te, "binary").get(L, A + 23);
          else
            throw new Error("Illegal pstring length");
        } else
          J.compressionName = void 0;
      }
    } else
      J.compressionName = "PCM";
    return J;
  }
}
AiffToken$1.Common = Common;
var iff$1 = {};
Object.defineProperty(iff$1, "__esModule", { value: !0 });
iff$1.Header = void 0;
const Token$o = lib$1, FourCC_1$9 = FourCC;
iff$1.Header = {
  len: 8,
  get: (C, L) => ({
    // Chunk type ID
    chunkID: FourCC_1$9.FourCcToken.get(C, L),
    // Chunk size
    chunkSize: Number(BigInt(Token$o.UINT32_BE.get(C, L + 4)))
  })
};
Object.defineProperty(AiffParser, "__esModule", { value: !0 });
AiffParser.AIFFParser = void 0;
const Token$n = lib$1, debug_1$k = browserExports, strtok3$3 = core$1, ID3v2Parser_1$4 = ID3v2Parser$1, FourCC_1$8 = FourCC, BasicParser_1$a = BasicParser$1, AiffToken = AiffToken$1, iff = iff$1, debug$k = (0, debug_1$k.default)("music-metadata:parser:aiff"), compressionTypes = {
  NONE: "not compressed	PCM	Apple Computer",
  sowt: "PCM (byte swapped)",
  fl32: "32-bit floating point IEEE 32-bit float",
  fl64: "64-bit floating point IEEE 64-bit float	Apple Computer",
  alaw: "ALaw 2:1	8-bit ITU-T G.711 A-law",
  ulaw: "µLaw 2:1	8-bit ITU-T G.711 µ-law	Apple Computer",
  ULAW: "CCITT G.711 u-law 8-bit ITU-T G.711 µ-law",
  ALAW: "CCITT G.711 A-law 8-bit ITU-T G.711 A-law",
  FL32: "Float 32	IEEE 32-bit float "
};
class AIFFParser extends BasicParser_1$a.BasicParser {
  async parse() {
    if ((await this.tokenizer.readToken(iff.Header)).chunkID !== "FORM")
      throw new Error("Invalid Chunk-ID, expected 'FORM'");
    const A = await this.tokenizer.readToken(FourCC_1$8.FourCcToken);
    switch (A) {
      case "AIFF":
        this.metadata.setFormat("container", A), this.isCompressed = !1;
        break;
      case "AIFC":
        this.metadata.setFormat("container", "AIFF-C"), this.isCompressed = !0;
        break;
      default:
        throw Error("Unsupported AIFF type: " + A);
    }
    this.metadata.setFormat("lossless", !this.isCompressed);
    try {
      for (; !this.tokenizer.fileInfo.size || this.tokenizer.fileInfo.size - this.tokenizer.position >= iff.Header.len; ) {
        debug$k("Reading AIFF chunk at offset=" + this.tokenizer.position);
        const W = await this.tokenizer.readToken(iff.Header), X = 2 * Math.round(W.chunkSize / 2), J = await this.readData(W);
        await this.tokenizer.ignore(X - J);
      }
    } catch (W) {
      if (W instanceof strtok3$3.EndOfStreamError)
        debug$k("End-of-stream");
      else
        throw W;
    }
  }
  async readData(L) {
    var A;
    switch (L.chunkID) {
      case "COMM":
        const W = await this.tokenizer.readToken(new AiffToken.Common(L, this.isCompressed));
        return this.metadata.setFormat("bitsPerSample", W.sampleSize), this.metadata.setFormat("sampleRate", W.sampleRate), this.metadata.setFormat("numberOfChannels", W.numChannels), this.metadata.setFormat("numberOfSamples", W.numSampleFrames), this.metadata.setFormat("duration", W.numSampleFrames / W.sampleRate), this.metadata.setFormat("codec", (A = W.compressionName) !== null && A !== void 0 ? A : compressionTypes[W.compressionType]), L.chunkSize;
      case "ID3 ":
        const X = await this.tokenizer.readToken(new Token$n.Uint8ArrayType(L.chunkSize)), J = strtok3$3.fromBuffer(X);
        return await new ID3v2Parser_1$4.ID3v2Parser().parse(this.metadata, J, this.options), L.chunkSize;
      case "SSND":
        return this.metadata.format.duration && this.metadata.setFormat("bitrate", 8 * L.chunkSize / this.metadata.format.duration), 0;
      case "NAME":
      case "AUTH":
      case "(c) ":
      case "ANNO":
        return this.readTextChunk(L);
      default:
        return debug$k(`Ignore chunk id=${L.chunkID}, size=${L.chunkSize}`), 0;
    }
  }
  async readTextChunk(L) {
    return (await this.tokenizer.readToken(new Token$n.StringType(L.chunkSize, "ascii"))).split("\0").map((W) => W.trim()).filter((W) => W && W.length > 0).forEach((W) => {
      this.metadata.addTag("AIFF", L.chunkID, W.trim());
    }), L.chunkSize;
  }
}
AiffParser.AIFFParser = AIFFParser;
var AsfParser$1 = {}, GUID$1 = {};
Object.defineProperty(GUID$1, "__esModule", { value: !0 });
class GUID {
  static fromBin(L, A = 0) {
    return new GUID(this.decode(L, A));
  }
  /**
   * Decode GUID in format like "B503BF5F-2EA9-CF11-8EE3-00C00C205365"
   * @param objectId Binary GUID
   * @param offset Read offset in bytes, default 0
   * @returns GUID as dashed hexadecimal representation
   */
  static decode(L, A = 0) {
    return (L.readUInt32LE(A).toString(16) + "-" + L.readUInt16LE(A + 4).toString(16) + "-" + L.readUInt16LE(A + 6).toString(16) + "-" + L.readUInt16BE(A + 8).toString(16) + "-" + L.slice(A + 10, A + 16).toString("hex")).toUpperCase();
  }
  /**
   * Decode stream type
   * @param mediaType Media type GUID
   * @returns Media type
   */
  static decodeMediaType(L) {
    switch (L.str) {
      case GUID.AudioMedia.str:
        return "audio";
      case GUID.VideoMedia.str:
        return "video";
      case GUID.CommandMedia.str:
        return "command";
      case GUID.Degradable_JPEG_Media.str:
        return "degradable-jpeg";
      case GUID.FileTransferMedia.str:
        return "file-transfer";
      case GUID.BinaryMedia.str:
        return "binary";
    }
  }
  /**
   * Encode GUID
   * @param guid GUID like: "B503BF5F-2EA9-CF11-8EE3-00C00C205365"
   * @returns Encoded Binary GUID
   */
  static encode(L) {
    const A = Buffer.alloc(16);
    return A.writeUInt32LE(parseInt(L.slice(0, 8), 16), 0), A.writeUInt16LE(parseInt(L.slice(9, 13), 16), 4), A.writeUInt16LE(parseInt(L.slice(14, 18), 16), 6), Buffer.from(L.slice(19, 23), "hex").copy(A, 8), Buffer.from(L.slice(24), "hex").copy(A, 10), A;
  }
  constructor(L) {
    this.str = L;
  }
  equals(L) {
    return this.str === L.str;
  }
  toBin() {
    return GUID.encode(this.str);
  }
}
GUID.HeaderObject = new GUID("75B22630-668E-11CF-A6D9-00AA0062CE6C");
GUID.DataObject = new GUID("75B22636-668E-11CF-A6D9-00AA0062CE6C");
GUID.SimpleIndexObject = new GUID("33000890-E5B1-11CF-89F4-00A0C90349CB");
GUID.IndexObject = new GUID("D6E229D3-35DA-11D1-9034-00A0C90349BE");
GUID.MediaObjectIndexObject = new GUID("FEB103F8-12AD-4C64-840F-2A1D2F7AD48C");
GUID.TimecodeIndexObject = new GUID("3CB73FD0-0C4A-4803-953D-EDF7B6228F0C");
GUID.FilePropertiesObject = new GUID("8CABDCA1-A947-11CF-8EE4-00C00C205365");
GUID.StreamPropertiesObject = new GUID("B7DC0791-A9B7-11CF-8EE6-00C00C205365");
GUID.HeaderExtensionObject = new GUID("5FBF03B5-A92E-11CF-8EE3-00C00C205365");
GUID.CodecListObject = new GUID("86D15240-311D-11D0-A3A4-00A0C90348F6");
GUID.ScriptCommandObject = new GUID("1EFB1A30-0B62-11D0-A39B-00A0C90348F6");
GUID.MarkerObject = new GUID("F487CD01-A951-11CF-8EE6-00C00C205365");
GUID.BitrateMutualExclusionObject = new GUID("D6E229DC-35DA-11D1-9034-00A0C90349BE");
GUID.ErrorCorrectionObject = new GUID("75B22635-668E-11CF-A6D9-00AA0062CE6C");
GUID.ContentDescriptionObject = new GUID("75B22633-668E-11CF-A6D9-00AA0062CE6C");
GUID.ExtendedContentDescriptionObject = new GUID("D2D0A440-E307-11D2-97F0-00A0C95EA850");
GUID.ContentBrandingObject = new GUID("2211B3FA-BD23-11D2-B4B7-00A0C955FC6E");
GUID.StreamBitratePropertiesObject = new GUID("7BF875CE-468D-11D1-8D82-006097C9A2B2");
GUID.ContentEncryptionObject = new GUID("2211B3FB-BD23-11D2-B4B7-00A0C955FC6E");
GUID.ExtendedContentEncryptionObject = new GUID("298AE614-2622-4C17-B935-DAE07EE9289C");
GUID.DigitalSignatureObject = new GUID("2211B3FC-BD23-11D2-B4B7-00A0C955FC6E");
GUID.PaddingObject = new GUID("1806D474-CADF-4509-A4BA-9AABCB96AAE8");
GUID.ExtendedStreamPropertiesObject = new GUID("14E6A5CB-C672-4332-8399-A96952065B5A");
GUID.AdvancedMutualExclusionObject = new GUID("A08649CF-4775-4670-8A16-6E35357566CD");
GUID.GroupMutualExclusionObject = new GUID("D1465A40-5A79-4338-B71B-E36B8FD6C249");
GUID.StreamPrioritizationObject = new GUID("D4FED15B-88D3-454F-81F0-ED5C45999E24");
GUID.BandwidthSharingObject = new GUID("A69609E6-517B-11D2-B6AF-00C04FD908E9");
GUID.LanguageListObject = new GUID("7C4346A9-EFE0-4BFC-B229-393EDE415C85");
GUID.MetadataObject = new GUID("C5F8CBEA-5BAF-4877-8467-AA8C44FA4CCA");
GUID.MetadataLibraryObject = new GUID("44231C94-9498-49D1-A141-1D134E457054");
GUID.IndexParametersObject = new GUID("D6E229DF-35DA-11D1-9034-00A0C90349BE");
GUID.MediaObjectIndexParametersObject = new GUID("6B203BAD-3F11-48E4-ACA8-D7613DE2CFA7");
GUID.TimecodeIndexParametersObject = new GUID("F55E496D-9797-4B5D-8C8B-604DFE9BFB24");
GUID.CompatibilityObject = new GUID("26F18B5D-4584-47EC-9F5F-0E651F0452C9");
GUID.AdvancedContentEncryptionObject = new GUID("43058533-6981-49E6-9B74-AD12CB86D58C");
GUID.AudioMedia = new GUID("F8699E40-5B4D-11CF-A8FD-00805F5C442B");
GUID.VideoMedia = new GUID("BC19EFC0-5B4D-11CF-A8FD-00805F5C442B");
GUID.CommandMedia = new GUID("59DACFC0-59E6-11D0-A3AC-00A0C90348F6");
GUID.JFIF_Media = new GUID("B61BE100-5B4E-11CF-A8FD-00805F5C442B");
GUID.Degradable_JPEG_Media = new GUID("35907DE0-E415-11CF-A917-00805F5C442B");
GUID.FileTransferMedia = new GUID("91BD222C-F21C-497A-8B6D-5AA86BFC0185");
GUID.BinaryMedia = new GUID("3AFB65E2-47EF-40F2-AC2C-70A90D71D343");
GUID.ASF_Index_Placeholder_Object = new GUID("D9AADE20-7C17-4F9C-BC28-8555DD98E2A2");
GUID$1.default = GUID;
var AsfObject$1 = {}, AsfUtil$1 = {};
Object.defineProperty(AsfUtil$1, "__esModule", { value: !0 });
AsfUtil$1.AsfUtil = void 0;
const Token$m = lib$1, util$7 = Util;
class AsfUtil {
  static getParserForAttr(L) {
    return AsfUtil.attributeParsers[L];
  }
  static parseUnicodeAttr(L) {
    return util$7.stripNulls(util$7.decodeString(L, "utf16le"));
  }
  static parseByteArrayAttr(L) {
    return Buffer.from(L);
  }
  static parseBoolAttr(L, A = 0) {
    return AsfUtil.parseWordAttr(L, A) === 1;
  }
  static parseDWordAttr(L, A = 0) {
    return L.readUInt32LE(A);
  }
  static parseQWordAttr(L, A = 0) {
    return Token$m.UINT64_LE.get(L, A);
  }
  static parseWordAttr(L, A = 0) {
    return L.readUInt16LE(A);
  }
}
AsfUtil.attributeParsers = [
  AsfUtil.parseUnicodeAttr,
  AsfUtil.parseByteArrayAttr,
  AsfUtil.parseBoolAttr,
  AsfUtil.parseDWordAttr,
  AsfUtil.parseQWordAttr,
  AsfUtil.parseWordAttr,
  AsfUtil.parseByteArrayAttr
];
AsfUtil$1.AsfUtil = AsfUtil;
(function(C) {
  Object.defineProperty(C, "__esModule", { value: !0 }), C.WmPictureToken = C.MetadataLibraryObjectState = C.MetadataObjectState = C.ExtendedStreamPropertiesObjectState = C.ExtendedContentDescriptionObjectState = C.ContentDescriptionObjectState = C.readCodecEntries = C.HeaderExtensionObject = C.StreamPropertiesObject = C.FilePropertiesObject = C.IgnoreObjectState = C.State = C.HeaderObjectToken = C.TopLevelHeaderObjectToken = C.DataType = void 0;
  const L = Util, A = lib$1, W = GUID$1, X = AsfUtil$1, J = ID3v2Token;
  (function(Le) {
    Le[Le.UnicodeString = 0] = "UnicodeString", Le[Le.ByteArray = 1] = "ByteArray", Le[Le.Bool = 2] = "Bool", Le[Le.DWord = 3] = "DWord", Le[Le.QWord = 4] = "QWord", Le[Le.Word = 5] = "Word";
  })(C.DataType || (C.DataType = {})), C.TopLevelHeaderObjectToken = {
    len: 30,
    get: (Le, ve) => ({
      objectId: W.default.fromBin(new A.BufferType(16).get(Le, ve)),
      objectSize: Number(A.UINT64_LE.get(Le, ve + 16)),
      numberOfHeaderObjects: A.UINT32_LE.get(Le, ve + 24)
      // Reserved: 2 bytes
    })
  }, C.HeaderObjectToken = {
    len: 24,
    get: (Le, ve) => ({
      objectId: W.default.fromBin(new A.BufferType(16).get(Le, ve)),
      objectSize: Number(A.UINT64_LE.get(Le, ve + 16))
    })
  };
  class te {
    constructor(ve) {
      this.len = Number(ve.objectSize) - C.HeaderObjectToken.len;
    }
    postProcessTag(ve, De, Ue, Fe) {
      if (De === "WM/Picture")
        ve.push({ id: De, value: Ae.fromBuffer(Fe) });
      else {
        const We = X.AsfUtil.getParserForAttr(Ue);
        if (!We)
          throw new Error("unexpected value headerType: " + Ue);
        ve.push({ id: De, value: We(Fe) });
      }
    }
  }
  C.State = te;
  class oe extends te {
    constructor(ve) {
      super(ve);
    }
    get(ve, De) {
      return null;
    }
  }
  C.IgnoreObjectState = oe;
  class ne extends te {
    constructor(ve) {
      super(ve);
    }
    get(ve, De) {
      return {
        fileId: W.default.fromBin(ve, De),
        fileSize: A.UINT64_LE.get(ve, De + 16),
        creationDate: A.UINT64_LE.get(ve, De + 24),
        dataPacketsCount: A.UINT64_LE.get(ve, De + 32),
        playDuration: A.UINT64_LE.get(ve, De + 40),
        sendDuration: A.UINT64_LE.get(ve, De + 48),
        preroll: A.UINT64_LE.get(ve, De + 56),
        flags: {
          broadcast: L.getBit(ve, De + 64, 24),
          seekable: L.getBit(ve, De + 64, 25)
        },
        // flagsNumeric: Token.UINT32_LE.get(buf, off + 64),
        minimumDataPacketSize: A.UINT32_LE.get(ve, De + 68),
        maximumDataPacketSize: A.UINT32_LE.get(ve, De + 72),
        maximumBitrate: A.UINT32_LE.get(ve, De + 76)
      };
    }
  }
  ne.guid = W.default.FilePropertiesObject, C.FilePropertiesObject = ne;
  class re extends te {
    constructor(ve) {
      super(ve);
    }
    get(ve, De) {
      return {
        streamType: W.default.decodeMediaType(W.default.fromBin(ve, De)),
        errorCorrectionType: W.default.fromBin(ve, De + 8)
        // ToDo
      };
    }
  }
  re.guid = W.default.StreamPropertiesObject, C.StreamPropertiesObject = re;
  class ce {
    constructor() {
      this.len = 22;
    }
    get(ve, De) {
      return {
        reserved1: W.default.fromBin(ve, De),
        reserved2: ve.readUInt16LE(De + 16),
        extensionDataSize: ve.readUInt32LE(De + 18)
      };
    }
  }
  ce.guid = W.default.HeaderExtensionObject, C.HeaderExtensionObject = ce;
  const ue = {
    len: 20,
    get: (Le, ve) => ({
      entryCount: Le.readUInt16LE(ve + 16)
    })
  };
  async function de(Le) {
    const ve = await Le.readNumber(A.UINT16_LE);
    return (await Le.readToken(new A.StringType(ve * 2, "utf16le"))).replace("\0", "");
  }
  async function be(Le) {
    const ve = await Le.readToken(ue), De = [];
    for (let Ue = 0; Ue < ve.entryCount; ++Ue)
      De.push(await me(Le));
    return De;
  }
  C.readCodecEntries = be;
  async function pe(Le) {
    const ve = await Le.readNumber(A.UINT16_LE), De = Buffer.alloc(ve);
    return await Le.readBuffer(De), De;
  }
  async function me(Le) {
    const ve = await Le.readNumber(A.UINT16_LE);
    return {
      type: {
        videoCodec: (ve & 1) === 1,
        audioCodec: (ve & 2) === 2
      },
      codecName: await de(Le),
      description: await de(Le),
      information: await pe(Le)
    };
  }
  class Me extends te {
    constructor(ve) {
      super(ve);
    }
    get(ve, De) {
      const Ue = [];
      let Fe = De + 10;
      for (let We = 0; We < Me.contentDescTags.length; ++We) {
        const Ke = ve.readUInt16LE(De + We * 2);
        if (Ke > 0) {
          const it = Me.contentDescTags[We], Qe = Fe + Ke;
          Ue.push({ id: it, value: X.AsfUtil.parseUnicodeAttr(ve.slice(Fe, Qe)) }), Fe = Qe;
        }
      }
      return Ue;
    }
  }
  Me.guid = W.default.ContentDescriptionObject, Me.contentDescTags = ["Title", "Author", "Copyright", "Description", "Rating"], C.ContentDescriptionObjectState = Me;
  class he extends te {
    constructor(ve) {
      super(ve);
    }
    get(ve, De) {
      const Ue = [], Fe = ve.readUInt16LE(De);
      let We = De + 2;
      for (let Ke = 0; Ke < Fe; Ke += 1) {
        const it = ve.readUInt16LE(We);
        We += 2;
        const Qe = X.AsfUtil.parseUnicodeAttr(ve.slice(We, We + it));
        We += it;
        const vt = ve.readUInt16LE(We);
        We += 2;
        const Ct = ve.readUInt16LE(We);
        We += 2;
        const Tt = ve.slice(We, We + Ct);
        We += Ct, this.postProcessTag(Ue, Qe, vt, Tt);
      }
      return Ue;
    }
  }
  he.guid = W.default.ExtendedContentDescriptionObject, C.ExtendedContentDescriptionObjectState = he;
  class ge extends te {
    constructor(ve) {
      super(ve);
    }
    get(ve, De) {
      return {
        startTime: A.UINT64_LE.get(ve, De),
        endTime: A.UINT64_LE.get(ve, De + 8),
        dataBitrate: ve.readInt32LE(De + 12),
        bufferSize: ve.readInt32LE(De + 16),
        initialBufferFullness: ve.readInt32LE(De + 20),
        alternateDataBitrate: ve.readInt32LE(De + 24),
        alternateBufferSize: ve.readInt32LE(De + 28),
        alternateInitialBufferFullness: ve.readInt32LE(De + 32),
        maximumObjectSize: ve.readInt32LE(De + 36),
        flags: {
          reliableFlag: L.getBit(ve, De + 40, 0),
          seekableFlag: L.getBit(ve, De + 40, 1),
          resendLiveCleanpointsFlag: L.getBit(ve, De + 40, 2)
        },
        // flagsNumeric: Token.UINT32_LE.get(buf, off + 64),
        streamNumber: ve.readInt16LE(De + 42),
        streamLanguageId: ve.readInt16LE(De + 44),
        averageTimePerFrame: ve.readInt32LE(De + 52),
        streamNameCount: ve.readInt32LE(De + 54),
        payloadExtensionSystems: ve.readInt32LE(De + 56),
        streamNames: [],
        streamPropertiesObject: null
      };
    }
  }
  ge.guid = W.default.ExtendedStreamPropertiesObject, C.ExtendedStreamPropertiesObjectState = ge;
  class Ce extends te {
    constructor(ve) {
      super(ve);
    }
    get(ve, De) {
      const Ue = [], Fe = Buffer.from(ve), We = Fe.readUInt16LE(De);
      let Ke = De + 2;
      for (let it = 0; it < We; it += 1) {
        Ke += 4;
        const Qe = Fe.readUInt16LE(Ke);
        Ke += 2;
        const vt = Fe.readUInt16LE(Ke);
        Ke += 2;
        const Ct = Fe.readUInt32LE(Ke);
        Ke += 4;
        const Tt = X.AsfUtil.parseUnicodeAttr(Fe.slice(Ke, Ke + Qe));
        Ke += Qe;
        const St = Fe.slice(Ke, Ke + Ct);
        Ke += Ct, this.postProcessTag(Ue, Tt, vt, St);
      }
      return Ue;
    }
  }
  Ce.guid = W.default.MetadataObject, C.MetadataObjectState = Ce;
  class Se extends Ce {
    constructor(ve) {
      super(ve);
    }
  }
  Se.guid = W.default.MetadataLibraryObject, C.MetadataLibraryObjectState = Se;
  class Ae {
    static fromBase64(ve) {
      return this.fromBuffer(Buffer.from(ve, "base64"));
    }
    static fromBuffer(ve) {
      return new Ae(ve.length).get(ve, 0);
    }
    constructor(ve) {
      this.len = ve;
    }
    get(ve, De) {
      const Ue = ve.readUInt8(De++), Fe = ve.readInt32LE(De);
      let We = 5;
      for (; ve.readUInt16BE(We) !== 0; )
        We += 2;
      const Ke = ve.slice(5, We).toString("utf16le");
      for (; ve.readUInt16BE(We) !== 0; )
        We += 2;
      const it = ve.slice(5, We).toString("utf16le");
      return {
        type: J.AttachedPictureType[Ue],
        format: Ke,
        description: it,
        size: Fe,
        data: ve.slice(We + 4)
      };
    }
  }
  C.WmPictureToken = Ae;
})(AsfObject$1);
Object.defineProperty(AsfParser$1, "__esModule", { value: !0 });
AsfParser$1.AsfParser = void 0;
const debug_1$j = browserExports, type_1$1 = type$1, GUID_1 = GUID$1, AsfObject = AsfObject$1, BasicParser_1$9 = BasicParser$1, debug$j = (0, debug_1$j.default)("music-metadata:parser:ASF"), headerType = "asf";
class AsfParser extends BasicParser_1$9.BasicParser {
  async parse() {
    const L = await this.tokenizer.readToken(AsfObject.TopLevelHeaderObjectToken);
    if (!L.objectId.equals(GUID_1.default.HeaderObject))
      throw new Error("expected asf header; but was not found; got: " + L.objectId.str);
    try {
      await this.parseObjectHeader(L.numberOfHeaderObjects);
    } catch (A) {
      debug$j("Error while parsing ASF: %s", A);
    }
  }
  async parseObjectHeader(L) {
    let A;
    do {
      const W = await this.tokenizer.readToken(AsfObject.HeaderObjectToken);
      switch (debug$j("header GUID=%s", W.objectId.str), W.objectId.str) {
        case AsfObject.FilePropertiesObject.guid.str:
          const X = await this.tokenizer.readToken(new AsfObject.FilePropertiesObject(W));
          this.metadata.setFormat("duration", Number(X.playDuration / BigInt(1e3)) / 1e4 - Number(X.preroll) / 1e3), this.metadata.setFormat("bitrate", X.maximumBitrate);
          break;
        case AsfObject.StreamPropertiesObject.guid.str:
          const J = await this.tokenizer.readToken(new AsfObject.StreamPropertiesObject(W));
          this.metadata.setFormat("container", "ASF/" + J.streamType);
          break;
        case AsfObject.HeaderExtensionObject.guid.str:
          const te = await this.tokenizer.readToken(new AsfObject.HeaderExtensionObject());
          await this.parseExtensionObject(te.extensionDataSize);
          break;
        case AsfObject.ContentDescriptionObjectState.guid.str:
          A = await this.tokenizer.readToken(new AsfObject.ContentDescriptionObjectState(W)), this.addTags(A);
          break;
        case AsfObject.ExtendedContentDescriptionObjectState.guid.str:
          A = await this.tokenizer.readToken(new AsfObject.ExtendedContentDescriptionObjectState(W)), this.addTags(A);
          break;
        case GUID_1.default.CodecListObject.str:
          const oe = await AsfObject.readCodecEntries(this.tokenizer);
          oe.forEach((re) => {
            this.metadata.addStreamInfo({
              type: re.type.videoCodec ? type_1$1.TrackType.video : type_1$1.TrackType.audio,
              codecName: re.codecName
            });
          });
          const ne = oe.filter((re) => re.type.audioCodec).map((re) => re.codecName).join("/");
          this.metadata.setFormat("codec", ne);
          break;
        case GUID_1.default.StreamBitratePropertiesObject.str:
          await this.tokenizer.ignore(W.objectSize - AsfObject.HeaderObjectToken.len);
          break;
        case GUID_1.default.PaddingObject.str:
          debug$j("Padding: %s bytes", W.objectSize - AsfObject.HeaderObjectToken.len), await this.tokenizer.ignore(W.objectSize - AsfObject.HeaderObjectToken.len);
          break;
        default:
          this.metadata.addWarning("Ignore ASF-Object-GUID: " + W.objectId.str), debug$j("Ignore ASF-Object-GUID: %s", W.objectId.str), await this.tokenizer.readToken(new AsfObject.IgnoreObjectState(W));
      }
    } while (--L);
  }
  addTags(L) {
    L.forEach((A) => {
      this.metadata.addTag(headerType, A.id, A.value);
    });
  }
  async parseExtensionObject(L) {
    do {
      const A = await this.tokenizer.readToken(AsfObject.HeaderObjectToken), W = A.objectSize - AsfObject.HeaderObjectToken.len;
      switch (A.objectId.str) {
        case AsfObject.ExtendedStreamPropertiesObjectState.guid.str:
          await this.tokenizer.readToken(new AsfObject.ExtendedStreamPropertiesObjectState(A));
          break;
        case AsfObject.MetadataObjectState.guid.str:
          const X = await this.tokenizer.readToken(new AsfObject.MetadataObjectState(A));
          this.addTags(X);
          break;
        case AsfObject.MetadataLibraryObjectState.guid.str:
          const J = await this.tokenizer.readToken(new AsfObject.MetadataLibraryObjectState(A));
          this.addTags(J);
          break;
        case GUID_1.default.PaddingObject.str:
          await this.tokenizer.ignore(W);
          break;
        case GUID_1.default.CompatibilityObject.str:
          this.tokenizer.ignore(W);
          break;
        case GUID_1.default.ASF_Index_Placeholder_Object.str:
          await this.tokenizer.ignore(W);
          break;
        default:
          this.metadata.addWarning("Ignore ASF-Object-GUID: " + A.objectId.str), await this.tokenizer.readToken(new AsfObject.IgnoreObjectState(A));
          break;
      }
      L -= A.objectSize;
    } while (L > 0);
  }
}
AsfParser$1.AsfParser = AsfParser;
var FlacParser$1 = {}, Vorbis = {};
Object.defineProperty(Vorbis, "__esModule", { value: !0 });
Vorbis.IdentificationHeader = Vorbis.CommonHeader = Vorbis.VorbisPictureToken = void 0;
const Token$l = lib$1, ID3v2Token_1$1 = ID3v2Token;
class VorbisPictureToken {
  static fromBase64(L) {
    return this.fromBuffer(Buffer.from(L, "base64"));
  }
  static fromBuffer(L) {
    return new VorbisPictureToken(L.length).get(L, 0);
  }
  constructor(L) {
    this.len = L;
  }
  get(L, A) {
    const W = ID3v2Token_1$1.AttachedPictureType[Token$l.UINT32_BE.get(L, A)], X = Token$l.UINT32_BE.get(L, A += 4), J = L.toString("utf-8", A += 4, A + X), te = Token$l.UINT32_BE.get(L, A += X), oe = L.toString("utf-8", A += 4, A + te), ne = Token$l.UINT32_BE.get(L, A += te), re = Token$l.UINT32_BE.get(L, A += 4), ce = Token$l.UINT32_BE.get(L, A += 4), ue = Token$l.UINT32_BE.get(L, A += 4), de = Token$l.UINT32_BE.get(L, A += 4), be = Buffer.from(L.slice(A += 4, A + de));
    return {
      type: W,
      format: J,
      description: oe,
      width: ne,
      height: re,
      colour_depth: ce,
      indexed_color: ue,
      data: be
    };
  }
}
Vorbis.VorbisPictureToken = VorbisPictureToken;
Vorbis.CommonHeader = {
  len: 7,
  get: (C, L) => ({
    packetType: C.readUInt8(L),
    vorbis: new Token$l.StringType(6, "ascii").get(C, L + 1)
  })
};
Vorbis.IdentificationHeader = {
  len: 23,
  get: (C, L) => {
    const A = new DataView(C.buffer, C.byteOffset);
    return {
      version: A.getUint32(L + 0, !0),
      channelMode: A.getUint8(L + 4),
      sampleRate: A.getUint32(L + 5, !0),
      bitrateMax: A.getUint32(L + 9, !0),
      bitrateNominal: A.getUint32(L + 13, !0),
      bitrateMin: A.getUint32(L + 17, !0)
    };
  }
};
var AbstractID3Parser$1 = {};
Object.defineProperty(AbstractID3Parser$1, "__esModule", { value: !0 });
AbstractID3Parser$1.AbstractID3Parser = void 0;
const core_1$2 = core$1, debug_1$i = browserExports, ID3v2Token_1 = ID3v2Token, ID3v2Parser_1$3 = ID3v2Parser$1, ID3v1Parser_1$2 = ID3v1Parser, BasicParser_1$8 = BasicParser$1, debug$i = (0, debug_1$i.default)("music-metadata:parser:ID3");
class AbstractID3Parser extends BasicParser_1$8.BasicParser {
  constructor() {
    super(...arguments), this.id3parser = new ID3v2Parser_1$3.ID3v2Parser();
  }
  static async startsWithID3v2Header(L) {
    return (await L.peekToken(ID3v2Token_1.ID3v2Header)).fileIdentifier === "ID3";
  }
  async parse() {
    try {
      await this.parseID3v2();
    } catch (L) {
      if (L instanceof core_1$2.EndOfStreamError)
        debug$i("End-of-stream");
      else
        throw L;
    }
  }
  finalize() {
  }
  async parseID3v2() {
    await this.tryReadId3v2Headers(), debug$i("End of ID3v2 header, go to MPEG-parser: pos=%s", this.tokenizer.position), await this.postId3v2Parse(), this.options.skipPostHeaders && this.metadata.hasAny() ? this.finalize() : (await new ID3v1Parser_1$2.ID3v1Parser().init(this.metadata, this.tokenizer, this.options).parse(), this.finalize());
  }
  async tryReadId3v2Headers() {
    if ((await this.tokenizer.peekToken(ID3v2Token_1.ID3v2Header)).fileIdentifier === "ID3")
      return debug$i("Found ID3v2 header, pos=%s", this.tokenizer.position), await this.id3parser.parse(this.metadata, this.tokenizer, this.options), this.tryReadId3v2Headers();
  }
}
AbstractID3Parser$1.AbstractID3Parser = AbstractID3Parser;
var VorbisParser$1 = {}, VorbisDecoder$1 = {};
Object.defineProperty(VorbisDecoder$1, "__esModule", { value: !0 });
VorbisDecoder$1.VorbisDecoder = void 0;
const Token$k = lib$1;
class VorbisDecoder {
  constructor(L, A) {
    this.data = L, this.offset = A;
  }
  readInt32() {
    const L = Token$k.UINT32_LE.get(this.data, this.offset);
    return this.offset += 4, L;
  }
  readStringUtf8() {
    const L = this.readInt32(), A = Buffer.from(this.data).toString("utf-8", this.offset, this.offset + L);
    return this.offset += L, A;
  }
  parseUserComment() {
    const L = this.offset, A = this.readStringUtf8(), W = A.indexOf("=");
    return {
      key: A.slice(0, W).toUpperCase(),
      value: A.slice(W + 1),
      len: this.offset - L
    };
  }
}
VorbisDecoder$1.VorbisDecoder = VorbisDecoder;
Object.defineProperty(VorbisParser$1, "__esModule", { value: !0 });
VorbisParser$1.VorbisParser = void 0;
const Token$j = lib$1, debug_1$h = browserExports, VorbisDecoder_1$1 = VorbisDecoder$1, Vorbis_1$1 = Vorbis, debug$h = (0, debug_1$h.default)("music-metadata:parser:ogg:vorbis1");
class VorbisParser {
  constructor(L, A) {
    this.metadata = L, this.options = A, this.pageSegments = [];
  }
  /**
   * Vorbis 1 parser
   * @param header Ogg Page Header
   * @param pageData Page data
   */
  parsePage(L, A) {
    if (L.headerType.firstPage)
      this.parseFirstPage(L, A);
    else {
      if (L.headerType.continued) {
        if (this.pageSegments.length === 0)
          throw new Error("Cannot continue on previous page");
        this.pageSegments.push(A);
      }
      if (L.headerType.lastPage || !L.headerType.continued) {
        if (this.pageSegments.length > 0) {
          const W = Buffer.concat(this.pageSegments);
          this.parseFullPage(W);
        }
        this.pageSegments = L.headerType.lastPage ? [] : [A];
      }
    }
    L.headerType.lastPage && this.calculateDuration(L);
  }
  flush() {
    this.parseFullPage(Buffer.concat(this.pageSegments));
  }
  parseUserComment(L, A) {
    const X = new VorbisDecoder_1$1.VorbisDecoder(L, A).parseUserComment();
    return this.addTag(X.key, X.value), X.len;
  }
  addTag(L, A) {
    if (L === "METADATA_BLOCK_PICTURE" && typeof A == "string") {
      if (this.options.skipCovers) {
        debug$h("Ignore picture");
        return;
      }
      A = Vorbis_1$1.VorbisPictureToken.fromBase64(A), debug$h(`Push picture: id=${L}, format=${A.format}`);
    } else
      debug$h(`Push tag: id=${L}, value=${A}`);
    this.metadata.addTag("vorbis", L, A);
  }
  calculateDuration(L) {
    this.metadata.format.sampleRate && L.absoluteGranulePosition >= 0 && (this.metadata.setFormat("numberOfSamples", L.absoluteGranulePosition), this.metadata.setFormat("duration", this.metadata.format.numberOfSamples / this.metadata.format.sampleRate));
  }
  /**
   * Parse first Ogg/Vorbis page
   * @param {IPageHeader} header
   * @param {Buffer} pageData
   */
  parseFirstPage(L, A) {
    this.metadata.setFormat("codec", "Vorbis I"), debug$h("Parse first page");
    const W = Vorbis_1$1.CommonHeader.get(A, 0);
    if (W.vorbis !== "vorbis")
      throw new Error("Metadata does not look like Vorbis");
    if (W.packetType === 1) {
      const X = Vorbis_1$1.IdentificationHeader.get(A, Vorbis_1$1.CommonHeader.len);
      this.metadata.setFormat("sampleRate", X.sampleRate), this.metadata.setFormat("bitrate", X.bitrateNominal), this.metadata.setFormat("numberOfChannels", X.channelMode), debug$h("sample-rate=%s[hz], bitrate=%s[b/s], channel-mode=%s", X.sampleRate, X.bitrateNominal, X.channelMode);
    } else
      throw new Error("First Ogg page should be type 1: the identification header");
  }
  parseFullPage(L) {
    const A = Vorbis_1$1.CommonHeader.get(L, 0);
    switch (debug$h("Parse full page: type=%s, byteLength=%s", A.packetType, L.byteLength), A.packetType) {
      case 3:
        return this.parseUserCommentList(L, Vorbis_1$1.CommonHeader.len);
    }
  }
  /**
   * Ref: https://xiph.org/vorbis/doc/Vorbis_I_spec.html#x1-840005.2
   */
  parseUserCommentList(L, A) {
    const W = Token$j.UINT32_LE.get(L, A);
    A += 4, A += W;
    let X = Token$j.UINT32_LE.get(L, A);
    for (A += 4; X-- > 0; )
      A += this.parseUserComment(L, A);
  }
}
VorbisParser$1.VorbisParser = VorbisParser;
Object.defineProperty(FlacParser$1, "__esModule", { value: !0 });
FlacParser$1.FlacParser = void 0;
const token_types_1$1 = lib$1, debug_1$g = browserExports, util$6 = Util, Vorbis_1 = Vorbis, AbstractID3Parser_1$3 = AbstractID3Parser$1, FourCC_1$7 = FourCC, VorbisParser_1$3 = VorbisParser$1, VorbisDecoder_1 = VorbisDecoder$1, debug$g = (0, debug_1$g.default)("music-metadata:parser:FLAC");
var BlockType;
(function(C) {
  C[C.STREAMINFO = 0] = "STREAMINFO", C[C.PADDING = 1] = "PADDING", C[C.APPLICATION = 2] = "APPLICATION", C[C.SEEKTABLE = 3] = "SEEKTABLE", C[C.VORBIS_COMMENT = 4] = "VORBIS_COMMENT", C[C.CUESHEET = 5] = "CUESHEET", C[C.PICTURE = 6] = "PICTURE";
})(BlockType || (BlockType = {}));
class FlacParser extends AbstractID3Parser_1$3.AbstractID3Parser {
  constructor() {
    super(...arguments), this.padding = 0;
  }
  /**
   * Initialize parser with output (metadata), input (tokenizer) & parsing options (options).
   * @param {INativeMetadataCollector} metadata Output
   * @param {ITokenizer} tokenizer Input
   * @param {IOptions} options Parsing options
   */
  init(L, A, W) {
    return super.init(L, A, W), this.vorbisParser = new VorbisParser_1$3.VorbisParser(L, W), this;
  }
  async postId3v2Parse() {
    if ((await this.tokenizer.readToken(FourCC_1$7.FourCcToken)).toString() !== "fLaC")
      throw new Error("Invalid FLAC preamble");
    let A;
    do
      A = await this.tokenizer.readToken(Metadata.BlockHeader), await this.parseDataBlock(A);
    while (!A.lastBlock);
    if (this.tokenizer.fileInfo.size && this.metadata.format.duration) {
      const W = this.tokenizer.fileInfo.size - this.tokenizer.position;
      this.metadata.setFormat("bitrate", 8 * W / this.metadata.format.duration);
    }
  }
  parseDataBlock(L) {
    switch (debug$g(`blockHeader type=${L.type}, length=${L.length}`), L.type) {
      case BlockType.STREAMINFO:
        return this.parseBlockStreamInfo(L.length);
      case BlockType.PADDING:
        this.padding += L.length;
        break;
      case BlockType.APPLICATION:
        break;
      case BlockType.SEEKTABLE:
        break;
      case BlockType.VORBIS_COMMENT:
        return this.parseComment(L.length);
      case BlockType.CUESHEET:
        break;
      case BlockType.PICTURE:
        return this.parsePicture(L.length).then();
      default:
        this.metadata.addWarning("Unknown block type: " + L.type);
    }
    return this.tokenizer.ignore(L.length).then();
  }
  /**
   * Parse STREAMINFO
   */
  async parseBlockStreamInfo(L) {
    if (L !== Metadata.BlockStreamInfo.len)
      throw new Error("Unexpected block-stream-info length");
    const A = await this.tokenizer.readToken(Metadata.BlockStreamInfo);
    this.metadata.setFormat("container", "FLAC"), this.metadata.setFormat("codec", "FLAC"), this.metadata.setFormat("lossless", !0), this.metadata.setFormat("numberOfChannels", A.channels), this.metadata.setFormat("bitsPerSample", A.bitsPerSample), this.metadata.setFormat("sampleRate", A.sampleRate), A.totalSamples > 0 && this.metadata.setFormat("duration", A.totalSamples / A.sampleRate);
  }
  /**
   * Parse VORBIS_COMMENT
   * Ref: https://www.xiph.org/vorbis/doc/Vorbis_I_spec.html#x1-640004.2.3
   */
  async parseComment(L) {
    const A = await this.tokenizer.readToken(new token_types_1$1.Uint8ArrayType(L)), W = new VorbisDecoder_1.VorbisDecoder(A, 0);
    W.readStringUtf8();
    const X = W.readInt32();
    for (let J = 0; J < X; J++) {
      const te = W.parseUserComment();
      this.vorbisParser.addTag(te.key, te.value);
    }
  }
  async parsePicture(L) {
    if (this.options.skipCovers)
      return this.tokenizer.ignore(L);
    {
      const A = await this.tokenizer.readToken(new Vorbis_1.VorbisPictureToken(L));
      this.vorbisParser.addTag("METADATA_BLOCK_PICTURE", A);
    }
  }
}
FlacParser$1.FlacParser = FlacParser;
class Metadata {
}
Metadata.BlockHeader = {
  len: 4,
  get: (C, L) => ({
    lastBlock: util$6.getBit(C, L, 7),
    type: util$6.getBitAllignedNumber(C, L, 1, 7),
    length: token_types_1$1.UINT24_BE.get(C, L + 1)
  })
};
Metadata.BlockStreamInfo = {
  len: 34,
  get: (C, L) => ({
    // The minimum block size (in samples) used in the stream.
    minimumBlockSize: token_types_1$1.UINT16_BE.get(C, L),
    // The maximum block size (in samples) used in the stream.
    // (Minimum blocksize == maximum blocksize) implies a fixed-blocksize stream.
    maximumBlockSize: token_types_1$1.UINT16_BE.get(C, L + 2) / 1e3,
    // The minimum frame size (in bytes) used in the stream.
    // May be 0 to imply the value is not known.
    minimumFrameSize: token_types_1$1.UINT24_BE.get(C, L + 4),
    // The maximum frame size (in bytes) used in the stream.
    // May be 0 to imply the value is not known.
    maximumFrameSize: token_types_1$1.UINT24_BE.get(C, L + 7),
    // Sample rate in Hz. Though 20 bits are available,
    // the maximum sample rate is limited by the structure of frame headers to 655350Hz.
    // Also, a value of 0 is invalid.
    sampleRate: token_types_1$1.UINT24_BE.get(C, L + 10) >> 4,
    // probably slower: sampleRate: common.getBitAllignedNumber(buf, off + 10, 0, 20),
    // (number of channels)-1. FLAC supports from 1 to 8 channels
    channels: util$6.getBitAllignedNumber(C, L + 12, 4, 3) + 1,
    // bits per sample)-1.
    // FLAC supports from 4 to 32 bits per sample. Currently the reference encoder and decoders only support up to 24 bits per sample.
    bitsPerSample: util$6.getBitAllignedNumber(C, L + 12, 7, 5) + 1,
    // Total samples in stream.
    // 'Samples' means inter-channel sample, i.e. one second of 44.1Khz audio will have 44100 samples regardless of the number of channels.
    // A value of zero here means the number of total samples is unknown.
    totalSamples: util$6.getBitAllignedNumber(C, L + 13, 4, 36),
    // the MD5 hash of the file (see notes for usage... it's a littly tricky)
    fileMD5: new token_types_1$1.Uint8ArrayType(16).get(C, L + 18)
  })
};
var MP4Parser$1 = {}, Atom$1 = {}, AtomToken$2 = {};
(function(C) {
  Object.defineProperty(C, "__esModule", { value: !0 }), C.ChapterText = C.StcoAtom = C.StszAtom = C.StscAtom = C.SampleToChunkToken = C.SttsAtom = C.TimeToSampleToken = C.SoundSampleDescriptionV0 = C.SoundSampleDescriptionVersion = C.StsdAtom = C.TrackHeaderAtom = C.NameAtom = C.DataAtom = C.MvhdAtom = C.MdhdAtom = C.FixedLengthAtom = C.mhdr = C.tkhd = C.ftyp = C.ExtendedSize = C.Header = void 0;
  const L = lib$1, A = browserExports, W = FourCC, X = (0, A.default)("music-metadata:parser:MP4:atom");
  C.Header = {
    len: 8,
    get: (Le, ve) => {
      const De = L.UINT32_BE.get(Le, ve);
      if (De < 0)
        throw new Error("Invalid atom header length");
      return {
        length: BigInt(De),
        name: new L.StringType(4, "binary").get(Le, ve + 4)
      };
    },
    put: (Le, ve, De) => (L.UINT32_BE.put(Le, ve, Number(De.length)), W.FourCcToken.put(Le, ve + 4, De.name))
  }, C.ExtendedSize = L.UINT64_BE, C.ftyp = {
    len: 4,
    get: (Le, ve) => ({
      type: new L.StringType(4, "ascii").get(Le, ve)
    })
  }, C.tkhd = {
    len: 4,
    get: (Le, ve) => ({
      type: new L.StringType(4, "ascii").get(Le, ve)
    })
  }, C.mhdr = {
    len: 8,
    get: (Le, ve) => ({
      version: L.UINT8.get(Le, ve),
      flags: L.UINT24_BE.get(Le, ve + 1),
      nextItemID: L.UINT32_BE.get(Le, ve + 4)
    })
  };
  class J {
    /**
     *
     * @param {number} len Length as specified in the size field
     * @param {number} expLen Total length of sum of specified fields in the standard
     */
    constructor(ve, De, Ue) {
      if (this.len = ve, ve < De)
        throw new Error(`Atom ${Ue} expected to be ${De}, but specifies ${ve} bytes long.`);
      ve > De && X(`Warning: atom ${Ue} expected to be ${De}, but was actually ${ve} bytes long.`);
    }
  }
  C.FixedLengthAtom = J;
  const te = {
    len: 4,
    get: (Le, ve) => {
      const De = L.UINT32_BE.get(Le, ve) - 2082844800;
      return new Date(De * 1e3);
    }
  };
  class oe extends J {
    constructor(ve) {
      super(ve, 24, "mdhd"), this.len = ve;
    }
    get(ve, De) {
      return {
        version: L.UINT8.get(ve, De + 0),
        flags: L.UINT24_BE.get(ve, De + 1),
        creationTime: te.get(ve, De + 4),
        modificationTime: te.get(ve, De + 8),
        timeScale: L.UINT32_BE.get(ve, De + 12),
        duration: L.UINT32_BE.get(ve, De + 16),
        language: L.UINT16_BE.get(ve, De + 20),
        quality: L.UINT16_BE.get(ve, De + 22)
      };
    }
  }
  C.MdhdAtom = oe;
  class ne extends J {
    constructor(ve) {
      super(ve, 100, "mvhd"), this.len = ve;
    }
    get(ve, De) {
      return {
        version: L.UINT8.get(ve, De),
        flags: L.UINT24_BE.get(ve, De + 1),
        creationTime: te.get(ve, De + 4),
        modificationTime: te.get(ve, De + 8),
        timeScale: L.UINT32_BE.get(ve, De + 12),
        duration: L.UINT32_BE.get(ve, De + 16),
        preferredRate: L.UINT32_BE.get(ve, De + 20),
        preferredVolume: L.UINT16_BE.get(ve, De + 24),
        // ignore reserver: 10 bytes
        // ignore matrix structure: 36 bytes
        previewTime: L.UINT32_BE.get(ve, De + 72),
        previewDuration: L.UINT32_BE.get(ve, De + 76),
        posterTime: L.UINT32_BE.get(ve, De + 80),
        selectionTime: L.UINT32_BE.get(ve, De + 84),
        selectionDuration: L.UINT32_BE.get(ve, De + 88),
        currentTime: L.UINT32_BE.get(ve, De + 92),
        nextTrackID: L.UINT32_BE.get(ve, De + 96)
      };
    }
  }
  C.MvhdAtom = ne;
  class re {
    constructor(ve) {
      this.len = ve;
    }
    get(ve, De) {
      return {
        type: {
          set: L.UINT8.get(ve, De + 0),
          type: L.UINT24_BE.get(ve, De + 1)
        },
        locale: L.UINT24_BE.get(ve, De + 4),
        value: Buffer.from(new L.Uint8ArrayType(this.len - 8).get(ve, De + 8))
      };
    }
  }
  C.DataAtom = re;
  class ce {
    constructor(ve) {
      this.len = ve;
    }
    get(ve, De) {
      return {
        version: L.UINT8.get(ve, De),
        flags: L.UINT24_BE.get(ve, De + 1),
        name: new L.StringType(this.len - 4, "utf-8").get(ve, De + 4)
      };
    }
  }
  C.NameAtom = ce;
  class ue {
    constructor(ve) {
      this.len = ve;
    }
    get(ve, De) {
      return {
        version: L.UINT8.get(ve, De),
        flags: L.UINT24_BE.get(ve, De + 1),
        creationTime: te.get(ve, De + 4),
        modificationTime: te.get(ve, De + 8),
        trackId: L.UINT32_BE.get(ve, De + 12),
        // reserved 4 bytes
        duration: L.UINT32_BE.get(ve, De + 20),
        layer: L.UINT16_BE.get(ve, De + 24),
        alternateGroup: L.UINT16_BE.get(ve, De + 26),
        volume: L.UINT16_BE.get(ve, De + 28)
        // ToDo: fixed point
        // ToDo: add remaining fields
      };
    }
  }
  C.TrackHeaderAtom = ue;
  const de = {
    len: 8,
    get: (Le, ve) => ({
      version: L.UINT8.get(Le, ve),
      flags: L.UINT24_BE.get(Le, ve + 1),
      numberOfEntries: L.UINT32_BE.get(Le, ve + 4)
    })
  };
  class be {
    constructor(ve) {
      this.len = ve;
    }
    get(ve, De) {
      return {
        dataFormat: W.FourCcToken.get(ve, De),
        dataReferenceIndex: L.UINT16_BE.get(ve, De + 10),
        description: new L.Uint8ArrayType(this.len - 12).get(ve, De + 12)
      };
    }
  }
  class pe {
    constructor(ve) {
      this.len = ve;
    }
    get(ve, De) {
      const Ue = de.get(ve, De);
      De += de.len;
      const Fe = [];
      for (let We = 0; We < Ue.numberOfEntries; ++We) {
        const Ke = L.UINT32_BE.get(ve, De);
        De += L.UINT32_BE.len, Fe.push(new be(Ke).get(ve, De)), De += Ke;
      }
      return {
        header: Ue,
        table: Fe
      };
    }
  }
  C.StsdAtom = pe, C.SoundSampleDescriptionVersion = {
    len: 8,
    get(Le, ve) {
      return {
        version: L.INT16_BE.get(Le, ve),
        revision: L.INT16_BE.get(Le, ve + 2),
        vendor: L.INT32_BE.get(Le, ve + 4)
      };
    }
  }, C.SoundSampleDescriptionV0 = {
    len: 12,
    get(Le, ve) {
      return {
        numAudioChannels: L.INT16_BE.get(Le, ve + 0),
        sampleSize: L.INT16_BE.get(Le, ve + 2),
        compressionId: L.INT16_BE.get(Le, ve + 4),
        packetSize: L.INT16_BE.get(Le, ve + 6),
        sampleRate: L.UINT16_BE.get(Le, ve + 8) + L.UINT16_BE.get(Le, ve + 10) / 1e4
      };
    }
  };
  class me {
    constructor(ve, De) {
      this.len = ve, this.token = De;
    }
    get(ve, De) {
      const Ue = L.INT32_BE.get(ve, De + 4);
      return {
        version: L.INT8.get(ve, De + 0),
        flags: L.INT24_BE.get(ve, De + 1),
        numberOfEntries: Ue,
        entries: Ae(ve, this.token, De + 8, this.len - 8, Ue)
      };
    }
  }
  C.TimeToSampleToken = {
    len: 8,
    get(Le, ve) {
      return {
        count: L.INT32_BE.get(Le, ve + 0),
        duration: L.INT32_BE.get(Le, ve + 4)
      };
    }
  };
  class Me extends me {
    constructor(ve) {
      super(ve, C.TimeToSampleToken), this.len = ve;
    }
  }
  C.SttsAtom = Me, C.SampleToChunkToken = {
    len: 12,
    get(Le, ve) {
      return {
        firstChunk: L.INT32_BE.get(Le, ve),
        samplesPerChunk: L.INT32_BE.get(Le, ve + 4),
        sampleDescriptionId: L.INT32_BE.get(Le, ve + 8)
      };
    }
  };
  class he extends me {
    constructor(ve) {
      super(ve, C.SampleToChunkToken), this.len = ve;
    }
  }
  C.StscAtom = he;
  class ge {
    constructor(ve) {
      this.len = ve;
    }
    get(ve, De) {
      const Ue = L.INT32_BE.get(ve, De + 8);
      return {
        version: L.INT8.get(ve, De),
        flags: L.INT24_BE.get(ve, De + 1),
        sampleSize: L.INT32_BE.get(ve, De + 4),
        numberOfEntries: Ue,
        entries: Ae(ve, L.INT32_BE, De + 12, this.len - 12, Ue)
      };
    }
  }
  C.StszAtom = ge;
  class Ce extends me {
    constructor(ve) {
      super(ve, L.INT32_BE), this.len = ve;
    }
  }
  C.StcoAtom = Ce;
  class Se {
    constructor(ve) {
      this.len = ve;
    }
    get(ve, De) {
      const Ue = L.INT16_BE.get(ve, De + 0);
      return new L.StringType(Ue, "utf-8").get(ve, De + 2);
    }
  }
  C.ChapterText = Se;
  function Ae(Le, ve, De, Ue, Fe) {
    if (X(`remainingLen=${Ue}, numberOfEntries=${Fe} * token-len=${ve.len}`), Ue === 0)
      return [];
    if (Ue !== Fe * ve.len)
      throw new Error("mismatch number-of-entries with remaining atom-length");
    const We = [];
    for (let Ke = 0; Ke < Fe; ++Ke)
      We.push(ve.get(Le, De)), De += ve.len;
    return We;
  }
})(AtomToken$2);
Object.defineProperty(Atom$1, "__esModule", { value: !0 });
Atom$1.Atom = void 0;
const debug_1$f = browserExports, AtomToken$1 = AtomToken$2, debug$f = (0, debug_1$f.default)("music-metadata:parser:MP4:Atom");
class Atom {
  static async readAtom(L, A, W, X) {
    const J = L.position, te = await L.readToken(AtomToken$1.Header);
    te.length === BigInt(1) && (te.length = await L.readToken(AtomToken$1.ExtendedSize));
    const ne = new Atom(te, te.length === BigInt(1), W), re = ne.getPayloadLength(X);
    return debug$f(`parse atom name=${ne.atomPath}, extended=${ne.extended}, offset=${J}, len=${ne.header.length}`), await ne.readData(L, A, re), ne;
  }
  constructor(L, A, W) {
    this.header = L, this.extended = A, this.parent = W, this.children = [], this.atomPath = (this.parent ? this.parent.atomPath + "." : "") + this.header.name;
  }
  getHeaderLength() {
    return this.extended ? 16 : 8;
  }
  getPayloadLength(L) {
    return (this.header.length === BigInt(0) ? L : Number(this.header.length)) - this.getHeaderLength();
  }
  async readAtoms(L, A, W) {
    for (; W > 0; ) {
      const X = await Atom.readAtom(L, A, this, W);
      this.children.push(X), W -= X.header.length === BigInt(0) ? W : Number(X.header.length);
    }
  }
  async readData(L, A, W) {
    switch (this.header.name) {
      case "moov":
      case "udta":
      case "trak":
      case "mdia":
      case "minf":
      case "stbl":
      case "<id>":
      case "ilst":
      case "tref":
        return this.readAtoms(L, A, this.getPayloadLength(W));
      case "meta":
        const J = (await L.peekToken(AtomToken$1.Header)).name === "hdlr" ? 0 : 4;
        return await L.ignore(J), this.readAtoms(L, A, this.getPayloadLength(W) - J);
      case "mdhd":
      case "mvhd":
      case "tkhd":
      case "stsz":
      case "mdat":
      default:
        return A(this, W);
    }
  }
}
Atom$1.Atom = Atom;
Object.defineProperty(MP4Parser$1, "__esModule", { value: !0 });
MP4Parser$1.MP4Parser = void 0;
const debug_1$e = browserExports, Token$i = lib$1, BasicParser_1$7 = BasicParser$1, ID3v1Parser_1$1 = ID3v1Parser, type_1 = type$1, Atom_1 = Atom$1, AtomToken = AtomToken$2, debug$e = (0, debug_1$e.default)("music-metadata:parser:MP4"), tagFormat = "iTunes", encoderDict = {
  raw: {
    lossy: !1,
    format: "raw"
  },
  MAC3: {
    lossy: !0,
    format: "MACE 3:1"
  },
  MAC6: {
    lossy: !0,
    format: "MACE 6:1"
  },
  ima4: {
    lossy: !0,
    format: "IMA 4:1"
  },
  ulaw: {
    lossy: !0,
    format: "uLaw 2:1"
  },
  alaw: {
    lossy: !0,
    format: "uLaw 2:1"
  },
  Qclp: {
    lossy: !0,
    format: "QUALCOMM PureVoice"
  },
  ".mp3": {
    lossy: !0,
    format: "MPEG-1 layer 3"
  },
  alac: {
    lossy: !1,
    format: "ALAC"
  },
  "ac-3": {
    lossy: !0,
    format: "AC-3"
  },
  mp4a: {
    lossy: !0,
    format: "MPEG-4/AAC"
  },
  mp4s: {
    lossy: !0,
    format: "MP4S"
  },
  // Closed Captioning Media, https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap3/qtff3.html#//apple_ref/doc/uid/TP40000939-CH205-SW87
  c608: {
    lossy: !0,
    format: "CEA-608"
  },
  c708: {
    lossy: !0,
    format: "CEA-708"
  }
};
function distinct(C, L, A) {
  return A.indexOf(C) === L;
}
class MP4Parser extends BasicParser_1$7.BasicParser {
  constructor() {
    super(...arguments), this.atomParsers = {
      /**
       * Parse movie header (mvhd) atom
       * Ref: https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap2/qtff2.html#//apple_ref/doc/uid/TP40000939-CH204-56313
       */
      mvhd: async (L) => {
        const A = await this.tokenizer.readToken(new AtomToken.MvhdAtom(L));
        this.metadata.setFormat("creationTime", A.creationTime), this.metadata.setFormat("modificationTime", A.modificationTime);
      },
      /**
       * Parse media header (mdhd) atom
       * Ref: https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap2/qtff2.html#//apple_ref/doc/uid/TP40000939-CH204-25615
       */
      mdhd: async (L) => {
        const A = await this.tokenizer.readToken(new AtomToken.MdhdAtom(L)), W = this.getTrackDescription();
        W.creationTime = A.creationTime, W.modificationTime = A.modificationTime, W.timeScale = A.timeScale, W.duration = A.duration;
      },
      chap: async (L) => {
        const A = this.getTrackDescription(), W = [];
        for (; L >= Token$i.UINT32_BE.len; )
          W.push(await this.tokenizer.readNumber(Token$i.UINT32_BE)), L -= Token$i.UINT32_BE.len;
        A.chapterList = W;
      },
      tkhd: async (L) => {
        const A = await this.tokenizer.readToken(new AtomToken.TrackHeaderAtom(L));
        this.tracks.push(A);
      },
      /**
       * Parse mdat atom.
       * Will scan for chapters
       */
      mdat: async (L) => {
        if (this.audioLengthInBytes = L, this.calculateBitRate(), this.options.includeChapters) {
          const A = this.tracks.filter((W) => W.chapterList);
          if (A.length === 1) {
            const W = A[0].chapterList, X = this.tracks.filter((J) => W.indexOf(J.trackId) !== -1);
            if (X.length === 1)
              return this.parseChapterTrack(X[0], A[0], L);
          }
        }
        await this.tokenizer.ignore(L);
      },
      ftyp: async (L) => {
        const A = [];
        for (; L > 0; ) {
          const X = await this.tokenizer.readToken(AtomToken.ftyp);
          L -= AtomToken.ftyp.len;
          const J = X.type.replace(/\W/g, "");
          J.length > 0 && A.push(J);
        }
        debug$e(`ftyp: ${A.join("/")}`);
        const W = A.filter(distinct).join("/");
        this.metadata.setFormat("container", W);
      },
      /**
       * Parse sample description atom
       */
      stsd: async (L) => {
        const A = await this.tokenizer.readToken(new AtomToken.StsdAtom(L)), W = this.getTrackDescription();
        W.soundSampleDescription = A.table.map((X) => this.parseSoundSampleDescription(X));
      },
      /**
       * sample-to-Chunk Atoms
       */
      stsc: async (L) => {
        const A = await this.tokenizer.readToken(new AtomToken.StscAtom(L));
        this.getTrackDescription().sampleToChunkTable = A.entries;
      },
      /**
       * time-to-sample table
       */
      stts: async (L) => {
        const A = await this.tokenizer.readToken(new AtomToken.SttsAtom(L));
        this.getTrackDescription().timeToSampleTable = A.entries;
      },
      /**
       * Parse sample-sizes atom ('stsz')
       */
      stsz: async (L) => {
        const A = await this.tokenizer.readToken(new AtomToken.StszAtom(L)), W = this.getTrackDescription();
        W.sampleSize = A.sampleSize, W.sampleSizeTable = A.entries;
      },
      /**
       * Parse chunk-offset atom ('stco')
       */
      stco: async (L) => {
        const A = await this.tokenizer.readToken(new AtomToken.StcoAtom(L));
        this.getTrackDescription().chunkOffsetTable = A.entries;
      },
      date: async (L) => {
        const A = await this.tokenizer.readToken(new Token$i.StringType(L, "utf-8"));
        this.addTag("date", A);
      }
    };
  }
  static read_BE_Integer(L, A) {
    const W = (A ? "INT" : "UINT") + L.length * 8 + (L.length > 1 ? "_BE" : ""), X = Token$i[W];
    if (!X)
      throw new Error('Token for integer type not found: "' + W + '"');
    return Number(X.get(L, 0));
  }
  async parse() {
    this.tracks = [];
    let L = this.tokenizer.fileInfo.size;
    for (; !this.tokenizer.fileInfo.size || L > 0; ) {
      try {
        if ((await this.tokenizer.peekToken(AtomToken.Header)).name === "\0\0\0\0") {
          const te = `Error at offset=${this.tokenizer.position}: box.id=0`;
          debug$e(te), this.addWarning(te);
          break;
        }
      } catch (J) {
        const te = `Error at offset=${this.tokenizer.position}: ${J.message}`;
        debug$e(te), this.addWarning(te);
        break;
      }
      const X = await Atom_1.Atom.readAtom(this.tokenizer, (J, te) => this.handleAtom(J, te), null, L);
      L -= X.header.length === BigInt(0) ? L : Number(X.header.length);
    }
    const A = [];
    this.tracks.forEach((X) => {
      const J = [];
      X.soundSampleDescription.forEach((te) => {
        const oe = {}, ne = encoderDict[te.dataFormat];
        if (ne ? (J.push(ne.format), oe.codecName = ne.format) : oe.codecName = `<${te.dataFormat}>`, te.description) {
          const { description: re } = te;
          re.sampleRate > 0 && (oe.type = type_1.TrackType.audio, oe.audio = {
            samplingFrequency: re.sampleRate,
            bitDepth: re.sampleSize,
            channels: re.numAudioChannels
          });
        }
        this.metadata.addStreamInfo(oe);
      }), J.length >= 1 && A.push(J.join("/"));
    }), A.length > 0 && this.metadata.setFormat("codec", A.filter(distinct).join("+"));
    const W = this.tracks.filter((X) => X.soundSampleDescription.length >= 1 && X.soundSampleDescription[0].description && X.soundSampleDescription[0].description.numAudioChannels > 0);
    if (W.length >= 1) {
      const X = W[0];
      if (X.timeScale > 0) {
        const oe = X.duration / X.timeScale;
        this.metadata.setFormat("duration", oe);
      }
      const J = X.soundSampleDescription[0];
      if (J.description && (this.metadata.setFormat("sampleRate", J.description.sampleRate), this.metadata.setFormat("bitsPerSample", J.description.sampleSize), this.metadata.setFormat("numberOfChannels", J.description.numAudioChannels), X.timeScale === 0 && X.timeToSampleTable.length > 0)) {
        const ne = X.timeToSampleTable.map((re) => re.count * re.duration).reduce((re, ce) => re + ce) / J.description.sampleRate;
        this.metadata.setFormat("duration", ne);
      }
      const te = encoderDict[J.dataFormat];
      te && this.metadata.setFormat("lossless", !te.lossy), this.calculateBitRate();
    }
  }
  async handleAtom(L, A) {
    if (L.parent)
      switch (L.parent.header.name) {
        case "ilst":
        case "<id>":
          return this.parseMetadataItemData(L);
      }
    if (this.atomParsers[L.header.name])
      return this.atomParsers[L.header.name](A);
    debug$e(`No parser for atom path=${L.atomPath}, payload-len=${A}, ignoring atom`), await this.tokenizer.ignore(A);
  }
  getTrackDescription() {
    return this.tracks[this.tracks.length - 1];
  }
  calculateBitRate() {
    this.audioLengthInBytes && this.metadata.format.duration && this.metadata.setFormat("bitrate", 8 * this.audioLengthInBytes / this.metadata.format.duration);
  }
  addTag(L, A) {
    this.metadata.addTag(tagFormat, L, A);
  }
  addWarning(L) {
    debug$e("Warning: " + L), this.metadata.addWarning(L);
  }
  /**
   * Parse data of Meta-item-list-atom (item of 'ilst' atom)
   * @param metaAtom
   * Ref: https://developer.apple.com/library/content/documentation/QuickTime/QTFF/Metadata/Metadata.html#//apple_ref/doc/uid/TP40000939-CH1-SW8
   */
  parseMetadataItemData(L) {
    let A = L.header.name;
    return L.readAtoms(this.tokenizer, async (W, X) => {
      const J = W.getPayloadLength(X);
      switch (W.header.name) {
        case "data":
          return this.parseValueAtom(A, W);
        case "name":
        case "mean":
        case "rate":
          const te = await this.tokenizer.readToken(new AtomToken.NameAtom(J));
          A += ":" + te.name;
          break;
        default:
          const oe = await this.tokenizer.readToken(new Token$i.BufferType(J));
          this.addWarning("Unsupported meta-item: " + A + "[" + W.header.name + "] => value=" + oe.toString("hex") + " ascii=" + oe.toString("ascii"));
      }
    }, L.getPayloadLength(0));
  }
  async parseValueAtom(L, A) {
    const W = await this.tokenizer.readToken(new AtomToken.DataAtom(Number(A.header.length) - AtomToken.Header.len));
    if (W.type.set !== 0)
      throw new Error("Unsupported type-set != 0: " + W.type.set);
    switch (W.type.type) {
      case 0:
        switch (L) {
          case "trkn":
          case "disk":
            const X = Token$i.UINT8.get(W.value, 3), J = Token$i.UINT8.get(W.value, 5);
            this.addTag(L, X + "/" + J);
            break;
          case "gnre":
            const te = Token$i.UINT8.get(W.value, 1), oe = ID3v1Parser_1$1.Genres[te - 1];
            this.addTag(L, oe);
            break;
          case "rate":
            const ne = W.value.toString("ascii");
            this.addTag(L, ne);
            break;
          default:
            debug$e("unknown proprietary value type for: " + A.atomPath);
        }
        break;
      case 1:
      case 18:
        this.addTag(L, W.value.toString("utf-8"));
        break;
      case 13:
        if (this.options.skipCovers)
          break;
        this.addTag(L, {
          format: "image/jpeg",
          data: Buffer.from(W.value)
        });
        break;
      case 14:
        if (this.options.skipCovers)
          break;
        this.addTag(L, {
          format: "image/png",
          data: Buffer.from(W.value)
        });
        break;
      case 21:
        this.addTag(L, MP4Parser.read_BE_Integer(W.value, !0));
        break;
      case 22:
        this.addTag(L, MP4Parser.read_BE_Integer(W.value, !1));
        break;
      case 65:
        this.addTag(L, W.value.readInt8(0));
        break;
      case 66:
        this.addTag(L, W.value.readInt16BE(0));
        break;
      case 67:
        this.addTag(L, W.value.readInt32BE(0));
        break;
      default:
        this.addWarning(`atom key=${L}, has unknown well-known-type (data-type): ${W.type.type}`);
    }
  }
  /**
   * @param sampleDescription
   * Ref: https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap3/qtff3.html#//apple_ref/doc/uid/TP40000939-CH205-128916
   */
  parseSoundSampleDescription(L) {
    const A = {
      dataFormat: L.dataFormat,
      dataReferenceIndex: L.dataReferenceIndex
    };
    let W = 0;
    const X = AtomToken.SoundSampleDescriptionVersion.get(L.description, W);
    return W += AtomToken.SoundSampleDescriptionVersion.len, X.version === 0 || X.version === 1 ? A.description = AtomToken.SoundSampleDescriptionV0.get(L.description, W) : debug$e(`Warning: sound-sample-description ${X} not implemented`), A;
  }
  async parseChapterTrack(L, A, W) {
    if (!L.sampleSize && L.chunkOffsetTable.length !== L.sampleSizeTable.length)
      throw new Error("Expected equal chunk-offset-table & sample-size-table length.");
    const X = [];
    for (let J = 0; J < L.chunkOffsetTable.length && W > 0; ++J) {
      const oe = L.chunkOffsetTable[J] - this.tokenizer.position, ne = L.sampleSize > 0 ? L.sampleSize : L.sampleSizeTable[J];
      if (W -= oe + ne, W < 0)
        throw new Error("Chapter chunk exceeding token length");
      await this.tokenizer.ignore(oe);
      const re = await this.tokenizer.readToken(new AtomToken.ChapterText(ne));
      debug$e(`Chapter ${J + 1}: ${re}`);
      const ce = {
        title: re,
        sampleOffset: this.findSampleOffset(A, this.tokenizer.position)
      };
      debug$e(`Chapter title=${ce.title}, offset=${ce.sampleOffset}/${this.tracks[0].duration}`), X.push(ce);
    }
    this.metadata.setFormat("chapters", X), await this.tokenizer.ignore(W);
  }
  findSampleOffset(L, A) {
    let W = 0;
    L.timeToSampleTable.forEach((J) => {
      W += J.count * J.duration;
    }), debug$e(`Total duration=${W}`);
    let X = 0;
    for (; X < L.chunkOffsetTable.length && L.chunkOffsetTable[X] < A; )
      ++X;
    return this.getChunkDuration(X + 1, L);
  }
  getChunkDuration(L, A) {
    let W = 0, X = A.timeToSampleTable[W].count, J = A.timeToSampleTable[W].duration, te = 1, oe = this.getSamplesPerChunk(te, A.sampleToChunkTable), ne = 0;
    for (; te < L; ) {
      const re = Math.min(X, oe);
      ne += re * J, X -= re, oe -= re, oe === 0 ? (++te, oe = this.getSamplesPerChunk(te, A.sampleToChunkTable)) : (++W, X = A.timeToSampleTable[W].count, J = A.timeToSampleTable[W].duration);
    }
    return ne;
  }
  getSamplesPerChunk(L, A) {
    for (let W = 0; W < A.length - 1; ++W)
      if (L >= A[W].firstChunk && L < A[W + 1].firstChunk)
        return A[W].samplesPerChunk;
    return A[A.length - 1].samplesPerChunk;
  }
}
MP4Parser$1.MP4Parser = MP4Parser;
var MpegParser$1 = {}, XingTag = {}, ExtendedLameHeader = {}, ReplayGainDataFormat = {};
Object.defineProperty(ReplayGainDataFormat, "__esModule", { value: !0 });
ReplayGainDataFormat.ReplayGain = void 0;
const common$2 = Util;
var NameCode;
(function(C) {
  C[C.not_set = 0] = "not_set", C[C.radio = 1] = "radio", C[C.audiophile = 2] = "audiophile";
})(NameCode || (NameCode = {}));
var ReplayGainOriginator;
(function(C) {
  C[C.unspecified = 0] = "unspecified", C[C.engineer = 1] = "engineer", C[C.user = 2] = "user", C[C.automatic = 3] = "automatic", C[C.rms_average = 4] = "rms_average";
})(ReplayGainOriginator || (ReplayGainOriginator = {}));
ReplayGainDataFormat.ReplayGain = {
  len: 2,
  get: (C, L) => {
    const A = common$2.getBitAllignedNumber(C, L, 0, 3), W = common$2.getBitAllignedNumber(C, L, 6, 1), X = common$2.getBitAllignedNumber(C, L, 7, 9) / 10;
    if (A > 0)
      return {
        type: common$2.getBitAllignedNumber(C, L, 0, 3),
        origin: common$2.getBitAllignedNumber(C, L, 3, 3),
        adjustment: W ? -X : X
      };
  }
};
Object.defineProperty(ExtendedLameHeader, "__esModule", { value: !0 });
ExtendedLameHeader.ExtendedLameHeader = void 0;
const Token$h = lib$1, common$1 = Util, ReplayGainDataFormat_1 = ReplayGainDataFormat;
ExtendedLameHeader.ExtendedLameHeader = {
  len: 27,
  get: (C, L) => {
    const A = Token$h.UINT32_BE.get(C, L + 2);
    return {
      revision: common$1.getBitAllignedNumber(C, L, 0, 4),
      vbr_method: common$1.getBitAllignedNumber(C, L, 4, 4),
      lowpass_filter: 100 * Token$h.UINT8.get(C, L + 1),
      track_peak: A === 0 ? void 0 : A / Math.pow(2, 23),
      track_gain: ReplayGainDataFormat_1.ReplayGain.get(C, 6),
      album_gain: ReplayGainDataFormat_1.ReplayGain.get(C, 8),
      music_length: Token$h.UINT32_BE.get(C, L + 20),
      music_crc: Token$h.UINT8.get(C, L + 24),
      header_crc: Token$h.UINT16_BE.get(C, L + 24)
    };
  }
};
(function(C) {
  Object.defineProperty(C, "__esModule", { value: !0 }), C.readXingHeader = C.XingHeaderFlags = C.LameEncoderVersion = C.InfoTagHeaderTag = void 0;
  const L = lib$1, A = Util, W = ExtendedLameHeader;
  C.InfoTagHeaderTag = new L.StringType(4, "ascii"), C.LameEncoderVersion = new L.StringType(6, "ascii"), C.XingHeaderFlags = {
    len: 4,
    get: (J, te) => ({
      frames: A.isBitSet(J, te, 31),
      bytes: A.isBitSet(J, te, 30),
      toc: A.isBitSet(J, te, 29),
      vbrScale: A.isBitSet(J, te, 28)
    })
  };
  async function X(J) {
    const te = await J.readToken(C.XingHeaderFlags), oe = {};
    if (te.frames && (oe.numFrames = await J.readToken(L.UINT32_BE)), te.bytes && (oe.streamSize = await J.readToken(L.UINT32_BE)), te.toc && (oe.toc = Buffer.alloc(100), await J.readBuffer(oe.toc)), te.vbrScale && (oe.vbrScale = await J.readToken(L.UINT32_BE)), await J.peekToken(new L.StringType(4, "ascii")) === "LAME" && (await J.ignore(4), oe.lame = {
      version: await J.readToken(new L.StringType(5, "ascii"))
    }, oe.lame.version.match(/\d+.\d+/g))) {
      const ue = oe.lame.version.match(/\d+.\d+/g)[0].split(".").map((de) => parseInt(de, 10));
      ue[0] >= 3 && ue[1] >= 90 && (oe.lame.extended = await J.readToken(W.ExtendedLameHeader));
    }
    return oe;
  }
  C.readXingHeader = X;
})(XingTag);
Object.defineProperty(MpegParser$1, "__esModule", { value: !0 });
MpegParser$1.MpegParser = void 0;
const Token$g = lib$1, core_1$1 = core$1, debug_1$d = browserExports, common = Util, AbstractID3Parser_1$2 = AbstractID3Parser$1, XingTag_1 = XingTag, debug$d = (0, debug_1$d.default)("music-metadata:parser:mpeg"), maxPeekLen = 1024, MPEG4 = {
  /**
   * Audio Object Types
   */
  AudioObjectTypes: [
    "AAC Main",
    "AAC LC",
    "AAC SSR",
    "AAC LTP"
    // Long Term Prediction
  ],
  /**
   * Sampling Frequencies
   * https://wiki.multimedia.cx/index.php/MPEG-4_Audio#Sampling_Frequencies
   */
  SamplingFrequencies: [
    96e3,
    88200,
    64e3,
    48e3,
    44100,
    32e3,
    24e3,
    22050,
    16e3,
    12e3,
    11025,
    8e3,
    7350,
    void 0,
    void 0,
    -1
  ]
  /**
   * Channel Configurations
   */
}, MPEG4_ChannelConfigurations = [
  void 0,
  ["front-center"],
  ["front-left", "front-right"],
  ["front-center", "front-left", "front-right"],
  ["front-center", "front-left", "front-right", "back-center"],
  ["front-center", "front-left", "front-right", "back-left", "back-right"],
  ["front-center", "front-left", "front-right", "back-left", "back-right", "LFE-channel"],
  ["front-center", "front-left", "front-right", "side-left", "side-right", "back-left", "back-right", "LFE-channel"]
];
class MpegFrameHeader {
  constructor(L, A) {
    this.versionIndex = common.getBitAllignedNumber(L, A + 1, 3, 2), this.layer = MpegFrameHeader.LayerDescription[common.getBitAllignedNumber(L, A + 1, 5, 2)], this.versionIndex > 1 && this.layer === 0 ? this.parseAdtsHeader(L, A) : this.parseMpegHeader(L, A), this.isProtectedByCRC = !common.isBitSet(L, A + 1, 7);
  }
  calcDuration(L) {
    return L * this.calcSamplesPerFrame() / this.samplingRate;
  }
  calcSamplesPerFrame() {
    return MpegFrameHeader.samplesInFrameTable[this.version === 1 ? 0 : 1][this.layer];
  }
  calculateSideInfoLength() {
    if (this.layer !== 3)
      return 2;
    if (this.channelModeIndex === 3) {
      if (this.version === 1)
        return 17;
      if (this.version === 2 || this.version === 2.5)
        return 9;
    } else {
      if (this.version === 1)
        return 32;
      if (this.version === 2 || this.version === 2.5)
        return 17;
    }
  }
  calcSlotSize() {
    return [null, 4, 1, 1][this.layer];
  }
  parseMpegHeader(L, A) {
    this.container = "MPEG", this.bitrateIndex = common.getBitAllignedNumber(L, A + 2, 0, 4), this.sampRateFreqIndex = common.getBitAllignedNumber(L, A + 2, 4, 2), this.padding = common.isBitSet(L, A + 2, 6), this.privateBit = common.isBitSet(L, A + 2, 7), this.channelModeIndex = common.getBitAllignedNumber(L, A + 3, 0, 2), this.modeExtension = common.getBitAllignedNumber(L, A + 3, 2, 2), this.isCopyrighted = common.isBitSet(L, A + 3, 4), this.isOriginalMedia = common.isBitSet(L, A + 3, 5), this.emphasis = common.getBitAllignedNumber(L, A + 3, 7, 2), this.version = MpegFrameHeader.VersionID[this.versionIndex], this.channelMode = MpegFrameHeader.ChannelMode[this.channelModeIndex], this.codec = `MPEG ${this.version} Layer ${this.layer}`;
    const W = this.calcBitrate();
    if (!W)
      throw new Error("Cannot determine bit-rate");
    if (this.bitrate = W * 1e3, this.samplingRate = this.calcSamplingRate(), this.samplingRate == null)
      throw new Error("Cannot determine sampling-rate");
  }
  parseAdtsHeader(L, A) {
    debug$d("layer=0 => ADTS"), this.version = this.versionIndex === 2 ? 4 : 2, this.container = "ADTS/MPEG-" + this.version;
    const W = common.getBitAllignedNumber(L, A + 2, 0, 2);
    this.codec = "AAC", this.codecProfile = MPEG4.AudioObjectTypes[W], debug$d(`MPEG-4 audio-codec=${this.codec}`);
    const X = common.getBitAllignedNumber(L, A + 2, 2, 4);
    this.samplingRate = MPEG4.SamplingFrequencies[X], debug$d(`sampling-rate=${this.samplingRate}`);
    const J = common.getBitAllignedNumber(L, A + 2, 7, 3);
    this.mp4ChannelConfig = MPEG4_ChannelConfigurations[J], debug$d(`channel-config=${this.mp4ChannelConfig.join("+")}`), this.frameLength = common.getBitAllignedNumber(L, A + 3, 6, 2) << 11;
  }
  calcBitrate() {
    if (this.bitrateIndex === 0 || // free
    this.bitrateIndex === 15)
      return;
    const L = `${Math.floor(this.version)}${this.layer}`;
    return MpegFrameHeader.bitrate_index[this.bitrateIndex][L];
  }
  calcSamplingRate() {
    return this.sampRateFreqIndex === 3 ? null : MpegFrameHeader.sampling_rate_freq_index[this.version][this.sampRateFreqIndex];
  }
}
MpegFrameHeader.SyncByte1 = 255;
MpegFrameHeader.SyncByte2 = 224;
MpegFrameHeader.VersionID = [2.5, null, 2, 1];
MpegFrameHeader.LayerDescription = [0, 3, 2, 1];
MpegFrameHeader.ChannelMode = ["stereo", "joint_stereo", "dual_channel", "mono"];
MpegFrameHeader.bitrate_index = {
  1: { 11: 32, 12: 32, 13: 32, 21: 32, 22: 8, 23: 8 },
  2: { 11: 64, 12: 48, 13: 40, 21: 48, 22: 16, 23: 16 },
  3: { 11: 96, 12: 56, 13: 48, 21: 56, 22: 24, 23: 24 },
  4: { 11: 128, 12: 64, 13: 56, 21: 64, 22: 32, 23: 32 },
  5: { 11: 160, 12: 80, 13: 64, 21: 80, 22: 40, 23: 40 },
  6: { 11: 192, 12: 96, 13: 80, 21: 96, 22: 48, 23: 48 },
  7: { 11: 224, 12: 112, 13: 96, 21: 112, 22: 56, 23: 56 },
  8: { 11: 256, 12: 128, 13: 112, 21: 128, 22: 64, 23: 64 },
  9: { 11: 288, 12: 160, 13: 128, 21: 144, 22: 80, 23: 80 },
  10: { 11: 320, 12: 192, 13: 160, 21: 160, 22: 96, 23: 96 },
  11: { 11: 352, 12: 224, 13: 192, 21: 176, 22: 112, 23: 112 },
  12: { 11: 384, 12: 256, 13: 224, 21: 192, 22: 128, 23: 128 },
  13: { 11: 416, 12: 320, 13: 256, 21: 224, 22: 144, 23: 144 },
  14: { 11: 448, 12: 384, 13: 320, 21: 256, 22: 160, 23: 160 }
};
MpegFrameHeader.sampling_rate_freq_index = {
  1: { 0: 44100, 1: 48e3, 2: 32e3 },
  2: { 0: 22050, 1: 24e3, 2: 16e3 },
  2.5: { 0: 11025, 1: 12e3, 2: 8e3 }
};
MpegFrameHeader.samplesInFrameTable = [
  /* Layer   I    II   III */
  [0, 384, 1152, 1152],
  [0, 384, 1152, 576]
  // MPEG-2(.5
];
const FrameHeader = {
  len: 4,
  get: (C, L) => new MpegFrameHeader(C, L)
};
function getVbrCodecProfile(C) {
  return "V" + Math.floor((100 - C) / 10);
}
class MpegParser extends AbstractID3Parser_1$2.AbstractID3Parser {
  constructor() {
    super(...arguments), this.frameCount = 0, this.syncFrameCount = -1, this.countSkipFrameData = 0, this.totalDataLength = 0, this.bitrates = [], this.calculateEofDuration = !1, this.buf_frame_header = Buffer.alloc(4), this.syncPeek = {
      buf: Buffer.alloc(maxPeekLen),
      len: 0
    };
  }
  /**
   * Called after ID3 headers have been parsed
   */
  async postId3v2Parse() {
    this.metadata.setFormat("lossless", !1);
    try {
      let L = !1;
      for (; !L; )
        await this.sync(), L = await this.parseCommonMpegHeader();
    } catch (L) {
      if (L instanceof core_1$1.EndOfStreamError) {
        if (debug$d("End-of-stream"), this.calculateEofDuration) {
          const A = this.frameCount * this.samplesPerFrame;
          this.metadata.setFormat("numberOfSamples", A);
          const W = A / this.metadata.format.sampleRate;
          debug$d(`Calculate duration at EOF: ${W} sec.`, W), this.metadata.setFormat("duration", W);
        }
      } else
        throw L;
    }
  }
  /**
   * Called after file has been fully parsed, this allows, if present, to exclude the ID3v1.1 header length
   */
  finalize() {
    const L = this.metadata.format, A = this.metadata.native.hasOwnProperty("ID3v1");
    if (L.duration && this.tokenizer.fileInfo.size) {
      const W = this.tokenizer.fileInfo.size - this.mpegOffset - (A ? 128 : 0);
      L.codecProfile && L.codecProfile[0] === "V" && this.metadata.setFormat("bitrate", W * 8 / L.duration);
    } else if (this.tokenizer.fileInfo.size && L.codecProfile === "CBR") {
      const W = this.tokenizer.fileInfo.size - this.mpegOffset - (A ? 128 : 0), X = Math.round(W / this.frame_size) * this.samplesPerFrame;
      this.metadata.setFormat("numberOfSamples", X);
      const J = X / L.sampleRate;
      debug$d("Calculate CBR duration based on file size: %s", J), this.metadata.setFormat("duration", J);
    }
  }
  async sync() {
    let L = !1;
    for (; ; ) {
      let A = 0;
      if (this.syncPeek.len = await this.tokenizer.peekBuffer(this.syncPeek.buf, { length: maxPeekLen, mayBeLess: !0 }), this.syncPeek.len <= 163)
        throw new core_1$1.EndOfStreamError();
      for (; ; )
        if (L && (this.syncPeek.buf[A] & 224) === 224) {
          this.buf_frame_header[0] = MpegFrameHeader.SyncByte1, this.buf_frame_header[1] = this.syncPeek.buf[A], await this.tokenizer.ignore(A), debug$d(`Sync at offset=${this.tokenizer.position - 1}, frameCount=${this.frameCount}`), this.syncFrameCount === this.frameCount && (debug$d(`Re-synced MPEG stream, frameCount=${this.frameCount}`), this.frameCount = 0, this.frame_size = 0), this.syncFrameCount = this.frameCount;
          return;
        } else if (L = !1, A = this.syncPeek.buf.indexOf(MpegFrameHeader.SyncByte1, A), A === -1) {
          if (this.syncPeek.len < this.syncPeek.buf.length)
            throw new core_1$1.EndOfStreamError();
          await this.tokenizer.ignore(this.syncPeek.len);
          break;
        } else
          ++A, L = !0;
    }
  }
  /**
   * Combined ADTS & MPEG (MP2 & MP3) header handling
   * @return {Promise<boolean>} true if parser should quit
   */
  async parseCommonMpegHeader() {
    this.frameCount === 0 && (this.mpegOffset = this.tokenizer.position - 1), await this.tokenizer.peekBuffer(this.buf_frame_header, { offset: 1, length: 3 });
    let L;
    try {
      L = FrameHeader.get(this.buf_frame_header, 0);
    } catch (A) {
      return await this.tokenizer.ignore(1), this.metadata.addWarning("Parse error: " + A.message), !1;
    }
    return await this.tokenizer.ignore(3), this.metadata.setFormat("container", L.container), this.metadata.setFormat("codec", L.codec), this.metadata.setFormat("lossless", !1), this.metadata.setFormat("sampleRate", L.samplingRate), this.frameCount++, L.version >= 2 && L.layer === 0 ? this.parseAdts(L) : this.parseAudioFrameHeader(L);
  }
  /**
   * @return {Promise<boolean>} true if parser should quit
   */
  async parseAudioFrameHeader(L) {
    this.metadata.setFormat("numberOfChannels", L.channelMode === "mono" ? 1 : 2), this.metadata.setFormat("bitrate", L.bitrate), this.frameCount < 20 * 1e4 && debug$d("offset=%s MP%s bitrate=%s sample-rate=%s", this.tokenizer.position - 4, L.layer, L.bitrate, L.samplingRate);
    const A = L.calcSlotSize();
    if (A === null)
      throw new Error("invalid slot_size");
    const W = L.calcSamplesPerFrame();
    debug$d(`samples_per_frame=${W}`);
    const J = W / 8 * L.bitrate / L.samplingRate + (L.padding ? A : 0);
    if (this.frame_size = Math.floor(J), this.audioFrameHeader = L, this.bitrates.push(L.bitrate), this.frameCount === 1)
      return this.offset = FrameHeader.len, await this.skipSideInformation(), !1;
    if (this.frameCount === 3) {
      if (this.areAllSame(this.bitrates)) {
        if (this.samplesPerFrame = W, this.metadata.setFormat("codecProfile", "CBR"), this.tokenizer.fileInfo.size)
          return !0;
      } else if (this.metadata.format.duration)
        return !0;
      if (!this.options.duration)
        return !0;
    }
    return this.options.duration && this.frameCount === 4 && (this.samplesPerFrame = W, this.calculateEofDuration = !0), this.offset = 4, L.isProtectedByCRC ? (await this.parseCrc(), !1) : (await this.skipSideInformation(), !1);
  }
  async parseAdts(L) {
    const A = Buffer.alloc(3);
    await this.tokenizer.readBuffer(A), L.frameLength += common.getBitAllignedNumber(A, 0, 0, 11), this.totalDataLength += L.frameLength, this.samplesPerFrame = 1024;
    const W = L.samplingRate / this.samplesPerFrame, J = 8 * (this.frameCount === 0 ? 0 : this.totalDataLength / this.frameCount) * W + 0.5;
    if (this.metadata.setFormat("bitrate", J), debug$d(`frame-count=${this.frameCount}, size=${L.frameLength} bytes, bit-rate=${J}`), await this.tokenizer.ignore(L.frameLength > 7 ? L.frameLength - 7 : 1), this.frameCount === 3)
      if (this.metadata.setFormat("codecProfile", L.codecProfile), L.mp4ChannelConfig && this.metadata.setFormat("numberOfChannels", L.mp4ChannelConfig.length), this.options.duration)
        this.calculateEofDuration = !0;
      else
        return !0;
    return !1;
  }
  async parseCrc() {
    return this.crc = await this.tokenizer.readNumber(Token$g.INT16_BE), this.offset += 2, this.skipSideInformation();
  }
  async skipSideInformation() {
    const L = this.audioFrameHeader.calculateSideInfoLength();
    await this.tokenizer.readToken(new Token$g.Uint8ArrayType(L)), this.offset += L, await this.readXtraInfoHeader();
  }
  async readXtraInfoHeader() {
    const L = await this.tokenizer.readToken(XingTag_1.InfoTagHeaderTag);
    switch (this.offset += XingTag_1.InfoTagHeaderTag.len, L) {
      case "Info":
        return this.metadata.setFormat("codecProfile", "CBR"), this.readXingInfoHeader();
      case "Xing":
        const W = await this.readXingInfoHeader(), X = getVbrCodecProfile(W.vbrScale);
        return this.metadata.setFormat("codecProfile", X), null;
      case "Xtra":
        break;
      case "LAME":
        const J = await this.tokenizer.readToken(XingTag_1.LameEncoderVersion);
        if (this.frame_size >= this.offset + XingTag_1.LameEncoderVersion.len)
          return this.offset += XingTag_1.LameEncoderVersion.len, this.metadata.setFormat("tool", "LAME " + J), await this.skipFrameData(this.frame_size - this.offset), null;
        this.metadata.addWarning("Corrupt LAME header");
        break;
    }
    const A = this.frame_size - this.offset;
    return A < 0 ? this.metadata.addWarning("Frame " + this.frameCount + "corrupt: negative frameDataLeft") : await this.skipFrameData(A), null;
  }
  /**
   * Ref: http://gabriel.mp3-tech.org/mp3infotag.html
   * @returns {Promise<string>}
   */
  async readXingInfoHeader() {
    const L = this.tokenizer.position, A = await (0, XingTag_1.readXingHeader)(this.tokenizer);
    if (this.offset += this.tokenizer.position - L, A.lame && (this.metadata.setFormat("tool", "LAME " + common.stripNulls(A.lame.version)), A.lame.extended && (this.metadata.setFormat("trackPeakLevel", A.lame.extended.track_peak), A.lame.extended.track_gain && this.metadata.setFormat("trackGain", A.lame.extended.track_gain.adjustment), A.lame.extended.album_gain && this.metadata.setFormat("albumGain", A.lame.extended.album_gain.adjustment), this.metadata.setFormat("duration", A.lame.extended.music_length / 1e3))), A.streamSize) {
      const X = this.audioFrameHeader.calcDuration(A.numFrames);
      return this.metadata.setFormat("duration", X), debug$d("Get duration from Xing header: %s", this.metadata.format.duration), A;
    }
    const W = this.frame_size - this.offset;
    return await this.skipFrameData(W), A;
  }
  async skipFrameData(L) {
    if (L < 0)
      throw new Error("frame-data-left cannot be negative");
    await this.tokenizer.ignore(L), this.countSkipFrameData += L;
  }
  areAllSame(L) {
    const A = L[0];
    return L.every((W) => W === A);
  }
}
MpegParser$1.MpegParser = MpegParser;
var musepack = {}, MpcSv8Parser$1 = {}, StreamVersion8 = {};
Object.defineProperty(StreamVersion8, "__esModule", { value: !0 });
StreamVersion8.StreamReader = void 0;
const Token$f = lib$1, debug_1$c = browserExports, util$5 = Util, debug$c = (0, debug_1$c.default)("music-metadata:parser:musepack:sv8"), PacketKey = new Token$f.StringType(2, "binary"), SH_part1 = {
  len: 5,
  get: (C, L) => ({
    crc: Token$f.UINT32_LE.get(C, L),
    streamVersion: Token$f.UINT8.get(C, L + 4)
  })
}, SH_part3 = {
  len: 2,
  get: (C, L) => ({
    sampleFrequency: [44100, 48e3, 37800, 32e3][util$5.getBitAllignedNumber(C, L, 0, 3)],
    maxUsedBands: util$5.getBitAllignedNumber(C, L, 3, 5),
    channelCount: util$5.getBitAllignedNumber(C, L + 1, 0, 4) + 1,
    msUsed: util$5.isBitSet(C, L + 1, 4),
    audioBlockFrames: util$5.getBitAllignedNumber(C, L + 1, 5, 3)
  })
};
class StreamReader {
  constructor(L) {
    this.tokenizer = L;
  }
  async readPacketHeader() {
    const L = await this.tokenizer.readToken(PacketKey), A = await this.readVariableSizeField();
    return {
      key: L,
      payloadLength: A.value - 2 - A.len
    };
  }
  async readStreamHeader(L) {
    const A = {};
    debug$c(`Reading SH at offset=${this.tokenizer.position}`);
    const W = await this.tokenizer.readToken(SH_part1);
    L -= SH_part1.len, Object.assign(A, W), debug$c(`SH.streamVersion = ${W.streamVersion}`);
    const X = await this.readVariableSizeField();
    L -= X.len, A.sampleCount = X.value;
    const J = await this.readVariableSizeField();
    L -= J.len, A.beginningOfSilence = J.value;
    const te = await this.tokenizer.readToken(SH_part3);
    return L -= SH_part3.len, Object.assign(A, te), await this.tokenizer.ignore(L), A;
  }
  async readVariableSizeField(L = 1, A = 0) {
    let W = await this.tokenizer.readNumber(Token$f.UINT8);
    return W & 128 ? (W &= 127, W += A, this.readVariableSizeField(L + 1, W << 7)) : { len: L, value: A + W };
  }
}
StreamVersion8.StreamReader = StreamReader;
Object.defineProperty(MpcSv8Parser$1, "__esModule", { value: !0 });
MpcSv8Parser$1.MpcSv8Parser = void 0;
const debug_1$b = browserExports, BasicParser_1$6 = BasicParser$1, APEv2Parser_1$4 = APEv2Parser$1, FourCC_1$6 = FourCC, SV8 = StreamVersion8, debug$b = (0, debug_1$b.default)("music-metadata:parser:musepack");
class MpcSv8Parser extends BasicParser_1$6.BasicParser {
  constructor() {
    super(...arguments), this.audioLength = 0;
  }
  async parse() {
    if (await this.tokenizer.readToken(FourCC_1$6.FourCcToken) !== "MPCK")
      throw new Error("Invalid Magic number");
    return this.metadata.setFormat("container", "Musepack, SV8"), this.parsePacket();
  }
  async parsePacket() {
    const L = new SV8.StreamReader(this.tokenizer);
    do {
      const A = await L.readPacketHeader();
      switch (debug$b(`packet-header key=${A.key}, payloadLength=${A.payloadLength}`), A.key) {
        case "SH":
          const W = await L.readStreamHeader(A.payloadLength);
          this.metadata.setFormat("numberOfSamples", W.sampleCount), this.metadata.setFormat("sampleRate", W.sampleFrequency), this.metadata.setFormat("duration", W.sampleCount / W.sampleFrequency), this.metadata.setFormat("numberOfChannels", W.channelCount);
          break;
        case "AP":
          this.audioLength += A.payloadLength, await this.tokenizer.ignore(A.payloadLength);
          break;
        case "RG":
        case "EI":
        case "SO":
        case "ST":
        case "CT":
          await this.tokenizer.ignore(A.payloadLength);
          break;
        case "SE":
          return this.metadata.setFormat("bitrate", this.audioLength * 8 / this.metadata.format.duration), APEv2Parser_1$4.APEv2Parser.tryParseApeHeader(this.metadata, this.tokenizer, this.options);
        default:
          throw new Error(`Unexpected header: ${A.key}`);
      }
    } while (!0);
  }
}
MpcSv8Parser$1.MpcSv8Parser = MpcSv8Parser;
var MpcSv7Parser$1 = {}, BitReader$1 = {};
Object.defineProperty(BitReader$1, "__esModule", { value: !0 });
BitReader$1.BitReader = void 0;
const Token$e = lib$1;
class BitReader {
  constructor(L) {
    this.tokenizer = L, this.pos = 0, this.dword = void 0;
  }
  /**
   *
   * @param bits 1..30 bits
   */
  async read(L) {
    for (; this.dword === void 0; )
      this.dword = await this.tokenizer.readToken(Token$e.UINT32_LE);
    let A = this.dword;
    return this.pos += L, this.pos < 32 ? (A >>>= 32 - this.pos, A & (1 << L) - 1) : (this.pos -= 32, this.pos === 0 ? (this.dword = void 0, A & (1 << L) - 1) : (this.dword = await this.tokenizer.readToken(Token$e.UINT32_LE), this.pos && (A <<= this.pos, A |= this.dword >>> 32 - this.pos), A & (1 << L) - 1));
  }
  async ignore(L) {
    if (this.pos > 0) {
      const X = 32 - this.pos;
      this.dword = void 0, L -= X, this.pos = 0;
    }
    const A = L % 32, W = (L - A) / 32;
    return await this.tokenizer.ignore(W * 4), this.read(A);
  }
}
BitReader$1.BitReader = BitReader;
var StreamVersion7 = {};
Object.defineProperty(StreamVersion7, "__esModule", { value: !0 });
StreamVersion7.Header = void 0;
const Token$d = lib$1, util$4 = Util;
StreamVersion7.Header = {
  len: 6 * 4,
  get: (C, L) => {
    const A = {
      // word 0
      signature: Buffer.from(C).toString("latin1", L, L + 3),
      // versionIndex number * 1000 (3.81 = 3810) (remember that 4-byte alignment causes this to take 4-bytes)
      streamMinorVersion: util$4.getBitAllignedNumber(C, L + 3, 0, 4),
      streamMajorVersion: util$4.getBitAllignedNumber(C, L + 3, 4, 4),
      // word 1
      frameCount: Token$d.UINT32_LE.get(C, L + 4),
      // word 2
      maxLevel: Token$d.UINT16_LE.get(C, L + 8),
      sampleFrequency: [44100, 48e3, 37800, 32e3][util$4.getBitAllignedNumber(C, L + 10, 0, 2)],
      link: util$4.getBitAllignedNumber(C, L + 10, 2, 2),
      profile: util$4.getBitAllignedNumber(C, L + 10, 4, 4),
      maxBand: util$4.getBitAllignedNumber(C, L + 11, 0, 6),
      intensityStereo: util$4.isBitSet(C, L + 11, 6),
      midSideStereo: util$4.isBitSet(C, L + 11, 7),
      // word 3
      titlePeak: Token$d.UINT16_LE.get(C, L + 12),
      titleGain: Token$d.UINT16_LE.get(C, L + 14),
      // word 4
      albumPeak: Token$d.UINT16_LE.get(C, L + 16),
      albumGain: Token$d.UINT16_LE.get(C, L + 18),
      // word
      lastFrameLength: Token$d.UINT32_LE.get(C, L + 20) >>> 20 & 2047,
      trueGapless: util$4.isBitSet(C, L + 23, 0)
    };
    return A.lastFrameLength = A.trueGapless ? Token$d.UINT32_LE.get(C, 20) >>> 20 & 2047 : 0, A;
  }
};
Object.defineProperty(MpcSv7Parser$1, "__esModule", { value: !0 });
MpcSv7Parser$1.MpcSv7Parser = void 0;
const debug_1$a = browserExports, BasicParser_1$5 = BasicParser$1, APEv2Parser_1$3 = APEv2Parser$1, BitReader_1 = BitReader$1, SV7 = StreamVersion7, debug$a = (0, debug_1$a.default)("music-metadata:parser:musepack");
class MpcSv7Parser extends BasicParser_1$5.BasicParser {
  constructor() {
    super(...arguments), this.audioLength = 0;
  }
  async parse() {
    const L = await this.tokenizer.readToken(SV7.Header);
    if (L.signature !== "MP+")
      throw new Error("Unexpected magic number");
    debug$a(`stream-version=${L.streamMajorVersion}.${L.streamMinorVersion}`), this.metadata.setFormat("container", "Musepack, SV7"), this.metadata.setFormat("sampleRate", L.sampleFrequency);
    const A = 1152 * (L.frameCount - 1) + L.lastFrameLength;
    this.metadata.setFormat("numberOfSamples", A), this.duration = A / L.sampleFrequency, this.metadata.setFormat("duration", this.duration), this.bitreader = new BitReader_1.BitReader(this.tokenizer), this.metadata.setFormat("numberOfChannels", L.midSideStereo || L.intensityStereo ? 2 : 1);
    const W = await this.bitreader.read(8);
    return this.metadata.setFormat("codec", (W / 100).toFixed(2)), await this.skipAudioData(L.frameCount), debug$a(`End of audio stream, switching to APEv2, offset=${this.tokenizer.position}`), APEv2Parser_1$3.APEv2Parser.tryParseApeHeader(this.metadata, this.tokenizer, this.options);
  }
  async skipAudioData(L) {
    for (; L-- > 0; ) {
      const W = await this.bitreader.read(20);
      this.audioLength += 20 + W, await this.bitreader.ignore(W);
    }
    const A = await this.bitreader.read(11);
    this.audioLength += A, this.metadata.setFormat("bitrate", this.audioLength / this.duration);
  }
}
MpcSv7Parser$1.MpcSv7Parser = MpcSv7Parser;
Object.defineProperty(musepack, "__esModule", { value: !0 });
const debug_1$9 = browserExports, Token$c = lib$1, AbstractID3Parser_1$1 = AbstractID3Parser$1, MpcSv8Parser_1 = MpcSv8Parser$1, MpcSv7Parser_1 = MpcSv7Parser$1, debug$9 = (0, debug_1$9.default)("music-metadata:parser:musepack");
class MusepackParser extends AbstractID3Parser_1$1.AbstractID3Parser {
  async postId3v2Parse() {
    const L = await this.tokenizer.peekToken(new Token$c.StringType(3, "binary"));
    let A;
    switch (L) {
      case "MP+": {
        debug$9("Musepack stream-version 7"), A = new MpcSv7Parser_1.MpcSv7Parser();
        break;
      }
      case "MPC": {
        debug$9("Musepack stream-version 8"), A = new MpcSv8Parser_1.MpcSv8Parser();
        break;
      }
      default:
        throw new Error("Invalid Musepack signature prefix");
    }
    return A.init(this.metadata, this.tokenizer, this.options), A.parse();
  }
}
musepack.default = MusepackParser;
var OggParser$1 = {}, OpusParser$1 = {}, Opus$1 = {};
Object.defineProperty(Opus$1, "__esModule", { value: !0 });
Opus$1.IdHeader = void 0;
const Token$b = lib$1;
class IdHeader {
  constructor(L) {
    if (this.len = L, L < 19)
      throw new Error("ID-header-page 0 should be at least 19 bytes long");
  }
  get(L, A) {
    return {
      magicSignature: new Token$b.StringType(8, "ascii").get(L, A + 0),
      version: L.readUInt8(A + 8),
      channelCount: L.readUInt8(A + 9),
      preSkip: L.readInt16LE(A + 10),
      inputSampleRate: L.readInt32LE(A + 12),
      outputGain: L.readInt16LE(A + 16),
      channelMapping: L.readUInt8(A + 18)
    };
  }
}
Opus$1.IdHeader = IdHeader;
Object.defineProperty(OpusParser$1, "__esModule", { value: !0 });
OpusParser$1.OpusParser = void 0;
const Token$a = lib$1, VorbisParser_1$2 = VorbisParser$1, Opus = Opus$1;
class OpusParser extends VorbisParser_1$2.VorbisParser {
  constructor(L, A, W) {
    super(L, A), this.tokenizer = W, this.lastPos = -1;
  }
  /**
   * Parse first Opus Ogg page
   * @param {IPageHeader} header
   * @param {Buffer} pageData
   */
  parseFirstPage(L, A) {
    if (this.metadata.setFormat("codec", "Opus"), this.idHeader = new Opus.IdHeader(A.length).get(A, 0), this.idHeader.magicSignature !== "OpusHead")
      throw new Error("Illegal ogg/Opus magic-signature");
    this.metadata.setFormat("sampleRate", this.idHeader.inputSampleRate), this.metadata.setFormat("numberOfChannels", this.idHeader.channelCount);
  }
  parseFullPage(L) {
    switch (new Token$a.StringType(8, "ascii").get(L, 0)) {
      case "OpusTags":
        this.parseUserCommentList(L, 8), this.lastPos = this.tokenizer.position - L.length;
        break;
    }
  }
  calculateDuration(L) {
    if (this.metadata.format.sampleRate && L.absoluteGranulePosition >= 0) {
      const A = L.absoluteGranulePosition - this.idHeader.preSkip;
      if (this.metadata.setFormat("numberOfSamples", A), this.metadata.setFormat("duration", A / 48e3), this.lastPos !== -1 && this.tokenizer.fileInfo.size && this.metadata.format.duration) {
        const W = this.tokenizer.fileInfo.size - this.lastPos;
        this.metadata.setFormat("bitrate", 8 * W / this.metadata.format.duration);
      }
    }
  }
}
OpusParser$1.OpusParser = OpusParser;
var SpeexParser$1 = {}, Speex$1 = {};
Object.defineProperty(Speex$1, "__esModule", { value: !0 });
Speex$1.Header = void 0;
const Token$9 = lib$1, util$3 = Util;
Speex$1.Header = {
  len: 80,
  get: (C, L) => ({
    speex: new Token$9.StringType(8, "ascii").get(C, L + 0),
    version: util$3.trimRightNull(new Token$9.StringType(20, "ascii").get(C, L + 8)),
    version_id: C.readInt32LE(L + 28),
    header_size: C.readInt32LE(L + 32),
    rate: C.readInt32LE(L + 36),
    mode: C.readInt32LE(L + 40),
    mode_bitstream_version: C.readInt32LE(L + 44),
    nb_channels: C.readInt32LE(L + 48),
    bitrate: C.readInt32LE(L + 52),
    frame_size: C.readInt32LE(L + 56),
    vbr: C.readInt32LE(L + 60),
    frames_per_packet: C.readInt32LE(L + 64),
    extra_headers: C.readInt32LE(L + 68),
    reserved1: C.readInt32LE(L + 72),
    reserved2: C.readInt32LE(L + 76)
  })
};
Object.defineProperty(SpeexParser$1, "__esModule", { value: !0 });
SpeexParser$1.SpeexParser = void 0;
const debug_1$8 = browserExports, VorbisParser_1$1 = VorbisParser$1, Speex = Speex$1, debug$8 = (0, debug_1$8.default)("music-metadata:parser:ogg:speex");
class SpeexParser extends VorbisParser_1$1.VorbisParser {
  constructor(L, A, W) {
    super(L, A), this.tokenizer = W;
  }
  /**
   * Parse first Speex Ogg page
   * @param {IPageHeader} header
   * @param {Buffer} pageData
   */
  parseFirstPage(L, A) {
    debug$8("First Ogg/Speex page");
    const W = Speex.Header.get(A, 0);
    this.metadata.setFormat("codec", `Speex ${W.version}`), this.metadata.setFormat("numberOfChannels", W.nb_channels), this.metadata.setFormat("sampleRate", W.rate), W.bitrate !== -1 && this.metadata.setFormat("bitrate", W.bitrate);
  }
}
SpeexParser$1.SpeexParser = SpeexParser;
var TheoraParser$1 = {}, Theora = {};
Object.defineProperty(Theora, "__esModule", { value: !0 });
Theora.IdentificationHeader = void 0;
const Token$8 = lib$1;
Theora.IdentificationHeader = {
  len: 42,
  get: (C, L) => ({
    id: new Token$8.StringType(7, "ascii").get(C, L),
    vmaj: C.readUInt8(L + 7),
    vmin: C.readUInt8(L + 8),
    vrev: C.readUInt8(L + 9),
    vmbw: C.readUInt16BE(L + 10),
    vmbh: C.readUInt16BE(L + 17),
    nombr: Token$8.UINT24_BE.get(C, L + 37),
    nqual: C.readUInt8(L + 40)
  })
};
Object.defineProperty(TheoraParser$1, "__esModule", { value: !0 });
TheoraParser$1.TheoraParser = void 0;
const debug_1$7 = browserExports, Theora_1 = Theora, debug$7 = (0, debug_1$7.default)("music-metadata:parser:ogg:theora");
class TheoraParser {
  constructor(L, A, W) {
    this.metadata = L, this.tokenizer = W;
  }
  /**
   * Vorbis 1 parser
   * @param header Ogg Page Header
   * @param pageData Page data
   */
  parsePage(L, A) {
    L.headerType.firstPage && this.parseFirstPage(L, A);
  }
  flush() {
    debug$7("flush");
  }
  calculateDuration(L) {
    debug$7("duration calculation not implemented");
  }
  /**
   * Parse first Theora Ogg page. the initial identification header packet
   * @param {IPageHeader} header
   * @param {Buffer} pageData
   */
  parseFirstPage(L, A) {
    debug$7("First Ogg/Theora page"), this.metadata.setFormat("codec", "Theora");
    const W = Theora_1.IdentificationHeader.get(A, 0);
    this.metadata.setFormat("bitrate", W.nombr);
  }
}
TheoraParser$1.TheoraParser = TheoraParser;
Object.defineProperty(OggParser$1, "__esModule", { value: !0 });
OggParser$1.OggParser = OggParser$1.SegmentTable = void 0;
const Token$7 = lib$1, core_1 = core$1, debug_1$6 = browserExports, util$2 = Util, FourCC_1$5 = FourCC, BasicParser_1$4 = BasicParser$1, VorbisParser_1 = VorbisParser$1, OpusParser_1 = OpusParser$1, SpeexParser_1 = SpeexParser$1, TheoraParser_1 = TheoraParser$1, debug$6 = (0, debug_1$6.default)("music-metadata:parser:ogg");
class SegmentTable {
  static sum(L, A, W) {
    let X = 0;
    for (let J = A; J < A + W; ++J)
      X += L[J];
    return X;
  }
  constructor(L) {
    this.len = L.page_segments;
  }
  get(L, A) {
    return {
      totalPageSize: SegmentTable.sum(L, A, this.len)
    };
  }
}
OggParser$1.SegmentTable = SegmentTable;
class OggParser extends BasicParser_1$4.BasicParser {
  /**
   * Parse page
   * @returns {Promise<void>}
   */
  async parse() {
    debug$6("pos=%s, parsePage()", this.tokenizer.position);
    try {
      let L;
      do {
        if (L = await this.tokenizer.readToken(OggParser.Header), L.capturePattern !== "OggS")
          throw new Error("Invalid Ogg capture pattern");
        this.metadata.setFormat("container", "Ogg"), this.header = L, this.pageNumber = L.pageSequenceNo, debug$6("page#=%s, Ogg.id=%s", L.pageSequenceNo, L.capturePattern);
        const A = await this.tokenizer.readToken(new SegmentTable(L));
        debug$6("totalPageSize=%s", A.totalPageSize);
        const W = await this.tokenizer.readToken(new Token$7.Uint8ArrayType(A.totalPageSize));
        if (debug$6("firstPage=%s, lastPage=%s, continued=%s", L.headerType.firstPage, L.headerType.lastPage, L.headerType.continued), L.headerType.firstPage) {
          const X = new Token$7.StringType(7, "ascii").get(Buffer.from(W), 0);
          switch (X) {
            case "vorbis":
              debug$6("Set page consumer to Ogg/Vorbis"), this.pageConsumer = new VorbisParser_1.VorbisParser(this.metadata, this.options);
              break;
            case "OpusHea":
              debug$6("Set page consumer to Ogg/Opus"), this.pageConsumer = new OpusParser_1.OpusParser(this.metadata, this.options, this.tokenizer);
              break;
            case "Speex  ":
              debug$6("Set page consumer to Ogg/Speex"), this.pageConsumer = new SpeexParser_1.SpeexParser(this.metadata, this.options, this.tokenizer);
              break;
            case "fishead":
            case "\0theora":
              debug$6("Set page consumer to Ogg/Theora"), this.pageConsumer = new TheoraParser_1.TheoraParser(this.metadata, this.options, this.tokenizer);
              break;
            default:
              throw new Error("gg audio-codec not recognized (id=" + X + ")");
          }
        }
        this.pageConsumer.parsePage(L, W);
      } while (!L.headerType.lastPage);
    } catch (L) {
      if (L instanceof core_1.EndOfStreamError)
        this.metadata.addWarning("Last OGG-page is not marked with last-page flag"), debug$6("End-of-stream"), this.metadata.addWarning("Last OGG-page is not marked with last-page flag"), this.header && this.pageConsumer.calculateDuration(this.header);
      else if (L.message.startsWith("FourCC"))
        this.pageNumber > 0 && (this.metadata.addWarning("Invalid FourCC ID, maybe last OGG-page is not marked with last-page flag"), this.pageConsumer.flush());
      else
        throw L;
    }
  }
}
OggParser.Header = {
  len: 27,
  get: (C, L) => ({
    capturePattern: FourCC_1$5.FourCcToken.get(C, L),
    version: Token$7.UINT8.get(C, L + 4),
    headerType: {
      continued: util$2.getBit(C, L + 5, 0),
      firstPage: util$2.getBit(C, L + 5, 1),
      lastPage: util$2.getBit(C, L + 5, 2)
    },
    // packet_flag: buf.readUInt8(off + 5),
    absoluteGranulePosition: Number(Token$7.UINT64_LE.get(C, L + 6)),
    streamSerialNumber: Token$7.UINT32_LE.get(C, L + 14),
    pageSequenceNo: Token$7.UINT32_LE.get(C, L + 18),
    pageChecksum: Token$7.UINT32_LE.get(C, L + 22),
    page_segments: Token$7.UINT8.get(C, L + 26)
  })
};
OggParser$1.OggParser = OggParser;
var WaveParser$1 = {}, RiffChunk = {};
Object.defineProperty(RiffChunk, "__esModule", { value: !0 });
RiffChunk.ListInfoTagValue = RiffChunk.Header = void 0;
const Token$6 = lib$1;
RiffChunk.Header = {
  len: 8,
  get: (C, L) => ({
    // Group-ID
    chunkID: C.toString("binary", L, L + 4),
    // Size
    chunkSize: Token$6.UINT32_LE.get(C, 4)
  })
};
class ListInfoTagValue {
  constructor(L) {
    this.tagHeader = L, this.len = L.chunkSize, this.len += this.len & 1;
  }
  get(L, A) {
    return new Token$6.StringType(this.tagHeader.chunkSize, "ascii").get(L, A);
  }
}
RiffChunk.ListInfoTagValue = ListInfoTagValue;
var WaveChunk$1 = {};
(function(C) {
  Object.defineProperty(C, "__esModule", { value: !0 }), C.FactChunk = C.Format = C.WaveFormat = void 0, function(W) {
    W[W.PCM = 1] = "PCM", W[W.ADPCM = 2] = "ADPCM", W[W.IEEE_FLOAT = 3] = "IEEE_FLOAT", W[W.MPEG_ADTS_AAC = 5632] = "MPEG_ADTS_AAC", W[W.MPEG_LOAS = 5634] = "MPEG_LOAS", W[W.RAW_AAC1 = 255] = "RAW_AAC1", W[W.DOLBY_AC3_SPDIF = 146] = "DOLBY_AC3_SPDIF", W[W.DVM = 8192] = "DVM", W[W.RAW_SPORT = 576] = "RAW_SPORT", W[W.ESST_AC3 = 577] = "ESST_AC3", W[W.DRM = 9] = "DRM", W[W.DTS2 = 8193] = "DTS2", W[W.MPEG = 80] = "MPEG";
  }(C.WaveFormat || (C.WaveFormat = {}));
  class L {
    constructor(X) {
      if (X.chunkSize < 16)
        throw new Error("Invalid chunk size");
      this.len = X.chunkSize;
    }
    get(X, J) {
      return {
        wFormatTag: X.readUInt16LE(J),
        nChannels: X.readUInt16LE(J + 2),
        nSamplesPerSec: X.readUInt32LE(J + 4),
        nAvgBytesPerSec: X.readUInt32LE(J + 8),
        nBlockAlign: X.readUInt16LE(J + 12),
        wBitsPerSample: X.readUInt16LE(J + 14)
      };
    }
  }
  C.Format = L;
  class A {
    constructor(X) {
      if (X.chunkSize < 4)
        throw new Error("Invalid fact chunk size.");
      this.len = X.chunkSize;
    }
    get(X, J) {
      return {
        dwSampleLength: X.readUInt32LE(J)
      };
    }
  }
  C.FactChunk = A;
})(WaveChunk$1);
var BwfChunk = {};
Object.defineProperty(BwfChunk, "__esModule", { value: !0 });
BwfChunk.BroadcastAudioExtensionChunk = void 0;
const Token$5 = lib$1, Util_1 = Util;
BwfChunk.BroadcastAudioExtensionChunk = {
  len: 420,
  get: (C, L) => ({
    description: (0, Util_1.stripNulls)(new Token$5.StringType(256, "ascii").get(C, L)).trim(),
    originator: (0, Util_1.stripNulls)(new Token$5.StringType(32, "ascii").get(C, L + 256)).trim(),
    originatorReference: (0, Util_1.stripNulls)(new Token$5.StringType(32, "ascii").get(C, L + 288)).trim(),
    originationDate: (0, Util_1.stripNulls)(new Token$5.StringType(10, "ascii").get(C, L + 320)).trim(),
    originationTime: (0, Util_1.stripNulls)(new Token$5.StringType(8, "ascii").get(C, L + 330)).trim(),
    timeReferenceLow: Token$5.UINT32_LE.get(C, L + 338),
    timeReferenceHigh: Token$5.UINT32_LE.get(C, L + 342),
    version: Token$5.UINT16_LE.get(C, L + 346),
    umid: new Token$5.Uint8ArrayType(64).get(C, L + 348),
    loudnessValue: Token$5.UINT16_LE.get(C, L + 412),
    maxTruePeakLevel: Token$5.UINT16_LE.get(C, L + 414),
    maxMomentaryLoudness: Token$5.UINT16_LE.get(C, L + 416),
    maxShortTermLoudness: Token$5.UINT16_LE.get(C, L + 418)
  })
};
Object.defineProperty(WaveParser$1, "__esModule", { value: !0 });
WaveParser$1.WaveParser = void 0;
const strtok3$2 = core$1, Token$4 = lib$1, debug_1$5 = browserExports, riff = RiffChunk, WaveChunk = WaveChunk$1, ID3v2Parser_1$2 = ID3v2Parser$1, util$1 = Util, FourCC_1$4 = FourCC, BasicParser_1$3 = BasicParser$1, BwfChunk_1 = BwfChunk, debug$5 = (0, debug_1$5.default)("music-metadata:parser:RIFF");
class WaveParser extends BasicParser_1$3.BasicParser {
  async parse() {
    const L = await this.tokenizer.readToken(riff.Header);
    if (debug$5(`pos=${this.tokenizer.position}, parse: chunkID=${L.chunkID}`), L.chunkID === "RIFF")
      return this.parseRiffChunk(L.chunkSize).catch((A) => {
        if (!(A instanceof strtok3$2.EndOfStreamError))
          throw A;
      });
  }
  async parseRiffChunk(L) {
    const A = await this.tokenizer.readToken(FourCC_1$4.FourCcToken);
    switch (this.metadata.setFormat("container", A), A) {
      case "WAVE":
        return this.readWaveChunk(L - FourCC_1$4.FourCcToken.len);
      default:
        throw new Error(`Unsupported RIFF format: RIFF/${A}`);
    }
  }
  async readWaveChunk(L) {
    for (; L >= riff.Header.len; ) {
      const A = await this.tokenizer.readToken(riff.Header);
      switch (L -= riff.Header.len + A.chunkSize, A.chunkSize > L && this.metadata.addWarning("Data chunk size exceeds file size"), this.header = A, debug$5(`pos=${this.tokenizer.position}, readChunk: chunkID=RIFF/WAVE/${A.chunkID}`), A.chunkID) {
        case "LIST":
          await this.parseListTag(A);
          break;
        case "fact":
          this.metadata.setFormat("lossless", !1), this.fact = await this.tokenizer.readToken(new WaveChunk.FactChunk(A));
          break;
        case "fmt ":
          const W = await this.tokenizer.readToken(new WaveChunk.Format(A));
          let X = WaveChunk.WaveFormat[W.wFormatTag];
          X || (debug$5("WAVE/non-PCM format=" + W.wFormatTag), X = "non-PCM (" + W.wFormatTag + ")"), this.metadata.setFormat("codec", X), this.metadata.setFormat("bitsPerSample", W.wBitsPerSample), this.metadata.setFormat("sampleRate", W.nSamplesPerSec), this.metadata.setFormat("numberOfChannels", W.nChannels), this.metadata.setFormat("bitrate", W.nBlockAlign * W.nSamplesPerSec * 8), this.blockAlign = W.nBlockAlign;
          break;
        case "id3 ":
        case "ID3 ":
          const J = await this.tokenizer.readToken(new Token$4.Uint8ArrayType(A.chunkSize)), te = strtok3$2.fromBuffer(J);
          await new ID3v2Parser_1$2.ID3v2Parser().parse(this.metadata, te, this.options);
          break;
        case "data":
          this.metadata.format.lossless !== !1 && this.metadata.setFormat("lossless", !0);
          let oe = A.chunkSize;
          if (this.tokenizer.fileInfo.size) {
            const ue = this.tokenizer.fileInfo.size - this.tokenizer.position;
            ue < oe && (this.metadata.addWarning("data chunk length exceeding file length"), oe = ue);
          }
          const ne = this.fact ? this.fact.dwSampleLength : oe === 4294967295 ? void 0 : oe / this.blockAlign;
          ne && (this.metadata.setFormat("numberOfSamples", ne), this.metadata.setFormat("duration", ne / this.metadata.format.sampleRate)), this.metadata.format.codec === "ADPCM" ? this.metadata.setFormat("bitrate", 352e3) : this.metadata.setFormat("bitrate", this.blockAlign * this.metadata.format.sampleRate * 8), await this.tokenizer.ignore(A.chunkSize);
          break;
        case "bext":
          const re = await this.tokenizer.readToken(BwfChunk_1.BroadcastAudioExtensionChunk);
          Object.keys(re).forEach((ue) => {
            this.metadata.addTag("exif", "bext." + ue, re[ue]);
          });
          const ce = A.chunkSize - BwfChunk_1.BroadcastAudioExtensionChunk.len;
          await this.tokenizer.ignore(ce);
          break;
        case "\0\0\0\0":
          debug$5(`Ignore padding chunk: RIFF/${A.chunkID} of ${A.chunkSize} bytes`), this.metadata.addWarning("Ignore chunk: RIFF/" + A.chunkID), await this.tokenizer.ignore(A.chunkSize);
          break;
        default:
          debug$5(`Ignore chunk: RIFF/${A.chunkID} of ${A.chunkSize} bytes`), this.metadata.addWarning("Ignore chunk: RIFF/" + A.chunkID), await this.tokenizer.ignore(A.chunkSize);
      }
      this.header.chunkSize % 2 === 1 && (debug$5("Read odd padding byte"), await this.tokenizer.ignore(1));
    }
  }
  async parseListTag(L) {
    const A = await this.tokenizer.readToken(new Token$4.StringType(4, "binary"));
    switch (debug$5("pos=%s, parseListTag: chunkID=RIFF/WAVE/LIST/%s", this.tokenizer.position, A), A) {
      case "INFO":
        return this.parseRiffInfoTags(L.chunkSize - 4);
      case "adtl":
      default:
        return this.metadata.addWarning("Ignore chunk: RIFF/WAVE/LIST/" + A), debug$5("Ignoring chunkID=RIFF/WAVE/LIST/" + A), this.tokenizer.ignore(L.chunkSize - 4).then();
    }
  }
  async parseRiffInfoTags(L) {
    for (; L >= 8; ) {
      const A = await this.tokenizer.readToken(riff.Header), W = new riff.ListInfoTagValue(A), X = await this.tokenizer.readToken(W);
      this.addTag(A.chunkID, util$1.stripNulls(X)), L -= 8 + W.len;
    }
    if (L !== 0)
      throw Error("Illegal remaining size: " + L);
  }
  addTag(L, A) {
    this.metadata.addTag("exif", L, A);
  }
}
WaveParser$1.WaveParser = WaveParser;
var WavPackParser$1 = {}, WavPackToken = {};
Object.defineProperty(WavPackToken, "__esModule", { value: !0 });
WavPackToken.WavPack = void 0;
const Token$3 = lib$1, FourCC_1$3 = FourCC, SampleRates = [
  6e3,
  8e3,
  9600,
  11025,
  12e3,
  16e3,
  22050,
  24e3,
  32e3,
  44100,
  48e3,
  64e3,
  88200,
  96e3,
  192e3,
  -1
];
class WavPack {
  static isBitSet(L, A) {
    return WavPack.getBitAllignedNumber(L, A, 1) === 1;
  }
  static getBitAllignedNumber(L, A, W) {
    return L >>> A & 4294967295 >>> 32 - W;
  }
}
WavPack.BlockHeaderToken = {
  len: 32,
  get: (C, L) => {
    const A = Token$3.UINT32_LE.get(C, L + 24), W = {
      // should equal 'wvpk'
      BlockID: FourCC_1$3.FourCcToken.get(C, L),
      //  0x402 to 0x410 are valid for decode
      blockSize: Token$3.UINT32_LE.get(C, L + 4),
      //  0x402 (1026) to 0x410 are valid for decode
      version: Token$3.UINT16_LE.get(C, L + 8),
      //  40-bit total samples for entire file (if block_index == 0 and a value of -1 indicates an unknown length)
      totalSamples: (
        /* replace with bigint? (Token.UINT8.get(buf, off + 11) << 32) + */
        Token$3.UINT32_LE.get(C, L + 12)
      ),
      // 40-bit block_index
      blockIndex: (
        /* replace with bigint? (Token.UINT8.get(buf, off + 10) << 32) + */
        Token$3.UINT32_LE.get(C, L + 16)
      ),
      // 40-bit total samples for entire file (if block_index == 0 and a value of -1 indicates an unknown length)
      blockSamples: Token$3.UINT32_LE.get(C, L + 20),
      // various flags for id and decoding
      flags: {
        bitsPerSample: (1 + WavPack.getBitAllignedNumber(A, 0, 2)) * 8,
        isMono: WavPack.isBitSet(A, 2),
        isHybrid: WavPack.isBitSet(A, 3),
        isJointStereo: WavPack.isBitSet(A, 4),
        crossChannel: WavPack.isBitSet(A, 5),
        hybridNoiseShaping: WavPack.isBitSet(A, 6),
        floatingPoint: WavPack.isBitSet(A, 7),
        samplingRate: SampleRates[WavPack.getBitAllignedNumber(A, 23, 4)],
        isDSD: WavPack.isBitSet(A, 31)
      },
      // crc for actual decoded data
      crc: new Token$3.Uint8ArrayType(4).get(C, L + 28)
    };
    return W.flags.isDSD && (W.totalSamples *= 8), W;
  }
};
WavPack.MetadataIdToken = {
  len: 1,
  get: (C, L) => ({
    functionId: WavPack.getBitAllignedNumber(C[L], 0, 6),
    isOptional: WavPack.isBitSet(C[L], 5),
    isOddSize: WavPack.isBitSet(C[L], 6),
    largeBlock: WavPack.isBitSet(C[L], 7)
  })
};
WavPackToken.WavPack = WavPack;
Object.defineProperty(WavPackParser$1, "__esModule", { value: !0 });
WavPackParser$1.WavPackParser = void 0;
const Token$2 = lib$1, APEv2Parser_1$2 = APEv2Parser$1, FourCC_1$2 = FourCC, BasicParser_1$2 = BasicParser$1, WavPackToken_1 = WavPackToken, debug_1$4 = browserExports, debug$4 = (0, debug_1$4.default)("music-metadata:parser:WavPack");
class WavPackParser extends BasicParser_1$2.BasicParser {
  async parse() {
    return this.audioDataSize = 0, await this.parseWavPackBlocks(), APEv2Parser_1$2.APEv2Parser.tryParseApeHeader(this.metadata, this.tokenizer, this.options);
  }
  async parseWavPackBlocks() {
    do {
      if (await this.tokenizer.peekToken(FourCC_1$2.FourCcToken) !== "wvpk")
        break;
      const A = await this.tokenizer.readToken(WavPackToken_1.WavPack.BlockHeaderToken);
      if (A.BlockID !== "wvpk")
        throw new Error("Invalid WavPack Block-ID");
      debug$4(`WavPack header blockIndex=${A.blockIndex}, len=${WavPackToken_1.WavPack.BlockHeaderToken.len}`), A.blockIndex === 0 && !this.metadata.format.container && (this.metadata.setFormat("container", "WavPack"), this.metadata.setFormat("lossless", !A.flags.isHybrid), this.metadata.setFormat("bitsPerSample", A.flags.bitsPerSample), A.flags.isDSD || (this.metadata.setFormat("sampleRate", A.flags.samplingRate), this.metadata.setFormat("duration", A.totalSamples / A.flags.samplingRate)), this.metadata.setFormat("numberOfChannels", A.flags.isMono ? 1 : 2), this.metadata.setFormat("numberOfSamples", A.totalSamples), this.metadata.setFormat("codec", A.flags.isDSD ? "DSD" : "PCM"));
      const W = A.blockSize - (WavPackToken_1.WavPack.BlockHeaderToken.len - 8);
      await (A.blockIndex === 0 ? this.parseMetadataSubBlock(A, W) : this.tokenizer.ignore(W)), A.blockSamples > 0 && (this.audioDataSize += A.blockSize);
    } while (!this.tokenizer.fileInfo.size || this.tokenizer.fileInfo.size - this.tokenizer.position >= WavPackToken_1.WavPack.BlockHeaderToken.len);
    this.metadata.setFormat("bitrate", this.audioDataSize * 8 / this.metadata.format.duration);
  }
  /**
   * Ref: http://www.wavpack.com/WavPack5FileFormat.pdf, 3.0 Metadata Sub-blocks
   * @param remainingLength
   */
  async parseMetadataSubBlock(L, A) {
    for (; A > WavPackToken_1.WavPack.MetadataIdToken.len; ) {
      const W = await this.tokenizer.readToken(WavPackToken_1.WavPack.MetadataIdToken), X = await this.tokenizer.readNumber(W.largeBlock ? Token$2.UINT24_LE : Token$2.UINT8), J = Buffer.alloc(X * 2 - (W.isOddSize ? 1 : 0));
      switch (await this.tokenizer.readBuffer(J), debug$4(`Metadata Sub-Blocks functionId=0x${W.functionId.toString(16)}, id.largeBlock=${W.largeBlock},data-size=${J.length}`), W.functionId) {
        case 0:
          break;
        case 14:
          debug$4("ID_DSD_BLOCK");
          const te = 1 << J.readUInt8(0), oe = L.flags.samplingRate * te * 8;
          if (!L.flags.isDSD)
            throw new Error("Only expect DSD block if DSD-flag is set");
          this.metadata.setFormat("sampleRate", oe), this.metadata.setFormat("duration", L.totalSamples / oe);
          break;
        case 36:
          debug$4("ID_ALT_TRAILER: trailer for non-wav files");
          break;
        case 38:
          this.metadata.setFormat("audioMD5", J);
          break;
        case 47:
          debug$4(`ID_BLOCK_CHECKSUM: checksum=${J.toString("hex")}`);
          break;
        default:
          debug$4(`Ignore unsupported meta-sub-block-id functionId=0x${W.functionId.toString(16)}`);
          break;
      }
      A -= WavPackToken_1.WavPack.MetadataIdToken.len + (W.largeBlock ? Token$2.UINT24_LE.len : Token$2.UINT8.len) + X * 2, debug$4(`remainingLength=${A}`), W.isOddSize && this.tokenizer.ignore(1);
    }
    if (A !== 0)
      throw new Error("metadata-sub-block should fit it remaining length");
  }
}
WavPackParser$1.WavPackParser = WavPackParser;
var DsfParser$1 = {}, DsfChunk = {};
(function(C) {
  Object.defineProperty(C, "__esModule", { value: !0 }), C.FormatChunk = C.ChannelType = C.DsdChunk = C.ChunkHeader = void 0;
  const L = lib$1, A = FourCC;
  C.ChunkHeader = {
    len: 12,
    get: (W, X) => ({ id: A.FourCcToken.get(W, X), size: L.UINT64_LE.get(W, X + 4) })
  }, C.DsdChunk = {
    len: 16,
    get: (W, X) => ({
      fileSize: L.INT64_LE.get(W, X),
      metadataPointer: L.INT64_LE.get(W, X + 8)
    })
  }, function(W) {
    W[W.mono = 1] = "mono", W[W.stereo = 2] = "stereo", W[W.channels = 3] = "channels", W[W.quad = 4] = "quad", W[W["4 channels"] = 5] = "4 channels", W[W["5 channels"] = 6] = "5 channels", W[W["5.1 channels"] = 7] = "5.1 channels";
  }(C.ChannelType || (C.ChannelType = {})), C.FormatChunk = {
    len: 40,
    get: (W, X) => ({
      formatVersion: L.INT32_LE.get(W, X),
      formatID: L.INT32_LE.get(W, X + 4),
      channelType: L.INT32_LE.get(W, X + 8),
      channelNum: L.INT32_LE.get(W, X + 12),
      samplingFrequency: L.INT32_LE.get(W, X + 16),
      bitsPerSample: L.INT32_LE.get(W, X + 20),
      sampleCount: L.INT64_LE.get(W, X + 24),
      blockSizePerChannel: L.INT32_LE.get(W, X + 32)
    })
  };
})(DsfChunk);
Object.defineProperty(DsfParser$1, "__esModule", { value: !0 });
DsfParser$1.DsfParser = void 0;
const debug_1$3 = browserExports, AbstractID3Parser_1 = AbstractID3Parser$1, DsfChunk_1 = DsfChunk, ID3v2Parser_1$1 = ID3v2Parser$1, debug$3 = (0, debug_1$3.default)("music-metadata:parser:DSF");
class DsfParser extends AbstractID3Parser_1.AbstractID3Parser {
  async postId3v2Parse() {
    const L = this.tokenizer.position, A = await this.tokenizer.readToken(DsfChunk_1.ChunkHeader);
    if (A.id !== "DSD ")
      throw new Error("Invalid chunk signature");
    this.metadata.setFormat("container", "DSF"), this.metadata.setFormat("lossless", !0);
    const W = await this.tokenizer.readToken(DsfChunk_1.DsdChunk);
    if (W.metadataPointer === BigInt(0))
      debug$3("No ID3v2 tag present");
    else
      return debug$3(`expect ID3v2 at offset=${W.metadataPointer}`), await this.parseChunks(W.fileSize - A.size), await this.tokenizer.ignore(Number(W.metadataPointer) - this.tokenizer.position - L), new ID3v2Parser_1$1.ID3v2Parser().parse(this.metadata, this.tokenizer, this.options);
  }
  async parseChunks(L) {
    for (; L >= DsfChunk_1.ChunkHeader.len; ) {
      const A = await this.tokenizer.readToken(DsfChunk_1.ChunkHeader);
      switch (debug$3(`Parsing chunk name=${A.id} size=${A.size}`), A.id) {
        case "fmt ":
          const W = await this.tokenizer.readToken(DsfChunk_1.FormatChunk);
          this.metadata.setFormat("numberOfChannels", W.channelNum), this.metadata.setFormat("sampleRate", W.samplingFrequency), this.metadata.setFormat("bitsPerSample", W.bitsPerSample), this.metadata.setFormat("numberOfSamples", W.sampleCount), this.metadata.setFormat("duration", Number(W.sampleCount) / W.samplingFrequency);
          const X = W.bitsPerSample * W.samplingFrequency * W.channelNum;
          this.metadata.setFormat("bitrate", X);
          return;
        default:
          this.tokenizer.ignore(Number(A.size) - DsfChunk_1.ChunkHeader.len);
          break;
      }
      L -= A.size;
    }
  }
}
DsfParser$1.DsfParser = DsfParser;
var DsdiffParser$1 = {}, DsdiffToken = {};
Object.defineProperty(DsdiffToken, "__esModule", { value: !0 });
DsdiffToken.ChunkHeader64 = void 0;
const Token$1 = lib$1, FourCC_1$1 = FourCC;
DsdiffToken.ChunkHeader64 = {
  len: 12,
  get: (C, L) => ({
    // Group-ID
    chunkID: FourCC_1$1.FourCcToken.get(C, L),
    // Size
    chunkSize: Token$1.INT64_BE.get(C, L + 4)
  })
};
Object.defineProperty(DsdiffParser$1, "__esModule", { value: !0 });
DsdiffParser$1.DsdiffParser = void 0;
const Token = lib$1, debug_1$2 = browserExports, strtok3$1 = core$1, FourCC_1 = FourCC, BasicParser_1$1 = BasicParser$1, ID3v2Parser_1 = ID3v2Parser$1, DsdiffToken_1 = DsdiffToken, debug$2 = (0, debug_1$2.default)("music-metadata:parser:aiff");
class DsdiffParser extends BasicParser_1$1.BasicParser {
  async parse() {
    const L = await this.tokenizer.readToken(DsdiffToken_1.ChunkHeader64);
    if (L.chunkID !== "FRM8")
      throw new Error("Unexpected chunk-ID");
    const A = (await this.tokenizer.readToken(FourCC_1.FourCcToken)).trim();
    switch (A) {
      case "DSD":
        return this.metadata.setFormat("container", `DSDIFF/${A}`), this.metadata.setFormat("lossless", !0), this.readFmt8Chunks(L.chunkSize - BigInt(FourCC_1.FourCcToken.len));
      default:
        throw Error(`Unsupported DSDIFF type: ${A}`);
    }
  }
  async readFmt8Chunks(L) {
    for (; L >= DsdiffToken_1.ChunkHeader64.len; ) {
      const A = await this.tokenizer.readToken(DsdiffToken_1.ChunkHeader64);
      debug$2(`Chunk id=${A.chunkID}`), await this.readData(A), L -= BigInt(DsdiffToken_1.ChunkHeader64.len) + A.chunkSize;
    }
  }
  async readData(L) {
    debug$2(`Reading data of chunk[ID=${L.chunkID}, size=${L.chunkSize}]`);
    const A = this.tokenizer.position;
    switch (L.chunkID.trim()) {
      case "FVER":
        const X = await this.tokenizer.readToken(Token.UINT32_LE);
        debug$2(`DSDIFF version=${X}`);
        break;
      case "PROP":
        if (await this.tokenizer.readToken(FourCC_1.FourCcToken) !== "SND ")
          throw new Error("Unexpected PROP-chunk ID");
        await this.handleSoundPropertyChunks(L.chunkSize - BigInt(FourCC_1.FourCcToken.len));
        break;
      case "ID3":
        const te = await this.tokenizer.readToken(new Token.Uint8ArrayType(Number(L.chunkSize))), oe = strtok3$1.fromBuffer(te);
        await new ID3v2Parser_1.ID3v2Parser().parse(this.metadata, oe, this.options);
        break;
      default:
        debug$2(`Ignore chunk[ID=${L.chunkID}, size=${L.chunkSize}]`);
        break;
      case "DSD":
        this.metadata.setFormat("numberOfSamples", Number(L.chunkSize * BigInt(8) / BigInt(this.metadata.format.numberOfChannels))), this.metadata.setFormat("duration", this.metadata.format.numberOfSamples / this.metadata.format.sampleRate);
        break;
    }
    const W = L.chunkSize - BigInt(this.tokenizer.position - A);
    W > 0 && (debug$2(`After Parsing chunk, remaining ${W} bytes`), await this.tokenizer.ignore(Number(W)));
  }
  async handleSoundPropertyChunks(L) {
    for (debug$2(`Parsing sound-property-chunks, remainingSize=${L}`); L > 0; ) {
      const A = await this.tokenizer.readToken(DsdiffToken_1.ChunkHeader64);
      debug$2(`Sound-property-chunk[ID=${A.chunkID}, size=${A.chunkSize}]`);
      const W = this.tokenizer.position;
      switch (A.chunkID.trim()) {
        case "FS":
          const J = await this.tokenizer.readToken(Token.UINT32_BE);
          this.metadata.setFormat("sampleRate", J);
          break;
        case "CHNL":
          const te = await this.tokenizer.readToken(Token.UINT16_BE);
          this.metadata.setFormat("numberOfChannels", te), await this.handleChannelChunks(A.chunkSize - BigInt(Token.UINT16_BE.len));
          break;
        case "CMPR":
          const oe = (await this.tokenizer.readToken(FourCC_1.FourCcToken)).trim(), ne = await this.tokenizer.readToken(Token.UINT8), re = await this.tokenizer.readToken(new Token.StringType(ne, "ascii"));
          oe === "DSD" && (this.metadata.setFormat("lossless", !0), this.metadata.setFormat("bitsPerSample", 1)), this.metadata.setFormat("codec", `${oe} (${re})`);
          break;
        case "ABSS":
          const ce = await this.tokenizer.readToken(Token.UINT16_BE), ue = await this.tokenizer.readToken(Token.UINT8), de = await this.tokenizer.readToken(Token.UINT8), be = await this.tokenizer.readToken(Token.UINT32_BE);
          debug$2(`ABSS ${ce}:${ue}:${de}.${be}`);
          break;
        case "LSCO":
          const pe = await this.tokenizer.readToken(Token.UINT16_BE);
          debug$2(`LSCO lsConfig=${pe}`);
          break;
        case "COMT":
        default:
          debug$2(`Unknown sound-property-chunk[ID=${A.chunkID}, size=${A.chunkSize}]`), await this.tokenizer.ignore(Number(A.chunkSize));
      }
      const X = A.chunkSize - BigInt(this.tokenizer.position - W);
      X > 0 && (debug$2(`After Parsing sound-property-chunk ${A.chunkSize}, remaining ${X} bytes`), await this.tokenizer.ignore(Number(X))), L -= BigInt(DsdiffToken_1.ChunkHeader64.len) + A.chunkSize, debug$2(`Parsing sound-property-chunks, remainingSize=${L}`);
    }
    if (this.metadata.format.lossless && this.metadata.format.sampleRate && this.metadata.format.numberOfChannels && this.metadata.format.bitsPerSample) {
      const A = this.metadata.format.sampleRate * this.metadata.format.numberOfChannels * this.metadata.format.bitsPerSample;
      this.metadata.setFormat("bitrate", A);
    }
  }
  async handleChannelChunks(L) {
    debug$2(`Parsing channel-chunks, remainingSize=${L}`);
    const A = [];
    for (; L >= FourCC_1.FourCcToken.len; ) {
      const W = await this.tokenizer.readToken(FourCC_1.FourCcToken);
      debug$2(`Channel[ID=${W}]`), A.push(W), L -= BigInt(FourCC_1.FourCcToken.len);
    }
    return debug$2(`Channels: ${A.join(", ")}`), A;
  }
}
DsdiffParser$1.DsdiffParser = DsdiffParser;
var MatroskaParser$1 = {}, MatroskaDtd = {};
Object.defineProperty(MatroskaDtd, "__esModule", { value: !0 });
MatroskaDtd.elements = void 0;
const types_1$1 = types$1;
MatroskaDtd.elements = {
  440786851: {
    name: "ebml",
    container: {
      17030: { name: "ebmlVersion", value: types_1$1.DataType.uint },
      17143: { name: "ebmlReadVersion", value: types_1$1.DataType.uint },
      17138: { name: "ebmlMaxIDWidth", value: types_1$1.DataType.uint },
      17139: { name: "ebmlMaxSizeWidth", value: types_1$1.DataType.uint },
      17026: { name: "docType", value: types_1$1.DataType.string },
      17031: { name: "docTypeVersion", value: types_1$1.DataType.uint },
      17029: { name: "docTypeReadVersion", value: types_1$1.DataType.uint }
      // 5.1.7
    }
  },
  // Matroska segments
  408125543: {
    name: "segment",
    container: {
      // Meta Seek Information
      290298740: {
        name: "seekHead",
        container: {
          19899: {
            name: "seek",
            container: {
              21419: { name: "seekId", value: types_1$1.DataType.binary },
              21420: { name: "seekPosition", value: types_1$1.DataType.uint }
            }
          }
        }
      },
      // Segment Information
      357149030: {
        name: "info",
        container: {
          29604: { name: "uid", value: types_1$1.DataType.uid },
          29572: { name: "filename", value: types_1$1.DataType.string },
          3979555: { name: "prevUID", value: types_1$1.DataType.uid },
          3965867: { name: "prevFilename", value: types_1$1.DataType.string },
          4110627: { name: "nextUID", value: types_1$1.DataType.uid },
          4096955: { name: "nextFilename", value: types_1$1.DataType.string },
          2807729: { name: "timecodeScale", value: types_1$1.DataType.uint },
          17545: { name: "duration", value: types_1$1.DataType.float },
          17505: { name: "dateUTC", value: types_1$1.DataType.uint },
          31657: { name: "title", value: types_1$1.DataType.string },
          19840: { name: "muxingApp", value: types_1$1.DataType.string },
          22337: { name: "writingApp", value: types_1$1.DataType.string }
        }
      },
      // Cluster
      524531317: {
        name: "cluster",
        multiple: !0,
        container: {
          231: { name: "timecode", value: types_1$1.DataType.uid },
          163: { name: "unknown", value: types_1$1.DataType.binary },
          167: { name: "position", value: types_1$1.DataType.uid },
          171: { name: "prevSize", value: types_1$1.DataType.uid }
        }
      },
      // Track
      374648427: {
        name: "tracks",
        container: {
          174: {
            name: "entries",
            multiple: !0,
            container: {
              215: { name: "trackNumber", value: types_1$1.DataType.uint },
              29637: { name: "uid", value: types_1$1.DataType.uid },
              131: { name: "trackType", value: types_1$1.DataType.uint },
              185: { name: "flagEnabled", value: types_1$1.DataType.bool },
              136: { name: "flagDefault", value: types_1$1.DataType.bool },
              21930: { name: "flagForced", value: types_1$1.DataType.bool },
              156: { name: "flagLacing", value: types_1$1.DataType.bool },
              28135: { name: "minCache", value: types_1$1.DataType.uint },
              28136: { name: "maxCache", value: types_1$1.DataType.uint },
              2352003: { name: "defaultDuration", value: types_1$1.DataType.uint },
              2306383: { name: "timecodeScale", value: types_1$1.DataType.float },
              21358: { name: "name", value: types_1$1.DataType.string },
              2274716: { name: "language", value: types_1$1.DataType.string },
              134: { name: "codecID", value: types_1$1.DataType.string },
              25506: { name: "codecPrivate", value: types_1$1.DataType.binary },
              2459272: { name: "codecName", value: types_1$1.DataType.string },
              3839639: { name: "codecSettings", value: types_1$1.DataType.string },
              3883072: { name: "codecInfoUrl", value: types_1$1.DataType.string },
              2536e3: { name: "codecDownloadUrl", value: types_1$1.DataType.string },
              170: { name: "codecDecodeAll", value: types_1$1.DataType.bool },
              28587: { name: "trackOverlay", value: types_1$1.DataType.uint },
              // Video
              224: {
                name: "video",
                container: {
                  154: { name: "flagInterlaced", value: types_1$1.DataType.bool },
                  21432: { name: "stereoMode", value: types_1$1.DataType.uint },
                  176: { name: "pixelWidth", value: types_1$1.DataType.uint },
                  186: { name: "pixelHeight", value: types_1$1.DataType.uint },
                  21680: { name: "displayWidth", value: types_1$1.DataType.uint },
                  21690: { name: "displayHeight", value: types_1$1.DataType.uint },
                  21683: { name: "aspectRatioType", value: types_1$1.DataType.uint },
                  3061028: { name: "colourSpace", value: types_1$1.DataType.uint },
                  3126563: { name: "gammaValue", value: types_1$1.DataType.float }
                }
              },
              // Audio
              225: {
                name: "audio",
                container: {
                  181: { name: "samplingFrequency", value: types_1$1.DataType.float },
                  30901: { name: "outputSamplingFrequency", value: types_1$1.DataType.float },
                  159: { name: "channels", value: types_1$1.DataType.uint },
                  148: { name: "channels", value: types_1$1.DataType.uint },
                  32123: { name: "channelPositions", value: types_1$1.DataType.binary },
                  25188: { name: "bitDepth", value: types_1$1.DataType.uint }
                }
              },
              // Content Encoding
              28032: {
                name: "contentEncodings",
                container: {
                  25152: {
                    name: "contentEncoding",
                    container: {
                      20529: { name: "order", value: types_1$1.DataType.uint },
                      20530: { name: "scope", value: types_1$1.DataType.bool },
                      20531: { name: "type", value: types_1$1.DataType.uint },
                      20532: {
                        name: "contentEncoding",
                        container: {
                          16980: { name: "contentCompAlgo", value: types_1$1.DataType.uint },
                          16981: { name: "contentCompSettings", value: types_1$1.DataType.binary }
                        }
                      },
                      20533: {
                        name: "contentEncoding",
                        container: {
                          18401: { name: "contentEncAlgo", value: types_1$1.DataType.uint },
                          18402: { name: "contentEncKeyID", value: types_1$1.DataType.binary },
                          18403: { name: "contentSignature ", value: types_1$1.DataType.binary },
                          18404: { name: "ContentSigKeyID  ", value: types_1$1.DataType.binary },
                          18405: { name: "contentSigAlgo ", value: types_1$1.DataType.uint },
                          18406: { name: "contentSigHashAlgo ", value: types_1$1.DataType.uint }
                        }
                      },
                      25188: { name: "bitDepth", value: types_1$1.DataType.uint }
                    }
                  }
                }
              }
            }
          }
        }
      },
      // Cueing Data
      475249515: {
        name: "cues",
        container: {
          187: {
            name: "cuePoint",
            container: {
              179: { name: "cueTime", value: types_1$1.DataType.uid },
              183: {
                name: "positions",
                container: {
                  247: { name: "track", value: types_1$1.DataType.uint },
                  241: { name: "clusterPosition", value: types_1$1.DataType.uint },
                  21368: { name: "blockNumber", value: types_1$1.DataType.uint },
                  234: { name: "codecState", value: types_1$1.DataType.uint },
                  219: {
                    name: "reference",
                    container: {
                      150: { name: "time", value: types_1$1.DataType.uint },
                      151: { name: "cluster", value: types_1$1.DataType.uint },
                      21343: { name: "number", value: types_1$1.DataType.uint },
                      235: { name: "codecState", value: types_1$1.DataType.uint }
                    }
                  },
                  240: { name: "relativePosition", value: types_1$1.DataType.uint }
                  // extended
                }
              }
            }
          }
        }
      },
      // Attachment
      423732329: {
        name: "attachments",
        container: {
          24999: {
            name: "attachedFiles",
            multiple: !0,
            container: {
              18046: { name: "description", value: types_1$1.DataType.string },
              18030: { name: "name", value: types_1$1.DataType.string },
              18016: { name: "mimeType", value: types_1$1.DataType.string },
              18012: { name: "data", value: types_1$1.DataType.binary },
              18094: { name: "uid", value: types_1$1.DataType.uid }
            }
          }
        }
      },
      // Chapters
      272869232: {
        name: "chapters",
        container: {
          17849: {
            name: "editionEntry",
            container: {
              182: {
                name: "chapterAtom",
                container: {
                  29636: { name: "uid", value: types_1$1.DataType.uid },
                  145: { name: "timeStart", value: types_1$1.DataType.uint },
                  146: { name: "timeEnd", value: types_1$1.DataType.uid },
                  152: { name: "hidden", value: types_1$1.DataType.bool },
                  17816: { name: "enabled", value: types_1$1.DataType.uid },
                  143: {
                    name: "track",
                    container: {
                      137: { name: "trackNumber", value: types_1$1.DataType.uid },
                      128: {
                        name: "display",
                        container: {
                          133: { name: "string", value: types_1$1.DataType.string },
                          17276: { name: "language ", value: types_1$1.DataType.string },
                          17278: { name: "country ", value: types_1$1.DataType.string }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      },
      // Tagging
      307544935: {
        name: "tags",
        container: {
          29555: {
            name: "tag",
            multiple: !0,
            container: {
              25536: {
                name: "target",
                container: {
                  25541: { name: "tagTrackUID", value: types_1$1.DataType.uid },
                  25540: { name: "tagChapterUID", value: types_1$1.DataType.uint },
                  25542: { name: "tagAttachmentUID", value: types_1$1.DataType.uid },
                  25546: { name: "targetType", value: types_1$1.DataType.string },
                  26826: { name: "targetTypeValue", value: types_1$1.DataType.uint },
                  25545: { name: "tagEditionUID", value: types_1$1.DataType.uid }
                  // extended
                }
              },
              26568: {
                name: "simpleTags",
                multiple: !0,
                container: {
                  17827: { name: "name", value: types_1$1.DataType.string },
                  17543: { name: "string", value: types_1$1.DataType.string },
                  17541: { name: "binary", value: types_1$1.DataType.binary },
                  17530: { name: "language", value: types_1$1.DataType.string },
                  17531: { name: "languageIETF", value: types_1$1.DataType.string },
                  17540: { name: "default", value: types_1$1.DataType.bool }
                  // extended
                }
              }
            }
          }
        }
      }
    }
  }
};
Object.defineProperty(MatroskaParser$1, "__esModule", { value: !0 });
MatroskaParser$1.MatroskaParser = void 0;
const token_types_1 = lib$1, debug_1$1 = browserExports, BasicParser_1 = BasicParser$1, types_1 = types$1, matroskaDtd = MatroskaDtd, debug$1 = (0, debug_1$1.default)("music-metadata:parser:matroska");
class MatroskaParser extends BasicParser_1.BasicParser {
  constructor() {
    super(), this.padding = 0, this.parserMap = /* @__PURE__ */ new Map(), this.ebmlMaxIDLength = 4, this.ebmlMaxSizeLength = 8, this.parserMap.set(types_1.DataType.uint, (L) => this.readUint(L)), this.parserMap.set(types_1.DataType.string, (L) => this.readString(L)), this.parserMap.set(types_1.DataType.binary, (L) => this.readBuffer(L)), this.parserMap.set(types_1.DataType.uid, async (L) => await this.readUint(L) === 1), this.parserMap.set(types_1.DataType.bool, (L) => this.readFlag(L)), this.parserMap.set(types_1.DataType.float, (L) => this.readFloat(L));
  }
  /**
   * Initialize parser with output (metadata), input (tokenizer) & parsing options (options).
   * @param {INativeMetadataCollector} metadata Output
   * @param {ITokenizer} tokenizer Input
   * @param {IOptions} options Parsing options
   */
  init(L, A, W) {
    return super.init(L, A, W), this;
  }
  async parse() {
    const L = await this.parseContainer(matroskaDtd.elements, this.tokenizer.fileInfo.size, []);
    if (this.metadata.setFormat("container", `EBML/${L.ebml.docType}`), L.segment) {
      const A = L.segment.info;
      if (A) {
        const X = A.timecodeScale ? A.timecodeScale : 1e6;
        if (typeof A.duration == "number") {
          const J = A.duration * X / 1e9;
          this.addTag("segment:title", A.title), this.metadata.setFormat("duration", J);
        }
      }
      const W = L.segment.tracks;
      if (W && W.entries) {
        W.entries.forEach((J) => {
          const te = {
            codecName: J.codecID.replace("A_", "").replace("V_", ""),
            codecSettings: J.codecSettings,
            flagDefault: J.flagDefault,
            flagLacing: J.flagLacing,
            flagEnabled: J.flagEnabled,
            language: J.language,
            name: J.name,
            type: J.trackType,
            audio: J.audio,
            video: J.video
          };
          this.metadata.addStreamInfo(te);
        });
        const X = W.entries.filter((J) => J.trackType === types_1.TrackType.audio.valueOf()).reduce((J, te) => !J || !J.flagDefault && te.flagDefault || te.trackNumber && te.trackNumber < J.trackNumber ? te : J, null);
        X && (this.metadata.setFormat("codec", X.codecID.replace("A_", "")), this.metadata.setFormat("sampleRate", X.audio.samplingFrequency), this.metadata.setFormat("numberOfChannels", X.audio.channels)), L.segment.tags && L.segment.tags.tag.forEach((J) => {
          const te = J.target, oe = te != null && te.targetTypeValue ? types_1.TargetType[te.targetTypeValue] : te != null && te.targetType ? te.targetType : "track";
          J.simpleTags.forEach((ne) => {
            const re = ne.string ? ne.string : ne.binary;
            this.addTag(`${oe}:${ne.name}`, re);
          });
        }), L.segment.attachments && L.segment.attachments.attachedFiles.filter((J) => J.mimeType.startsWith("image/")).map((J) => ({
          data: J.data,
          format: J.mimeType,
          description: J.description,
          name: J.name
        })).forEach((J) => {
          this.addTag("picture", J);
        });
      }
    }
  }
  async parseContainer(L, A, W) {
    const X = {};
    for (; this.tokenizer.position < A; ) {
      let J;
      try {
        J = await this.readElement();
      } catch (oe) {
        if (oe.message === "End-Of-Stream")
          break;
        throw oe;
      }
      const te = L[J.id];
      if (te)
        if (debug$1(`Element: name=${te.name}, container=${!!te.container}`), te.container) {
          const oe = await this.parseContainer(te.container, J.len >= 0 ? this.tokenizer.position + J.len : -1, W.concat([te.name]));
          te.multiple ? (X[te.name] || (X[te.name] = []), X[te.name].push(oe)) : X[te.name] = oe;
        } else
          X[te.name] = await this.parserMap.get(te.value)(J);
      else
        switch (J.id) {
          case 236:
            this.padding += J.len, await this.tokenizer.ignore(J.len);
            break;
          default:
            debug$1(`parseEbml: path=${W.join("/")}, unknown element: id=${J.id.toString(16)}`), this.padding += J.len, await this.tokenizer.ignore(J.len);
        }
    }
    return X;
  }
  async readVintData(L) {
    const A = await this.tokenizer.peekNumber(token_types_1.UINT8);
    let W = 128, X = 1;
    for (; !(A & W); ) {
      if (X > L)
        throw new Error("VINT value exceeding maximum size");
      ++X, W >>= 1;
    }
    const J = Buffer.alloc(X);
    return await this.tokenizer.readBuffer(J), J;
  }
  async readElement() {
    const L = await this.readVintData(this.ebmlMaxIDLength), A = await this.readVintData(this.ebmlMaxSizeLength);
    A[0] ^= 128 >> A.length - 1;
    const W = Math.min(6, A.length);
    return {
      id: L.readUIntBE(0, L.length),
      len: A.readUIntBE(A.length - W, W)
    };
  }
  isMaxValue(L) {
    if (L.length === this.ebmlMaxSizeLength) {
      for (let A = 1; A < this.ebmlMaxSizeLength; ++A)
        if (L[A] !== 255)
          return !1;
      return !0;
    }
    return !1;
  }
  async readFloat(L) {
    switch (L.len) {
      case 0:
        return 0;
      case 4:
        return this.tokenizer.readNumber(token_types_1.Float32_BE);
      case 8:
        return this.tokenizer.readNumber(token_types_1.Float64_BE);
      case 10:
        return this.tokenizer.readNumber(token_types_1.Float64_BE);
      default:
        throw new Error(`Invalid IEEE-754 float length: ${L.len}`);
    }
  }
  async readFlag(L) {
    return await this.readUint(L) === 1;
  }
  async readUint(L) {
    const A = await this.readBuffer(L), W = Math.min(6, L.len);
    return A.readUIntBE(L.len - W, W);
  }
  async readString(L) {
    return (await this.tokenizer.readToken(new token_types_1.StringType(L.len, "utf-8"))).replace(/\00.*$/g, "");
  }
  async readBuffer(L) {
    const A = Buffer.alloc(L.len);
    return await this.tokenizer.readBuffer(A), A;
  }
  addTag(L, A) {
    this.metadata.addTag("matroska", L, A);
  }
}
MatroskaParser$1.MatroskaParser = MatroskaParser;
Object.defineProperty(ParserFactory$1, "__esModule", { value: !0 });
ParserFactory$1.ParserFactory = ParserFactory$1.parseHttpContentType = void 0;
const FileType = core, ContentType = contentType, MimeType = mediaTyper, debug_1 = browserExports, MetadataCollector_1 = MetadataCollector$1, AiffParser_1 = AiffParser, APEv2Parser_1$1 = APEv2Parser$1, AsfParser_1 = AsfParser$1, FlacParser_1 = FlacParser$1, MP4Parser_1 = MP4Parser$1, MpegParser_1 = MpegParser$1, musepack_1 = musepack, OggParser_1 = OggParser$1, WaveParser_1 = WaveParser$1, WavPackParser_1 = WavPackParser$1, DsfParser_1 = DsfParser$1, DsdiffParser_1 = DsdiffParser$1, MatroskaParser_1 = MatroskaParser$1, debug = (0, debug_1.default)("music-metadata:parser:factory");
function parseHttpContentType(C) {
  const L = ContentType.parse(C), A = MimeType.parse(L.type);
  return {
    type: A.type,
    subtype: A.subtype,
    suffix: A.suffix,
    parameters: L.parameters
  };
}
ParserFactory$1.parseHttpContentType = parseHttpContentType;
async function parse(C, L, A = {}) {
  const W = await ParserFactory.loadParser(L), X = new MetadataCollector_1.MetadataCollector(A);
  return await W.init(X, C, A).parse(), X.toCommonMetadata();
}
class ParserFactory {
  /**
   * Parse metadata from tokenizer
   * @param tokenizer - Tokenizer
   * @param opts - Options
   * @returns Native metadata
   */
  static async parseOnContentType(L, A) {
    const { mimeType: W, path: X, url: J } = await L.fileInfo, te = ParserFactory.getParserIdForMimeType(W) || ParserFactory.getParserIdForExtension(X) || ParserFactory.getParserIdForExtension(J);
    return te || debug("No parser found for MIME-type / extension: " + W), this.parse(L, te, A);
  }
  static async parse(L, A, W) {
    if (!A) {
      debug("Guess parser on content...");
      const X = Buffer.alloc(4100);
      if (await L.peekBuffer(X, { mayBeLess: !0 }), L.fileInfo.path && (A = this.getParserIdForExtension(L.fileInfo.path)), !A) {
        const J = await FileType.fromBuffer(X);
        if (!J)
          throw new Error("Failed to determine audio format");
        if (debug(`Guessed file type is mime=${J.mime}, extension=${J.ext}`), A = ParserFactory.getParserIdForMimeType(J.mime), !A)
          throw new Error("Guessed MIME-type not supported: " + J.mime);
      }
    }
    return parse(L, A, W);
  }
  /**
   * @param filePath - Path, filename or extension to audio file
   * @return Parser sub-module name
   */
  static getParserIdForExtension(L) {
    if (!L)
      return;
    switch (this.getExtension(L).toLocaleLowerCase() || L) {
      case ".mp2":
      case ".mp3":
      case ".m2a":
      case ".aac":
        return "mpeg";
      case ".ape":
        return "apev2";
      case ".mp4":
      case ".m4a":
      case ".m4b":
      case ".m4pa":
      case ".m4v":
      case ".m4r":
      case ".3gp":
        return "mp4";
      case ".wma":
      case ".wmv":
      case ".asf":
        return "asf";
      case ".flac":
        return "flac";
      case ".ogg":
      case ".ogv":
      case ".oga":
      case ".ogm":
      case ".ogx":
      case ".opus":
      case ".spx":
        return "ogg";
      case ".aif":
      case ".aiff":
      case ".aifc":
        return "aiff";
      case ".wav":
      case ".bwf":
        return "riff";
      case ".wv":
      case ".wvp":
        return "wavpack";
      case ".mpc":
        return "musepack";
      case ".dsf":
        return "dsf";
      case ".dff":
        return "dsdiff";
      case ".mka":
      case ".mkv":
      case ".mk3d":
      case ".mks":
      case ".webm":
        return "matroska";
    }
  }
  static async loadParser(L) {
    switch (L) {
      case "aiff":
        return new AiffParser_1.AIFFParser();
      case "adts":
      case "mpeg":
        return new MpegParser_1.MpegParser();
      case "apev2":
        return new APEv2Parser_1$1.APEv2Parser();
      case "asf":
        return new AsfParser_1.AsfParser();
      case "dsf":
        return new DsfParser_1.DsfParser();
      case "dsdiff":
        return new DsdiffParser_1.DsdiffParser();
      case "flac":
        return new FlacParser_1.FlacParser();
      case "mp4":
        return new MP4Parser_1.MP4Parser();
      case "musepack":
        return new musepack_1.default();
      case "ogg":
        return new OggParser_1.OggParser();
      case "riff":
        return new WaveParser_1.WaveParser();
      case "wavpack":
        return new WavPackParser_1.WavPackParser();
      case "matroska":
        return new MatroskaParser_1.MatroskaParser();
      default:
        throw new Error(`Unknown parser type: ${L}`);
    }
  }
  static getExtension(L) {
    const A = L.lastIndexOf(".");
    return A === -1 ? "" : L.slice(A);
  }
  /**
   * @param httpContentType - HTTP Content-Type, extension, path or filename
   * @returns Parser sub-module name
   */
  static getParserIdForMimeType(L) {
    let A;
    try {
      A = parseHttpContentType(L);
    } catch {
      debug(`Invalid HTTP Content-Type header value: ${L}`);
      return;
    }
    const W = A.subtype.indexOf("x-") === 0 ? A.subtype.substring(2) : A.subtype;
    switch (A.type) {
      case "audio":
        switch (W) {
          case "mp3":
          case "mpeg":
            return "mpeg";
          case "aac":
          case "aacp":
            return "adts";
          case "flac":
            return "flac";
          case "ape":
          case "monkeys-audio":
            return "apev2";
          case "mp4":
          case "m4a":
            return "mp4";
          case "ogg":
          case "opus":
          case "speex":
            return "ogg";
          case "ms-wma":
          case "ms-wmv":
          case "ms-asf":
            return "asf";
          case "aiff":
          case "aif":
          case "aifc":
            return "aiff";
          case "vnd.wave":
          case "wav":
          case "wave":
            return "riff";
          case "wavpack":
            return "wavpack";
          case "musepack":
            return "musepack";
          case "matroska":
          case "webm":
            return "matroska";
          case "dsf":
            return "dsf";
        }
        break;
      case "video":
        switch (W) {
          case "ms-asf":
          case "ms-wmv":
            return "asf";
          case "m4v":
          case "mp4":
            return "mp4";
          case "ogg":
            return "ogg";
          case "matroska":
          case "webm":
            return "matroska";
        }
        break;
      case "application":
        switch (W) {
          case "vnd.ms-asf":
            return "asf";
          case "ogg":
            return "ogg";
        }
        break;
    }
  }
}
ParserFactory$1.ParserFactory = ParserFactory;
var RandomUint8ArrayReader$1 = {};
Object.defineProperty(RandomUint8ArrayReader$1, "__esModule", { value: !0 });
RandomUint8ArrayReader$1.RandomUint8ArrayReader = void 0;
class RandomUint8ArrayReader {
  constructor(L) {
    this.uint8Array = L, this.fileSize = L.length;
  }
  /**
   * Read from a given position of an abstracted file or buffer.
   * @param uint8Array - Uint8Array that the data will be written to.
   * @param offset - Offset in the buffer to start writing at.
   * @param length - Integer specifying the number of bytes to read.
   * @param position - Specifies where to begin reading from in the file.
   * @return Promise providing bytes read
   */
  async randomRead(L, A, W, X) {
    return L.set(this.uint8Array.subarray(X, X + W), A), W;
  }
}
RandomUint8ArrayReader$1.RandomUint8ArrayReader = RandomUint8ArrayReader;
var Lyrics3 = {};
(function(C) {
  Object.defineProperty(C, "__esModule", { value: !0 }), C.getLyricsHeaderLength = C.endTag2 = void 0, C.endTag2 = "LYRICS200";
  async function L(A) {
    if (A.fileSize >= 143) {
      const W = Buffer.alloc(15);
      await A.randomRead(W, 0, W.length, A.fileSize - 143);
      const X = W.toString("binary");
      if (X.substr(6) === C.endTag2)
        return parseInt(X.substr(0, 6), 10) + 15;
    }
    return 0;
  }
  C.getLyricsHeaderLength = L;
})(Lyrics3);
Object.defineProperty(core$2, "__esModule", { value: !0 });
core$2.scanAppendingHeaders = core$2.selectCover = core$2.ratingToStars = core$2.orderTags = core$2.parseFromTokenizer = core$2.parseBuffer = core$2.parseStream = void 0;
const strtok3 = core$1, ParserFactory_1 = ParserFactory$1, RandomUint8ArrayReader_1 = RandomUint8ArrayReader$1, APEv2Parser_1 = APEv2Parser$1, ID3v1Parser_1 = ID3v1Parser, Lyrics3_1 = Lyrics3;
function parseStream(C, L, A = {}) {
  return parseFromTokenizer(strtok3.fromStream(C, typeof L == "string" ? { mimeType: L } : L), A);
}
core$2.parseStream = parseStream;
async function parseBuffer(C, L, A = {}) {
  const W = new RandomUint8ArrayReader_1.RandomUint8ArrayReader(C);
  await scanAppendingHeaders(W, A);
  const X = strtok3.fromBuffer(C, typeof L == "string" ? { mimeType: L } : L);
  return parseFromTokenizer(X, A);
}
core$2.parseBuffer = parseBuffer;
function parseFromTokenizer(C, L) {
  return ParserFactory_1.ParserFactory.parseOnContentType(C, L);
}
core$2.parseFromTokenizer = parseFromTokenizer;
function orderTags(C) {
  const L = {};
  for (const A of C)
    (L[A.id] = L[A.id] || []).push(A.value);
  return L;
}
core$2.orderTags = orderTags;
function ratingToStars(C) {
  return C === void 0 ? 0 : 1 + Math.round(C * 4);
}
core$2.ratingToStars = ratingToStars;
function selectCover(C) {
  return C ? C.reduce((L, A) => A.name && A.name.toLowerCase() in ["front", "cover", "cover (front)"] ? A : L) : null;
}
core$2.selectCover = selectCover;
async function scanAppendingHeaders(C, L = {}) {
  let A = C.fileSize;
  if (await (0, ID3v1Parser_1.hasID3v1Header)(C)) {
    A -= 128;
    const W = await (0, Lyrics3_1.getLyricsHeaderLength)(C);
    A -= W;
  }
  L.apeHeader = await APEv2Parser_1.APEv2Parser.findApeFooterOffset(C, A);
}
core$2.scanAppendingHeaders = scanAppendingHeaders;
var lib = {}, readableBrowser = { exports: {} }, events = { exports: {} }, R = typeof Reflect == "object" ? Reflect : null, ReflectApply = R && typeof R.apply == "function" ? R.apply : function C(L, A, W) {
  return Function.prototype.apply.call(L, A, W);
}, ReflectOwnKeys;
R && typeof R.ownKeys == "function" ? ReflectOwnKeys = R.ownKeys : Object.getOwnPropertySymbols ? ReflectOwnKeys = function(L) {
  return Object.getOwnPropertyNames(L).concat(Object.getOwnPropertySymbols(L));
} : ReflectOwnKeys = function(L) {
  return Object.getOwnPropertyNames(L);
};
function ProcessEmitWarning(C) {
  console && console.warn && console.warn(C);
}
var NumberIsNaN = Number.isNaN || function C(L) {
  return L !== L;
};
function EventEmitter() {
  EventEmitter.init.call(this);
}
events.exports = EventEmitter;
events.exports.once = once$2;
EventEmitter.EventEmitter = EventEmitter;
EventEmitter.prototype._events = void 0;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = void 0;
var defaultMaxListeners = 10;
function checkListener(C) {
  if (typeof C != "function")
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof C);
}
Object.defineProperty(EventEmitter, "defaultMaxListeners", {
  enumerable: !0,
  get: function() {
    return defaultMaxListeners;
  },
  set: function(C) {
    if (typeof C != "number" || C < 0 || NumberIsNaN(C))
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + C + ".");
    defaultMaxListeners = C;
  }
});
EventEmitter.init = function() {
  (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
};
EventEmitter.prototype.setMaxListeners = function C(L) {
  if (typeof L != "number" || L < 0 || NumberIsNaN(L))
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + L + ".");
  return this._maxListeners = L, this;
};
function _getMaxListeners(C) {
  return C._maxListeners === void 0 ? EventEmitter.defaultMaxListeners : C._maxListeners;
}
EventEmitter.prototype.getMaxListeners = function C() {
  return _getMaxListeners(this);
};
EventEmitter.prototype.emit = function C(L) {
  for (var A = [], W = 1; W < arguments.length; W++) A.push(arguments[W]);
  var X = L === "error", J = this._events;
  if (J !== void 0)
    X = X && J.error === void 0;
  else if (!X)
    return !1;
  if (X) {
    var te;
    if (A.length > 0 && (te = A[0]), te instanceof Error)
      throw te;
    var oe = new Error("Unhandled error." + (te ? " (" + te.message + ")" : ""));
    throw oe.context = te, oe;
  }
  var ne = J[L];
  if (ne === void 0)
    return !1;
  if (typeof ne == "function")
    ReflectApply(ne, this, A);
  else
    for (var re = ne.length, ce = arrayClone(ne, re), W = 0; W < re; ++W)
      ReflectApply(ce[W], this, A);
  return !0;
};
function _addListener(C, L, A, W) {
  var X, J, te;
  if (checkListener(A), J = C._events, J === void 0 ? (J = C._events = /* @__PURE__ */ Object.create(null), C._eventsCount = 0) : (J.newListener !== void 0 && (C.emit(
    "newListener",
    L,
    A.listener ? A.listener : A
  ), J = C._events), te = J[L]), te === void 0)
    te = J[L] = A, ++C._eventsCount;
  else if (typeof te == "function" ? te = J[L] = W ? [A, te] : [te, A] : W ? te.unshift(A) : te.push(A), X = _getMaxListeners(C), X > 0 && te.length > X && !te.warned) {
    te.warned = !0;
    var oe = new Error("Possible EventEmitter memory leak detected. " + te.length + " " + String(L) + " listeners added. Use emitter.setMaxListeners() to increase limit");
    oe.name = "MaxListenersExceededWarning", oe.emitter = C, oe.type = L, oe.count = te.length, ProcessEmitWarning(oe);
  }
  return C;
}
EventEmitter.prototype.addListener = function C(L, A) {
  return _addListener(this, L, A, !1);
};
EventEmitter.prototype.on = EventEmitter.prototype.addListener;
EventEmitter.prototype.prependListener = function C(L, A) {
  return _addListener(this, L, A, !0);
};
function onceWrapper() {
  if (!this.fired)
    return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
}
function _onceWrap(C, L, A) {
  var W = { fired: !1, wrapFn: void 0, target: C, type: L, listener: A }, X = onceWrapper.bind(W);
  return X.listener = A, W.wrapFn = X, X;
}
EventEmitter.prototype.once = function C(L, A) {
  return checkListener(A), this.on(L, _onceWrap(this, L, A)), this;
};
EventEmitter.prototype.prependOnceListener = function C(L, A) {
  return checkListener(A), this.prependListener(L, _onceWrap(this, L, A)), this;
};
EventEmitter.prototype.removeListener = function C(L, A) {
  var W, X, J, te, oe;
  if (checkListener(A), X = this._events, X === void 0)
    return this;
  if (W = X[L], W === void 0)
    return this;
  if (W === A || W.listener === A)
    --this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : (delete X[L], X.removeListener && this.emit("removeListener", L, W.listener || A));
  else if (typeof W != "function") {
    for (J = -1, te = W.length - 1; te >= 0; te--)
      if (W[te] === A || W[te].listener === A) {
        oe = W[te].listener, J = te;
        break;
      }
    if (J < 0)
      return this;
    J === 0 ? W.shift() : spliceOne(W, J), W.length === 1 && (X[L] = W[0]), X.removeListener !== void 0 && this.emit("removeListener", L, oe || A);
  }
  return this;
};
EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
EventEmitter.prototype.removeAllListeners = function C(L) {
  var A, W, X;
  if (W = this._events, W === void 0)
    return this;
  if (W.removeListener === void 0)
    return arguments.length === 0 ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : W[L] !== void 0 && (--this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : delete W[L]), this;
  if (arguments.length === 0) {
    var J = Object.keys(W), te;
    for (X = 0; X < J.length; ++X)
      te = J[X], te !== "removeListener" && this.removeAllListeners(te);
    return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
  }
  if (A = W[L], typeof A == "function")
    this.removeListener(L, A);
  else if (A !== void 0)
    for (X = A.length - 1; X >= 0; X--)
      this.removeListener(L, A[X]);
  return this;
};
function _listeners(C, L, A) {
  var W = C._events;
  if (W === void 0)
    return [];
  var X = W[L];
  return X === void 0 ? [] : typeof X == "function" ? A ? [X.listener || X] : [X] : A ? unwrapListeners(X) : arrayClone(X, X.length);
}
EventEmitter.prototype.listeners = function C(L) {
  return _listeners(this, L, !0);
};
EventEmitter.prototype.rawListeners = function C(L) {
  return _listeners(this, L, !1);
};
EventEmitter.listenerCount = function(C, L) {
  return typeof C.listenerCount == "function" ? C.listenerCount(L) : listenerCount.call(C, L);
};
EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(C) {
  var L = this._events;
  if (L !== void 0) {
    var A = L[C];
    if (typeof A == "function")
      return 1;
    if (A !== void 0)
      return A.length;
  }
  return 0;
}
EventEmitter.prototype.eventNames = function C() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};
function arrayClone(C, L) {
  for (var A = new Array(L), W = 0; W < L; ++W)
    A[W] = C[W];
  return A;
}
function spliceOne(C, L) {
  for (; L + 1 < C.length; L++)
    C[L] = C[L + 1];
  C.pop();
}
function unwrapListeners(C) {
  for (var L = new Array(C.length), A = 0; A < L.length; ++A)
    L[A] = C[A].listener || C[A];
  return L;
}
function once$2(C, L) {
  return new Promise(function(A, W) {
    function X(te) {
      C.removeListener(L, J), W(te);
    }
    function J() {
      typeof C.removeListener == "function" && C.removeListener("error", X), A([].slice.call(arguments));
    }
    eventTargetAgnosticAddListener(C, L, J, { once: !0 }), L !== "error" && addErrorHandlerIfEventEmitter(C, X, { once: !0 });
  });
}
function addErrorHandlerIfEventEmitter(C, L, A) {
  typeof C.on == "function" && eventTargetAgnosticAddListener(C, "error", L, A);
}
function eventTargetAgnosticAddListener(C, L, A, W) {
  if (typeof C.on == "function")
    W.once ? C.once(L, A) : C.on(L, A);
  else if (typeof C.addEventListener == "function")
    C.addEventListener(L, function X(J) {
      W.once && C.removeEventListener(L, X), A(J);
    });
  else
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof C);
}
var eventsExports = events.exports, streamBrowser = eventsExports.EventEmitter;
const require$$2 = /* @__PURE__ */ getAugmentedNamespace(dist);
var util = {}, types = {}, shams$1 = function C() {
  if (typeof Symbol != "function" || typeof Object.getOwnPropertySymbols != "function")
    return !1;
  if (typeof Symbol.iterator == "symbol")
    return !0;
  var L = {}, A = Symbol("test"), W = Object(A);
  if (typeof A == "string" || Object.prototype.toString.call(A) !== "[object Symbol]" || Object.prototype.toString.call(W) !== "[object Symbol]")
    return !1;
  var X = 42;
  L[A] = X;
  for (A in L)
    return !1;
  if (typeof Object.keys == "function" && Object.keys(L).length !== 0 || typeof Object.getOwnPropertyNames == "function" && Object.getOwnPropertyNames(L).length !== 0)
    return !1;
  var J = Object.getOwnPropertySymbols(L);
  if (J.length !== 1 || J[0] !== A || !Object.prototype.propertyIsEnumerable.call(L, A))
    return !1;
  if (typeof Object.getOwnPropertyDescriptor == "function") {
    var te = Object.getOwnPropertyDescriptor(L, A);
    if (te.value !== X || te.enumerable !== !0)
      return !1;
  }
  return !0;
}, hasSymbols$2 = shams$1, shams = function C() {
  return hasSymbols$2() && !!Symbol.toStringTag;
}, esErrors = Error, _eval = EvalError, range = RangeError, ref = ReferenceError, syntax = SyntaxError, type = TypeError, uri = URIError, origSymbol = typeof Symbol < "u" && Symbol, hasSymbolSham = shams$1, hasSymbols$1 = function C() {
  return typeof origSymbol != "function" || typeof Symbol != "function" || typeof origSymbol("foo") != "symbol" || typeof Symbol("bar") != "symbol" ? !1 : hasSymbolSham();
}, test = {
  __proto__: null,
  foo: {}
}, $Object = Object, hasProto$1 = function C() {
  return { __proto__: test }.foo === test.foo && !(test instanceof $Object);
}, ERROR_MESSAGE = "Function.prototype.bind called on incompatible ", toStr$3 = Object.prototype.toString, max = Math.max, funcType = "[object Function]", concatty = function C(L, A) {
  for (var W = [], X = 0; X < L.length; X += 1)
    W[X] = L[X];
  for (var J = 0; J < A.length; J += 1)
    W[J + L.length] = A[J];
  return W;
}, slicy = function C(L, A) {
  for (var W = [], X = A, J = 0; X < L.length; X += 1, J += 1)
    W[J] = L[X];
  return W;
}, joiny = function(C, L) {
  for (var A = "", W = 0; W < C.length; W += 1)
    A += C[W], W + 1 < C.length && (A += L);
  return A;
}, implementation$1 = function C(L) {
  var A = this;
  if (typeof A != "function" || toStr$3.apply(A) !== funcType)
    throw new TypeError(ERROR_MESSAGE + A);
  for (var W = slicy(arguments, 1), X, J = function() {
    if (this instanceof X) {
      var ce = A.apply(
        this,
        concatty(W, arguments)
      );
      return Object(ce) === ce ? ce : this;
    }
    return A.apply(
      L,
      concatty(W, arguments)
    );
  }, te = max(0, A.length - W.length), oe = [], ne = 0; ne < te; ne++)
    oe[ne] = "$" + ne;
  if (X = Function("binder", "return function (" + joiny(oe, ",") + "){ return binder.apply(this,arguments); }")(J), A.prototype) {
    var re = function() {
    };
    re.prototype = A.prototype, X.prototype = new re(), re.prototype = null;
  }
  return X;
}, implementation = implementation$1, functionBind = Function.prototype.bind || implementation, call$1 = Function.prototype.call, $hasOwn = Object.prototype.hasOwnProperty, bind$1 = functionBind, hasown = bind$1.call(call$1, $hasOwn), undefined$1, $Error = esErrors, $EvalError = _eval, $RangeError = range, $ReferenceError = ref, $SyntaxError$1 = syntax, $TypeError$2 = type, $URIError = uri, $Function = Function, getEvalledConstructor = function(C) {
  try {
    return $Function('"use strict"; return (' + C + ").constructor;")();
  } catch {
  }
}, $gOPD$1 = Object.getOwnPropertyDescriptor;
if ($gOPD$1)
  try {
    $gOPD$1({}, "");
  } catch {
    $gOPD$1 = null;
  }
var throwTypeError = function() {
  throw new $TypeError$2();
}, ThrowTypeError = $gOPD$1 ? function() {
  try {
    return arguments.callee, throwTypeError;
  } catch {
    try {
      return $gOPD$1(arguments, "callee").get;
    } catch {
      return throwTypeError;
    }
  }
}() : throwTypeError, hasSymbols = hasSymbols$1(), hasProto = hasProto$1(), getProto$1 = Object.getPrototypeOf || (hasProto ? function(C) {
  return C.__proto__;
} : null), needsEval = {}, TypedArray = typeof Uint8Array > "u" || !getProto$1 ? undefined$1 : getProto$1(Uint8Array), INTRINSICS = {
  __proto__: null,
  "%AggregateError%": typeof AggregateError > "u" ? undefined$1 : AggregateError,
  "%Array%": Array,
  "%ArrayBuffer%": typeof ArrayBuffer > "u" ? undefined$1 : ArrayBuffer,
  "%ArrayIteratorPrototype%": hasSymbols && getProto$1 ? getProto$1([][Symbol.iterator]()) : undefined$1,
  "%AsyncFromSyncIteratorPrototype%": undefined$1,
  "%AsyncFunction%": needsEval,
  "%AsyncGenerator%": needsEval,
  "%AsyncGeneratorFunction%": needsEval,
  "%AsyncIteratorPrototype%": needsEval,
  "%Atomics%": typeof Atomics > "u" ? undefined$1 : Atomics,
  "%BigInt%": typeof BigInt > "u" ? undefined$1 : BigInt,
  "%BigInt64Array%": typeof BigInt64Array > "u" ? undefined$1 : BigInt64Array,
  "%BigUint64Array%": typeof BigUint64Array > "u" ? undefined$1 : BigUint64Array,
  "%Boolean%": Boolean,
  "%DataView%": typeof DataView > "u" ? undefined$1 : DataView,
  "%Date%": Date,
  "%decodeURI%": decodeURI,
  "%decodeURIComponent%": decodeURIComponent,
  "%encodeURI%": encodeURI,
  "%encodeURIComponent%": encodeURIComponent,
  "%Error%": $Error,
  "%eval%": eval,
  // eslint-disable-line no-eval
  "%EvalError%": $EvalError,
  "%Float32Array%": typeof Float32Array > "u" ? undefined$1 : Float32Array,
  "%Float64Array%": typeof Float64Array > "u" ? undefined$1 : Float64Array,
  "%FinalizationRegistry%": typeof FinalizationRegistry > "u" ? undefined$1 : FinalizationRegistry,
  "%Function%": $Function,
  "%GeneratorFunction%": needsEval,
  "%Int8Array%": typeof Int8Array > "u" ? undefined$1 : Int8Array,
  "%Int16Array%": typeof Int16Array > "u" ? undefined$1 : Int16Array,
  "%Int32Array%": typeof Int32Array > "u" ? undefined$1 : Int32Array,
  "%isFinite%": isFinite,
  "%isNaN%": isNaN,
  "%IteratorPrototype%": hasSymbols && getProto$1 ? getProto$1(getProto$1([][Symbol.iterator]())) : undefined$1,
  "%JSON%": typeof JSON == "object" ? JSON : undefined$1,
  "%Map%": typeof Map > "u" ? undefined$1 : Map,
  "%MapIteratorPrototype%": typeof Map > "u" || !hasSymbols || !getProto$1 ? undefined$1 : getProto$1((/* @__PURE__ */ new Map())[Symbol.iterator]()),
  "%Math%": Math,
  "%Number%": Number,
  "%Object%": Object,
  "%parseFloat%": parseFloat,
  "%parseInt%": parseInt,
  "%Promise%": typeof Promise > "u" ? undefined$1 : Promise,
  "%Proxy%": typeof Proxy > "u" ? undefined$1 : Proxy,
  "%RangeError%": $RangeError,
  "%ReferenceError%": $ReferenceError,
  "%Reflect%": typeof Reflect > "u" ? undefined$1 : Reflect,
  "%RegExp%": RegExp,
  "%Set%": typeof Set > "u" ? undefined$1 : Set,
  "%SetIteratorPrototype%": typeof Set > "u" || !hasSymbols || !getProto$1 ? undefined$1 : getProto$1((/* @__PURE__ */ new Set())[Symbol.iterator]()),
  "%SharedArrayBuffer%": typeof SharedArrayBuffer > "u" ? undefined$1 : SharedArrayBuffer,
  "%String%": String,
  "%StringIteratorPrototype%": hasSymbols && getProto$1 ? getProto$1(""[Symbol.iterator]()) : undefined$1,
  "%Symbol%": hasSymbols ? Symbol : undefined$1,
  "%SyntaxError%": $SyntaxError$1,
  "%ThrowTypeError%": ThrowTypeError,
  "%TypedArray%": TypedArray,
  "%TypeError%": $TypeError$2,
  "%Uint8Array%": typeof Uint8Array > "u" ? undefined$1 : Uint8Array,
  "%Uint8ClampedArray%": typeof Uint8ClampedArray > "u" ? undefined$1 : Uint8ClampedArray,
  "%Uint16Array%": typeof Uint16Array > "u" ? undefined$1 : Uint16Array,
  "%Uint32Array%": typeof Uint32Array > "u" ? undefined$1 : Uint32Array,
  "%URIError%": $URIError,
  "%WeakMap%": typeof WeakMap > "u" ? undefined$1 : WeakMap,
  "%WeakRef%": typeof WeakRef > "u" ? undefined$1 : WeakRef,
  "%WeakSet%": typeof WeakSet > "u" ? undefined$1 : WeakSet
};
if (getProto$1)
  try {
    null.error;
  } catch (C) {
    var errorProto = getProto$1(getProto$1(C));
    INTRINSICS["%Error.prototype%"] = errorProto;
  }
var doEval = function C(L) {
  var A;
  if (L === "%AsyncFunction%")
    A = getEvalledConstructor("async function () {}");
  else if (L === "%GeneratorFunction%")
    A = getEvalledConstructor("function* () {}");
  else if (L === "%AsyncGeneratorFunction%")
    A = getEvalledConstructor("async function* () {}");
  else if (L === "%AsyncGenerator%") {
    var W = C("%AsyncGeneratorFunction%");
    W && (A = W.prototype);
  } else if (L === "%AsyncIteratorPrototype%") {
    var X = C("%AsyncGenerator%");
    X && getProto$1 && (A = getProto$1(X.prototype));
  }
  return INTRINSICS[L] = A, A;
}, LEGACY_ALIASES = {
  __proto__: null,
  "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
  "%ArrayPrototype%": ["Array", "prototype"],
  "%ArrayProto_entries%": ["Array", "prototype", "entries"],
  "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
  "%ArrayProto_keys%": ["Array", "prototype", "keys"],
  "%ArrayProto_values%": ["Array", "prototype", "values"],
  "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
  "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
  "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
  "%BooleanPrototype%": ["Boolean", "prototype"],
  "%DataViewPrototype%": ["DataView", "prototype"],
  "%DatePrototype%": ["Date", "prototype"],
  "%ErrorPrototype%": ["Error", "prototype"],
  "%EvalErrorPrototype%": ["EvalError", "prototype"],
  "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
  "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
  "%FunctionPrototype%": ["Function", "prototype"],
  "%Generator%": ["GeneratorFunction", "prototype"],
  "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
  "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
  "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
  "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
  "%JSONParse%": ["JSON", "parse"],
  "%JSONStringify%": ["JSON", "stringify"],
  "%MapPrototype%": ["Map", "prototype"],
  "%NumberPrototype%": ["Number", "prototype"],
  "%ObjectPrototype%": ["Object", "prototype"],
  "%ObjProto_toString%": ["Object", "prototype", "toString"],
  "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
  "%PromisePrototype%": ["Promise", "prototype"],
  "%PromiseProto_then%": ["Promise", "prototype", "then"],
  "%Promise_all%": ["Promise", "all"],
  "%Promise_reject%": ["Promise", "reject"],
  "%Promise_resolve%": ["Promise", "resolve"],
  "%RangeErrorPrototype%": ["RangeError", "prototype"],
  "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
  "%RegExpPrototype%": ["RegExp", "prototype"],
  "%SetPrototype%": ["Set", "prototype"],
  "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
  "%StringPrototype%": ["String", "prototype"],
  "%SymbolPrototype%": ["Symbol", "prototype"],
  "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
  "%TypedArrayPrototype%": ["TypedArray", "prototype"],
  "%TypeErrorPrototype%": ["TypeError", "prototype"],
  "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
  "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
  "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
  "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
  "%URIErrorPrototype%": ["URIError", "prototype"],
  "%WeakMapPrototype%": ["WeakMap", "prototype"],
  "%WeakSetPrototype%": ["WeakSet", "prototype"]
}, bind = functionBind, hasOwn = hasown, $concat = bind.call(Function.call, Array.prototype.concat), $spliceApply = bind.call(Function.apply, Array.prototype.splice), $replace = bind.call(Function.call, String.prototype.replace), $strSlice = bind.call(Function.call, String.prototype.slice), $exec = bind.call(Function.call, RegExp.prototype.exec), rePropName$1 = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g, reEscapeChar = /\\(\\)?/g, stringToPath = function C(L) {
  var A = $strSlice(L, 0, 1), W = $strSlice(L, -1);
  if (A === "%" && W !== "%")
    throw new $SyntaxError$1("invalid intrinsic syntax, expected closing `%`");
  if (W === "%" && A !== "%")
    throw new $SyntaxError$1("invalid intrinsic syntax, expected opening `%`");
  var X = [];
  return $replace(L, rePropName$1, function(J, te, oe, ne) {
    X[X.length] = oe ? $replace(ne, reEscapeChar, "$1") : te || J;
  }), X;
}, getBaseIntrinsic = function C(L, A) {
  var W = L, X;
  if (hasOwn(LEGACY_ALIASES, W) && (X = LEGACY_ALIASES[W], W = "%" + X[0] + "%"), hasOwn(INTRINSICS, W)) {
    var J = INTRINSICS[W];
    if (J === needsEval && (J = doEval(W)), typeof J > "u" && !A)
      throw new $TypeError$2("intrinsic " + L + " exists, but is not available. Please file an issue!");
    return {
      alias: X,
      name: W,
      value: J
    };
  }
  throw new $SyntaxError$1("intrinsic " + L + " does not exist!");
}, getIntrinsic = function C(L, A) {
  if (typeof L != "string" || L.length === 0)
    throw new $TypeError$2("intrinsic name must be a non-empty string");
  if (arguments.length > 1 && typeof A != "boolean")
    throw new $TypeError$2('"allowMissing" argument must be a boolean');
  if ($exec(/^%?[^%]*%?$/, L) === null)
    throw new $SyntaxError$1("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
  var W = stringToPath(L), X = W.length > 0 ? W[0] : "", J = getBaseIntrinsic("%" + X + "%", A), te = J.name, oe = J.value, ne = !1, re = J.alias;
  re && (X = re[0], $spliceApply(W, $concat([0, 1], re)));
  for (var ce = 1, ue = !0; ce < W.length; ce += 1) {
    var de = W[ce], be = $strSlice(de, 0, 1), pe = $strSlice(de, -1);
    if ((be === '"' || be === "'" || be === "`" || pe === '"' || pe === "'" || pe === "`") && be !== pe)
      throw new $SyntaxError$1("property names with quotes must have matching quotes");
    if ((de === "constructor" || !ue) && (ne = !0), X += "." + de, te = "%" + X + "%", hasOwn(INTRINSICS, te))
      oe = INTRINSICS[te];
    else if (oe != null) {
      if (!(de in oe)) {
        if (!A)
          throw new $TypeError$2("base intrinsic for " + L + " exists, but the property is not available.");
        return;
      }
      if ($gOPD$1 && ce + 1 >= W.length) {
        var me = $gOPD$1(oe, de);
        ue = !!me, ue && "get" in me && !("originalValue" in me.get) ? oe = me.get : oe = oe[de];
      } else
        ue = hasOwn(oe, de), oe = oe[de];
      ue && !ne && (INTRINSICS[te] = oe);
    }
  }
  return oe;
}, callBind$2 = { exports: {} }, esDefineProperty, hasRequiredEsDefineProperty;
function requireEsDefineProperty() {
  if (hasRequiredEsDefineProperty) return esDefineProperty;
  hasRequiredEsDefineProperty = 1;
  var C = getIntrinsic, L = C("%Object.defineProperty%", !0) || !1;
  if (L)
    try {
      L({}, "a", { value: 1 });
    } catch {
      L = !1;
    }
  return esDefineProperty = L, esDefineProperty;
}
var GetIntrinsic$2 = getIntrinsic, $gOPD = GetIntrinsic$2("%Object.getOwnPropertyDescriptor%", !0);
if ($gOPD)
  try {
    $gOPD([], "length");
  } catch {
    $gOPD = null;
  }
var gopd$1 = $gOPD, $defineProperty$1 = requireEsDefineProperty(), $SyntaxError = syntax, $TypeError$1 = type, gopd = gopd$1, defineDataProperty = function C(L, A, W) {
  if (!L || typeof L != "object" && typeof L != "function")
    throw new $TypeError$1("`obj` must be an object or a function`");
  if (typeof A != "string" && typeof A != "symbol")
    throw new $TypeError$1("`property` must be a string or a symbol`");
  if (arguments.length > 3 && typeof arguments[3] != "boolean" && arguments[3] !== null)
    throw new $TypeError$1("`nonEnumerable`, if provided, must be a boolean or null");
  if (arguments.length > 4 && typeof arguments[4] != "boolean" && arguments[4] !== null)
    throw new $TypeError$1("`nonWritable`, if provided, must be a boolean or null");
  if (arguments.length > 5 && typeof arguments[5] != "boolean" && arguments[5] !== null)
    throw new $TypeError$1("`nonConfigurable`, if provided, must be a boolean or null");
  if (arguments.length > 6 && typeof arguments[6] != "boolean")
    throw new $TypeError$1("`loose`, if provided, must be a boolean");
  var X = arguments.length > 3 ? arguments[3] : null, J = arguments.length > 4 ? arguments[4] : null, te = arguments.length > 5 ? arguments[5] : null, oe = arguments.length > 6 ? arguments[6] : !1, ne = !!gopd && gopd(L, A);
  if ($defineProperty$1)
    $defineProperty$1(L, A, {
      configurable: te === null && ne ? ne.configurable : !te,
      enumerable: X === null && ne ? ne.enumerable : !X,
      value: W,
      writable: J === null && ne ? ne.writable : !J
    });
  else if (oe || !X && !J && !te)
    L[A] = W;
  else
    throw new $SyntaxError("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.");
}, $defineProperty = requireEsDefineProperty(), hasPropertyDescriptors = function C() {
  return !!$defineProperty;
};
hasPropertyDescriptors.hasArrayLengthDefineBug = function C() {
  if (!$defineProperty)
    return null;
  try {
    return $defineProperty([], "length", { value: 1 }).length !== 1;
  } catch {
    return !0;
  }
};
var hasPropertyDescriptors_1 = hasPropertyDescriptors, GetIntrinsic$1 = getIntrinsic, define = defineDataProperty, hasDescriptors = hasPropertyDescriptors_1(), gOPD$1 = gopd$1, $TypeError = type, $floor = GetIntrinsic$1("%Math.floor%"), setFunctionLength = function C(L, A) {
  if (typeof L != "function")
    throw new $TypeError("`fn` is not a function");
  if (typeof A != "number" || A < 0 || A > 4294967295 || $floor(A) !== A)
    throw new $TypeError("`length` must be a positive 32-bit integer");
  var W = arguments.length > 2 && !!arguments[2], X = !0, J = !0;
  if ("length" in L && gOPD$1) {
    var te = gOPD$1(L, "length");
    te && !te.configurable && (X = !1), te && !te.writable && (J = !1);
  }
  return (X || J || !W) && (hasDescriptors ? define(
    /** @type {Parameters<define>[0]} */
    L,
    "length",
    A,
    !0,
    !0
  ) : define(
    /** @type {Parameters<define>[0]} */
    L,
    "length",
    A
  )), L;
};
(function(C) {
  var L = functionBind, A = getIntrinsic, W = setFunctionLength, X = type, J = A("%Function.prototype.apply%"), te = A("%Function.prototype.call%"), oe = A("%Reflect.apply%", !0) || L.call(te, J), ne = requireEsDefineProperty(), re = A("%Math.max%");
  C.exports = function(de) {
    if (typeof de != "function")
      throw new X("a function is required");
    var be = oe(L, te, arguments);
    return W(
      be,
      1 + re(0, de.length - (arguments.length - 1)),
      !0
    );
  };
  var ce = function() {
    return oe(L, J, arguments);
  };
  ne ? ne(C.exports, "apply", { value: ce }) : C.exports.apply = ce;
})(callBind$2);
var callBindExports = callBind$2.exports, GetIntrinsic = getIntrinsic, callBind$1 = callBindExports, $indexOf$1 = callBind$1(GetIntrinsic("String.prototype.indexOf")), callBound$2 = function C(L, A) {
  var W = GetIntrinsic(L, !!A);
  return typeof W == "function" && $indexOf$1(L, ".prototype.") > -1 ? callBind$1(W) : W;
}, hasToStringTag$3 = shams(), callBound$1 = callBound$2, $toString$1 = callBound$1("Object.prototype.toString"), isStandardArguments = function C(L) {
  return hasToStringTag$3 && L && typeof L == "object" && Symbol.toStringTag in L ? !1 : $toString$1(L) === "[object Arguments]";
}, isLegacyArguments = function C(L) {
  return isStandardArguments(L) ? !0 : L !== null && typeof L == "object" && typeof L.length == "number" && L.length >= 0 && $toString$1(L) !== "[object Array]" && $toString$1(L.callee) === "[object Function]";
}, supportsStandardArguments = function() {
  return isStandardArguments(arguments);
}();
isStandardArguments.isLegacyArguments = isLegacyArguments;
var isArguments = supportsStandardArguments ? isStandardArguments : isLegacyArguments, toStr$2 = Object.prototype.toString, fnToStr$1 = Function.prototype.toString, isFnRegex = /^\s*(?:function)?\*/, hasToStringTag$2 = shams(), getProto = Object.getPrototypeOf, getGeneratorFunc = function() {
  if (!hasToStringTag$2)
    return !1;
  try {
    return Function("return function*() {}")();
  } catch {
  }
}, GeneratorFunction, isGeneratorFunction = function C(L) {
  if (typeof L != "function")
    return !1;
  if (isFnRegex.test(fnToStr$1.call(L)))
    return !0;
  if (!hasToStringTag$2) {
    var A = toStr$2.call(L);
    return A === "[object GeneratorFunction]";
  }
  if (!getProto)
    return !1;
  if (typeof GeneratorFunction > "u") {
    var W = getGeneratorFunc();
    GeneratorFunction = W ? getProto(W) : !1;
  }
  return getProto(L) === GeneratorFunction;
}, fnToStr = Function.prototype.toString, reflectApply = typeof Reflect == "object" && Reflect !== null && Reflect.apply, badArrayLike, isCallableMarker;
if (typeof reflectApply == "function" && typeof Object.defineProperty == "function")
  try {
    badArrayLike = Object.defineProperty({}, "length", {
      get: function() {
        throw isCallableMarker;
      }
    }), isCallableMarker = {}, reflectApply(function() {
      throw 42;
    }, null, badArrayLike);
  } catch (C) {
    C !== isCallableMarker && (reflectApply = null);
  }
else
  reflectApply = null;
var constructorRegex = /^\s*class\b/, isES6ClassFn = function C(L) {
  try {
    var A = fnToStr.call(L);
    return constructorRegex.test(A);
  } catch {
    return !1;
  }
}, tryFunctionObject = function C(L) {
  try {
    return isES6ClassFn(L) ? !1 : (fnToStr.call(L), !0);
  } catch {
    return !1;
  }
}, toStr$1 = Object.prototype.toString, objectClass = "[object Object]", fnClass = "[object Function]", genClass = "[object GeneratorFunction]", ddaClass = "[object HTMLAllCollection]", ddaClass2 = "[object HTML document.all class]", ddaClass3 = "[object HTMLCollection]", hasToStringTag$1 = typeof Symbol == "function" && !!Symbol.toStringTag, isIE68 = !(0 in [,]), isDDA = function C() {
  return !1;
};
if (typeof document == "object") {
  var all = document.all;
  toStr$1.call(all) === toStr$1.call(document.all) && (isDDA = function(L) {
    if ((isIE68 || !L) && (typeof L > "u" || typeof L == "object"))
      try {
        var A = toStr$1.call(L);
        return (A === ddaClass || A === ddaClass2 || A === ddaClass3 || A === objectClass) && L("") == null;
      } catch {
      }
    return !1;
  });
}
var isCallable$1 = reflectApply ? function C(L) {
  if (isDDA(L))
    return !0;
  if (!L || typeof L != "function" && typeof L != "object")
    return !1;
  try {
    reflectApply(L, null, badArrayLike);
  } catch (A) {
    if (A !== isCallableMarker)
      return !1;
  }
  return !isES6ClassFn(L) && tryFunctionObject(L);
} : function C(L) {
  if (isDDA(L))
    return !0;
  if (!L || typeof L != "function" && typeof L != "object")
    return !1;
  if (hasToStringTag$1)
    return tryFunctionObject(L);
  if (isES6ClassFn(L))
    return !1;
  var A = toStr$1.call(L);
  return A !== fnClass && A !== genClass && !/^\[object HTML/.test(A) ? !1 : tryFunctionObject(L);
}, isCallable = isCallable$1, toStr = Object.prototype.toString, hasOwnProperty = Object.prototype.hasOwnProperty, forEachArray = function C(L, A, W) {
  for (var X = 0, J = L.length; X < J; X++)
    hasOwnProperty.call(L, X) && (W == null ? A(L[X], X, L) : A.call(W, L[X], X, L));
}, forEachString = function C(L, A, W) {
  for (var X = 0, J = L.length; X < J; X++)
    W == null ? A(L.charAt(X), X, L) : A.call(W, L.charAt(X), X, L);
}, forEachObject = function C(L, A, W) {
  for (var X in L)
    hasOwnProperty.call(L, X) && (W == null ? A(L[X], X, L) : A.call(W, L[X], X, L));
}, forEach$1 = function C(L, A, W) {
  if (!isCallable(A))
    throw new TypeError("iterator must be a function");
  var X;
  arguments.length >= 3 && (X = W), toStr.call(L) === "[object Array]" ? forEachArray(L, A, X) : typeof L == "string" ? forEachString(L, A, X) : forEachObject(L, A, X);
}, forEach_1 = forEach$1, possibleTypedArrayNames = [
  "Float32Array",
  "Float64Array",
  "Int8Array",
  "Int16Array",
  "Int32Array",
  "Uint8Array",
  "Uint8ClampedArray",
  "Uint16Array",
  "Uint32Array",
  "BigInt64Array",
  "BigUint64Array"
], possibleNames = possibleTypedArrayNames, g$1 = typeof globalThis > "u" ? commonjsGlobal : globalThis, availableTypedArrays$1 = function C() {
  for (var L = [], A = 0; A < possibleNames.length; A++)
    typeof g$1[possibleNames[A]] == "function" && (L[L.length] = possibleNames[A]);
  return L;
}, forEach = forEach_1, availableTypedArrays = availableTypedArrays$1, callBind = callBindExports, callBound = callBound$2, gOPD = gopd$1, $toString = callBound("Object.prototype.toString"), hasToStringTag = shams(), g = typeof globalThis > "u" ? commonjsGlobal : globalThis, typedArrays = availableTypedArrays(), $slice = callBound("String.prototype.slice"), getPrototypeOf = Object.getPrototypeOf, $indexOf = callBound("Array.prototype.indexOf", !0) || function C(L, A) {
  for (var W = 0; W < L.length; W += 1)
    if (L[W] === A)
      return W;
  return -1;
}, cache = { __proto__: null };
hasToStringTag && gOPD && getPrototypeOf ? forEach(typedArrays, function(C) {
  var L = new g[C]();
  if (Symbol.toStringTag in L) {
    var A = getPrototypeOf(L), W = gOPD(A, Symbol.toStringTag);
    if (!W) {
      var X = getPrototypeOf(A);
      W = gOPD(X, Symbol.toStringTag);
    }
    cache["$" + C] = callBind(W.get);
  }
}) : forEach(typedArrays, function(C) {
  var L = new g[C](), A = L.slice || L.set;
  A && (cache["$" + C] = callBind(A));
});
var tryTypedArrays = function C(L) {
  var A = !1;
  return forEach(
    // eslint-disable-next-line no-extra-parens
    /** @type {Record<`\$${TypedArrayName}`, Getter>} */
    /** @type {any} */
    cache,
    /** @type {(getter: Getter, name: `\$${import('.').TypedArrayName}`) => void} */
    function(W, X) {
      if (!A)
        try {
          "$" + W(L) === X && (A = $slice(X, 1));
        } catch {
        }
    }
  ), A;
}, trySlices = function C(L) {
  var A = !1;
  return forEach(
    // eslint-disable-next-line no-extra-parens
    /** @type {Record<`\$${TypedArrayName}`, Getter>} */
    /** @type {any} */
    cache,
    /** @type {(getter: typeof cache, name: `\$${import('.').TypedArrayName}`) => void} */
    function(W, X) {
      if (!A)
        try {
          W(L), A = $slice(X, 1);
        } catch {
        }
    }
  ), A;
}, whichTypedArray$1 = function C(L) {
  if (!L || typeof L != "object")
    return !1;
  if (!hasToStringTag) {
    var A = $slice($toString(L), 8, -1);
    return $indexOf(typedArrays, A) > -1 ? A : A !== "Object" ? !1 : trySlices(L);
  }
  return gOPD ? tryTypedArrays(L) : null;
}, whichTypedArray = whichTypedArray$1, isTypedArray = function C(L) {
  return !!whichTypedArray(L);
};
(function(C) {
  var L = isArguments, A = isGeneratorFunction, W = whichTypedArray$1, X = isTypedArray;
  function J(kt) {
    return kt.call.bind(kt);
  }
  var te = typeof BigInt < "u", oe = typeof Symbol < "u", ne = J(Object.prototype.toString), re = J(Number.prototype.valueOf), ce = J(String.prototype.valueOf), ue = J(Boolean.prototype.valueOf);
  if (te)
    var de = J(BigInt.prototype.valueOf);
  if (oe)
    var be = J(Symbol.prototype.valueOf);
  function pe(kt, Xt) {
    if (typeof kt != "object")
      return !1;
    try {
      return Xt(kt), !0;
    } catch {
      return !1;
    }
  }
  C.isArgumentsObject = L, C.isGeneratorFunction = A, C.isTypedArray = X;
  function me(kt) {
    return typeof Promise < "u" && kt instanceof Promise || kt !== null && typeof kt == "object" && typeof kt.then == "function" && typeof kt.catch == "function";
  }
  C.isPromise = me;
  function Me(kt) {
    return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? ArrayBuffer.isView(kt) : X(kt) || Pe(kt);
  }
  C.isArrayBufferView = Me;
  function he(kt) {
    return W(kt) === "Uint8Array";
  }
  C.isUint8Array = he;
  function ge(kt) {
    return W(kt) === "Uint8ClampedArray";
  }
  C.isUint8ClampedArray = ge;
  function Ce(kt) {
    return W(kt) === "Uint16Array";
  }
  C.isUint16Array = Ce;
  function Se(kt) {
    return W(kt) === "Uint32Array";
  }
  C.isUint32Array = Se;
  function Ae(kt) {
    return W(kt) === "Int8Array";
  }
  C.isInt8Array = Ae;
  function Le(kt) {
    return W(kt) === "Int16Array";
  }
  C.isInt16Array = Le;
  function ve(kt) {
    return W(kt) === "Int32Array";
  }
  C.isInt32Array = ve;
  function De(kt) {
    return W(kt) === "Float32Array";
  }
  C.isFloat32Array = De;
  function Ue(kt) {
    return W(kt) === "Float64Array";
  }
  C.isFloat64Array = Ue;
  function Fe(kt) {
    return W(kt) === "BigInt64Array";
  }
  C.isBigInt64Array = Fe;
  function We(kt) {
    return W(kt) === "BigUint64Array";
  }
  C.isBigUint64Array = We;
  function Ke(kt) {
    return ne(kt) === "[object Map]";
  }
  Ke.working = typeof Map < "u" && Ke(/* @__PURE__ */ new Map());
  function it(kt) {
    return typeof Map > "u" ? !1 : Ke.working ? Ke(kt) : kt instanceof Map;
  }
  C.isMap = it;
  function Qe(kt) {
    return ne(kt) === "[object Set]";
  }
  Qe.working = typeof Set < "u" && Qe(/* @__PURE__ */ new Set());
  function vt(kt) {
    return typeof Set > "u" ? !1 : Qe.working ? Qe(kt) : kt instanceof Set;
  }
  C.isSet = vt;
  function Ct(kt) {
    return ne(kt) === "[object WeakMap]";
  }
  Ct.working = typeof WeakMap < "u" && Ct(/* @__PURE__ */ new WeakMap());
  function Tt(kt) {
    return typeof WeakMap > "u" ? !1 : Ct.working ? Ct(kt) : kt instanceof WeakMap;
  }
  C.isWeakMap = Tt;
  function St(kt) {
    return ne(kt) === "[object WeakSet]";
  }
  St.working = typeof WeakSet < "u" && St(/* @__PURE__ */ new WeakSet());
  function Je(kt) {
    return St(kt);
  }
  C.isWeakSet = Je;
  function He(kt) {
    return ne(kt) === "[object ArrayBuffer]";
  }
  He.working = typeof ArrayBuffer < "u" && He(new ArrayBuffer());
  function qe(kt) {
    return typeof ArrayBuffer > "u" ? !1 : He.working ? He(kt) : kt instanceof ArrayBuffer;
  }
  C.isArrayBuffer = qe;
  function Ze(kt) {
    return ne(kt) === "[object DataView]";
  }
  Ze.working = typeof ArrayBuffer < "u" && typeof DataView < "u" && Ze(new DataView(new ArrayBuffer(1), 0, 1));
  function Pe(kt) {
    return typeof DataView > "u" ? !1 : Ze.working ? Ze(kt) : kt instanceof DataView;
  }
  C.isDataView = Pe;
  var Ye = typeof SharedArrayBuffer < "u" ? SharedArrayBuffer : void 0;
  function ot(kt) {
    return ne(kt) === "[object SharedArrayBuffer]";
  }
  function Be(kt) {
    return typeof Ye > "u" ? !1 : (typeof ot.working > "u" && (ot.working = ot(new Ye())), ot.working ? ot(kt) : kt instanceof Ye);
  }
  C.isSharedArrayBuffer = Be;
  function Ve(kt) {
    return ne(kt) === "[object AsyncFunction]";
  }
  C.isAsyncFunction = Ve;
  function fe(kt) {
    return ne(kt) === "[object Map Iterator]";
  }
  C.isMapIterator = fe;
  function _e(kt) {
    return ne(kt) === "[object Set Iterator]";
  }
  C.isSetIterator = _e;
  function je(kt) {
    return ne(kt) === "[object Generator]";
  }
  C.isGeneratorObject = je;
  function Ne(kt) {
    return ne(kt) === "[object WebAssembly.Module]";
  }
  C.isWebAssemblyCompiledModule = Ne;
  function Ie(kt) {
    return pe(kt, re);
  }
  C.isNumberObject = Ie;
  function Xe(kt) {
    return pe(kt, ce);
  }
  C.isStringObject = Xe;
  function ft(kt) {
    return pe(kt, ue);
  }
  C.isBooleanObject = ft;
  function It(kt) {
    return te && pe(kt, de);
  }
  C.isBigIntObject = It;
  function jt(kt) {
    return oe && pe(kt, be);
  }
  C.isSymbolObject = jt;
  function Ot(kt) {
    return Ie(kt) || Xe(kt) || ft(kt) || It(kt) || jt(kt);
  }
  C.isBoxedPrimitive = Ot;
  function Ut(kt) {
    return typeof Uint8Array < "u" && (qe(kt) || Be(kt));
  }
  C.isAnyArrayBuffer = Ut, ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach(function(kt) {
    Object.defineProperty(C, kt, {
      enumerable: !1,
      value: function() {
        throw new Error(kt + " is not supported in userland");
      }
    });
  });
})(types);
var isBufferBrowser = function C(L) {
  return L && typeof L == "object" && typeof L.copy == "function" && typeof L.fill == "function" && typeof L.readUInt8 == "function";
}, inherits_browser = { exports: {} };
typeof Object.create == "function" ? inherits_browser.exports = function(L, A) {
  A && (L.super_ = A, L.prototype = Object.create(A.prototype, {
    constructor: {
      value: L,
      enumerable: !1,
      writable: !0,
      configurable: !0
    }
  }));
} : inherits_browser.exports = function(L, A) {
  if (A) {
    L.super_ = A;
    var W = function() {
    };
    W.prototype = A.prototype, L.prototype = new W(), L.prototype.constructor = L;
  }
};
var inherits_browserExports = inherits_browser.exports;
(function(C) {
  var L = Object.getOwnPropertyDescriptors || function(Pe) {
    for (var Ye = Object.keys(Pe), ot = {}, Be = 0; Be < Ye.length; Be++)
      ot[Ye[Be]] = Object.getOwnPropertyDescriptor(Pe, Ye[Be]);
    return ot;
  }, A = /%[sdj%]/g;
  C.format = function(Ze) {
    if (!Ae(Ze)) {
      for (var Pe = [], Ye = 0; Ye < arguments.length; Ye++)
        Pe.push(te(arguments[Ye]));
      return Pe.join(" ");
    }
    for (var Ye = 1, ot = arguments, Be = ot.length, Ve = String(Ze).replace(A, function(_e) {
      if (_e === "%%") return "%";
      if (Ye >= Be) return _e;
      switch (_e) {
        case "%s":
          return String(ot[Ye++]);
        case "%d":
          return Number(ot[Ye++]);
        case "%j":
          try {
            return JSON.stringify(ot[Ye++]);
          } catch {
            return "[Circular]";
          }
        default:
          return _e;
      }
    }), fe = ot[Ye]; Ye < Be; fe = ot[++Ye])
      ge(fe) || !Ue(fe) ? Ve += " " + fe : Ve += " " + te(fe);
    return Ve;
  }, C.deprecate = function(Ze, Pe) {
    if (typeof process$1 < "u" && process$1.noDeprecation === !0)
      return Ze;
    if (typeof process$1 > "u")
      return function() {
        return C.deprecate(Ze, Pe).apply(this, arguments);
      };
    var Ye = !1;
    function ot() {
      if (!Ye) {
        if (process$1.throwDeprecation)
          throw new Error(Pe);
        process$1.traceDeprecation ? console.trace(Pe) : console.error(Pe), Ye = !0;
      }
      return Ze.apply(this, arguments);
    }
    return ot;
  };
  var W = {}, X = /^$/;
  if (process$1.env.NODE_DEBUG) {
    var J = process$1.env.NODE_DEBUG;
    J = J.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase(), X = new RegExp("^" + J + "$", "i");
  }
  C.debuglog = function(Ze) {
    if (Ze = Ze.toUpperCase(), !W[Ze])
      if (X.test(Ze)) {
        var Pe = process$1.pid;
        W[Ze] = function() {
          var Ye = C.format.apply(C, arguments);
          console.error("%s %d: %s", Ze, Pe, Ye);
        };
      } else
        W[Ze] = function() {
        };
    return W[Ze];
  };
  function te(Ze, Pe) {
    var Ye = {
      seen: [],
      stylize: ne
    };
    return arguments.length >= 3 && (Ye.depth = arguments[2]), arguments.length >= 4 && (Ye.colors = arguments[3]), he(Pe) ? Ye.showHidden = Pe : Pe && C._extend(Ye, Pe), ve(Ye.showHidden) && (Ye.showHidden = !1), ve(Ye.depth) && (Ye.depth = 2), ve(Ye.colors) && (Ye.colors = !1), ve(Ye.customInspect) && (Ye.customInspect = !0), Ye.colors && (Ye.stylize = oe), ce(Ye, Ze, Ye.depth);
  }
  C.inspect = te, te.colors = {
    bold: [1, 22],
    italic: [3, 23],
    underline: [4, 24],
    inverse: [7, 27],
    white: [37, 39],
    grey: [90, 39],
    black: [30, 39],
    blue: [34, 39],
    cyan: [36, 39],
    green: [32, 39],
    magenta: [35, 39],
    red: [31, 39],
    yellow: [33, 39]
  }, te.styles = {
    special: "cyan",
    number: "yellow",
    boolean: "yellow",
    undefined: "grey",
    null: "bold",
    string: "green",
    date: "magenta",
    // "name": intentionally not styling
    regexp: "red"
  };
  function oe(Ze, Pe) {
    var Ye = te.styles[Pe];
    return Ye ? "\x1B[" + te.colors[Ye][0] + "m" + Ze + "\x1B[" + te.colors[Ye][1] + "m" : Ze;
  }
  function ne(Ze, Pe) {
    return Ze;
  }
  function re(Ze) {
    var Pe = {};
    return Ze.forEach(function(Ye, ot) {
      Pe[Ye] = !0;
    }), Pe;
  }
  function ce(Ze, Pe, Ye) {
    if (Ze.customInspect && Pe && Ke(Pe.inspect) && // Filter out the util module, it's inspect function is special
    Pe.inspect !== C.inspect && // Also filter out any prototype objects using the circular check.
    !(Pe.constructor && Pe.constructor.prototype === Pe)) {
      var ot = Pe.inspect(Ye, Ze);
      return Ae(ot) || (ot = ce(Ze, ot, Ye)), ot;
    }
    var Be = ue(Ze, Pe);
    if (Be)
      return Be;
    var Ve = Object.keys(Pe), fe = re(Ve);
    if (Ze.showHidden && (Ve = Object.getOwnPropertyNames(Pe)), We(Pe) && (Ve.indexOf("message") >= 0 || Ve.indexOf("description") >= 0))
      return de(Pe);
    if (Ve.length === 0) {
      if (Ke(Pe)) {
        var _e = Pe.name ? ": " + Pe.name : "";
        return Ze.stylize("[Function" + _e + "]", "special");
      }
      if (De(Pe))
        return Ze.stylize(RegExp.prototype.toString.call(Pe), "regexp");
      if (Fe(Pe))
        return Ze.stylize(Date.prototype.toString.call(Pe), "date");
      if (We(Pe))
        return de(Pe);
    }
    var je = "", Ne = !1, Ie = ["{", "}"];
    if (Me(Pe) && (Ne = !0, Ie = ["[", "]"]), Ke(Pe)) {
      var Xe = Pe.name ? ": " + Pe.name : "";
      je = " [Function" + Xe + "]";
    }
    if (De(Pe) && (je = " " + RegExp.prototype.toString.call(Pe)), Fe(Pe) && (je = " " + Date.prototype.toUTCString.call(Pe)), We(Pe) && (je = " " + de(Pe)), Ve.length === 0 && (!Ne || Pe.length == 0))
      return Ie[0] + je + Ie[1];
    if (Ye < 0)
      return De(Pe) ? Ze.stylize(RegExp.prototype.toString.call(Pe), "regexp") : Ze.stylize("[Object]", "special");
    Ze.seen.push(Pe);
    var ft;
    return Ne ? ft = be(Ze, Pe, Ye, fe, Ve) : ft = Ve.map(function(It) {
      return pe(Ze, Pe, Ye, fe, It, Ne);
    }), Ze.seen.pop(), me(ft, je, Ie);
  }
  function ue(Ze, Pe) {
    if (ve(Pe))
      return Ze.stylize("undefined", "undefined");
    if (Ae(Pe)) {
      var Ye = "'" + JSON.stringify(Pe).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
      return Ze.stylize(Ye, "string");
    }
    if (Se(Pe))
      return Ze.stylize("" + Pe, "number");
    if (he(Pe))
      return Ze.stylize("" + Pe, "boolean");
    if (ge(Pe))
      return Ze.stylize("null", "null");
  }
  function de(Ze) {
    return "[" + Error.prototype.toString.call(Ze) + "]";
  }
  function be(Ze, Pe, Ye, ot, Be) {
    for (var Ve = [], fe = 0, _e = Pe.length; fe < _e; ++fe)
      St(Pe, String(fe)) ? Ve.push(pe(
        Ze,
        Pe,
        Ye,
        ot,
        String(fe),
        !0
      )) : Ve.push("");
    return Be.forEach(function(je) {
      je.match(/^\d+$/) || Ve.push(pe(
        Ze,
        Pe,
        Ye,
        ot,
        je,
        !0
      ));
    }), Ve;
  }
  function pe(Ze, Pe, Ye, ot, Be, Ve) {
    var fe, _e, je;
    if (je = Object.getOwnPropertyDescriptor(Pe, Be) || { value: Pe[Be] }, je.get ? je.set ? _e = Ze.stylize("[Getter/Setter]", "special") : _e = Ze.stylize("[Getter]", "special") : je.set && (_e = Ze.stylize("[Setter]", "special")), St(ot, Be) || (fe = "[" + Be + "]"), _e || (Ze.seen.indexOf(je.value) < 0 ? (ge(Ye) ? _e = ce(Ze, je.value, null) : _e = ce(Ze, je.value, Ye - 1), _e.indexOf(`
`) > -1 && (Ve ? _e = _e.split(`
`).map(function(Ne) {
      return "  " + Ne;
    }).join(`
`).slice(2) : _e = `
` + _e.split(`
`).map(function(Ne) {
      return "   " + Ne;
    }).join(`
`))) : _e = Ze.stylize("[Circular]", "special")), ve(fe)) {
      if (Ve && Be.match(/^\d+$/))
        return _e;
      fe = JSON.stringify("" + Be), fe.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (fe = fe.slice(1, -1), fe = Ze.stylize(fe, "name")) : (fe = fe.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), fe = Ze.stylize(fe, "string"));
    }
    return fe + ": " + _e;
  }
  function me(Ze, Pe, Ye) {
    var ot = Ze.reduce(function(Be, Ve) {
      return Ve.indexOf(`
`) >= 0, Be + Ve.replace(/\u001b\[\d\d?m/g, "").length + 1;
    }, 0);
    return ot > 60 ? Ye[0] + (Pe === "" ? "" : Pe + `
 `) + " " + Ze.join(`,
  `) + " " + Ye[1] : Ye[0] + Pe + " " + Ze.join(", ") + " " + Ye[1];
  }
  C.types = types;
  function Me(Ze) {
    return Array.isArray(Ze);
  }
  C.isArray = Me;
  function he(Ze) {
    return typeof Ze == "boolean";
  }
  C.isBoolean = he;
  function ge(Ze) {
    return Ze === null;
  }
  C.isNull = ge;
  function Ce(Ze) {
    return Ze == null;
  }
  C.isNullOrUndefined = Ce;
  function Se(Ze) {
    return typeof Ze == "number";
  }
  C.isNumber = Se;
  function Ae(Ze) {
    return typeof Ze == "string";
  }
  C.isString = Ae;
  function Le(Ze) {
    return typeof Ze == "symbol";
  }
  C.isSymbol = Le;
  function ve(Ze) {
    return Ze === void 0;
  }
  C.isUndefined = ve;
  function De(Ze) {
    return Ue(Ze) && Qe(Ze) === "[object RegExp]";
  }
  C.isRegExp = De, C.types.isRegExp = De;
  function Ue(Ze) {
    return typeof Ze == "object" && Ze !== null;
  }
  C.isObject = Ue;
  function Fe(Ze) {
    return Ue(Ze) && Qe(Ze) === "[object Date]";
  }
  C.isDate = Fe, C.types.isDate = Fe;
  function We(Ze) {
    return Ue(Ze) && (Qe(Ze) === "[object Error]" || Ze instanceof Error);
  }
  C.isError = We, C.types.isNativeError = We;
  function Ke(Ze) {
    return typeof Ze == "function";
  }
  C.isFunction = Ke;
  function it(Ze) {
    return Ze === null || typeof Ze == "boolean" || typeof Ze == "number" || typeof Ze == "string" || typeof Ze == "symbol" || // ES6 symbol
    typeof Ze > "u";
  }
  C.isPrimitive = it, C.isBuffer = isBufferBrowser;
  function Qe(Ze) {
    return Object.prototype.toString.call(Ze);
  }
  function vt(Ze) {
    return Ze < 10 ? "0" + Ze.toString(10) : Ze.toString(10);
  }
  var Ct = [
    "Jan",
    "Feb",
    "Mar",
    "Apr",
    "May",
    "Jun",
    "Jul",
    "Aug",
    "Sep",
    "Oct",
    "Nov",
    "Dec"
  ];
  function Tt() {
    var Ze = /* @__PURE__ */ new Date(), Pe = [
      vt(Ze.getHours()),
      vt(Ze.getMinutes()),
      vt(Ze.getSeconds())
    ].join(":");
    return [Ze.getDate(), Ct[Ze.getMonth()], Pe].join(" ");
  }
  C.log = function() {
    console.log("%s - %s", Tt(), C.format.apply(C, arguments));
  }, C.inherits = inherits_browserExports, C._extend = function(Ze, Pe) {
    if (!Pe || !Ue(Pe)) return Ze;
    for (var Ye = Object.keys(Pe), ot = Ye.length; ot--; )
      Ze[Ye[ot]] = Pe[Ye[ot]];
    return Ze;
  };
  function St(Ze, Pe) {
    return Object.prototype.hasOwnProperty.call(Ze, Pe);
  }
  var Je = typeof Symbol < "u" ? Symbol("util.promisify.custom") : void 0;
  C.promisify = function(Pe) {
    if (typeof Pe != "function")
      throw new TypeError('The "original" argument must be of type Function');
    if (Je && Pe[Je]) {
      var Ye = Pe[Je];
      if (typeof Ye != "function")
        throw new TypeError('The "util.promisify.custom" argument must be of type Function');
      return Object.defineProperty(Ye, Je, {
        value: Ye,
        enumerable: !1,
        writable: !1,
        configurable: !0
      }), Ye;
    }
    function Ye() {
      for (var ot, Be, Ve = new Promise(function(je, Ne) {
        ot = je, Be = Ne;
      }), fe = [], _e = 0; _e < arguments.length; _e++)
        fe.push(arguments[_e]);
      fe.push(function(je, Ne) {
        je ? Be(je) : ot(Ne);
      });
      try {
        Pe.apply(this, fe);
      } catch (je) {
        Be(je);
      }
      return Ve;
    }
    return Object.setPrototypeOf(Ye, Object.getPrototypeOf(Pe)), Je && Object.defineProperty(Ye, Je, {
      value: Ye,
      enumerable: !1,
      writable: !1,
      configurable: !0
    }), Object.defineProperties(
      Ye,
      L(Pe)
    );
  }, C.promisify.custom = Je;
  function He(Ze, Pe) {
    if (!Ze) {
      var Ye = new Error("Promise was rejected with a falsy value");
      Ye.reason = Ze, Ze = Ye;
    }
    return Pe(Ze);
  }
  function qe(Ze) {
    if (typeof Ze != "function")
      throw new TypeError('The "original" argument must be of type Function');
    function Pe() {
      for (var Ye = [], ot = 0; ot < arguments.length; ot++)
        Ye.push(arguments[ot]);
      var Be = Ye.pop();
      if (typeof Be != "function")
        throw new TypeError("The last argument must be of type Function");
      var Ve = this, fe = function() {
        return Be.apply(Ve, arguments);
      };
      Ze.apply(this, Ye).then(
        function(_e) {
          process$1.nextTick(fe.bind(null, null, _e));
        },
        function(_e) {
          process$1.nextTick(He.bind(null, _e, fe));
        }
      );
    }
    return Object.setPrototypeOf(Pe, Object.getPrototypeOf(Ze)), Object.defineProperties(
      Pe,
      L(Ze)
    ), Pe;
  }
  C.callbackify = qe;
})(util);
var buffer_list, hasRequiredBuffer_list;
function requireBuffer_list() {
  if (hasRequiredBuffer_list) return buffer_list;
  hasRequiredBuffer_list = 1;
  function C(pe, me) {
    var Me = Object.keys(pe);
    if (Object.getOwnPropertySymbols) {
      var he = Object.getOwnPropertySymbols(pe);
      me && (he = he.filter(function(ge) {
        return Object.getOwnPropertyDescriptor(pe, ge).enumerable;
      })), Me.push.apply(Me, he);
    }
    return Me;
  }
  function L(pe) {
    for (var me = 1; me < arguments.length; me++) {
      var Me = arguments[me] != null ? arguments[me] : {};
      me % 2 ? C(Object(Me), !0).forEach(function(he) {
        A(pe, he, Me[he]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(pe, Object.getOwnPropertyDescriptors(Me)) : C(Object(Me)).forEach(function(he) {
        Object.defineProperty(pe, he, Object.getOwnPropertyDescriptor(Me, he));
      });
    }
    return pe;
  }
  function A(pe, me, Me) {
    return me = te(me), me in pe ? Object.defineProperty(pe, me, { value: Me, enumerable: !0, configurable: !0, writable: !0 }) : pe[me] = Me, pe;
  }
  function W(pe, me) {
    if (!(pe instanceof me))
      throw new TypeError("Cannot call a class as a function");
  }
  function X(pe, me) {
    for (var Me = 0; Me < me.length; Me++) {
      var he = me[Me];
      he.enumerable = he.enumerable || !1, he.configurable = !0, "value" in he && (he.writable = !0), Object.defineProperty(pe, te(he.key), he);
    }
  }
  function J(pe, me, Me) {
    return me && X(pe.prototype, me), Object.defineProperty(pe, "prototype", { writable: !1 }), pe;
  }
  function te(pe) {
    var me = oe(pe, "string");
    return typeof me == "symbol" ? me : String(me);
  }
  function oe(pe, me) {
    if (typeof pe != "object" || pe === null) return pe;
    var Me = pe[Symbol.toPrimitive];
    if (Me !== void 0) {
      var he = Me.call(pe, me || "default");
      if (typeof he != "object") return he;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (me === "string" ? String : Number)(pe);
  }
  var ne = require$$2, re = ne.Buffer, ce = util, ue = ce.inspect, de = ue && ue.custom || "inspect";
  function be(pe, me, Me) {
    re.prototype.copy.call(pe, me, Me);
  }
  return buffer_list = /* @__PURE__ */ function() {
    function pe() {
      W(this, pe), this.head = null, this.tail = null, this.length = 0;
    }
    return J(pe, [{
      key: "push",
      value: function(Me) {
        var he = {
          data: Me,
          next: null
        };
        this.length > 0 ? this.tail.next = he : this.head = he, this.tail = he, ++this.length;
      }
    }, {
      key: "unshift",
      value: function(Me) {
        var he = {
          data: Me,
          next: this.head
        };
        this.length === 0 && (this.tail = he), this.head = he, ++this.length;
      }
    }, {
      key: "shift",
      value: function() {
        if (this.length !== 0) {
          var Me = this.head.data;
          return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, Me;
        }
      }
    }, {
      key: "clear",
      value: function() {
        this.head = this.tail = null, this.length = 0;
      }
    }, {
      key: "join",
      value: function(Me) {
        if (this.length === 0) return "";
        for (var he = this.head, ge = "" + he.data; he = he.next; ) ge += Me + he.data;
        return ge;
      }
    }, {
      key: "concat",
      value: function(Me) {
        if (this.length === 0) return re.alloc(0);
        for (var he = re.allocUnsafe(Me >>> 0), ge = this.head, Ce = 0; ge; )
          be(ge.data, he, Ce), Ce += ge.data.length, ge = ge.next;
        return he;
      }
      // Consumes a specified amount of bytes or characters from the buffered data.
    }, {
      key: "consume",
      value: function(Me, he) {
        var ge;
        return Me < this.head.data.length ? (ge = this.head.data.slice(0, Me), this.head.data = this.head.data.slice(Me)) : Me === this.head.data.length ? ge = this.shift() : ge = he ? this._getString(Me) : this._getBuffer(Me), ge;
      }
    }, {
      key: "first",
      value: function() {
        return this.head.data;
      }
      // Consumes a specified amount of characters from the buffered data.
    }, {
      key: "_getString",
      value: function(Me) {
        var he = this.head, ge = 1, Ce = he.data;
        for (Me -= Ce.length; he = he.next; ) {
          var Se = he.data, Ae = Me > Se.length ? Se.length : Me;
          if (Ae === Se.length ? Ce += Se : Ce += Se.slice(0, Me), Me -= Ae, Me === 0) {
            Ae === Se.length ? (++ge, he.next ? this.head = he.next : this.head = this.tail = null) : (this.head = he, he.data = Se.slice(Ae));
            break;
          }
          ++ge;
        }
        return this.length -= ge, Ce;
      }
      // Consumes a specified amount of bytes from the buffered data.
    }, {
      key: "_getBuffer",
      value: function(Me) {
        var he = re.allocUnsafe(Me), ge = this.head, Ce = 1;
        for (ge.data.copy(he), Me -= ge.data.length; ge = ge.next; ) {
          var Se = ge.data, Ae = Me > Se.length ? Se.length : Me;
          if (Se.copy(he, he.length - Me, 0, Ae), Me -= Ae, Me === 0) {
            Ae === Se.length ? (++Ce, ge.next ? this.head = ge.next : this.head = this.tail = null) : (this.head = ge, ge.data = Se.slice(Ae));
            break;
          }
          ++Ce;
        }
        return this.length -= Ce, he;
      }
      // Make sure the linked list only shows the minimal necessary information.
    }, {
      key: de,
      value: function(Me, he) {
        return ue(this, L(L({}, he), {}, {
          // Only inspect one level.
          depth: 0,
          // It should not recurse.
          customInspect: !1
        }));
      }
    }]), pe;
  }(), buffer_list;
}
function destroy(C, L) {
  var A = this, W = this._readableState && this._readableState.destroyed, X = this._writableState && this._writableState.destroyed;
  return W || X ? (L ? L(C) : C && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = !0, process$1.nextTick(emitErrorNT, this, C)) : process$1.nextTick(emitErrorNT, this, C)), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this._writableState.destroyed = !0), this._destroy(C || null, function(J) {
    !L && J ? A._writableState ? A._writableState.errorEmitted ? process$1.nextTick(emitCloseNT, A) : (A._writableState.errorEmitted = !0, process$1.nextTick(emitErrorAndCloseNT, A, J)) : process$1.nextTick(emitErrorAndCloseNT, A, J) : L ? (process$1.nextTick(emitCloseNT, A), L(J)) : process$1.nextTick(emitCloseNT, A);
  }), this);
}
function emitErrorAndCloseNT(C, L) {
  emitErrorNT(C, L), emitCloseNT(C);
}
function emitCloseNT(C) {
  C._writableState && !C._writableState.emitClose || C._readableState && !C._readableState.emitClose || C.emit("close");
}
function undestroy() {
  this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending = !1, this._writableState.finalCalled = !1, this._writableState.prefinished = !1, this._writableState.finished = !1, this._writableState.errorEmitted = !1);
}
function emitErrorNT(C, L) {
  C.emit("error", L);
}
function errorOrDestroy(C, L) {
  var A = C._readableState, W = C._writableState;
  A && A.autoDestroy || W && W.autoDestroy ? C.destroy(L) : C.emit("error", L);
}
var destroy_1 = {
  destroy,
  undestroy,
  errorOrDestroy
}, errorsBrowser = {};
function _inheritsLoose(C, L) {
  C.prototype = Object.create(L.prototype), C.prototype.constructor = C, C.__proto__ = L;
}
var codes = {};
function createErrorType(C, L, A) {
  A || (A = Error);
  function W(J, te, oe) {
    return typeof L == "string" ? L : L(J, te, oe);
  }
  var X = /* @__PURE__ */ function(J) {
    _inheritsLoose(te, J);
    function te(oe, ne, re) {
      return J.call(this, W(oe, ne, re)) || this;
    }
    return te;
  }(A);
  X.prototype.name = A.name, X.prototype.code = C, codes[C] = X;
}
function oneOf(C, L) {
  if (Array.isArray(C)) {
    var A = C.length;
    return C = C.map(function(W) {
      return String(W);
    }), A > 2 ? "one of ".concat(L, " ").concat(C.slice(0, A - 1).join(", "), ", or ") + C[A - 1] : A === 2 ? "one of ".concat(L, " ").concat(C[0], " or ").concat(C[1]) : "of ".concat(L, " ").concat(C[0]);
  } else
    return "of ".concat(L, " ").concat(String(C));
}
function startsWith(C, L, A) {
  return C.substr(0, L.length) === L;
}
function endsWith(C, L, A) {
  return (A === void 0 || A > C.length) && (A = C.length), C.substring(A - L.length, A) === L;
}
function includes(C, L, A) {
  return typeof A != "number" && (A = 0), A + L.length > C.length ? !1 : C.indexOf(L, A) !== -1;
}
createErrorType("ERR_INVALID_OPT_VALUE", function(C, L) {
  return 'The value "' + L + '" is invalid for option "' + C + '"';
}, TypeError);
createErrorType("ERR_INVALID_ARG_TYPE", function(C, L, A) {
  var W;
  typeof L == "string" && startsWith(L, "not ") ? (W = "must not be", L = L.replace(/^not /, "")) : W = "must be";
  var X;
  if (endsWith(C, " argument"))
    X = "The ".concat(C, " ").concat(W, " ").concat(oneOf(L, "type"));
  else {
    var J = includes(C, ".") ? "property" : "argument";
    X = 'The "'.concat(C, '" ').concat(J, " ").concat(W, " ").concat(oneOf(L, "type"));
  }
  return X += ". Received type ".concat(typeof A), X;
}, TypeError);
createErrorType("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
createErrorType("ERR_METHOD_NOT_IMPLEMENTED", function(C) {
  return "The " + C + " method is not implemented";
});
createErrorType("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
createErrorType("ERR_STREAM_DESTROYED", function(C) {
  return "Cannot call " + C + " after a stream was destroyed";
});
createErrorType("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
createErrorType("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
createErrorType("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
createErrorType("ERR_UNKNOWN_ENCODING", function(C) {
  return "Unknown encoding: " + C;
}, TypeError);
createErrorType("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
errorsBrowser.codes = codes;
var ERR_INVALID_OPT_VALUE = errorsBrowser.codes.ERR_INVALID_OPT_VALUE;
function highWaterMarkFrom(C, L, A) {
  return C.highWaterMark != null ? C.highWaterMark : L ? C[A] : null;
}
function getHighWaterMark(C, L, A, W) {
  var X = highWaterMarkFrom(L, W, A);
  if (X != null) {
    if (!(isFinite(X) && Math.floor(X) === X) || X < 0) {
      var J = W ? A : "highWaterMark";
      throw new ERR_INVALID_OPT_VALUE(J, X);
    }
    return Math.floor(X);
  }
  return C.objectMode ? 16 : 16 * 1024;
}
var state = {
  getHighWaterMark
}, browser$1 = deprecate;
function deprecate(C, L) {
  if (config("noDeprecation"))
    return C;
  var A = !1;
  function W() {
    if (!A) {
      if (config("throwDeprecation"))
        throw new Error(L);
      config("traceDeprecation") ? console.trace(L) : console.warn(L), A = !0;
    }
    return C.apply(this, arguments);
  }
  return W;
}
function config(C) {
  try {
    if (!commonjsGlobal.localStorage) return !1;
  } catch {
    return !1;
  }
  var L = commonjsGlobal.localStorage[C];
  return L == null ? !1 : String(L).toLowerCase() === "true";
}
var _stream_writable, hasRequired_stream_writable;
function require_stream_writable() {
  if (hasRequired_stream_writable) return _stream_writable;
  hasRequired_stream_writable = 1, _stream_writable = De;
  function C(Be) {
    var Ve = this;
    this.next = null, this.entry = null, this.finish = function() {
      ot(Ve, Be);
    };
  }
  var L;
  De.WritableState = Le;
  var A = {
    deprecate: browser$1
  }, W = streamBrowser, X = require$$2.Buffer, J = (typeof commonjsGlobal < "u" ? commonjsGlobal : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function te(Be) {
    return X.from(Be);
  }
  function oe(Be) {
    return X.isBuffer(Be) || Be instanceof J;
  }
  var ne = destroy_1, re = state, ce = re.getHighWaterMark, ue = errorsBrowser.codes, de = ue.ERR_INVALID_ARG_TYPE, be = ue.ERR_METHOD_NOT_IMPLEMENTED, pe = ue.ERR_MULTIPLE_CALLBACK, me = ue.ERR_STREAM_CANNOT_PIPE, Me = ue.ERR_STREAM_DESTROYED, he = ue.ERR_STREAM_NULL_VALUES, ge = ue.ERR_STREAM_WRITE_AFTER_END, Ce = ue.ERR_UNKNOWN_ENCODING, Se = ne.errorOrDestroy;
  inherits_browserExports(De, W);
  function Ae() {
  }
  function Le(Be, Ve, fe) {
    L = L || require_stream_duplex(), Be = Be || {}, typeof fe != "boolean" && (fe = Ve instanceof L), this.objectMode = !!Be.objectMode, fe && (this.objectMode = this.objectMode || !!Be.writableObjectMode), this.highWaterMark = ce(this, Be, "writableHighWaterMark", fe), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
    var _e = Be.decodeStrings === !1;
    this.decodeStrings = !_e, this.defaultEncoding = Be.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function(je) {
      Ct(Ve, je);
    }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.emitClose = Be.emitClose !== !1, this.autoDestroy = !!Be.autoDestroy, this.bufferedRequestCount = 0, this.corkedRequestsFree = new C(this);
  }
  Le.prototype.getBuffer = function() {
    for (var Ve = this.bufferedRequest, fe = []; Ve; )
      fe.push(Ve), Ve = Ve.next;
    return fe;
  }, function() {
    try {
      Object.defineProperty(Le.prototype, "buffer", {
        get: A.deprecate(function() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
      });
    } catch {
    }
  }();
  var ve;
  typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (ve = Function.prototype[Symbol.hasInstance], Object.defineProperty(De, Symbol.hasInstance, {
    value: function(Ve) {
      return ve.call(this, Ve) ? !0 : this !== De ? !1 : Ve && Ve._writableState instanceof Le;
    }
  })) : ve = function(Ve) {
    return Ve instanceof this;
  };
  function De(Be) {
    L = L || require_stream_duplex();
    var Ve = this instanceof L;
    if (!Ve && !ve.call(De, this)) return new De(Be);
    this._writableState = new Le(Be, this, Ve), this.writable = !0, Be && (typeof Be.write == "function" && (this._write = Be.write), typeof Be.writev == "function" && (this._writev = Be.writev), typeof Be.destroy == "function" && (this._destroy = Be.destroy), typeof Be.final == "function" && (this._final = Be.final)), W.call(this);
  }
  De.prototype.pipe = function() {
    Se(this, new me());
  };
  function Ue(Be, Ve) {
    var fe = new ge();
    Se(Be, fe), process$1.nextTick(Ve, fe);
  }
  function Fe(Be, Ve, fe, _e) {
    var je;
    return fe === null ? je = new he() : typeof fe != "string" && !Ve.objectMode && (je = new de("chunk", ["string", "Buffer"], fe)), je ? (Se(Be, je), process$1.nextTick(_e, je), !1) : !0;
  }
  De.prototype.write = function(Be, Ve, fe) {
    var _e = this._writableState, je = !1, Ne = !_e.objectMode && oe(Be);
    return Ne && !X.isBuffer(Be) && (Be = te(Be)), typeof Ve == "function" && (fe = Ve, Ve = null), Ne ? Ve = "buffer" : Ve || (Ve = _e.defaultEncoding), typeof fe != "function" && (fe = Ae), _e.ending ? Ue(this, fe) : (Ne || Fe(this, _e, Be, fe)) && (_e.pendingcb++, je = Ke(this, _e, Ne, Be, Ve, fe)), je;
  }, De.prototype.cork = function() {
    this._writableState.corked++;
  }, De.prototype.uncork = function() {
    var Be = this._writableState;
    Be.corked && (Be.corked--, !Be.writing && !Be.corked && !Be.bufferProcessing && Be.bufferedRequest && Je(this, Be));
  }, De.prototype.setDefaultEncoding = function(Ve) {
    if (typeof Ve == "string" && (Ve = Ve.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((Ve + "").toLowerCase()) > -1)) throw new Ce(Ve);
    return this._writableState.defaultEncoding = Ve, this;
  }, Object.defineProperty(De.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState && this._writableState.getBuffer();
    }
  });
  function We(Be, Ve, fe) {
    return !Be.objectMode && Be.decodeStrings !== !1 && typeof Ve == "string" && (Ve = X.from(Ve, fe)), Ve;
  }
  Object.defineProperty(De.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function Ke(Be, Ve, fe, _e, je, Ne) {
    if (!fe) {
      var Ie = We(Ve, _e, je);
      _e !== Ie && (fe = !0, je = "buffer", _e = Ie);
    }
    var Xe = Ve.objectMode ? 1 : _e.length;
    Ve.length += Xe;
    var ft = Ve.length < Ve.highWaterMark;
    if (ft || (Ve.needDrain = !0), Ve.writing || Ve.corked) {
      var It = Ve.lastBufferedRequest;
      Ve.lastBufferedRequest = {
        chunk: _e,
        encoding: je,
        isBuf: fe,
        callback: Ne,
        next: null
      }, It ? It.next = Ve.lastBufferedRequest : Ve.bufferedRequest = Ve.lastBufferedRequest, Ve.bufferedRequestCount += 1;
    } else
      it(Be, Ve, !1, Xe, _e, je, Ne);
    return ft;
  }
  function it(Be, Ve, fe, _e, je, Ne, Ie) {
    Ve.writelen = _e, Ve.writecb = Ie, Ve.writing = !0, Ve.sync = !0, Ve.destroyed ? Ve.onwrite(new Me("write")) : fe ? Be._writev(je, Ve.onwrite) : Be._write(je, Ne, Ve.onwrite), Ve.sync = !1;
  }
  function Qe(Be, Ve, fe, _e, je) {
    --Ve.pendingcb, fe ? (process$1.nextTick(je, _e), process$1.nextTick(Pe, Be, Ve), Be._writableState.errorEmitted = !0, Se(Be, _e)) : (je(_e), Be._writableState.errorEmitted = !0, Se(Be, _e), Pe(Be, Ve));
  }
  function vt(Be) {
    Be.writing = !1, Be.writecb = null, Be.length -= Be.writelen, Be.writelen = 0;
  }
  function Ct(Be, Ve) {
    var fe = Be._writableState, _e = fe.sync, je = fe.writecb;
    if (typeof je != "function") throw new pe();
    if (vt(fe), Ve) Qe(Be, fe, _e, Ve, je);
    else {
      var Ne = He(fe) || Be.destroyed;
      !Ne && !fe.corked && !fe.bufferProcessing && fe.bufferedRequest && Je(Be, fe), _e ? process$1.nextTick(Tt, Be, fe, Ne, je) : Tt(Be, fe, Ne, je);
    }
  }
  function Tt(Be, Ve, fe, _e) {
    fe || St(Be, Ve), Ve.pendingcb--, _e(), Pe(Be, Ve);
  }
  function St(Be, Ve) {
    Ve.length === 0 && Ve.needDrain && (Ve.needDrain = !1, Be.emit("drain"));
  }
  function Je(Be, Ve) {
    Ve.bufferProcessing = !0;
    var fe = Ve.bufferedRequest;
    if (Be._writev && fe && fe.next) {
      var _e = Ve.bufferedRequestCount, je = new Array(_e), Ne = Ve.corkedRequestsFree;
      Ne.entry = fe;
      for (var Ie = 0, Xe = !0; fe; )
        je[Ie] = fe, fe.isBuf || (Xe = !1), fe = fe.next, Ie += 1;
      je.allBuffers = Xe, it(Be, Ve, !0, Ve.length, je, "", Ne.finish), Ve.pendingcb++, Ve.lastBufferedRequest = null, Ne.next ? (Ve.corkedRequestsFree = Ne.next, Ne.next = null) : Ve.corkedRequestsFree = new C(Ve), Ve.bufferedRequestCount = 0;
    } else {
      for (; fe; ) {
        var ft = fe.chunk, It = fe.encoding, jt = fe.callback, Ot = Ve.objectMode ? 1 : ft.length;
        if (it(Be, Ve, !1, Ot, ft, It, jt), fe = fe.next, Ve.bufferedRequestCount--, Ve.writing)
          break;
      }
      fe === null && (Ve.lastBufferedRequest = null);
    }
    Ve.bufferedRequest = fe, Ve.bufferProcessing = !1;
  }
  De.prototype._write = function(Be, Ve, fe) {
    fe(new be("_write()"));
  }, De.prototype._writev = null, De.prototype.end = function(Be, Ve, fe) {
    var _e = this._writableState;
    return typeof Be == "function" ? (fe = Be, Be = null, Ve = null) : typeof Ve == "function" && (fe = Ve, Ve = null), Be != null && this.write(Be, Ve), _e.corked && (_e.corked = 1, this.uncork()), _e.ending || Ye(this, _e, fe), this;
  }, Object.defineProperty(De.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.length;
    }
  });
  function He(Be) {
    return Be.ending && Be.length === 0 && Be.bufferedRequest === null && !Be.finished && !Be.writing;
  }
  function qe(Be, Ve) {
    Be._final(function(fe) {
      Ve.pendingcb--, fe && Se(Be, fe), Ve.prefinished = !0, Be.emit("prefinish"), Pe(Be, Ve);
    });
  }
  function Ze(Be, Ve) {
    !Ve.prefinished && !Ve.finalCalled && (typeof Be._final == "function" && !Ve.destroyed ? (Ve.pendingcb++, Ve.finalCalled = !0, process$1.nextTick(qe, Be, Ve)) : (Ve.prefinished = !0, Be.emit("prefinish")));
  }
  function Pe(Be, Ve) {
    var fe = He(Ve);
    if (fe && (Ze(Be, Ve), Ve.pendingcb === 0 && (Ve.finished = !0, Be.emit("finish"), Ve.autoDestroy))) {
      var _e = Be._readableState;
      (!_e || _e.autoDestroy && _e.endEmitted) && Be.destroy();
    }
    return fe;
  }
  function Ye(Be, Ve, fe) {
    Ve.ending = !0, Pe(Be, Ve), fe && (Ve.finished ? process$1.nextTick(fe) : Be.once("finish", fe)), Ve.ended = !0, Be.writable = !1;
  }
  function ot(Be, Ve, fe) {
    var _e = Be.entry;
    for (Be.entry = null; _e; ) {
      var je = _e.callback;
      Ve.pendingcb--, je(fe), _e = _e.next;
    }
    Ve.corkedRequestsFree.next = Be;
  }
  return Object.defineProperty(De.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState === void 0 ? !1 : this._writableState.destroyed;
    },
    set: function(Ve) {
      this._writableState && (this._writableState.destroyed = Ve);
    }
  }), De.prototype.destroy = ne.destroy, De.prototype._undestroy = ne.undestroy, De.prototype._destroy = function(Be, Ve) {
    Ve(Be);
  }, _stream_writable;
}
var _stream_duplex, hasRequired_stream_duplex;
function require_stream_duplex() {
  if (hasRequired_stream_duplex) return _stream_duplex;
  hasRequired_stream_duplex = 1;
  var C = Object.keys || function(re) {
    var ce = [];
    for (var ue in re) ce.push(ue);
    return ce;
  };
  _stream_duplex = te;
  var L = require_stream_readable(), A = require_stream_writable();
  inherits_browserExports(te, L);
  for (var W = C(A.prototype), X = 0; X < W.length; X++) {
    var J = W[X];
    te.prototype[J] || (te.prototype[J] = A.prototype[J]);
  }
  function te(re) {
    if (!(this instanceof te)) return new te(re);
    L.call(this, re), A.call(this, re), this.allowHalfOpen = !0, re && (re.readable === !1 && (this.readable = !1), re.writable === !1 && (this.writable = !1), re.allowHalfOpen === !1 && (this.allowHalfOpen = !1, this.once("end", oe)));
  }
  Object.defineProperty(te.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  }), Object.defineProperty(te.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState && this._writableState.getBuffer();
    }
  }), Object.defineProperty(te.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.length;
    }
  });
  function oe() {
    this._writableState.ended || process$1.nextTick(ne, this);
  }
  function ne(re) {
    re.end();
  }
  return Object.defineProperty(te.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState === void 0 || this._writableState === void 0 ? !1 : this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function(ce) {
      this._readableState === void 0 || this._writableState === void 0 || (this._readableState.destroyed = ce, this._writableState.destroyed = ce);
    }
  }), _stream_duplex;
}
var string_decoder = {}, safeBuffer = { exports: {} };
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
var hasRequiredSafeBuffer;
function requireSafeBuffer() {
  return hasRequiredSafeBuffer || (hasRequiredSafeBuffer = 1, function(C, L) {
    var A = require$$2, W = A.Buffer;
    function X(te, oe) {
      for (var ne in te)
        oe[ne] = te[ne];
    }
    W.from && W.alloc && W.allocUnsafe && W.allocUnsafeSlow ? C.exports = A : (X(A, L), L.Buffer = J);
    function J(te, oe, ne) {
      return W(te, oe, ne);
    }
    J.prototype = Object.create(W.prototype), X(W, J), J.from = function(te, oe, ne) {
      if (typeof te == "number")
        throw new TypeError("Argument must not be a number");
      return W(te, oe, ne);
    }, J.alloc = function(te, oe, ne) {
      if (typeof te != "number")
        throw new TypeError("Argument must be a number");
      var re = W(te);
      return oe !== void 0 ? typeof ne == "string" ? re.fill(oe, ne) : re.fill(oe) : re.fill(0), re;
    }, J.allocUnsafe = function(te) {
      if (typeof te != "number")
        throw new TypeError("Argument must be a number");
      return W(te);
    }, J.allocUnsafeSlow = function(te) {
      if (typeof te != "number")
        throw new TypeError("Argument must be a number");
      return A.SlowBuffer(te);
    };
  }(safeBuffer, safeBuffer.exports)), safeBuffer.exports;
}
var hasRequiredString_decoder;
function requireString_decoder() {
  if (hasRequiredString_decoder) return string_decoder;
  hasRequiredString_decoder = 1;
  var C = requireSafeBuffer().Buffer, L = C.isEncoding || function(he) {
    switch (he = "" + he, he && he.toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
      case "raw":
        return !0;
      default:
        return !1;
    }
  };
  function A(he) {
    if (!he) return "utf8";
    for (var ge; ; )
      switch (he) {
        case "utf8":
        case "utf-8":
          return "utf8";
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return "utf16le";
        case "latin1":
        case "binary":
          return "latin1";
        case "base64":
        case "ascii":
        case "hex":
          return he;
        default:
          if (ge) return;
          he = ("" + he).toLowerCase(), ge = !0;
      }
  }
  function W(he) {
    var ge = A(he);
    if (typeof ge != "string" && (C.isEncoding === L || !L(he))) throw new Error("Unknown encoding: " + he);
    return ge || he;
  }
  string_decoder.StringDecoder = X;
  function X(he) {
    this.encoding = W(he);
    var ge;
    switch (this.encoding) {
      case "utf16le":
        this.text = ue, this.end = de, ge = 4;
        break;
      case "utf8":
        this.fillLast = ne, ge = 4;
        break;
      case "base64":
        this.text = be, this.end = pe, ge = 3;
        break;
      default:
        this.write = me, this.end = Me;
        return;
    }
    this.lastNeed = 0, this.lastTotal = 0, this.lastChar = C.allocUnsafe(ge);
  }
  X.prototype.write = function(he) {
    if (he.length === 0) return "";
    var ge, Ce;
    if (this.lastNeed) {
      if (ge = this.fillLast(he), ge === void 0) return "";
      Ce = this.lastNeed, this.lastNeed = 0;
    } else
      Ce = 0;
    return Ce < he.length ? ge ? ge + this.text(he, Ce) : this.text(he, Ce) : ge || "";
  }, X.prototype.end = ce, X.prototype.text = re, X.prototype.fillLast = function(he) {
    if (this.lastNeed <= he.length)
      return he.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
    he.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, he.length), this.lastNeed -= he.length;
  };
  function J(he) {
    return he <= 127 ? 0 : he >> 5 === 6 ? 2 : he >> 4 === 14 ? 3 : he >> 3 === 30 ? 4 : he >> 6 === 2 ? -1 : -2;
  }
  function te(he, ge, Ce) {
    var Se = ge.length - 1;
    if (Se < Ce) return 0;
    var Ae = J(ge[Se]);
    return Ae >= 0 ? (Ae > 0 && (he.lastNeed = Ae - 1), Ae) : --Se < Ce || Ae === -2 ? 0 : (Ae = J(ge[Se]), Ae >= 0 ? (Ae > 0 && (he.lastNeed = Ae - 2), Ae) : --Se < Ce || Ae === -2 ? 0 : (Ae = J(ge[Se]), Ae >= 0 ? (Ae > 0 && (Ae === 2 ? Ae = 0 : he.lastNeed = Ae - 3), Ae) : 0));
  }
  function oe(he, ge, Ce) {
    if ((ge[0] & 192) !== 128)
      return he.lastNeed = 0, "�";
    if (he.lastNeed > 1 && ge.length > 1) {
      if ((ge[1] & 192) !== 128)
        return he.lastNeed = 1, "�";
      if (he.lastNeed > 2 && ge.length > 2 && (ge[2] & 192) !== 128)
        return he.lastNeed = 2, "�";
    }
  }
  function ne(he) {
    var ge = this.lastTotal - this.lastNeed, Ce = oe(this, he);
    if (Ce !== void 0) return Ce;
    if (this.lastNeed <= he.length)
      return he.copy(this.lastChar, ge, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
    he.copy(this.lastChar, ge, 0, he.length), this.lastNeed -= he.length;
  }
  function re(he, ge) {
    var Ce = te(this, he, ge);
    if (!this.lastNeed) return he.toString("utf8", ge);
    this.lastTotal = Ce;
    var Se = he.length - (Ce - this.lastNeed);
    return he.copy(this.lastChar, 0, Se), he.toString("utf8", ge, Se);
  }
  function ce(he) {
    var ge = he && he.length ? this.write(he) : "";
    return this.lastNeed ? ge + "�" : ge;
  }
  function ue(he, ge) {
    if ((he.length - ge) % 2 === 0) {
      var Ce = he.toString("utf16le", ge);
      if (Ce) {
        var Se = Ce.charCodeAt(Ce.length - 1);
        if (Se >= 55296 && Se <= 56319)
          return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = he[he.length - 2], this.lastChar[1] = he[he.length - 1], Ce.slice(0, -1);
      }
      return Ce;
    }
    return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = he[he.length - 1], he.toString("utf16le", ge, he.length - 1);
  }
  function de(he) {
    var ge = he && he.length ? this.write(he) : "";
    if (this.lastNeed) {
      var Ce = this.lastTotal - this.lastNeed;
      return ge + this.lastChar.toString("utf16le", 0, Ce);
    }
    return ge;
  }
  function be(he, ge) {
    var Ce = (he.length - ge) % 3;
    return Ce === 0 ? he.toString("base64", ge) : (this.lastNeed = 3 - Ce, this.lastTotal = 3, Ce === 1 ? this.lastChar[0] = he[he.length - 1] : (this.lastChar[0] = he[he.length - 2], this.lastChar[1] = he[he.length - 1]), he.toString("base64", ge, he.length - Ce));
  }
  function pe(he) {
    var ge = he && he.length ? this.write(he) : "";
    return this.lastNeed ? ge + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : ge;
  }
  function me(he) {
    return he.toString(this.encoding);
  }
  function Me(he) {
    return he && he.length ? this.write(he) : "";
  }
  return string_decoder;
}
var ERR_STREAM_PREMATURE_CLOSE = errorsBrowser.codes.ERR_STREAM_PREMATURE_CLOSE;
function once$1(C) {
  var L = !1;
  return function() {
    if (!L) {
      L = !0;
      for (var A = arguments.length, W = new Array(A), X = 0; X < A; X++)
        W[X] = arguments[X];
      C.apply(this, W);
    }
  };
}
function noop$1() {
}
function isRequest$1(C) {
  return C.setHeader && typeof C.abort == "function";
}
function eos$1(C, L, A) {
  if (typeof L == "function") return eos$1(C, null, L);
  L || (L = {}), A = once$1(A || noop$1);
  var W = L.readable || L.readable !== !1 && C.readable, X = L.writable || L.writable !== !1 && C.writable, J = function() {
    C.writable || oe();
  }, te = C._writableState && C._writableState.finished, oe = function() {
    X = !1, te = !0, W || A.call(C);
  }, ne = C._readableState && C._readableState.endEmitted, re = function() {
    W = !1, ne = !0, X || A.call(C);
  }, ce = function(pe) {
    A.call(C, pe);
  }, ue = function() {
    var pe;
    if (W && !ne)
      return (!C._readableState || !C._readableState.ended) && (pe = new ERR_STREAM_PREMATURE_CLOSE()), A.call(C, pe);
    if (X && !te)
      return (!C._writableState || !C._writableState.ended) && (pe = new ERR_STREAM_PREMATURE_CLOSE()), A.call(C, pe);
  }, de = function() {
    C.req.on("finish", oe);
  };
  return isRequest$1(C) ? (C.on("complete", oe), C.on("abort", ue), C.req ? de() : C.on("request", de)) : X && !C._writableState && (C.on("end", J), C.on("close", J)), C.on("end", re), C.on("finish", oe), L.error !== !1 && C.on("error", ce), C.on("close", ue), function() {
    C.removeListener("complete", oe), C.removeListener("abort", ue), C.removeListener("request", de), C.req && C.req.removeListener("finish", oe), C.removeListener("end", J), C.removeListener("close", J), C.removeListener("finish", oe), C.removeListener("end", re), C.removeListener("error", ce), C.removeListener("close", ue);
  };
}
var endOfStream = eos$1, async_iterator, hasRequiredAsync_iterator;
function requireAsync_iterator() {
  if (hasRequiredAsync_iterator) return async_iterator;
  hasRequiredAsync_iterator = 1;
  var C;
  function L(Ce, Se, Ae) {
    return Se = A(Se), Se in Ce ? Object.defineProperty(Ce, Se, { value: Ae, enumerable: !0, configurable: !0, writable: !0 }) : Ce[Se] = Ae, Ce;
  }
  function A(Ce) {
    var Se = W(Ce, "string");
    return typeof Se == "symbol" ? Se : String(Se);
  }
  function W(Ce, Se) {
    if (typeof Ce != "object" || Ce === null) return Ce;
    var Ae = Ce[Symbol.toPrimitive];
    if (Ae !== void 0) {
      var Le = Ae.call(Ce, Se || "default");
      if (typeof Le != "object") return Le;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (Se === "string" ? String : Number)(Ce);
  }
  var X = endOfStream, J = Symbol("lastResolve"), te = Symbol("lastReject"), oe = Symbol("error"), ne = Symbol("ended"), re = Symbol("lastPromise"), ce = Symbol("handlePromise"), ue = Symbol("stream");
  function de(Ce, Se) {
    return {
      value: Ce,
      done: Se
    };
  }
  function be(Ce) {
    var Se = Ce[J];
    if (Se !== null) {
      var Ae = Ce[ue].read();
      Ae !== null && (Ce[re] = null, Ce[J] = null, Ce[te] = null, Se(de(Ae, !1)));
    }
  }
  function pe(Ce) {
    process$1.nextTick(be, Ce);
  }
  function me(Ce, Se) {
    return function(Ae, Le) {
      Ce.then(function() {
        if (Se[ne]) {
          Ae(de(void 0, !0));
          return;
        }
        Se[ce](Ae, Le);
      }, Le);
    };
  }
  var Me = Object.getPrototypeOf(function() {
  }), he = Object.setPrototypeOf((C = {
    get stream() {
      return this[ue];
    },
    next: function() {
      var Se = this, Ae = this[oe];
      if (Ae !== null)
        return Promise.reject(Ae);
      if (this[ne])
        return Promise.resolve(de(void 0, !0));
      if (this[ue].destroyed)
        return new Promise(function(Ue, Fe) {
          process$1.nextTick(function() {
            Se[oe] ? Fe(Se[oe]) : Ue(de(void 0, !0));
          });
        });
      var Le = this[re], ve;
      if (Le)
        ve = new Promise(me(Le, this));
      else {
        var De = this[ue].read();
        if (De !== null)
          return Promise.resolve(de(De, !1));
        ve = new Promise(this[ce]);
      }
      return this[re] = ve, ve;
    }
  }, L(C, Symbol.asyncIterator, function() {
    return this;
  }), L(C, "return", function() {
    var Se = this;
    return new Promise(function(Ae, Le) {
      Se[ue].destroy(null, function(ve) {
        if (ve) {
          Le(ve);
          return;
        }
        Ae(de(void 0, !0));
      });
    });
  }), C), Me), ge = function(Se) {
    var Ae, Le = Object.create(he, (Ae = {}, L(Ae, ue, {
      value: Se,
      writable: !0
    }), L(Ae, J, {
      value: null,
      writable: !0
    }), L(Ae, te, {
      value: null,
      writable: !0
    }), L(Ae, oe, {
      value: null,
      writable: !0
    }), L(Ae, ne, {
      value: Se._readableState.endEmitted,
      writable: !0
    }), L(Ae, ce, {
      value: function(De, Ue) {
        var Fe = Le[ue].read();
        Fe ? (Le[re] = null, Le[J] = null, Le[te] = null, De(de(Fe, !1))) : (Le[J] = De, Le[te] = Ue);
      },
      writable: !0
    }), Ae));
    return Le[re] = null, X(Se, function(ve) {
      if (ve && ve.code !== "ERR_STREAM_PREMATURE_CLOSE") {
        var De = Le[te];
        De !== null && (Le[re] = null, Le[J] = null, Le[te] = null, De(ve)), Le[oe] = ve;
        return;
      }
      var Ue = Le[J];
      Ue !== null && (Le[re] = null, Le[J] = null, Le[te] = null, Ue(de(void 0, !0))), Le[ne] = !0;
    }), Se.on("readable", pe.bind(null, Le)), Le;
  };
  return async_iterator = ge, async_iterator;
}
var fromBrowser, hasRequiredFromBrowser;
function requireFromBrowser() {
  return hasRequiredFromBrowser || (hasRequiredFromBrowser = 1, fromBrowser = function() {
    throw new Error("Readable.from is not available in the browser");
  }), fromBrowser;
}
var _stream_readable, hasRequired_stream_readable;
function require_stream_readable() {
  if (hasRequired_stream_readable) return _stream_readable;
  hasRequired_stream_readable = 1, _stream_readable = Ue;
  var C;
  Ue.ReadableState = De, eventsExports.EventEmitter;
  var L = function(Ie, Xe) {
    return Ie.listeners(Xe).length;
  }, A = streamBrowser, W = require$$2.Buffer, X = (typeof commonjsGlobal < "u" ? commonjsGlobal : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function J(Ne) {
    return W.from(Ne);
  }
  function te(Ne) {
    return W.isBuffer(Ne) || Ne instanceof X;
  }
  var oe = util, ne;
  oe && oe.debuglog ? ne = oe.debuglog("stream") : ne = function() {
  };
  var re = requireBuffer_list(), ce = destroy_1, ue = state, de = ue.getHighWaterMark, be = errorsBrowser.codes, pe = be.ERR_INVALID_ARG_TYPE, me = be.ERR_STREAM_PUSH_AFTER_EOF, Me = be.ERR_METHOD_NOT_IMPLEMENTED, he = be.ERR_STREAM_UNSHIFT_AFTER_END_EVENT, ge, Ce, Se;
  inherits_browserExports(Ue, A);
  var Ae = ce.errorOrDestroy, Le = ["error", "close", "destroy", "pause", "resume"];
  function ve(Ne, Ie, Xe) {
    if (typeof Ne.prependListener == "function") return Ne.prependListener(Ie, Xe);
    !Ne._events || !Ne._events[Ie] ? Ne.on(Ie, Xe) : Array.isArray(Ne._events[Ie]) ? Ne._events[Ie].unshift(Xe) : Ne._events[Ie] = [Xe, Ne._events[Ie]];
  }
  function De(Ne, Ie, Xe) {
    C = C || require_stream_duplex(), Ne = Ne || {}, typeof Xe != "boolean" && (Xe = Ie instanceof C), this.objectMode = !!Ne.objectMode, Xe && (this.objectMode = this.objectMode || !!Ne.readableObjectMode), this.highWaterMark = de(this, Ne, "readableHighWaterMark", Xe), this.buffer = new re(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.paused = !0, this.emitClose = Ne.emitClose !== !1, this.autoDestroy = !!Ne.autoDestroy, this.destroyed = !1, this.defaultEncoding = Ne.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, Ne.encoding && (ge || (ge = requireString_decoder().StringDecoder), this.decoder = new ge(Ne.encoding), this.encoding = Ne.encoding);
  }
  function Ue(Ne) {
    if (C = C || require_stream_duplex(), !(this instanceof Ue)) return new Ue(Ne);
    var Ie = this instanceof C;
    this._readableState = new De(Ne, this, Ie), this.readable = !0, Ne && (typeof Ne.read == "function" && (this._read = Ne.read), typeof Ne.destroy == "function" && (this._destroy = Ne.destroy)), A.call(this);
  }
  Object.defineProperty(Ue.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState === void 0 ? !1 : this._readableState.destroyed;
    },
    set: function(Ie) {
      this._readableState && (this._readableState.destroyed = Ie);
    }
  }), Ue.prototype.destroy = ce.destroy, Ue.prototype._undestroy = ce.undestroy, Ue.prototype._destroy = function(Ne, Ie) {
    Ie(Ne);
  }, Ue.prototype.push = function(Ne, Ie) {
    var Xe = this._readableState, ft;
    return Xe.objectMode ? ft = !0 : typeof Ne == "string" && (Ie = Ie || Xe.defaultEncoding, Ie !== Xe.encoding && (Ne = W.from(Ne, Ie), Ie = ""), ft = !0), Fe(this, Ne, Ie, !1, ft);
  }, Ue.prototype.unshift = function(Ne) {
    return Fe(this, Ne, null, !0, !1);
  };
  function Fe(Ne, Ie, Xe, ft, It) {
    ne("readableAddChunk", Ie);
    var jt = Ne._readableState;
    if (Ie === null)
      jt.reading = !1, Ct(Ne, jt);
    else {
      var Ot;
      if (It || (Ot = Ke(jt, Ie)), Ot)
        Ae(Ne, Ot);
      else if (jt.objectMode || Ie && Ie.length > 0)
        if (typeof Ie != "string" && !jt.objectMode && Object.getPrototypeOf(Ie) !== W.prototype && (Ie = J(Ie)), ft)
          jt.endEmitted ? Ae(Ne, new he()) : We(Ne, jt, Ie, !0);
        else if (jt.ended)
          Ae(Ne, new me());
        else {
          if (jt.destroyed)
            return !1;
          jt.reading = !1, jt.decoder && !Xe ? (Ie = jt.decoder.write(Ie), jt.objectMode || Ie.length !== 0 ? We(Ne, jt, Ie, !1) : Je(Ne, jt)) : We(Ne, jt, Ie, !1);
        }
      else ft || (jt.reading = !1, Je(Ne, jt));
    }
    return !jt.ended && (jt.length < jt.highWaterMark || jt.length === 0);
  }
  function We(Ne, Ie, Xe, ft) {
    Ie.flowing && Ie.length === 0 && !Ie.sync ? (Ie.awaitDrain = 0, Ne.emit("data", Xe)) : (Ie.length += Ie.objectMode ? 1 : Xe.length, ft ? Ie.buffer.unshift(Xe) : Ie.buffer.push(Xe), Ie.needReadable && Tt(Ne)), Je(Ne, Ie);
  }
  function Ke(Ne, Ie) {
    var Xe;
    return !te(Ie) && typeof Ie != "string" && Ie !== void 0 && !Ne.objectMode && (Xe = new pe("chunk", ["string", "Buffer", "Uint8Array"], Ie)), Xe;
  }
  Ue.prototype.isPaused = function() {
    return this._readableState.flowing === !1;
  }, Ue.prototype.setEncoding = function(Ne) {
    ge || (ge = requireString_decoder().StringDecoder);
    var Ie = new ge(Ne);
    this._readableState.decoder = Ie, this._readableState.encoding = this._readableState.decoder.encoding;
    for (var Xe = this._readableState.buffer.head, ft = ""; Xe !== null; )
      ft += Ie.write(Xe.data), Xe = Xe.next;
    return this._readableState.buffer.clear(), ft !== "" && this._readableState.buffer.push(ft), this._readableState.length = ft.length, this;
  };
  var it = 1073741824;
  function Qe(Ne) {
    return Ne >= it ? Ne = it : (Ne--, Ne |= Ne >>> 1, Ne |= Ne >>> 2, Ne |= Ne >>> 4, Ne |= Ne >>> 8, Ne |= Ne >>> 16, Ne++), Ne;
  }
  function vt(Ne, Ie) {
    return Ne <= 0 || Ie.length === 0 && Ie.ended ? 0 : Ie.objectMode ? 1 : Ne !== Ne ? Ie.flowing && Ie.length ? Ie.buffer.head.data.length : Ie.length : (Ne > Ie.highWaterMark && (Ie.highWaterMark = Qe(Ne)), Ne <= Ie.length ? Ne : Ie.ended ? Ie.length : (Ie.needReadable = !0, 0));
  }
  Ue.prototype.read = function(Ne) {
    ne("read", Ne), Ne = parseInt(Ne, 10);
    var Ie = this._readableState, Xe = Ne;
    if (Ne !== 0 && (Ie.emittedReadable = !1), Ne === 0 && Ie.needReadable && ((Ie.highWaterMark !== 0 ? Ie.length >= Ie.highWaterMark : Ie.length > 0) || Ie.ended))
      return ne("read: emitReadable", Ie.length, Ie.ended), Ie.length === 0 && Ie.ended ? fe(this) : Tt(this), null;
    if (Ne = vt(Ne, Ie), Ne === 0 && Ie.ended)
      return Ie.length === 0 && fe(this), null;
    var ft = Ie.needReadable;
    ne("need readable", ft), (Ie.length === 0 || Ie.length - Ne < Ie.highWaterMark) && (ft = !0, ne("length less than watermark", ft)), Ie.ended || Ie.reading ? (ft = !1, ne("reading or ended", ft)) : ft && (ne("do read"), Ie.reading = !0, Ie.sync = !0, Ie.length === 0 && (Ie.needReadable = !0), this._read(Ie.highWaterMark), Ie.sync = !1, Ie.reading || (Ne = vt(Xe, Ie)));
    var It;
    return Ne > 0 ? It = Ve(Ne, Ie) : It = null, It === null ? (Ie.needReadable = Ie.length <= Ie.highWaterMark, Ne = 0) : (Ie.length -= Ne, Ie.awaitDrain = 0), Ie.length === 0 && (Ie.ended || (Ie.needReadable = !0), Xe !== Ne && Ie.ended && fe(this)), It !== null && this.emit("data", It), It;
  };
  function Ct(Ne, Ie) {
    if (ne("onEofChunk"), !Ie.ended) {
      if (Ie.decoder) {
        var Xe = Ie.decoder.end();
        Xe && Xe.length && (Ie.buffer.push(Xe), Ie.length += Ie.objectMode ? 1 : Xe.length);
      }
      Ie.ended = !0, Ie.sync ? Tt(Ne) : (Ie.needReadable = !1, Ie.emittedReadable || (Ie.emittedReadable = !0, St(Ne)));
    }
  }
  function Tt(Ne) {
    var Ie = Ne._readableState;
    ne("emitReadable", Ie.needReadable, Ie.emittedReadable), Ie.needReadable = !1, Ie.emittedReadable || (ne("emitReadable", Ie.flowing), Ie.emittedReadable = !0, process$1.nextTick(St, Ne));
  }
  function St(Ne) {
    var Ie = Ne._readableState;
    ne("emitReadable_", Ie.destroyed, Ie.length, Ie.ended), !Ie.destroyed && (Ie.length || Ie.ended) && (Ne.emit("readable"), Ie.emittedReadable = !1), Ie.needReadable = !Ie.flowing && !Ie.ended && Ie.length <= Ie.highWaterMark, Be(Ne);
  }
  function Je(Ne, Ie) {
    Ie.readingMore || (Ie.readingMore = !0, process$1.nextTick(He, Ne, Ie));
  }
  function He(Ne, Ie) {
    for (; !Ie.reading && !Ie.ended && (Ie.length < Ie.highWaterMark || Ie.flowing && Ie.length === 0); ) {
      var Xe = Ie.length;
      if (ne("maybeReadMore read 0"), Ne.read(0), Xe === Ie.length)
        break;
    }
    Ie.readingMore = !1;
  }
  Ue.prototype._read = function(Ne) {
    Ae(this, new Me("_read()"));
  }, Ue.prototype.pipe = function(Ne, Ie) {
    var Xe = this, ft = this._readableState;
    switch (ft.pipesCount) {
      case 0:
        ft.pipes = Ne;
        break;
      case 1:
        ft.pipes = [ft.pipes, Ne];
        break;
      default:
        ft.pipes.push(Ne);
        break;
    }
    ft.pipesCount += 1, ne("pipe count=%d opts=%j", ft.pipesCount, Ie);
    var It = (!Ie || Ie.end !== !1) && Ne !== process$1.stdout && Ne !== process$1.stderr, jt = It ? Ut : Dt;
    ft.endEmitted ? process$1.nextTick(jt) : Xe.once("end", jt), Ne.on("unpipe", Ot);
    function Ot(Pt, zt) {
      ne("onunpipe"), Pt === Xe && zt && zt.hasUnpiped === !1 && (zt.hasUnpiped = !0, tr());
    }
    function Ut() {
      ne("onend"), Ne.end();
    }
    var kt = qe(Xe);
    Ne.on("drain", kt);
    var Xt = !1;
    function tr() {
      ne("cleanup"), Ne.removeListener("close", Lt), Ne.removeListener("finish", Et), Ne.removeListener("drain", kt), Ne.removeListener("error", xt), Ne.removeListener("unpipe", Ot), Xe.removeListener("end", Ut), Xe.removeListener("end", Dt), Xe.removeListener("data", Wt), Xt = !0, ft.awaitDrain && (!Ne._writableState || Ne._writableState.needDrain) && kt();
    }
    Xe.on("data", Wt);
    function Wt(Pt) {
      ne("ondata");
      var zt = Ne.write(Pt);
      ne("dest.write", zt), zt === !1 && ((ft.pipesCount === 1 && ft.pipes === Ne || ft.pipesCount > 1 && je(ft.pipes, Ne) !== -1) && !Xt && (ne("false write response, pause", ft.awaitDrain), ft.awaitDrain++), Xe.pause());
    }
    function xt(Pt) {
      ne("onerror", Pt), Dt(), Ne.removeListener("error", xt), L(Ne, "error") === 0 && Ae(Ne, Pt);
    }
    ve(Ne, "error", xt);
    function Lt() {
      Ne.removeListener("finish", Et), Dt();
    }
    Ne.once("close", Lt);
    function Et() {
      ne("onfinish"), Ne.removeListener("close", Lt), Dt();
    }
    Ne.once("finish", Et);
    function Dt() {
      ne("unpipe"), Xe.unpipe(Ne);
    }
    return Ne.emit("pipe", Xe), ft.flowing || (ne("pipe resume"), Xe.resume()), Ne;
  };
  function qe(Ne) {
    return function() {
      var Xe = Ne._readableState;
      ne("pipeOnDrain", Xe.awaitDrain), Xe.awaitDrain && Xe.awaitDrain--, Xe.awaitDrain === 0 && L(Ne, "data") && (Xe.flowing = !0, Be(Ne));
    };
  }
  Ue.prototype.unpipe = function(Ne) {
    var Ie = this._readableState, Xe = {
      hasUnpiped: !1
    };
    if (Ie.pipesCount === 0) return this;
    if (Ie.pipesCount === 1)
      return Ne && Ne !== Ie.pipes ? this : (Ne || (Ne = Ie.pipes), Ie.pipes = null, Ie.pipesCount = 0, Ie.flowing = !1, Ne && Ne.emit("unpipe", this, Xe), this);
    if (!Ne) {
      var ft = Ie.pipes, It = Ie.pipesCount;
      Ie.pipes = null, Ie.pipesCount = 0, Ie.flowing = !1;
      for (var jt = 0; jt < It; jt++) ft[jt].emit("unpipe", this, {
        hasUnpiped: !1
      });
      return this;
    }
    var Ot = je(Ie.pipes, Ne);
    return Ot === -1 ? this : (Ie.pipes.splice(Ot, 1), Ie.pipesCount -= 1, Ie.pipesCount === 1 && (Ie.pipes = Ie.pipes[0]), Ne.emit("unpipe", this, Xe), this);
  }, Ue.prototype.on = function(Ne, Ie) {
    var Xe = A.prototype.on.call(this, Ne, Ie), ft = this._readableState;
    return Ne === "data" ? (ft.readableListening = this.listenerCount("readable") > 0, ft.flowing !== !1 && this.resume()) : Ne === "readable" && !ft.endEmitted && !ft.readableListening && (ft.readableListening = ft.needReadable = !0, ft.flowing = !1, ft.emittedReadable = !1, ne("on readable", ft.length, ft.reading), ft.length ? Tt(this) : ft.reading || process$1.nextTick(Pe, this)), Xe;
  }, Ue.prototype.addListener = Ue.prototype.on, Ue.prototype.removeListener = function(Ne, Ie) {
    var Xe = A.prototype.removeListener.call(this, Ne, Ie);
    return Ne === "readable" && process$1.nextTick(Ze, this), Xe;
  }, Ue.prototype.removeAllListeners = function(Ne) {
    var Ie = A.prototype.removeAllListeners.apply(this, arguments);
    return (Ne === "readable" || Ne === void 0) && process$1.nextTick(Ze, this), Ie;
  };
  function Ze(Ne) {
    var Ie = Ne._readableState;
    Ie.readableListening = Ne.listenerCount("readable") > 0, Ie.resumeScheduled && !Ie.paused ? Ie.flowing = !0 : Ne.listenerCount("data") > 0 && Ne.resume();
  }
  function Pe(Ne) {
    ne("readable nexttick read 0"), Ne.read(0);
  }
  Ue.prototype.resume = function() {
    var Ne = this._readableState;
    return Ne.flowing || (ne("resume"), Ne.flowing = !Ne.readableListening, Ye(this, Ne)), Ne.paused = !1, this;
  };
  function Ye(Ne, Ie) {
    Ie.resumeScheduled || (Ie.resumeScheduled = !0, process$1.nextTick(ot, Ne, Ie));
  }
  function ot(Ne, Ie) {
    ne("resume", Ie.reading), Ie.reading || Ne.read(0), Ie.resumeScheduled = !1, Ne.emit("resume"), Be(Ne), Ie.flowing && !Ie.reading && Ne.read(0);
  }
  Ue.prototype.pause = function() {
    return ne("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1 && (ne("pause"), this._readableState.flowing = !1, this.emit("pause")), this._readableState.paused = !0, this;
  };
  function Be(Ne) {
    var Ie = Ne._readableState;
    for (ne("flow", Ie.flowing); Ie.flowing && Ne.read() !== null; ) ;
  }
  Ue.prototype.wrap = function(Ne) {
    var Ie = this, Xe = this._readableState, ft = !1;
    Ne.on("end", function() {
      if (ne("wrapped end"), Xe.decoder && !Xe.ended) {
        var Ot = Xe.decoder.end();
        Ot && Ot.length && Ie.push(Ot);
      }
      Ie.push(null);
    }), Ne.on("data", function(Ot) {
      if (ne("wrapped data"), Xe.decoder && (Ot = Xe.decoder.write(Ot)), !(Xe.objectMode && Ot == null) && !(!Xe.objectMode && (!Ot || !Ot.length))) {
        var Ut = Ie.push(Ot);
        Ut || (ft = !0, Ne.pause());
      }
    });
    for (var It in Ne)
      this[It] === void 0 && typeof Ne[It] == "function" && (this[It] = /* @__PURE__ */ function(Ut) {
        return function() {
          return Ne[Ut].apply(Ne, arguments);
        };
      }(It));
    for (var jt = 0; jt < Le.length; jt++)
      Ne.on(Le[jt], this.emit.bind(this, Le[jt]));
    return this._read = function(Ot) {
      ne("wrapped _read", Ot), ft && (ft = !1, Ne.resume());
    }, this;
  }, typeof Symbol == "function" && (Ue.prototype[Symbol.asyncIterator] = function() {
    return Ce === void 0 && (Ce = requireAsync_iterator()), Ce(this);
  }), Object.defineProperty(Ue.prototype, "readableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.highWaterMark;
    }
  }), Object.defineProperty(Ue.prototype, "readableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState && this._readableState.buffer;
    }
  }), Object.defineProperty(Ue.prototype, "readableFlowing", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.flowing;
    },
    set: function(Ie) {
      this._readableState && (this._readableState.flowing = Ie);
    }
  }), Ue._fromList = Ve, Object.defineProperty(Ue.prototype, "readableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.length;
    }
  });
  function Ve(Ne, Ie) {
    if (Ie.length === 0) return null;
    var Xe;
    return Ie.objectMode ? Xe = Ie.buffer.shift() : !Ne || Ne >= Ie.length ? (Ie.decoder ? Xe = Ie.buffer.join("") : Ie.buffer.length === 1 ? Xe = Ie.buffer.first() : Xe = Ie.buffer.concat(Ie.length), Ie.buffer.clear()) : Xe = Ie.buffer.consume(Ne, Ie.decoder), Xe;
  }
  function fe(Ne) {
    var Ie = Ne._readableState;
    ne("endReadable", Ie.endEmitted), Ie.endEmitted || (Ie.ended = !0, process$1.nextTick(_e, Ie, Ne));
  }
  function _e(Ne, Ie) {
    if (ne("endReadableNT", Ne.endEmitted, Ne.length), !Ne.endEmitted && Ne.length === 0 && (Ne.endEmitted = !0, Ie.readable = !1, Ie.emit("end"), Ne.autoDestroy)) {
      var Xe = Ie._writableState;
      (!Xe || Xe.autoDestroy && Xe.finished) && Ie.destroy();
    }
  }
  typeof Symbol == "function" && (Ue.from = function(Ne, Ie) {
    return Se === void 0 && (Se = requireFromBrowser()), Se(Ue, Ne, Ie);
  });
  function je(Ne, Ie) {
    for (var Xe = 0, ft = Ne.length; Xe < ft; Xe++)
      if (Ne[Xe] === Ie) return Xe;
    return -1;
  }
  return _stream_readable;
}
var _stream_transform = Transform$1, _require$codes$1 = errorsBrowser.codes, ERR_METHOD_NOT_IMPLEMENTED = _require$codes$1.ERR_METHOD_NOT_IMPLEMENTED, ERR_MULTIPLE_CALLBACK = _require$codes$1.ERR_MULTIPLE_CALLBACK, ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes$1.ERR_TRANSFORM_ALREADY_TRANSFORMING, ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes$1.ERR_TRANSFORM_WITH_LENGTH_0, Duplex = require_stream_duplex();
inherits_browserExports(Transform$1, Duplex);
function afterTransform(C, L) {
  var A = this._transformState;
  A.transforming = !1;
  var W = A.writecb;
  if (W === null)
    return this.emit("error", new ERR_MULTIPLE_CALLBACK());
  A.writechunk = null, A.writecb = null, L != null && this.push(L), W(C);
  var X = this._readableState;
  X.reading = !1, (X.needReadable || X.length < X.highWaterMark) && this._read(X.highWaterMark);
}
function Transform$1(C) {
  if (!(this instanceof Transform$1)) return new Transform$1(C);
  Duplex.call(this, C), this._transformState = {
    afterTransform: afterTransform.bind(this),
    needTransform: !1,
    transforming: !1,
    writecb: null,
    writechunk: null,
    writeencoding: null
  }, this._readableState.needReadable = !0, this._readableState.sync = !1, C && (typeof C.transform == "function" && (this._transform = C.transform), typeof C.flush == "function" && (this._flush = C.flush)), this.on("prefinish", prefinish);
}
function prefinish() {
  var C = this;
  typeof this._flush == "function" && !this._readableState.destroyed ? this._flush(function(L, A) {
    done(C, L, A);
  }) : done(this, null, null);
}
Transform$1.prototype.push = function(C, L) {
  return this._transformState.needTransform = !1, Duplex.prototype.push.call(this, C, L);
};
Transform$1.prototype._transform = function(C, L, A) {
  A(new ERR_METHOD_NOT_IMPLEMENTED("_transform()"));
};
Transform$1.prototype._write = function(C, L, A) {
  var W = this._transformState;
  if (W.writecb = A, W.writechunk = C, W.writeencoding = L, !W.transforming) {
    var X = this._readableState;
    (W.needTransform || X.needReadable || X.length < X.highWaterMark) && this._read(X.highWaterMark);
  }
};
Transform$1.prototype._read = function(C) {
  var L = this._transformState;
  L.writechunk !== null && !L.transforming ? (L.transforming = !0, this._transform(L.writechunk, L.writeencoding, L.afterTransform)) : L.needTransform = !0;
};
Transform$1.prototype._destroy = function(C, L) {
  Duplex.prototype._destroy.call(this, C, function(A) {
    L(A);
  });
};
function done(C, L, A) {
  if (L) return C.emit("error", L);
  if (A != null && C.push(A), C._writableState.length) throw new ERR_TRANSFORM_WITH_LENGTH_0();
  if (C._transformState.transforming) throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
  return C.push(null);
}
var _stream_passthrough = PassThrough, Transform = _stream_transform;
inherits_browserExports(PassThrough, Transform);
function PassThrough(C) {
  if (!(this instanceof PassThrough)) return new PassThrough(C);
  Transform.call(this, C);
}
PassThrough.prototype._transform = function(C, L, A) {
  A(null, C);
};
var eos;
function once(C) {
  var L = !1;
  return function() {
    L || (L = !0, C.apply(void 0, arguments));
  };
}
var _require$codes = errorsBrowser.codes, ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS, ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
function noop(C) {
  if (C) throw C;
}
function isRequest(C) {
  return C.setHeader && typeof C.abort == "function";
}
function destroyer(C, L, A, W) {
  W = once(W);
  var X = !1;
  C.on("close", function() {
    X = !0;
  }), eos === void 0 && (eos = endOfStream), eos(C, {
    readable: L,
    writable: A
  }, function(te) {
    if (te) return W(te);
    X = !0, W();
  });
  var J = !1;
  return function(te) {
    if (!X && !J) {
      if (J = !0, isRequest(C)) return C.abort();
      if (typeof C.destroy == "function") return C.destroy();
      W(te || new ERR_STREAM_DESTROYED("pipe"));
    }
  };
}
function call(C) {
  C();
}
function pipe(C, L) {
  return C.pipe(L);
}
function popCallback(C) {
  return !C.length || typeof C[C.length - 1] != "function" ? noop : C.pop();
}
function pipeline() {
  for (var C = arguments.length, L = new Array(C), A = 0; A < C; A++)
    L[A] = arguments[A];
  var W = popCallback(L);
  if (Array.isArray(L[0]) && (L = L[0]), L.length < 2)
    throw new ERR_MISSING_ARGS("streams");
  var X, J = L.map(function(te, oe) {
    var ne = oe < L.length - 1, re = oe > 0;
    return destroyer(te, ne, re, function(ce) {
      X || (X = ce), ce && J.forEach(call), !ne && (J.forEach(call), W(X));
    });
  });
  return L.reduce(pipe);
}
var pipeline_1 = pipeline;
(function(C, L) {
  L = C.exports = require_stream_readable(), L.Stream = L, L.Readable = L, L.Writable = require_stream_writable(), L.Duplex = require_stream_duplex(), L.Transform = _stream_transform, L.PassThrough = _stream_passthrough, L.finished = endOfStream, L.pipeline = pipeline_1;
})(readableBrowser, readableBrowser.exports);
var readableBrowserExports = readableBrowser.exports;
Object.defineProperty(lib, "__esModule", { value: !0 });
lib.ReadableWebToNodeStream = void 0;
const readable_stream_1 = readableBrowserExports;
class ReadableWebToNodeStream extends readable_stream_1.Readable {
  /**
   *
   * @param stream Readable​Stream: https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream
   */
  constructor(L) {
    super(), this.bytesRead = 0, this.released = !1, this.reader = L.getReader();
  }
  /**
   * Implementation of readable._read(size).
   * When readable._read() is called, if data is available from the resource,
   * the implementation should begin pushing that data into the read queue
   * https://nodejs.org/api/stream.html#stream_readable_read_size_1
   */
  async _read() {
    if (this.released) {
      this.push(null);
      return;
    }
    this.pendingRead = this.reader.read();
    const L = await this.pendingRead;
    delete this.pendingRead, L.done || this.released ? this.push(null) : (this.bytesRead += L.value.length, this.push(L.value));
  }
  /**
   * If there is no unresolved read call to Web-API Readable​Stream immediately returns;
   * otherwise will wait until the read is resolved.
   */
  async waitForReadToComplete() {
    this.pendingRead && await this.pendingRead;
  }
  /**
   * Close wrapper
   */
  async close() {
    await this.syncAndRelease();
  }
  async syncAndRelease() {
    this.released = !0, await this.waitForReadToComplete(), await this.reader.releaseLock();
  }
}
lib.ReadableWebToNodeStream = ReadableWebToNodeStream;
(function(C) {
  Object.defineProperty(C, "__esModule", { value: !0 }), C.fetchFromUrl = C.parseBlob = C.parseReadableStream = C.parseNodeStream = C.selectCover = C.ratingToStars = C.orderTags = C.parseFromTokenizer = C.parseBuffer = void 0;
  const L = browserExports, A = core$2, W = lib, X = L("music-metadata-browser:main");
  var J = core$2;
  Object.defineProperty(C, "parseBuffer", { enumerable: !0, get: function() {
    return J.parseBuffer;
  } }), Object.defineProperty(C, "parseFromTokenizer", { enumerable: !0, get: function() {
    return J.parseFromTokenizer;
  } }), Object.defineProperty(C, "orderTags", { enumerable: !0, get: function() {
    return J.orderTags;
  } }), Object.defineProperty(C, "ratingToStars", { enumerable: !0, get: function() {
    return J.ratingToStars;
  } }), Object.defineProperty(C, "selectCover", { enumerable: !0, get: function() {
    return J.selectCover;
  } }), C.parseNodeStream = A.parseStream;
  async function te(ce, ue, de) {
    const be = new W.ReadableWebToNodeStream(ce), pe = await (0, C.parseNodeStream)(be, typeof ue == "string" ? { mimeType: ue } : ue, de);
    return await be.close(), pe;
  }
  C.parseReadableStream = te;
  async function oe(ce, ue) {
    ce.type, ce.size, ce instanceof File && ce.name;
    const de = ce.stream ? ce.stream() : ne(ce);
    return te(de, { mimeType: ce.type, size: ce.size }, ue);
  }
  C.parseBlob = oe;
  function ne(ce) {
    const ue = new FileReader();
    return new ReadableStream({
      start(de) {
        ue.onloadend = (be) => {
          let pe = be.target.result;
          pe instanceof ArrayBuffer && (pe = new Uint8Array(pe)), de.enqueue(pe), de.close();
        }, ue.onerror = (be) => {
          de.close();
        }, ue.onabort = (be) => {
          de.close();
        }, ue.readAsArrayBuffer(ce);
      }
    });
  }
  async function re(ce, ue) {
    const de = await fetch(ce), be = {
      size: parseInt(de.headers.get("Content-Length"), 10),
      mimeType: de.headers.get("Content-Type")
    };
    if (de.ok)
      if (de.body) {
        const pe = await te(de.body, be, ue);
        return X("Closing HTTP-readable-stream..."), de.body.locked || await de.body.cancel(), X("HTTP-readable-stream closed."), pe;
      } else
        return oe(await de.blob(), ue);
    else
      throw new Error(`HTTP error status=${de.status}: ${de.statusText}`);
  }
  C.fetchFromUrl = re;
})(lib$3);
const BufferBuilderProcessor = "" + new URL("assets/buffer-builder-processor-BhnxGUx8.js", import.meta.url).href, encodedJs = "dmFyIGEyPXo9Pnt0aHJvdyBUeXBlRXJyb3Ioeil9O3ZhciBmMj0oeixOLFcpPT5OLmhhcyh6KXx8YTIoIkNhbm5vdCAiK1cpO3ZhciBsMj0oeixOLFcpPT4oZjIoeixOLCJyZWFkIGZyb20gcHJpdmF0ZSBmaWVsZCIpLFc/Vy5jYWxsKHopOk4uZ2V0KHopKSx1Mj0oeixOLFcpPT5OLmhhcyh6KT9hMigiQ2Fubm90IGFkZCB0aGUgc2FtZSBwcml2YXRlIG1lbWJlciBtb3JlIHRoYW4gb25jZSIpOk4gaW5zdGFuY2VvZiBXZWFrU2V0P04uYWRkKHopOk4uc2V0KHosVyksaDI9KHosTixXLFMpPT4oZjIoeixOLCJ3cml0ZSB0byBwcml2YXRlIGZpZWxkIiksUz9TLmNhbGwoeixXKTpOLnNldCh6LFcpLFcpOyhmdW5jdGlvbigpeyJ1c2Ugc3RyaWN0Ijt2YXIgXzA7dmFyIHo9KGUsdD0wLG49MSk9PkUwKE4wKHQsZSksbiksTj1lPT57ZS5fY2xpcHBlZD0hMSxlLl91bmNsaXBwZWQ9ZS5zbGljZSgwKTtmb3IobGV0IHQ9MDt0PD0zO3QrKyl0PDM/KChlW3RdPDB8fGVbdF0+MjU1KSYmKGUuX2NsaXBwZWQ9ITApLGVbdF09eihlW3RdLDAsMjU1KSk6dD09PTMmJihlW3RdPXooZVt0XSwwLDEpKTtyZXR1cm4gZX07Y29uc3QgVz17fTtmb3IobGV0IGUgb2ZbIkJvb2xlYW4iLCJOdW1iZXIiLCJTdHJpbmciLCJGdW5jdGlvbiIsIkFycmF5IiwiRGF0ZSIsIlJlZ0V4cCIsIlVuZGVmaW5lZCIsIk51bGwiXSlXW2Bbb2JqZWN0ICR7ZX1dYF09ZS50b0xvd2VyQ2FzZSgpO2Z1bmN0aW9uIFMoZSl7cmV0dXJuIFdbT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGUpXXx8Im9iamVjdCJ9dmFyIEk9KGUsdD1udWxsKT0+ZS5sZW5ndGg+PTM/QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZSk6UyhlWzBdKT09Im9iamVjdCImJnQ/dC5zcGxpdCgiIikuZmlsdGVyKG49PmVbMF1bbl0hPT12b2lkIDApLm1hcChuPT5lWzBdW25dKTplWzBdLFIwPWU9PntpZihlLmxlbmd0aDwyKXJldHVybiBudWxsO2NvbnN0IHQ9ZS5sZW5ndGgtMTtyZXR1cm4gUyhlW3RdKT09InN0cmluZyI/ZVt0XS50b0xvd2VyQ2FzZSgpOm51bGx9O2NvbnN0e1BJOlMwLG1pbjpFMCxtYXg6TjB9PU1hdGgsVj1TMCoyLEwwPVMwLzMsYjI9UzAvMTgwLGQyPTE4MC9TMDt2YXIgUj17Zm9ybWF0Ont9LGF1dG9kZXRlY3Q6W119O2NsYXNzIGJ7Y29uc3RydWN0b3IoLi4udCl7Y29uc3Qgbj10aGlzO2lmKFModFswXSk9PT0ib2JqZWN0IiYmdFswXS5jb25zdHJ1Y3RvciYmdFswXS5jb25zdHJ1Y3Rvcj09PXRoaXMuY29uc3RydWN0b3IpcmV0dXJuIHRbMF07bGV0IHI9UjAodCkscz0hMTtpZighcil7cz0hMCxSLnNvcnRlZHx8KFIuYXV0b2RldGVjdD1SLmF1dG9kZXRlY3Quc29ydCgobyxjKT0+Yy5wLW8ucCksUi5zb3J0ZWQ9ITApO2ZvcihsZXQgbyBvZiBSLmF1dG9kZXRlY3QpaWYocj1vLnRlc3QoLi4udCkscilicmVha31pZihSLmZvcm1hdFtyXSl7Y29uc3Qgbz1SLmZvcm1hdFtyXS5hcHBseShudWxsLHM/dDp0LnNsaWNlKDAsLTEpKTtuLl9yZ2I9TihvKX1lbHNlIHRocm93IG5ldyBFcnJvcigidW5rbm93biBmb3JtYXQ6ICIrdCk7bi5fcmdiLmxlbmd0aD09PTMmJm4uX3JnYi5wdXNoKDEpfXRvU3RyaW5nKCl7cmV0dXJuIFModGhpcy5oZXgpPT0iZnVuY3Rpb24iP3RoaXMuaGV4KCk6YFske3RoaXMuX3JnYi5qb2luKCIsIil9XWB9fWNvbnN0IHAyPSIyLjYuMCIsTT0oLi4uZSk9Pm5ldyBNLkNvbG9yKC4uLmUpO00uQ29sb3I9YixNLnZlcnNpb249cDI7Y29uc3QgZzI9KC4uLmUpPT57ZT1JKGUsImNteWsiKTtjb25zdFt0LG4scixzXT1lLG89ZS5sZW5ndGg+ND9lWzRdOjE7cmV0dXJuIHM9PT0xP1swLDAsMCxvXTpbdD49MT8wOjI1NSooMS10KSooMS1zKSxuPj0xPzA6MjU1KigxLW4pKigxLXMpLHI+PTE/MDoyNTUqKDEtcikqKDEtcyksb119LHttYXg6ZDF9PU1hdGgsbTI9KC4uLmUpPT57bGV0W3QsbixyXT1JKGUsInJnYiIpO3Q9dC8yNTUsbj1uLzI1NSxyPXIvMjU1O2NvbnN0IHM9MS1kMSh0LGQxKG4scikpLG89czwxPzEvKDEtcyk6MCxjPSgxLXQtcykqbyxpPSgxLW4tcykqbyxhPSgxLXItcykqbztyZXR1cm5bYyxpLGEsc119O2IucHJvdG90eXBlLmNteWs9ZnVuY3Rpb24oKXtyZXR1cm4gbTIodGhpcy5fcmdiKX0sTS5jbXlrPSguLi5lKT0+bmV3IGIoLi4uZSwiY215ayIpLFIuZm9ybWF0LmNteWs9ZzIsUi5hdXRvZGV0ZWN0LnB1c2goe3A6Mix0ZXN0OiguLi5lKT0+e2lmKGU9SShlLCJjbXlrIiksUyhlKT09PSJhcnJheSImJmUubGVuZ3RoPT09NClyZXR1cm4iY215ayJ9fSk7Y29uc3QgRDA9ZT0+TWF0aC5yb3VuZChlKjEwMCkvMTAwLHcyPSguLi5lKT0+e2NvbnN0IHQ9SShlLCJoc2xhIik7bGV0IG49UjAoZSl8fCJsc2EiO3JldHVybiB0WzBdPUQwKHRbMF18fDApLHRbMV09RDAodFsxXSoxMDApKyIlIix0WzJdPUQwKHRbMl0qMTAwKSsiJSIsbj09PSJoc2xhInx8dC5sZW5ndGg+MyYmdFszXTwxPyh0WzNdPXQubGVuZ3RoPjM/dFszXToxLG49ImhzbGEiKTp0Lmxlbmd0aD0zLGAke259KCR7dC5qb2luKCIsIil9KWB9LHAxPSguLi5lKT0+e2U9SShlLCJyZ2JhIik7bGV0W3QsbixyXT1lO3QvPTI1NSxuLz0yNTUsci89MjU1O2NvbnN0IHM9RTAodCxuLHIpLG89TjAodCxuLHIpLGM9KG8rcykvMjtsZXQgaSxhO3JldHVybiBvPT09cz8oaT0wLGE9TnVtYmVyLk5hTik6aT1jPC41PyhvLXMpLyhvK3MpOihvLXMpLygyLW8tcyksdD09bz9hPShuLXIpLyhvLXMpOm49PW8/YT0yKyhyLXQpLyhvLXMpOnI9PW8mJihhPTQrKHQtbikvKG8tcykpLGEqPTYwLGE8MCYmKGErPTM2MCksZS5sZW5ndGg+MyYmZVszXSE9PXZvaWQgMD9bYSxpLGMsZVszXV06W2EsaSxjXX0se3JvdW5kOkcwfT1NYXRoLHkyPSguLi5lKT0+e2NvbnN0IHQ9SShlLCJyZ2JhIik7bGV0IG49UjAoZSl8fCJyZ2IiO3JldHVybiBuLnN1YnN0cigwLDMpPT0iaHNsIj93MihwMSh0KSxuKToodFswXT1HMCh0WzBdKSx0WzFdPUcwKHRbMV0pLHRbMl09RzAodFsyXSksKG49PT0icmdiYSJ8fHQubGVuZ3RoPjMmJnRbM108MSkmJih0WzNdPXQubGVuZ3RoPjM/dFszXToxLG49InJnYmEiKSxgJHtufSgke3Quc2xpY2UoMCxuPT09InJnYiI/Mzo0KS5qb2luKCIsIil9KWApfSx7cm91bmQ6cTB9PU1hdGgsVzA9KC4uLmUpPT57ZT1JKGUsImhzbCIpO2NvbnN0W3QsbixyXT1lO2xldCBzLG8sYztpZihuPT09MClzPW89Yz1yKjI1NTtlbHNle2NvbnN0IGk9WzAsMCwwXSxhPVswLDAsMF0sZj1yPC41P3IqKDErbik6cituLXIqbixsPTIqci1mLHU9dC8zNjA7aVswXT11KzEvMyxpWzFdPXUsaVsyXT11LTEvMztmb3IobGV0IGQ9MDtkPDM7ZCsrKWlbZF08MCYmKGlbZF0rPTEpLGlbZF0+MSYmKGlbZF0tPTEpLDYqaVtkXTwxP2FbZF09bCsoZi1sKSo2KmlbZF06MippW2RdPDE/YVtkXT1mOjMqaVtkXTwyP2FbZF09bCsoZi1sKSooMi8zLWlbZF0pKjY6YVtkXT1sO1tzLG8sY109W3EwKGFbMF0qMjU1KSxxMChhWzFdKjI1NSkscTAoYVsyXSoyNTUpXX1yZXR1cm4gZS5sZW5ndGg+Mz9bcyxvLGMsZVszXV06W3MsbyxjLDFdfSxnMT0vXnJnYlwoXHMqKC0/XGQrKSxccyooLT9cZCspXHMqLFxzKigtP1xkKylccypcKSQvLG0xPS9ecmdiYVwoXHMqKC0/XGQrKSxccyooLT9cZCspXHMqLFxzKigtP1xkKylccyosXHMqKFswMV18WzAxXT9cLlxkKylcKSQvLHcxPS9ecmdiXChccyooLT9cZCsoPzpcLlxkKyk/KSUsXHMqKC0/XGQrKD86XC5cZCspPyklXHMqLFxzKigtP1xkKyg/OlwuXGQrKT8pJVxzKlwpJC8seTE9L15yZ2JhXChccyooLT9cZCsoPzpcLlxkKyk/KSUsXHMqKC0/XGQrKD86XC5cZCspPyklXHMqLFxzKigtP1xkKyg/OlwuXGQrKT8pJVxzKixccyooWzAxXXxbMDFdP1wuXGQrKVwpJC8sXzE9L15oc2xcKFxzKigtP1xkKyg/OlwuXGQrKT8pLFxzKigtP1xkKyg/OlwuXGQrKT8pJVxzKixccyooLT9cZCsoPzpcLlxkKyk/KSVccypcKSQvLGsxPS9eaHNsYVwoXHMqKC0/XGQrKD86XC5cZCspPyksXHMqKC0/XGQrKD86XC5cZCspPyklXHMqLFxzKigtP1xkKyg/OlwuXGQrKT8pJVxzKixccyooWzAxXXxbMDFdP1wuXGQrKVwpJC8se3JvdW5kOk0xfT1NYXRoLGowPWU9PntlPWUudG9Mb3dlckNhc2UoKS50cmltKCk7bGV0IHQ7aWYoUi5mb3JtYXQubmFtZWQpdHJ5e3JldHVybiBSLmZvcm1hdC5uYW1lZChlKX1jYXRjaHt9aWYodD1lLm1hdGNoKGcxKSl7Y29uc3Qgbj10LnNsaWNlKDEsNCk7Zm9yKGxldCByPTA7cjwzO3IrKyluW3JdPStuW3JdO3JldHVybiBuWzNdPTEsbn1pZih0PWUubWF0Y2gobTEpKXtjb25zdCBuPXQuc2xpY2UoMSw1KTtmb3IobGV0IHI9MDtyPDQ7cisrKW5bcl09K25bcl07cmV0dXJuIG59aWYodD1lLm1hdGNoKHcxKSl7Y29uc3Qgbj10LnNsaWNlKDEsNCk7Zm9yKGxldCByPTA7cjwzO3IrKyluW3JdPU0xKG5bcl0qMi41NSk7cmV0dXJuIG5bM109MSxufWlmKHQ9ZS5tYXRjaCh5MSkpe2NvbnN0IG49dC5zbGljZSgxLDUpO2ZvcihsZXQgcj0wO3I8MztyKyspbltyXT1NMShuW3JdKjIuNTUpO3JldHVybiBuWzNdPStuWzNdLG59aWYodD1lLm1hdGNoKF8xKSl7Y29uc3Qgbj10LnNsaWNlKDEsNCk7blsxXSo9LjAxLG5bMl0qPS4wMTtjb25zdCByPVcwKG4pO3JldHVybiByWzNdPTEscn1pZih0PWUubWF0Y2goazEpKXtjb25zdCBuPXQuc2xpY2UoMSw0KTtuWzFdKj0uMDEsblsyXSo9LjAxO2NvbnN0IHI9VzAobik7cmV0dXJuIHJbM109K3RbNF0scn19O2owLnRlc3Q9ZT0+ZzEudGVzdChlKXx8bTEudGVzdChlKXx8dzEudGVzdChlKXx8eTEudGVzdChlKXx8XzEudGVzdChlKXx8azEudGVzdChlKSxiLnByb3RvdHlwZS5jc3M9ZnVuY3Rpb24oZSl7cmV0dXJuIHkyKHRoaXMuX3JnYixlKX0sTS5jc3M9KC4uLmUpPT5uZXcgYiguLi5lLCJjc3MiKSxSLmZvcm1hdC5jc3M9ajAsUi5hdXRvZGV0ZWN0LnB1c2goe3A6NSx0ZXN0OihlLC4uLnQpPT57aWYoIXQubGVuZ3RoJiZTKGUpPT09InN0cmluZyImJmowLnRlc3QoZSkpcmV0dXJuImNzcyJ9fSksUi5mb3JtYXQuZ2w9KC4uLmUpPT57Y29uc3QgdD1JKGUsInJnYmEiKTtyZXR1cm4gdFswXSo9MjU1LHRbMV0qPTI1NSx0WzJdKj0yNTUsdH0sTS5nbD0oLi4uZSk9Pm5ldyBiKC4uLmUsImdsIiksYi5wcm90b3R5cGUuZ2w9ZnVuY3Rpb24oKXtjb25zdCBlPXRoaXMuX3JnYjtyZXR1cm5bZVswXS8yNTUsZVsxXS8yNTUsZVsyXS8yNTUsZVszXV19O2NvbnN0e2Zsb29yOl8yfT1NYXRoLGsyPSguLi5lKT0+e2U9SShlLCJoY2ciKTtsZXRbdCxuLHJdPWUscyxvLGM7cj1yKjI1NTtjb25zdCBpPW4qMjU1O2lmKG49PT0wKXM9bz1jPXI7ZWxzZXt0PT09MzYwJiYodD0wKSx0PjM2MCYmKHQtPTM2MCksdDwwJiYodCs9MzYwKSx0Lz02MDtjb25zdCBhPV8yKHQpLGY9dC1hLGw9ciooMS1uKSx1PWwraSooMS1mKSxkPWwraSpmLHk9bCtpO3N3aXRjaChhKXtjYXNlIDA6W3MsbyxjXT1beSxkLGxdO2JyZWFrO2Nhc2UgMTpbcyxvLGNdPVt1LHksbF07YnJlYWs7Y2FzZSAyOltzLG8sY109W2wseSxkXTticmVhaztjYXNlIDM6W3MsbyxjXT1bbCx1LHldO2JyZWFrO2Nhc2UgNDpbcyxvLGNdPVtkLGwseV07YnJlYWs7Y2FzZSA1OltzLG8sY109W3ksbCx1XTticmVha319cmV0dXJuW3MsbyxjLGUubGVuZ3RoPjM/ZVszXToxXX0sTTI9KC4uLmUpPT57Y29uc3RbdCxuLHJdPUkoZSwicmdiIikscz1FMCh0LG4sciksbz1OMCh0LG4sciksYz1vLXMsaT1jKjEwMC8yNTUsYT1zLygyNTUtYykqMTAwO2xldCBmO3JldHVybiBjPT09MD9mPU51bWJlci5OYU46KHQ9PT1vJiYoZj0obi1yKS9jKSxuPT09byYmKGY9Misoci10KS9jKSxyPT09byYmKGY9NCsodC1uKS9jKSxmKj02MCxmPDAmJihmKz0zNjApKSxbZixpLGFdfTtiLnByb3RvdHlwZS5oY2c9ZnVuY3Rpb24oKXtyZXR1cm4gTTIodGhpcy5fcmdiKX0sTS5oY2c9KC4uLmUpPT5uZXcgYiguLi5lLCJoY2ciKSxSLmZvcm1hdC5oY2c9azIsUi5hdXRvZGV0ZWN0LnB1c2goe3A6MSx0ZXN0OiguLi5lKT0+e2lmKGU9SShlLCJoY2ciKSxTKGUpPT09ImFycmF5IiYmZS5sZW5ndGg9PT0zKXJldHVybiJoY2cifX0pO2NvbnN0IEEyPS9eIz8oW0EtRmEtZjAtOV17Nn18W0EtRmEtZjAtOV17M30pJC8sQzI9L14jPyhbQS1GYS1mMC05XXs4fXxbQS1GYS1mMC05XXs0fSkkLyxBMT1lPT57aWYoZS5tYXRjaChBMikpeyhlLmxlbmd0aD09PTR8fGUubGVuZ3RoPT09NykmJihlPWUuc3Vic3RyKDEpKSxlLmxlbmd0aD09PTMmJihlPWUuc3BsaXQoIiIpLGU9ZVswXStlWzBdK2VbMV0rZVsxXStlWzJdK2VbMl0pO2NvbnN0IHQ9cGFyc2VJbnQoZSwxNiksbj10Pj4xNixyPXQ+PjgmMjU1LHM9dCYyNTU7cmV0dXJuW24scixzLDFdfWlmKGUubWF0Y2goQzIpKXsoZS5sZW5ndGg9PT01fHxlLmxlbmd0aD09PTkpJiYoZT1lLnN1YnN0cigxKSksZS5sZW5ndGg9PT00JiYoZT1lLnNwbGl0KCIiKSxlPWVbMF0rZVswXStlWzFdK2VbMV0rZVsyXStlWzJdK2VbM10rZVszXSk7Y29uc3QgdD1wYXJzZUludChlLDE2KSxuPXQ+PjI0JjI1NSxyPXQ+PjE2JjI1NSxzPXQ+PjgmMjU1LG89TWF0aC5yb3VuZCgodCYyNTUpLzI1NSoxMDApLzEwMDtyZXR1cm5bbixyLHMsb119dGhyb3cgbmV3IEVycm9yKGB1bmtub3duIGhleCBjb2xvcjogJHtlfWApfSx7cm91bmQ6RjB9PU1hdGgsQzE9KC4uLmUpPT57bGV0W3QsbixyLHNdPUkoZSwicmdiYSIpLG89UjAoZSl8fCJhdXRvIjtzPT09dm9pZCAwJiYocz0xKSxvPT09ImF1dG8iJiYobz1zPDE/InJnYmEiOiJyZ2IiKSx0PUYwKHQpLG49RjAobikscj1GMChyKTtsZXQgaT0iMDAwMDAwIisodDw8MTZ8bjw8OHxyKS50b1N0cmluZygxNik7aT1pLnN1YnN0cihpLmxlbmd0aC02KTtsZXQgYT0iMCIrRjAocyoyNTUpLnRvU3RyaW5nKDE2KTtzd2l0Y2goYT1hLnN1YnN0cihhLmxlbmd0aC0yKSxvLnRvTG93ZXJDYXNlKCkpe2Nhc2UicmdiYSI6cmV0dXJuYCMke2l9JHthfWA7Y2FzZSJhcmdiIjpyZXR1cm5gIyR7YX0ke2l9YDtkZWZhdWx0OnJldHVybmAjJHtpfWB9fTtiLnByb3RvdHlwZS5oZXg9ZnVuY3Rpb24oZSl7cmV0dXJuIEMxKHRoaXMuX3JnYixlKX0sTS5oZXg9KC4uLmUpPT5uZXcgYiguLi5lLCJoZXgiKSxSLmZvcm1hdC5oZXg9QTEsUi5hdXRvZGV0ZWN0LnB1c2goe3A6NCx0ZXN0OihlLC4uLnQpPT57aWYoIXQubGVuZ3RoJiZTKGUpPT09InN0cmluZyImJlszLDQsNSw2LDcsOCw5XS5pbmRleE9mKGUubGVuZ3RoKT49MClyZXR1cm4iaGV4In19KTtjb25zdHtjb3M6aTB9PU1hdGgsdjI9KC4uLmUpPT57ZT1JKGUsImhzaSIpO2xldFt0LG4scl09ZSxzLG8sYztyZXR1cm4gaXNOYU4odCkmJih0PTApLGlzTmFOKG4pJiYobj0wKSx0PjM2MCYmKHQtPTM2MCksdDwwJiYodCs9MzYwKSx0Lz0zNjAsdDwxLzM/KGM9KDEtbikvMyxzPSgxK24qaTAoVip0KS9pMChMMC1WKnQpKS8zLG89MS0oYytzKSk6dDwyLzM/KHQtPTEvMyxzPSgxLW4pLzMsbz0oMStuKmkwKFYqdCkvaTAoTDAtVip0KSkvMyxjPTEtKHMrbykpOih0LT0yLzMsbz0oMS1uKS8zLGM9KDErbippMChWKnQpL2kwKEwwLVYqdCkpLzMscz0xLShvK2MpKSxzPXoocipzKjMpLG89eihyKm8qMyksYz16KHIqYyozKSxbcyoyNTUsbyoyNTUsYyoyNTUsZS5sZW5ndGg+Mz9lWzNdOjFdfSx7bWluOlIyLHNxcnQ6UzIsYWNvczpGMn09TWF0aCxJMj0oLi4uZSk9PntsZXRbdCxuLHJdPUkoZSwicmdiIik7dC89MjU1LG4vPTI1NSxyLz0yNTU7bGV0IHM7Y29uc3Qgbz1SMih0LG4sciksYz0odCtuK3IpLzMsaT1jPjA/MS1vL2M6MDtyZXR1cm4gaT09PTA/cz1OYU46KHM9KHQtbisodC1yKSkvMixzLz1TMigodC1uKSoodC1uKSsodC1yKSoobi1yKSkscz1GMihzKSxyPm4mJihzPVYtcykscy89ViksW3MqMzYwLGksY119O2IucHJvdG90eXBlLmhzaT1mdW5jdGlvbigpe3JldHVybiBJMih0aGlzLl9yZ2IpfSxNLmhzaT0oLi4uZSk9Pm5ldyBiKC4uLmUsImhzaSIpLFIuZm9ybWF0LmhzaT12MixSLmF1dG9kZXRlY3QucHVzaCh7cDoyLHRlc3Q6KC4uLmUpPT57aWYoZT1JKGUsImhzaSIpLFMoZSk9PT0iYXJyYXkiJiZlLmxlbmd0aD09PTMpcmV0dXJuImhzaSJ9fSksYi5wcm90b3R5cGUuaHNsPWZ1bmN0aW9uKCl7cmV0dXJuIHAxKHRoaXMuX3JnYil9LE0uaHNsPSguLi5lKT0+bmV3IGIoLi4uZSwiaHNsIiksUi5mb3JtYXQuaHNsPVcwLFIuYXV0b2RldGVjdC5wdXNoKHtwOjIsdGVzdDooLi4uZSk9PntpZihlPUkoZSwiaHNsIiksUyhlKT09PSJhcnJheSImJmUubGVuZ3RoPT09MylyZXR1cm4iaHNsIn19KTtjb25zdHtmbG9vcjp4Mn09TWF0aCxCMj0oLi4uZSk9PntlPUkoZSwiaHN2Iik7bGV0W3QsbixyXT1lLHMsbyxjO2lmKHIqPTI1NSxuPT09MClzPW89Yz1yO2Vsc2V7dD09PTM2MCYmKHQ9MCksdD4zNjAmJih0LT0zNjApLHQ8MCYmKHQrPTM2MCksdC89NjA7Y29uc3QgaT14Mih0KSxhPXQtaSxmPXIqKDEtbiksbD1yKigxLW4qYSksdT1yKigxLW4qKDEtYSkpO3N3aXRjaChpKXtjYXNlIDA6W3MsbyxjXT1bcix1LGZdO2JyZWFrO2Nhc2UgMTpbcyxvLGNdPVtsLHIsZl07YnJlYWs7Y2FzZSAyOltzLG8sY109W2Yscix1XTticmVhaztjYXNlIDM6W3MsbyxjXT1bZixsLHJdO2JyZWFrO2Nhc2UgNDpbcyxvLGNdPVt1LGYscl07YnJlYWs7Y2FzZSA1OltzLG8sY109W3IsZixsXTticmVha319cmV0dXJuW3MsbyxjLGUubGVuZ3RoPjM/ZVszXToxXX0se21pbjp6MixtYXg6UDJ9PU1hdGgsJDI9KC4uLmUpPT57ZT1JKGUsInJnYiIpO2xldFt0LG4scl09ZTtjb25zdCBzPXoyKHQsbixyKSxvPVAyKHQsbixyKSxjPW8tcztsZXQgaSxhLGY7cmV0dXJuIGY9by8yNTUsbz09PTA/KGk9TnVtYmVyLk5hTixhPTApOihhPWMvbyx0PT09byYmKGk9KG4tcikvYyksbj09PW8mJihpPTIrKHItdCkvYykscj09PW8mJihpPTQrKHQtbikvYyksaSo9NjAsaTwwJiYoaSs9MzYwKSksW2ksYSxmXX07Yi5wcm90b3R5cGUuaHN2PWZ1bmN0aW9uKCl7cmV0dXJuICQyKHRoaXMuX3JnYil9LE0uaHN2PSguLi5lKT0+bmV3IGIoLi4uZSwiaHN2IiksUi5mb3JtYXQuaHN2PUIyLFIuYXV0b2RldGVjdC5wdXNoKHtwOjIsdGVzdDooLi4uZSk9PntpZihlPUkoZSwiaHN2IiksUyhlKT09PSJhcnJheSImJmUubGVuZ3RoPT09MylyZXR1cm4iaHN2In19KTt2YXIgRz17S246MTgsWG46Ljk1MDQ3LFluOjEsWm46MS4wODg4Myx0MDouMTM3OTMxMDM0LHQxOi4yMDY4OTY1NTIsdDI6LjEyODQxODU1LHQzOi4wMDg4NTY0NTJ9O2NvbnN0e3BvdzpUMn09TWF0aCx2MT0oLi4uZSk9PntlPUkoZSwibGFiIik7Y29uc3RbdCxuLHJdPWU7bGV0IHMsbyxjLGksYSxmO3JldHVybiBvPSh0KzE2KS8xMTYscz1pc05hTihuKT9vOm8rbi81MDAsYz1pc05hTihyKT9vOm8tci8yMDAsbz1HLlluKk8wKG8pLHM9Ry5YbipPMChzKSxjPUcuWm4qTzAoYyksaT1IMCgzLjI0MDQ1NDIqcy0xLjUzNzEzODUqby0uNDk4NTMxNCpjKSxhPUgwKC0uOTY5MjY2KnMrMS44NzYwMTA4Km8rLjA0MTU1NipjKSxmPUgwKC4wNTU2NDM0KnMtLjIwNDAyNTkqbysxLjA1NzIyNTIqYyksW2ksYSxmLGUubGVuZ3RoPjM/ZVszXToxXX0sSDA9ZT0+MjU1KihlPD0uMDAzMDQ/MTIuOTIqZToxLjA1NSpUMihlLDEvMi40KS0uMDU1KSxPMD1lPT5lPkcudDE/ZSplKmU6Ry50MiooZS1HLnQwKSx7cG93OlIxfT1NYXRoLFMxPSguLi5lKT0+e2NvbnN0W3QsbixyXT1JKGUsInJnYiIpLFtzLG8sY109RTIodCxuLHIpLGk9MTE2Km8tMTY7cmV0dXJuW2k8MD8wOmksNTAwKihzLW8pLDIwMCooby1jKV19LFkwPWU9PihlLz0yNTUpPD0uMDQwNDU/ZS8xMi45MjpSMSgoZSsuMDU1KS8xLjA1NSwyLjQpLFUwPWU9PmU+Ry50Mz9SMShlLDEvMyk6ZS9HLnQyK0cudDAsRTI9KGUsdCxuKT0+e2U9WTAoZSksdD1ZMCh0KSxuPVkwKG4pO2NvbnN0IHI9VTAoKC40MTI0NTY0KmUrLjM1NzU3NjEqdCsuMTgwNDM3NSpuKS9HLlhuKSxzPVUwKCguMjEyNjcyOSplKy43MTUxNTIyKnQrLjA3MjE3NSpuKS9HLlluKSxvPVUwKCguMDE5MzMzOSplKy4xMTkxOTIqdCsuOTUwMzA0MSpuKS9HLlpuKTtyZXR1cm5bcixzLG9dfTtiLnByb3RvdHlwZS5sYWI9ZnVuY3Rpb24oKXtyZXR1cm4gUzEodGhpcy5fcmdiKX0sTS5sYWI9KC4uLmUpPT5uZXcgYiguLi5lLCJsYWIiKSxSLmZvcm1hdC5sYWI9djEsUi5hdXRvZGV0ZWN0LnB1c2goe3A6Mix0ZXN0OiguLi5lKT0+e2lmKGU9SShlLCJsYWIiKSxTKGUpPT09ImFycmF5IiYmZS5sZW5ndGg9PT0zKXJldHVybiJsYWIifX0pO2NvbnN0e3NpbjpOMixjb3M6TDJ9PU1hdGgsRjE9KC4uLmUpPT57bGV0W3QsbixyXT1JKGUsImxjaCIpO3JldHVybiBpc05hTihyKSYmKHI9MCkscj1yKmIyLFt0LEwyKHIpKm4sTjIocikqbl19LEkxPSguLi5lKT0+e2U9SShlLCJsY2giKTtjb25zdFt0LG4scl09ZSxbcyxvLGNdPUYxKHQsbixyKSxbaSxhLGZdPXYxKHMsbyxjKTtyZXR1cm5baSxhLGYsZS5sZW5ndGg+Mz9lWzNdOjFdfSxEMj0oLi4uZSk9Pntjb25zdCB0PUkoZSwiaGNsIikucmV2ZXJzZSgpO3JldHVybiBJMSguLi50KX0se3NxcnQ6RzIsYXRhbjI6cTIscm91bmQ6VzJ9PU1hdGgseDE9KC4uLmUpPT57Y29uc3RbdCxuLHJdPUkoZSwibGFiIikscz1HMihuKm4rcipyKTtsZXQgbz0ocTIocixuKSpkMiszNjApJTM2MDtyZXR1cm4gVzIocyoxZTQpPT09MCYmKG89TnVtYmVyLk5hTiksW3QscyxvXX0sQjE9KC4uLmUpPT57Y29uc3RbdCxuLHJdPUkoZSwicmdiIiksW3MsbyxjXT1TMSh0LG4scik7cmV0dXJuIHgxKHMsbyxjKX07Yi5wcm90b3R5cGUubGNoPWZ1bmN0aW9uKCl7cmV0dXJuIEIxKHRoaXMuX3JnYil9LGIucHJvdG90eXBlLmhjbD1mdW5jdGlvbigpe3JldHVybiBCMSh0aGlzLl9yZ2IpLnJldmVyc2UoKX0sTS5sY2g9KC4uLmUpPT5uZXcgYiguLi5lLCJsY2giKSxNLmhjbD0oLi4uZSk9Pm5ldyBiKC4uLmUsImhjbCIpLFIuZm9ybWF0LmxjaD1JMSxSLmZvcm1hdC5oY2w9RDIsWyJsY2giLCJoY2wiXS5mb3JFYWNoKGU9PlIuYXV0b2RldGVjdC5wdXNoKHtwOjIsdGVzdDooLi4udCk9PntpZih0PUkodCxlKSxTKHQpPT09ImFycmF5IiYmdC5sZW5ndGg9PT0zKXJldHVybiBlfX0pKTtjb25zdCBhMD17YWxpY2VibHVlOiIjZjBmOGZmIixhbnRpcXVld2hpdGU6IiNmYWViZDciLGFxdWE6IiMwMGZmZmYiLGFxdWFtYXJpbmU6IiM3ZmZmZDQiLGF6dXJlOiIjZjBmZmZmIixiZWlnZToiI2Y1ZjVkYyIsYmlzcXVlOiIjZmZlNGM0IixibGFjazoiIzAwMDAwMCIsYmxhbmNoZWRhbG1vbmQ6IiNmZmViY2QiLGJsdWU6IiMwMDAwZmYiLGJsdWV2aW9sZXQ6IiM4YTJiZTIiLGJyb3duOiIjYTUyYTJhIixidXJseXdvb2Q6IiNkZWI4ODciLGNhZGV0Ymx1ZToiIzVmOWVhMCIsY2hhcnRyZXVzZToiIzdmZmYwMCIsY2hvY29sYXRlOiIjZDI2OTFlIixjb3JhbDoiI2ZmN2Y1MCIsY29ybmZsb3dlcmJsdWU6IiM2NDk1ZWQiLGNvcm5zaWxrOiIjZmZmOGRjIixjcmltc29uOiIjZGMxNDNjIixjeWFuOiIjMDBmZmZmIixkYXJrYmx1ZToiIzAwMDA4YiIsZGFya2N5YW46IiMwMDhiOGIiLGRhcmtnb2xkZW5yb2Q6IiNiODg2MGIiLGRhcmtncmF5OiIjYTlhOWE5IixkYXJrZ3JlZW46IiMwMDY0MDAiLGRhcmtncmV5OiIjYTlhOWE5IixkYXJra2hha2k6IiNiZGI3NmIiLGRhcmttYWdlbnRhOiIjOGIwMDhiIixkYXJrb2xpdmVncmVlbjoiIzU1NmIyZiIsZGFya29yYW5nZToiI2ZmOGMwMCIsZGFya29yY2hpZDoiIzk5MzJjYyIsZGFya3JlZDoiIzhiMDAwMCIsZGFya3NhbG1vbjoiI2U5OTY3YSIsZGFya3NlYWdyZWVuOiIjOGZiYzhmIixkYXJrc2xhdGVibHVlOiIjNDgzZDhiIixkYXJrc2xhdGVncmF5OiIjMmY0ZjRmIixkYXJrc2xhdGVncmV5OiIjMmY0ZjRmIixkYXJrdHVycXVvaXNlOiIjMDBjZWQxIixkYXJrdmlvbGV0OiIjOTQwMGQzIixkZWVwcGluazoiI2ZmMTQ5MyIsZGVlcHNreWJsdWU6IiMwMGJmZmYiLGRpbWdyYXk6IiM2OTY5NjkiLGRpbWdyZXk6IiM2OTY5NjkiLGRvZGdlcmJsdWU6IiMxZTkwZmYiLGZpcmVicmljazoiI2IyMjIyMiIsZmxvcmFsd2hpdGU6IiNmZmZhZjAiLGZvcmVzdGdyZWVuOiIjMjI4YjIyIixmdWNoc2lhOiIjZmYwMGZmIixnYWluc2Jvcm86IiNkY2RjZGMiLGdob3N0d2hpdGU6IiNmOGY4ZmYiLGdvbGQ6IiNmZmQ3MDAiLGdvbGRlbnJvZDoiI2RhYTUyMCIsZ3JheToiIzgwODA4MCIsZ3JlZW46IiMwMDgwMDAiLGdyZWVueWVsbG93OiIjYWRmZjJmIixncmV5OiIjODA4MDgwIixob25leWRldzoiI2YwZmZmMCIsaG90cGluazoiI2ZmNjliNCIsaW5kaWFucmVkOiIjY2Q1YzVjIixpbmRpZ286IiM0YjAwODIiLGl2b3J5OiIjZmZmZmYwIixraGFraToiI2YwZTY4YyIsbGFzZXJsZW1vbjoiI2ZmZmY1NCIsbGF2ZW5kZXI6IiNlNmU2ZmEiLGxhdmVuZGVyYmx1c2g6IiNmZmYwZjUiLGxhd25ncmVlbjoiIzdjZmMwMCIsbGVtb25jaGlmZm9uOiIjZmZmYWNkIixsaWdodGJsdWU6IiNhZGQ4ZTYiLGxpZ2h0Y29yYWw6IiNmMDgwODAiLGxpZ2h0Y3lhbjoiI2UwZmZmZiIsbGlnaHRnb2xkZW5yb2Q6IiNmYWZhZDIiLGxpZ2h0Z29sZGVucm9keWVsbG93OiIjZmFmYWQyIixsaWdodGdyYXk6IiNkM2QzZDMiLGxpZ2h0Z3JlZW46IiM5MGVlOTAiLGxpZ2h0Z3JleToiI2QzZDNkMyIsbGlnaHRwaW5rOiIjZmZiNmMxIixsaWdodHNhbG1vbjoiI2ZmYTA3YSIsbGlnaHRzZWFncmVlbjoiIzIwYjJhYSIsbGlnaHRza3libHVlOiIjODdjZWZhIixsaWdodHNsYXRlZ3JheToiIzc3ODg5OSIsbGlnaHRzbGF0ZWdyZXk6IiM3Nzg4OTkiLGxpZ2h0c3RlZWxibHVlOiIjYjBjNGRlIixsaWdodHllbGxvdzoiI2ZmZmZlMCIsbGltZToiIzAwZmYwMCIsbGltZWdyZWVuOiIjMzJjZDMyIixsaW5lbjoiI2ZhZjBlNiIsbWFnZW50YToiI2ZmMDBmZiIsbWFyb29uOiIjODAwMDAwIixtYXJvb24yOiIjN2YwMDAwIixtYXJvb24zOiIjYjAzMDYwIixtZWRpdW1hcXVhbWFyaW5lOiIjNjZjZGFhIixtZWRpdW1ibHVlOiIjMDAwMGNkIixtZWRpdW1vcmNoaWQ6IiNiYTU1ZDMiLG1lZGl1bXB1cnBsZToiIzkzNzBkYiIsbWVkaXVtc2VhZ3JlZW46IiMzY2IzNzEiLG1lZGl1bXNsYXRlYmx1ZToiIzdiNjhlZSIsbWVkaXVtc3ByaW5nZ3JlZW46IiMwMGZhOWEiLG1lZGl1bXR1cnF1b2lzZToiIzQ4ZDFjYyIsbWVkaXVtdmlvbGV0cmVkOiIjYzcxNTg1IixtaWRuaWdodGJsdWU6IiMxOTE5NzAiLG1pbnRjcmVhbToiI2Y1ZmZmYSIsbWlzdHlyb3NlOiIjZmZlNGUxIixtb2NjYXNpbjoiI2ZmZTRiNSIsbmF2YWpvd2hpdGU6IiNmZmRlYWQiLG5hdnk6IiMwMDAwODAiLG9sZGxhY2U6IiNmZGY1ZTYiLG9saXZlOiIjODA4MDAwIixvbGl2ZWRyYWI6IiM2YjhlMjMiLG9yYW5nZToiI2ZmYTUwMCIsb3JhbmdlcmVkOiIjZmY0NTAwIixvcmNoaWQ6IiNkYTcwZDYiLHBhbGVnb2xkZW5yb2Q6IiNlZWU4YWEiLHBhbGVncmVlbjoiIzk4ZmI5OCIscGFsZXR1cnF1b2lzZToiI2FmZWVlZSIscGFsZXZpb2xldHJlZDoiI2RiNzA5MyIscGFwYXlhd2hpcDoiI2ZmZWZkNSIscGVhY2hwdWZmOiIjZmZkYWI5IixwZXJ1OiIjY2Q4NTNmIixwaW5rOiIjZmZjMGNiIixwbHVtOiIjZGRhMGRkIixwb3dkZXJibHVlOiIjYjBlMGU2IixwdXJwbGU6IiM4MDAwODAiLHB1cnBsZTI6IiM3ZjAwN2YiLHB1cnBsZTM6IiNhMDIwZjAiLHJlYmVjY2FwdXJwbGU6IiM2NjMzOTkiLHJlZDoiI2ZmMDAwMCIscm9zeWJyb3duOiIjYmM4ZjhmIixyb3lhbGJsdWU6IiM0MTY5ZTEiLHNhZGRsZWJyb3duOiIjOGI0NTEzIixzYWxtb246IiNmYTgwNzIiLHNhbmR5YnJvd246IiNmNGE0NjAiLHNlYWdyZWVuOiIjMmU4YjU3IixzZWFzaGVsbDoiI2ZmZjVlZSIsc2llbm5hOiIjYTA1MjJkIixzaWx2ZXI6IiNjMGMwYzAiLHNreWJsdWU6IiM4N2NlZWIiLHNsYXRlYmx1ZToiIzZhNWFjZCIsc2xhdGVncmF5OiIjNzA4MDkwIixzbGF0ZWdyZXk6IiM3MDgwOTAiLHNub3c6IiNmZmZhZmEiLHNwcmluZ2dyZWVuOiIjMDBmZjdmIixzdGVlbGJsdWU6IiM0NjgyYjQiLHRhbjoiI2QyYjQ4YyIsdGVhbDoiIzAwODA4MCIsdGhpc3RsZToiI2Q4YmZkOCIsdG9tYXRvOiIjZmY2MzQ3Iix0dXJxdW9pc2U6IiM0MGUwZDAiLHZpb2xldDoiI2VlODJlZSIsd2hlYXQ6IiNmNWRlYjMiLHdoaXRlOiIjZmZmZmZmIix3aGl0ZXNtb2tlOiIjZjVmNWY1Iix5ZWxsb3c6IiNmZmZmMDAiLHllbGxvd2dyZWVuOiIjOWFjZDMyIn07Yi5wcm90b3R5cGUubmFtZT1mdW5jdGlvbigpe2NvbnN0IGU9QzEodGhpcy5fcmdiLCJyZ2IiKTtmb3IobGV0IHQgb2YgT2JqZWN0LmtleXMoYTApKWlmKGEwW3RdPT09ZSlyZXR1cm4gdC50b0xvd2VyQ2FzZSgpO3JldHVybiBlfSxSLmZvcm1hdC5uYW1lZD1lPT57aWYoZT1lLnRvTG93ZXJDYXNlKCksYTBbZV0pcmV0dXJuIEExKGEwW2VdKTt0aHJvdyBuZXcgRXJyb3IoInVua25vd24gY29sb3IgbmFtZTogIitlKX0sUi5hdXRvZGV0ZWN0LnB1c2goe3A6NSx0ZXN0OihlLC4uLnQpPT57aWYoIXQubGVuZ3RoJiZTKGUpPT09InN0cmluZyImJmEwW2UudG9Mb3dlckNhc2UoKV0pcmV0dXJuIm5hbWVkIn19KTtjb25zdCBqMj1lPT57aWYoUyhlKT09Im51bWJlciImJmU+PTAmJmU8PTE2Nzc3MjE1KXtjb25zdCB0PWU+PjE2LG49ZT4+OCYyNTUscj1lJjI1NTtyZXR1cm5bdCxuLHIsMV19dGhyb3cgbmV3IEVycm9yKCJ1bmtub3duIG51bSBjb2xvcjogIitlKX0sSDI9KC4uLmUpPT57Y29uc3RbdCxuLHJdPUkoZSwicmdiIik7cmV0dXJuKHQ8PDE2KSsobjw8OCkrcn07Yi5wcm90b3R5cGUubnVtPWZ1bmN0aW9uKCl7cmV0dXJuIEgyKHRoaXMuX3JnYil9LE0ubnVtPSguLi5lKT0+bmV3IGIoLi4uZSwibnVtIiksUi5mb3JtYXQubnVtPWoyLFIuYXV0b2RldGVjdC5wdXNoKHtwOjUsdGVzdDooLi4uZSk9PntpZihlLmxlbmd0aD09PTEmJlMoZVswXSk9PT0ibnVtYmVyIiYmZVswXT49MCYmZVswXTw9MTY3NzcyMTUpcmV0dXJuIm51bSJ9fSk7Y29uc3R7cm91bmQ6ejF9PU1hdGg7Yi5wcm90b3R5cGUucmdiPWZ1bmN0aW9uKGU9ITApe3JldHVybiBlPT09ITE/dGhpcy5fcmdiLnNsaWNlKDAsMyk6dGhpcy5fcmdiLnNsaWNlKDAsMykubWFwKHoxKX0sYi5wcm90b3R5cGUucmdiYT1mdW5jdGlvbihlPSEwKXtyZXR1cm4gdGhpcy5fcmdiLnNsaWNlKDAsNCkubWFwKCh0LG4pPT5uPDM/ZT09PSExP3Q6ejEodCk6dCl9LE0ucmdiPSguLi5lKT0+bmV3IGIoLi4uZSwicmdiIiksUi5mb3JtYXQucmdiPSguLi5lKT0+e2NvbnN0IHQ9SShlLCJyZ2JhIik7cmV0dXJuIHRbM109PT12b2lkIDAmJih0WzNdPTEpLHR9LFIuYXV0b2RldGVjdC5wdXNoKHtwOjMsdGVzdDooLi4uZSk9PntpZihlPUkoZSwicmdiYSIpLFMoZSk9PT0iYXJyYXkiJiYoZS5sZW5ndGg9PT0zfHxlLmxlbmd0aD09PTQmJlMoZVszXSk9PSJudW1iZXIiJiZlWzNdPj0wJiZlWzNdPD0xKSlyZXR1cm4icmdiIn19KTtjb25zdHtsb2c6STB9PU1hdGgsUDE9ZT0+e2NvbnN0IHQ9ZS8xMDA7bGV0IG4scixzO3JldHVybiB0PDY2PyhuPTI1NSxyPXQ8Nj8wOi0xNTUuMjU0ODU1NjI3MDkxNzktLjQ0NTk2OTUwNDY5NTc5MTMzKihyPXQtMikrMTA0LjQ5MjE2MTk5MzkzODg4KkkwKHIpLHM9dDwyMD8wOi0yNTQuNzY5MzUxODQxMjA5MDIrLjgyNzQwOTYwNjQwMDczOTUqKHM9dC0xMCkrMTE1LjY3OTk0NDAxMDY2MTQ3KkkwKHMpKToobj0zNTEuOTc2OTA1NjY4MDU2OTMrLjExNDIwNjQ1Mzc4NDE2NSoobj10LTU1KS00MC4yNTM2NjMwOTMzMjEyNypJMChuKSxyPTMyNS40NDk0MTI1NzExOTc0Ky4wNzk0MzQ1NjUzNjY2MjM0Mioocj10LTUwKS0yOC4wODUyOTYzNTA3OTU3KkkwKHIpLHM9MjU1KSxbbixyLHMsMV19LHtyb3VuZDpPMn09TWF0aCxZMj0oLi4uZSk9Pntjb25zdCB0PUkoZSwicmdiIiksbj10WzBdLHI9dFsyXTtsZXQgcz0xZTMsbz00ZTQ7Y29uc3QgYz0uNDtsZXQgaTtmb3IoO28tcz5jOyl7aT0obytzKSouNTtjb25zdCBhPVAxKGkpO2FbMl0vYVswXT49ci9uP289aTpzPWl9cmV0dXJuIE8yKGkpfTtiLnByb3RvdHlwZS50ZW1wPWIucHJvdG90eXBlLmtlbHZpbj1iLnByb3RvdHlwZS50ZW1wZXJhdHVyZT1mdW5jdGlvbigpe3JldHVybiBZMih0aGlzLl9yZ2IpfSxNLnRlbXA9TS5rZWx2aW49TS50ZW1wZXJhdHVyZT0oLi4uZSk9Pm5ldyBiKC4uLmUsInRlbXAiKSxSLmZvcm1hdC50ZW1wPVIuZm9ybWF0LmtlbHZpbj1SLmZvcm1hdC50ZW1wZXJhdHVyZT1QMTtjb25zdHtwb3c6eDAsc2lnbjpVMn09TWF0aCwkMT0oLi4uZSk9PntlPUkoZSwibGFiIik7Y29uc3RbdCxuLHJdPWUscz14MCh0Ky4zOTYzMzc3Nzc0Km4rLjIxNTgwMzc1NzMqciwzKSxvPXgwKHQtLjEwNTU2MTM0NTgqbi0uMDYzODU0MTcyOCpyLDMpLGM9eDAodC0uMDg5NDg0MTc3NSpuLTEuMjkxNDg1NTQ4KnIsMyk7cmV0dXJuWzI1NSpYMCg0LjA3Njc0MTY2MjEqcy0zLjMwNzcxMTU5MTMqbysuMjMwOTY5OTI5MipjKSwyNTUqWDAoLTEuMjY4NDM4MDA0NipzKzIuNjA5NzU3NDAxMSpvLS4zNDEzMTkzOTY1KmMpLDI1NSpYMCgtLjAwNDE5NjA4NjMqcy0uNzAzNDE4NjE0NypvKzEuNzA3NjE0NzAxKmMpLGUubGVuZ3RoPjM/ZVszXToxXX07ZnVuY3Rpb24gWDAoZSl7Y29uc3QgdD1NYXRoLmFicyhlKTtyZXR1cm4gdD4uMDAzMTMwOD8oVTIoZSl8fDEpKigxLjA1NSp4MCh0LDEvMi40KS0uMDU1KTplKjEyLjkyfWNvbnN0e2NicnQ6VjAscG93OlgyLHNpZ246VjJ9PU1hdGgsVDE9KC4uLmUpPT57Y29uc3RbdCxuLHJdPUkoZSwicmdiIiksW3MsbyxjXT1bSzAodC8yNTUpLEswKG4vMjU1KSxLMChyLzI1NSldLGk9VjAoLjQxMjIyMTQ3MDgqcysuNTM2MzMyNTM2MypvKy4wNTE0NDU5OTI5KmMpLGE9VjAoLjIxMTkwMzQ5ODIqcysuNjgwNjk5NTQ1MSpvKy4xMDczOTY5NTY2KmMpLGY9VjAoLjA4ODMwMjQ2MTkqcysuMjgxNzE4ODM3NipvKy42Mjk5Nzg3MDA1KmMpO3JldHVyblsuMjEwNDU0MjU1MyppKy43OTM2MTc3ODUqYS0uMDA0MDcyMDQ2OCpmLDEuOTc3OTk4NDk1MSppLTIuNDI4NTkyMjA1KmErLjQ1MDU5MzcwOTkqZiwuMDI1OTA0MDM3MSppKy43ODI3NzE3NjYyKmEtLjgwODY3NTc2NipmXX07ZnVuY3Rpb24gSzAoZSl7Y29uc3QgdD1NYXRoLmFicyhlKTtyZXR1cm4gdDwuMDQwNDU/ZS8xMi45MjooVjIoZSl8fDEpKlgyKCh0Ky4wNTUpLzEuMDU1LDIuNCl9Yi5wcm90b3R5cGUub2tsYWI9ZnVuY3Rpb24oKXtyZXR1cm4gVDEodGhpcy5fcmdiKX0sTS5va2xhYj0oLi4uZSk9Pm5ldyBiKC4uLmUsIm9rbGFiIiksUi5mb3JtYXQub2tsYWI9JDEsUi5hdXRvZGV0ZWN0LnB1c2goe3A6Myx0ZXN0OiguLi5lKT0+e2lmKGU9SShlLCJva2xhYiIpLFMoZSk9PT0iYXJyYXkiJiZlLmxlbmd0aD09PTMpcmV0dXJuIm9rbGFiIn19KTtjb25zdCBLMj0oLi4uZSk9PntlPUkoZSwibGNoIik7Y29uc3RbdCxuLHJdPWUsW3MsbyxjXT1GMSh0LG4sciksW2ksYSxmXT0kMShzLG8sYyk7cmV0dXJuW2ksYSxmLGUubGVuZ3RoPjM/ZVszXToxXX0sWjI9KC4uLmUpPT57Y29uc3RbdCxuLHJdPUkoZSwicmdiIiksW3MsbyxjXT1UMSh0LG4scik7cmV0dXJuIHgxKHMsbyxjKX07Yi5wcm90b3R5cGUub2tsY2g9ZnVuY3Rpb24oKXtyZXR1cm4gWjIodGhpcy5fcmdiKX0sTS5va2xjaD0oLi4uZSk9Pm5ldyBiKC4uLmUsIm9rbGNoIiksUi5mb3JtYXQub2tsY2g9SzIsUi5hdXRvZGV0ZWN0LnB1c2goe3A6Myx0ZXN0OiguLi5lKT0+e2lmKGU9SShlLCJva2xjaCIpLFMoZSk9PT0iYXJyYXkiJiZlLmxlbmd0aD09PTMpcmV0dXJuIm9rbGNoIn19KSxiLnByb3RvdHlwZS5hbHBoYT1mdW5jdGlvbihlLHQ9ITEpe3JldHVybiBlIT09dm9pZCAwJiZTKGUpPT09Im51bWJlciI/dD8odGhpcy5fcmdiWzNdPWUsdGhpcyk6bmV3IGIoW3RoaXMuX3JnYlswXSx0aGlzLl9yZ2JbMV0sdGhpcy5fcmdiWzJdLGVdLCJyZ2IiKTp0aGlzLl9yZ2JbM119LGIucHJvdG90eXBlLmNsaXBwZWQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fcmdiLl9jbGlwcGVkfHwhMX0sYi5wcm90b3R5cGUuZGFya2VuPWZ1bmN0aW9uKGU9MSl7Y29uc3QgdD10aGlzLG49dC5sYWIoKTtyZXR1cm4gblswXS09Ry5LbiplLG5ldyBiKG4sImxhYiIpLmFscGhhKHQuYWxwaGEoKSwhMCl9LGIucHJvdG90eXBlLmJyaWdodGVuPWZ1bmN0aW9uKGU9MSl7cmV0dXJuIHRoaXMuZGFya2VuKC1lKX0sYi5wcm90b3R5cGUuZGFya2VyPWIucHJvdG90eXBlLmRhcmtlbixiLnByb3RvdHlwZS5icmlnaHRlcj1iLnByb3RvdHlwZS5icmlnaHRlbixiLnByb3RvdHlwZS5nZXQ9ZnVuY3Rpb24oZSl7Y29uc3RbdCxuXT1lLnNwbGl0KCIuIikscj10aGlzW3RdKCk7aWYobil7Y29uc3Qgcz10LmluZGV4T2YobiktKHQuc3Vic3RyKDAsMik9PT0ib2siPzI6MCk7aWYocz4tMSlyZXR1cm4gcltzXTt0aHJvdyBuZXcgRXJyb3IoYHVua25vd24gY2hhbm5lbCAke259IGluIG1vZGUgJHt0fWApfWVsc2UgcmV0dXJuIHJ9O2NvbnN0e3BvdzpRMn09TWF0aCxKMj0xZS03LGU2PTIwO2IucHJvdG90eXBlLmx1bWluYW5jZT1mdW5jdGlvbihlLHQ9InJnYiIpe2lmKGUhPT12b2lkIDAmJlMoZSk9PT0ibnVtYmVyIil7aWYoZT09PTApcmV0dXJuIG5ldyBiKFswLDAsMCx0aGlzLl9yZ2JbM11dLCJyZ2IiKTtpZihlPT09MSlyZXR1cm4gbmV3IGIoWzI1NSwyNTUsMjU1LHRoaXMuX3JnYlszXV0sInJnYiIpO2xldCBuPXRoaXMubHVtaW5hbmNlKCkscj1lNjtjb25zdCBzPShjLGkpPT57Y29uc3QgYT1jLmludGVycG9sYXRlKGksLjUsdCksZj1hLmx1bWluYW5jZSgpO3JldHVybiBNYXRoLmFicyhlLWYpPEoyfHwhci0tP2E6Zj5lP3MoYyxhKTpzKGEsaSl9LG89KG4+ZT9zKG5ldyBiKFswLDAsMF0pLHRoaXMpOnModGhpcyxuZXcgYihbMjU1LDI1NSwyNTVdKSkpLnJnYigpO3JldHVybiBuZXcgYihbLi4ubyx0aGlzLl9yZ2JbM11dKX1yZXR1cm4gdDYoLi4udGhpcy5fcmdiLnNsaWNlKDAsMykpfTtjb25zdCB0Nj0oZSx0LG4pPT4oZT1aMChlKSx0PVowKHQpLG49WjAobiksLjIxMjYqZSsuNzE1Mip0Ky4wNzIyKm4pLFowPWU9PihlLz0yNTUsZTw9LjAzOTI4P2UvMTIuOTI6UTIoKGUrLjA1NSkvMS4wNTUsMi40KSk7dmFyIEw9e30sbTA9KGUsdCxuPS41LC4uLnIpPT57bGV0IHM9clswXXx8ImxyZ2IiO2lmKCFMW3NdJiYhci5sZW5ndGgmJihzPU9iamVjdC5rZXlzKEwpWzBdKSwhTFtzXSl0aHJvdyBuZXcgRXJyb3IoYGludGVycG9sYXRpb24gbW9kZSAke3N9IGlzIG5vdCBkZWZpbmVkYCk7cmV0dXJuIFMoZSkhPT0ib2JqZWN0IiYmKGU9bmV3IGIoZSkpLFModCkhPT0ib2JqZWN0IiYmKHQ9bmV3IGIodCkpLExbc10oZSx0LG4pLmFscGhhKGUuYWxwaGEoKStuKih0LmFscGhhKCktZS5hbHBoYSgpKSl9O2IucHJvdG90eXBlLm1peD1iLnByb3RvdHlwZS5pbnRlcnBvbGF0ZT1mdW5jdGlvbihlLHQ9LjUsLi4ubil7cmV0dXJuIG0wKHRoaXMsZSx0LC4uLm4pfSxiLnByb3RvdHlwZS5wcmVtdWx0aXBseT1mdW5jdGlvbihlPSExKXtjb25zdCB0PXRoaXMuX3JnYixuPXRbM107cmV0dXJuIGU/KHRoaXMuX3JnYj1bdFswXSpuLHRbMV0qbix0WzJdKm4sbl0sdGhpcyk6bmV3IGIoW3RbMF0qbix0WzFdKm4sdFsyXSpuLG5dLCJyZ2IiKX0sYi5wcm90b3R5cGUuc2F0dXJhdGU9ZnVuY3Rpb24oZT0xKXtjb25zdCB0PXRoaXMsbj10LmxjaCgpO3JldHVybiBuWzFdKz1HLktuKmUsblsxXTwwJiYoblsxXT0wKSxuZXcgYihuLCJsY2giKS5hbHBoYSh0LmFscGhhKCksITApfSxiLnByb3RvdHlwZS5kZXNhdHVyYXRlPWZ1bmN0aW9uKGU9MSl7cmV0dXJuIHRoaXMuc2F0dXJhdGUoLWUpfSxiLnByb3RvdHlwZS5zZXQ9ZnVuY3Rpb24oZSx0LG49ITEpe2NvbnN0W3Isc109ZS5zcGxpdCgiLiIpLG89dGhpc1tyXSgpO2lmKHMpe2NvbnN0IGM9ci5pbmRleE9mKHMpLShyLnN1YnN0cigwLDIpPT09Im9rIj8yOjApO2lmKGM+LTEpe2lmKFModCk9PSJzdHJpbmciKXN3aXRjaCh0LmNoYXJBdCgwKSl7Y2FzZSIrIjpvW2NdKz0rdDticmVhaztjYXNlIi0iOm9bY10rPSt0O2JyZWFrO2Nhc2UiKiI6b1tjXSo9K3Quc3Vic3RyKDEpO2JyZWFrO2Nhc2UiLyI6b1tjXS89K3Quc3Vic3RyKDEpO2JyZWFrO2RlZmF1bHQ6b1tjXT0rdH1lbHNlIGlmKFModCk9PT0ibnVtYmVyIilvW2NdPXQ7ZWxzZSB0aHJvdyBuZXcgRXJyb3IoInVuc3VwcG9ydGVkIHZhbHVlIGZvciBDb2xvci5zZXQiKTtjb25zdCBpPW5ldyBiKG8scik7cmV0dXJuIG4/KHRoaXMuX3JnYj1pLl9yZ2IsdGhpcyk6aX10aHJvdyBuZXcgRXJyb3IoYHVua25vd24gY2hhbm5lbCAke3N9IGluIG1vZGUgJHtyfWApfWVsc2UgcmV0dXJuIG99LGIucHJvdG90eXBlLnRpbnQ9ZnVuY3Rpb24oZT0uNSwuLi50KXtyZXR1cm4gbTAodGhpcywid2hpdGUiLGUsLi4udCl9LGIucHJvdG90eXBlLnNoYWRlPWZ1bmN0aW9uKGU9LjUsLi4udCl7cmV0dXJuIG0wKHRoaXMsImJsYWNrIixlLC4uLnQpfTtjb25zdCBuNj0oZSx0LG4pPT57Y29uc3Qgcj1lLl9yZ2Iscz10Ll9yZ2I7cmV0dXJuIG5ldyBiKHJbMF0rbiooc1swXS1yWzBdKSxyWzFdK24qKHNbMV0tclsxXSksclsyXStuKihzWzJdLXJbMl0pLCJyZ2IiKX07TC5yZ2I9bjY7Y29uc3R7c3FydDpRMCxwb3c6ZjB9PU1hdGgscjY9KGUsdCxuKT0+e2NvbnN0W3IscyxvXT1lLl9yZ2IsW2MsaSxhXT10Ll9yZ2I7cmV0dXJuIG5ldyBiKFEwKGYwKHIsMikqKDEtbikrZjAoYywyKSpuKSxRMChmMChzLDIpKigxLW4pK2YwKGksMikqbiksUTAoZjAobywyKSooMS1uKStmMChhLDIpKm4pLCJyZ2IiKX07TC5scmdiPXI2O2NvbnN0IHM2PShlLHQsbik9Pntjb25zdCByPWUubGFiKCkscz10LmxhYigpO3JldHVybiBuZXcgYihyWzBdK24qKHNbMF0tclswXSksclsxXStuKihzWzFdLXJbMV0pLHJbMl0rbiooc1syXS1yWzJdKSwibGFiIil9O0wubGFiPXM2O3ZhciBsMD0oZSx0LG4scik9PntsZXQgcyxvO3I9PT0iaHNsIj8ocz1lLmhzbCgpLG89dC5oc2woKSk6cj09PSJoc3YiPyhzPWUuaHN2KCksbz10LmhzdigpKTpyPT09ImhjZyI/KHM9ZS5oY2coKSxvPXQuaGNnKCkpOnI9PT0iaHNpIj8ocz1lLmhzaSgpLG89dC5oc2koKSk6cj09PSJsY2gifHxyPT09ImhjbCI/KHI9ImhjbCIscz1lLmhjbCgpLG89dC5oY2woKSk6cj09PSJva2xjaCImJihzPWUub2tsY2goKS5yZXZlcnNlKCksbz10Lm9rbGNoKCkucmV2ZXJzZSgpKTtsZXQgYyxpLGEsZixsLHU7KHIuc3Vic3RyKDAsMSk9PT0iaCJ8fHI9PT0ib2tsY2giKSYmKFtjLGEsbF09cyxbaSxmLHVdPW8pO2xldCBkLHksXyxDO3JldHVybiFpc05hTihjKSYmIWlzTmFOKGkpPyhpPmMmJmktYz4xODA/Qz1pLShjKzM2MCk6aTxjJiZjLWk+MTgwP0M9aSszNjAtYzpDPWktYyx5PWMrbipDKTppc05hTihjKT9pc05hTihpKT95PU51bWJlci5OYU46KHk9aSwobD09MXx8bD09MCkmJnIhPSJoc3YiJiYoZD1mKSk6KHk9YywodT09MXx8dT09MCkmJnIhPSJoc3YiJiYoZD1hKSksZD09PXZvaWQgMCYmKGQ9YStuKihmLWEpKSxfPWwrbioodS1sKSxyPT09Im9rbGNoIj9uZXcgYihbXyxkLHldLHIpOm5ldyBiKFt5LGQsX10scil9O2NvbnN0IEUxPShlLHQsbik9PmwwKGUsdCxuLCJsY2giKTtMLmxjaD1FMSxMLmhjbD1FMTtjb25zdCBvNj0oZSx0LG4pPT57Y29uc3Qgcj1lLm51bSgpLHM9dC5udW0oKTtyZXR1cm4gbmV3IGIocituKihzLXIpLCJudW0iKX07TC5udW09bzY7Y29uc3QgYzY9KGUsdCxuKT0+bDAoZSx0LG4sImhjZyIpO0wuaGNnPWM2O2NvbnN0IGk2PShlLHQsbik9PmwwKGUsdCxuLCJoc2kiKTtMLmhzaT1pNjtjb25zdCBhNj0oZSx0LG4pPT5sMChlLHQsbiwiaHNsIik7TC5oc2w9YTY7Y29uc3QgZjY9KGUsdCxuKT0+bDAoZSx0LG4sImhzdiIpO0wuaHN2PWY2O2NvbnN0IGw2PShlLHQsbik9Pntjb25zdCByPWUub2tsYWIoKSxzPXQub2tsYWIoKTtyZXR1cm4gbmV3IGIoclswXStuKihzWzBdLXJbMF0pLHJbMV0rbiooc1sxXS1yWzFdKSxyWzJdK24qKHNbMl0tclsyXSksIm9rbGFiIil9O0wub2tsYWI9bDY7Y29uc3QgdTY9KGUsdCxuKT0+bDAoZSx0LG4sIm9rbGNoIik7TC5va2xjaD11Njtjb25zdHtwb3c6SjAsc3FydDplMSxQSTp0MSxjb3M6TjEsc2luOkwxLGF0YW4yOmg2fT1NYXRoO3ZhciBiNj0oZSx0PSJscmdiIixuPW51bGwpPT57Y29uc3Qgcj1lLmxlbmd0aDtufHwobj1BcnJheS5mcm9tKG5ldyBBcnJheShyKSkubWFwKCgpPT4xKSk7Y29uc3Qgcz1yL24ucmVkdWNlKGZ1bmN0aW9uKHUsZCl7cmV0dXJuIHUrZH0pO2lmKG4uZm9yRWFjaCgodSxkKT0+e25bZF0qPXN9KSxlPWUubWFwKHU9Pm5ldyBiKHUpKSx0PT09ImxyZ2IiKXJldHVybiBkNihlLG4pO2NvbnN0IG89ZS5zaGlmdCgpLGM9by5nZXQodCksaT1bXTtsZXQgYT0wLGY9MDtmb3IobGV0IHU9MDt1PGMubGVuZ3RoO3UrKylpZihjW3VdPShjW3VdfHwwKSpuWzBdLGkucHVzaChpc05hTihjW3VdKT8wOm5bMF0pLHQuY2hhckF0KHUpPT09ImgiJiYhaXNOYU4oY1t1XSkpe2NvbnN0IGQ9Y1t1XS8xODAqdDE7YSs9TjEoZCkqblswXSxmKz1MMShkKSpuWzBdfWxldCBsPW8uYWxwaGEoKSpuWzBdO2UuZm9yRWFjaCgodSxkKT0+e2NvbnN0IHk9dS5nZXQodCk7bCs9dS5hbHBoYSgpKm5bZCsxXTtmb3IobGV0IF89MDtfPGMubGVuZ3RoO18rKylpZighaXNOYU4oeVtfXSkpaWYoaVtfXSs9bltkKzFdLHQuY2hhckF0KF8pPT09ImgiKXtjb25zdCBDPXlbX10vMTgwKnQxO2ErPU4xKEMpKm5bZCsxXSxmKz1MMShDKSpuW2QrMV19ZWxzZSBjW19dKz15W19dKm5bZCsxXX0pO2ZvcihsZXQgdT0wO3U8Yy5sZW5ndGg7dSsrKWlmKHQuY2hhckF0KHUpPT09ImgiKXtsZXQgZD1oNihmL2lbdV0sYS9pW3VdKS90MSoxODA7Zm9yKDtkPDA7KWQrPTM2MDtmb3IoO2Q+PTM2MDspZC09MzYwO2NbdV09ZH1lbHNlIGNbdV09Y1t1XS9pW3VdO3JldHVybiBsLz1yLG5ldyBiKGMsdCkuYWxwaGEobD4uOTk5OTk/MTpsLCEwKX07Y29uc3QgZDY9KGUsdCk9Pntjb25zdCBuPWUubGVuZ3RoLHI9WzAsMCwwLDBdO2ZvcihsZXQgcz0wO3M8ZS5sZW5ndGg7cysrKXtjb25zdCBvPWVbc10sYz10W3NdL24saT1vLl9yZ2I7clswXSs9SjAoaVswXSwyKSpjLHJbMV0rPUowKGlbMV0sMikqYyxyWzJdKz1KMChpWzJdLDIpKmMsclszXSs9aVszXSpjfXJldHVybiByWzBdPWUxKHJbMF0pLHJbMV09ZTEoclsxXSksclsyXT1lMShyWzJdKSxyWzNdPi45OTk5OTk5JiYoclszXT0xKSxuZXcgYihOKHIpKX0se3BvdzpwNn09TWF0aDtmdW5jdGlvbiBCMChlKXtsZXQgdD0icmdiIixuPU0oIiNjY2MiKSxyPTAscz1bMCwxXSxvPVtdLGM9WzAsMF0saT0hMSxhPVtdLGY9ITEsbD0wLHU9MSxkPSExLHk9e30sXz0hMCxDPTE7Y29uc3QgcD1mdW5jdGlvbihoKXtpZihoPWh8fFsiI2ZmZiIsIiMwMDAiXSxoJiZTKGgpPT09InN0cmluZyImJk0uYnJld2VyJiZNLmJyZXdlcltoLnRvTG93ZXJDYXNlKCldJiYoaD1NLmJyZXdlcltoLnRvTG93ZXJDYXNlKCldKSxTKGgpPT09ImFycmF5Iil7aC5sZW5ndGg9PT0xJiYoaD1baFswXSxoWzBdXSksaD1oLnNsaWNlKDApO2ZvcihsZXQgbT0wO208aC5sZW5ndGg7bSsrKWhbbV09TShoW21dKTtvLmxlbmd0aD0wO2ZvcihsZXQgbT0wO208aC5sZW5ndGg7bSsrKW8ucHVzaChtLyhoLmxlbmd0aC0xKSl9cmV0dXJuICQoKSxhPWh9LGc9ZnVuY3Rpb24oaCl7aWYoaSE9bnVsbCl7Y29uc3QgbT1pLmxlbmd0aC0xO2xldCBrPTA7Zm9yKDtrPG0mJmg+PWlba107KWsrKztyZXR1cm4gay0xfXJldHVybiAwfTtsZXQgQj1oPT5oLEU9aD0+aDtjb25zdCBQPWZ1bmN0aW9uKGgsbSl7bGV0IGssdztpZihtPT1udWxsJiYobT0hMSksaXNOYU4oaCl8fGg9PT1udWxsKXJldHVybiBuO20/dz1oOmkmJmkubGVuZ3RoPjI/dz1nKGgpLyhpLmxlbmd0aC0yKTp1IT09bD93PShoLWwpLyh1LWwpOnc9MSx3PUUodyksbXx8KHc9Qih3KSksQyE9PTEmJih3PXA2KHcsQykpLHc9Y1swXSt3KigxLWNbMF0tY1sxXSksdz16KHcsMCwxKTtjb25zdCBGPU1hdGguZmxvb3IodyoxZTQpO2lmKF8mJnlbRl0paz15W0ZdO2Vsc2V7aWYoUyhhKT09PSJhcnJheSIpZm9yKGxldCB2PTA7djxvLmxlbmd0aDt2Kyspe2NvbnN0IHg9b1t2XTtpZih3PD14KXtrPWFbdl07YnJlYWt9aWYodz49eCYmdj09PW8ubGVuZ3RoLTEpe2s9YVt2XTticmVha31pZih3PngmJnc8b1t2KzFdKXt3PSh3LXgpLyhvW3YrMV0teCksaz1NLmludGVycG9sYXRlKGFbdl0sYVt2KzFdLHcsdCk7YnJlYWt9fWVsc2UgUyhhKT09PSJmdW5jdGlvbiImJihrPWEodykpO18mJih5W0ZdPWspfXJldHVybiBrfTt2YXIgJD0oKT0+eT17fTtwKGUpO2NvbnN0IEE9ZnVuY3Rpb24oaCl7Y29uc3QgbT1NKFAoaCkpO3JldHVybiBmJiZtW2ZdP21bZl0oKTptfTtyZXR1cm4gQS5jbGFzc2VzPWZ1bmN0aW9uKGgpe2lmKGghPW51bGwpe2lmKFMoaCk9PT0iYXJyYXkiKWk9aCxzPVtoWzBdLGhbaC5sZW5ndGgtMV1dO2Vsc2V7Y29uc3QgbT1NLmFuYWx5emUocyk7aD09PTA/aT1bbS5taW4sbS5tYXhdOmk9TS5saW1pdHMobSwiZSIsaCl9cmV0dXJuIEF9cmV0dXJuIGl9LEEuZG9tYWluPWZ1bmN0aW9uKGgpe2lmKCFhcmd1bWVudHMubGVuZ3RoKXJldHVybiBzO2w9aFswXSx1PWhbaC5sZW5ndGgtMV0sbz1bXTtjb25zdCBtPWEubGVuZ3RoO2lmKGgubGVuZ3RoPT09bSYmbCE9PXUpZm9yKGxldCBrIG9mIEFycmF5LmZyb20oaCkpby5wdXNoKChrLWwpLyh1LWwpKTtlbHNle2ZvcihsZXQgaz0wO2s8bTtrKyspby5wdXNoKGsvKG0tMSkpO2lmKGgubGVuZ3RoPjIpe2NvbnN0IGs9aC5tYXAoKEYsdik9PnYvKGgubGVuZ3RoLTEpKSx3PWgubWFwKEY9PihGLWwpLyh1LWwpKTt3LmV2ZXJ5KChGLHYpPT5rW3ZdPT09Ril8fChFPUY9PntpZihGPD0wfHxGPj0xKXJldHVybiBGO2xldCB2PTA7Zm9yKDtGPj13W3YrMV07KXYrKztjb25zdCB4PShGLXdbdl0pLyh3W3YrMV0td1t2XSk7cmV0dXJuIGtbdl0reCooa1t2KzFdLWtbdl0pfSl9fXJldHVybiBzPVtsLHVdLEF9LEEubW9kZT1mdW5jdGlvbihoKXtyZXR1cm4gYXJndW1lbnRzLmxlbmd0aD8odD1oLCQoKSxBKTp0fSxBLnJhbmdlPWZ1bmN0aW9uKGgsbSl7cmV0dXJuIHAoaCksQX0sQS5vdXQ9ZnVuY3Rpb24oaCl7cmV0dXJuIGY9aCxBfSxBLnNwcmVhZD1mdW5jdGlvbihoKXtyZXR1cm4gYXJndW1lbnRzLmxlbmd0aD8ocj1oLEEpOnJ9LEEuY29ycmVjdExpZ2h0bmVzcz1mdW5jdGlvbihoKXtyZXR1cm4gaD09bnVsbCYmKGg9ITApLGQ9aCwkKCksZD9CPWZ1bmN0aW9uKG0pe2NvbnN0IGs9UCgwLCEwKS5sYWIoKVswXSx3PVAoMSwhMCkubGFiKClbMF0sRj1rPnc7bGV0IHY9UChtLCEwKS5sYWIoKVswXTtjb25zdCB4PWsrKHctaykqbTtsZXQgRD12LXgsSD0wLFk9MSxYPTIwO2Zvcig7TWF0aC5hYnMoRCk+LjAxJiZYLS0gPjA7KShmdW5jdGlvbigpe3JldHVybiBGJiYoRCo9LTEpLEQ8MD8oSD1tLG0rPShZLW0pKi41KTooWT1tLG0rPShILW0pKi41KSx2PVAobSwhMCkubGFiKClbMF0sRD12LXh9KSgpO3JldHVybiBtfTpCPW09Pm0sQX0sQS5wYWRkaW5nPWZ1bmN0aW9uKGgpe3JldHVybiBoIT1udWxsPyhTKGgpPT09Im51bWJlciImJihoPVtoLGhdKSxjPWgsQSk6Y30sQS5jb2xvcnM9ZnVuY3Rpb24oaCxtKXthcmd1bWVudHMubGVuZ3RoPDImJihtPSJoZXgiKTtsZXQgaz1bXTtpZihhcmd1bWVudHMubGVuZ3RoPT09MClrPWEuc2xpY2UoMCk7ZWxzZSBpZihoPT09MSlrPVtBKC41KV07ZWxzZSBpZihoPjEpe2NvbnN0IHc9c1swXSxGPXNbMV0tdztrPWc2KDAsaCkubWFwKHY9PkEodyt2LyhoLTEpKkYpKX1lbHNle2U9W107bGV0IHc9W107aWYoaSYmaS5sZW5ndGg+Milmb3IobGV0IEY9MSx2PWkubGVuZ3RoLHg9MTw9djt4P0Y8djpGPnY7eD9GKys6Ri0tKXcucHVzaCgoaVtGLTFdK2lbRl0pKi41KTtlbHNlIHc9cztrPXcubWFwKEY9PkEoRikpfXJldHVybiBNW21dJiYoaz1rLm1hcCh3PT53W21dKCkpKSxrfSxBLmNhY2hlPWZ1bmN0aW9uKGgpe3JldHVybiBoIT1udWxsPyhfPWgsQSk6X30sQS5nYW1tYT1mdW5jdGlvbihoKXtyZXR1cm4gaCE9bnVsbD8oQz1oLEEpOkN9LEEubm9kYXRhPWZ1bmN0aW9uKGgpe3JldHVybiBoIT1udWxsPyhuPU0oaCksQSk6bn0sQX1mdW5jdGlvbiBnNihlLHQsbil7bGV0IHI9W10scz1lPHQsbz10O2ZvcihsZXQgYz1lO3M/YzxvOmM+bztzP2MrKzpjLS0pci5wdXNoKGMpO3JldHVybiByfWNvbnN0IG02PWZ1bmN0aW9uKGUpe2xldCB0PVsxLDFdO2ZvcihsZXQgbj0xO248ZTtuKyspe2xldCByPVsxXTtmb3IobGV0IHM9MTtzPD10Lmxlbmd0aDtzKyspcltzXT0odFtzXXx8MCkrdFtzLTFdO3Q9cn1yZXR1cm4gdH0sdzY9ZnVuY3Rpb24oZSl7bGV0IHQsbixyLHM7aWYoZT1lLm1hcChvPT5uZXcgYihvKSksZS5sZW5ndGg9PT0yKVtuLHJdPWUubWFwKG89Pm8ubGFiKCkpLHQ9ZnVuY3Rpb24obyl7Y29uc3QgYz1bMCwxLDJdLm1hcChpPT5uW2ldK28qKHJbaV0tbltpXSkpO3JldHVybiBuZXcgYihjLCJsYWIiKX07ZWxzZSBpZihlLmxlbmd0aD09PTMpW24scixzXT1lLm1hcChvPT5vLmxhYigpKSx0PWZ1bmN0aW9uKG8pe2NvbnN0IGM9WzAsMSwyXS5tYXAoaT0+KDEtbykqKDEtbykqbltpXSsyKigxLW8pKm8qcltpXStvKm8qc1tpXSk7cmV0dXJuIG5ldyBiKGMsImxhYiIpfTtlbHNlIGlmKGUubGVuZ3RoPT09NCl7bGV0IG87W24scixzLG9dPWUubWFwKGM9PmMubGFiKCkpLHQ9ZnVuY3Rpb24oYyl7Y29uc3QgaT1bMCwxLDJdLm1hcChhPT4oMS1jKSooMS1jKSooMS1jKSpuW2FdKzMqKDEtYykqKDEtYykqYypyW2FdKzMqKDEtYykqYypjKnNbYV0rYypjKmMqb1thXSk7cmV0dXJuIG5ldyBiKGksImxhYiIpfX1lbHNlIGlmKGUubGVuZ3RoPj01KXtsZXQgbyxjLGk7bz1lLm1hcChhPT5hLmxhYigpKSxpPWUubGVuZ3RoLTEsYz1tNihpKSx0PWZ1bmN0aW9uKGEpe2NvbnN0IGY9MS1hLGw9WzAsMSwyXS5tYXAodT0+by5yZWR1Y2UoKGQseSxfKT0+ZCtjW19dKmYqKihpLV8pKmEqKl8qeVt1XSwwKSk7cmV0dXJuIG5ldyBiKGwsImxhYiIpfX1lbHNlIHRocm93IG5ldyBSYW5nZUVycm9yKCJObyBwb2ludCBpbiBydW5uaW5nIGJlemllciB3aXRoIG9ubHkgb25lIGNvbG9yLiIpO3JldHVybiB0fTt2YXIgeTY9ZT0+e2NvbnN0IHQ9dzYoZSk7cmV0dXJuIHQuc2NhbGU9KCk9PkIwKHQpLHR9O2NvbnN0IFU9KGUsdCxuKT0+e2lmKCFVW25dKXRocm93IG5ldyBFcnJvcigidW5rbm93biBibGVuZCBtb2RlICIrbik7cmV0dXJuIFVbbl0oZSx0KX0sUT1lPT4odCxuKT0+e2NvbnN0IHI9TShuKS5yZ2IoKSxzPU0odCkucmdiKCk7cmV0dXJuIE0ucmdiKGUocixzKSl9LEo9ZT0+KHQsbik9Pntjb25zdCByPVtdO3JldHVybiByWzBdPWUodFswXSxuWzBdKSxyWzFdPWUodFsxXSxuWzFdKSxyWzJdPWUodFsyXSxuWzJdKSxyfSxfNj1lPT5lLGs2PShlLHQpPT5lKnQvMjU1LE02PShlLHQpPT5lPnQ/dDplLEE2PShlLHQpPT5lPnQ/ZTp0LEM2PShlLHQpPT4yNTUqKDEtKDEtZS8yNTUpKigxLXQvMjU1KSksdjY9KGUsdCk9PnQ8MTI4PzIqZSp0LzI1NToyNTUqKDEtMiooMS1lLzI1NSkqKDEtdC8yNTUpKSxSNj0oZSx0KT0+MjU1KigxLSgxLXQvMjU1KS8oZS8yNTUpKSxTNj0oZSx0KT0+ZT09PTI1NT8yNTU6KGU9MjU1Kih0LzI1NSkvKDEtZS8yNTUpLGU+MjU1PzI1NTplKTtVLm5vcm1hbD1RKEooXzYpKSxVLm11bHRpcGx5PVEoSihrNikpLFUuc2NyZWVuPVEoSihDNikpLFUub3ZlcmxheT1RKEoodjYpKSxVLmRhcmtlbj1RKEooTTYpKSxVLmxpZ2h0ZW49UShKKEE2KSksVS5kb2RnZT1RKEooUzYpKSxVLmJ1cm49UShKKFI2KSk7Y29uc3R7cG93OkY2LHNpbjpJNixjb3M6eDZ9PU1hdGg7ZnVuY3Rpb24gQjYoZT0zMDAsdD0tMS41LG49MSxyPTEscz1bMCwxXSl7bGV0IG89MCxjO1Mocyk9PT0iYXJyYXkiP2M9c1sxXS1zWzBdOihjPTAscz1bcyxzXSk7Y29uc3QgaT1mdW5jdGlvbihhKXtjb25zdCBmPVYqKChlKzEyMCkvMzYwK3QqYSksbD1GNihzWzBdK2MqYSxyKSxkPShvIT09MD9uWzBdK2EqbzpuKSpsKigxLWwpLzIseT14NihmKSxfPUk2KGYpLEM9bCtkKigtLjE0ODYxKnkrMS43ODI3NypfKSxwPWwrZCooLS4yOTIyNyp5LS45MDY0OSpfKSxnPWwrZCooMS45NzI5NCp5KTtyZXR1cm4gTShOKFtDKjI1NSxwKjI1NSxnKjI1NSwxXSkpfTtyZXR1cm4gaS5zdGFydD1mdW5jdGlvbihhKXtyZXR1cm4gYT09bnVsbD9lOihlPWEsaSl9LGkucm90YXRpb25zPWZ1bmN0aW9uKGEpe3JldHVybiBhPT1udWxsP3Q6KHQ9YSxpKX0saS5nYW1tYT1mdW5jdGlvbihhKXtyZXR1cm4gYT09bnVsbD9yOihyPWEsaSl9LGkuaHVlPWZ1bmN0aW9uKGEpe3JldHVybiBhPT1udWxsP246KG49YSxTKG4pPT09ImFycmF5Ij8obz1uWzFdLW5bMF0sbz09PTAmJihuPW5bMV0pKTpvPTAsaSl9LGkubGlnaHRuZXNzPWZ1bmN0aW9uKGEpe3JldHVybiBhPT1udWxsP3M6KFMoYSk9PT0iYXJyYXkiPyhzPWEsYz1hWzFdLWFbMF0pOihzPVthLGFdLGM9MCksaSl9LGkuc2NhbGU9KCk9Pk0uc2NhbGUoaSksaS5odWUobiksaX1jb25zdCB6Nj0iMDEyMzQ1Njc4OWFiY2RlZiIse2Zsb29yOlA2LHJhbmRvbTokNn09TWF0aDt2YXIgVDY9KCk9PntsZXQgZT0iIyI7Zm9yKGxldCB0PTA7dDw2O3QrKyllKz16Ni5jaGFyQXQoUDYoJDYoKSoxNikpO3JldHVybiBuZXcgYihlLCJoZXgiKX07Y29uc3R7bG9nOkQxLHBvdzpFNixmbG9vcjpONixhYnM6TDZ9PU1hdGg7ZnVuY3Rpb24gRzEoZSx0PW51bGwpe2NvbnN0IG49e21pbjpOdW1iZXIuTUFYX1ZBTFVFLG1heDpOdW1iZXIuTUFYX1ZBTFVFKi0xLHN1bTowLHZhbHVlczpbXSxjb3VudDowfTtyZXR1cm4gUyhlKT09PSJvYmplY3QiJiYoZT1PYmplY3QudmFsdWVzKGUpKSxlLmZvckVhY2gocj0+e3QmJlMocik9PT0ib2JqZWN0IiYmKHI9clt0XSksciE9bnVsbCYmIWlzTmFOKHIpJiYobi52YWx1ZXMucHVzaChyKSxuLnN1bSs9cixyPG4ubWluJiYobi5taW49cikscj5uLm1heCYmKG4ubWF4PXIpLG4uY291bnQrPTEpfSksbi5kb21haW49W24ubWluLG4ubWF4XSxuLmxpbWl0cz0ocixzKT0+cTEobixyLHMpLG59ZnVuY3Rpb24gcTEoZSx0PSJlcXVhbCIsbj03KXtTKGUpPT0iYXJyYXkiJiYoZT1HMShlKSk7Y29uc3R7bWluOnIsbWF4OnN9PWUsbz1lLnZhbHVlcy5zb3J0KChpLGEpPT5pLWEpO2lmKG49PT0xKXJldHVybltyLHNdO2NvbnN0IGM9W107aWYodC5zdWJzdHIoMCwxKT09PSJjIiYmKGMucHVzaChyKSxjLnB1c2gocykpLHQuc3Vic3RyKDAsMSk9PT0iZSIpe2MucHVzaChyKTtmb3IobGV0IGk9MTtpPG47aSsrKWMucHVzaChyK2kvbioocy1yKSk7Yy5wdXNoKHMpfWVsc2UgaWYodC5zdWJzdHIoMCwxKT09PSJsIil7aWYocjw9MCl0aHJvdyBuZXcgRXJyb3IoIkxvZ2FyaXRobWljIHNjYWxlcyBhcmUgb25seSBwb3NzaWJsZSBmb3IgdmFsdWVzID4gMCIpO2NvbnN0IGk9TWF0aC5MT0cxMEUqRDEociksYT1NYXRoLkxPRzEwRSpEMShzKTtjLnB1c2gocik7Zm9yKGxldCBmPTE7ZjxuO2YrKyljLnB1c2goRTYoMTAsaStmL24qKGEtaSkpKTtjLnB1c2gocyl9ZWxzZSBpZih0LnN1YnN0cigwLDEpPT09InEiKXtjLnB1c2gocik7Zm9yKGxldCBpPTE7aTxuO2krKyl7Y29uc3QgYT0oby5sZW5ndGgtMSkqaS9uLGY9TjYoYSk7aWYoZj09PWEpYy5wdXNoKG9bZl0pO2Vsc2V7Y29uc3QgbD1hLWY7Yy5wdXNoKG9bZl0qKDEtbCkrb1tmKzFdKmwpfX1jLnB1c2gocyl9ZWxzZSBpZih0LnN1YnN0cigwLDEpPT09ImsiKXtsZXQgaTtjb25zdCBhPW8ubGVuZ3RoLGY9bmV3IEFycmF5KGEpLGw9bmV3IEFycmF5KG4pO2xldCB1PSEwLGQ9MCx5PW51bGw7eT1bXSx5LnB1c2gocik7Zm9yKGxldCBwPTE7cDxuO3ArKyl5LnB1c2gocitwL24qKHMtcikpO2Zvcih5LnB1c2gocyk7dTspe2ZvcihsZXQgZz0wO2c8bjtnKyspbFtnXT0wO2ZvcihsZXQgZz0wO2c8YTtnKyspe2NvbnN0IEI9b1tnXTtsZXQgRT1OdW1iZXIuTUFYX1ZBTFVFLFA7Zm9yKGxldCAkPTA7JDxuOyQrKyl7Y29uc3QgQT1MNih5WyRdLUIpO0E8RSYmKEU9QSxQPSQpLGxbUF0rKyxmW2ddPVB9fWNvbnN0IHA9bmV3IEFycmF5KG4pO2ZvcihsZXQgZz0wO2c8bjtnKyspcFtnXT1udWxsO2ZvcihsZXQgZz0wO2c8YTtnKyspaT1mW2ddLHBbaV09PT1udWxsP3BbaV09b1tnXTpwW2ldKz1vW2ddO2ZvcihsZXQgZz0wO2c8bjtnKyspcFtnXSo9MS9sW2ddO3U9ITE7Zm9yKGxldCBnPTA7ZzxuO2crKylpZihwW2ddIT09eVtnXSl7dT0hMDticmVha315PXAsZCsrLGQ+MjAwJiYodT0hMSl9Y29uc3QgXz17fTtmb3IobGV0IHA9MDtwPG47cCsrKV9bcF09W107Zm9yKGxldCBwPTA7cDxhO3ArKylpPWZbcF0sX1tpXS5wdXNoKG9bcF0pO2xldCBDPVtdO2ZvcihsZXQgcD0wO3A8bjtwKyspQy5wdXNoKF9bcF1bMF0pLEMucHVzaChfW3BdW19bcF0ubGVuZ3RoLTFdKTtDPUMuc29ydCgocCxnKT0+cC1nKSxjLnB1c2goQ1swXSk7Zm9yKGxldCBwPTE7cDxDLmxlbmd0aDtwKz0yKXtjb25zdCBnPUNbcF07IWlzTmFOKGcpJiZjLmluZGV4T2YoZyk9PT0tMSYmYy5wdXNoKGcpfX1yZXR1cm4gY312YXIgRDY9KGUsdCk9PntlPW5ldyBiKGUpLHQ9bmV3IGIodCk7Y29uc3Qgbj1lLmx1bWluYW5jZSgpLHI9dC5sdW1pbmFuY2UoKTtyZXR1cm4gbj5yPyhuKy4wNSkvKHIrLjA1KToocisuMDUpLyhuKy4wNSl9O2NvbnN0e3NxcnQ6Syxwb3c6VCxtaW46RzYsbWF4OnE2LGF0YW4yOlcxLGFiczpqMSxjb3M6ejAsc2luOkgxLGV4cDpXNixQSTpPMX09TWF0aDtmdW5jdGlvbiBqNihlLHQsbj0xLHI9MSxzPTEpe3ZhciBvPWZ1bmN0aW9uKFope3JldHVybiAzNjAqWi8oMipPMSl9LGM9ZnVuY3Rpb24oWil7cmV0dXJuIDIqTzEqWi8zNjB9O2U9bmV3IGIoZSksdD1uZXcgYih0KTtjb25zdFtpLGEsZl09QXJyYXkuZnJvbShlLmxhYigpKSxbbCx1LGRdPUFycmF5LmZyb20odC5sYWIoKSkseT0oaStsKS8yLF89SyhUKGEsMikrVChmLDIpKSxDPUsoVCh1LDIpK1QoZCwyKSkscD0oXytDKS8yLGc9LjUqKDEtSyhUKHAsNykvKFQocCw3KStUKDI1LDcpKSkpLEI9YSooMStnKSxFPXUqKDErZyksUD1LKFQoQiwyKStUKGYsMikpLCQ9SyhUKEUsMikrVChkLDIpKSxBPShQKyQpLzIsaD1vKFcxKGYsQikpLG09byhXMShkLEUpKSxrPWg+PTA/aDpoKzM2MCx3PW0+PTA/bTptKzM2MCxGPWoxKGstdyk+MTgwPyhrK3crMzYwKS8yOihrK3cpLzIsdj0xLS4xNyp6MChjKEYtMzApKSsuMjQqejAoYygyKkYpKSsuMzIqejAoYygzKkYrNikpLS4yKnowKGMoNCpGLTYzKSk7bGV0IHg9dy1rO3g9ajEoeCk8PTE4MD94Onc8PWs/eCszNjA6eC0zNjAseD0yKksoUCokKSpIMShjKHgpLzIpO2NvbnN0IEQ9bC1pLEg9JC1QLFk9MSsuMDE1KlQoeS01MCwyKS9LKDIwK1QoeS01MCwyKSksWD0xKy4wNDUqQSx0MD0xKy4wMTUqQSp2LHMwPTMwKlc2KC1UKChGLTI3NSkvMjUsMikpLG8wPS0oMipLKFQoQSw3KS8oVChBLDcpK1QoMjUsNykpKSkqSDEoMipjKHMwKSksYzA9SyhUKEQvKG4qWSksMikrVChILyhyKlgpLDIpK1QoeC8ocyp0MCksMikrbzAqKEgvKHIqWCkpKih4LyhzKnQwKSkpO3JldHVybiBxNigwLEc2KDEwMCxjMCkpfWZ1bmN0aW9uIEg2KGUsdCxuPSJsYWIiKXtlPW5ldyBiKGUpLHQ9bmV3IGIodCk7Y29uc3Qgcj1lLmdldChuKSxzPXQuZ2V0KG4pO2xldCBvPTA7Zm9yKGxldCBjIGluIHIpe2NvbnN0IGk9KHJbY118fDApLShzW2NdfHwwKTtvKz1pKml9cmV0dXJuIE1hdGguc3FydChvKX12YXIgTzY9KC4uLmUpPT57dHJ5e3JldHVybiBuZXcgYiguLi5lKSwhMH1jYXRjaHtyZXR1cm4hMX19LFk2PXtjb29sKCl7cmV0dXJuIEIwKFtNLmhzbCgxODAsMSwuOSksTS5oc2woMjUwLC43LC40KV0pfSxob3QoKXtyZXR1cm4gQjAoWyIjMDAwIiwiI2YwMCIsIiNmZjAiLCIjZmZmIl0pLm1vZGUoInJnYiIpfX07Y29uc3QgUDA9e09yUmQ6WyIjZmZmN2VjIiwiI2ZlZThjOCIsIiNmZGQ0OWUiLCIjZmRiYjg0IiwiI2ZjOGQ1OSIsIiNlZjY1NDgiLCIjZDczMDFmIiwiI2IzMDAwMCIsIiM3ZjAwMDAiXSxQdUJ1OlsiI2ZmZjdmYiIsIiNlY2U3ZjIiLCIjZDBkMWU2IiwiI2E2YmRkYiIsIiM3NGE5Y2YiLCIjMzY5MGMwIiwiIzA1NzBiMCIsIiMwNDVhOGQiLCIjMDIzODU4Il0sQnVQdTpbIiNmN2ZjZmQiLCIjZTBlY2Y0IiwiI2JmZDNlNiIsIiM5ZWJjZGEiLCIjOGM5NmM2IiwiIzhjNmJiMSIsIiM4ODQxOWQiLCIjODEwZjdjIiwiIzRkMDA0YiJdLE9yYW5nZXM6WyIjZmZmNWViIiwiI2ZlZTZjZSIsIiNmZGQwYTIiLCIjZmRhZTZiIiwiI2ZkOGQzYyIsIiNmMTY5MTMiLCIjZDk0ODAxIiwiI2E2MzYwMyIsIiM3ZjI3MDQiXSxCdUduOlsiI2Y3ZmNmZCIsIiNlNWY1ZjkiLCIjY2NlY2U2IiwiIzk5ZDhjOSIsIiM2NmMyYTQiLCIjNDFhZTc2IiwiIzIzOGI0NSIsIiMwMDZkMmMiLCIjMDA0NDFiIl0sWWxPckJyOlsiI2ZmZmZlNSIsIiNmZmY3YmMiLCIjZmVlMzkxIiwiI2ZlYzQ0ZiIsIiNmZTk5MjkiLCIjZWM3MDE0IiwiI2NjNGMwMiIsIiM5OTM0MDQiLCIjNjYyNTA2Il0sWWxHbjpbIiNmZmZmZTUiLCIjZjdmY2I5IiwiI2Q5ZjBhMyIsIiNhZGRkOGUiLCIjNzhjNjc5IiwiIzQxYWI1ZCIsIiMyMzg0NDMiLCIjMDA2ODM3IiwiIzAwNDUyOSJdLFJlZHM6WyIjZmZmNWYwIiwiI2ZlZTBkMiIsIiNmY2JiYTEiLCIjZmM5MjcyIiwiI2ZiNmE0YSIsIiNlZjNiMmMiLCIjY2IxODFkIiwiI2E1MGYxNSIsIiM2NzAwMGQiXSxSZFB1OlsiI2ZmZjdmMyIsIiNmZGUwZGQiLCIjZmNjNWMwIiwiI2ZhOWZiNSIsIiNmNzY4YTEiLCIjZGQzNDk3IiwiI2FlMDE3ZSIsIiM3YTAxNzciLCIjNDkwMDZhIl0sR3JlZW5zOlsiI2Y3ZmNmNSIsIiNlNWY1ZTAiLCIjYzdlOWMwIiwiI2ExZDk5YiIsIiM3NGM0NzYiLCIjNDFhYjVkIiwiIzIzOGI0NSIsIiMwMDZkMmMiLCIjMDA0NDFiIl0sWWxHbkJ1OlsiI2ZmZmZkOSIsIiNlZGY4YjEiLCIjYzdlOWI0IiwiIzdmY2RiYiIsIiM0MWI2YzQiLCIjMWQ5MWMwIiwiIzIyNWVhOCIsIiMyNTM0OTQiLCIjMDgxZDU4Il0sUHVycGxlczpbIiNmY2ZiZmQiLCIjZWZlZGY1IiwiI2RhZGFlYiIsIiNiY2JkZGMiLCIjOWU5YWM4IiwiIzgwN2RiYSIsIiM2YTUxYTMiLCIjNTQyNzhmIiwiIzNmMDA3ZCJdLEduQnU6WyIjZjdmY2YwIiwiI2UwZjNkYiIsIiNjY2ViYzUiLCIjYThkZGI1IiwiIzdiY2NjNCIsIiM0ZWIzZDMiLCIjMmI4Y2JlIiwiIzA4NjhhYyIsIiMwODQwODEiXSxHcmV5czpbIiNmZmZmZmYiLCIjZjBmMGYwIiwiI2Q5ZDlkOSIsIiNiZGJkYmQiLCIjOTY5Njk2IiwiIzczNzM3MyIsIiM1MjUyNTIiLCIjMjUyNTI1IiwiIzAwMDAwMCJdLFlsT3JSZDpbIiNmZmZmY2MiLCIjZmZlZGEwIiwiI2ZlZDk3NiIsIiNmZWIyNGMiLCIjZmQ4ZDNjIiwiI2ZjNGUyYSIsIiNlMzFhMWMiLCIjYmQwMDI2IiwiIzgwMDAyNiJdLFB1UmQ6WyIjZjdmNGY5IiwiI2U3ZTFlZiIsIiNkNGI5ZGEiLCIjYzk5NGM3IiwiI2RmNjViMCIsIiNlNzI5OGEiLCIjY2UxMjU2IiwiIzk4MDA0MyIsIiM2NzAwMWYiXSxCbHVlczpbIiNmN2ZiZmYiLCIjZGVlYmY3IiwiI2M2ZGJlZiIsIiM5ZWNhZTEiLCIjNmJhZWQ2IiwiIzQyOTJjNiIsIiMyMTcxYjUiLCIjMDg1MTljIiwiIzA4MzA2YiJdLFB1QnVHbjpbIiNmZmY3ZmIiLCIjZWNlMmYwIiwiI2QwZDFlNiIsIiNhNmJkZGIiLCIjNjdhOWNmIiwiIzM2OTBjMCIsIiMwMjgxOGEiLCIjMDE2YzU5IiwiIzAxNDYzNiJdLFZpcmlkaXM6WyIjNDQwMTU0IiwiIzQ4Mjc3NyIsIiMzZjRhOGEiLCIjMzE2NzhlIiwiIzI2ODM4ZiIsIiMxZjlkOGEiLCIjNmNjZTVhIiwiI2I2ZGUyYiIsIiNmZWU4MjUiXSxTcGVjdHJhbDpbIiM5ZTAxNDIiLCIjZDUzZTRmIiwiI2Y0NmQ0MyIsIiNmZGFlNjEiLCIjZmVlMDhiIiwiI2ZmZmZiZiIsIiNlNmY1OTgiLCIjYWJkZGE0IiwiIzY2YzJhNSIsIiMzMjg4YmQiLCIjNWU0ZmEyIl0sUmRZbEduOlsiI2E1MDAyNiIsIiNkNzMwMjciLCIjZjQ2ZDQzIiwiI2ZkYWU2MSIsIiNmZWUwOGIiLCIjZmZmZmJmIiwiI2Q5ZWY4YiIsIiNhNmQ5NmEiLCIjNjZiZDYzIiwiIzFhOTg1MCIsIiMwMDY4MzciXSxSZEJ1OlsiIzY3MDAxZiIsIiNiMjE4MmIiLCIjZDY2MDRkIiwiI2Y0YTU4MiIsIiNmZGRiYzciLCIjZjdmN2Y3IiwiI2QxZTVmMCIsIiM5MmM1ZGUiLCIjNDM5M2MzIiwiIzIxNjZhYyIsIiMwNTMwNjEiXSxQaVlHOlsiIzhlMDE1MiIsIiNjNTFiN2QiLCIjZGU3N2FlIiwiI2YxYjZkYSIsIiNmZGUwZWYiLCIjZjdmN2Y3IiwiI2U2ZjVkMCIsIiNiOGUxODYiLCIjN2ZiYzQxIiwiIzRkOTIyMSIsIiMyNzY0MTkiXSxQUkduOlsiIzQwMDA0YiIsIiM3NjJhODMiLCIjOTk3MGFiIiwiI2MyYTVjZiIsIiNlN2Q0ZTgiLCIjZjdmN2Y3IiwiI2Q5ZjBkMyIsIiNhNmRiYTAiLCIjNWFhZTYxIiwiIzFiNzgzNyIsIiMwMDQ0MWIiXSxSZFlsQnU6WyIjYTUwMDI2IiwiI2Q3MzAyNyIsIiNmNDZkNDMiLCIjZmRhZTYxIiwiI2ZlZTA5MCIsIiNmZmZmYmYiLCIjZTBmM2Y4IiwiI2FiZDllOSIsIiM3NGFkZDEiLCIjNDU3NWI0IiwiIzMxMzY5NSJdLEJyQkc6WyIjNTQzMDA1IiwiIzhjNTEwYSIsIiNiZjgxMmQiLCIjZGZjMjdkIiwiI2Y2ZThjMyIsIiNmNWY1ZjUiLCIjYzdlYWU1IiwiIzgwY2RjMSIsIiMzNTk3OGYiLCIjMDE2NjVlIiwiIzAwM2MzMCJdLFJkR3k6WyIjNjcwMDFmIiwiI2IyMTgyYiIsIiNkNjYwNGQiLCIjZjRhNTgyIiwiI2ZkZGJjNyIsIiNmZmZmZmYiLCIjZTBlMGUwIiwiI2JhYmFiYSIsIiM4Nzg3ODciLCIjNGQ0ZDRkIiwiIzFhMWExYSJdLFB1T3I6WyIjN2YzYjA4IiwiI2IzNTgwNiIsIiNlMDgyMTQiLCIjZmRiODYzIiwiI2ZlZTBiNiIsIiNmN2Y3ZjciLCIjZDhkYWViIiwiI2IyYWJkMiIsIiM4MDczYWMiLCIjNTQyNzg4IiwiIzJkMDA0YiJdLFNldDI6WyIjNjZjMmE1IiwiI2ZjOGQ2MiIsIiM4ZGEwY2IiLCIjZTc4YWMzIiwiI2E2ZDg1NCIsIiNmZmQ5MmYiLCIjZTVjNDk0IiwiI2IzYjNiMyJdLEFjY2VudDpbIiM3ZmM5N2YiLCIjYmVhZWQ0IiwiI2ZkYzA4NiIsIiNmZmZmOTkiLCIjMzg2Y2IwIiwiI2YwMDI3ZiIsIiNiZjViMTciLCIjNjY2NjY2Il0sU2V0MTpbIiNlNDFhMWMiLCIjMzc3ZWI4IiwiIzRkYWY0YSIsIiM5ODRlYTMiLCIjZmY3ZjAwIiwiI2ZmZmYzMyIsIiNhNjU2MjgiLCIjZjc4MWJmIiwiIzk5OTk5OSJdLFNldDM6WyIjOGRkM2M3IiwiI2ZmZmZiMyIsIiNiZWJhZGEiLCIjZmI4MDcyIiwiIzgwYjFkMyIsIiNmZGI0NjIiLCIjYjNkZTY5IiwiI2ZjY2RlNSIsIiNkOWQ5ZDkiLCIjYmM4MGJkIiwiI2NjZWJjNSIsIiNmZmVkNmYiXSxEYXJrMjpbIiMxYjllNzciLCIjZDk1ZjAyIiwiIzc1NzBiMyIsIiNlNzI5OGEiLCIjNjZhNjFlIiwiI2U2YWIwMiIsIiNhNjc2MWQiLCIjNjY2NjY2Il0sUGFpcmVkOlsiI2E2Y2VlMyIsIiMxZjc4YjQiLCIjYjJkZjhhIiwiIzMzYTAyYyIsIiNmYjlhOTkiLCIjZTMxYTFjIiwiI2ZkYmY2ZiIsIiNmZjdmMDAiLCIjY2FiMmQ2IiwiIzZhM2Q5YSIsIiNmZmZmOTkiLCIjYjE1OTI4Il0sUGFzdGVsMjpbIiNiM2UyY2QiLCIjZmRjZGFjIiwiI2NiZDVlOCIsIiNmNGNhZTQiLCIjZTZmNWM5IiwiI2ZmZjJhZSIsIiNmMWUyY2MiLCIjY2NjY2NjIl0sUGFzdGVsMTpbIiNmYmI0YWUiLCIjYjNjZGUzIiwiI2NjZWJjNSIsIiNkZWNiZTQiLCIjZmVkOWE2IiwiI2ZmZmZjYyIsIiNlNWQ4YmQiLCIjZmRkYWVjIiwiI2YyZjJmMiJdfTtmb3IobGV0IGUgb2YgT2JqZWN0LmtleXMoUDApKVAwW2UudG9Mb3dlckNhc2UoKV09UDBbZV07T2JqZWN0LmFzc2lnbihNLHthdmVyYWdlOmI2LGJlemllcjp5NixibGVuZDpVLGN1YmVoZWxpeDpCNixtaXg6bTAsaW50ZXJwb2xhdGU6bTAscmFuZG9tOlQ2LHNjYWxlOkIwLGFuYWx5emU6RzEsY29udHJhc3Q6RDYsZGVsdGFFOmo2LGRpc3RhbmNlOkg2LGxpbWl0czpxMSx2YWxpZDpPNixzY2FsZXM6WTYsaW5wdXQ6Uixjb2xvcnM6YTAsYnJld2VyOlAwfSk7Y29uc3QgVTY9W1suMDA0NTI4LC4wMDQzNDEsLjAwNDMwN10sWy4wMDU2MjUsLjAwNjE1NiwuMDA2MDFdLFsuMDA2NjI4LC4wMDgyOTMsLjAwODE2MV0sWy4wMDc1NTEsLjAxMDczOCwuMDEwNzldLFsuMDA4MzgyLC4wMTM0ODIsLjAxMzk0MV0sWy4wMDkxMTEsLjAxNjUyLC4wMTc2NjJdLFsuMDA5NzI3LC4wMTk4NDYsLjAyMjAwOV0sWy4wMTAyMjMsLjAyMzQ1MiwuMDI3MDM1XSxbLjAxMDU5MywuMDI3MzMxLC4wMzI3OTldLFsuMDEwODMzLC4wMzE0NzUsLjAzOTM2MV0sWy4wMTA5NDEsLjAzNTg3NSwuMDQ2NDE1XSxbLjAxMDkxOCwuMDQwNTIsLjA1MzU5N10sWy4wMTA3NjgsLjA0NTE1OCwuMDYwOTE0XSxbLjAxMDQ5MiwuMDQ5NzA4LC4wNjgzNjddLFsuMDEwMDk4LC4wNTQxNzEsLjA3NTk1NF0sWy4wMDk1OTQsLjA1ODU0OSwuMDgzNjcyXSxbLjAwODk4OSwuMDYyODQsLjA5MTUyMV0sWy4wMDgyOTcsLjA2NzA0NiwuMDk5NDk5XSxbLjAwNzUzLC4wNzExNjUsLjEwNzYwM10sWy4wMDY3MDQsLjA3NTE5NiwuMTE1ODNdLFsuMDA1ODM4LC4wNzkxNCwuMTI0MTc4XSxbLjAwNDk0OSwuMDgyOTk0LC4xMzI2NDNdLFsuMDA0MDYyLC4wODY3NTgsLjE0MTIyM10sWy4wMDMxOTgsLjA5MDQzLC4xNDk5MTNdLFsuMDAyMzgyLC4wOTQwMSwuMTU4NzExXSxbLjAwMTY0MywuMDk3NDk0LC4xNjc2MTJdLFsuMDAxMDA5LC4xMDA4ODMsLjE3NjYxMl0sWzUxNGUtNiwuMTA0MTc0LC4xODU3MDRdLFsxODdlLTYsLjEwNzM2NiwuMTk0ODg2XSxbNjZlLTYsLjExMDQ1NywuMjA0MTUxXSxbMTg2ZS02LC4xMTM0NDUsLjIxMzQ5Nl0sWzU4N2UtNiwuMTE2MzI5LC4yMjI5MTRdLFsuMDAxMzA5LC4xMTkxMDYsLjIzMjM5N10sWy4wMDIzOTQsLjEyMTc3NiwuMjQxOTQyXSxbLjAwMzg4NiwuMTI0MzM2LC4yNTE1NDJdLFsuMDA1ODMxLC4xMjY3ODQsLjI2MTE4OV0sWy4wMDgyNzYsLjEyOTEyLC4yNzA4NzZdLFsuMDExMjY4LC4xMzEzNDIsLjI4MDU5OF0sWy4wMTQ4NTksLjEzMzQ0NywuMjkwMzQ1XSxbLjAxOTEsLjEzNTQzNSwuMzAwMTExXSxbLjAyNDA0MywuMTM3MzA1LC4zMDk4ODhdLFsuMDI5NzQyLC4xMzkwNTQsLjMxOTY2OV0sWy4wMzYyNTIsLjE0MDY4MywuMzI5NDQxXSxbLjA0MzUwNywuMTQyMTg5LC4zMzkyMDNdLFsuMDUwOTIyLC4xNDM1NzEsLjM0ODk0Ml0sWy4wNTg0MzIsLjE0NDgzMSwuMzU4NjQ5XSxbLjA2NjA0MSwuMTQ1OTY1LC4zNjgzMTldLFsuMDczNzQ0LC4xNDY5NzQsLjM3NzkzOF0sWy4wODE1NDEsLjE0Nzg1OCwuMzg3NTAxXSxbLjA4OTQzMSwuMTQ4NjE2LC4zOTY5OThdLFsuMDk3NDExLC4xNDkyNDgsLjQwNjQxOV0sWy4xMDU0NzksLjE0OTc1NCwuNDE1NzU1XSxbLjExMzYzNCwuMTUwMTM0LC40MjQ5OThdLFsuMTIxODczLC4xNTAzODksLjQzNDEzOV0sWy4xMzAxOTIsLjE1MDUyMSwuNDQzMTY3XSxbLjEzODU5MSwuMTUwNTI4LC40NTIwNzVdLFsuMTQ3MDY1LC4xNTA0MTMsLjQ2MDg1Ml0sWy4xNTU2MTQsLjE1MDE3NSwuNDY5NDkzXSxbLjE2NDIzMiwuMTQ5ODE4LC40Nzc5ODVdLFsuMTcyOTE3LC4xNDkzNDMsLjQ4NjMyMl0sWy4xODE2NjYsLjE0ODc1MSwuNDk0NDk0XSxbLjE5MDQ3NiwuMTQ4MDQ2LC41MDI0OTNdLFsuMTk5MzQ0LC4xNDcyMjksLjUxMDMxM10sWy4yMDgyNjcsLjE0NjMwMiwuNTE3OTQ0XSxbLjIxNzI0MiwuMTQ1MjY3LC41MjUzOF0sWy4yMjYyNjQsLjE0NDEzMSwuNTMyNjEzXSxbLjIzNTMzMSwuMTQyODk0LC41Mzk2MzVdLFsuMjQ0NDQsLjE0MTU1OSwuNTQ2NDQyXSxbLjI1MzU4NywuMTQwMTMxLC41NTMwMjZdLFsuMjYyNzY5LC4xMzg2MTUsLjU1OTM4MV0sWy4yNzE5ODEsLjEzNzAxNiwuNTY1NV0sWy4yODEyMjIsLjEzNTMzNSwuNTcxMzgxXSxbLjI5MDQ4NywuMTMzNTgxLC41NzcwMTddLFsuMjk5Nzc0LC4xMzE3NTcsLjU4MjQwNF0sWy4zMDkwOCwuMTI5ODY3LC41ODc1MzhdLFsuMzE4Mzk5LC4xMjc5MiwuNTkyNDE1XSxbLjMyNzczLC4xMjU5MjEsLjU5NzAzMl0sWy4zMzcwNjksLjEyMzg3NywuNjAxMzg1XSxbLjM0NjQxMywuMTIxNzkzLC42MDU0NzRdLFsuMzU1NzU4LC4xMTk2NzgsLjYwOTI5NV0sWy4zNjUxMDIsLjExNzU0LC42MTI4NDZdLFsuMzc0NDQzLC4xMTUzODYsLjYxNjEyN10sWy4zODM3NzQsLjExMzIyNiwuNjE5MTM4XSxbLjM5MzA5NiwuMTExMDY2LC42MjE4NzZdLFsuNDAyNDA0LC4xMDg5MTgsLjYyNDM0M10sWy40MTE2OTQsLjEwNjc5NCwuNjI2NTRdLFsuNDIwOTY3LC4xMDQ2OTgsLjYyODQ2Nl0sWy40MzAyMTcsLjEwMjY0NSwuNjMwMTIzXSxbLjQzOTQ0MiwuMTAwNjQ3LC42MzE1MTNdLFsuNDQ4NjM3LC4wOTg3MTcsLjYzMjYzOF0sWy40NTc4MDUsLjA5Njg2MSwuNjMzNDk5XSxbLjQ2Njk0LC4wOTUwOTUsLjYzNDFdLFsuNDc2MDQsLjA5MzQzMywuNjM0NDQzXSxbLjQ4NTEwMiwuMDkxODg1LC42MzQ1MzJdLFsuNDk0MTI1LC4wOTA0NjYsLjYzNDM3XSxbLjUwMzEwNCwuMDg5MTksLjYzMzk2Ml0sWy41MTIwNDEsLjA4ODA2NywuNjMzMzExXSxbLjUyMDkzMSwuMDg3MTA4LC42MzI0Ml0sWy41Mjk3NzMsLjA4NjMyOSwuNjMxMjk3XSxbLjUzODU2NCwuMDg1NzM4LC42Mjk5NDRdLFsuNTQ3MzAyLC4wODUzNDYsLjYyODM2N10sWy41NTU5ODYsLjA4NTE2MiwuNjI2NTcyXSxbLjU2NDYxNSwuMDg1MTksLjYyNDU2M10sWy41NzMxODcsLjA4NTQzOSwuNjIyMzQ1XSxbLjU4MTY5OCwuMDg1OTEzLC42MTk5MjZdLFsuNTkwMTQ5LC4wODY2MTUsLjYxNzMxMV0sWy41OTg1MzgsLjA4NzU0MywuNjE0NTAzXSxbLjYwNjg2MiwuMDg4NywuNjExNTExXSxbLjYxNTEyLC4wOTAwODQsLjYwODM0M10sWy42MjMzMTIsLjA5MTY5LC42MDUwMDFdLFsuNjMxNDM4LC4wOTM1MTEsLjYwMTQ4OV0sWy42Mzk0OTIsLjA5NTU0NiwuNTk3ODIxXSxbLjY0NzQ3NiwuMDk3Nzg3LC41OTM5OTldLFsuNjU1Mzg5LC4xMDAyMjYsLjU5MDAyOF0sWy42NjMyMywuMTAyODU2LC41ODU5MTRdLFsuNjcwOTk1LC4xMDU2NjksLjU4MTY2N10sWy42Nzg2ODYsLjEwODY1OCwuNTc3MjkxXSxbLjY4NjMwMiwuMTExODEzLC41NzI3OV0sWy42OTM4NCwuMTE1MTI5LC41NjgxNzVdLFsuNzAxMywuMTE4NTk3LC41NjM0NDldLFsuNzA4NjgyLC4xMjIyMDksLjU1ODYxNl0sWy43MTU5ODQsLjEyNTk1OSwuNTUzNjg3XSxbLjcyMzIwNiwuMTI5ODQsLjU0ODY2Nl0sWy43MzAzNDYsLjEzMzg0NiwuNTQzNTU4XSxbLjczNzQwNiwuMTM3OTcsLjUzODM2Nl0sWy43NDQzODIsLjE0MjIwOSwuNTMzMTAxXSxbLjc1MTI3NCwuMTQ2NTU2LC41Mjc3NjddLFsuNzU4MDgyLC4xNTEwMDgsLjUyMjM2OV0sWy43NjQ4MDUsLjE1NTU1OSwuNTE2OTEyXSxbLjc3MTQ0MywuMTYwMjA2LC41MTE0MDJdLFsuNzc3OTk1LC4xNjQ5NDYsLjUwNTg0NV0sWy43ODQ0NTksLjE2OTc3NCwuNTAwMjQ2XSxbLjc5MDgzNiwuMTc0Njg5LC40OTQ2MDddLFsuNzk3MTI1LC4xNzk2ODgsLjQ4ODkzNV0sWy44MDMzMjUsLjE4NDc2NywuNDgzMjM4XSxbLjgwOTQzNSwuMTg5OTI1LC40Nzc1MThdLFsuODE1NDU1LC4xOTUxNiwuNDcxNzgxXSxbLjgyMTM4NCwuMjAwNDcxLC40NjYwMjhdLFsuODI3MjIyLC4yMDU4NTQsLjQ2MDI2N10sWy44MzI5NjgsLjIxMTMwOCwuNDU0NTA1XSxbLjgzODYyMSwuMjE2ODM0LC40NDg3MzhdLFsuODQ0MTgxLC4yMjI0MjgsLjQ0Mjk3OV0sWy44NDk2NDcsLjIyODA5LC40MzcyM10sWy44NTUwMTksLjIzMzgxOSwuNDMxNDkxXSxbLjg2MDI5NSwuMjM5NjEzLC40MjU3NzFdLFsuODY1NDc1LC4yNDU0NzEsLjQyMDA3NF0sWy44NzA1NTgsLjI1MTM5MywuNDE0NDAzXSxbLjg3NTU0NSwuMjU3MzgsLjQwODc1OV0sWy44ODA0MzMsLjI2MzQyNywuNDAzMTUyXSxbLjg4NTIyMywuMjY5NTM1LC4zOTc1ODVdLFsuODg5OTEzLC4yNzU3MDUsLjM5MjA1OF0sWy44OTQ1MDMsLjI4MTkzNCwuMzg2NTc4XSxbLjg5ODk5MywuMjg4MjIyLC4zODExNTJdLFsuOTAzMzgxLC4yOTQ1NjksLjM3NTc4MV0sWy45MDc2NjcsLjMwMDk3NCwuMzcwNDY5XSxbLjkxMTg0OSwuMzA3NDM1LC4zNjUyMjNdLFsuOTE1OTI4LC4zMTM5NTMsLjM2MDA0OF0sWy45MTk5MDIsLjMyMDUyNywuMzU0OTQ4XSxbLjkyMzc3MSwuMzI3MTU1LC4zNDk5MjhdLFsuOTI3NTMzLC4zMzM4MzgsLjM0NDk5NF0sWy45MzExODgsLjM0MDU3NiwuMzQwMTQ5XSxbLjkzNDczNiwuMzQ3MzY2LC4zMzU0MDNdLFsuOTM4MTc1LC4zNTQyMDcsLjMzMDc2Ml0sWy45NDE1MDQsLjM2MTEwMSwuMzI2MjI5XSxbLjk0NDcyMywuMzY4MDQ1LC4zMjE4MTRdLFsuOTQ3ODMxLC4zNzUwMzksLjMxNzUyM10sWy45NTA4MjYsLjM4MjA4MywuMzEzMzY0XSxbLjk1MzcwOSwuMzg5MTc1LC4zMDkzNDVdLFsuOTU2NDc4LC4zOTYzMTQsLjMwNTQ3N10sWy45NTkxMzMsLjQwMzQ5OSwuMzAxNzY2XSxbLjk2MTY3MSwuNDEwNzMxLC4yOTgyMjFdLFsuOTY0MDkzLC40MTgwMDgsLjI5NDg1M10sWy45NjYzOTksLjQyNTMyNywuMjkxNjc2XSxbLjk2ODU4NiwuNDMyNjksLjI4ODY5Nl0sWy45NzA2NTQsLjQ0MDA5NSwuMjg1OTI2XSxbLjk3MjYwMywuNDQ3NTQsLjI4MzM4XSxbLjk3NDQzMSwuNDU1MDI1LC4yODEwNjddLFsuOTc2MTM5LC40NjI1NDcsLjI3OTAwM10sWy45Nzc3MjUsLjQ3MDEwNywuMjc3MTk4XSxbLjk3OTE4OCwuNDc3NzAzLC4yNzU2NjZdLFsuOTgwNTI5LC40ODUzMzIsLjI3NDQyMl0sWy45ODE3NDcsLjQ5Mjk5NSwuMjczNDc2XSxbLjk4Mjg0LC41MDA2OSwuMjcyODQyXSxbLjk4MzgwOCwuNTA4NDE1LC4yNzI1MzJdLFsuOTg0NjUzLC41MTYxNjgsLjI3MjU2XSxbLjk4NTM3MywuNTIzOTQ4LC4yNzI5MzddLFsuOTg1OTY2LC41MzE3NTQsLjI3MzY3M10sWy45ODY0MzYsLjUzOTU4MiwuMjc0Nzc5XSxbLjk4Njc4LC41NDc0MzQsLjI3NjI2NF0sWy45ODY5OTgsLjU1NTMwNSwuMjc4MTM1XSxbLjk4NzA5MSwuNTYzMTk1LC4yODA0MDFdLFsuOTg3MDYxLC41NzExLC4yODMwNjZdLFsuOTg2OTA3LC41NzkwMTksLjI4NjEzN10sWy45ODY2MjksLjU4Njk1LC4yODk2MTVdLFsuOTg2MjI5LC41OTQ4OTEsLjI5MzUwM10sWy45ODU3MDksLjYwMjgzOSwuMjk3ODAyXSxbLjk4NTA2OSwuNjEwNzkyLC4zMDI1MTJdLFsuOTg0MzEsLjYxODc0OCwuMzA3NjMyXSxbLjk4MzQzNSwuNjI2NzA0LC4zMTMxNTldLFsuOTgyNDQ1LC42MzQ2NTcsLjMxOTA4OV0sWy45ODEzNDEsLjY0MjYwNiwuMzI1NDJdLFsuOTgwMTMsLjY1MDU0NiwuMzMyMTQ0XSxbLjk3ODgxMiwuNjU4NDc1LC4zMzkyNTddLFsuOTc3MzkyLC42NjYzOTEsLjM0Njc1M10sWy45NzU4NywuNjc0MjksLjM1NDYyNV0sWy45NzQyNTIsLjY4MjE3LC4zNjI4NjVdLFsuOTcyNTQ1LC42OTAwMjYsLjM3MTQ2Nl0sWy45NzA3NSwuNjk3ODU2LC4zODA0MTldLFsuOTY4ODczLC43MDU2NTgsLjM4OTcxOF0sWy45NjY5MjEsLjcxMzQyNiwuMzk5MzUzXSxbLjk2NDkwMSwuNzIxMTU3LC40MDkzMTNdLFsuOTYyODE1LC43Mjg4NTEsLjQxOTU5NF0sWy45NjA2NzcsLjczNjUsLjQzMDE4MV0sWy45NTg0OSwuNzQ0MTAzLC40NDEwN10sWy45NTYyNjMsLjc1MTY1NiwuNDUyMjQ4XSxbLjk1NDAwOSwuNzU5MTUzLC40NjM3MDJdLFsuOTUxNzMyLC43NjY1OTUsLjQ3NTQyOV0sWy45NDk0NDUsLjc3Mzk3NCwuNDg3NDE0XSxbLjk0NzE1OCwuNzgxMjg5LC40OTk2NDddLFsuOTQ0ODg1LC43ODg1MzUsLjUxMjExNl0sWy45NDI2MzQsLjc5NTcwOSwuNTI0ODExXSxbLjk0MDQyMywuODAyODA3LC41Mzc3MTddLFsuOTM4MjYxLC44MDk4MjUsLjU1MDgyNV0sWy45MzYxNjMsLjgxNjc2LC41NjQxMjFdLFsuOTM0MTQ2LC44MjM2MDgsLjU3NzU5MV0sWy45MzIyMjQsLjgzMDM2NiwuNTkxMjJdLFsuOTMwNDEyLC44MzcwMzEsLjYwNDk5N10sWy45Mjg3MjcsLjg0MzU5OSwuNjE4OTA0XSxbLjkyNzE4NywuODUwMDY2LC42MzI5MjZdLFsuOTI1ODA5LC44NTY0MzIsLjY0NzA0N10sWy45MjQ2MSwuODYyNjkxLC42NjEyNDldLFsuOTIzNjA3LC44Njg4NDMsLjY3NTUxN10sWy45MjI4MiwuODc0ODg0LC42ODk4MzJdLFsuOTIyMjY1LC44ODA4MTIsLjcwNDE3NF0sWy45MjE5NjIsLjg4NjYyNiwuNzE4NTIzXSxbLjkyMTkzLC44OTIzMjMsLjczMjg1OV0sWy45MjIxODMsLjg5NzkwMywuNzQ3MTYzXSxbLjkyMjc0MSwuOTAzMzY0LC43NjE0MV0sWy45MjM2MiwuOTA4NzA2LC43NzU1OF0sWy45MjQ4MzcsLjkxMzkyOCwuNzg5NjQ4XSxbLjkyNjQwNSwuOTE5MDMxLC44MDM1OV0sWy45MjgzNCwuOTI0MDE1LC44MTczODFdLFsuOTMwNjU1LC45Mjg4ODEsLjgzMDk5NV0sWy45MzMzNiwuOTMzNjMxLC44NDQ0MDVdLFsuOTM2NDY2LC45MzgyNjcsLjg1NzU4M10sWy45Mzk5ODIsLjk0Mjc5MSwuODcwNDk5XSxbLjk0MzkxNCwuOTQ3MjA3LC44ODMxMjJdLFsuOTQ4MjY3LC45NTE1MTksLjg5NTQyMV0sWy45NTMwNDQsLjk1NTczMiwuOTA3MzU5XSxbLjk1ODI0NiwuOTU5ODUyLC45MTg5MDFdLFsuOTYzODY5LC45NjM4ODcsLjkzMDAwNF0sWy45Njk5MDksLjk2Nzg0NSwuOTQwNjIzXSxbLjk3NjM1NSwuOTcxNzM3LC45NTA3MDRdLFsuOTgzMTk1LC45NzU1OCwuOTYwMTgxXSxbLjk5MDQwMiwuOTc5Mzk1LC45Njg5NjZdLFsuOTk3OTMsLjk4MzIxNywuOTc2OTJdXSxYNj1bWzExM2UtNiwzNmUtNiwuMDAxMDczXSxbMTc1ZS02LDFlLTQsLjAwMTQxOV0sWzI1NGUtNiwxNzhlLTYsLjAwMTgzNV0sWzM0OWUtNiwyN2UtNSwuMDAyMzE5XSxbNDYxZS02LDM3NWUtNiwuMDAyODc0XSxbNTg3ZS02LDQ5MmUtNiwuMDAzNDk5XSxbNzNlLTUsNjIxZS02LC4wMDQxOTddLFs4ODdlLTYsNzYxZS02LC4wMDQ5NzNdLFsuMDAxMDYxLDkxMWUtNiwuMDA1ODI5XSxbLjAwMTI1LC4wMDEwNzEsLjAwNjc2OF0sWy4wMDE0NTYsLjAwMTI0LC4wMDc3OTVdLFsuMDAxNjc5LC4wMDE0MTgsLjAwODkxNF0sWy4wMDE5MTksLjAwMTYwMywuMDEwMTI4XSxbLjAwMjE3NywuMDAxNzk2LC4wMTE0NDFdLFsuMDAyNDUzLC4wMDE5OTQsLjAxMjg2XSxbLjAwMjc0OSwuMDAyMTk4LC4wMTQzOV0sWy4wMDMwNjYsLjAwMjQwNiwuMDE2MDMzXSxbLjAwMzQwNCwuMDAyNjE4LC4wMTc3OTVdLFsuMDAzNzY0LC4wMDI4MzMsLjAxOTY4Ml0sWy4wMDQxNDgsLjAwMzA1LC4wMjE2OThdLFsuMDA0NTU4LC4wMDMyNjcsLjAyMzg1Ml0sWy4wMDQ5OTQsLjAwMzQ4NCwuMDI2MTQ4XSxbLjAwNTQ1OSwuMDAzNjk5LC4wMjg1OTFdLFsuMDA1OTU0LC4wMDM5MTEsLjAzMTE4Nl0sWy4wMDY0ODIsLjAwNDEyLC4wMzM5NF0sWy4wMDcwNDQsLjAwNDMyMywuMDM2ODU3XSxbLjAwNzY0MywuMDA0NTE5LC4wMzk5NDRdLFsuMDA4MjgyLC4wMDQ3MDgsLjA0MzIwNV0sWy4wMDg5NjMsLjAwNDg4NywuMDQ2NjQ1XSxbLjAwOTY5LC4wMDUwNTQsLjA1MDI2OF0sWy4wMTA0NjUsLjAwNTIxLC4wNTQwNzddLFsuMDExMjkzLC4wMDUzNTEsLjA1ODA3NF0sWy4wMTIxNzYsLjAwNTQ3NiwuMDYyMjY1XSxbLjAxMzEyLC4wMDU1ODUsLjA2NjY0OF0sWy4wMTQxMjgsLjAwNTY3NSwuMDcxMjE1XSxbLjAxNTIwMiwuMDA1NzQ3LC4wNzU5NjNdLFsuMDE2MzQ5LC4wMDU3OTgsLjA4MDg4N10sWy4wMTc1NzMsLjAwNTgyOCwuMDg1OTgyXSxbLjAxODg3NywuMDA1ODM3LC4wOTEyMjNdLFsuMDIwMjY1LC4wMDU4MjYsLjA5NjU5OV0sWy4wMjE3NDEsLjAwNTc5NCwuMTAyMDldLFsuMDIzMzA2LC4wMDU3NDQsLjEwNzY2Ml0sWy4wMjQ5NjUsLjAwNTY3NiwuMTEzMjk3XSxbLjAyNjcxOCwuMDA1NTk1LC4xMTg5NDldLFsuMDI4NTY1LC4wMDU1MDMsLjEyNDU5NV0sWy4wMzA1MDYsLjAwNTQwMywuMTMwMTg3XSxbLjAzMjU0LC4wMDUzLC4xMzU2OTVdLFsuMDM0NjYzLC4wMDUxOTksLjE0MTA4MV0sWy4wMzY4NzQsLjAwNTEwMiwuMTQ2MzE0XSxbLjAzOTE2OSwuMDA1MDE1LC4xNTEzNjRdLFsuMDQxNTQzLC4wMDQ5NDIsLjE1NjIxMV0sWy4wNDM5OTQsLjAwNDg4NSwuMTYwODM1XSxbLjA0NjUxNywuMDA0ODQ3LC4xNjUyMjddLFsuMDQ5MTEsLjAwNDgzLC4xNjkzNzldLFsuMDUxNzY5LC4wMDQ4MzcsLjE3MzI5MV0sWy4wNTQ0OTQsLjAwNDg2NiwuMTc2OTY1XSxbLjA1NzI4MSwuMDA0OTIxLC4xODA0MDVdLFsuMDYwMTMsLjAwNDk5OCwuMTgzNjIyXSxbLjA2MzAzOCwuMDA1MTAxLC4xODY2MjRdLFsuMDY2MDA3LC4wMDUyMjYsLjE4OTQyMl0sWy4wNjkwMzYsLjAwNTM3NSwuMTkyMDI4XSxbLjA3MjEyNSwuMDA1NTQ1LC4xOTQ0NTNdLFsuMDc1Mjc2LC4wMDU3MzUsLjE5NjcwOV0sWy4wNzg0ODUsLjAwNTk0NywuMTk4ODA3XSxbLjA4MTc1NywuMDA2MTc3LC4yMDA3NThdLFsuMDg1MDkzLC4wMDY0MjUsLjIwMjU3MV0sWy4wODg0OTEsLjAwNjY5LC4yMDQyNTldLFsuMDkxOTU0LC4wMDY5NzEsLjIwNTgyN10sWy4wOTU0ODQsLjAwNzI2NywuMjA3Mjg0XSxbLjA5OTA4LC4wMDc1NzcsLjIwODY0XSxbLjEwMjc0MywuMDA3OTAxLC4yMDk5MDFdLFsuMTA2NDc2LC4wMDgyMzcsLjIxMTA3MV0sWy4xMTAyODEsLjAwODU4NSwuMjEyMTU4XSxbLjExNDE1NywuMDA4OTQ0LC4yMTMxNjZdLFsuMTE4MTA2LC4wMDkzMTQsLjIxNDEwM10sWy4xMjIxMjksLjAwOTY5MywuMjE0OTddLFsuMTI2MjI4LC4wMTAwODIsLjIxNTc3XSxbLjEzMDQwNiwuMDEwNDc5LC4yMTY1MV0sWy4xMzQ2NjEsLjAxMDg4NSwuMjE3MTg5XSxbLjEzODk5NiwuMDExMjk4LC4yMTc4MTFdLFsuMTQzNDExLC4wMTE3MTksLjIxODM4Ml0sWy4xNDc5MDgsLjAxMjE0NiwuMjE4OV0sWy4xNTI0OSwuMDEyNTgsLjIxOTM2OF0sWy4xNTcxNTYsLjAxMzAyMSwuMjE5Nzg3XSxbLjE2MTkwOCwuMDEzNDY3LC4yMjAxNTldLFsuMTY2NzQ4LC4wMTM5MTgsLjIyMDQ4NF0sWy4xNzE2NzcsLjAxNDM3NSwuMjIwNzY0XSxbLjE3NjY5NiwuMDE0ODM3LC4yMjFdLFsuMTgxODA2LC4wMTUzMDQsLjIyMTE5Ml0sWy4xODcwMDksLjAxNTc3NSwuMjIxMzRdLFsuMTkyMzA0LC4wMTYyNTEsLjIyMTQ0Nl0sWy4xOTc2OTQsLjAxNjczMSwuMjIxNTFdLFsuMjAzMTgxLC4wMTcyMTUsLjIyMTUzMV0sWy4yMDg3NjUsLjAxNzcwNCwuMjIxNTA5XSxbLjIxNDQ0NywuMDE4MTk2LC4yMjE0NDVdLFsuMjIwMjI4LC4wMTg2OTIsLjIyMTMzN10sWy4yMjYxMSwuMDE5MTkxLC4yMjExODhdLFsuMjMyMDk0LC4wMTk2OTUsLjIyMDk5NV0sWy4yMzgxODEsLjAyMDIwMiwuMjIwNzU4XSxbLjI0NDM3MSwuMDIwNzEyLC4yMjA0NzldLFsuMjUwNjY2LC4wMjEyMjcsLjIyMDE1NV0sWy4yNTcwNjYsLjAyMTc0NCwuMjE5Nzg2XSxbLjI2MzU3MywuMDIyMjY2LC4yMTkzNzNdLFsuMjcwMTg4LC4wMjI3OTIsLjIxODkxNF0sWy4yNzY5MTEsLjAyMzMyMSwuMjE4NDFdLFsuMjgzNzQyLC4wMjM4NTUsLjIxNzg2XSxbLjI5MDY4NCwuMDI0MzkyLC4yMTcyNjNdLFsuMjk3NzM3LC4wMjQ5MzQsLjIxNjYyXSxbLjMwNDg5OSwuMDI1NDgxLC4yMTU5M10sWy4zMTIxNzQsLjAyNjAzMiwuMjE1MTkyXSxbLjMxOTU2MSwuMDI2NTg5LC4yMTQ0MDZdLFsuMzI3MDYsLjAyNzE1LC4yMTM1NzFdLFsuMzM0NjcyLC4wMjc3MTgsLjIxMjY4OV0sWy4zNDIzOTgsLjAyODI5MSwuMjExNzU2XSxbLjM1MDIzNiwuMDI4ODcxLC4yMTA3NzVdLFsuMzU4MTg4LC4wMjk0NTcsLjIwOTc0Nl0sWy4zNjYyNTMsLjAzMDA1MSwuMjA4NjY2XSxbLjM3NDQzMSwuMDMwNjUyLC4yMDc1MzddLFsuMzgyNzIyLC4wMzEyNjIsLjIwNjM1OF0sWy4zOTExMjQsLjAzMTg4LC4yMDUxM10sWy4zOTk2NCwuMDMyNTA4LC4yMDM4NTNdLFsuNDA4MjY2LC4wMzMxNDYsLjIwMjUyNl0sWy40MTcwMDMsLjAzMzc5NSwuMjAxMTQ5XSxbLjQyNTg1LC4wMzQ0NTYsLjE5OTcyNF0sWy40MzQ4MDQsLjAzNTEyOSwuMTk4MjUxXSxbLjQ0Mzg2NywuMDM1ODE2LC4xOTY3MjldLFsuNDUzMDM1LC4wMzY1MTcsLjE5NTE1OV0sWy40NjIzMDYsLjAzNzIzMywuMTkzNTQyXSxbLjQ3MTY4LC4wMzc5NjYsLjE5MTg3OF0sWy40ODExNTQsLjAzODcxNywuMTkwMTY5XSxbLjQ5MDcyNywuMDM5NDg3LC4xODg0MTRdLFsuNTAwMzkzLC4wNDAyNzgsLjE4NjYxNV0sWy41MTAxNTIsLjA0MTA5LC4xODQ3NzNdLFsuNTE5OTk4LC4wNDE5MjYsLjE4Mjg5XSxbLjUyOTkzMSwuMDQyNzg4LC4xODA5NjZdLFsuNTM5OTQ0LC4wNDM2NzcsLjE3OTAwM10sWy41NTAwMzYsLjA0NDU5NSwuMTc3MDAyXSxbLjU2MDE5OCwuMDQ1NTQ0LC4xNzQ5NjZdLFsuNTcwNDI5LC4wNDY1MjYsLjE3Mjg5Nl0sWy41ODA3MjEsLjA0NzU0NSwuMTcwNzk0XSxbLjU5MTA3MSwuMDQ4NjAxLC4xNjg2NTldLFsuNjAxNDcxLC4wNDk2OTksLjE2NjQ5N10sWy42MTE5MTMsLjA1MDg0LC4xNjQzMV0sWy42MjIzOSwuMDUyMDI5LC4xNjIxXSxbLjYzMjg5NCwuMDUzMjY4LC4xNTk4N10sWy42NDM0MTgsLjA1NDU2MSwuMTU3NjI1XSxbLjY1Mzk1MSwuMDU1OTEsLjE1NTM2Nl0sWy42NjQ0ODUsLjA1NzMyMSwuMTUzMDk0XSxbLjY3NTAwOSwuMDU4Nzk2LC4xNTA4MTZdLFsuNjg1NTExLC4wNjAzNDEsLjE0ODUzNl0sWy42OTU5NzksLjA2MTk2MSwuMTQ2MjU5XSxbLjcwNjQwNCwuMDYzNjU5LC4xNDM5ODldLFsuNzE2NzcsLjA2NTQzOSwuMTQxNzI3XSxbLjcyNzA2NSwuMDY3MzA5LC4xMzk0ODJdLFsuNzM3Mjc1LC4wNjkyNzMsLjEzNzI1OV0sWy43NDczODUsLjA3MTMzNSwuMTM1MDY0XSxbLjc1NzM4LC4wNzM1MDIsLjEzMjkwMV0sWy43NjcyNDQsLjA3NTc3OSwuMTMwNzc3XSxbLjc3Njk2NSwuMDc4MTcxLC4xMjg2OTldLFsuNzg2NTI2LC4wODA2ODYsLjEyNjY3M10sWy43OTU5MSwuMDgzMzI3LC4xMjQ3MDVdLFsuODA1MTA3LC4wODYxLC4xMjI4MDNdLFsuODE0MDk3LC4wODkwMSwuMTIwOTc0XSxbLjgyMjg3MSwuMDkyMDYzLC4xMTkyMjRdLFsuODMxNDE0LC4wOTUyNjIsLjExNzU2MV0sWy44Mzk3MTcsLjA5ODYxMywuMTE1OTldLFsuODQ3NzY4LC4xMDIxMTcsLjExNDUxOF0sWy44NTU1NTksLjEwNTc3OSwuMTEzMTVdLFsuODYzMDg2LC4xMDk2MDEsLjExMTg5NF0sWy44NzAzNCwuMTEzNTg2LC4xMTA3NTNdLFsuODc3MzE5LC4xMTc3MzUsLjEwOTczMV0sWy44ODQwMjMsLjEyMjA0OCwuMTA4ODM0XSxbLjg5MDQ1MiwuMTI2NTI1LC4xMDgwNjZdLFsuODk2NjA2LC4xMzExNjcsLjEwNzQyN10sWy45MDI0ODcsLjEzNTk3MywuMTA2OTIxXSxbLjkwODEwMSwuMTQwOTQzLC4xMDY1NDhdLFsuOTEzNDU0LC4xNDYwNzQsLjEwNjMxMV0sWy45MTg1NTcsLjE1MTM2MywuMTA2MjEyXSxbLjkyMzQxMSwuMTU2ODEsLjEwNjI0OV0sWy45MjgwMjYsLjE2MjQxMywuMTA2NDIyXSxbLjkzMjQwOCwuMTY4MTcxLC4xMDY3MzFdLFsuOTM2NTY3LC4xNzQwNzksLjEwNzE3NV0sWy45NDA1MTEsLjE4MDEzNywuMTA3NzU0XSxbLjk0NDI0OSwuMTg2MzQzLC4xMDg0NjZdLFsuOTQ3NzksLjE5MjY5MiwuMTA5MzEyXSxbLjk1MTE0NSwuMTk5MTg1LC4xMTAyODldLFsuOTU0MzE4LC4yMDU4MTgsLjExMTM5OF0sWy45NTczMjEsLjIxMjU4OSwuMTEyNjM1XSxbLjk2MDE2LC4yMTk0OTcsLjExNDAwMl0sWy45NjI4NDEsLjIyNjUzOSwuMTE1NDk3XSxbLjk2NTM3MywuMjMzNzE2LC4xMTcxMTldLFsuOTY3NzYxLC4yNDEwMjYsLjExODg2N10sWy45NzAwMTEsLjI0ODQ2NiwuMTIwNzRdLFsuOTcyMTI2LC4yNTYwMzcsLjEyMjczOF0sWy45NzQxMTIsLjI2MzczOSwuMTI0ODU5XSxbLjk3NTk3MywuMjcxNTcxLC4xMjcxMDZdLFsuOTc3NzEyLC4yNzk1MzIsLjEyOTQ3NV0sWy45NzkzNTgsLjI4NzYxMywuMTMxOTY5XSxbLjk4MDkwMywuMjk1ODE5LC4xMzQ1ODVdLFsuOTgyMzM5LC4zMDQxNTQsLjEzNzMyNl0sWy45ODM2NjUsLjMxMjYxNiwuMTQwMTg5XSxbLjk4NDg4NSwuMzIxMjA5LC4xNDMxNzhdLFsuOTg2MDMsLjMyOTkxOSwuMTQ2Mjg5XSxbLjk4NzEwMiwuMzM4NzQ5LC4xNDk1MjRdLFsuOTg4MDcxLC4zNDc3MTEsLjE1Mjg4NV0sWy45ODg5MzksLjM1NjgwMywuMTU2MzcyXSxbLjk4OTc0OCwuMzY2MDE0LC4xNTk5ODRdLFsuOTkwNDk1LC4zNzUzNDMsLjE2MzcyM10sWy45OTExNDIsLjM4NDgwOCwuMTY3NTldLFsuOTkxNjk2LC4zOTQ0MDMsLjE3MTU4N10sWy45OTIyMzcsLjQwNDEwNiwuMTc1NzFdLFsuOTkyNjc5LC40MTM5NDMsLjE3OTk2NV0sWy45OTMwMTksLjQyMzkyMiwuMTg0MzU2XSxbLjk5MzM2MywuNDM0MDAyLC4xODg4NzFdLFsuOTkzNjEsLjQ0NDIyMiwuMTkzNTI2XSxbLjk5Mzc2NCwuNDU0NTgzLC4xOTgzMTldLFsuOTkzOTI1LC40NjUwNDcsLjIwMzI0XSxbLjk5Mzk4NCwuNDc1NjU1LC4yMDgzMDZdLFsuOTkzOTg0LC40ODYzOTUsLjIxMzUxMl0sWy45OTM5NjIsLjQ5NzI1MywuMjE4ODU1XSxbLjk5MzgzNSwuNTA4MjYxLC4yMjQzNDhdLFsuOTkzNzA1LC41MTkzODIsLjIyOTk3OV0sWy45OTM1MDIsLjUzMDY0MywuMjM1NzZdLFsuOTkzMjMyLC41NDIwNDQsLjI0MTY5NF0sWy45OTI5NTgsLjU1MzU2MiwuMjQ3NzddLFsuOTkyNTcsLjU2NTI0LC4yNTQwMTFdLFsuOTkyMjE3LC41NzcwMjQsLjI2MDM5M10sWy45OTE3NiwuNTg4OTY0LC4yNjY5NDJdLFsuOTkxMjkxLC42MDEwMzEsLjI3MzY0Nl0sWy45OTA3NzEsLjYxMzIzOCwuMjgwNTEzXSxbLjk5MDIsLjYyNTU4OCwuMjg3NTQ2XSxbLjk4OTYyMiwuNjM4MDY0LC4yOTQ3NF0sWy45ODg5NTksLjY1MDY5OSwuMzAyMTExXSxbLjk4ODMyNiwuNjYzNDUsLjMwOTY0MV0sWy45ODc1ODgsLjY3NjM2OCwuMzE3MzYxXSxbLjk4NjkwNiwuNjg5Mzk0LC4zMjUyMzZdLFsuOTg2MTAzLC43MDI1OTksLjMzMzMxMV0sWy45ODUzNzksLjcxNTkwNywuMzQxNTM5XSxbLjk4NDUzMywuNzI5MzkzLC4zNDk5NzRdLFsuOTgzNzY5LC43NDI5ODUsLjM1ODU2OF0sWy45ODI4ODgsLjc1Njc1OSwuMzY3MzcyXSxbLjk4MjA5OCwuNzcwNjM4LC4zNzYzMzZdLFsuOTgxMTk1LC43ODQ2OTgsLjM4NTUxNl0sWy45ODAzOTUsLjc5ODg2NCwuMzk0ODUzXSxbLjk3OTQ5MSwuODEzMjExLC40MDQ0MDddLFsuOTc4NjgyLC44Mjc2NzEsLjQxNDEyNl0sWy45Nzc3OTUsLjg0MjMwNiwuNDI0MDU4XSxbLjk3Njk4NywuODU3MDYxLC40MzQxNTZdLFsuOTc2MTMyLC44NzE5ODMsLjQ0NDQ2M10sWy45NzUzMzEsLjg4NzA0MSwuNDU0OTQ1XSxbLjk3NDUyNCwuOTAyMjU4LC40NjU2Ml0sWy45NzM3NCwuOTE3NjIyLC40NzY0ODFdLFsuOTcyOTkyLC45MzMxMzMsLjQ4NzUyMV0sWy45NzIyMjcsLjk0ODgxMywuNDk4NzU0XSxbLjk3MTU0NywuOTY0NjI5LC41MTAxNDldLFsuOTcwOCwuOTgwNjMzLC41MjE3NDldXSxWNj1bWzExM2UtNiwzNmUtNiwuMDAxMDczXSxbMTc1ZS02LDk4ZS02LC4wMDE0MzddLFsyNTVlLTYsMTc0ZS02LC4wMDE4NzZdLFszNTJlLTYsMjYzZS02LC4wMDIzOTJdLFs0NjVlLTYsMzYzZS02LC4wMDI5ODRdLFs1OTRlLTYsNDc1ZS02LC4wMDM2NTddLFs3NGUtNSw1OTdlLTYsLjAwNDQxNV0sWzkwM2UtNiw3MjllLTYsLjAwNTI1N10sWy4wMDEwODMsODY5ZS02LC4wMDYxOTddLFsuMDAxMjgyLC4wMDEwMTcsLjAwNzIzMV0sWy4wMDE0OTksLjAwMTE3MSwuMDA4MzY3XSxbLjAwMTczNywuMDAxMzMxLC4wMDk2MTNdLFsuMDAxOTk2LC4wMDE0OTYsLjAxMDk2OF0sWy4wMDIyNzgsLjAwMTY2NCwuMDEyNDQ0XSxbLjAwMjU4NCwuMDAxODM1LC4wMTQwNDVdLFsuMDAyOTE1LC4wMDIwMDYsLjAxNTc3M10sWy4wMDMyNzUsLjAwMjE3OCwuMDE3NjM0XSxbLjAwMzY2NCwuMDAyMzQ3LC4wMTk2NDRdLFsuMDA0MDg1LC4wMDI1MTMsLjAyMTc5OF0sWy4wMDQ1NDEsLjAwMjY3NiwuMDI0MTAyXSxbLjAwNTAzNCwuMDAyODMyLC4wMjY1NjFdLFsuMDA1NTY4LC4wMDI5OCwuMDI5MTg3XSxbLjAwNjE0NiwuMDAzMTE5LC4wMzE5OF0sWy4wMDY3NzIsLjAwMzI0NywuMDM0OTRdLFsuMDA3NDQ4LC4wMDMzNjIsLjAzODA3XSxbLjAwODE3OSwuMDAzNDY0LC4wNDEzNjldLFsuMDA4OTY5LC4wMDM1NSwuMDQ0ODM3XSxbLjAwOTgyMywuMDAzNjIsLjA0ODQ3XSxbLjAxMDc0NCwuMDAzNjcyLC4wNTIyNl0sWy4wMTE3MzYsLjAwMzcwNiwuMDU2MTk5XSxbLjAxMjgwNSwuMDAzNzIxLC4wNjAyNzRdLFsuMDEzOTUzLC4wMDM3MTgsLjA2NDQ2OF0sWy4wMTUxODMsLjAwMzY5NywuMDY4NzZdLFsuMDE2NDk5LC4wMDM2NTksLjA3MzEyOF0sWy4wMTc5MDIsLjAwMzYwNiwuMDc3NTQ2XSxbLjAxOTM5NSwuMDAzNTQsLjA4MTk4NV0sWy4wMjA5NzYsLjAwMzQ2NCwuMDg2NDE3XSxbLjAyMjY0NywuMDAzMzgxLC4wOTA4MV0sWy4wMjQ0MDQsLjAwMzI5NCwuMDk1MTMzXSxbLjAyNjI0NywuMDAzMjA2LC4wOTkzNl0sWy4wMjgxNzQsLjAwMzEyMSwuMTAzNDY3XSxbLjAzMDE4MiwuMDAzMDQyLC4xMDc0MzNdLFsuMDMyMjY5LC4wMDI5NzIsLjExMTI0MV0sWy4wMzQ0MzEsLjAwMjkxMywuMTE0ODc4XSxbLjAzNjY2OCwuMDAyODY2LC4xMTgzMzddLFsuMDM4OTc1LC4wMDI4MzQsLjEyMTYxMV0sWy4wNDEzNTEsLjAwMjgxOCwuMTI0N10sWy4wNDM3OTYsLjAwMjgxOCwuMTI3NjA0XSxbLjA0NjMwNywuMDAyODM0LC4xMzAzMjddLFsuMDQ4ODg0LC4wMDI4NjgsLjEzMjg3M10sWy4wNTE1MjcsLjAwMjkxOCwuMTM1MjQ4XSxbLjA1NDIzNSwuMDAyOTg1LC4xMzc0NTldLFsuMDU3MDA4LC4wMDMwNjksLjEzOTUxMl0sWy4wNTk4NDUsLjAwMzE2OCwuMTQxNDE3XSxbLjA2Mjc0NywuMDAzMjgzLC4xNDMxNzldLFsuMDY1NzE0LC4wMDM0MTIsLjE0NDgwN10sWy4wNjg3NDgsLjAwMzU1NSwuMTQ2MzA2XSxbLjA3MTg0OSwuMDAzNzEyLC4xNDc2ODVdLFsuMDc1MDE4LC4wMDM4ODIsLjE0ODk0OF0sWy4wNzgyNTUsLjAwNDA2NCwuMTUwMTA0XSxbLjA4MTU2MSwuMDA0MjU3LC4xNTExNTZdLFsuMDg0OTM3LC4wMDQ0NjIsLjE1MjExXSxbLjA4ODM4NCwuMDA0Njc3LC4xNTI5NzJdLFsuMDkxOTAzLC4wMDQ5MDIsLjE1Mzc0NF0sWy4wOTU0OTQsLjAwNTEzNywuMTU0NDMyXSxbLjA5OTE1OSwuMDA1MzgxLC4xNTUwMzldLFsuMTAyODk5LC4wMDU2MzQsLjE1NTU2OF0sWy4xMDY3MTQsLjAwNTg5NSwuMTU2MDIyXSxbLjExMDYwNiwuMDA2MTY0LC4xNTY0MDVdLFsuMTE0NTc2LC4wMDY0NDEsLjE1NjcxOF0sWy4xMTg2MjQsLjAwNjcyNCwuMTU2OTY0XSxbLjEyMjc1LC4wMDcwMTYsLjE1NzE0N10sWy4xMjY5NTcsLjAwNzMxNCwuMTU3MjY2XSxbLjEzMTI0NCwuMDA3NjE4LC4xNTczMjNdLFsuMTM1NjE0LC4wMDc5MjksLjE1NzMyXSxbLjE0MDA2NywuMDA4MjQ2LC4xNTcyNTddLFsuMTQ0NjAzLC4wMDg1NjksLjE1NzEzN10sWy4xNDkyMjMsLjAwODg5OCwuMTU2OTYxXSxbLjE1MzkzLC4wMDkyMzMsLjE1NjcyN10sWy4xNTg3MjIsLjAwOTU3NCwuMTU2NDRdLFsuMTYzNjAxLC4wMDk5MiwuMTU2MDk3XSxbLjE2ODU2NiwuMDEwMjcyLC4xNTU3MDFdLFsuMTczNjIxLC4wMTA2MywuMTU1MjU0XSxbLjE3ODc2MywuMDEwOTk0LC4xNTQ3NTRdLFsuMTgzOTk0LC4wMTEzNjMsLjE1NDIwM10sWy4xODkzMTYsLjAxMTczOCwuMTUzNTk5XSxbLjE5NDcyOSwuMDEyMTE5LC4xNTI5NDRdLFsuMjAwMjMxLC4wMTI1MDYsLjE1MjI0XSxbLjIwNTgyNSwuMDEyODk5LC4xNTE0ODVdLFsuMjExNTExLC4wMTMyOTgsLjE1MDY4Ml0sWy4yMTcyODgsLjAxMzcwMywuMTQ5ODI5XSxbLjIyMzE1OCwuMDE0MTE1LC4xNDg5MjldLFsuMjI5MTE5LC4wMTQ1MzQsLjE0Nzk4XSxbLjIzNTE3MywuMDE0OTYsLjE0Njk4M10sWy4yNDEzMTksLjAxNTM5MywuMTQ1OTRdLFsuMjQ3NTU5LC4wMTU4MzQsLjE0NDg1XSxbLjI1Mzg5LC4wMTYyODIsLjE0MzcxNV0sWy4yNjAzMTQsLjAxNjczOSwuMTQyNTM1XSxbLjI2NjgzLC4wMTcyMDQsLjE0MTMxXSxbLjI3MzQzNywuMDE3Njc5LC4xNDAwNDFdLFsuMjgwMTM2LC4wMTgxNjIsLjEzODczXSxbLjI4NjkyNywuMDE4NjU2LC4xMzczNzZdLFsuMjkzODA4LC4wMTkxNiwuMTM1OTgxXSxbLjMwMDc3OCwuMDE5Njc0LC4xMzQ1NDZdLFsuMzA3ODM4LC4wMjAyLC4xMzMwNzJdLFsuMzE0OTg3LC4wMjA3MzgsLjEzMTU1OF0sWy4zMjIyMjMsLjAyMTI4OCwuMTMwMDA3XSxbLjMyOTU0NSwuMDIxODUyLC4xMjg0MTldLFsuMzM2OTU1LC4wMjI0MjksLjEyNjc5N10sWy4zNDQ0NDcsLjAyMzAyMiwuMTI1MTQxXSxbLjM1MjAyMiwuMDIzNjI5LC4xMjM0NTJdLFsuMzU5NjgxLC4wMjQyNTIsLjEyMTczMl0sWy4zNjc0MTgsLjAyNDg5MywuMTE5OTgyXSxbLjM3NTIzNSwuMDI1NTUxLC4xMTgyMDNdLFsuMzgzMTI5LC4wMjYyMjgsLjExNjM5Nl0sWy4zOTEwOTgsLjAyNjkyNCwuMTE0NTYzXSxbLjM5OTE0MSwuMDI3NjQxLC4xMTI3MDddLFsuNDA3MjU1LC4wMjgzOCwuMTEwODI3XSxbLjQxNTQzNywuMDI5MTQyLC4xMDg5MjZdLFsuNDIzNjg1LC4wMjk5MjcsLjEwNzAwNl0sWy40MzE5OTksLjAzMDczOCwuMTA1MDY4XSxbLjQ0MDM3NSwuMDMxNTc1LC4xMDMxMTRdLFsuNDQ4ODA5LC4wMzI0MzksLjEwMTE0NV0sWy40NTczMDEsLjAzMzMzMiwuMDk5MTYzXSxbLjQ2NTg0NCwuMDM0MjU1LC4wOTcxNjldLFsuNDc0NDM5LC4wMzUyMSwuMDk1MTY2XSxbLjQ4MzA4MywuMDM2MTk4LC4wOTMxNTVdLFsuNDkxNzY4LC4wMzcyMiwuMDkxMTM4XSxbLjUwMDQ5NSwuMDM4Mjc5LC4wODkxMTddLFsuNTA5MjYsLjAzOTM3NSwuMDg3MDk0XSxbLjUxODA1NywuMDQwNTEsLjA4NTA3XSxbLjUyNjg4NSwuMDQxNjg3LC4wODMwNDddLFsuNTM1NzM4LC4wNDI5MDYsLjA4MTAyN10sWy41NDQ2MTMsLjA0NDE2OSwuMDc5MDFdLFsuNTUzNTA2LC4wNDU0NzksLjA3N10sWy41NjI0MTMsLjA0NjgzNywuMDc0OTk3XSxbLjU3MTMzLC4wNDgyNDUsLjA3MzAwM10sWy41ODAyNTIsLjA0OTcwNSwuMDcxMDE5XSxbLjU4OTE3NSwuMDUxMjE5LC4wNjkwNDhdLFsuNTk4MDkyLC4wNTI3ODksLjA2NzA5XSxbLjYwNzAwMywuMDU0NDE4LC4wNjUxNDhdLFsuNjE1OTAxLC4wNTYxMDYsLjA2MzIyMl0sWy42MjQ3OCwuMDU3ODU3LC4wNjEzMTRdLFsuNjMzNjM4LC4wNTk2NzIsLjA1OTQyNF0sWy42NDI0NjgsLjA2MTU1MywuMDU3NTU1XSxbLjY1MTI2NiwuMDYzNTA0LC4wNTU3MDhdLFsuNjYwMDI4LC4wNjU1MjUsLjA1Mzg4Ml0sWy42Njg3NDgsLjA2NzYxOSwuMDUyMDgxXSxbLjY3NzQyMywuMDY5Nzg4LC4wNTAzMDNdLFsuNjg2MDQ2LC4wNzIwMzYsLjA0ODU1MV0sWy42OTQ2MTQsLjA3NDM2MywuMDQ2ODI1XSxbLjcwMzExOSwuMDc2NzcyLC4wNDUxMjZdLFsuNzExNTYsLjA3OTI2NiwuMDQzNDU1XSxbLjcxOTkzMiwuMDgxODQ2LC4wNDE4MTFdLFsuNzI4MjI5LC4wODQ1MTUsLjA0MDE5N10sWy43MzY0NDYsLjA4NzI3NSwuMDM4NjEyXSxbLjc0NDU4LC4wOTAxMjgsLjAzNzA1N10sWy43NTI2MjQsLjA5MzA3NywuMDM1NTMxXSxbLjc2MDU3OCwuMDk2MTIzLC4wMzQwMzddLFsuNzY4NDM0LC4wOTkyNjksLjAzMjU3M10sWy43NzYxOSwuMTAyNTE3LC4wMzExNDFdLFsuNzgzODM5LC4xMDU4NjksLjAyOTczOV0sWy43OTEzODIsLjEwOTMyOCwuMDI4MzddLFsuNzk4ODA5LC4xMTI4OTQsLjAyNzAzMV0sWy44MDYxMjIsLjExNjU3MSwuMDI1NzI1XSxbLjgxMzMxNCwuMTIwMzYsLjAyNDQ1MV0sWy44MjAzODIsLjEyNDI2MywuMDIzMjA5XSxbLjgyNzMyNCwuMTI4MjgyLC4wMjE5OThdLFsuODM0MTM1LC4xMzI0MTksLjAyMDgyXSxbLjg0MDgxMiwuMTM2Njc3LC4wMTk2NzRdLFsuODQ3MzUzLC4xNDEwNTYsLjAxODU2XSxbLjg1Mzc1NSwuMTQ1NTU5LC4wMTc0NzhdLFsuODYwMDEyLC4xNTAxODcsLjAxNjQyOV0sWy44NjYxMjUsLjE1NDk0MiwuMDE1NDEyXSxbLjg3MjA5MSwuMTU5ODI3LC4wMTQ0MjhdLFsuODc3OTA3LC4xNjQ4NDIsLjAxMzQ3N10sWy44ODM1NjgsLjE2OTk5LC4wMTI1NThdLFsuODg5MDc1LC4xNzUyNzEsLjAxMTY3M10sWy44OTQ0MjIsLjE4MDY4OCwuMDEwODIxXSxbLjg5OTYxMiwuMTg2MjQzLC4wMTAwMDNdLFsuOTA0NjM4LC4xOTE5MzYsLjAwOTIxOV0sWy45MDk0OTksLjE5Nzc3LC4wMDg0N10sWy45MTQxOTYsLjIwMzc0NSwuMDA3NzU1XSxbLjkxODcyNCwuMjA5ODY1LC4wMDcwNzZdLFsuOTIzMDgxLC4yMTYxMjksLjAwNjQzNF0sWy45MjcyNjYsLjIyMjU0LC4wMDU4MjhdLFsuOTMxMjc5LC4yMjkwOTgsLjAwNTI2XSxbLjkzNTExNiwuMjM1ODA2LC4wMDQ3MzFdLFsuOTM4Nzc2LC4yNDI2NjYsLjAwNDI0Ml0sWy45NDIyNTcsLjI0OTY3NywuMDAzNzkzXSxbLjk0NTU1OCwuMjU2ODQzLC4wMDMzODZdLFsuOTQ4Njc3LC4yNjQxNjIsLjAwMzAyMl0sWy45NTE2MTMsLjI3MTYzOSwuMDAyNzA0XSxbLjk1NDM2NSwuMjc5Mjc0LC4wMDI0MzFdLFsuOTU2OTMsLjI4NzA2NywuMDAyMjA3XSxbLjk1OTMwNywuMjk1MDIxLC4wMDIwMzJdLFsuOTYxNDk4LC4zMDMxMzcsLjAwMTkwOV0sWy45NjM0OTUsLjMxMTQxNCwuMDAxODRdLFsuOTY1MzA0LC4zMTk4NTgsLjAwMTgyN10sWy45NjY5MTgsLjMyODQ2NSwuMDAxODczXSxbLjk2ODM0LC4zMzcyNDEsLjAwMTk4MV0sWy45Njk1NjgsLjM0NjE4NCwuMDAyMTUzXSxbLjk3MDYwMSwuMzU1Mjk1LC4wMDIzOTJdLFsuOTcxNDM1LC4zNjQ1NzYsLjAwMjcwMl0sWy45NzIwNzIsLjM3NDAyOSwuMDAzMDg3XSxbLjk3MjUxMywuMzgzNjU0LC4wMDM1NV0sWy45NzI3NTMsLjM5MzQ1MywuMDA0MDk1XSxbLjk3Mjc5NSwuNDAzNDI1LC4wMDQ3MjddLFsuOTcyNjM2LC40MTM1NzEsLjAwNTQ1MV0sWy45NzIyNzgsLjQyMzg5NCwuMDA2MjcxXSxbLjk3MTcxOSwuNDM0MzkxLC4wMDcxOTNdLFsuOTcwOTU5LC40NDUwNjYsLjAwODIyM10sWy45Njk5OTcsLjQ1NTkxOCwuMDA5MzY4XSxbLjk2ODgzOCwuNDY2OTQ4LC4wMTA2MzNdLFsuOTY3NDc4LC40NzgxNTYsLjAxMjAyN10sWy45NjU5MTUsLjQ4OTU0MywuMDEzNTU3XSxbLjk2NDE1NCwuNTAxMTA5LC4wMTUyMzFdLFsuOTYyMTk4LC41MTI4NSwuMDE3MDZdLFsuOTYwMDQ2LC41MjQ3NzEsLjAxOTA1Ml0sWy45NTc3MDQsLjUzNjg2NSwuMDIxMjE5XSxbLjk1NTE3NiwuNTQ5MTM2LC4wMjM1NzJdLFsuOTUyNDYyLC41NjE1NzgsLjAyNjEyM10sWy45NDk1NywuNTc0MTkxLC4wMjg4ODddLFsuOTQ2NTA4LC41ODY5NzMsLjAzMTg3OF0sWy45NDMyNzIsLjU5OTkyMywuMDM1MTEyXSxbLjkzOTg2OCwuNjEzMDM2LC4wMzg2MDldLFsuOTM2MzE3LC42MjYzMDgsLjA0MjM4Nl0sWy45MzI2MzMsLjYzOTcyOCwuMDQ2NDY0XSxbLjkyODgzMiwuNjUzMjkyLC4wNTA4NjVdLFsuOTI0OTE5LC42NjY5OTcsLjA1NTYxNl0sWy45MjA5MDUsLjY4MDgzNCwuMDYwNzQ4XSxbLjkxNjg0MSwuNjk0NzgzLC4wNjYyODVdLFsuOTEyNzU3LC43MDg4MzMsLjA3MjI1N10sWy45MDg2NTIsLjcyMjk3NSwuMDc4NzExXSxbLjkwNDU5OSwuNzM3MTg1LC4wODU2NzZdLFsuOTAwNjYzLC43NTE0MzIsLjA5MzE4NF0sWy44OTY4NTQsLjc2NTcwNywuMTAxMjk5XSxbLjg5MzI5NSwuNzc5OTY1LC4xMTAwMzldLFsuODkwMDQ0LC43OTQxNzUsLjExOTQ1OV0sWy44ODcyMDksLjgwODI5NiwuMTI5NTkxXSxbLjg4NDksLjgyMjI4MiwuMTQwNDY2XSxbLjg4MzIzOCwuODM2MDg3LC4xNTIxMDddLFsuODgyMzU2LC44NDk2NjIsLjE2NDUyXSxbLjg4MjM3OSwuODYyOTU3LC4xNzc2OTZdLFsuODgzNDM3LC44NzU5MzMsLjE5MTYwMV0sWy44ODU2MjcsLjg4ODU1NiwuMjA2MTkxXSxbLjg4OTAzOSwuOTAwODA0LC4yMjEzODhdLFsuODkzNzA4LC45MTI2NzMsLjIzNzEzMV0sWy44OTk2NjIsLjkyNDE2NSwuMjUzMzE5XSxbLjkwNjg4LC45MzUzLC4yNjk4NzVdLFsuOTE1MzE3LC45NDYxMDIsLjI4Njc1NV0sWy45MjQ5MzIsLjk1NjYwNywuMzAzODE3XSxbLjkzNTY0OCwuOTY2ODQ1LC4zMjEwNjddLFsuOTQ3Mzk1LC45NzY4NDcsLjMzODQ2XSxbLjk2MDExMSwuOTg2NjUxLC4zNTU5NTddLFsuOTczNzI5LC45OTYyODIsLjM3MzUyMl1dLEs2PVtbLjAwMzk3LC4wMDIzMDcsLjI0MDg1NF0sWy4wMDUyNjUsLjAwMjIsLjI0NTk5MV0sWy4wMDY2MTQsLjAwMjEwNiwuMjUwOTIxXSxbLjAwODAxNiwuMDAyMDIyLC4yNTU2N10sWy4wMDk0NywuMDAxOTQ4LC4yNjAyNThdLFsuMDEwOTc2LC4wMDE4ODIsLjI2NDcwNF0sWy4wMTI1MzIsLjAwMTgyMywuMjY5MDJdLFsuMDE0MTQxLC4wMDE3NzEsLjI3MzIyMl0sWy4wMTU4MDMsLjAwMTcyMywuMjc3MzI0XSxbLjAxNzUxOCwuMDAxNjc5LC4yODEzMzRdLFsuMDE5Mjg4LC4wMDE2MzcsLjI4NTI2MV0sWy4wMjExMTMsLjAwMTU5OCwuMjg5MTFdLFsuMDIyOTkzLC4wMDE1NjEsLjI5Mjg4OV0sWy4wMjQ5MjksLjAwMTUyNSwuMjk2NjAxXSxbLjAyNjkyMSwuMDAxNDksLjMwMDI1MV0sWy4wMjg5NywuMDAxNDU1LC4zMDM4NDJdLFsuMDMxMDc4LC4wMDE0MjEsLjMwNzM3Nl0sWy4wMzMyNDQsLjAwMTM4NiwuMzEwODU2XSxbLjAzNTQ2OSwuMDAxMzUsLjMxNDI4M10sWy4wMzc3NTMsLjAwMTMxNCwuMzE3NjU5XSxbLjA0MDA5OCwuMDAxMjc3LC4zMjA5ODNdLFsuMDQyNTAzLC4wMDEyMzksLjMyNDI1N10sWy4wNDQ5NywuMDAxMiwuMzI3NDhdLFsuMDQ3NDk5LC4wMDExNTksLjMzMDY1M10sWy4wNTAwOTIsLjAwMTExOCwuMzMzNzczXSxbLjA1Mjc0OCwuMDAxMDc0LC4zMzY4NDFdLFsuMDU1NDY5LC4wMDEwMywuMzM5ODU0XSxbLjA1ODI1Myw5ODRlLTYsLjM0MjgxM10sWy4wNjExMDQsOTM3ZS02LC4zNDU3MTVdLFsuMDY0MDIsODg5ZS02LC4zNDg1NTddLFsuMDY3MDAyLDg0ZS01LC4zNTEzNF0sWy4wNzAwNTEsNzllLTUsLjM1NDA1OV0sWy4wNzMxNjcsNzRlLTUsLjM1NjcxNF0sWy4wNzYzNTEsNjg5ZS02LC4zNTkzXSxbLjA3OTYwNCw2MzhlLTYsLjM2MTgxN10sWy4wODI5MjUsNTg2ZS02LC4zNjQyNjFdLFsuMDg2MzE1LDUzNWUtNiwuMzY2NjI4XSxbLjA4OTc3NSw0ODVlLTYsLjM2ODkxOF0sWy4wOTMzMDMsNDM1ZS02LC4zNzExMjVdLFsuMDk2OTAyLDM4NmUtNiwuMzczMjQ4XSxbLjEwMDU3MSwzMzllLTYsLjM3NTI4NF0sWy4xMDQzMSwyOTRlLTYsLjM3NzIyOV0sWy4xMDgxMTksMjUxZS02LC4zNzkwOF0sWy4xMTE5OTksMjExZS02LC4zODA4MzRdLFsuMTE1OTQ5LDE3NGUtNiwuMzgyNDg4XSxbLjExOTk3LDE0ZS01LC4zODQwMzhdLFsuMTI0MDYyLDExMWUtNiwuMzg1NDgzXSxbLjEyODIyNCw4NmUtNiwuMzg2ODE4XSxbLjEzMjQ1Niw2NmUtNiwuMzg4MDRdLFsuMTM2NzU4LDUyZS02LC4zODkxNDZdLFsuMTQxMTI5LDQ1ZS02LC4zOTAxMzRdLFsuMTQ1NTcsNDRlLTYsLjM5MTAwMl0sWy4xNTAwOCw1ZS01LC4zOTE3NDddLFsuMTU0NjU3LDY0ZS02LC4zOTIzNjVdLFsuMTU5MzAzLDg3ZS02LC4zOTI4NTVdLFsuMTY0MDE2LDExOWUtNiwuMzkzMjE0XSxbLjE2ODc5NywxNjFlLTYsLjM5MzQ0XSxbLjE3MzY0MiwyMTNlLTYsLjM5MzUzMl0sWy4xNzg1NTMsMjc3ZS02LC4zOTM0ODldLFsuMTgzNTI5LDM1MmUtNiwuMzkzMzA3XSxbLjE4ODU2Nyw0MzllLTYsLjM5Mjk4N10sWy4xOTM2NjcsNTRlLTUsLjM5MjUyOF0sWy4xOTg4MjgsNjU1ZS02LC4zOTE5M10sWy4yMDQwNSw3ODRlLTYsLjM5MTE5MV0sWy4yMDkzMyw5MjhlLTYsLjM5MDMxMl0sWy4yMTQ2NjksLjAwMTA4OCwuMzg5MjkxXSxbLjIyMDA2NCwuMDAxMjY0LC4zODgxM10sWy4yMjU1MTMsLjAwMTQ1OCwuMzg2ODMxXSxbLjIzMTAxNywuMDAxNjY5LC4zODUzOTRdLFsuMjM2NTcxLC4wMDE4OTksLjM4MzgyXSxbLjI0MjE3NiwuMDAyMTQ4LC4zODIxMTFdLFsuMjQ3ODMsLjAwMjQxNiwuMzgwMjddLFsuMjUzNTMyLC4wMDI3MDUsLjM3ODI5OV0sWy4yNTkyNzgsLjAwMzAxNSwuMzc2MTk5XSxbLjI2NTA2OCwuMDAzMzQ2LC4zNzM5NzRdLFsuMjcwOTAxLC4wMDM3LC4zNzE2MjhdLFsuMjc2NzczLC4wMDQwNzYsLjM2OTE2M10sWy4yODI2ODQsLjAwNDQ3NiwuMzY2NTg0XSxbLjI4ODYzMywuMDA0ODk5LC4zNjM4OTNdLFsuMjk0NjE2LC4wMDUzNDcsLjM2MTA5Nl0sWy4zMDA2MzEsLjAwNTgxOSwuMzU4MTk3XSxbLjMwNjY3OCwuMDA2MzE3LC4zNTUxOTldLFsuMzEyNzU1LC4wMDY4NCwuMzUyMTA5XSxbLjMxODg1NywuMDA3MzksLjM0ODkzMV0sWy4zMjQ5ODYsLjAwNzk2NiwuMzQ1NjcxXSxbLjMzMTEzOSwuMDA4NTY5LC4zNDIzMzJdLFsuMzM3MzE1LC4wMDkyLC4zMzg5Ml0sWy4zNDM1MTEsLjAwOTg1OCwuMzM1NDQyXSxbLjM0OTcyNSwuMDEwNTQ1LC4zMzE5MDJdLFsuMzU1OTU3LC4wMTEyNTksLjMyODMwNV0sWy4zNjIyMDQsLjAxMjAwMywuMzI0NjU2XSxbLjM2ODQ2NCwuMDEyNzc2LC4zMjA5NjJdLFsuMzc0NzM3LC4wMTM1NzgsLjMxNzIyNl0sWy4zODEwMjIsLjAxNDQwOSwuMzEzNDU1XSxbLjM4NzMxNiwuMDE1MjcxLC4zMDk2NTNdLFsuMzkzNjE3LC4wMTYxNjIsLjMwNTgyNV0sWy4zOTk5MjUsLjAxNzA4NCwuMzAxOTc3XSxbLjQwNjI0LC4wMTgwMzYsLjI5ODExM10sWy40MTI1NTksLjAxOTAxOSwuMjk0MjM2XSxbLjQxODg4MiwuMDIwMDM0LC4yOTAzNTFdLFsuNDI1MjA2LC4wMjEwNzksLjI4NjQ2NF0sWy40MzE1MzIsLjAyMjE1NSwuMjgyNTc4XSxbLjQzNzg2LC4wMjMyNjQsLjI3ODY5Nl0sWy40NDQxODcsLjAyNDQwMywuMjc0ODIxXSxbLjQ1MDUxMiwuMDI1NTc1LC4yNzA5NThdLFsuNDU2ODM3LC4wMjY3NzksLjI2NzEwOV0sWy40NjMxNTgsLjAyODAxNiwuMjYzMjc4XSxbLjQ2OTQ3NiwuMDI5Mjg1LC4yNTk0NjVdLFsuNDc1NzkxLC4wMzA1ODYsLjI1NTY3Nl0sWy40ODIxMDMsLjAzMTkyLC4yNTE5MTJdLFsuNDg4NDA4LC4wMzMyODgsLjI0ODE3NF0sWy40OTQ3MSwuMDM0Njg4LC4yNDQ0NjVdLFsuNTAxMDA2LC4wMzYxMjIsLjI0MDc4OF0sWy41MDcyOTcsLjAzNzU5LC4yMzcxNDRdLFsuNTEzNTgxLC4wMzkwOTIsLjIzMzUzMl0sWy41MTk4NiwuMDQwNjI3LC4yMjk5NTVdLFsuNTI2MTMsLjA0MjE5NywuMjI2NDE0XSxbLjUzMjM5NiwuMDQzODAyLC4yMjI5MDldLFsuNTM4NjU0LC4wNDU0NDEsLjIxOTQ0M10sWy41NDQ5MDUsLjA0NzExNiwuMjE2MDE0XSxbLjU1MTE0NywuMDQ4ODI2LC4yMTI2MjNdLFsuNTU3Mzg0LC4wNTA1NzEsLjIwOTI3MV0sWy41NjM2MTMsLjA1MjM1MywuMjA1OTZdLFsuNTY5ODMyLC4wNTQxNywuMjAyNjg4XSxbLjU3NjA0NCwuMDU2MDI1LC4xOTk0NTddLFsuNTgyMjQ4LC4wNTc5MTYsLjE5NjI2NF0sWy41ODg0NDMsLjA1OTg0NCwuMTkzMTFdLFsuNTk0NjI5LC4wNjE4MSwuMTg5OTk3XSxbLjYwMDgwOCwuMDYzODE0LC4xODY5MjFdLFsuNjA2OTc2LC4wNjU4NTYsLjE4Mzg4NV0sWy42MTMxMzUsLjA2NzkzNywuMTgwODg3XSxbLjYxOTI4NCwuMDcwMDU3LC4xNzc5MjddLFsuNjI1NDI1LC4wNzIyMTcsLjE3NTAwNl0sWy42MzE1NTMsLjA3NDQxNywuMTcyMTIxXSxbLjYzNzY3MiwuMDc2NjU3LC4xNjkyNzRdLFsuNjQzNzgsLjA3ODkzOSwuMTY2NDYzXSxbLjY0OTg3OCwuMDgxMjYyLC4xNjM2ODddLFsuNjU1OTYzLC4wODM2MjcsLjE2MDk0Nl0sWy42NjIwMzQsLjA4NjAzNSwuMTU4MjRdLFsuNjY4MDkzLC4wODg0ODYsLjE1NTU2N10sWy42NzQxNCwuMDkwOTgsLjE1MjkyOV0sWy42ODAxNzIsLjA5MzUxOSwuMTUwMzI0XSxbLjY4NjE5MSwuMDk2MTAzLC4xNDc3NV0sWy42OTIxOTIsLjA5ODczMywuMTQ1MjA5XSxbLjY5ODE3OCwuMTAxNDA5LC4xNDI2OThdLFsuNzA0MTQ4LC4xMDQxMzEsLjE0MDIxOF0sWy43MTAxMDEsLjEwNjkwMiwuMTM3NzY4XSxbLjcxNjAzNCwuMTA5NzIsLjEzNTM0OF0sWy43MjE5NDcsLjExMjU4OCwuMTMyOTU3XSxbLjcyNzg0LC4xMTU1MDcsLjEzMDU5NF0sWy43MzM3MTMsLjExODQ3NSwuMTI4MjU5XSxbLjczOTU2MiwuMTIxNDk1LC4xMjU5NTFdLFsuNzQ1Mzg4LC4xMjQ1NjcsLjEyMzY3XSxbLjc1MTE4OSwuMTI3NjkyLC4xMjE0MTZdLFsuNzU2OTY0LC4xMzA4NzIsLjExOTE4OF0sWy43NjI3MTMsLjEzNDEwNywuMTE2OTg2XSxbLjc2ODQzMiwuMTM3Mzk3LC4xMTQ4MDldLFsuNzc0MTIxLC4xNDA3NDMsLjExMjY1N10sWy43Nzk3NzgsLjE0NDE0NywuMTEwNTNdLFsuNzg1NDAzLC4xNDc2MTEsLjEwODQyNl0sWy43OTA5OTMsLjE1MTEzNCwuMTA2MzQ3XSxbLjc5NjU0OCwuMTU0NzE3LC4xMDQyOTFdLFsuODAyMDY1LC4xNTgzNjIsLjEwMjI1OV0sWy44MDc1NDMsLjE2MjA3MSwuMTAwMjQ5XSxbLjgxMjk3OSwuMTY1ODQzLC4wOTgyNjRdLFsuODE4Mzc1LC4xNjk2NzksLjA5NjNdLFsuODIzNzI0LC4xNzM1ODEsLjA5NDM1OV0sWy44MjkwMjYsLjE3NzU1MSwuMDkyNDRdLFsuODM0MjgyLC4xODE1ODksLjA5MDU0M10sWy44Mzk0ODcsLjE4NTY5NiwuMDg4NjY4XSxbLjg0NDYzOSwuMTg5ODc0LC4wODY4MTZdLFsuODQ5NzM4LC4xOTQxMjQsLjA4NDk4NF0sWy44NTQ3ODIsLjE5ODQ0NywuMDgzMTc1XSxbLjg1OTc2OSwuMjAyODQzLC4wODEzODddLFsuODY0NjkzLC4yMDczMTYsLjA3OTYyXSxbLjg2OTU1NSwuMjExODY1LC4wNzc4NzZdLFsuODc0MzU0LC4yMTY0OTIsLjA3NjE1Ml0sWy44NzkwODYsLjIyMTE5OCwuMDc0NDQ5XSxbLjg4Mzc1LC4yMjU5ODQsLjA3Mjc2OV0sWy44ODgzNDIsLjIzMDg1MiwuMDcxMTA5XSxbLjg5Mjg2NCwuMjM1ODA0LC4wNjk0NzJdLFsuODk3MzA5LC4yNDA4MzksLjA2Nzg1NV0sWy45MDE2NzYsLjI0NTk2LC4wNjYyNTldLFsuOTA1OTYyLC4yNTExNjgsLjA2NDY4NV0sWy45MTAxNjcsLjI1NjQ2NSwuMDYzMTMyXSxbLjkxNDI4OSwuMjYxODUxLC4wNjE2MDFdLFsuOTE4MzI1LC4yNjczMjgsLjA2MDA5Ml0sWy45MjIyNzIsLjI3Mjg5NywuMDU4NjA1XSxbLjkyNjEyNiwuMjc4NTYsLjA1NzE0XSxbLjkyOTg4OSwuMjg0MzE5LC4wNTU2OTVdLFsuOTMzNTU1LC4yOTAxNzMsLjA1NDI3M10sWy45MzcxMjEsLjI5NjEyNywuMDUyODczXSxbLjk0MDU4NywuMzAyMTc5LC4wNTE0OTVdLFsuOTQzOTUxLC4zMDgzMzIsLjA1MDEzOV0sWy45NDcyMTMsLjMxNDU4NywuMDQ4ODA2XSxbLjk1MDM2MywuMzIwOTQ2LC4wNDc0OTZdLFsuOTUzNDA3LC4zMjc0MDksLjA0NjIwOV0sWy45NTYzMzYsLjMzMzk3OCwuMDQ0OTQ0XSxbLjk1OTE1NCwuMzQwNjU2LC4wNDM3MDRdLFsuOTYxODUzLC4zNDc0NDIsLjA0MjQ4Nl0sWy45NjQ0MzEsLjM1NDM0MiwuMDQxMjkyXSxbLjk2Njg4NywuMzYxMzUyLC4wNDAxMjFdLFsuOTY5MjE3LC4zNjg0NzYsLjAzODk3NV0sWy45NzE0MjMsLjM3NTcxNSwuMDM3ODU0XSxbLjk3MzUsLjM4MzA3MSwuMDM2NzU3XSxbLjk3NTQ0NiwuMzkwNTQ2LC4wMzU2ODVdLFsuOTc3MjU2LC4zOTgxMzksLjAzNDYzOV0sWy45Nzg5MzEsLjQwNTg1NCwuMDMzNjE5XSxbLjk4MDQ2OSwuNDEzNjkxLC4wMzI2MjVdLFsuOTgxODY0LC40MjE2NTIsLjAzMTY1OF0sWy45ODMxMTYsLjQyOTc0LC4wMzA3MTddLFsuOTg0MjIyLC40Mzc5NTQsLjAyOTgwNV0sWy45ODUxNzgsLjQ0NjI5NiwuMDI4OTIxXSxbLjk4NTk4NSwuNDU0NzcsLjAyODA2NV0sWy45ODY2MzcsLjQ2MzM3NCwuMDI3MjM5XSxbLjk4NzEzNiwuNDcyMTEyLC4wMjY0NDJdLFsuOTg3NDc1LC40ODA5ODQsLjAyNTY3Nl0sWy45ODc2NTMsLjQ4OTk5NCwuMDI0OTQxXSxbLjk4NzY3MiwuNDk5MTQxLC4wMjQyMzhdLFsuOTg3NTIyLC41MDg0MjcsLjAyMzU2OF0sWy45ODcyMDYsLjUxNzg1MiwuMDIyOTNdLFsuOTg2NzIzLC41Mjc0MjIsLjAyMjMyN10sWy45ODYwNjksLjUzNzEzMywuMDIxNzU5XSxbLjk4NTIzNiwuNTQ2OTkzLC4wMjEyMjZdLFsuOTg0MjI0LC41NTY5OTksLjAyMDcyOF0sWy45ODMwMzQsLjU2NzE1NCwuMDIwMjY4XSxbLjk4MTY2NSwuNTc3NDU3LC4wMTk4NDddLFsuOTgwMTE4LC41ODc5MTIsLjAxOTQ2NF0sWy45NzgzODgsLjU5ODUxNywuMDE5MTIxXSxbLjk3NjQ3NSwuNjA5Mjc0LC4wMTg4MTldLFsuOTc0MzcsLjYyMDE5MSwuMDE4NTU4XSxbLjk3MjA3LC42MzEyNjQsLjAxODMzOF0sWy45Njk1ODQsLjY0MjQ5NSwuMDE4MTZdLFsuOTY2OTE2LC42NTM4OCwuMDE4MDI2XSxbLjk2NDA1NywuNjY1NDI1LC4wMTc5MzVdLFsuOTYwOTkxLC42NzcxMzksLjAxNzg4Nl0sWy45NTc3NDIsLjY4OTAwOCwuMDE3ODgxXSxbLjk1NDMxNiwuNzAxMDM1LC4wMTc5MTldLFsuOTUwNjcsLjcxMzIzOCwuMDE3OTk2XSxbLjk0Njg1MywuNzI1NTk4LC4wMTgxMTVdLFsuOTQyODQ0LC43MzgxMjQsLjAxODI3MV0sWy45Mzg2NDQsLjc1MDgxOCwuMDE4NDYxXSxbLjkzNDI3MiwuNzYzNjczLC4wMTg2ODNdLFsuOTI5NzA5LC43NzY2OTgsLjAxODkyOF0sWy45MjQ5OCwuNzg5ODg2LC4wMTkxOTFdLFsuOTIwMDk3LC44MDMyMzYsLjAxOTQ2Ml0sWy45MTUwMzQsLjgxNjc1OSwuMDE5NzI2XSxbLjkwOTg0OCwuODMwNDQsLjAxOTk2OF0sWy45MDQ1NDMsLjg0NDI3NSwuMDIwMTY0XSxbLjg5OTE0NCwuODU4MjY2LC4wMjAyODRdLFsuODkzNjc4LC44NzI0MDYsLjAyMDI4NV0sWy44ODgyMDIsLjg4NjY4MywuMDIwMTFdLFsuODgyOCwuOTAxMDc2LC4wMTk2ODJdLFsuODc3NjI3LC45MTU1NDIsLjAxODg5NF0sWy44NzI4NzgsLjkzMDAyOSwuMDE3NTk0XSxbLjg2ODkzMSwuOTQ0NDE2LC4wMTU1OV1dLFo2PVtbLjE4OTk1LC4wNzE3NiwuMjMyMTddLFsuMTk0ODMsLjA4MzM5LC4yNjE0OV0sWy4xOTk1NiwuMDk0OTgsLjI5MDI0XSxbLjIwNDE1LC4xMDY1MiwuMzE4NDRdLFsuMjA4NiwuMTE4MDIsLjM0NjA3XSxbLjIxMjkxLC4xMjk0NywuMzczMTRdLFsuMjE3MDgsLjE0MDg3LC4zOTk2NF0sWy4yMjExMSwuMTUyMjMsLjQyNTU4XSxbLjIyNSwuMTYzNTQsLjQ1MDk2XSxbLjIyODc1LC4xNzQ4MSwuNDc1NzhdLFsuMjMyMzYsLjE4NjAzLC41MDAwNF0sWy4yMzU4MiwuMTk3MiwuNTIzNzNdLFsuMjM5MTUsLjIwODMzLC41NDY4Nl0sWy4yNDIzNCwuMjE5NDEsLjU2OTQyXSxbLjI0NTM5LC4yMzA0NCwuNTkxNDJdLFsuMjQ4MywuMjQxNDMsLjYxMjg2XSxbLjI1MTA3LC4yNTIzNywuNjMzNzRdLFsuMjUzNjksLjI2MzI3LC42NTQwNl0sWy4yNTYxOCwuMjc0MTIsLjY3MzgxXSxbLjI1ODUzLC4yODQ5MiwuNjkzXSxbLjI2MDc0LC4yOTU2OCwuNzExNjJdLFsuMjYyOCwuMzA2MzksLjcyOTY4XSxbLjI2NDczLC4zMTcwNiwuNzQ3MThdLFsuMjY2NTIsLjMyNzY4LC43NjQxMl0sWy4yNjgxNiwuMzM4MjUsLjc4MDVdLFsuMjY5NjcsLjM0ODc4LC43OTYzMV0sWy4yNzEwMywuMzU5MjYsLjgxMTU2XSxbLjI3MjI2LC4zNjk3LC44MjYyNF0sWy4yNzMzNCwuMzgwMDgsLjg0MDM3XSxbLjI3NDI5LC4zOTA0MywuODUzOTNdLFsuMjc1MDksLjQwMDcyLC44NjY5Ml0sWy4yNzU3NiwuNDEwOTcsLjg3OTM2XSxbLjI3NjI4LC40MjExOCwuODkxMjNdLFsuMjc2NjcsLjQzMTM0LC45MDI1NF0sWy4yNzY5MSwuNDQxNDUsLjkxMzI4XSxbLjI3NzAxLC40NTE1MiwuOTIzNDddLFsuMjc2OTgsLjQ2MTUzLC45MzMwOV0sWy4yNzY4LC40NzE1MSwuOTQyMTRdLFsuMjc2NDgsLjQ4MTQ0LC45NTA2NF0sWy4yNzYwMywuNDkxMzIsLjk1ODU3XSxbLjI3NTQzLC41MDExNSwuOTY1OTRdLFsuMjc0NjksLjUxMDk0LC45NzI3NV0sWy4yNzM4MSwuNTIwNjksLjk3ODk5XSxbLjI3MjczLC41MzA0LC45ODQ2MV0sWy4yNzEwNiwuNTQwMTUsLjk4OTNdLFsuMjY4NzgsLjU0OTk1LC45OTMwM10sWy4yNjU5MiwuNTU5NzksLjk5NTgzXSxbLjI2MjUyLC41Njk2NywuOTk3NzNdLFsuMjU4NjIsLjU3OTU4LC45OTg3Nl0sWy4yNTQyNSwuNTg5NSwuOTk4OTZdLFsuMjQ5NDYsLjU5OTQzLC45OTgzNV0sWy4yNDQyNywuNjA5MzcsLjk5Njk3XSxbLjIzODc0LC42MTkzMSwuOTk0ODVdLFsuMjMyODgsLjYyOTIzLC45OTIwMl0sWy4yMjY3NiwuNjM5MTMsLjk4ODUxXSxbLjIyMDM5LC42NDkwMSwuOTg0MzZdLFsuMjEzODIsLjY1ODg2LC45Nzk1OV0sWy4yMDcwOCwuNjY4NjYsLjk3NDIzXSxbLjIwMDIxLC42Nzg0MiwuOTY4MzNdLFsuMTkzMjYsLjY4ODEyLC45NjE5XSxbLjE4NjI1LC42OTc3NSwuOTU0OThdLFsuMTc5MjMsLjcwNzMyLC45NDc2MV0sWy4xNzIyMywuNzE2OCwuOTM5ODFdLFsuMTY1MjksLjcyNjIsLjkzMTYxXSxbLjE1ODQ0LC43MzU1MSwuOTIzMDVdLFsuMTUxNzMsLjc0NDcyLC45MTQxNl0sWy4xNDUxOSwuNzUzODEsLjkwNDk2XSxbLjEzODg2LC43NjI3OSwuODk1NV0sWy4xMzI3OCwuNzcxNjUsLjg4NThdLFsuMTI2OTgsLjc4MDM3LC44NzU5XSxbLjEyMTUxLC43ODg5NiwuODY1ODFdLFsuMTE2MzksLjc5NzQsLjg1NTU5XSxbLjExMTY3LC44MDU2OSwuODQ1MjVdLFsuMTA3MzgsLjgxMzgxLC44MzQ4NF0sWy4xMDM1NywuODIxNzcsLjgyNDM3XSxbLjEwMDI2LC44Mjk1NSwuODEzODldLFsuMDk3NSwuODM3MTQsLjgwMzQyXSxbLjA5NTMyLC44NDQ1NSwuNzkyOTldLFsuMDkzNzcsLjg1MTc1LC43ODI2NF0sWy4wOTI4NywuODU4NzUsLjc3MjRdLFsuMDkyNjcsLjg2NTU0LC43NjIzXSxbLjA5MzIsLjg3MjExLC43NTIzN10sWy4wOTQ1MSwuODc4NDQsLjc0MjY1XSxbLjA5NjYyLC44ODQ1NCwuNzMzMTZdLFsuMDk5NTgsLjg5MDQsLjcyMzkzXSxbLjEwMzQyLC44OTYsLjcxNV0sWy4xMDgxNSwuOTAxNDIsLjcwNTk5XSxbLjExMzc0LC45MDY3MywuNjk2NTFdLFsuMTIwMTQsLjkxMTkzLC42ODY2XSxbLjEyNzMzLC45MTcwMSwuNjc2MjddLFsuMTM1MjYsLjkyMTk3LC42NjU1Nl0sWy4xNDM5MSwuOTI2OCwuNjU0NDhdLFsuMTUzMjMsLjkzMTUxLC42NDMwOF0sWy4xNjMxOSwuOTM2MDksLjYzMTM3XSxbLjE3Mzc3LC45NDA1MywuNjE5MzhdLFsuMTg0OTEsLjk0NDg0LC42MDcxM10sWy4xOTY1OSwuOTQ5MDEsLjU5NDY2XSxbLjIwODc3LC45NTMwNCwuNTgxOTldLFsuMjIxNDIsLjk1NjkyLC41NjkxNF0sWy4yMzQ0OSwuOTYwNjUsLjU1NjE0XSxbLjI0Nzk3LC45NjQyMywuNTQzMDNdLFsuMjYxOCwuOTY3NjUsLjUyOTgxXSxbLjI3NTk3LC45NzA5MiwuNTE2NTNdLFsuMjkwNDIsLjk3NDAzLC41MDMyMV0sWy4zMDUxMywuOTc2OTcsLjQ4OTg3XSxbLjMyMDA2LC45Nzk3NCwuNDc2NTRdLFsuMzM1MTcsLjk4MjM0LC40NjMyNV0sWy4zNTA0MywuOTg0NzcsLjQ1MDAyXSxbLjM2NTgxLC45ODcwMiwuNDM2ODhdLFsuMzgxMjcsLjk4OTA5LC40MjM4Nl0sWy4zOTY3OCwuOTkwOTgsLjQxMDk4XSxbLjQxMjI5LC45OTI2OCwuMzk4MjZdLFsuNDI3NzgsLjk5NDE5LC4zODU3NV0sWy40NDMyMSwuOTk1NTEsLjM3MzQ1XSxbLjQ1ODU0LC45OTY2MywuMzYxNF0sWy40NzM3NSwuOTk3NTUsLjM0OTYzXSxbLjQ4ODc5LC45OTgyOCwuMzM4MTZdLFsuNTAzNjIsLjk5ODc5LC4zMjcwMV0sWy41MTgyMiwuOTk5MSwuMzE2MjJdLFsuNTMyNTUsLjk5OTE5LC4zMDU4MV0sWy41NDY1OCwuOTk5MDcsLjI5NTgxXSxbLjU2MDI2LC45OTg3MywuMjg2MjNdLFsuNTczNTcsLjk5ODE3LC4yNzcxMl0sWy41ODY0NiwuOTk3MzksLjI2ODQ5XSxbLjU5ODkxLC45OTYzOCwuMjYwMzhdLFsuNjEwODgsLjk5NTE0LC4yNTI4XSxbLjYyMjMzLC45OTM2NiwuMjQ1NzldLFsuNjMzMjMsLjk5MTk1LC4yMzkzN10sWy42NDM2MiwuOTg5OTksLjIzMzU2XSxbLjY1Mzk0LC45ODc3NSwuMjI4MzVdLFsuNjY0MjgsLjk4NTI0LC4yMjM3XSxbLjY3NDYyLC45ODI0NiwuMjE5Nl0sWy42ODQ5NCwuOTc5NDEsLjIxNjAyXSxbLjY5NTI1LC45NzYxLC4yMTI5NF0sWy43MDU1MywuOTcyNTUsLjIxMDMyXSxbLjcxNTc3LC45Njg3NSwuMjA4MTVdLFsuNzI1OTYsLjk2NDcsLjIwNjRdLFsuNzM2MSwuOTYwNDMsLjIwNTA0XSxbLjc0NjE3LC45NTU5MywuMjA0MDZdLFsuNzU2MTcsLjk1MTIxLC4yMDM0M10sWy43NjYwOCwuOTQ2MjcsLjIwMzExXSxbLjc3NTkxLC45NDExMywuMjAzMV0sWy43ODU2MywuOTM1NzksLjIwMzM2XSxbLjc5NTI0LC45MzAyNSwuMjAzODZdLFsuODA0NzMsLjkyNDUyLC4yMDQ1OV0sWy44MTQxLC45MTg2MSwuMjA1NTJdLFsuODIzMzMsLjkxMjUzLC4yMDY2M10sWy44MzI0MSwuOTA2MjcsLjIwNzg4XSxbLjg0MTMzLC44OTk4NiwuMjA5MjZdLFsuODUwMSwuODkzMjgsLjIxMDc0XSxbLjg1ODY4LC44ODY1NSwuMjEyM10sWy44NjcwOSwuODc5NjgsLjIxMzkxXSxbLjg3NTMsLjg3MjY3LC4yMTU1NV0sWy44ODMzMSwuODY1NTMsLjIxNzE5XSxbLjg5MTEyLC44NTgyNiwuMjE4OF0sWy44OTg3LC44NTA4NywuMjIwMzhdLFsuOTA2MDUsLjg0MzM3LC4yMjE4OF0sWy45MTMxNywuODM1NzYsLjIyMzI4XSxbLjkyMDA0LC44MjgwNiwuMjI0NTZdLFsuOTI2NjYsLjgyMDI1LC4yMjU3XSxbLjkzMzAxLC44MTIzNiwuMjI2NjddLFsuOTM5MDksLjgwNDM5LC4yMjc0NF0sWy45NDQ4OSwuNzk2MzQsLjIyOF0sWy45NTAzOSwuNzg4MjMsLjIyODMxXSxbLjk1NTYsLjc4MDA1LC4yMjgzNl0sWy45NjA0OSwuNzcxODEsLjIyODExXSxbLjk2NTA3LC43NjM1MiwuMjI3NTRdLFsuOTY5MzEsLjc1NTE5LC4yMjY2M10sWy45NzMyMywuNzQ2ODIsLjIyNTM2XSxbLjk3Njc5LC43Mzg0MiwuMjIzNjldLFsuOTgsLjczLC4yMjE2MV0sWy45ODI4OSwuNzIxNCwuMjE5MThdLFsuOTg1NDksLjcxMjUsLjIxNjVdLFsuOTg3ODEsLjcwMzMsLjIxMzU4XSxbLjk4OTg2LC42OTM4MiwuMjEwNDNdLFsuOTkxNjMsLjY4NDA4LC4yMDcwNl0sWy45OTMxNCwuNjc0MDgsLjIwMzQ4XSxbLjk5NDM4LC42NjM4NiwuMTk5NzFdLFsuOTk1MzUsLjY1MzQxLC4xOTU3N10sWy45OTYwNywuNjQyNzcsLjE5MTY1XSxbLjk5NjU0LC42MzE5MywuMTg3MzhdLFsuOTk2NzUsLjYyMDkzLC4xODI5N10sWy45OTY3MiwuNjA5NzcsLjE3ODQyXSxbLjk5NjQ0LC41OTg0NiwuMTczNzZdLFsuOTk1OTMsLjU4NzAzLC4xNjg5OV0sWy45OTUxNywuNTc1NDksLjE2NDEyXSxbLjk5NDE5LC41NjM4NiwuMTU5MThdLFsuOTkyOTcsLjU1MjE0LC4xNTQxN10sWy45OTE1MywuNTQwMzYsLjE0OTFdLFsuOTg5ODcsLjUyODU0LC4xNDM5OF0sWy45ODc5OSwuNTE2NjcsLjEzODgzXSxbLjk4NTksLjUwNDc5LC4xMzM2N10sWy45ODM2LC40OTI5MSwuMTI4NDldLFsuOTgxMDgsLjQ4MTA0LC4xMjMzMl0sWy45NzgzNywuNDY5MiwuMTE4MTddLFsuOTc1NDUsLjQ1NzQsLjExMzA1XSxbLjk3MjM0LC40NDU2NSwuMTA3OTddLFsuOTY5MDQsLjQzMzk5LC4xMDI5NF0sWy45NjU1NSwuNDIyNDEsLjA5Nzk4XSxbLjk2MTg3LC40MTA5MywuMDkzMV0sWy45NTgwMSwuMzk5NTgsLjA4ODMxXSxbLjk1Mzk4LC4zODgzNiwuMDgzNjJdLFsuOTQ5NzcsLjM3NzI5LC4wNzkwNV0sWy45NDUzOCwuMzY2MzgsLjA3NDYxXSxbLjk0MDg0LC4zNTU2NiwuMDcwMzFdLFsuOTM2MTIsLjM0NTEzLC4wNjYxNl0sWy45MzEyNSwuMzM0ODIsLjA2MjE4XSxbLjkyNjIzLC4zMjQ3MywuMDU4MzddLFsuOTIxMDUsLjMxNDg5LC4wNTQ3NV0sWy45MTU3MiwuMzA1MywuMDUxMzRdLFsuOTEwMjQsLjI5NTk5LC4wNDgxNF0sWy45MDQ2MywuMjg2OTYsLjA0NTE2XSxbLjg5ODg4LC4yNzgyNCwuMDQyNDNdLFsuODkyOTgsLjI2OTgxLC4wMzk5M10sWy44ODY5MSwuMjYxNTIsLjAzNzUzXSxbLjg4MDY2LC4yNTMzNCwuMDM1MjFdLFsuODc0MjIsLjI0NTI2LC4wMzI5N10sWy44Njc2LC4yMzczLC4wMzA4Ml0sWy44NjA3OSwuMjI5NDUsLjAyODc1XSxbLjg1MzgsLjIyMTcsLjAyNjc3XSxbLjg0NjYyLC4yMTQwNywuMDI0ODddLFsuODM5MjYsLjIwNjU0LC4wMjMwNV0sWy44MzE3MiwuMTk5MTIsLjAyMTMxXSxbLjgyMzk5LC4xOTE4MiwuMDE5NjZdLFsuODE2MDgsLjE4NDYyLC4wMTgwOV0sWy44MDc5OSwuMTc3NTMsLjAxNjZdLFsuNzk5NzEsLjE3MDU1LC4wMTUyXSxbLjc5MTI1LC4xNjM2OCwuMDEzODddLFsuNzgyNiwuMTU2OTMsLjAxMjY0XSxbLjc3Mzc3LC4xNTAyOCwuMDExNDhdLFsuNzY0NzYsLjE0Mzc0LC4wMTA0MV0sWy43NTU1NiwuMTM3MzEsLjAwOTQyXSxbLjc0NjE3LC4xMzA5OCwuMDA4NTFdLFsuNzM2NjEsLjEyNDc3LC4wMDc2OV0sWy43MjY4NiwuMTE4NjcsLjAwNjk1XSxbLjcxNjkyLC4xMTI2OCwuMDA2MjldLFsuNzA2OCwuMTA2OCwuMDA1NzFdLFsuNjk2NSwuMTAxMDIsLjAwNTIyXSxbLjY4NjAyLC4wOTUzNiwuMDA0ODFdLFsuNjc1MzUsLjA4OTgsLjAwNDQ5XSxbLjY2NDQ5LC4wODQzNiwuMDA0MjRdLFsuNjUzNDUsLjA3OTAyLC4wMDQwOF0sWy42NDIyMywuMDczOCwuMDA0MDFdLFsuNjMwODIsLjA2ODY4LC4wMDQwMV0sWy42MTkyMywuMDYzNjcsLjAwNDFdLFsuNjA3NDYsLjA1ODc4LC4wMDQyN10sWy41OTU1LC4wNTM5OSwuMDA0NTNdLFsuNTgzMzYsLjA0OTMxLC4wMDQ4Nl0sWy41NzEwMywuMDQ0NzQsLjAwNTI5XSxbLjU1ODUyLC4wNDAyOCwuMDA1NzldLFsuNTQ1ODMsLjAzNTkzLC4wMDYzOF0sWy41MzI5NSwuMDMxNjksLjAwNzA1XSxbLjUxOTg5LC4wMjc1NiwuMDA3OF0sWy41MDY2NCwuMDIzNTQsLjAwODYzXSxbLjQ5MzIxLC4wMTk2MywuMDA5NTVdLFsuNDc5NiwuMDE1ODMsLjAxMDVdXSxRNj1bWy4wNTc5NTEsMzc3ZS02LC4wODg2NTddLFsuMDU4NjA0LDc0M2UtNiwuMDkyMDIyXSxbLjA1OTIyOSwuMDAxMTMyLC4wOTU0MjRdLFsuMDU5ODI2LC4wMDE1NDMsLjA5ODg2M10sWy4wNjAzOTUsLjAwMTk3OSwuMTAyMzMzXSxbLjA2MDkzNCwuMDAyNDM4LC4xMDU4MzRdLFsuMDYxNDQzLC4wMDI5MjIsLjEwOTM2XSxbLjA2MTkyMywuMDAzNDMxLC4xMTI5MDldLFsuMDYyMzcxLC4wMDM5NjcsLjExNjQ4XSxbLjA2Mjc4OCwuMDA0NTI5LC4xMjAwNjVdLFsuMDYzMTczLC4wMDUxMTgsLjEyMzY2NF0sWy4wNjM1MjYsLjAwNTczNiwuMTI3Mjc0XSxbLjA2Mzg0NiwuMDA2MzgxLC4xMzA4ODldLFsuMDY0MTMzLC4wMDcwNTUsLjEzNDUwNl0sWy4wNjQzODYsLjAwNzc1OSwuMTM4MTI0XSxbLjA2NDYwNiwuMDA4NDkzLC4xNDE3MzZdLFsuMDY0NzkxLC4wMDkyNTgsLjE0NTM0XSxbLjA2NDk0MywuMDEwMDUzLC4xNDg5MzJdLFsuMDY1MDYsLjAxMDg4LC4xNTI1MDldLFsuMDY1MTQ0LC4wMTE3MzksLjE1NjA2Nl0sWy4wNjUxOTMsLjAxMjYzMSwuMTU5Nl0sWy4wNjUyMDgsLjAxMzU1NSwuMTYzMTA4XSxbLjA2NTE4OCwuMDE0NTEzLC4xNjY1ODZdLFsuMDY1MTM1LC4wMTU1MDQsLjE3MDAzXSxbLjA2NTA0OCwuMDE2NTI5LC4xNzM0MzddLFsuMDY0OTI4LC4wMTc1ODgsLjE3NjgwNV0sWy4wNjQ3NzQsLjAxODY4MSwuMTgwMTI5XSxbLjA2NDU4OSwuMDE5ODA5LC4xODM0MDZdLFsuMDY0MzcsLjAyMDk3MywuMTg2NjMzXSxbLjA2NDEyMSwuMDIyMTcxLC4xODk4MDldLFsuMDYzODQsLjAyMzQwNCwuMTkyOTI5XSxbLjA2MzUyOSwuMDI0NjcyLC4xOTU5OTJdLFsuMDYzMTg5LC4wMjU5NzUsLjE5ODk5NF0sWy4wNjI4MiwuMDI3MzE0LC4yMDE5MzRdLFsuMDYyNDIzLC4wMjg2ODcsLjIwNDgxXSxbLjA2MiwuMDMwMDk2LC4yMDc2Ml0sWy4wNjE1NSwuMDMxNTM5LC4yMTAzNjJdLFsuMDYxMDc2LC4wMzMwMTgsLjIxMzAzNF0sWy4wNjA1NzcsLjAzNDUzMSwuMjE1NjM4XSxbLjA2MDA1NywuMDM2MDc4LC4yMTgxNjhdLFsuMDU5NTE0LC4wMzc2NTksLjIyMDYyN10sWy4wNTg5NTEsLjAzOTI3NCwuMjIzMDEzXSxbLjA1ODM2OCwuMDQwOTIyLC4yMjUzMjRdLFsuMDU3NzY4LC4wNDI2MDQsLjIyNzU2M10sWy4wNTcxNTEsLjA0NDMxOCwuMjI5NzI4XSxbLjA1NjUxOCwuMDQ2MDY0LC4yMzE4Ml0sWy4wNTU4NzEsLjA0Nzg0MiwuMjMzODM3XSxbLjA1NTIxMSwuMDQ5NjUzLC4yMzU3ODJdLFsuMDU0NTM5LC4wNTE0OTQsLjIzNzY1NV0sWy4wNTM4NTcsLjA1MzM2NSwuMjM5NDU2XSxbLjA1MzE2NSwuMDU1MjY3LC4yNDExODhdLFsuMDUyNDY2LC4wNTcxOTgsLjI0Mjg1XSxbLjA1MTc1OSwuMDU5MTU5LC4yNDQ0NDNdLFsuMDUxMDQ2LC4wNjExNDgsLjI0NTk3XSxbLjA1MDMyOSwuMDYzMTY2LC4yNDc0MzFdLFsuMDQ5NjA5LC4wNjUyMTIsLjI0ODgyOF0sWy4wNDg4ODYsLjA2NzI4NCwuMjUwMTYzXSxbLjA0ODE2MiwuMDY5Mzg0LC4yNTE0MzldLFsuMDQ3NDM4LC4wNzE1MTEsLjI1MjY1M10sWy4wNDY3MTUsLjA3MzY2MywuMjUzODEyXSxbLjA0NTk5MiwuMDc1ODQxLC4yNTQ5MTVdLFsuMDQ1MjczLC4wNzgwNDUsLjI1NTk2NF0sWy4wNDQ1NTcsLjA4MDI3MywuMjU2OTYyXSxbLjA0Mzg0NiwuMDgyNTI2LC4yNTc5MV0sWy4wNDMxMzksLjA4NDgwMywuMjU4ODExXSxbLjA0MjQzOCwuMDg3MTA0LC4yNTk2NjZdLFsuMDQxNzQzLC4wODk0MjksLjI2MDQ3N10sWy4wNDEwNTUsLjA5MTc3NywuMjYxMjQ1XSxbLjA0MDM3NCwuMDk0MTQ4LC4yNjE5NzJdLFsuMDM5NzAyLC4wOTY1NDIsLjI2MjY2MV0sWy4wMzkwMzcsLjA5ODk1OSwuMjYzMzEzXSxbLjAzODM4MiwuMTAxMzk4LC4yNjM5MjldLFsuMDM3NzM2LC4xMDM4NiwuMjY0NTEyXSxbLjAzNzA5OSwuMTA2MzQ0LC4yNjUwNjNdLFsuMDM2NDcyLC4xMDg4NSwuMjY1NTgzXSxbLjAzNTg1NSwuMTExMzc4LC4yNjYwNzZdLFsuMDM1MjQ5LC4xMTM5MjgsLjI2NjU0XSxbLjAzNDY1MywuMTE2NSwuMjY2OTc4XSxbLjAzNDA2NywuMTE5MDkzLC4yNjczOTFdLFsuMDMzNDkyLC4xMjE3MSwuMjY3NzhdLFsuMDMyOTI3LC4xMjQzNDgsLjI2ODE0N10sWy4wMzIzNzMsLjEyNzAwOCwuMjY4NDkzXSxbLjAzMTgyOSwuMTI5NjksLjI2ODgxN10sWy4wMzEyOTYsLjEzMjM5NCwuMjY5MTIzXSxbLjAzMDc3MywuMTM1MTIxLC4yNjk0MV0sWy4wMzAyNiwuMTM3ODcxLC4yNjk2NzhdLFsuMDI5NzU4LC4xNDA2NDMsLjI2OTkyOV0sWy4wMjkyNjUsLjE0MzQzOCwuMjcwMTYzXSxbLjAyODc4MSwuMTQ2MjU3LC4yNzAzODFdLFsuMDI4MzA4LC4xNDkwOTksLjI3MDU4NF0sWy4wMjc4NDMsLjE1MTk2NCwuMjcwNzcxXSxbLjAyNzM4NywuMTU0ODUzLC4yNzA5NDNdLFsuMDI2OTQsLjE1Nzc2NywuMjcxMV0sWy4wMjY1MDEsLjE2MDcwNCwuMjcxMjQzXSxbLjAyNjA3LC4xNjM2NjYsLjI3MTM3MV0sWy4wMjU2NDgsLjE2NjY1MywuMjcxNDg1XSxbLjAyNTIzMiwuMTY5NjY2LC4yNzE1ODRdLFsuMDI0ODI0LC4xNzI3MDQsLjI3MTY2OV0sWy4wMjQ0MjMsLjE3NTc2NywuMjcxNzM4XSxbLjAyNDAyOCwuMTc4ODU3LC4yNzE3OTNdLFsuMDIzNjQsLjE4MTk3NCwuMjcxODMzXSxbLjAyMzI1NywuMTg1MTE3LC4yNzE4NTZdLFsuMDIyODgxLC4xODgyODgsLjI3MTg2M10sWy4wMjI1MSwuMTkxNDg2LC4yNzE4NTVdLFsuMDIyMTQ0LC4xOTQ3MTMsLjI3MTgyOF0sWy4wMjE3ODQsLjE5Nzk2NywuMjcxNzg0XSxbLjAyMTQyOCwuMjAxMjUsLjI3MTcyXSxbLjAyMTA3NywuMjA0NTYzLC4yNzE2MzhdLFsuMDIwNzMsLjIwNzkwNCwuMjcxNTM2XSxbLjAyMDM4OCwuMjExMjc1LC4yNzE0MTJdLFsuMDIwMDUsLjIxNDY3NiwuMjcxMjY3XSxbLjAxOTcxNiwuMjE4MTA3LC4yNzExXSxbLjAxOTM4NywuMjIxNTY5LC4yNzA5MDldLFsuMDE5MDYyLC4yMjUwNjIsLjI3MDY5NV0sWy4wMTg3NDEsLjIyODU4NSwuMjcwNDU2XSxbLjAxODQyNSwuMjMyMTQxLC4yNzAxODldLFsuMDE4MTEzLC4yMzU3MjgsLjI2OTg5Nl0sWy4wMTc4MDYsLjIzOTM0OCwuMjY5NTc0XSxbLjAxNzUwNCwuMjQyOTk4LC4yNjkyMjJdLFsuMDE3MjA3LC4yNDY2ODIsLjI2ODg0MV0sWy4wMTY5MTYsLjI1MDM5OSwuMjY4NDI2XSxbLjAxNjYzLC4yNTQxNDgsLjI2Nzk4XSxbLjAxNjM1MiwuMjU3OTMsLjI2NzUwMV0sWy4wMTYwOCwuMjYxNzQ2LC4yNjY5ODddLFsuMDE1ODE2LC4yNjU1OTQsLjI2NjQzNl0sWy4wMTU1NTksLjI2OTQ3NiwuMjY1ODQ5XSxbLjAxNTMxMiwuMjczMzkyLC4yNjUyMjRdLFsuMDE1MDc0LC4yNzczNCwuMjY0NTU5XSxbLjAxNDg0NiwuMjgxMzIzLC4yNjM4NTRdLFsuMDE0NjI5LC4yODUzMzksLjI2MzEwN10sWy4wMTQ0MjUsLjI4OTM4OSwuMjYyMzJdLFsuMDE0MjM0LC4yOTM0NzIsLjI2MTQ4OF0sWy4wMTQwNTgsLjI5NzU4OSwuMjYwNjEzXSxbLjAxMzg5NiwuMzAxNzM4LC4yNTk2OTJdLFsuMDEzNzUxLC4zMDU5MjEsLjI1ODcyNV0sWy4wMTM2MjQsLjMxMDEzNywuMjU3NzExXSxbLjAxMzUxNiwuMzE0Mzg3LC4yNTY2NV0sWy4wMTM0MjksLjMxODY2OCwuMjU1NTM5XSxbLjAxMzM2NCwuMzIyOTgyLC4yNTQzODFdLFsuMDEzMzIyLC4zMjczMjgsLjI1MzE3M10sWy4wMTMzMDYsLjMzMTcwNiwuMjUxOTEzXSxbLjAxMzMxNywuMzM2MTE2LC4yNTA2MDJdLFsuMDEzMzU2LC4zNDA1NTYsLjI0OTIzOV0sWy4wMTM0MjcsLjM0NTAyOCwuMjQ3ODI0XSxbLjAxMzUyOSwuMzQ5NTMsLjI0NjM1N10sWy4wMTM2NjcsLjM1NDA2MSwuMjQ0ODM3XSxbLjAxMzg0MSwuMzU4NjIzLC4yNDMyNjRdLFsuMDE0MDU0LC4zNjMyMTMsLjI0MTYzNl0sWy4wMTQzMDgsLjM2NzgzMSwuMjM5OTU2XSxbLjAxNDYwNSwuMzcyNDc2LC4yMzgyMjFdLFsuMDE0OTQ4LC4zNzcxNSwuMjM2NDMyXSxbLjAxNTMzOSwuMzgxODQ5LC4yMzQ1ODldLFsuMDE1NzgsLjM4NjU3NiwuMjMyNjkyXSxbLjAxNjI3NSwuMzkxMzI2LC4yMzA3NDJdLFsuMDE2ODI1LC4zOTYxMDEsLjIyODczOF0sWy4wMTc0MzQsLjQwMDg5OSwuMjI2NjhdLFsuMDE4MTA0LC40MDU3MjEsLjIyNDU2OV0sWy4wMTg4MzksLjQxMDU2NCwuMjIyNDA2XSxbLjAxOTY0MSwuNDE1NDI3LC4yMjAxOTFdLFsuMDIwNTEyLC40MjAzMTIsLjIxNzkyM10sWy4wMjE0NTcsLjQyNTIxNiwuMjE1NjA1XSxbLjAyMjQ3OSwuNDMwMTM3LC4yMTMyMzZdLFsuMDIzNTgsLjQzNTA3NywuMjEwODE4XSxbLjAyNDc2NCwuNDQwMDMyLC4yMDgzNV0sWy4wMjYwMzQsLjQ0NTAwNCwuMjA1ODM1XSxbLjAyNzM5NCwuNDQ5OTg4LC4yMDMyNzFdLFsuMDI4ODQ3LC40NTQ5ODUsLjIwMDY2Ml0sWy4wMzAzOTYsLjQ1OTk5NSwuMTk4MDA4XSxbLjAzMjA0NiwuNDY1MDE2LC4xOTUzMV0sWy4wMzM4LC40NzAwNDYsLjE5MjU2OV0sWy4wMzU2NjIsLjQ3NTA4MywuMTg5Nzg2XSxbLjAzNzYzNiwuNDgwMTI4LC4xODY5NjRdLFsuMDM5NzI1LC40ODUxNzgsLjE4NDEwMV0sWy4wNDE5MzMsLjQ5MDIzNCwuMTgxMjAxXSxbLjA0NDI2NiwuNDk1MjkxLC4xNzgyNjVdLFsuMDQ2NzI1LC41MDAzNTEsLjE3NTI5NF0sWy4wNDkzMTcsLjUwNTQxMiwuMTcyMjkxXSxbLjA1MjA0NCwuNTEwNDcsLjE2OTI1N10sWy4wNTQ5MTIsLjUxNTUyNiwuMTY2MTkyXSxbLjA1NzkyNCwuNTIwNTc4LC4xNjMwOTldLFsuMDYxMDg1LC41MjU2MjQsLjE1OTk4XSxbLjA2NDQsLjUzMDY2NCwuMTU2ODM1XSxbLjA2Nzg3MywuNTM1NjkzLC4xNTM2NjldLFsuMDcxNTA4LC41NDA3MTMsLjE1MDQ4Ml0sWy4wNzUzMSwuNTQ1NzIxLC4xNDcyNzddLFsuMDc5MjgzLC41NTA3MTcsLjE0NDA1NV0sWy4wODM0MzMsLjU1NTY5NywuMTQwODE5XSxbLjA4Nzc2NCwuNTYwNjYsLjEzNzU3XSxbLjA5MjI4MSwuNTY1NjA0LC4xMzQzMDldLFsuMDk2OTg5LC41NzA1MjksLjEzMTA0XSxbLjEwMTg5MywuNTc1NDMxLC4xMjc3NjZdLFsuMTA2OTk2LC41ODAzMSwuMTI0NDg3XSxbLjExMjMwNSwuNTg1MTY0LC4xMjEyMDddLFsuMTE3ODI0LC41ODk5OSwuMTE3OTI4XSxbLjEyMzU1OCwuNTk0Nzg5LC4xMTQ2NTJdLFsuMTI5NTExLC41OTk1NTYsLjExMTM4MV0sWy4xMzU2OSwuNjA0Mjk0LC4xMDgxMThdLFsuMTQyMDk5LC42MDg5OTQsLjEwNDg2NF0sWy4xNDg3NDMsLjYxMzY2LC4xMDE2MjNdLFsuMTU1NjI3LC42MTgyODgsLjA5ODM5Nl0sWy4xNjI3NTUsLjYyMjg3OCwuMDk1MTg3XSxbLjE3MDEzMywuNjI3NDI3LC4wOTE5OTddLFsuMTc3NzY0LC42MzE5MzQsLjA4ODgzXSxbLjE4NTY1NCwuNjM2Mzk2LC4wODU2ODldLFsuMTkzODA3LC42NDA4MTQsLjA4MjU3M10sWy4yMDIyMjgsLjY0NTE4MywuMDc5NDg4XSxbLjIxMDkyMSwuNjQ5NTAzLC4wNzY0MzZdLFsuMjE5ODkxLC42NTM3NzMsLjA3MzQxOF0sWy4yMjkxNDMsLjY1Nzk5MiwuMDcwNDM4XSxbLjIzODY3OSwuNjYyMTU4LC4wNjc0OTddLFsuMjQ4NTA1LC42NjYyNjgsLjA2NDU5OF0sWy4yNTg2MjMsLjY3MDMyMSwuMDYxNzQ1XSxbLjI2OTAzNywuNjc0MzE5LC4wNTg5MzldLFsuMjc5NzUxLC42NzgyNTksLjA1NjE4NF0sWy4yOTA3NjUsLjY4MjE0LC4wNTM0ODJdLFsuMzAyMDg1LC42ODU5NTksLjA1MDgzNV0sWy4zMTM3MTIsLjY4OTcxOSwuMDQ4MjQ2XSxbLjMyNTY0OCwuNjkzNDE3LC4wNDU3MThdLFsuMzM3ODk2LC42OTcwNTMsLjA0MzI1M10sWy4zNTA0NTUsLjcwMDYyNywuMDQwODUzXSxbLjM2MzMzLC43MDQxMzksLjAzODUyMV0sWy4zNzY1MTcsLjcwNzU4OCwuMDM2MjYxXSxbLjM5MDAxOSwuNzEwOTc1LC4wMzQwNzNdLFsuNDAzODM1LC43MTQyOTgsLjAzMTk2MV0sWy40MTc5NjQsLjcxNzU2MSwuMDI5OTI4XSxbLjQzMjQwNSwuNzIwNzYzLC4wMjc5NzVdLFsuNDQ3MTU2LC43MjM5MDMsLjAyNjEwNV0sWy40NjIyMTMsLjcyNjk4NiwuMDI0MzIxXSxbLjQ3NzU3NywuNzMwMDEsLjAyMjYyNV0sWy40OTMyNDMsLjczMjk3OCwuMDIxMDE5XSxbLjUwOTIwNiwuNzM1ODkxLC4wMTk1MDZdLFsuNTI1NDYxLC43Mzg3NTEsLjAxODA4OF0sWy41NDIwMDQsLjc0MTU2MywuMDE2NzY3XSxbLjU1ODgzMSwuNzQ0MzI1LC4wMTU1NDddLFsuNTc1OTMyLC43NDcwNDEsLjAxNDQyN10sWy41OTMzMDUsLjc0OTcxNywuMDEzNDEzXSxbLjYxMDk0LC43NTIzNTEsLjAxMjUwNF0sWy42Mjg4MjgsLjc1NDk0OSwuMDExNzA0XSxbLjY0Njk2NiwuNzU3NTE0LC4wMTEwMTVdLFsuNjY1MzQ0LC43NjAwNDksLjAxMDQzOF0sWy42ODM5NTIsLjc2MjU1NywuMDA5OTc3XSxbLjcwMjc4MiwuNzY1MDQ0LC4wMDk2MzJdLFsuNzIxODI1LC43Njc1MTEsLjAwOTQwNl0sWy43NDEwNzQsLjc2OTk2NCwuMDA5MzAxXSxbLjc2MDUxOCwuNzcyNDA2LC4wMDkzMl0sWy43ODAxNSwuNzc0ODM5LC4wMDk0NjNdLFsuNzk5OTU4LC43NzcyNywuMDA5NzM0XSxbLjgxOTkzNiwuNzc5Njk5LC4wMTAxMzRdLFsuODQwMDY0LC43ODIxMzksLjAxMDY2Nl0sWy44NjAzNCwuNzg0NTg2LC4wMTEzMzFdLFsuODgwNzU4LC43ODcwNDYsLjAxMjEzMl0sWy45MDEzMTEsLjc4OTUyMSwuMDEzMDddLFsuOTIxOTksLjc5MjAxNywuMDE0MTQ4XSxbLjk0Mjc4NiwuNzk0NTM1LC4wMTUzNjhdLFsuOTYzNjkzLC43OTcwNzgsLjAxNjczMl0sWy45ODQ3MDgsLjc5OTY1MSwuMDE4MjQzXV0sSjY9W1sxMDIsMjU1LDUxXSxbMjU1LDkwLDBdLFsyNTUsMjU1LDBdXSxlMz1bWzAsMCwuMjE0MDQxXSxbMCwwLDFdLFswLC4yMTQwNDEsMV0sWzAsMSwxXSxbLjIxNDA0MSwxLC4yMTQwNDFdLFsxLDEsMF0sWzEsLjIxNDA0MSwwXSxbMSwwLDBdLFsuMjE0MDQxLDAsMF1dLHcwPTI1NTtmdW5jdGlvbiB0MyhlKXtyZXR1cm4gZTwwPzA6ZT4xP3cwOk51bWJlci5pc05hTihlKT8wOk1hdGgucm91bmQoZSp3MCl9ZnVuY3Rpb24gdTAoZSx0KXtjb25zdCBuPXQzKHQpLHI9ZVtuXTtyZXR1cm5bclswXSp3MCxyWzFdKncwLHJbMl0qdzBdfWZ1bmN0aW9uICQwKGUpe3JldHVybiB0PT5lKHQpLnJnYigpfWNvbnN0IFkxPXUwLmJpbmQobnVsbCxVNiksbjM9dTAuYmluZChudWxsLFE2KSxyMz11MC5iaW5kKG51bGwsWjYpLHMzPXUwLmJpbmQobnVsbCxLNiksbzM9dTAuYmluZChudWxsLFY2KSxjMz11MC5iaW5kKG51bGwsWDYpLGkzPSQwKE0uY3ViZWhlbGl4KCkuc2NhbGUoKSksYTM9JDAoTS5zY2FsZShKNi5tYXAoZT0+TS5yZ2IoZVswXSxlWzFdLGVbMl0pKSkubW9kZSgibGFiIikpLFUxPSQwKE0uc2NhbGUoZTMubWFwKGU9Pk0ucmdiKGVbMF0qMjU1LGVbMV0qMjU1LGVbMl0qMjU1KSkpLm1vZGUoImxyZ2IiKSksWDE9e2dyYXlzY2FsZToiR3JleXMiLGJsdWU6IkJsdWVzIixncmVlbjoiR3JlZW5zIixvcmFuZ2U6Ik9yYW5nZXMiLHB1cnBsZToiUHVycGxlcyIscmVkOiJSZWRzIixhdWRhY2l0eTpZMSxyb3NldXM6WTEsdmlyaWRpczpuMyx0dXJibzpyMyxwbGFzbWE6czMsaW5mZXJubzpvMyxtYWdtYTpjMyxjdWJlSGVsaXg6aTMsZ2FtbWFJSTphMyxqZXQ6VTEscmF2ZW46VTF9O2Z1bmN0aW9uIGYzKGUpe2xldCB0PVgxW2VdO3JldHVybiB0PT09dm9pZCAwJiYoY29uc29sZS53YXJuKCJDb3VsZCBub3QgZmluZCBjb2xvciBzY2FsZSIsZSwiLiBEZWZhdWx0aW5nIHRvIGdyYXlzY2FsZSIpLHQ9WDEuZ3JheXNjYWxlKSx0eXBlb2YgdD09InN0cmluZyI/JDAoTS5zY2FsZSh0KSk6dH1mdW5jdGlvbiBsMyhlKXtyZXR1cm4gNzAwKihNYXRoLmV4cChlLzExMjcpLTEpfWZ1bmN0aW9uIFYxKGUpe3JldHVybiAxMTI3Kk1hdGgubG9nKDErZS83MDApfWZ1bmN0aW9uIHUzKGUpe2NvbnN0IHQ9W10sbj1bXSxyPVtdLHM9VjEoZS5sb3dGcmVxdWVuY3kpLG89VjEoZS5oaWdoRnJlcXVlbmN5KSxjPShvLXMpLyhlLmJhbmtDb3VudCsxKTtmb3IobGV0IGE9MDthPGUuYmFua0NvdW50O2ErKyluW2FdPWwzKHMrYSpjKSx0W2FdPU1hdGguZmxvb3IoKGUuZmZ0U2l6ZSsxKSpuW2FdLyhlLnNhbXBsZVJhdGUvMikpO2ZvcihsZXQgYT0wO2E8dC5sZW5ndGg7YSsrKXtyW2FdPVtdO2NvbnN0IGY9YT09PXQubGVuZ3RoLTE/dFthXS10W2EtMV06dFthKzFdLXRbYV07Zm9yKGxldCBsPTA7bDxlLmZmdFNpemU7bCsrKWw+dFthXStmP3JbYV1bbF09MDpsPnRbYV0/clthXVtsXT0xLShsLXRbYV0pL2Y6bD09PXRbYV0/clthXVtsXT0xOmw+PXRbYV0tZj9yW2FdW2xdPTEtKHRbYV0tbCkvZjpyW2FdW2xdPTB9Y29uc3QgaT1hPT57Y29uc3QgZj1uZXcgRmxvYXQzMkFycmF5KHIubGVuZ3RoKTtmb3IobGV0IGw9MDtsPHIubGVuZ3RoO2wrKyl7bGV0IHU9MDtmb3IobGV0IGQ9MDtkPGEubGVuZ3RoO2QrKyl1Kz1hW2RdKnJbbF1bZF07ZltsXT11fXJldHVybiBmfTtyZXR1cm57ZmlsdGVyczpyLGxvd01lbDpzLGhpZ2hNZWw6byxkZWx0YU1lbDpjLGxvd0ZyZXE6ZS5sb3dGcmVxdWVuY3ksaGlnaEZyZXE6ZS5oaWdoRnJlcXVlbmN5LGZpbHRlcjppfX1mdW5jdGlvbiBoMyhlKXtjb25zdCB0PXUzKGUpO3JldHVybiBuPT57aWYobi5sZW5ndGghPT1lLmZmdFNpemUpe2NvbnN0IHI9YFBhc3NlZCBpbiBGRlQgYmlucyB3ZXJlIGluY29ycmVjdCBzaXplLiBFeHBlY3RlZCAke2UuZmZ0U2l6ZX0gYnV0IHdhcyAke24ubGVuZ3RofWA7dGhyb3cgbmV3IEVycm9yKHIpfXJldHVybiB0LmZpbHRlcihuKX19Y29uc3QgYjM9ZT0+TWF0aC5zaW4oTWF0aC5QSSplKS8oTWF0aC5QSSplKSxLMT1lPT57Y29uc3QgdD1NYXRoLmFicyhlKTtpZih0PDMuNzUpe2NvbnN0IG49ZS8zLjc1KihlLzMuNzUpO3JldHVybiAxK24qKDMuNTE1NjIyOStuKigzLjA4OTk0MjQrbiooMS4yMDY3NDkyK24qKC4yNjU5NzMyK24qKC4wMzYwNzY4K24qLjAwNDU4MTMpKSkpKX1lbHNle2NvbnN0IG49My43NS90O3JldHVybiBNYXRoLmV4cCh0KS9NYXRoLnNxcnQodCkqKC4zOTg5NDIyOCtuKiguMDEzMjg1OTIrbiooLjAwMjI1MzE5K24qKC0uMDAxNTc1NjUrbiooLjAwOTE2MjgxK24qKC0uMDIwNTc3MDYrbiooLjAyNjM1NTM3K24qKC0uMDE2NDc2MzMrbiouMDAzOTIzNzcpKSkpKSkpKX19LGQzPXtoYW5uOihlLHQpPT4uNS0uNSpNYXRoLmNvcygyKk1hdGguUEkqZS8odC0xKSksaGFtbWluZzooZSx0KT0+LjU0LS40NipNYXRoLmNvcygyKk1hdGguUEkqZS8odC0xKSksY29zaW5lOihlLHQpPT5NYXRoLnNpbihNYXRoLlBJKmUvKHQtMSkpLGxhbmN6b3M6KGUsdCk9PmIzKDIqZS8odC0xKS0xKSxnYXVzc2lhbjooZSx0LG49LjQpPT5NYXRoLnBvdyhNYXRoLkUsLS41Kk1hdGgucG93KChlLSh0LTEpLzIpLyhuKih0LTEpLzIpLDIpKSx0dWtleTooZSx0LG49LjUpPT5lPC41Km4qKHQtMSk/LjUqKDErTWF0aC5jb3MoTWF0aC5QSSooMiplLyhuKih0LTEpKS0xKSkpOmU8KDEtLjUqbikqKHQtMSk/MTouNSooMStNYXRoLmNvcyhNYXRoLlBJKigyKmUvKG4qKHQtMSkpKzEtMi9uKSkpLGJsYWNrbWFuOihlLHQpPT4uNDItLjUqTWF0aC5jb3MoMipNYXRoLlBJKmUvKHQtMSkpKy4wOCpNYXRoLmNvcyg0Kk1hdGguUEkqZS8odC0xKSksZXhhY3RfYmxhY2ttYW46KGUsdCk9Pi40MjQzODAxLS40OTczNDA2Kk1hdGguY29zKDIqTWF0aC5QSSplLyh0LTEpKSsuMDc4Mjc5MypNYXRoLmNvcyg0Kk1hdGguUEkqZS8odC0xKSksa2Fpc2VyOihlLHQsbj0zKT0+SzEoTWF0aC5QSSpuKk1hdGguc3FydCgxLU1hdGgucG93KDIqZS8odC0xKS0xLDIpKSkvSzEoTWF0aC5QSSpuKSxudXR0YWxsOihlLHQpPT4uMzU1NzY4LS40ODczOTYqTWF0aC5jb3MoMipNYXRoLlBJKmUvKHQtMSkpKy4xNDQyMzIqTWF0aC5jb3MoNCpNYXRoLlBJKmUvKHQtMSkpLS4wMTI2MDQqTWF0aC5jb3MoNipNYXRoLlBJKmUvKHQtMSkpLGJsYWNrbWFuX2hhcnJpczooZSx0KT0+LjM1ODc1LS40ODgyOSpNYXRoLmNvcygyKk1hdGguUEkqZS8odC0xKSkrLjE0MTI4Kk1hdGguY29zKDQqTWF0aC5QSSplLyh0LTEpKS0uMDExNjgqTWF0aC5jb3MoNipNYXRoLlBJKmUvKHQtMSkpLGJsYWNrbWFuX251dHRhbGw6KGUsdCk9Pi4zNjM1ODE5LS4zNjM1ODE5Kk1hdGguY29zKDIqTWF0aC5QSSplLyh0LTEpKSsuMTM2NTk5NSpNYXRoLmNvcyg0Kk1hdGguUEkqZS8odC0xKSktLjAxMDY0MTEqTWF0aC5jb3MoNipNYXRoLlBJKmUvKHQtMSkpLGZsYXRfdG9wOihlLHQpPT4xLTEuOTMqTWF0aC5jb3MoMipNYXRoLlBJKmUvKHQtMSkpKzEuMjkqTWF0aC5jb3MoNCpNYXRoLlBJKmUvKHQtMSkpLS4zODgqTWF0aC5jb3MoNipNYXRoLlBJKmUvKHQtMSkpKy4wMzIqTWF0aC5jb3MoOCpNYXRoLlBJKmUvKHQtMSkpfSxwMz0oZSx0LG4pPT57Y29uc3Qgcj1lLmxlbmd0aDtmb3IobGV0IHM9MDtzPHI7KytzKWVbc10qPXQocyxyLG4pO3JldHVybiBlfSxqPWU9Pih0LG4pPT5wMyh0LGQzW2VdLG4pLG4xPWooImhhbm4iKSxnMz1qKCJoYW1taW5nIiksbTM9aigiY29zaW5lIiksdzM9aigibGFuY3pvcyIpLHkzPWooImdhdXNzaWFuIiksXzM9aigidHVrZXkiKSxrMz1qKCJibGFja21hbiIpLE0zPWooImV4YWN0X2JsYWNrbWFuIiksQTM9aigia2Fpc2VyIiksQzM9aigibnV0dGFsbCIpLHYzPWooImJsYWNrbWFuX2hhcnJpcyIpLFIzPWooImJsYWNrbWFuX251dHRhbGwiKSxTMz1qKCJmbGF0X3RvcCIpLFoxPW5ldyBNYXAoW1siaGFubiIsbjFdLFsiaGFtbWluZyIsZzNdLFsiY29zaW5lIixtM10sWyJsYW5jem9zIix3M10sWyJnYXVzc2lhbiIseTNdLFsidHVrZXkiLF8zXSxbImJsYWNrbWFuIixrM10sWyJleGFjdF9ibGFja21hbiIsTTNdLFsia2Fpc2VyIixBM10sWyJudXR0YWxsIixDM10sWyJibGFja21hbl9oYXJyaXMiLHYzXSxbImJsYWNrbWFuX251dHRhbGwiLFIzXSxbImZsYXRfdG9wIixTM11dKTtmdW5jdGlvbiBGMyhlPSJoYW5uIil7Y29uc3QgdD1aMS5nZXQoZSk/P24xO3JldHVybiBuPT50KG4pfWZ1bmN0aW9uIEkzKGU9Imhhbm4iLHQpe2NvbnN0IG49WjEuZ2V0KGUpPz9uMSxyPUFycmF5LmZyb20oe2xlbmd0aDp0fSkuZmlsbCgxKSxzPW4ocik7cmV0dXJuIHMucmVkdWNlKChjLGkpPT5jK2ksMCkvcy5sZW5ndGh9ZnVuY3Rpb24gcShlKXtpZih0aGlzLnNpemU9ZXwwLHRoaXMuc2l6ZTw9MXx8dGhpcy5zaXplJnRoaXMuc2l6ZS0xKXRocm93IG5ldyBFcnJvcigiRkZUIHNpemUgbXVzdCBiZSBhIHBvd2VyIG9mIHR3byBhbmQgYmlnZ2VyIHRoYW4gMSIpO3RoaXMuX2NzaXplPWU8PDE7Y29uc3QgdD1uZXcgQXJyYXkodGhpcy5zaXplKjIpO2ZvcihsZXQgcj0wO3I8dC5sZW5ndGg7cis9Mil7Y29uc3Qgcz1NYXRoLlBJKnIvdGhpcy5zaXplO3Rbcl09TWF0aC5jb3MocyksdFtyKzFdPS1NYXRoLnNpbihzKX10aGlzLnRhYmxlPXQ7bGV0IG49MDtmb3IobGV0IHI9MTt0aGlzLnNpemU+cjtyPDw9MSluKys7dGhpcy5fd2lkdGg9biUyPT09MD9uLTE6bix0aGlzLl9iaXRyZXY9bmV3IEFycmF5KDE8PHRoaXMuX3dpZHRoKTtmb3IobGV0IHI9MDtyPHRoaXMuX2JpdHJldi5sZW5ndGg7cisrKXt0aGlzLl9iaXRyZXZbcl09MDtmb3IobGV0IHM9MDtzPHRoaXMuX3dpZHRoO3MrPTIpe2NvbnN0IG89dGhpcy5fd2lkdGgtcy0yO3RoaXMuX2JpdHJldltyXXw9KHI+Pj5zJjMpPDxvfX10aGlzLl9vdXQ9bnVsbCx0aGlzLl9kYXRhPW51bGwsdGhpcy5faW52PTB9cS5wcm90b3R5cGUuZnJvbUNvbXBsZXhBcnJheT1mdW5jdGlvbih0LG4pe2NvbnN0IHI9bnx8bmV3IEZsb2F0MzJBcnJheSh0Lmxlbmd0aD4+PjEpO2ZvcihsZXQgcz0wO3M8dC5sZW5ndGg7cys9MilyW3M+Pj4xXT10W3NdO3JldHVybiByfSxxLnByb3RvdHlwZS5jcmVhdGVDb21wbGV4QXJyYXk9ZnVuY3Rpb24oKXtjb25zdCB0PW5ldyBGbG9hdDMyQXJyYXkodGhpcy5fY3NpemUpO2ZvcihsZXQgbj0wO248dC5sZW5ndGg7bisrKXRbbl09MDtyZXR1cm4gdH0scS5wcm90b3R5cGUudG9Db21wbGV4QXJyYXk9ZnVuY3Rpb24odCxuKXtjb25zdCByPW58fHRoaXMuY3JlYXRlQ29tcGxleEFycmF5KCk7Zm9yKGxldCBzPTA7czxyLmxlbmd0aDtzKz0yKXJbc109dFtzPj4+MV0scltzKzFdPTA7cmV0dXJuIHJ9LHEucHJvdG90eXBlLmNvbXBsZXRlU3BlY3RydW09ZnVuY3Rpb24odCl7Y29uc3Qgbj10aGlzLl9jc2l6ZSxyPW4+Pj4xO2ZvcihsZXQgcz0yO3M8cjtzKz0yKXRbbi1zXT10W3NdLHRbbi1zKzFdPS10W3MrMV19LHEucHJvdG90eXBlLnRyYW5zZm9ybT1mdW5jdGlvbih0LG4pe2lmKHQ9PT1uKXRocm93IG5ldyBFcnJvcigiSW5wdXQgYW5kIG91dHB1dCBidWZmZXJzIG11c3QgYmUgZGlmZmVyZW50Iik7dGhpcy5fb3V0PXQsdGhpcy5fZGF0YT1uLHRoaXMuX2ludj0wLHRoaXMuX3RyYW5zZm9ybTQoKSx0aGlzLl9vdXQ9bnVsbCx0aGlzLl9kYXRhPW51bGx9LHEucHJvdG90eXBlLnJlYWxUcmFuc2Zvcm09ZnVuY3Rpb24odCxuKXtpZih0PT09bil0aHJvdyBuZXcgRXJyb3IoIklucHV0IGFuZCBvdXRwdXQgYnVmZmVycyBtdXN0IGJlIGRpZmZlcmVudCIpO3RoaXMuX291dD10LHRoaXMuX2RhdGE9bix0aGlzLl9pbnY9MCx0aGlzLl9yZWFsVHJhbnNmb3JtNCgpLHRoaXMuX291dD1udWxsLHRoaXMuX2RhdGE9bnVsbH0scS5wcm90b3R5cGUuaW52ZXJzZVRyYW5zZm9ybT1mdW5jdGlvbih0LG4pe2lmKHQ9PT1uKXRocm93IG5ldyBFcnJvcigiSW5wdXQgYW5kIG91dHB1dCBidWZmZXJzIG11c3QgYmUgZGlmZmVyZW50Iik7dGhpcy5fb3V0PXQsdGhpcy5fZGF0YT1uLHRoaXMuX2ludj0xLHRoaXMuX3RyYW5zZm9ybTQoKTtmb3IobGV0IHI9MDtyPHQubGVuZ3RoO3IrKyl0W3JdLz10aGlzLnNpemU7dGhpcy5fb3V0PW51bGwsdGhpcy5fZGF0YT1udWxsfSxxLnByb3RvdHlwZS5fdHJhbnNmb3JtND1mdW5jdGlvbigpe2NvbnN0IHQ9dGhpcy5fb3V0LG49dGhpcy5fY3NpemU7bGV0IHM9MTw8dGhpcy5fd2lkdGgsbz1uL3M8PDEsYyxpO2NvbnN0IGE9dGhpcy5fYml0cmV2O2lmKG89PT00KWZvcihjPTAsaT0wO2M8bjtjKz1vLGkrKyl7Y29uc3QgdT1hW2ldO3RoaXMuX3NpbmdsZVRyYW5zZm9ybTIoYyx1LHMpfWVsc2UgZm9yKGM9MCxpPTA7YzxuO2MrPW8saSsrKXtjb25zdCB1PWFbaV07dGhpcy5fc2luZ2xlVHJhbnNmb3JtNChjLHUscyl9Y29uc3QgZj10aGlzLl9pbnY/LTE6MSxsPXRoaXMudGFibGU7Zm9yKHM+Pj0yO3M+PTI7cz4+PTIpe289bi9zPDwxO2NvbnN0IHU9bz4+PjI7Zm9yKGM9MDtjPG47Yys9byl7Y29uc3QgZD1jK3U7Zm9yKGxldCB5PWMsXz0wO3k8ZDt5Kz0yLF8rPXMpe2NvbnN0IEM9eSxwPUMrdSxnPXArdSxCPWcrdSxFPXRbQ10sUD10W0MrMV0sJD10W3BdLEE9dFtwKzFdLGg9dFtnXSxtPXRbZysxXSxrPXRbQl0sdz10W0IrMV0sRj1FLHY9UCx4PWxbX10sRD1mKmxbXysxXSxIPSQqeC1BKkQsWT0kKkQrQSp4LFg9bFsyKl9dLHQwPWYqbFsyKl8rMV0sczA9aCpYLW0qdDAsaDA9aCp0MCttKlgsbzA9bFszKl9dLGMwPWYqbFszKl8rMV0sWj1rKm8wLXcqYzAsazA9aypjMCt3Km8wLE0wPUYrczAsYjA9ditoMCxkMD1GLXMwLEEwPXYtaDAsQzA9SCtaLHAwPVkrazAsZzA9ZiooSC1aKSx2MD1mKihZLWswKSxUMD1NMCtDMCxpMT1iMCtwMCxhMT1NMC1DMCxmMT1iMC1wMCxsMT1kMCt2MCx1MT1BMC1nMCxoMT1kMC12MCxiMT1BMCtnMDt0W0NdPVQwLHRbQysxXT1pMSx0W3BdPWwxLHRbcCsxXT11MSx0W2ddPWExLHRbZysxXT1mMSx0W0JdPWgxLHRbQisxXT1iMX19fX0scS5wcm90b3R5cGUuX3NpbmdsZVRyYW5zZm9ybTI9ZnVuY3Rpb24odCxuLHIpe2NvbnN0IHM9dGhpcy5fb3V0LG89dGhpcy5fZGF0YSxjPW9bbl0saT1vW24rMV0sYT1vW24rcl0sZj1vW24rcisxXSxsPWMrYSx1PWkrZixkPWMtYSx5PWktZjtzW3RdPWwsc1t0KzFdPXUsc1t0KzJdPWQsc1t0KzNdPXl9LHEucHJvdG90eXBlLl9zaW5nbGVUcmFuc2Zvcm00PWZ1bmN0aW9uKHQsbixyKXtjb25zdCBzPXRoaXMuX291dCxvPXRoaXMuX2RhdGEsYz10aGlzLl9pbnY/LTE6MSxpPXIqMixhPXIqMyxmPW9bbl0sbD1vW24rMV0sdT1vW24rcl0sZD1vW24rcisxXSx5PW9bbitpXSxfPW9bbitpKzFdLEM9b1tuK2FdLHA9b1tuK2ErMV0sZz1mK3ksQj1sK18sRT1mLXksUD1sLV8sJD11K0MsQT1kK3AsaD1jKih1LUMpLG09YyooZC1wKSxrPWcrJCx3PUIrQSxGPUUrbSx2PVAtaCx4PWctJCxEPUItQSxIPUUtbSxZPVAraDtzW3RdPWssc1t0KzFdPXcsc1t0KzJdPUYsc1t0KzNdPXYsc1t0KzRdPXgsc1t0KzVdPUQsc1t0KzZdPUgsc1t0KzddPVl9LHEucHJvdG90eXBlLl9yZWFsVHJhbnNmb3JtND1mdW5jdGlvbigpe2NvbnN0IHQ9dGhpcy5fb3V0LG49dGhpcy5fY3NpemU7bGV0IHM9MTw8dGhpcy5fd2lkdGgsbz1uL3M8PDEsYyxpO2NvbnN0IGE9dGhpcy5fYml0cmV2O2lmKG89PT00KWZvcihjPTAsaT0wO2M8bjtjKz1vLGkrKyl7Y29uc3QgdT1hW2ldO3RoaXMuX3NpbmdsZVJlYWxUcmFuc2Zvcm0yKGMsdT4+PjEscz4+PjEpfWVsc2UgZm9yKGM9MCxpPTA7YzxuO2MrPW8saSsrKXtjb25zdCB1PWFbaV07dGhpcy5fc2luZ2xlUmVhbFRyYW5zZm9ybTQoYyx1Pj4+MSxzPj4+MSl9Y29uc3QgZj10aGlzLl9pbnY/LTE6MSxsPXRoaXMudGFibGU7Zm9yKHM+Pj0yO3M+PTI7cz4+PTIpe289bi9zPDwxO2NvbnN0IHU9bz4+PjEsZD11Pj4+MSx5PWQ+Pj4xO2ZvcihjPTA7YzxuO2MrPW8pZm9yKGxldCBfPTAsQz0wO188PXk7Xys9MixDKz1zKXtjb25zdCBwPWMrXyxnPXArZCxCPWcrZCxFPUIrZCxQPXRbcF0sJD10W3ArMV0sQT10W2ddLGg9dFtnKzFdLG09dFtCXSxrPXRbQisxXSx3PXRbRV0sRj10W0UrMV0sdj1QLHg9JCxEPWxbQ10sSD1mKmxbQysxXSxZPUEqRC1oKkgsWD1BKkgraCpELHQwPWxbMipDXSxzMD1mKmxbMipDKzFdLGgwPW0qdDAtaypzMCxvMD1tKnMwK2sqdDAsYzA9bFszKkNdLFo9ZipsWzMqQysxXSxrMD13KmMwLUYqWixNMD13KlorRipjMCxiMD12K2gwLGQwPXgrbzAsQTA9di1oMCxDMD14LW8wLHAwPVkrazAsZzA9WCtNMCx2MD1mKihZLWswKSxUMD1mKihYLU0wKSxpMT1iMCtwMCxhMT1kMCtnMCxmMT1BMCtUMCxsMT1DMC12MDtpZih0W3BdPWkxLHRbcCsxXT1hMSx0W2ddPWYxLHRbZysxXT1sMSxfPT09MCl7Y29uc3QgVjM9YjAtcDAsSzM9ZDAtZzA7dFtCXT1WMyx0W0IrMV09SzM7Y29udGludWV9aWYoXz09PXkpY29udGludWU7Y29uc3QgdTE9QTAsaDE9LUMwLGIxPWIwLEczPS1kMCxxMz0tZipUMCxXMz0tZip2MCxqMz0tZipnMCxIMz0tZipwMCxPMz11MStxMyxZMz1oMStXMyxVMz1iMStIMyxYMz1HMy1qMyxjMj1jK2QtXyxpMj1jK3UtXzt0W2MyXT1PMyx0W2MyKzFdPVkzLHRbaTJdPVUzLHRbaTIrMV09WDN9fX0scS5wcm90b3R5cGUuX3NpbmdsZVJlYWxUcmFuc2Zvcm0yPWZ1bmN0aW9uKHQsbixyKXtjb25zdCBzPXRoaXMuX291dCxvPXRoaXMuX2RhdGEsYz1vW25dLGk9b1tuK3JdLGE9YytpLGY9Yy1pO3NbdF09YSxzW3QrMV09MCxzW3QrMl09ZixzW3QrM109MH0scS5wcm90b3R5cGUuX3NpbmdsZVJlYWxUcmFuc2Zvcm00PWZ1bmN0aW9uKHQsbixyKXtjb25zdCBzPXRoaXMuX291dCxvPXRoaXMuX2RhdGEsYz10aGlzLl9pbnY/LTE6MSxpPXIqMixhPXIqMyxmPW9bbl0sbD1vW24rcl0sdT1vW24raV0sZD1vW24rYV0seT1mK3UsXz1mLXUsQz1sK2QscD1jKihsLWQpLGc9eStDLEI9XyxFPS1wLFA9eS1DLCQ9XyxBPXA7c1t0XT1nLHNbdCsxXT0wLHNbdCsyXT1CLHNbdCszXT1FLHNbdCs0XT1QLHNbdCs1XT0wLHNbdCs2XT0kLHNbdCs3XT1BfTtjb25zdCBRMT00LHIxPW5ldyBNYXA7Y2xhc3MgeDN7Y29uc3RydWN0b3IodCxuKXt1Mih0aGlzLF8wKTt0aGlzLm1lbFNjYWxlPW51bGwsdGhpcy5sYXN0RnJhbWVJbmRleD0wLHRoaXMuYXVkaW89dCx0aGlzLm9wdGlvbnM9bix0aGlzLmxhc3RGcmFtZUluZGV4PTAscjEuaGFzKG4ud2luZG93U2l6ZSk/dGhpcy5mZnQ9cjEuZ2V0KG4ud2luZG93U2l6ZSk6KHRoaXMuZmZ0PW5ldyBxKG4ud2luZG93U2l6ZSkscjEuc2V0KG4ud2luZG93U2l6ZSx0aGlzLmZmdCkpLGgyKHRoaXMsXzAsdC5lbmRTYW1wbGUtdC5zdGFydFNhbXBsZSk7Y29uc3Qgcj1NYXRoLmNlaWwodGhpcy50b3RhbFNhbXBsZXMvdGhpcy5zdGVwKSxzPW4ud2luZG93U2l6ZS8yO3RoaXMuY29sb3JTY2FsZT1mMyhuLmNvbG9yTWFwKSx0aGlzLnNtb290aD1GMyhuLndpbmRvd0Z1bmN0aW9uKSxuLm1lbFNjYWxlJiYodGhpcy5tZWxTY2FsZT1oMyh7ZmZ0U2l6ZTpzLGJhbmtDb3VudDpzLGxvd0ZyZXF1ZW5jeTowLGhpZ2hGcmVxdWVuY3k6dGhpcy5ueXF1aXN0LHNhbXBsZVJhdGU6dC5zYW1wbGVSYXRlfSkpLHRoaXMuZmZ0V2lkdGg9cix0aGlzLmZmdEhlaWdodD1zLHRoaXMuaW1hZ2VCdWZmZXI9bmV3IFVpbnQ4Q2xhbXBlZEFycmF5KHRoaXMuZmZ0V2lkdGgqdGhpcy5mZnRIZWlnaHQqUTEpLHRoaXMuaW1hZ2VCdWZmZXIuZmlsbCgyNTUpLHRoaXMuY29tcGxleElucHV0PW5ldyBGbG9hdDMyQXJyYXkodGhpcy5zaXplKjIpLHRoaXMuZmZ0T3V0cHV0PW5ldyBGbG9hdDMyQXJyYXkodGhpcy5zaXplKjIpLHRoaXMud2luZG93PW5ldyBGbG9hdDMyQXJyYXkodGhpcy5zaXplKSx0aGlzLnNwZWN0cnVtPW5ldyBGbG9hdDMyQXJyYXkodGhpcy5zaXplLzIpLHRoaXMuZXN0aW1hdGVkV2luZG93TG9zcz1JMyhuLndpbmRvd0Z1bmN0aW9uLG4ud2luZG93U2l6ZSksdGhpcy5hbXBsaWZpY2F0aW9uRmFjdG9yPTEvdGhpcy5lc3RpbWF0ZWRXaW5kb3dMb3NzfWdldCBueXF1aXN0KCl7cmV0dXJuIHRoaXMuYXVkaW8uc2FtcGxlUmF0ZS8yfWdldCBzdGVwKCl7cmV0dXJuIHRoaXMub3B0aW9ucy53aW5kb3dTaXplLXRoaXMub3B0aW9ucy53aW5kb3dPdmVybGFwfWdldCBzaXplKCl7cmV0dXJuIHRoaXMub3B0aW9ucy53aW5kb3dTaXplfWdldCBvdXRwdXRCdWZmZXIoKXtyZXR1cm4gdGhpcy5pbWFnZUJ1ZmZlcn1nZXQgd2lkdGgoKXtyZXR1cm4gdGhpcy5mZnRXaWR0aH1nZXQgaGVpZ2h0KCl7cmV0dXJuIHRoaXMuZmZ0SGVpZ2h0fWdldCB0b3RhbFNhbXBsZXMoKXtyZXR1cm4gbDIodGhpcyxfMCl9cGFydGlhbEdlbmVyYXRlKHQsbixyKXtsZXQgcz0wO2ZvcihzPTA7czxuJiZ0aGlzLmV4dHJhY3RXaW5kb3codCxzLG4sdGhpcy5zaXplLHIpO3MrPXRoaXMuc3RlcCl7aWYodGhpcy5zbW9vdGgodGhpcy53aW5kb3cpLHRoaXMuaW50ZXJsZWF2ZVJlYWxzKCksdGhpcy5mZnQudHJhbnNmb3JtKHRoaXMuZmZ0T3V0cHV0LHRoaXMuY29tcGxleElucHV0KSx0aGlzLmV4dHJhY3RNYWduaXR1ZGVBbmRTY2FsZSh0aGlzLmZmdE91dHB1dCksdGhpcy5tZWxTY2FsZSl7Y29uc3Qgbz10aGlzLm1lbFNjYWxlKHRoaXMuc3BlY3RydW0pO3RoaXMuc3BlY3RydW0uc2V0KG8pfXRoaXMucGFpbnRTcGVjdHJ1bUludG9QaXhlbEJ1ZmZlcigpLHRoaXMubGFzdEZyYW1lSW5kZXgrK31yZXR1cm4gc31leHRyYWN0V2luZG93KHQsbixyLHMsbyl7Y29uc3QgYz1uK3M7aWYoYzw9cil0aGlzLndpbmRvdy5zZXQodC5zdWJhcnJheShuLGMpKTtlbHNle2lmKCFvKXJldHVybiExO3RoaXMud2luZG93LnNldCh0LnN1YmFycmF5KHItcyxyKSl9cmV0dXJuITB9aW50ZXJsZWF2ZVJlYWxzKCl7Y29uc3QgdD10aGlzLndpbmRvdyxuPXRoaXMuY29tcGxleElucHV0O2ZvcihsZXQgcj0wO3I8dC5sZW5ndGg7cisrKW5bcioyXT10W3JdfWV4dHJhY3RNYWduaXR1ZGVBbmRTY2FsZSh0KXtjb25zdCBuPXRoaXMuc3BlY3RydW0scj1uLmxlbmd0aCxzPXRoaXMuc2l6ZSxvPXRoaXMuYW1wbGlmaWNhdGlvbkZhY3RvcixjPTI7Zm9yKGxldCBpPTA7aTxyO2krKyl7Y29uc3QgYT1jK2kqMixmPXRbYV0vcyxsPXRbYSsxXS9zO2xldCB1PU1hdGguc3FydChmKmYrbCpsKTt1PXUqMix1PXUqbyxuW2ldPXV9fXBhaW50U3BlY3RydW1JbnRvUGl4ZWxCdWZmZXIoKXtmb3IobGV0IHQ9MDt0PHRoaXMuc3BlY3RydW0ubGVuZ3RoO3QrKyl7Y29uc3Qgbj10aGlzLnNwZWN0cnVtW3RdO2xldCByPTIwKk1hdGgubG9nMTAobik7cis9MjA7Y29uc3Qgbz0tODYsaT0tNi1vO2xldCBhPShyLW8pL2k7YSs9dGhpcy5vcHRpb25zLmJyaWdodG5lc3MsYSo9dGhpcy5vcHRpb25zLmNvbnRyYXN0O2NvbnN0IGY9dGhpcy5sYXN0RnJhbWVJbmRleCxsPXRoaXMuZmZ0SGVpZ2h0LTEtdCx1PVExKihmK2wqdGhpcy5mZnRXaWR0aCk7dT50aGlzLmltYWdlQnVmZmVyLmxlbmd0aC00JiZjb25zb2xlLmVycm9yKCJvdmVyZmxvdyBjb29yZGluYXRlcyIsZixsLHUsdGhpcy5pbWFnZUJ1ZmZlci5sZW5ndGgsdGhpcy5mZnRXaWR0aCx0aGlzLmZmdEhlaWdodCk7Y29uc3QgZD10aGlzLmNvbG9yU2NhbGUoYSk7dGhpcy5pbWFnZUJ1ZmZlci5zZXQoZCx1KX19fV8wPW5ldyBXZWFrTWFwO2Z1bmN0aW9uIHMxKGUpe2NvbnN0IHQ9QjMoZSk7cmV0dXJuIG5ldyBQcm9taXNlKG49PnNldFRpbWVvdXQobix0KSl9ZnVuY3Rpb24gQjMoZSl7cmV0dXJuIGUqMWUzfXZhciBKMT0oZT0+KGVbZS5CVUZGRVJfQVZBSUxBQkxFPTBdPSJCVUZGRVJfQVZBSUxBQkxFIixlW2UuQlVGRkVSX1dSSVRFX0hFQUQ9MV09IkJVRkZFUl9XUklURV9IRUFEIixlW2UuV09SS0VSX1NUQVRFPTJdPSJXT1JLRVJfU1RBVEUiLGVbZS5HRU5FUkFUSU9OPTNdPSJHRU5FUkFUSU9OIixlW2UuUFJPQ0VTU09SX1JFQURZPTRdPSJQUk9DRVNTT1JfUkVBRFkiLGVbZS5QUk9DRVNTT1JfQ09NUExFVEU9NV09IlBST0NFU1NPUl9DT01QTEVURSIsZSkpKEoxfHx7fSk7Y29uc3QgZTI9LTE7Y2xhc3MgbzF7c3RhdGljIGNyZWF0ZVN0YXRlKCl7Y29uc3QgdD1uZXcgU2hhcmVkQXJyYXlCdWZmZXIoT2JqZWN0LmtleXMoSjEpLmxlbmd0aC8yKkludDMyQXJyYXkuQllURVNfUEVSX0VMRU1FTlQpLG49bmV3IG8xKHQpO3JldHVybiBuLnByb2Nlc3NvclJlYWR5R2VuZXJhdGlvbj1lMixuLnByb2Nlc3NvckNvbXBsZXRlR2VuZXJhdGlvbj1lMixufWNvbnN0cnVjdG9yKHQpe3RoaXMuc3RhdGU9bmV3IEludDMyQXJyYXkodCl9Z2V0IHN0YXRlQnVmZmVyKCl7cmV0dXJuIHRoaXMuc3RhdGUuYnVmZmVyfWdldCBidWZmZXJBdmFpbGFibGUoKXtyZXR1cm4gQXRvbWljcy5sb2FkKHRoaXMuc3RhdGUsMCk9PT0xfXNldCBidWZmZXJBdmFpbGFibGUodCl7QXRvbWljcy5zdG9yZSh0aGlzLnN0YXRlLDAsdCksQXRvbWljcy5ub3RpZnkodGhpcy5zdGF0ZSwwLHQpfWdldCBidWZmZXJXcml0ZUhlYWQoKXtyZXR1cm4gQXRvbWljcy5sb2FkKHRoaXMuc3RhdGUsMSl9c2V0IGJ1ZmZlcldyaXRlSGVhZCh0KXtBdG9taWNzLnN0b3JlKHRoaXMuc3RhdGUsMSx0KX1nZXQgd29ya2VyTmV3KCl7cmV0dXJuIEF0b21pY3MubG9hZCh0aGlzLnN0YXRlLDIpPT09MH1nZXQgd29ya2VySWRsZSgpe3JldHVybiBBdG9taWNzLmxvYWQodGhpcy5zdGF0ZSwyKT09PTF9Z2V0IHdvcmtlclByb2Nlc3NpbmcoKXtyZXR1cm4gQXRvbWljcy5sb2FkKHRoaXMuc3RhdGUsMik9PT0yfXNldCB3b3JrZXJQcm9jZXNzaW5nKHQpe0F0b21pY3Muc3RvcmUodGhpcy5zdGF0ZSwyLHQpLEF0b21pY3Mubm90aWZ5KHRoaXMuc3RhdGUsMix0KX1nZXQgZ2VuZXJhdGlvbigpe3JldHVybiBBdG9taWNzLmxvYWQodGhpcy5zdGF0ZSwzKX1nZXQgcHJvY2Vzc29yUmVhZHlHZW5lcmF0aW9uKCl7cmV0dXJuIEF0b21pY3MubG9hZCh0aGlzLnN0YXRlLDQpfXNldCBwcm9jZXNzb3JSZWFkeUdlbmVyYXRpb24odCl7QXRvbWljcy5zdG9yZSh0aGlzLnN0YXRlLDQsdCl9Z2V0IHByb2Nlc3NvckNvbXBsZXRlR2VuZXJhdGlvbigpe3JldHVybiBBdG9taWNzLmxvYWQodGhpcy5zdGF0ZSw1KX1zZXQgcHJvY2Vzc29yQ29tcGxldGVHZW5lcmF0aW9uKHQpe0F0b21pY3Muc3RvcmUodGhpcy5zdGF0ZSw1LHQpfWlzUHJvY2Vzc29yUmVhZHkodCl7cmV0dXJuIEF0b21pY3MubG9hZCh0aGlzLnN0YXRlLDQpPT09dH1pc1Byb2Nlc3NvckNvbXBsZXRlKHQpe3JldHVybiBBdG9taWNzLmxvYWQodGhpcy5zdGF0ZSw1KT09PXR9cHJvY2Vzc29yQ29tcGxldGUodCl7Y29uc3Qgbj10aGlzLnByb2Nlc3NvckNvbXBsZXRlR2VuZXJhdGlvbjt0Pm4mJih0aGlzLnByb2Nlc3NvckNvbXBsZXRlR2VuZXJhdGlvbj10KSx0PT09bisxJiYodGhpcy5idWZmZXJBdmFpbGFibGU9MSl9cmVzZXQoKXtjb25zdCBuPUF0b21pY3MuYWRkKHRoaXMuc3RhdGUsMywxKSsxO3JldHVybiB0aGlzLmJ1ZmZlcldyaXRlSGVhZD0wLHRoaXMuYnVmZmVyQXZhaWxhYmxlPTAsbn1tYXRjaGVzQ3VycmVudEdlbmVyYXRpb24odCl7cmV0dXJuIEF0b21pY3MubG9hZCh0aGlzLnN0YXRlLDMpPT09dH1hc3luYyB3YWl0Rm9yUHJvY2Vzc29yUmVhZHkodCl7Zm9yKDt0aGlzLnByb2Nlc3NvclJlYWR5R2VuZXJhdGlvbjx0Oylhd2FpdCBzMSgwKTtyZXR1cm4gdGhpcy5tYXRjaGVzQ3VycmVudEdlbmVyYXRpb24odCl9YXN5bmMgd2FpdEZvcldvcmtlclJlYWR5KCl7Zm9yKDt0aGlzLndvcmtlck5ldzspYXdhaXQgczEoMCl9YXN5bmMgd2FpdEZvcldvcmtlcklkbGUoKXtmb3IoOyF0aGlzLndvcmtlcklkbGU7KWF3YWl0IHMxKDApfX1jbGFzcyB6MyBleHRlbmRzIG8xe2NvbnN0cnVjdG9yKCl7c3VwZXIoLi4uYXJndW1lbnRzKSx0aGlzLlRJTUVPVVQ9MX1wcm9jZXNzb3JDYW5HZW5lcmF0ZSh0KXtyZXR1cm4gdGhpcy5pc1Byb2Nlc3NvclJlYWR5KHQpJiYhdGhpcy5pc1Byb2Nlc3NvckNvbXBsZXRlKHQpfXdhaXRGb3JCdWZmZXIoKXtyZXR1cm4gQXRvbWljcy53YWl0KHRoaXMuc3RhdGUsMCwwLHRoaXMuVElNRU9VVCk9PT0ibm90LWVxdWFsIn1idWZmZXJQcm9jZXNzZWQodCxuKXtpZihuPHRoaXMuYnVmZmVyV3JpdGVIZWFkKXtjb25zdCByPXRoaXMuYnVmZmVyV3JpdGVIZWFkLW47dC5jb3B5V2l0aGluKDAsbix0aGlzLmJ1ZmZlcldyaXRlSGVhZCksdGhpcy5idWZmZXJXcml0ZUhlYWQ9cn1lbHNlIHRoaXMuYnVmZmVyV3JpdGVIZWFkPTA7dGhpcy5idWZmZXJBdmFpbGFibGU9MH13b3JrZXJCdXN5KCl7dGhpcy53b3JrZXJQcm9jZXNzaW5nPTJ9d29ya2VyUmVhZHkoKXt0aGlzLndvcmtlclByb2Nlc3Npbmc9MX19bGV0IGUwLG4wLHkwLHQyLHIwLG4yLE8sYzEscjI7ZnVuY3Rpb24gczIoZSl7Y29uc3QgdD1yMC5wYXJ0aWFsR2VuZXJhdGUoYzEsTy5idWZmZXJXcml0ZUhlYWQsTy5pc1Byb2Nlc3NvckNvbXBsZXRlKGUpKTtPLmJ1ZmZlclByb2Nlc3NlZChjMSx0KX1mdW5jdGlvbiBQMyhlKXtjb25zdCBuPWAke2B3b3JrZXIgKCR7ZX0pOmB9IHJlbmRlcmA7Y29uc29sZS50aW1lKG4pLE8ud29ya2VyQnVzeSgpO2xldCByPSExO2Zvcig7Ty5wcm9jZXNzb3JDYW5HZW5lcmF0ZShlKTspe2lmKCFPLndhaXRGb3JCdWZmZXIoKSl7aWYoTy5tYXRjaGVzQ3VycmVudEdlbmVyYXRpb24oZSkpY29udGludWU7cj0hMDticmVha31zMihlKX1yfHwoTy5idWZmZXJXcml0ZUhlYWQ+MCYmczIoZSksJDMocjAub3V0cHV0QnVmZmVyKSksY29uc29sZS50aW1lRW5kKG4pLE8ud29ya2VyUmVhZHkoKX1mdW5jdGlvbiAkMyhlLHQpe2NvbnN0IG49bmV3IEltYWdlRGF0YShlLHIwLndpZHRoLHIwLmhlaWdodCk7dDIucHV0SW1hZ2VEYXRhKG4sMCwwKSxvMigpfWZ1bmN0aW9uIG8yKGUpe24wLmRyYXdJbWFnZSh5MCwwLDAsZTAud2lkdGgsZTAuaGVpZ2h0KSxuMC5jb21taXQmJm4wLmNvbW1pdCgpfWZ1bmN0aW9uIFQzKGUpe089bmV3IHozKGUuc3RhdGUpLGMxPW5ldyBGbG9hdDMyQXJyYXkoZS5zYW1wbGVCdWZmZXIpLGUwPWUuY2FudmFzLHkwPW5ldyBPZmZzY3JlZW5DYW52YXMoNTEyLDUxMiksdDI9eTAuZ2V0Q29udGV4dCgiMmQiKSxuMD1lMC5nZXRDb250ZXh0KCIyZCIpLG4wLmltYWdlU21vb3RoaW5nRW5hYmxlZD0hMCxuMC5pbWFnZVNtb290aGluZ1F1YWxpdHk9ImhpZ2giLE8ud29ya2VyUmVhZHkoKX1mdW5jdGlvbiBFMyhlKXsoe29wdGlvbnM6bjIsYXVkaW9JbmZvcm1hdGlvbjpyMn09ZSkscjA9bmV3IHgzKHIyLG4yKSx5MC53aWR0aD1yMC53aWR0aCx5MC5oZWlnaHQ9cjAuaGVpZ2h0LFAzKGUuZ2VuZXJhdGlvbil9ZnVuY3Rpb24gTjMoKXtuMC5jbGVhclJlY3QoMCwwLGUwLndpZHRoLGUwLmhlaWdodCl9ZnVuY3Rpb24gTDMoZSl7ZTAud2lkdGg9ZS53aWR0aCxlMC5oZWlnaHQ9ZS5oZWlnaHQsbzIoTy5nZW5lcmF0aW9uKX1mdW5jdGlvbiBEMyhlKXtzd2l0Y2goZS5kYXRhWzBdKXtjYXNlInNldHVwIjpUMyhlLmRhdGFbMV0pO2JyZWFrO2Nhc2UicmVzaXplLWNhbnZhcyI6TDMoZS5kYXRhWzFdKTticmVhaztjYXNlInJlZ2VuZXJhdGUtc3BlY3Ryb2dyYW0iOkUzKGUuZGF0YVsxXSk7YnJlYWs7Y2FzZSJjbGVhci1jYW52YXMiOk4zKCk7YnJlYWs7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoInVua25vd24gbWVzc2FnZTogIitlLmRhdGFbMF0pfX1vbm1lc3NhZ2U9RDN9KSgpOwo=", decodeBase64 = (C) => Uint8Array.from(atob(C), (L) => L.charCodeAt(0)), blob = typeof self < "u" && self.Blob && new Blob([decodeBase64(encodedJs)], { type: "text/javascript;charset=utf-8" });
function WorkerWrapper(C) {
  let L;
  try {
    if (L = blob && (self.URL || self.webkitURL).createObjectURL(blob), !L) throw "";
    const A = new Worker(L, {
      name: C == null ? void 0 : C.name
    });
    return A.addEventListener("error", () => {
      (self.URL || self.webkitURL).revokeObjectURL(L);
    }), A;
  } catch {
    return new Worker(
      "data:text/javascript;base64," + encodedJs,
      {
        name: C == null ? void 0 : C.name
      }
    );
  } finally {
    L && (self.URL || self.webkitURL).revokeObjectURL(L);
  }
}
const BUFFER_PROCESSOR_NAME = "buffer-builder-processor";
class AudioHelper {
  constructor() {
    this.spectrogramWorker = null, this.cachedResponse = null, this.cachedAudioInformation = null, this.offscreenCanvas = null, this.generationData = /* @__PURE__ */ new Map(), this.segmentSize = 44100, this.generation = 0, this.spectrogramWorker = new WorkerWrapper(), this.state = State.createState(), this.sampleBuffer = new SharedArrayBuffer(Float32Array.BYTES_PER_ELEMENT * this.segmentSize);
  }
  get canvasTransferred() {
    return !!this.offscreenCanvas;
  }
  async connect(L, A, W) {
    if (this.offscreenCanvas)
      throw new Error("Connect can only be called once. Use regenerateSpectrogram to update the spectrogram.");
    const X = performance.now();
    this.offscreenCanvas = A.transferControlToOffscreen(), this.setupWorker();
    const J = await this.render(W, this.generation, L);
    return console.log("audio: connect complete", performance.now() - X), J;
  }
  async changeSource(L, A) {
    if (console.log("audio: change source"), !this.spectrogramWorker)
      throw new Error("Worker is not initialized. Call connect() first.");
    if (!this.cachedResponse)
      throw new Error("No source to regenerate spectrogram");
    const W = await this.abort();
    return this.clearCanvas(), await this.render(A, W, L);
  }
  async regenerateSpectrogram(L) {
    const A = performance.now();
    if (!this.spectrogramWorker)
      throw new Error("Worker is not initialized. Call connect() first.");
    const W = await this.abort();
    if (!this.cachedResponse)
      throw new Error("No spectrogram options to regenerate");
    await this.render(L, W), console.log("audio: regenerate complete", performance.now() - A);
  }
  resizeCanvas(L) {
    if (!this.spectrogramWorker)
      throw new Error("Worker is not initialized");
    const A = ["resize-canvas", L];
    this.spectrogramWorker.postMessage(A);
  }
  async abort() {
    const L = this.generation, A = this.generationData.get(L);
    A && (A.disconnect(), this.generationData.delete(L));
    const W = this.state.reset();
    return this.generation = W, await this.state.waitForWorkerIdle(), W;
  }
  /**
   * Internal render function. Does not check if we need to abort.
   * @param options the spectrogram options
   * @param generation the generation number
   * @param src  if provided fetches the audio at the supplied source, otherwise clones a buffer of the last response
   */
  async render(L, A, W = null) {
    const X = W ? await this.fetchAudio(W) : await this.cachedBuffer(), J = this.cachedAudioInformation;
    return await this.createAudioContext(J, X, A), this.regenerateWorker(L, J, A), J;
  }
  createAudioInformation(L) {
    if (!L.format.duration || !L.format.sampleRate || !L.format.numberOfChannels)
      throw new Error("Could not determine all audio metadata");
    return Object.freeze({
      startSample: 0,
      endSample: L.format.duration * L.format.sampleRate,
      sampleRate: L.format.sampleRate,
      channels: L.format.numberOfChannels,
      duration: L.format.duration
    });
  }
  async fetchAudio(L) {
    const A = `audio (${this.generation}): fetch and decode audio`;
    console.time(A);
    const W = await fetch(L);
    if (!W.ok)
      throw new Error(`Failed to fetch audio: ${W.statusText}`);
    const X = W.clone(), J = await W.arrayBuffer(), te = await lib$3.parseBlob(new Blob([J])), oe = this.createAudioInformation(te);
    return this.cachedResponse = X, this.cachedAudioInformation = oe, console.timeEnd(A), J;
  }
  async cachedBuffer() {
    if (!this.cachedResponse)
      throw new Error("No cached file");
    const L = this.cachedResponse.clone(), A = await this.cachedResponse.arrayBuffer();
    return this.cachedResponse = L, A;
  }
  async createAudioContext(L, A, W) {
    const X = L.duration * L.sampleRate * L.channels;
    //! creates a buffer the size of the entire audio file
    const J = new OfflineAudioContext({
      numberOfChannels: L.channels,
      sampleRate: L.sampleRate,
      length: X
    }), te = await J.decodeAudioData(A), oe = new AudioBufferSourceNode(J, { buffer: te }), ne = new URL(BufferBuilderProcessor, import.meta.url);
    await J.audioWorklet.addModule(ne);
    const re = new AudioWorkletNode(J, BUFFER_PROCESSOR_NAME);
    oe.connect(re).connect(J.destination), J.addEventListener("complete", () => {
      this.state.processorComplete(W);
    }), await this.setupProcessor(re, W) && (this.generationData.set(W, oe), oe.start(), J.startRendering());
  }
  // messages
  async setupWorker() {
    if (!this.offscreenCanvas)
      throw new Error("Canvas is not initialized");
    if (!this.spectrogramWorker)
      throw new Error("Worker is not initialized");
    const L = [
      "setup",
      {
        state: this.state.stateBuffer,
        sampleBuffer: this.sampleBuffer,
        canvas: this.offscreenCanvas
      }
    ];
    this.spectrogramWorker.postMessage(L, [this.offscreenCanvas]), await this.state.waitForWorkerReady();
  }
  // very specifically not using instance value of this.generation
  // we want that value closed over so it can't change
  async setupProcessor(L, A) {
    const W = [
      "setup",
      { state: this.state.stateBuffer, sampleBuffer: this.sampleBuffer, generation: A }
    ];
    return L.port.postMessage(W), await this.state.waitForProcessorReady(A);
  }
  clearCanvas() {
    var L;
    (L = this.spectrogramWorker) == null || L.postMessage(["clear-canvas"]);
  }
  regenerateWorker(L, A, W) {
    if (!this.spectrogramWorker)
      throw new Error("Worker is not initialized");
    const X = [
      "regenerate-spectrogram",
      {
        options: L,
        audioInformation: A,
        generation: W
      }
    ];
    this.spectrogramWorker.postMessage(X);
  }
}
class SpectrogramOptions {
  constructor(L, A, W, X, J, te, oe) {
    this.windowSize = L, this.windowOverlap = A, this.windowFunction = W, this.melScale = X, this.brightness = J, this.contrast = te, this.colorMap = oe;
  }
  get windowStep() {
    return this.windowSize - this.windowOverlap;
  }
}
const spectrogramStyles = ":host{display:block}#spectrogram-container{position:relative;background-color:var(--oe-panel-color-lighter);width:100%;height:100%}#spectrogram-container>canvas{position:relative;display:inherit;height:100%;min-height:128px}";
var __defProp$a = Object.defineProperty, __getOwnPropDesc$a = Object.getOwnPropertyDescriptor, __decorateClass$a = (C, L, A, W) => {
  for (var X = W > 1 ? void 0 : W ? __getOwnPropDesc$a(L, A) : L, J = C.length - 1, te; J >= 0; J--)
    (te = C[J]) && (X = (W ? te(L, A, X) : te(X)) || X);
  return W && X && __defProp$a(L, A, X), X;
};
const defaultAudioModel = new AudioModel(0, 0, { startOffset: 0, duration: 0 }), domRenderWindowConverter = (C) => {
  if (!C)
    return;
  const [L, A, W, X] = C.split(",").map(parseFloat);
  return new RenderWindow(L, W, A, X);
};
let SpectrogramComponent = class extends e(AbstractComponent(h$1)) {
  constructor() {
    super(...arguments), this.paused = !0, this.src = "", this.scaling = "stretch", this.windowSize = 512, this.windowFunction = "hann", this.windowOverlap = 0, this.melScale = !1, this.colorMap = "", this.offset = 0, this.brightness = 0, this.contrast = 1, this.audio = d(defaultAudioModel), this.currentTime = d(this.offset), this.renderCanvasSize = d({ width: 128, height: 0 }), this.renderWindow = w(() => this.parseRenderWindow()), this.unitConverters = d(void 0), this.audioHelper = new AudioHelper(), this.doneFirstRender = !1, this.nextRequestId = null, this.playStartedAt = null;
  }
  get spectrogramOptions() {
    return new SpectrogramOptions(
      this.windowSize,
      this.windowOverlap,
      this.windowFunction,
      this.melScale,
      this.brightness,
      this.contrast,
      this.colorMap
    );
  }
  set spectrogramOptions(C) {
    this.windowSize = C.windowSize, this.windowOverlap = C.windowOverlap, this.windowFunction = C.windowFunction, this.melScale = C.melScale, this.brightness = C.brightness, this.contrast = C.contrast, this.colorMap = C.colorMap;
  }
  get possibleWindowSizes() {
    return [128, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768];
  }
  get possibleWindowOverlaps() {
    const C = this.possibleWindowSizes, L = this.spectrogramOptions.windowSize;
    return C.filter((A) => A < L);
  }
  get renderedSource() {
    if (this.src)
      return this.src;
    const C = this.slotElements[0];
    return C instanceof HTMLSourceElement ? C.src : "";
  }
  hasSource() {
    return !!this.src || this.slotElements.length > 0;
  }
  // todo: this should be part of a mixin
  disconnectedCallback() {
    OeResizeObserver.instance.unobserve(this.canvas), super.disconnectedCallback();
  }
  firstUpdated() {
    OeResizeObserver.observe(this.canvas, (L) => this.handleResize(L)), this.resizeCanvas(this.canvas), this.hasSource() && this.renderSpectrogram();
    const C = new UnitConverter(
      this.renderWindow,
      this.renderCanvasSize,
      this.audio,
      d(this.melScale)
    );
    this.unitConverters = d(C);
  }
  updated(C) {
    this.doneFirstRender ? this.invalidateSpectrogramOptions(C) ? (this.regenerateSpectrogramOptions(), this.unitConverters.value && (this.unitConverters.value.melScale.value = this.melScale)) : this.invalidateSpectrogramSource(C) && (this.pause(), this.regenerateSpectrogram(), this.updateCurrentTime()) : this.invalidateSpectrogramSource(C) && this.hasSource() && this.renderSpectrogram(), this.resizeCanvas(this.canvas);
  }
  renderSpectrogram() {
    this.dispatchEvent(
      new CustomEvent("loading", {
        bubbles: !0
      })
    ), this.audioHelper.connect(this.renderedSource, this.canvas, this.spectrogramOptions).then((C) => {
      const L = { duration: C.duration, startOffset: this.offset };
      this.audio.value = new AudioModel(C.duration, C.sampleRate, L), this.dispatchEvent(
        new CustomEvent("loaded", {
          bubbles: !0
        })
      ), this.doneFirstRender = !0;
    });
  }
  regenerateSpectrogram() {
    !this.doneFirstRender || !this.renderedSource || (console.log("regenerating spectrogram"), this.dispatchEvent(
      new CustomEvent("loading", {
        bubbles: !0
      })
    ), this.audioHelper.changeSource(this.renderedSource, this.spectrogramOptions).then((C) => {
      const L = { duration: C.duration, startOffset: this.offset };
      this.audio.value = new AudioModel(C.duration, C.sampleRate, L), this.dispatchEvent(
        new CustomEvent("loaded", {
          bubbles: !0
        })
      );
    }));
  }
  regenerateSpectrogramOptions() {
    !this.doneFirstRender || !this.renderedSource || this.audioHelper.regenerateSpectrogram(this.spectrogramOptions).then(() => {
      this.dispatchEvent(
        new CustomEvent("loaded", {
          bubbles: !0
        })
      );
    });
  }
  resetSettings() {
    this.colorMap = "audacity", this.contrast = 1, this.brightness = 0, this.melScale = !1, this.stop();
  }
  play(C = !1) {
    this.setPaused(!1, C);
  }
  pause(C = !1) {
    this.setPaused(!0, C);
  }
  stop() {
    this.currentTime.value = 0, this.pause();
  }
  handleSlotChange() {
    this.hasSource() && this.renderSpectrogram();
  }
  originalFftSize() {
    const C = this.spectrogramOptions, L = C.windowSize - C.windowOverlap, A = this.audio.value.duration, W = this.audio.value.sampleRate, X = A * W, J = Math.ceil(X / L), te = C.windowSize / 2;
    return { width: J, height: te };
  }
  naturalSize(C, L) {
    const A = Math.min(L.clientWidth / C.width, L.clientHeight / C.height);
    return {
      width: C.width * A,
      height: C.height * A
    };
  }
  stretchSize(C) {
    const L = C;
    if (L)
      return { width: L.clientWidth, height: L.clientHeight };
    throw new Error("Spectrogram element does not have a parent to scale to");
  }
  // TODO: parents should not contribute to the size of the canvas
  handleResize(C) {
    if (C.length === 0) return;
    const L = C[0].target;
    this.resizeCanvas(L);
  }
  // TODO: refactor this procedure
  resizeCanvas(C) {
    let L;
    if (this.scaling === "original")
      L = this.originalFftSize();
    else if (this.scaling === "natural") {
      const A = this.originalFftSize();
      L = this.naturalSize(A, C);
    } else
      L = this.stretchSize(C);
    this.renderCanvasSize.value = L, this.audioHelper.canvasTransferred ? this.audioHelper.resizeCanvas(L) : (this.canvas.width = L.width, this.canvas.height = L.height), this.scaling === "original" && (this.style.height = `${L.height}px`, this.style.width = `${L.width}px`), this.scaling === "stretch" ? this.canvas.style.width = "100%" : this.canvas.style.width = "auto";
  }
  /**
   * Specifies if the spectrogram is invalidated with the new parameters
   * This method can be used to check if the spectrogram needs to be re-rendered
   */
  invalidateSpectrogramOptions(C) {
    return [
      "domRenderWindow",
      "brightness",
      "contrast",
      "windowSize",
      "windowFunction",
      "windowOverlap",
      "melScale",
      "colorMap",
      "offset"
    ].some((A) => C.has(A));
  }
  invalidateSpectrogramSource(C) {
    return ["src", "slotElements"].some((A) => C.has(A));
  }
  updateCurrentTime(C = !1) {
    if (C) {
      this.nextRequestId && (window.cancelAnimationFrame(this.nextRequestId), this.nextRequestId = null), this.nextRequestId = requestAnimationFrame(() => this.pollUpdateHighFreqCurrentTime());
      return;
    }
    this.currentTime.value = this.mediaElement.currentTime;
  }
  // we used to set lastHighResSync to performance.now(), but this caused some
  // visual artifacts when the audio was paused and then played again
  // this was because the time between calling function and fetching the highResTime
  // later on led to a time difference of a couple of milliseconds
  pollUpdateHighFreqCurrentTime(C = null, L = null) {
    if (!this.paused) {
      const A = this.mediaElement.currentTime;
      let W = 0;
      const X = performance.now();
      if (A === L ? (W = (X - (C ?? X)) / 1e3, this.playStartedAt === null && (this.playStartedAt = X)) : this.playStartedAt !== null && (C = X), A + W >= this.audio.value.duration) {
        this.currentTime.value = this.audio.value.duration, this.pause();
        return;
      }
      this.currentTime.value = A + W, this.nextRequestId = requestAnimationFrame(
        () => this.pollUpdateHighFreqCurrentTime(C, A)
      );
    }
  }
  setPaused(C, L = !1) {
    if (C == this.mediaElement.paused) return;
    const A = {
      play: !C,
      keyboardShortcut: L
    };
    this.dispatchEvent(
      new CustomEvent(SpectrogramComponent.playEventName, { detail: A, cancelable: !0, bubbles: !0 })
    ) && (C ? (this.nextRequestId && (window.cancelAnimationFrame(this.nextRequestId), this.nextRequestId = null), this.playStartedAt = null, this.mediaElement.pause()) : (this.mediaElement.play(), this.updateCurrentTime(!0)), this.paused = C);
  }
  // creates a render window from an audio segment if no explicit render window
  // is provided
  parseRenderWindow() {
    var C;
    return this.domRenderWindow ? this.domRenderWindow : new RenderWindow(
      this.offset,
      this.offset + this.audio.value.duration,
      0,
      ((C = this.unitConverters.value) == null ? void 0 : C.nyquist.value) ?? 0
    );
  }
  render() {
    return ke$1`
      <div id="spectrogram-container">
        <canvas></canvas>
      </div>
      <audio id="media-element" src="${this.src}" @ended="${this.pause}" preload="metadata" crossorigin="anonymous">
        <slot @slotchange="${this.handleSlotChange}"></slot>
      </audio>
    `;
  }
};
SpectrogramComponent.styles = r$6(spectrogramStyles);
SpectrogramComponent.playEventName = "play";
__decorateClass$a([
  n$1({ attribute: "window", converter: domRenderWindowConverter, reflect: !0 })
], SpectrogramComponent.prototype, "domRenderWindow", 2);
__decorateClass$a([
  n$1({ type: Boolean, reflect: !0 })
], SpectrogramComponent.prototype, "paused", 2);
__decorateClass$a([
  n$1({ type: String, reflect: !0 })
], SpectrogramComponent.prototype, "src", 2);
__decorateClass$a([
  n$1({ type: String, reflect: !0 })
], SpectrogramComponent.prototype, "scaling", 2);
__decorateClass$a([
  n$1({ type: Number, attribute: "window-size" })
], SpectrogramComponent.prototype, "windowSize", 2);
__decorateClass$a([
  n$1({ type: String, attribute: "window-function" })
], SpectrogramComponent.prototype, "windowFunction", 2);
__decorateClass$a([
  n$1({ type: Number, attribute: "window-overlap" })
], SpectrogramComponent.prototype, "windowOverlap", 2);
__decorateClass$a([
  n$1({ type: Boolean, attribute: "mel-scale", converter: booleanConverter })
], SpectrogramComponent.prototype, "melScale", 2);
__decorateClass$a([
  n$1({ type: String, attribute: "color-map" })
], SpectrogramComponent.prototype, "colorMap", 2);
__decorateClass$a([
  n$1({ type: Number })
], SpectrogramComponent.prototype, "offset", 2);
__decorateClass$a([
  n$1({ type: Number })
], SpectrogramComponent.prototype, "brightness", 2);
__decorateClass$a([
  n$1({ type: Number })
], SpectrogramComponent.prototype, "contrast", 2);
__decorateClass$a([
  o$2()
], SpectrogramComponent.prototype, "slotElements", 2);
__decorateClass$a([
  e$6("#media-element")
], SpectrogramComponent.prototype, "mediaElement", 2);
__decorateClass$a([
  e$6("canvas")
], SpectrogramComponent.prototype, "canvas", 2);
SpectrogramComponent = __decorateClass$a([
  t$4("oe-spectrogram")
], SpectrogramComponent);
const indicatorStyles = ":host{position:relative;display:inline-block;width:100%}:host::part(indicator-line){stroke:red;stroke-width:2}:host::part(seek-icon){stroke:gray;fill:#fff}#wrapped-element{position:relative}#indicator-svg{position:absolute;height:100%;z-index:1;overflow:visible}#indicator-line{stroke:currentColor;shape-rendering:crispEdges;will-change:transform}";
var __defProp$9 = Object.defineProperty, __getOwnPropDesc$9 = Object.getOwnPropertyDescriptor, __decorateClass$9 = (C, L, A, W) => {
  for (var X = W > 1 ? void 0 : W ? __getOwnPropDesc$9(L, A) : L, J = C.length - 1, te; J >= 0; J--)
    (te = C[J]) && (X = (W ? te(L, A, X) : te(X)) || X);
  return W && X && __defProp$9(L, A, X), X;
};
let IndicatorComponent = class extends AbstractComponent(h$1) {
  constructor() {
    super(...arguments), this.visible = !0, this.xPos = 0, this.computedTimePx = w(() => 0);
  }
  handleSlotChange() {
    this.spectrogram && this.spectrogram.unitConverters && (this.unitConverter = this.spectrogram.unitConverters.value, this.computedTimePx = w(() => {
      if (!this.spectrogram || !this.unitConverter)
        return 0;
      const C = this.spectrogram.currentTime, L = this.unitConverter.scaleX.value;
      return L(C.value);
    }), this.unitConverter && this.unitConverter.canvasSize.subscribe(this.handleCanvasResize));
  }
  handleCanvasResize(C) {
    if (this != null && this.wrappedElement) {
      const { width: L, height: A } = C;
      this.wrappedElement.style.width = `${L}px`, this.wrappedElement.style.height = `${A}px`;
    }
  }
  render() {
    return ke$1`
      <div id="wrapped-element">
        ${nn(
      this.visible,
      () => ke$1`
            <svg id="indicator-svg">
              <g id="indicator-group" style="transform: translateX(${s(this.computedTimePx)}px)">
                <line part="indicator-line" y1="0" y2="100%"></line>
                <circle id="seek-icon" part="seek-icon" cy="100%" r="5" />
              </g>
            </svg>
          `
    )}

        <slot @slotchange="${this.handleSlotChange}"></slot>
      </div>
    `;
  }
};
IndicatorComponent.styles = r$6(indicatorStyles);
__decorateClass$9([
  n$1({ type: Boolean, converter: booleanConverter })
], IndicatorComponent.prototype, "visible", 2);
__decorateClass$9([
  queryDeeplyAssignedElement({ selector: "oe-spectrogram" })
], IndicatorComponent.prototype, "spectrogram", 2);
__decorateClass$9([
  e$6("#wrapped-element")
], IndicatorComponent.prototype, "wrappedElement", 2);
IndicatorComponent = __decorateClass$9([
  t$4("oe-indicator")
], IndicatorComponent);
var DecisionOptions = /* @__PURE__ */ ((C) => (C.FALSE = "false", C.TRUE = "true", C.UNSURE = "unsure", C.SKIP = "skip", C))(DecisionOptions || {});
class Decision {
  constructor(L, A, W) {
    this.confirmed = L, this.decisionId = A, this.tag = W ?? { text: "" };
  }
}
class Classification extends Decision {
  constructor(L, A, W) {
    super(L, A, W);
  }
}
class Verification extends Decision {
  constructor(L, A, W) {
    super(L, A, W);
  }
}
class SubjectWrapper {
  constructor(L, A, W) {
    this.clientCached = !1, this.serverCached = !1, this.decisions = /* @__PURE__ */ new Map(), this.subject = L, this.url = A, this.tag = W;
  }
  /** An array of all the decisions applied to a subject */
  get decisionModels() {
    return Array.from(this.decisions.values());
  }
  /** The singular verification decision that has been applied to a subject */
  get verification() {
    return this.decisions.get(this.tag.text);
  }
  /** Multiple classification decisions that have been applied to a subject */
  get classifications() {
    return this.decisionModels.filter((L) => L instanceof Classification);
  }
  /**
   * Adds a decision to the subject and removes any decisions that have been
   * made against the same tag.
   * Decisions that are made about the same tag are removed so that it is not
   * possible to have both a positive and negative decision about a tag
   */
  addDecision(L) {
    this.decisions.set(L.tag.text, L);
  }
  /** Removes a decision from the subject */
  removeDecision(L) {
    this.decisions.delete(L.tag.text);
  }
  /**
   * @description
   * Compares the subjects decisions to an array of required tags and
   * applies a skip decision to any required tags that do not have a decision
   * made about them
   *
   * @param {Boolean} requiresVerification
   * Looks at the subject model and applies a skip decision to the
   * verification task if none is applied
   *
   * @param {Array} requiredClassifications
   * Classifications that will be * applied as a skip decision if not present
   * on the subject
   */
  skipUndecided(L, A) {
    if (L && this.verification === void 0) {
      const J = new Verification(DecisionOptions.SKIP, -1, this.tag);
      this.addDecision(J);
    }
    for (const J of A) {
      if (this.classifications.some((oe) => oe.tag.text === J.text))
        continue;
      const te = new Classification(DecisionOptions.SKIP, -1, J);
      this.addDecision(te);
    }
  }
  /** Checks if the current subject has a decision */
  hasDecision(L) {
    const A = this.decisions.get(L.tag.text);
    return (A == null ? void 0 : A.decisionId) === L.decisionId;
  }
  /** Checks if the current subject has a tag applied */
  hasTag(L) {
    return this.decisions.has(L.text);
  }
  /** Checks if all tags in an array are present on a subject */
  hasTags(L) {
    return L.every((A) => this.hasTag(A));
  }
}
const SPLIT_LOWER_UPPER_RE = new RegExp("([\\p{Ll}\\d])(\\p{Lu})", "gu"), SPLIT_UPPER_UPPER_RE = new RegExp("(\\p{Lu})([\\p{Lu}][\\p{Ll}])", "gu"), SPLIT_SEPARATE_NUMBER_RE = new RegExp("(\\d)\\p{Ll}|(\\p{L})\\d", "u"), DEFAULT_STRIP_REGEXP = /[^\p{L}\d]+/giu, SPLIT_REPLACE_VALUE = "$1\0$2", DEFAULT_PREFIX_SUFFIX_CHARACTERS = "";
function split(C) {
  let L = C.trim();
  L = L.replace(SPLIT_LOWER_UPPER_RE, SPLIT_REPLACE_VALUE).replace(SPLIT_UPPER_UPPER_RE, SPLIT_REPLACE_VALUE), L = L.replace(DEFAULT_STRIP_REGEXP, "\0");
  let A = 0, W = L.length;
  for (; L.charAt(A) === "\0"; )
    A++;
  if (A === W)
    return [];
  for (; L.charAt(W - 1) === "\0"; )
    W--;
  return L.slice(A, W).split(/\0/g);
}
function splitSeparateNumbers(C) {
  const L = split(C);
  for (let A = 0; A < L.length; A++) {
    const W = L[A], X = SPLIT_SEPARATE_NUMBER_RE.exec(W);
    if (X) {
      const J = X.index + (X[1] ?? X[2]).length;
      L.splice(A, 1, W.slice(0, J), W.slice(J));
    }
  }
  return L;
}
function noCase(C, L) {
  const [A, W, X] = splitPrefixSuffix(C, L);
  return A + W.map(lowerFactory(L == null ? void 0 : L.locale)).join((L == null ? void 0 : L.delimiter) ?? " ") + X;
}
function camelCase(C, L) {
  const [A, W, X] = splitPrefixSuffix(C, L), J = lowerFactory(L == null ? void 0 : L.locale), te = upperFactory(L == null ? void 0 : L.locale), oe = L != null && L.mergeAmbiguousCharacters ? capitalCaseTransformFactory(J, te) : pascalCaseTransformFactory(J, te);
  return A + W.map((ne, re) => re === 0 ? J(ne) : oe(ne, re)).join((L == null ? void 0 : L.delimiter) ?? "") + X;
}
function pascalCase(C, L) {
  const [A, W, X] = splitPrefixSuffix(C, L), J = lowerFactory(L == null ? void 0 : L.locale), te = upperFactory(L == null ? void 0 : L.locale), oe = L != null && L.mergeAmbiguousCharacters ? capitalCaseTransformFactory(J, te) : pascalCaseTransformFactory(J, te);
  return A + W.map(oe).join((L == null ? void 0 : L.delimiter) ?? "") + X;
}
function dotCase(C, L) {
  return noCase(C, { delimiter: ".", ...L });
}
function kebabCase(C, L) {
  return noCase(C, { delimiter: "-", ...L });
}
function sentenceCase(C, L) {
  const [A, W, X] = splitPrefixSuffix(C, L), J = lowerFactory(L == null ? void 0 : L.locale), te = upperFactory(L == null ? void 0 : L.locale), oe = capitalCaseTransformFactory(J, te);
  return A + W.map((ne, re) => re === 0 ? oe(ne) : J(ne)).join((L == null ? void 0 : L.delimiter) ?? " ") + X;
}
function snakeCase(C, L) {
  return noCase(C, { delimiter: "_", ...L });
}
function lowerFactory(C) {
  return C === !1 ? (L) => L.toLowerCase() : (L) => L.toLocaleLowerCase(C);
}
function upperFactory(C) {
  return C === !1 ? (L) => L.toUpperCase() : (L) => L.toLocaleUpperCase(C);
}
function capitalCaseTransformFactory(C, L) {
  return (A) => `${L(A[0])}${C(A.slice(1))}`;
}
function pascalCaseTransformFactory(C, L) {
  return (A, W) => {
    const X = A[0];
    return (W > 0 && X >= "0" && X <= "9" ? "_" + X : L(X)) + C(A.slice(1));
  };
}
function splitPrefixSuffix(C, L = {}) {
  const A = L.split ?? (L.separateNumbers ? splitSeparateNumbers : split), W = L.prefixCharacters ?? DEFAULT_PREFIX_SUFFIX_CHARACTERS, X = L.suffixCharacters ?? DEFAULT_PREFIX_SUFFIX_CHARACTERS;
  let J = 0, te = C.length;
  for (; J < C.length; ) {
    const oe = C.charAt(J);
    if (!W.includes(oe))
      break;
    J++;
  }
  for (; te > J; ) {
    const oe = te - 1, ne = C.charAt(oe);
    if (!X.includes(ne))
      break;
    te = oe;
  }
  return [
    C.slice(0, J),
    A(C.slice(J, te)),
    C.slice(te)
  ];
}
const uppercaseTransformer = (C) => C.toUpperCase(), loweCaseTransformer = (C) => C.toLowerCase();
class ModelParser {
  constructor() {
  }
  // this function takes a model and a transformer
  // it searches through the values in the transformer and checks to see if the key exists in the model
  // if it does, then the models key is updated with the key from the transformer
  static deriveModel(L, A) {
    const W = {};
    for (const [X, J] of Object.entries(A))
      for (const te of J)
        L[te] && (W[X] = L[te]);
    return W;
  }
  static getKeyPermutations(L) {
    return [
      camelCase,
      snakeCase,
      dotCase,
      pascalCase,
      kebabCase,
      noCase,
      sentenceCase,
      uppercaseTransformer,
      loweCaseTransformer
    ].map((W) => W(L));
  }
  static keyTransformer(L) {
    return L.flatMap(ModelParser.getKeyPermutations);
  }
}
class SubjectParser extends ModelParser {
  static parse(L) {
    const A = {
      url: SubjectParser.keyTransformer(["src", "url", "audioLink"]),
      tag: SubjectParser.keyTransformer([
        // Common name formats
        "tags",
        "tag",
        "label",
        "classification",
        // Raven format
        "species",
        // BirdNet format
        "scientificName",
        "commonName",
        // Ecosounds annotation download formats
        "commonNameTags",
        "speciesNameTags"
      ])
    }, W = SubjectParser.deriveModel(L, A), X = W.url ?? "", J = W.tag ?? { text: "" };
    return new SubjectWrapper(L, X, J);
  }
}
class GridPageFetcher {
  constructor(L) {
    this.subjectQueueBuffer = [], this.pagingContext = {}, this.clientCacheLength = 10, this.serverCacheLength = 50, this.pagingCallback = L, this.converter = SubjectParser;
  }
  /**
   * Removes the next n requestedItems from the queue
   * If this method is called in a predictable manner, it can perform some
   * caching operations to improve performance
   */
  async getItems(L) {
    const A = Math.max(this.clientCacheLength, this.serverCacheLength, L);
    for (; this.subjectQueueBuffer.length < A && (await this.fetchNextPage()).length !== 0; )
      ;
    return this.audioCacheClient(), this.audioCacheServer(), this.subjectQueueBuffer.splice(0, L);
  }
  // during client caching, we do a GET request to the server for the
  // audio file. Therefore, requests that have already been client cached
  // have also already been server cached. We therefore, remove these
  // requests from the calculations
  async audioCacheClient() {
    const L = this.subjectQueueBuffer.slice(0, this.clientCacheLength).filter((A) => !A.clientCached);
    for (const A of L)
      A.clientCached = !0, fetch(A.url);
  }
  // during server caching, we do a HEAD request to the server for the
  // audio file. We do this because some servers have to split a large
  // audio file using ffmpeg when a file is requested.
  // by doing a HEAD request, we can warm the ffmpeg split file on the server
  async audioCacheServer() {
    const L = this.subjectQueueBuffer.slice(0, this.serverCacheLength).filter((A) => !A.serverCached);
    for (const A of L)
      A.serverCached = !0, fetch(A.url, { method: "HEAD" });
  }
  // because we must support iterable callbacks, we must behave as if the
  // user supplied callback can only be called once per page
  // therefore, we add all rows that we have fetched (even during caching)
  // to a buffer that we can pull from when requesting results for the same
  // page
  async fetchNextPage() {
    const { subjects: L, context: A } = await this.pagingCallback(this.pagingContext), W = L.map(this.converter.parse);
    return this.pagingContext = A, this.subjectQueueBuffer.push(...W), W;
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const Jt = (C, L, A) => {
  const W = /* @__PURE__ */ new Map();
  for (let X = L; X <= A; X++) W.set(C[X], X);
  return W;
}, Qt = e$4(class extends i$3 {
  constructor(C) {
    if (super(C), C.type !== t$2.CHILD) throw Error("repeat() can only be used in text expressions");
  }
  dt(C, L, A) {
    let W;
    A === void 0 ? A = L : L !== void 0 && (W = L);
    const X = [], J = [];
    let te = 0;
    for (const oe of C) X[te] = W ? W(oe, te) : te, J[te] = A(oe, te), te++;
    return { values: J, keys: X };
  }
  render(C, L, A) {
    return this.dt(C, L, A).values;
  }
  update(C, [L, A, W]) {
    const X = ut(C), { values: J, keys: te } = this.dt(L, A, W);
    if (!Array.isArray(X)) return this.ut = te, J;
    const oe = this.ut ?? (this.ut = []), ne = [];
    let re, ce, ue = 0, de = X.length - 1, be = 0, pe = J.length - 1;
    for (; ue <= de && be <= pe; ) if (X[ue] === null) ue++;
    else if (X[de] === null) de--;
    else if (oe[ue] === te[be]) ne[be] = ct(X[ue], J[be]), ue++, be++;
    else if (oe[de] === te[pe]) ne[pe] = ct(X[de], J[pe]), de--, pe--;
    else if (oe[ue] === te[pe]) ne[pe] = ct(X[ue], J[pe]), at(C, ne[pe + 1], X[ue]), ue++, pe--;
    else if (oe[de] === te[be]) ne[be] = ct(X[de], J[be]), at(C, X[ue], X[de]), de--, be++;
    else if (re === void 0 && (re = Jt(te, be, pe), ce = Jt(oe, ue, de)), re.has(oe[ue])) if (re.has(oe[de])) {
      const me = ce.get(te[be]), Me = me !== void 0 ? X[me] : null;
      if (Me === null) {
        const he = at(C, X[ue]);
        ct(he, J[be]), ne[be] = he;
      } else ne[be] = ct(Me, J[be]), at(C, X[ue], Me), X[me] = null;
      be++;
    } else pt(X[de]), de--;
    else pt(X[ue]), ue++;
    for (; be <= pe; ) {
      const me = at(C, ne[pe + 1]);
      ct(me, J[be]), ne[be++] = me;
    }
    for (; ue <= de; ) {
      const me = X[ue++];
      me !== null && pt(me);
    }
    return this.ut = te, dt(C, ne), R$1;
  }
}), verificationGridStyles = "#highlight-box{position:absolute;display:none;top:0;left:0;width:0px;height:0px;background-color:var(--oe-selected-color);border:solid 2px var(--oe-border-color);border-radius:var(--oe-border-rounding);opacity:.3;z-index:5;pointer-events:none}.statistics-section{position:relative;display:inline-block;width:-moz-fit-content;width:fit-content;padding:var(--oe-spacing)}.verification-container{background-color:var(--oe-background-color);height:100%}.verification-grid{display:flex;flex-wrap:wrap;flex-grow:1;-webkit-user-select:none;-moz-user-select:none;user-select:none;justify-content:center;align-items:stretch;padding-top:var(--oe-spacing);padding-bottom:var(--oe-spacing);gap:var(--oe-spacing)}.no-items-message{font-size:1.2rem}.verification-controls-title{text-align:center;font-family:sans-serif;font-weight:400;font-size:1.4rem;letter-spacing:0em;color:var(--oe-font-color)}.verification-controls{display:flex;flex-wrap:wrap;justify-content:space-around;align-items:end;padding:var(--oe-spacing);gap:var(--oe-spacing);color:var(--oe-font-color)}.decision-controls h2{display:block}.decision-controls .decision-control-actions{display:flex;flex-wrap:wrap;justify-content:center}.decision-controls-left,.decision-controls-right{display:flex}.no-decisions-warning{color:var(--oe-danger-color);font-weight:700}@media (max-width: 600px){oe-spectrogram{height:380px}}";
var __defProp$8 = Object.defineProperty, __getOwnPropDesc$8 = Object.getOwnPropertyDescriptor, __decorateClass$8 = (C, L, A, W) => {
  for (var X = W > 1 ? void 0 : W ? __getOwnPropDesc$8(L, A) : L, J = C.length - 1, te; J >= 0; J--)
    (te = C[J]) && (X = (W ? te(L, A, X) : te(X)) || X);
  return W && X && __defProp$8(L, A, X), X;
};
const verificationGridContext = Symbol("verification-grid-context");
let VerificationGridComponent = class extends AbstractComponent(h$1) {
  constructor() {
    super(...arguments), this.settings = {
      axes: d(!0),
      indicator: d(!0),
      mediaControls: d(!0)
    }, this.gridSize = 8, this.selectionBehavior = "default", this.historyHead = 0, this.currentSubSelection = [], this.currentPage = [], this.keydownHandler = this.handleKeyDown.bind(this), this.keyupHandler = this.handleKeyUp.bind(this), this.blurHandler = this.handleWindowBlur.bind(this), this.intersectionHandler = this.handleIntersection.bind(this), this.selectionHandler = this.handleSelection.bind(this), this.decisionHandler = this.handleDecision.bind(this), this.intersectionObserver = new IntersectionObserver(this.intersectionHandler), this.subjectHistory = [], this.hiddenTiles = 0, this.decisionsDisabled = !1, this.showingSelectionShortcuts = !1, this.selectionHead = null, this.doneRenderBoxInit = !1, this.highlight = {
      start: { x: 0, y: 0 },
      current: { x: 0, y: 0 },
      highlighting: !1,
      elements: []
    };
  }
  get pagedItems() {
    return this.subjectHistory.length;
  }
  /**
   * A derived selector for all oe-decision, oe-verification
   * and oe-classification elements
   */
  get decisionElements() {
    return [...this.verificationDecisionElements, ...this.classificationDecisionElements];
  }
  /** A count of the number of tiles currently visible on the screen */
  get effectivePageSize() {
    return this.gridSize - this.hiddenTiles;
  }
  connectedCallback() {
    super.connectedCallback(), document.addEventListener("keydown", this.keydownHandler), document.addEventListener("keyup", this.keyupHandler), window.addEventListener("blur", this.blurHandler);
  }
  disconnectedCallback() {
    this.intersectionObserver.disconnect(), document.removeEventListener("keydown", this.keydownHandler), document.removeEventListener("keyup", this.keyupHandler), window.removeEventListener("blur", this.blurHandler), this.gridContainer.removeEventListener("selected", this.selectionHandler), this.decisionsContainer.removeEventListener("decision", this.decisionHandler), super.disconnectedCallback();
  }
  isViewingHistory() {
    return this.historyHead !== 0;
  }
  resetSpectrogramSettings() {
    for (const C of this.gridTiles)
      C.resetSettings();
  }
  isHelpDialogOpen() {
    return this.helpDialog.open;
  }
  // to use regions in VSCode, press Ctrl + Shift + P > "Fold"/"Unfold"
  //#region Updates
  firstUpdated() {
    this.gridContainer.addEventListener("selected", this.selectionHandler), this.decisionsContainer.addEventListener("decision", this.decisionHandler);
  }
  willUpdate(C) {
    if (C.has("gridSize")) {
      const L = C.get("gridSize"), A = this.gridSize;
      (!isFinite(A) || A <= 0) && (this.gridSize = L, console.error("New grid size value could not be converted to a number"));
    }
  }
  async updated(C) {
    const L = ["selectionBehavior"], A = ["getPage", "gridSize"];
    L.some((W) => C.has(W)) && this.handleTileInvalidation(), A.some((W) => C.has(W)) && await this.handleSourceInvalidation();
  }
  handleTileInvalidation() {
    let C = this.selectionBehavior;
    C === "default" && (C = this.isMobileDevice() ? "tablet" : "desktop");
    const L = this.decisionElements ?? [];
    for (const A of L)
      A.selectionMode = C;
    this.helpDialog.selectionBehavior = C, this.helpDialog.decisionElements = L, this.removeSubSelection();
  }
  async handleSourceInvalidation() {
    this.isViewingHistory() || this.verificationMode(), this.subjectHistory = [], this.getPage && (this.paginationFetcher = new GridPageFetcher(this.getPage), this.currentPage = await this.paginationFetcher.getItems(this.gridSize), await this.renderCurrentPage());
    const C = this.decisionElements;
    C && C.forEach((L, A) => {
      L.decisionId = A;
    });
  }
  //#endregion
  //#region EventHandlers
  handleKeyDown(C) {
    if (C.altKey) {
      this.showingSelectionShortcuts || this.showSelectionShortcuts();
      return;
    }
    switch (C.key) {
      case ESCAPE_KEY: {
        this.removeSubSelection();
        break;
      }
      case LEFT_ARROW_KEY: {
        C.preventDefault(), this.handlePreviousPageClick();
        break;
      }
      case RIGHT_ARROW_KEY: {
        C.preventDefault(), this.handleNextPageClick();
        break;
      }
      case "d": {
        C.ctrlKey && (C.preventDefault(), this.removeSubSelection());
        break;
      }
      case "a": {
        C.ctrlKey && C.preventDefault(), this.subSelectAll();
        break;
      }
      case "?": {
        this.helpDialog.showModal(!1);
        break;
      }
    }
  }
  handleKeyUp(C) {
    if (C.altKey) {
      C.preventDefault();
      return;
    }
    this.showingSelectionShortcuts && this.hideSelectionShortcuts();
  }
  // some keys add additional information to the screen
  // e.g. pressing Alt will show the selection keyboard shortcuts
  //
  // however, the alt key can also be used to switch virtual desktops in Windows
  // because of this, if the user switches virtual desktops, we never receive
  // the keyup event that is usually used to hide the additional information
  // therefore, we listen for the window blur event so that when the window
  // loses focus, we hide the additional information
  handleWindowBlur() {
    this.hideSelectionShortcuts(), this.hideHighlightBox();
  }
  handleHelpDialogOpen() {
    this.gridContainer.removeEventListener("selected", this.selectionHandler), this.decisionsContainer.removeEventListener("decision", this.decisionHandler);
  }
  handleHelpDialogClose() {
    this.gridContainer.addEventListener("selected", this.selectionHandler), this.decisionsContainer.addEventListener("decision", this.decisionHandler);
  }
  //#endregion
  //#region SelectionHandlers
  tileSelectionShortcutsShown(C) {
    const L = this.gridTiles;
    for (const A of L)
      A.showKeyboardShortcuts = C;
  }
  // showing and hiding selection shortcuts are two different functions to
  // follow defensive programming principles. So that if showing the selection
  // shortcuts fails, the grids internal state representation is not update if
  // we fail to hide all (but is set if we fail to show all)
  showSelectionShortcuts() {
    this.canSubSelect() && (this.showingSelectionShortcuts = !0, this.tileSelectionShortcutsShown(!0));
  }
  hideSelectionShortcuts() {
    this.tileSelectionShortcutsShown(!1), this.showingSelectionShortcuts = !1;
  }
  // TODO: The intersection observer has been disabled because its functionality
  // is buggy when the verification grid is larger than the screen size
  // see: https://github.com/ecoacoustics/web-components/issues/146
  // see: https://github.com/ecoacoustics/web-components/issues/147
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  handleIntersection(C) {
  }
  handleSelection(C) {
    if (this.canSubSelect()) {
      switch (this.selectionBehavior) {
        case "default":
          this.handleDefaultSelection(C);
          break;
        case "desktop":
          this.handleDesktopSelection(C);
          break;
        case "tablet":
          this.handleTabletSelection(C);
          break;
        default:
          console.error(`could not find selection behavior ${this.selectionBehavior}`), this.handleDesktopSelection(C);
          break;
      }
      this.updateSubSelection();
    }
  }
  // TODO: this should be refactored out to a getter. The getter should return
  // tablet or desktop based on the device type when default is being used
  /**
   * @description
   * The default selection handler will infer the device type and
   * the selection behavior will be set to "tablet", otherwise it will be set
   * to "desktop"
   */
  handleDefaultSelection(C) {
    this.isMobileDevice() ? this.handleTabletSelection(C) : this.handleDesktopSelection(C);
  }
  /**
   * @description
   * Click                  Select a single tile (de-selecting any other items)
   * Shift + click          Select a range of tiles (de-selecting any other items)
   * Ctrl + click           Toggles the selection state of a single tile (not effecting other tiles)
   * Ctrl + Shift + click   Select a range of tiles (not effecting other tiles)
   */
  handleDesktopSelection(C) {
    if (this.selectionBehavior === "tablet")
      throw new Error("Attempted desktop selection when explicit tablet selection is specified");
    const L = C.detail.index;
    if (C.detail.ctrlKey || this.removeSubSelection(), C.detail.shiftKey) {
      this.selectionHead ?? (this.selectionHead = L);
      const A = L;
      this.addSubSelectionRange(this.selectionHead, A);
      return;
    }
    this.toggleTileSelection(L), this.selectionHead = L;
  }
  handleTabletSelection(C) {
    this.toggleTileSelection(C.detail.index);
  }
  toggleTileSelection(C) {
    const L = this.gridTiles;
    L[C].selected = !L[C].selected;
  }
  addSubSelectionRange(C, L) {
    L < C && ([C, L] = [L, C]);
    const A = this.gridTiles;
    for (let W = C; W <= L; W++)
      A[W].selected = !0;
  }
  subSelectAll() {
    if (!this.canSubSelect())
      return;
    const C = this.gridTiles;
    for (const L of C)
      L.selected = !0;
    this.updateSubSelection();
  }
  removeSubSelection() {
    const C = this.gridTiles;
    for (const L of C)
      L.selected = !1;
    this.updateSubSelection();
  }
  canSubSelect() {
    return this.gridSize > 1 && !this.isHelpDialogOpen();
  }
  isMobileDevice() {
    if (navigator.userAgentData)
      return navigator.userAgentData.mobile;
    throw new Error("Could not determine if the device is a touch device");
  }
  updateSubSelection() {
    const C = Array.from(this.gridTiles);
    this.currentSubSelection = C.filter((L) => L.selected).map((L) => L.model);
  }
  //#endregion
  // TODO: The selection bounding box isn't currently complete
  //#region SelectionBoundingBox
  // TODO: Clean this up
  renderHighlightBox(C) {
    if (!(!this.canSubSelect() || this.isMobileDevice()) && C.isPrimary) {
      if (this.highlight.highlighting = !0, !this.shadowRoot)
        return;
      const L = this.shadowRoot.getElementById("highlight-box");
      if (!L)
        return;
      this.doneRenderBoxInit || (this.gridTiles.forEach((A) => {
        this.highlight.elements.push({
          position: A.getBoundingClientRect(),
          element: A
        });
      }), this.doneRenderBoxInit = !0), L.style.display = "block", L.style.left = `${C.pageX}px`, L.style.top = `${C.pageY}px`, this.highlight.start = { x: C.pageX, y: C.pageY };
    }
  }
  resizeHighlightBox(C) {
    if (!this.highlight.highlighting || !this.shadowRoot)
      return;
    const L = this.shadowRoot.getElementById("highlight-box");
    if (!L)
      return;
    const { pageX: A, pageY: W } = C;
    this.highlight.current = { x: A, y: W };
    const X = this.highlight.current.x - this.highlight.start.x, J = this.highlight.current.y - this.highlight.start.y;
    L.style.width = `${Math.abs(X)}px`, L.style.height = `${Math.abs(J)}px`, X < 0 && (L.style.left = `${A}px`), J < 0 && (L.style.top = `${W}px`), this.calculateHighlightIntersection();
  }
  calculateHighlightIntersection() {
    const C = Math.min(this.highlight.start.x, this.highlight.current.x), L = Math.max(this.highlight.start.x, this.highlight.current.x), A = Math.min(this.highlight.start.y, this.highlight.current.y), W = Math.max(this.highlight.start.y, this.highlight.current.y);
    for (const X of this.highlight.elements) {
      const { top: J, bottom: te, left: oe, right: ne } = X.position, re = X.element;
      oe <= L && ne >= C && J <= W && te >= A ? re.selected = !0 : re.selected = !1;
    }
    this.updateSubSelection();
  }
  hideHighlightBox() {
    if (!this.shadowRoot || this.isMobileDevice())
      return;
    this.highlight.highlighting = !1;
    const C = this.shadowRoot.getElementById("highlight-box");
    C && (console.log("stop highlight"), C.style.width = "0px", C.style.height = "0px", C.style.top = "0px", C.style.left = "0px", C.style.display = "none");
  }
  //#endregion
  //#region Navigation
  handlePreviousPageClick() {
    this.canNavigatePrevious() && (this.historyHead += this.gridSize, this.renderHistory(this.historyHead));
  }
  handleNextPageClick() {
    this.isViewingHistory() && this.pageForwardHistory();
  }
  pageForwardHistory() {
    this.canNavigateNext() && (this.historyHead -= this.gridSize, this.renderHistory(this.historyHead));
  }
  renderHistory(C) {
    const L = Math.max(0, this.subjectHistory.length - C), A = Math.min(this.subjectHistory.length, L + this.gridSize), W = this.subjectHistory.slice(L, A);
    this.renderVirtualPage(W), this.historyMode();
  }
  /**
   * @description
   * Change the verification grid to the "history mode" layout
   * Note: Changing to "History Mode" does not render the history. It is only
   *       responsible for changing the layout of the verification grid.
   */
  historyMode() {
    if (this.subjectHistory.length === 0)
      throw new Error("No decisions to show in history");
    (!this.gridTiles || this.gridTiles.length === 0) && this.performUpdate();
    const C = this.pageTouchedDecisionElements();
    this.removeDecisionButtonHighlight(), this.showDecisionButtonHighlight(C);
  }
  /**
   * @description
   * Change the verification grid to the "normal mode" layout
   * Note: Changing to "Verification Mode" does not stop rendering history
   *       responsible for changing the layout of the verification grid.
   */
  verificationMode() {
    this.removeSubSelection(), this.removeDecisionButtonHighlight(), this.historyHead = 0;
  }
  /**
   * @description
   * Changes to the "verification mode" and renders the
   */
  resumeVerification() {
    this.renderCurrentPage(), this.verificationMode();
  }
  // we ue the effective grid size here so that hidden tiles are not counted
  // when the user pages
  async nextPage(C = this.effectivePageSize) {
    if (this.removeSubSelection(), this.resetSpectrogramSettings(), this.removeDecisionButtonHighlight(), !this.paginationFetcher)
      throw new Error("No paginator found.");
    this.subjectHistory.push(...this.currentPage), this.currentPage = await this.paginationFetcher.getItems(C), this.renderVirtualPage(this.currentPage);
  }
  canNavigatePrevious() {
    const C = this.pagedItems > 0, L = this.historyHead < this.subjectHistory.length;
    return C && L;
  }
  canNavigateNext() {
    return this.historyHead > this.gridSize;
  }
  //#endregion
  //#region Decisions
  async handleDecision(C) {
    if (this.isHelpDialogOpen())
      return;
    const L = C.detail.value, A = Array.from(this.gridTiles), W = A.filter((re) => re.selected), oe = (W.length > 0 ? W : A).filter((re) => !re.hidden).map(
      (re) => [re, L]
    );
    for (const [re, ce] of oe)
      for (const ue of ce)
        ue instanceof Verification && (ue.tag = re.model.tag), re.model.hasDecision(ue) ? re.removeDecision(ue) : re.addDecision(ue);
    this.dispatchEvent(new CustomEvent(VerificationGridComponent.decisionMadeEventName, { detail: oe }));
    const ne = this.pageTouchedDecisionElements();
    this.removeDecisionButtonHighlight(), this.showDecisionButtonHighlight(ne), this.shouldAutoPage() && (await sleep(0.3), this.nextPage());
  }
  // TODO: finish this function
  shouldAutoPage() {
    return !this.isViewingHistory() && !this.hasOutstandingVerification() && !this.hasOutstandingClassification();
  }
  requiredTags() {
    return this.classificationDecisionElements.map((C) => C.tag).filter(
      (C, L, A) => A.indexOf(C) === L && A.findIndex((W) => W.text === C.text) === L
    );
  }
  // for verification tasks, the user will be adding one verification decision
  // to each grid tile. Therefore, we can test that there is some sort of
  // verifications applied to every tile
  hasOutstandingVerification() {
    if (!this.hasVerificationTask())
      return !1;
    const C = this.gridTiles;
    for (const L of C)
      if (!(L.model.verification !== void 0))
        return !0;
    return !1;
  }
  // during a classification task, we want to ensure that every tile has a
  // decision about every tag (not classification decision)
  // we don't check against classification decisions because we want to support
  // adding "negative" classifications against a tile
  hasOutstandingClassification() {
    if (!this.hasClassificationTask())
      return !1;
    const C = this.classificationDecisionElements.map(
      (A) => A.tag
    );
    return !Array.from(this.gridTiles).every((A) => A.model.hasTags(C));
  }
  setDecisionDisabled(C) {
    const L = this.decisionElements ?? [];
    for (const A of L)
      A.disabled = C;
    this.decisionsDisabled = C, this.skipButton.disabled = C;
  }
  //#endregion
  //#region DecisionHighlights
  /**
   * Returns an array of references to all decision elements that have been used
   * on the current page of spectrograms
   */
  pageTouchedDecisionElements() {
    const C = this.currentPage.flatMap((L) => L.decisionModels.map((A) => A.decisionId));
    return this.decisionElements.filter((L) => C.includes(L.decisionId));
  }
  showDecisionButtonHighlight(C) {
    for (const L of C)
      L.highlighted = !0;
  }
  removeDecisionButtonHighlight() {
    const C = this.decisionElements ?? [];
    for (const L of C)
      L.highlighted = !1;
  }
  //#endregion
  //#region Rendering
  async renderCurrentPage() {
    if (!this.paginationFetcher)
      throw new Error("Pagination fetcher not found");
    this.renderVirtualPage(this.currentPage);
  }
  async renderVirtualPage(C) {
    const L = this.gridTiles;
    if (L === void 0 || L.length === 0)
      throw new Error("Could not find instantiated spectrogram elements");
    if (this.setDecisionDisabled(!0), C.length === 0)
      return;
    this.currentPage = C;
    const A = L.length - C.length;
    A > 0 ? this.hideGridItems(A) : this.hiddenTiles > 0 && (this.showAllGridItems(), this.hiddenTiles = 0);
  }
  hideGridItems(C) {
    Array.from(this.gridTiles).slice(-C).forEach((L) => {
      L.hidden = !0;
    }), this.hiddenTiles = C;
  }
  showAllGridItems() {
    const C = this.gridTiles ?? [];
    for (const L of C)
      L.hidden = !1;
  }
  hasDecisionElements() {
    return Array.from(this.decisionElements ?? []).length > 0;
  }
  areSpectrogramsLoaded() {
    return !Array.from(this.gridTiles).some((L) => !L.loaded);
  }
  handleSpectrogramLoaded() {
    const C = this.decisionsDisabled, L = !this.areSpectrogramsLoaded();
    C !== L && this.setDecisionDisabled(L), L || this.dispatchEvent(new CustomEvent(VerificationGridComponent.loadedEventName));
  }
  //#endregion
  //#region Prompts
  hasClassificationTask() {
    return this.classificationDecisionElements.length > 0;
  }
  hasVerificationTask() {
    return this.verificationDecisionElements.length > 0;
  }
  mixedTaskPromptTemplate(C, L) {
    return L ? ke$1`<p>Make a decision about all of the selected audio segments</p>` : C ? ke$1`<p>Make a decision about all of the audio segments</p>` : ke$1`<p>Make a decision about the shown audio segment</p>`;
  }
  classificationTaskPromptTemplate(C, L) {
    return L ? ke$1`<p>Apply labels to selected audio segments</p>` : C ? ke$1`<p>Classify all relevant audio segments</p>` : ke$1`<p>Apply a classification to the audio segment</p>`;
  }
  verificationTaskPromptTemplate(C, L) {
    return L ? ke$1`<p>Do all of the selected audio segments have the correct applied tag</p>` : C ? ke$1`<p>Do all of the audio segments have the correct applied tag</p>` : ke$1`<p>Does the show audio segment have the correct applied tag</p>`;
  }
  decisionPromptTemplate() {
    const L = this.currentSubSelection.length > 0, A = this.gridSize > 1;
    return this.hasClassificationTask() && this.hasVerificationTask() ? this.mixedTaskPromptTemplate(A, L) : this.hasClassificationTask() ? this.classificationTaskPromptTemplate(A, L) : this.hasVerificationTask() ? this.verificationTaskPromptTemplate(A, L) : L ? ke$1`<p>Are all of the selected a</p>` : ke$1`<p>${A ? "Are all of these a" : "Is the shown spectrogram a"}</p>`;
  }
  //#endregion
  //#region Templates
  statisticsTemplate() {
    return ke$1`
      <div class="statistics-section">
        <h2>Statistics</h2>
        <p><span>Validated Items</span>: ${this.subjectHistory.length}</p>
      </div>
    `;
  }
  // private noItemsTemplate(): TemplateResult<1> {
  //   return html`
  //     <div class="no-items-message">
  //       <p>
  //         <strong>No un-validated results found</strong>
  //       </p>
  //       <p>All ${this.pagedItems} annotations are validated</p>
  //     </div>
  //   `;
  // }
  noDecisionsTemplate() {
    return ke$1` <strong class="no-decisions-warning"> No decisions available. </strong> `;
  }
  // TODO: this function could definitely be refactored
  doneDecisionTemplate() {
    return ke$1`
      <oe-decision
        id="skip-button"
        @decision="${(L) => {
      L.stopPropagation();
      const A = this.requiredTags(), W = this.hasVerificationTask(), X = this.gridTiles;
      for (const J of X)
        J.model.skipUndecided(W, A);
      this.nextPage();
    }}"
        verified="SKIP"
        shortcut="\`"
        .highlighted="${this.isViewingHistory()}"
      >
        Skip
      </oe-decision>
    `;
  }
  render() {
    let C = D;
    return this.gridItemTemplate && (C = this.gridItemTemplate.cloneNode(!0)), ke$1`
      <oe-verification-help-dialog
        @open="${this.handleHelpDialogOpen}"
        @close="${this.handleHelpDialogClose}"
        verificationTasksCount="${this.hasVerificationTask() ? 1 : 0}"
        classificationTasksCount="${this.requiredTags().length}"
      ></oe-verification-help-dialog>
      <div id="highlight-box" @mouseup="${this.hideHighlightBox}" @mousemove="${this.resizeHighlightBox}"></div>

      <div class="verification-container">
        <div
          id="grid-container"
          @pointerdown="${this.renderHighlightBox}"
          @pointerup="${this.hideHighlightBox}"
          @pointermove="${this.resizeHighlightBox}"
          class="verification-grid"
        >
          ${Qt(
      this.currentPage,
      (L, A) => ke$1`
              <oe-verification-grid-tile
                @loaded="${this.handleSpectrogramLoaded}"
                .requiredTags="${this.requiredTags()}"
                .model="${L}"
                .index="${A}"
              >
                ${C}
              </oe-verification-grid-tile>
            `
    )}
        </div>

        <div class="verification-controls">
          <span class="decision-controls-left">
            <oe-verification-grid-settings></oe-verification-grid-settings>

            <button
              data-testid="help-dialog-button"
              @click="${() => this.helpDialog.showModal(!1)}"
              class="oe-btn-info"
              rel="help"
            >
              <sl-icon name="question-circle" class="large-icon"></sl-icon>
            </button>

            <button
              data-testid="previous-page-button"
              class="oe-btn oe-btn-secondary"
              ?disabled="${!this.canNavigatePrevious()}"
              @click="${this.handlePreviousPageClick}"
            >
              ${this.gridSize > 1 ? "Previous Page" : "Previous"}
            </button>

            <button
              data-testid="next-page-button"
              class="oe-btn-secondary"
              ?disabled="${!this.canNavigateNext()}"
              @click="${this.handleNextPageClick}"
            >
              ${this.gridSize > 1 ? "Next Page" : "Next"}
            </button>

            <button
              data-testid="continue-verifying-button"
              class="oe-btn-secondary ${Rt({ hidden: !this.isViewingHistory() })}"
              ?disabled="${!this.isViewingHistory()}"
              @click="${this.resumeVerification}"
            >
              Continue ${this.hasVerificationTask() ? "Verifying" : "Classifying"}
            </button>
          </span>

          <span class="decision-controls">
            <h2 class="verification-controls-title">
              ${this.hasDecisionElements() ? this.decisionPromptTemplate() : this.noDecisionsTemplate()}
            </h2>
            <div id="decisions-container" class="decision-control-actions">
              <slot></slot>

              ${this.doneDecisionTemplate()}
            </div>
          </span>

          <span class="decision-controls-right">
            <slot name="data-source"></slot>
          </span>
        </div>

        <div>${this.statisticsTemplate()}</div>
      </div>
    `;
  }
  //#endregion
};
VerificationGridComponent.styles = r$6(verificationGridStyles);
VerificationGridComponent.decisionMadeEventName = "decision-made";
VerificationGridComponent.loadedEventName = "loaded";
__decorateClass$8([
  e$2({ context: verificationGridContext }),
  n$1({ attribute: !1 })
], VerificationGridComponent.prototype, "settings", 2);
__decorateClass$8([
  n$1({ attribute: "grid-size", type: Number, reflect: !0 })
], VerificationGridComponent.prototype, "gridSize", 2);
__decorateClass$8([
  n$1({ attribute: "selection-behavior", type: String, reflect: !0 })
], VerificationGridComponent.prototype, "selectionBehavior", 2);
__decorateClass$8([
  n$1({ attribute: "get-page", type: Function, converter: callbackConverter })
], VerificationGridComponent.prototype, "getPage", 2);
__decorateClass$8([
  r$3()
], VerificationGridComponent.prototype, "historyHead", 2);
__decorateClass$8([
  o$2({ selector: "oe-verification" })
], VerificationGridComponent.prototype, "verificationDecisionElements", 2);
__decorateClass$8([
  o$2({ selector: "oe-classification" })
], VerificationGridComponent.prototype, "classificationDecisionElements", 2);
__decorateClass$8([
  queryDeeplyAssignedElement({ selector: "template" })
], VerificationGridComponent.prototype, "gridItemTemplate", 2);
__decorateClass$8([
  r$2("oe-verification-grid-tile")
], VerificationGridComponent.prototype, "gridTiles", 2);
__decorateClass$8([
  e$6("oe-verification-help-dialog")
], VerificationGridComponent.prototype, "helpDialog", 2);
__decorateClass$8([
  e$6("#grid-container")
], VerificationGridComponent.prototype, "gridContainer", 2);
__decorateClass$8([
  e$6("#decisions-container")
], VerificationGridComponent.prototype, "decisionsContainer", 2);
__decorateClass$8([
  e$6("#skip-button")
], VerificationGridComponent.prototype, "skipButton", 2);
__decorateClass$8([
  r$3()
], VerificationGridComponent.prototype, "currentSubSelection", 2);
__decorateClass$8([
  r$3()
], VerificationGridComponent.prototype, "currentPage", 2);
VerificationGridComponent = __decorateClass$8([
  t$4("oe-verification-grid")
], VerificationGridComponent);
var index = {
  schemeGroups: {
    sequential: ["BuGn", "BuPu", "GnBu", "OrRd", "PuBu", "PuBuGn", "PuRd", "RdPu", "YlGn", "YlGnBu", "YlOrBr", "YlOrRd"],
    singlehue: ["Blues", "Greens", "Greys", "Oranges", "Purples", "Reds"],
    diverging: ["BrBG", "PiYG", "PRGn", "PuOr", "RdBu", "RdGy", "RdYlBu", "RdYlGn", "Spectral"],
    qualitative: ["Accent", "Dark2", "Paired", "Pastel1", "Pastel2", "Set1", "Set2", "Set3"]
  },
  YlGn: {
    3: ["#f7fcb9", "#addd8e", "#31a354"],
    4: ["#ffffcc", "#c2e699", "#78c679", "#238443"],
    5: ["#ffffcc", "#c2e699", "#78c679", "#31a354", "#006837"],
    6: ["#ffffcc", "#d9f0a3", "#addd8e", "#78c679", "#31a354", "#006837"],
    7: ["#ffffcc", "#d9f0a3", "#addd8e", "#78c679", "#41ab5d", "#238443", "#005a32"],
    8: ["#ffffe5", "#f7fcb9", "#d9f0a3", "#addd8e", "#78c679", "#41ab5d", "#238443", "#005a32"],
    9: ["#ffffe5", "#f7fcb9", "#d9f0a3", "#addd8e", "#78c679", "#41ab5d", "#238443", "#006837", "#004529"]
  },
  YlGnBu: {
    3: ["#edf8b1", "#7fcdbb", "#2c7fb8"],
    4: ["#ffffcc", "#a1dab4", "#41b6c4", "#225ea8"],
    5: ["#ffffcc", "#a1dab4", "#41b6c4", "#2c7fb8", "#253494"],
    6: ["#ffffcc", "#c7e9b4", "#7fcdbb", "#41b6c4", "#2c7fb8", "#253494"],
    7: ["#ffffcc", "#c7e9b4", "#7fcdbb", "#41b6c4", "#1d91c0", "#225ea8", "#0c2c84"],
    8: ["#ffffd9", "#edf8b1", "#c7e9b4", "#7fcdbb", "#41b6c4", "#1d91c0", "#225ea8", "#0c2c84"],
    9: ["#ffffd9", "#edf8b1", "#c7e9b4", "#7fcdbb", "#41b6c4", "#1d91c0", "#225ea8", "#253494", "#081d58"]
  },
  GnBu: {
    3: ["#e0f3db", "#a8ddb5", "#43a2ca"],
    4: ["#f0f9e8", "#bae4bc", "#7bccc4", "#2b8cbe"],
    5: ["#f0f9e8", "#bae4bc", "#7bccc4", "#43a2ca", "#0868ac"],
    6: ["#f0f9e8", "#ccebc5", "#a8ddb5", "#7bccc4", "#43a2ca", "#0868ac"],
    7: ["#f0f9e8", "#ccebc5", "#a8ddb5", "#7bccc4", "#4eb3d3", "#2b8cbe", "#08589e"],
    8: ["#f7fcf0", "#e0f3db", "#ccebc5", "#a8ddb5", "#7bccc4", "#4eb3d3", "#2b8cbe", "#08589e"],
    9: ["#f7fcf0", "#e0f3db", "#ccebc5", "#a8ddb5", "#7bccc4", "#4eb3d3", "#2b8cbe", "#0868ac", "#084081"]
  },
  BuGn: {
    3: ["#e5f5f9", "#99d8c9", "#2ca25f"],
    4: ["#edf8fb", "#b2e2e2", "#66c2a4", "#238b45"],
    5: ["#edf8fb", "#b2e2e2", "#66c2a4", "#2ca25f", "#006d2c"],
    6: ["#edf8fb", "#ccece6", "#99d8c9", "#66c2a4", "#2ca25f", "#006d2c"],
    7: ["#edf8fb", "#ccece6", "#99d8c9", "#66c2a4", "#41ae76", "#238b45", "#005824"],
    8: ["#f7fcfd", "#e5f5f9", "#ccece6", "#99d8c9", "#66c2a4", "#41ae76", "#238b45", "#005824"],
    9: ["#f7fcfd", "#e5f5f9", "#ccece6", "#99d8c9", "#66c2a4", "#41ae76", "#238b45", "#006d2c", "#00441b"]
  },
  PuBuGn: {
    3: ["#ece2f0", "#a6bddb", "#1c9099"],
    4: ["#f6eff7", "#bdc9e1", "#67a9cf", "#02818a"],
    5: ["#f6eff7", "#bdc9e1", "#67a9cf", "#1c9099", "#016c59"],
    6: ["#f6eff7", "#d0d1e6", "#a6bddb", "#67a9cf", "#1c9099", "#016c59"],
    7: ["#f6eff7", "#d0d1e6", "#a6bddb", "#67a9cf", "#3690c0", "#02818a", "#016450"],
    8: ["#fff7fb", "#ece2f0", "#d0d1e6", "#a6bddb", "#67a9cf", "#3690c0", "#02818a", "#016450"],
    9: ["#fff7fb", "#ece2f0", "#d0d1e6", "#a6bddb", "#67a9cf", "#3690c0", "#02818a", "#016c59", "#014636"]
  },
  PuBu: {
    3: ["#ece7f2", "#a6bddb", "#2b8cbe"],
    4: ["#f1eef6", "#bdc9e1", "#74a9cf", "#0570b0"],
    5: ["#f1eef6", "#bdc9e1", "#74a9cf", "#2b8cbe", "#045a8d"],
    6: ["#f1eef6", "#d0d1e6", "#a6bddb", "#74a9cf", "#2b8cbe", "#045a8d"],
    7: ["#f1eef6", "#d0d1e6", "#a6bddb", "#74a9cf", "#3690c0", "#0570b0", "#034e7b"],
    8: ["#fff7fb", "#ece7f2", "#d0d1e6", "#a6bddb", "#74a9cf", "#3690c0", "#0570b0", "#034e7b"],
    9: ["#fff7fb", "#ece7f2", "#d0d1e6", "#a6bddb", "#74a9cf", "#3690c0", "#0570b0", "#045a8d", "#023858"]
  },
  BuPu: {
    3: ["#e0ecf4", "#9ebcda", "#8856a7"],
    4: ["#edf8fb", "#b3cde3", "#8c96c6", "#88419d"],
    5: ["#edf8fb", "#b3cde3", "#8c96c6", "#8856a7", "#810f7c"],
    6: ["#edf8fb", "#bfd3e6", "#9ebcda", "#8c96c6", "#8856a7", "#810f7c"],
    7: ["#edf8fb", "#bfd3e6", "#9ebcda", "#8c96c6", "#8c6bb1", "#88419d", "#6e016b"],
    8: ["#f7fcfd", "#e0ecf4", "#bfd3e6", "#9ebcda", "#8c96c6", "#8c6bb1", "#88419d", "#6e016b"],
    9: ["#f7fcfd", "#e0ecf4", "#bfd3e6", "#9ebcda", "#8c96c6", "#8c6bb1", "#88419d", "#810f7c", "#4d004b"]
  },
  RdPu: {
    3: ["#fde0dd", "#fa9fb5", "#c51b8a"],
    4: ["#feebe2", "#fbb4b9", "#f768a1", "#ae017e"],
    5: ["#feebe2", "#fbb4b9", "#f768a1", "#c51b8a", "#7a0177"],
    6: ["#feebe2", "#fcc5c0", "#fa9fb5", "#f768a1", "#c51b8a", "#7a0177"],
    7: ["#feebe2", "#fcc5c0", "#fa9fb5", "#f768a1", "#dd3497", "#ae017e", "#7a0177"],
    8: ["#fff7f3", "#fde0dd", "#fcc5c0", "#fa9fb5", "#f768a1", "#dd3497", "#ae017e", "#7a0177"],
    9: ["#fff7f3", "#fde0dd", "#fcc5c0", "#fa9fb5", "#f768a1", "#dd3497", "#ae017e", "#7a0177", "#49006a"]
  },
  PuRd: {
    3: ["#e7e1ef", "#c994c7", "#dd1c77"],
    4: ["#f1eef6", "#d7b5d8", "#df65b0", "#ce1256"],
    5: ["#f1eef6", "#d7b5d8", "#df65b0", "#dd1c77", "#980043"],
    6: ["#f1eef6", "#d4b9da", "#c994c7", "#df65b0", "#dd1c77", "#980043"],
    7: ["#f1eef6", "#d4b9da", "#c994c7", "#df65b0", "#e7298a", "#ce1256", "#91003f"],
    8: ["#f7f4f9", "#e7e1ef", "#d4b9da", "#c994c7", "#df65b0", "#e7298a", "#ce1256", "#91003f"],
    9: ["#f7f4f9", "#e7e1ef", "#d4b9da", "#c994c7", "#df65b0", "#e7298a", "#ce1256", "#980043", "#67001f"]
  },
  OrRd: {
    3: ["#fee8c8", "#fdbb84", "#e34a33"],
    4: ["#fef0d9", "#fdcc8a", "#fc8d59", "#d7301f"],
    5: ["#fef0d9", "#fdcc8a", "#fc8d59", "#e34a33", "#b30000"],
    6: ["#fef0d9", "#fdd49e", "#fdbb84", "#fc8d59", "#e34a33", "#b30000"],
    7: ["#fef0d9", "#fdd49e", "#fdbb84", "#fc8d59", "#ef6548", "#d7301f", "#990000"],
    8: ["#fff7ec", "#fee8c8", "#fdd49e", "#fdbb84", "#fc8d59", "#ef6548", "#d7301f", "#990000"],
    9: ["#fff7ec", "#fee8c8", "#fdd49e", "#fdbb84", "#fc8d59", "#ef6548", "#d7301f", "#b30000", "#7f0000"]
  },
  YlOrRd: {
    3: ["#ffeda0", "#feb24c", "#f03b20"],
    4: ["#ffffb2", "#fecc5c", "#fd8d3c", "#e31a1c"],
    5: ["#ffffb2", "#fecc5c", "#fd8d3c", "#f03b20", "#bd0026"],
    6: ["#ffffb2", "#fed976", "#feb24c", "#fd8d3c", "#f03b20", "#bd0026"],
    7: ["#ffffb2", "#fed976", "#feb24c", "#fd8d3c", "#fc4e2a", "#e31a1c", "#b10026"],
    8: ["#ffffcc", "#ffeda0", "#fed976", "#feb24c", "#fd8d3c", "#fc4e2a", "#e31a1c", "#b10026"],
    9: ["#ffffcc", "#ffeda0", "#fed976", "#feb24c", "#fd8d3c", "#fc4e2a", "#e31a1c", "#bd0026", "#800026"]
  },
  YlOrBr: {
    3: ["#fff7bc", "#fec44f", "#d95f0e"],
    4: ["#ffffd4", "#fed98e", "#fe9929", "#cc4c02"],
    5: ["#ffffd4", "#fed98e", "#fe9929", "#d95f0e", "#993404"],
    6: ["#ffffd4", "#fee391", "#fec44f", "#fe9929", "#d95f0e", "#993404"],
    7: ["#ffffd4", "#fee391", "#fec44f", "#fe9929", "#ec7014", "#cc4c02", "#8c2d04"],
    8: ["#ffffe5", "#fff7bc", "#fee391", "#fec44f", "#fe9929", "#ec7014", "#cc4c02", "#8c2d04"],
    9: ["#ffffe5", "#fff7bc", "#fee391", "#fec44f", "#fe9929", "#ec7014", "#cc4c02", "#993404", "#662506"]
  },
  Purples: {
    3: ["#efedf5", "#bcbddc", "#756bb1"],
    4: ["#f2f0f7", "#cbc9e2", "#9e9ac8", "#6a51a3"],
    5: ["#f2f0f7", "#cbc9e2", "#9e9ac8", "#756bb1", "#54278f"],
    6: ["#f2f0f7", "#dadaeb", "#bcbddc", "#9e9ac8", "#756bb1", "#54278f"],
    7: ["#f2f0f7", "#dadaeb", "#bcbddc", "#9e9ac8", "#807dba", "#6a51a3", "#4a1486"],
    8: ["#fcfbfd", "#efedf5", "#dadaeb", "#bcbddc", "#9e9ac8", "#807dba", "#6a51a3", "#4a1486"],
    9: ["#fcfbfd", "#efedf5", "#dadaeb", "#bcbddc", "#9e9ac8", "#807dba", "#6a51a3", "#54278f", "#3f007d"]
  },
  Blues: {
    3: ["#deebf7", "#9ecae1", "#3182bd"],
    4: ["#eff3ff", "#bdd7e7", "#6baed6", "#2171b5"],
    5: ["#eff3ff", "#bdd7e7", "#6baed6", "#3182bd", "#08519c"],
    6: ["#eff3ff", "#c6dbef", "#9ecae1", "#6baed6", "#3182bd", "#08519c"],
    7: ["#eff3ff", "#c6dbef", "#9ecae1", "#6baed6", "#4292c6", "#2171b5", "#084594"],
    8: ["#f7fbff", "#deebf7", "#c6dbef", "#9ecae1", "#6baed6", "#4292c6", "#2171b5", "#084594"],
    9: ["#f7fbff", "#deebf7", "#c6dbef", "#9ecae1", "#6baed6", "#4292c6", "#2171b5", "#08519c", "#08306b"]
  },
  Greens: {
    3: ["#e5f5e0", "#a1d99b", "#31a354"],
    4: ["#edf8e9", "#bae4b3", "#74c476", "#238b45"],
    5: ["#edf8e9", "#bae4b3", "#74c476", "#31a354", "#006d2c"],
    6: ["#edf8e9", "#c7e9c0", "#a1d99b", "#74c476", "#31a354", "#006d2c"],
    7: ["#edf8e9", "#c7e9c0", "#a1d99b", "#74c476", "#41ab5d", "#238b45", "#005a32"],
    8: ["#f7fcf5", "#e5f5e0", "#c7e9c0", "#a1d99b", "#74c476", "#41ab5d", "#238b45", "#005a32"],
    9: ["#f7fcf5", "#e5f5e0", "#c7e9c0", "#a1d99b", "#74c476", "#41ab5d", "#238b45", "#006d2c", "#00441b"]
  },
  Oranges: {
    3: ["#fee6ce", "#fdae6b", "#e6550d"],
    4: ["#feedde", "#fdbe85", "#fd8d3c", "#d94701"],
    5: ["#feedde", "#fdbe85", "#fd8d3c", "#e6550d", "#a63603"],
    6: ["#feedde", "#fdd0a2", "#fdae6b", "#fd8d3c", "#e6550d", "#a63603"],
    7: ["#feedde", "#fdd0a2", "#fdae6b", "#fd8d3c", "#f16913", "#d94801", "#8c2d04"],
    8: ["#fff5eb", "#fee6ce", "#fdd0a2", "#fdae6b", "#fd8d3c", "#f16913", "#d94801", "#8c2d04"],
    9: ["#fff5eb", "#fee6ce", "#fdd0a2", "#fdae6b", "#fd8d3c", "#f16913", "#d94801", "#a63603", "#7f2704"]
  },
  Reds: {
    3: ["#fee0d2", "#fc9272", "#de2d26"],
    4: ["#fee5d9", "#fcae91", "#fb6a4a", "#cb181d"],
    5: ["#fee5d9", "#fcae91", "#fb6a4a", "#de2d26", "#a50f15"],
    6: ["#fee5d9", "#fcbba1", "#fc9272", "#fb6a4a", "#de2d26", "#a50f15"],
    7: ["#fee5d9", "#fcbba1", "#fc9272", "#fb6a4a", "#ef3b2c", "#cb181d", "#99000d"],
    8: ["#fff5f0", "#fee0d2", "#fcbba1", "#fc9272", "#fb6a4a", "#ef3b2c", "#cb181d", "#99000d"],
    9: ["#fff5f0", "#fee0d2", "#fcbba1", "#fc9272", "#fb6a4a", "#ef3b2c", "#cb181d", "#a50f15", "#67000d"]
  },
  Greys: {
    3: ["#f0f0f0", "#bdbdbd", "#636363"],
    4: ["#f7f7f7", "#cccccc", "#969696", "#525252"],
    5: ["#f7f7f7", "#cccccc", "#969696", "#636363", "#252525"],
    6: ["#f7f7f7", "#d9d9d9", "#bdbdbd", "#969696", "#636363", "#252525"],
    7: ["#f7f7f7", "#d9d9d9", "#bdbdbd", "#969696", "#737373", "#525252", "#252525"],
    8: ["#ffffff", "#f0f0f0", "#d9d9d9", "#bdbdbd", "#969696", "#737373", "#525252", "#252525"],
    9: ["#ffffff", "#f0f0f0", "#d9d9d9", "#bdbdbd", "#969696", "#737373", "#525252", "#252525", "#000000"]
  },
  PuOr: {
    3: ["#f1a340", "#f7f7f7", "#998ec3"],
    4: ["#e66101", "#fdb863", "#b2abd2", "#5e3c99"],
    5: ["#e66101", "#fdb863", "#f7f7f7", "#b2abd2", "#5e3c99"],
    6: ["#b35806", "#f1a340", "#fee0b6", "#d8daeb", "#998ec3", "#542788"],
    7: ["#b35806", "#f1a340", "#fee0b6", "#f7f7f7", "#d8daeb", "#998ec3", "#542788"],
    8: ["#b35806", "#e08214", "#fdb863", "#fee0b6", "#d8daeb", "#b2abd2", "#8073ac", "#542788"],
    9: ["#b35806", "#e08214", "#fdb863", "#fee0b6", "#f7f7f7", "#d8daeb", "#b2abd2", "#8073ac", "#542788"],
    10: ["#7f3b08", "#b35806", "#e08214", "#fdb863", "#fee0b6", "#d8daeb", "#b2abd2", "#8073ac", "#542788", "#2d004b"],
    11: ["#7f3b08", "#b35806", "#e08214", "#fdb863", "#fee0b6", "#f7f7f7", "#d8daeb", "#b2abd2", "#8073ac", "#542788", "#2d004b"]
  },
  BrBG: {
    3: ["#d8b365", "#f5f5f5", "#5ab4ac"],
    4: ["#a6611a", "#dfc27d", "#80cdc1", "#018571"],
    5: ["#a6611a", "#dfc27d", "#f5f5f5", "#80cdc1", "#018571"],
    6: ["#8c510a", "#d8b365", "#f6e8c3", "#c7eae5", "#5ab4ac", "#01665e"],
    7: ["#8c510a", "#d8b365", "#f6e8c3", "#f5f5f5", "#c7eae5", "#5ab4ac", "#01665e"],
    8: ["#8c510a", "#bf812d", "#dfc27d", "#f6e8c3", "#c7eae5", "#80cdc1", "#35978f", "#01665e"],
    9: ["#8c510a", "#bf812d", "#dfc27d", "#f6e8c3", "#f5f5f5", "#c7eae5", "#80cdc1", "#35978f", "#01665e"],
    10: ["#543005", "#8c510a", "#bf812d", "#dfc27d", "#f6e8c3", "#c7eae5", "#80cdc1", "#35978f", "#01665e", "#003c30"],
    11: ["#543005", "#8c510a", "#bf812d", "#dfc27d", "#f6e8c3", "#f5f5f5", "#c7eae5", "#80cdc1", "#35978f", "#01665e", "#003c30"]
  },
  PRGn: {
    3: ["#af8dc3", "#f7f7f7", "#7fbf7b"],
    4: ["#7b3294", "#c2a5cf", "#a6dba0", "#008837"],
    5: ["#7b3294", "#c2a5cf", "#f7f7f7", "#a6dba0", "#008837"],
    6: ["#762a83", "#af8dc3", "#e7d4e8", "#d9f0d3", "#7fbf7b", "#1b7837"],
    7: ["#762a83", "#af8dc3", "#e7d4e8", "#f7f7f7", "#d9f0d3", "#7fbf7b", "#1b7837"],
    8: ["#762a83", "#9970ab", "#c2a5cf", "#e7d4e8", "#d9f0d3", "#a6dba0", "#5aae61", "#1b7837"],
    9: ["#762a83", "#9970ab", "#c2a5cf", "#e7d4e8", "#f7f7f7", "#d9f0d3", "#a6dba0", "#5aae61", "#1b7837"],
    10: ["#40004b", "#762a83", "#9970ab", "#c2a5cf", "#e7d4e8", "#d9f0d3", "#a6dba0", "#5aae61", "#1b7837", "#00441b"],
    11: ["#40004b", "#762a83", "#9970ab", "#c2a5cf", "#e7d4e8", "#f7f7f7", "#d9f0d3", "#a6dba0", "#5aae61", "#1b7837", "#00441b"]
  },
  PiYG: {
    3: ["#e9a3c9", "#f7f7f7", "#a1d76a"],
    4: ["#d01c8b", "#f1b6da", "#b8e186", "#4dac26"],
    5: ["#d01c8b", "#f1b6da", "#f7f7f7", "#b8e186", "#4dac26"],
    6: ["#c51b7d", "#e9a3c9", "#fde0ef", "#e6f5d0", "#a1d76a", "#4d9221"],
    7: ["#c51b7d", "#e9a3c9", "#fde0ef", "#f7f7f7", "#e6f5d0", "#a1d76a", "#4d9221"],
    8: ["#c51b7d", "#de77ae", "#f1b6da", "#fde0ef", "#e6f5d0", "#b8e186", "#7fbc41", "#4d9221"],
    9: ["#c51b7d", "#de77ae", "#f1b6da", "#fde0ef", "#f7f7f7", "#e6f5d0", "#b8e186", "#7fbc41", "#4d9221"],
    10: ["#8e0152", "#c51b7d", "#de77ae", "#f1b6da", "#fde0ef", "#e6f5d0", "#b8e186", "#7fbc41", "#4d9221", "#276419"],
    11: ["#8e0152", "#c51b7d", "#de77ae", "#f1b6da", "#fde0ef", "#f7f7f7", "#e6f5d0", "#b8e186", "#7fbc41", "#4d9221", "#276419"]
  },
  RdBu: {
    3: ["#ef8a62", "#f7f7f7", "#67a9cf"],
    4: ["#ca0020", "#f4a582", "#92c5de", "#0571b0"],
    5: ["#ca0020", "#f4a582", "#f7f7f7", "#92c5de", "#0571b0"],
    6: ["#b2182b", "#ef8a62", "#fddbc7", "#d1e5f0", "#67a9cf", "#2166ac"],
    7: ["#b2182b", "#ef8a62", "#fddbc7", "#f7f7f7", "#d1e5f0", "#67a9cf", "#2166ac"],
    8: ["#b2182b", "#d6604d", "#f4a582", "#fddbc7", "#d1e5f0", "#92c5de", "#4393c3", "#2166ac"],
    9: ["#b2182b", "#d6604d", "#f4a582", "#fddbc7", "#f7f7f7", "#d1e5f0", "#92c5de", "#4393c3", "#2166ac"],
    10: ["#67001f", "#b2182b", "#d6604d", "#f4a582", "#fddbc7", "#d1e5f0", "#92c5de", "#4393c3", "#2166ac", "#053061"],
    11: ["#67001f", "#b2182b", "#d6604d", "#f4a582", "#fddbc7", "#f7f7f7", "#d1e5f0", "#92c5de", "#4393c3", "#2166ac", "#053061"]
  },
  RdGy: {
    3: ["#ef8a62", "#ffffff", "#999999"],
    4: ["#ca0020", "#f4a582", "#bababa", "#404040"],
    5: ["#ca0020", "#f4a582", "#ffffff", "#bababa", "#404040"],
    6: ["#b2182b", "#ef8a62", "#fddbc7", "#e0e0e0", "#999999", "#4d4d4d"],
    7: ["#b2182b", "#ef8a62", "#fddbc7", "#ffffff", "#e0e0e0", "#999999", "#4d4d4d"],
    8: ["#b2182b", "#d6604d", "#f4a582", "#fddbc7", "#e0e0e0", "#bababa", "#878787", "#4d4d4d"],
    9: ["#b2182b", "#d6604d", "#f4a582", "#fddbc7", "#ffffff", "#e0e0e0", "#bababa", "#878787", "#4d4d4d"],
    10: ["#67001f", "#b2182b", "#d6604d", "#f4a582", "#fddbc7", "#e0e0e0", "#bababa", "#878787", "#4d4d4d", "#1a1a1a"],
    11: ["#67001f", "#b2182b", "#d6604d", "#f4a582", "#fddbc7", "#ffffff", "#e0e0e0", "#bababa", "#878787", "#4d4d4d", "#1a1a1a"]
  },
  RdYlBu: {
    3: ["#fc8d59", "#ffffbf", "#91bfdb"],
    4: ["#d7191c", "#fdae61", "#abd9e9", "#2c7bb6"],
    5: ["#d7191c", "#fdae61", "#ffffbf", "#abd9e9", "#2c7bb6"],
    6: ["#d73027", "#fc8d59", "#fee090", "#e0f3f8", "#91bfdb", "#4575b4"],
    7: ["#d73027", "#fc8d59", "#fee090", "#ffffbf", "#e0f3f8", "#91bfdb", "#4575b4"],
    8: ["#d73027", "#f46d43", "#fdae61", "#fee090", "#e0f3f8", "#abd9e9", "#74add1", "#4575b4"],
    9: ["#d73027", "#f46d43", "#fdae61", "#fee090", "#ffffbf", "#e0f3f8", "#abd9e9", "#74add1", "#4575b4"],
    10: ["#a50026", "#d73027", "#f46d43", "#fdae61", "#fee090", "#e0f3f8", "#abd9e9", "#74add1", "#4575b4", "#313695"],
    11: ["#a50026", "#d73027", "#f46d43", "#fdae61", "#fee090", "#ffffbf", "#e0f3f8", "#abd9e9", "#74add1", "#4575b4", "#313695"]
  },
  Spectral: {
    3: ["#fc8d59", "#ffffbf", "#99d594"],
    4: ["#d7191c", "#fdae61", "#abdda4", "#2b83ba"],
    5: ["#d7191c", "#fdae61", "#ffffbf", "#abdda4", "#2b83ba"],
    6: ["#d53e4f", "#fc8d59", "#fee08b", "#e6f598", "#99d594", "#3288bd"],
    7: ["#d53e4f", "#fc8d59", "#fee08b", "#ffffbf", "#e6f598", "#99d594", "#3288bd"],
    8: ["#d53e4f", "#f46d43", "#fdae61", "#fee08b", "#e6f598", "#abdda4", "#66c2a5", "#3288bd"],
    9: ["#d53e4f", "#f46d43", "#fdae61", "#fee08b", "#ffffbf", "#e6f598", "#abdda4", "#66c2a5", "#3288bd"],
    10: ["#9e0142", "#d53e4f", "#f46d43", "#fdae61", "#fee08b", "#e6f598", "#abdda4", "#66c2a5", "#3288bd", "#5e4fa2"],
    11: ["#9e0142", "#d53e4f", "#f46d43", "#fdae61", "#fee08b", "#ffffbf", "#e6f598", "#abdda4", "#66c2a5", "#3288bd", "#5e4fa2"]
  },
  RdYlGn: {
    3: ["#fc8d59", "#ffffbf", "#91cf60"],
    4: ["#d7191c", "#fdae61", "#a6d96a", "#1a9641"],
    5: ["#d7191c", "#fdae61", "#ffffbf", "#a6d96a", "#1a9641"],
    6: ["#d73027", "#fc8d59", "#fee08b", "#d9ef8b", "#91cf60", "#1a9850"],
    7: ["#d73027", "#fc8d59", "#fee08b", "#ffffbf", "#d9ef8b", "#91cf60", "#1a9850"],
    8: ["#d73027", "#f46d43", "#fdae61", "#fee08b", "#d9ef8b", "#a6d96a", "#66bd63", "#1a9850"],
    9: ["#d73027", "#f46d43", "#fdae61", "#fee08b", "#ffffbf", "#d9ef8b", "#a6d96a", "#66bd63", "#1a9850"],
    10: ["#a50026", "#d73027", "#f46d43", "#fdae61", "#fee08b", "#d9ef8b", "#a6d96a", "#66bd63", "#1a9850", "#006837"],
    11: ["#a50026", "#d73027", "#f46d43", "#fdae61", "#fee08b", "#ffffbf", "#d9ef8b", "#a6d96a", "#66bd63", "#1a9850", "#006837"]
  },
  Accent: {
    3: ["#7fc97f", "#beaed4", "#fdc086"],
    4: ["#7fc97f", "#beaed4", "#fdc086", "#ffff99"],
    5: ["#7fc97f", "#beaed4", "#fdc086", "#ffff99", "#386cb0"],
    6: ["#7fc97f", "#beaed4", "#fdc086", "#ffff99", "#386cb0", "#f0027f"],
    7: ["#7fc97f", "#beaed4", "#fdc086", "#ffff99", "#386cb0", "#f0027f", "#bf5b17"],
    8: ["#7fc97f", "#beaed4", "#fdc086", "#ffff99", "#386cb0", "#f0027f", "#bf5b17", "#666666"]
  },
  Dark2: {
    3: ["#1b9e77", "#d95f02", "#7570b3"],
    4: ["#1b9e77", "#d95f02", "#7570b3", "#e7298a"],
    5: ["#1b9e77", "#d95f02", "#7570b3", "#e7298a", "#66a61e"],
    6: ["#1b9e77", "#d95f02", "#7570b3", "#e7298a", "#66a61e", "#e6ab02"],
    7: ["#1b9e77", "#d95f02", "#7570b3", "#e7298a", "#66a61e", "#e6ab02", "#a6761d"],
    8: ["#1b9e77", "#d95f02", "#7570b3", "#e7298a", "#66a61e", "#e6ab02", "#a6761d", "#666666"]
  },
  Paired: {
    3: ["#a6cee3", "#1f78b4", "#b2df8a"],
    4: ["#a6cee3", "#1f78b4", "#b2df8a", "#33a02c"],
    5: ["#a6cee3", "#1f78b4", "#b2df8a", "#33a02c", "#fb9a99"],
    6: ["#a6cee3", "#1f78b4", "#b2df8a", "#33a02c", "#fb9a99", "#e31a1c"],
    7: ["#a6cee3", "#1f78b4", "#b2df8a", "#33a02c", "#fb9a99", "#e31a1c", "#fdbf6f"],
    8: ["#a6cee3", "#1f78b4", "#b2df8a", "#33a02c", "#fb9a99", "#e31a1c", "#fdbf6f", "#ff7f00"],
    9: ["#a6cee3", "#1f78b4", "#b2df8a", "#33a02c", "#fb9a99", "#e31a1c", "#fdbf6f", "#ff7f00", "#cab2d6"],
    10: ["#a6cee3", "#1f78b4", "#b2df8a", "#33a02c", "#fb9a99", "#e31a1c", "#fdbf6f", "#ff7f00", "#cab2d6", "#6a3d9a"],
    11: ["#a6cee3", "#1f78b4", "#b2df8a", "#33a02c", "#fb9a99", "#e31a1c", "#fdbf6f", "#ff7f00", "#cab2d6", "#6a3d9a", "#ffff99"],
    12: ["#a6cee3", "#1f78b4", "#b2df8a", "#33a02c", "#fb9a99", "#e31a1c", "#fdbf6f", "#ff7f00", "#cab2d6", "#6a3d9a", "#ffff99", "#b15928"]
  },
  Pastel1: {
    3: ["#fbb4ae", "#b3cde3", "#ccebc5"],
    4: ["#fbb4ae", "#b3cde3", "#ccebc5", "#decbe4"],
    5: ["#fbb4ae", "#b3cde3", "#ccebc5", "#decbe4", "#fed9a6"],
    6: ["#fbb4ae", "#b3cde3", "#ccebc5", "#decbe4", "#fed9a6", "#ffffcc"],
    7: ["#fbb4ae", "#b3cde3", "#ccebc5", "#decbe4", "#fed9a6", "#ffffcc", "#e5d8bd"],
    8: ["#fbb4ae", "#b3cde3", "#ccebc5", "#decbe4", "#fed9a6", "#ffffcc", "#e5d8bd", "#fddaec"],
    9: ["#fbb4ae", "#b3cde3", "#ccebc5", "#decbe4", "#fed9a6", "#ffffcc", "#e5d8bd", "#fddaec", "#f2f2f2"]
  },
  Pastel2: {
    3: ["#b3e2cd", "#fdcdac", "#cbd5e8"],
    4: ["#b3e2cd", "#fdcdac", "#cbd5e8", "#f4cae4"],
    5: ["#b3e2cd", "#fdcdac", "#cbd5e8", "#f4cae4", "#e6f5c9"],
    6: ["#b3e2cd", "#fdcdac", "#cbd5e8", "#f4cae4", "#e6f5c9", "#fff2ae"],
    7: ["#b3e2cd", "#fdcdac", "#cbd5e8", "#f4cae4", "#e6f5c9", "#fff2ae", "#f1e2cc"],
    8: ["#b3e2cd", "#fdcdac", "#cbd5e8", "#f4cae4", "#e6f5c9", "#fff2ae", "#f1e2cc", "#cccccc"]
  },
  Set1: {
    3: ["#e41a1c", "#377eb8", "#4daf4a"],
    4: ["#e41a1c", "#377eb8", "#4daf4a", "#984ea3"],
    5: ["#e41a1c", "#377eb8", "#4daf4a", "#984ea3", "#ff7f00"],
    6: ["#e41a1c", "#377eb8", "#4daf4a", "#984ea3", "#ff7f00", "#ffff33"],
    7: ["#e41a1c", "#377eb8", "#4daf4a", "#984ea3", "#ff7f00", "#ffff33", "#a65628"],
    8: ["#e41a1c", "#377eb8", "#4daf4a", "#984ea3", "#ff7f00", "#ffff33", "#a65628", "#f781bf"],
    9: ["#e41a1c", "#377eb8", "#4daf4a", "#984ea3", "#ff7f00", "#ffff33", "#a65628", "#f781bf", "#999999"]
  },
  Set2: {
    3: ["#66c2a5", "#fc8d62", "#8da0cb"],
    4: ["#66c2a5", "#fc8d62", "#8da0cb", "#e78ac3"],
    5: ["#66c2a5", "#fc8d62", "#8da0cb", "#e78ac3", "#a6d854"],
    6: ["#66c2a5", "#fc8d62", "#8da0cb", "#e78ac3", "#a6d854", "#ffd92f"],
    7: ["#66c2a5", "#fc8d62", "#8da0cb", "#e78ac3", "#a6d854", "#ffd92f", "#e5c494"],
    8: ["#66c2a5", "#fc8d62", "#8da0cb", "#e78ac3", "#a6d854", "#ffd92f", "#e5c494", "#b3b3b3"]
  },
  Set3: {
    3: ["#8dd3c7", "#ffffb3", "#bebada"],
    4: ["#8dd3c7", "#ffffb3", "#bebada", "#fb8072"],
    5: ["#8dd3c7", "#ffffb3", "#bebada", "#fb8072", "#80b1d3"],
    6: ["#8dd3c7", "#ffffb3", "#bebada", "#fb8072", "#80b1d3", "#fdb462"],
    7: ["#8dd3c7", "#ffffb3", "#bebada", "#fb8072", "#80b1d3", "#fdb462", "#b3de69"],
    8: ["#8dd3c7", "#ffffb3", "#bebada", "#fb8072", "#80b1d3", "#fdb462", "#b3de69", "#fccde5"],
    9: ["#8dd3c7", "#ffffb3", "#bebada", "#fb8072", "#80b1d3", "#fdb462", "#b3de69", "#fccde5", "#d9d9d9"],
    10: ["#8dd3c7", "#ffffb3", "#bebada", "#fb8072", "#80b1d3", "#fdb462", "#b3de69", "#fccde5", "#d9d9d9", "#bc80bd"],
    11: ["#8dd3c7", "#ffffb3", "#bebada", "#fb8072", "#80b1d3", "#fdb462", "#b3de69", "#fccde5", "#d9d9d9", "#bc80bd", "#ccebc5"],
    12: ["#8dd3c7", "#ffffb3", "#bebada", "#fb8072", "#80b1d3", "#fdb462", "#b3de69", "#fccde5", "#d9d9d9", "#bc80bd", "#ccebc5", "#ffed6f"]
  }
};
const colorBrewerColors = index.Paired[11], decisionColors = r$6(`
  ${colorBrewerColors.map(
  (C, L) => i$5`
    .decision-${L} {
      --decision-color: ${r$6(C)};
      --decision-color-${L}: ${r$6(C)};
    }
  `
).join("")}
`), verificationGridTileStyles = ":host{--decision-color: var(--oe-panel-color);--selected-border-size: 4px}.spectrogram-container{margin:0;background-color:var(--oe-panel-color);padding:var(--oe-spacing)}.tile-container{position:relative;border-radius:var(--oe-border-rounding);box-shadow:var(--oe-backdrop-shadow) var(--oe-panel-color);cursor:pointer;margin-bottom:0;min-width:350px;padding:var(--selected-border-size);background-color:var(--oe-panel-color);max-height:100vh;transition:border-color var(--oe-animation-time) ease-out,border-size var(--oe-animation-time) ease-out}.tile-container:hover{box-shadow:var(--oe-backdrop-shadow) var(--oe-selected-color)}.tag-label{position:flex;padding:var(--oe-spacing);padding-top:0;text-align:center;width:100%}.selected{background-color:var(--oe-selected-color)}.hidden{position:absolute;opacity:0}.keyboard-hint{position:absolute;left:50%;top:50%;transform:translateY(calc(-50% - 1rem));z-index:2;font-size:2rem}.overlay-text{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);z-index:2;font-size:4em;background-color:var(--oe-panel-color);border-radius:var(--oe-border-rounding)}.progress-meter{position:relative;display:flex;height:var(--oe-spacing);width:100%;border-radius:4px;border:1px solid var(--oe-border-color);margin:0}.progress-meter-item{flex:1 0;border-right:1px solid var(--oe-border-color)}.skip{background:repeating-linear-gradient(45deg,var(--oe-warning-color),var(--oe-warning-color) 10px,transparent 10px,transparent 20px)!important}";
var __defProp$7 = Object.defineProperty, __getOwnPropDesc$7 = Object.getOwnPropertyDescriptor, __decorateClass$7 = (C, L, A, W) => {
  for (var X = W > 1 ? void 0 : W ? __getOwnPropDesc$7(L, A) : L, J = C.length - 1, te; J >= 0; J--)
    (te = C[J]) && (X = (W ? te(L, A, X) : te(X)) || X);
  return W && X && __defProp$7(L, A, X), X;
};
const shortcutOrder = "1234567890qwertyuiopasdfghjklzxcvbnm", shortcutTranslation = {
  1: "!",
  2: "@",
  3: "#",
  4: "$",
  5: "%",
  6: "^",
  7: "&",
  8: "*",
  9: "(",
  0: ")"
}, gridTileContext = Symbol("grid-tile-context");
let VerificationGridTileComponent = class extends AbstractComponent(h$1) {
  constructor() {
    super(...arguments), this.hidden = !1, this.showKeyboardShortcuts = !1, this.selected = !1, this.index = 0, this.keyDownHandler = this.handleKeyDown.bind(this), this.loadingHandler = this.handleLoading.bind(this), this.loadedHandler = this.handleLoaded.bind(this), this.playHandler = this.handlePlay.bind(this), this.loaded = !1, this.shortcuts = [];
  }
  get decisionIndices() {
    return this.model ? this.model.decisionModels.map((C) => C.decisionId) : [];
  }
  get requiredDecisionsCount() {
    return this.requiredTags.length;
  }
  connectedCallback() {
    super.connectedCallback(), document.addEventListener("keydown", this.keyDownHandler);
  }
  disconnectedCallback() {
    document.removeEventListener("keydown", this.keyDownHandler), this.spectrogram && (this.spectrogram.removeEventListener("loading", this.loadingHandler), this.spectrogram.removeEventListener("loaded", this.loadedHandler)), this.contentsWrapper.removeEventListener("play", this.playHandler), super.disconnectedCallback();
  }
  firstUpdated() {
    if (this.contentsWrapper.addEventListener("play", this.playHandler), !this.spectrogram)
      throw new Error("Could not find spectrogram component");
    this.spectrogram.addEventListener("loading", this.loadingHandler), this.spectrogram.addEventListener("loaded", this.loadedHandler);
  }
  // TODO: check if the model has updated, and conditionally change the spectrograms src
  willUpdate() {
    var L;
    this.spectrogram && ((L = this.model) != null && L.url) && (this.spectrogram.src = this.model.url);
    const C = shortcutOrder[this.index];
    this.shortcuts = [C, shortcutTranslation[C] ?? ""];
  }
  resetSettings() {
    this.spectrogram && this.spectrogram.resetSettings();
  }
  addDecision(C) {
    this.model.addDecision(C), this.requestUpdate();
  }
  removeDecision(C) {
    this.model.removeDecision(C), this.requestUpdate();
  }
  handlePlay(C) {
    !this.selected && C.detail.keyboardShortcut && C.preventDefault();
  }
  // this method is called when the spectrogram starts rendering
  handleLoading() {
    this.loaded = !1;
  }
  // this method is called when the spectrogram finishes rendering
  handleLoaded() {
    this.loaded = !0, this.dispatchEvent(new CustomEvent("loaded", { bubbles: !0 }));
  }
  handleFocusedKeyDown(C) {
    switch (C.key) {
      case ENTER_KEY: {
        this.dispatchSelectedEvent(C);
        break;
      }
    }
  }
  handleKeyDown(C) {
    C.key === SPACE_KEY && C.preventDefault(), C.altKey && this.shortcuts.includes(C.key.toLowerCase()) && this.dispatchEvent(
      new CustomEvent(VerificationGridTileComponent.selectedEventName, {
        bubbles: !0,
        detail: {
          index: this.index,
          shiftKey: C.shiftKey,
          ctrlKey: C.ctrlKey
        }
      })
    );
  }
  dispatchSelectedEvent(C) {
    const L = ["oe-media-controls", "button", "oe-info-card", "a"], A = C.target;
    if (!(A instanceof HTMLElement))
      return;
    const W = A.tagName;
    L.includes(W.toLocaleLowerCase()) || this.dispatchEvent(
      new CustomEvent(VerificationGridTileComponent.selectedEventName, {
        bubbles: !0,
        detail: {
          index: this.index,
          shiftKey: C.shiftKey,
          ctrlKey: C.ctrlKey
        }
      })
    );
  }
  keyboardShortcutTemplate() {
    return ke$1`
      <div class="keyboard-hint ${Rt({ hidden: !this.showKeyboardShortcuts })}">
        <kbd>${this.shortcuts.at(0)}</kbd>
      </div>
    `;
  }
  tileDecisions() {
    const C = this.model.decisionModels;
    return Array.from({ length: this.requiredDecisionsCount }).map((L, A) => {
      const W = this.requiredTags[A], X = C.find((J) => J.tag.text === W.text);
      return X || W;
    });
  }
  meterTemplate() {
    const C = "var(--oe-panel-color)", L = this.tileDecisions();
    return ke$1`
      <div class="progress-meter">
        ${Qt(L, (A) => {
      const W = A instanceof Decision ? `var(--decision-color-${A.decisionId})` : C, X = A instanceof Decision ? A.tag.text : A.text, J = Rt({
        skip: A instanceof Decision && A.confirmed === DecisionOptions.SKIP
      });
      return ke$1`
            <sl-tooltip content="${X}">
              <span class="progress-meter-item ${J}" style="background-color: ${W}"></span>
            </sl-tooltip>
          `;
    })}
      </div>
    `;
  }
  render() {
    var W;
    const C = {};
    for (const X of this.decisionIndices) {
      const J = `decision-${X}`;
      C[J] = !0;
    }
    const L = Rt({
      selected: this.selected,
      hidden: this.hidden,
      ...C
    }), A = Rt({
      selected: this.selected
    });
    return ke$1`
      <div
        id="contents-wrapper"
        @click="${this.dispatchSelectedEvent}"
        @keydown="${this.handleFocusedKeyDown}"
        class="tile-container ${L}"
        part="tile-container"
        role="button"
        tabindex="0"
        aria-hidden="${this.hidden}"
      >
        ${this.keyboardShortcutTemplate()}
        <figure class="spectrogram-container ${A}">
          <figcaption class="tag-label">${(W = this.model) == null ? void 0 : W.tag}</figcaption>
          <oe-axes ?visible="${s(this.settings.axes)}">
            <oe-indicator ?visible="${s(this.settings.indicator)}">
              <oe-spectrogram id="spectrogram" color-map="audacity"></oe-spectrogram>
            </oe-indicator>
          </oe-axes>

          <div class="meter">${this.meterTemplate()}</div>

          <oe-media-controls
            ?visible="${s(this.settings.mediaControls)}"
            for="spectrogram"
          ></oe-media-controls>

          <slot></slot>
        </figure>
      </div>
    `;
  }
};
VerificationGridTileComponent.styles = [r$6(verificationGridTileStyles), decisionColors];
VerificationGridTileComponent.selectedEventName = "selected";
__decorateClass$7([
  e$2({ context: gridTileContext }),
  n$1({ type: Object })
], VerificationGridTileComponent.prototype, "model", 2);
__decorateClass$7([
  c$1({ context: verificationGridContext, subscribe: !0 }),
  n$1({ attribute: !1 })
], VerificationGridTileComponent.prototype, "settings", 2);
__decorateClass$7([
  n$1({ type: Boolean, converter: booleanConverter, reflect: !0 })
], VerificationGridTileComponent.prototype, "hidden", 2);
__decorateClass$7([
  n$1({ attribute: !1, type: Boolean })
], VerificationGridTileComponent.prototype, "showKeyboardShortcuts", 2);
__decorateClass$7([
  n$1({ attribute: !1, type: Boolean })
], VerificationGridTileComponent.prototype, "selected", 2);
__decorateClass$7([
  n$1({ attribute: !1, type: Number })
], VerificationGridTileComponent.prototype, "index", 2);
__decorateClass$7([
  n$1({ attribute: !1, type: Array })
], VerificationGridTileComponent.prototype, "requiredTags", 2);
__decorateClass$7([
  e$6("oe-spectrogram")
], VerificationGridTileComponent.prototype, "spectrogram", 2);
__decorateClass$7([
  e$6("#contents-wrapper")
], VerificationGridTileComponent.prototype, "contentsWrapper", 2);
VerificationGridTileComponent = __decorateClass$7([
  t$4("oe-verification-grid-tile")
], VerificationGridTileComponent);
const infoCardStyle = ".card-container{position:relative;padding:var(--oe-spacing);color:var(--oe-font-color);background-color:var(--oe-background-color);border-radius:var(--oe-border-rounding);font-size:var(--oe-font-size);min-width:calc(100% - calc(var(--oe-spacing) * 2));max-width:-moz-min-content;max-width:min-content}.subject-row{display:grid;grid-template-columns:1fr 2fr;gap:.5rem}.subject-row .subject-key{font-weight:700}.subject-row .subject-key,.subject-row .subject-value{overflow-wrap:break-word;word-break:break-word}.static-actions{display:flex;justify-content:space-between}";
var __defProp$6 = Object.defineProperty, __getOwnPropDesc$6 = Object.getOwnPropertyDescriptor, __decorateClass$6 = (C, L, A, W) => {
  for (var X = W > 1 ? void 0 : W ? __getOwnPropDesc$6(L, A) : L, J = C.length - 1, te; J >= 0; J--)
    (te = C[J]) && (X = (W ? te(L, A, X) : te(X)) || X);
  return W && X && __defProp$6(L, A, X), X;
};
let InfoCardComponent = class extends AbstractComponent(h$1) {
  constructor() {
    super(...arguments), this.defaultLines = 3, this.showExpanded = !1, this.identityStrategy = (C) => C, this.numberStrategy = (C) => Number(C).toLocaleString(), this.urlStrategy = (C) => ke$1`<a href="${C}" target="_blank">${this.formatUrl(C)}</a>`;
  }
  subjectRowCount() {
    return this.model ? Object.keys(this.model.subject).length : 0;
  }
  /**
   * Converts a url into a human readable format
   * by using the format https://.../last-path?first-parameter...
   */
  formatUrl(C) {
    var te;
    const L = "…", A = C.split(":/")[0], W = ((te = C.split("/").at(-1)) == null ? void 0 : te.split("&")[0]) ?? "", J = C.split("&").length > 1 ? L : "";
    return A + L + W + J;
  }
  subjectRowTemplate(C) {
    const [L, A] = C;
    let W = this.identityStrategy;
    return typeof A == "string" && A.includes(":/") ? W = this.urlStrategy : (typeof A == "number" || !isNaN(Number(A)) && A !== "") && (W = this.numberStrategy), ke$1`
      <div class="subject-row">
        <div class="subject-key">${L}</div>
        <div class="subject-value">${W(A)}</div>
      </div>
    `;
  }
  subjectTemplate(C) {
    if (C === void 0)
      return D;
    const L = Object.entries(C);
    return this.showExpanded || L.splice(this.defaultLines), L.map((A) => this.subjectRowTemplate(A));
  }
  showMoreButtonTemplate() {
    return this.subjectRowCount() > this.defaultLines ? ke$1`
      <a id="show-more" href="javascript:void 0" @click="${() => this.showExpanded = !this.showExpanded}">
        ${this.showExpanded ? "Show Less" : "Show More"}
      </a>
    ` : D;
  }
  render() {
    var C, L;
    return ke$1`
      <div class="card-container">
        <div class="subject-content">${this.subjectTemplate((C = this.model) == null ? void 0 : C.subject)}</div>

        <hr />

        <div class="static-actions">
          <a id="download-recording" href="${((L = this.model) == null ? void 0 : L.url) ?? ""}" target="_blank" download>Download Recording</a>
          ${this.showMoreButtonTemplate()}
        </div>
      </div>
    `;
  }
};
InfoCardComponent.styles = r$6(infoCardStyle);
__decorateClass$6([
  c$1({ context: gridTileContext, subscribe: !0 }),
  n$1({ attribute: !1 })
], InfoCardComponent.prototype, "model", 2);
__decorateClass$6([
  n$1({ attribute: "default-lines", type: Number, reflect: !0 })
], InfoCardComponent.prototype, "defaultLines", 2);
__decorateClass$6([
  r$3()
], InfoCardComponent.prototype, "showExpanded", 2);
InfoCardComponent = __decorateClass$6([
  t$4("oe-info-card")
], InfoCardComponent);
function defaultFormatter(C) {
  return C == null ? "" : `${C}`;
}
function numberFormatter(C = {}) {
  const { separator: L, decimals: A } = C;
  return L ? A ? (W) => W.toFixed(A).replace(".", L) : (W) => `${W}`.replace(".", L) : A ? (W) => W.toFixed(A) : (W) => `${W}`;
}
function stringFormatter(C = {}) {
  const L = typeof C.quote == "string" ? C.quote : '"', A = typeof C.escapedQuote == "string" ? C.escapedQuote : `${L}${L}`;
  if (!L || L === A)
    return (X) => X;
  const W = new RegExp(L, "g");
  return (X) => (X.includes(L) && (X = X.replace(W, A)), `${L}${X}${L}`);
}
function symbolFormatter(C = { stringFormatter: stringFormatter() }) {
  return (L) => C.stringFormatter(L.toString().slice(7, -1));
}
function objectFormatter(C = { stringFormatter: stringFormatter() }) {
  return (L) => {
    if (L === null)
      return "";
    let A = JSON.stringify(L);
    return A === void 0 ? "" : (A[0] === '"' && (A = A.replace(/^"(.+)"$/, "$1")), C.stringFormatter(A));
  };
}
const rePropName = RegExp(
  // Match anything that isn't a dot or bracket.
  `[^.[\\]]+|\\[(?:([^"'][^[]*)|(["'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))`,
  "g"
);
function castPath(C) {
  var L, A, W;
  const X = [];
  let J;
  for (; J = rePropName.exec(C); )
    X.push((W = (L = J[3]) !== null && L !== void 0 ? L : (A = J[1]) === null || A === void 0 ? void 0 : A.trim()) !== null && W !== void 0 ? W : J[0]);
  return X;
}
function getProp(C, L, A) {
  if (L in C) {
    const J = C[L];
    return J === void 0 ? A : J;
  }
  const W = Array.isArray(L) ? L : castPath(L);
  let X = C;
  for (const J of W)
    if (X = X == null ? void 0 : X[J], X === void 0)
      return A;
  return X;
}
function flattenReducer(C, L) {
  try {
    return Array.isArray(L) ? C.push(...L) : C.push(L), C;
  } catch {
    return C.concat(L);
  }
}
function fastJoin(C, L) {
  let A = !0;
  return C.reduce((W, X) => (X == null && (X = ""), A ? (A = !1, `${X}`) : `${W}${L}${X}`), "");
}
var FormatterTypes;
(function(C) {
  C.header = "header", C.undefined = "undefined", C.boolean = "boolean", C.number = "number", C.bigint = "bigint", C.string = "string", C.symbol = "symbol", C.function = "function", C.object = "object";
})(FormatterTypes || (FormatterTypes = {}));
class JSON2CSVBase {
  constructor(L) {
    this.opts = this.preprocessOpts(L);
  }
  /**
   * Check passing opts and set defaults.
   *
   * @param {Json2CsvOptions} opts Options object containing fields,
   * delimiter, default value, header, etc.
   */
  preprocessOpts(L) {
    const A = Object.assign({}, L);
    A.fields && (A.fields = this.preprocessFieldsInfo(A.fields, A.defaultValue)), A.transforms = A.transforms || [];
    const W = A.formatters && A.formatters.string || stringFormatter(), X = objectFormatter({ stringFormatter: W }), J = {
      header: W,
      undefined: defaultFormatter,
      boolean: defaultFormatter,
      number: numberFormatter(),
      bigint: defaultFormatter,
      string: W,
      symbol: symbolFormatter({ stringFormatter: W }),
      function: X,
      object: X
    };
    return A.formatters = Object.assign(Object.assign({}, J), A.formatters), A.delimiter = A.delimiter || ",", A.eol = A.eol || `
`, A.header = A.header !== !1, A.includeEmptyRows = A.includeEmptyRows || !1, A.withBOM = A.withBOM || !1, A;
  }
  /**
   * Check and normalize the fields configuration.
   *
   * @param {(string|object)[]} fields Fields configuration provided by the user
   * or inferred from the data
   * @returns {object[]} preprocessed FieldsInfo array
   */
  preprocessFieldsInfo(L, A) {
    return L.map((W) => {
      if (typeof W == "string")
        return {
          label: W,
          value: (X) => getProp(X, W, A)
        };
      if (typeof W == "object") {
        const X = "default" in W ? W.default : A;
        if (typeof W.value == "string") {
          const J = W.value;
          return {
            label: W.label || W.value,
            value: (te) => getProp(te, J, X)
          };
        }
        if (typeof W.value == "function") {
          const J = W.label || W.value.name || "", te = { label: J, default: X }, oe = W.value;
          return {
            label: J,
            value(ne) {
              const re = oe(ne, te);
              return re === void 0 ? X : re;
            }
          };
        }
      }
      throw new Error("Invalid field info option. " + JSON.stringify(W));
    });
  }
  /**
   * Create the title row with all the provided fields as column headings
   *
   * @returns {String} titles as a string
   */
  getHeader() {
    return fastJoin(this.opts.fields.map((L) => this.opts.formatters.header(L.label)), this.opts.delimiter);
  }
  /**
   * Preprocess each object according to the given transforms (unwind, flatten, etc.).
   * @param {Object} row JSON object to be converted in a CSV row
   */
  preprocessRow(L) {
    return this.opts.transforms.reduce((A, W) => A.map((X) => W(X)).reduce(flattenReducer, []), [L]);
  }
  /**
   * Create the content of a specific CSV row
   *
   * @param {Object} row JSON object to be converted in a CSV row
   * @returns {String} CSV string (row)
   */
  processRow(L) {
    if (!L)
      return;
    const A = this.opts.fields.map((W) => this.processCell(L, W));
    if (!(!this.opts.includeEmptyRows && A.every((W) => W === "")))
      return fastJoin(A, this.opts.delimiter);
  }
  /**
   * Create the content of a specfic CSV row cell
   *
   * @param {Object} row JSON object representing the  CSV row that the cell belongs to
   * @param {FieldInfo} fieldInfo Details of the field to process to be a CSV cell
   * @returns {String} CSV string (cell)
   */
  processCell(L, A) {
    return this.processValue(A.value(L));
  }
  /**
   * Create the content of a specfic CSV row cell
   *
   * @param {T} value Value to be included in a CSV cell
   * @returns {String} Value stringified and processed
   */
  processValue(L) {
    const A = this.opts.formatters[typeof L];
    return A(L);
  }
}
class JSON2CSVParser extends JSON2CSVBase {
  constructor(L) {
    super(L);
  }
  /**
   * Main function that converts json to csv.
   *
   * @param {Array|Object} data Array of JSON objects to be converted to CSV
   * @returns {String} The CSV formated data as a string
   */
  parse(L) {
    const A = this.preprocessData(L);
    this.opts.fields = this.opts.fields || this.preprocessFieldsInfo(A.reduce((te, oe) => (Object.keys(oe).forEach((ne) => {
      te.includes(ne) || te.push(ne);
    }), te), []), this.opts.defaultValue);
    const W = this.opts.header ? this.getHeader() : "", X = this.processData(A);
    return (this.opts.withBOM ? "\uFEFF" : "") + W + (W && X ? this.opts.eol : "") + X;
  }
  /**
   * Preprocess the data according to the give opts (unwind, flatten, etc.)
    and calculate the fields and field names if they are not provided.
   *
   * @param {Array|Object} data Array or object to be converted to CSV
   */
  preprocessData(L) {
    const A = Array.isArray(L) ? L : [L];
    if (!this.opts.fields) {
      if (L == null || A.length === 0)
        throw new Error('Data should not be empty or the "fields" option should be included');
      if (typeof A[0] != "object")
        throw new Error('Data items should be objects or the "fields" option should be included');
    }
    return this.opts.transforms.length === 0 ? A : A.map((W) => this.preprocessRow(W)).reduce(flattenReducer, []);
  }
  /**
   * Create the content row by row below the header
   *
   * @param {Array} data Array of JSON objects to be converted to CSV
   * @returns {String} CSV string (body)
   */
  processData(L) {
    return fastJoin(
      L.map((A) => this.processRow(A)).filter((A) => A),
      // Filter empty rows
      this.opts.eol
    );
  }
}
var charset;
(function(C) {
  C[C.BACKSPACE = 8] = "BACKSPACE", C[C.FORM_FEED = 12] = "FORM_FEED", C[C.NEWLINE = 10] = "NEWLINE", C[C.CARRIAGE_RETURN = 13] = "CARRIAGE_RETURN", C[C.TAB = 9] = "TAB", C[C.SPACE = 32] = "SPACE", C[C.EXCLAMATION_MARK = 33] = "EXCLAMATION_MARK", C[C.QUOTATION_MARK = 34] = "QUOTATION_MARK", C[C.NUMBER_SIGN = 35] = "NUMBER_SIGN", C[C.DOLLAR_SIGN = 36] = "DOLLAR_SIGN", C[C.PERCENT_SIGN = 37] = "PERCENT_SIGN", C[C.AMPERSAND = 38] = "AMPERSAND", C[C.APOSTROPHE = 39] = "APOSTROPHE", C[C.LEFT_PARENTHESIS = 40] = "LEFT_PARENTHESIS", C[C.RIGHT_PARENTHESIS = 41] = "RIGHT_PARENTHESIS", C[C.ASTERISK = 42] = "ASTERISK", C[C.PLUS_SIGN = 43] = "PLUS_SIGN", C[C.COMMA = 44] = "COMMA", C[C.HYPHEN_MINUS = 45] = "HYPHEN_MINUS", C[C.FULL_STOP = 46] = "FULL_STOP", C[C.SOLIDUS = 47] = "SOLIDUS", C[C.DIGIT_ZERO = 48] = "DIGIT_ZERO", C[C.DIGIT_ONE = 49] = "DIGIT_ONE", C[C.DIGIT_TWO = 50] = "DIGIT_TWO", C[C.DIGIT_THREE = 51] = "DIGIT_THREE", C[C.DIGIT_FOUR = 52] = "DIGIT_FOUR", C[C.DIGIT_FIVE = 53] = "DIGIT_FIVE", C[C.DIGIT_SIX = 54] = "DIGIT_SIX", C[C.DIGIT_SEVEN = 55] = "DIGIT_SEVEN", C[C.DIGIT_EIGHT = 56] = "DIGIT_EIGHT", C[C.DIGIT_NINE = 57] = "DIGIT_NINE", C[C.COLON = 58] = "COLON", C[C.SEMICOLON = 59] = "SEMICOLON", C[C.LESS_THAN_SIGN = 60] = "LESS_THAN_SIGN", C[C.EQUALS_SIGN = 61] = "EQUALS_SIGN", C[C.GREATER_THAN_SIGN = 62] = "GREATER_THAN_SIGN", C[C.QUESTION_MARK = 63] = "QUESTION_MARK", C[C.COMMERCIAL_AT = 64] = "COMMERCIAL_AT", C[C.LATIN_CAPITAL_LETTER_A = 65] = "LATIN_CAPITAL_LETTER_A", C[C.LATIN_CAPITAL_LETTER_B = 66] = "LATIN_CAPITAL_LETTER_B", C[C.LATIN_CAPITAL_LETTER_C = 67] = "LATIN_CAPITAL_LETTER_C", C[C.LATIN_CAPITAL_LETTER_D = 68] = "LATIN_CAPITAL_LETTER_D", C[C.LATIN_CAPITAL_LETTER_E = 69] = "LATIN_CAPITAL_LETTER_E", C[C.LATIN_CAPITAL_LETTER_F = 70] = "LATIN_CAPITAL_LETTER_F", C[C.LATIN_CAPITAL_LETTER_G = 71] = "LATIN_CAPITAL_LETTER_G", C[C.LATIN_CAPITAL_LETTER_H = 72] = "LATIN_CAPITAL_LETTER_H", C[C.LATIN_CAPITAL_LETTER_I = 73] = "LATIN_CAPITAL_LETTER_I", C[C.LATIN_CAPITAL_LETTER_J = 74] = "LATIN_CAPITAL_LETTER_J", C[C.LATIN_CAPITAL_LETTER_K = 75] = "LATIN_CAPITAL_LETTER_K", C[C.LATIN_CAPITAL_LETTER_L = 76] = "LATIN_CAPITAL_LETTER_L", C[C.LATIN_CAPITAL_LETTER_M = 77] = "LATIN_CAPITAL_LETTER_M", C[C.LATIN_CAPITAL_LETTER_N = 78] = "LATIN_CAPITAL_LETTER_N", C[C.LATIN_CAPITAL_LETTER_O = 79] = "LATIN_CAPITAL_LETTER_O", C[C.LATIN_CAPITAL_LETTER_P = 80] = "LATIN_CAPITAL_LETTER_P", C[C.LATIN_CAPITAL_LETTER_Q = 81] = "LATIN_CAPITAL_LETTER_Q", C[C.LATIN_CAPITAL_LETTER_R = 82] = "LATIN_CAPITAL_LETTER_R", C[C.LATIN_CAPITAL_LETTER_S = 83] = "LATIN_CAPITAL_LETTER_S", C[C.LATIN_CAPITAL_LETTER_T = 84] = "LATIN_CAPITAL_LETTER_T", C[C.LATIN_CAPITAL_LETTER_U = 85] = "LATIN_CAPITAL_LETTER_U", C[C.LATIN_CAPITAL_LETTER_V = 86] = "LATIN_CAPITAL_LETTER_V", C[C.LATIN_CAPITAL_LETTER_W = 87] = "LATIN_CAPITAL_LETTER_W", C[C.LATIN_CAPITAL_LETTER_X = 88] = "LATIN_CAPITAL_LETTER_X", C[C.LATIN_CAPITAL_LETTER_Y = 89] = "LATIN_CAPITAL_LETTER_Y", C[C.LATIN_CAPITAL_LETTER_Z = 90] = "LATIN_CAPITAL_LETTER_Z", C[C.LEFT_SQUARE_BRACKET = 91] = "LEFT_SQUARE_BRACKET", C[C.REVERSE_SOLIDUS = 92] = "REVERSE_SOLIDUS", C[C.RIGHT_SQUARE_BRACKET = 93] = "RIGHT_SQUARE_BRACKET", C[C.CIRCUMFLEX_ACCENT = 94] = "CIRCUMFLEX_ACCENT", C[C.LOW_LINE = 95] = "LOW_LINE", C[C.GRAVE_ACCENT = 96] = "GRAVE_ACCENT", C[C.LATIN_SMALL_LETTER_A = 97] = "LATIN_SMALL_LETTER_A", C[C.LATIN_SMALL_LETTER_B = 98] = "LATIN_SMALL_LETTER_B", C[C.LATIN_SMALL_LETTER_C = 99] = "LATIN_SMALL_LETTER_C", C[C.LATIN_SMALL_LETTER_D = 100] = "LATIN_SMALL_LETTER_D", C[C.LATIN_SMALL_LETTER_E = 101] = "LATIN_SMALL_LETTER_E", C[C.LATIN_SMALL_LETTER_F = 102] = "LATIN_SMALL_LETTER_F", C[C.LATIN_SMALL_LETTER_G = 103] = "LATIN_SMALL_LETTER_G", C[C.LATIN_SMALL_LETTER_H = 104] = "LATIN_SMALL_LETTER_H", C[C.LATIN_SMALL_LETTER_I = 105] = "LATIN_SMALL_LETTER_I", C[C.LATIN_SMALL_LETTER_J = 106] = "LATIN_SMALL_LETTER_J", C[C.LATIN_SMALL_LETTER_K = 107] = "LATIN_SMALL_LETTER_K", C[C.LATIN_SMALL_LETTER_L = 108] = "LATIN_SMALL_LETTER_L", C[C.LATIN_SMALL_LETTER_M = 109] = "LATIN_SMALL_LETTER_M", C[C.LATIN_SMALL_LETTER_N = 110] = "LATIN_SMALL_LETTER_N", C[C.LATIN_SMALL_LETTER_O = 111] = "LATIN_SMALL_LETTER_O", C[C.LATIN_SMALL_LETTER_P = 112] = "LATIN_SMALL_LETTER_P", C[C.LATIN_SMALL_LETTER_Q = 113] = "LATIN_SMALL_LETTER_Q", C[C.LATIN_SMALL_LETTER_R = 114] = "LATIN_SMALL_LETTER_R", C[C.LATIN_SMALL_LETTER_S = 115] = "LATIN_SMALL_LETTER_S", C[C.LATIN_SMALL_LETTER_T = 116] = "LATIN_SMALL_LETTER_T", C[C.LATIN_SMALL_LETTER_U = 117] = "LATIN_SMALL_LETTER_U", C[C.LATIN_SMALL_LETTER_V = 118] = "LATIN_SMALL_LETTER_V", C[C.LATIN_SMALL_LETTER_W = 119] = "LATIN_SMALL_LETTER_W", C[C.LATIN_SMALL_LETTER_X = 120] = "LATIN_SMALL_LETTER_X", C[C.LATIN_SMALL_LETTER_Y = 121] = "LATIN_SMALL_LETTER_Y", C[C.LATIN_SMALL_LETTER_Z = 122] = "LATIN_SMALL_LETTER_Z", C[C.LEFT_CURLY_BRACKET = 123] = "LEFT_CURLY_BRACKET", C[C.VERTICAL_LINE = 124] = "VERTICAL_LINE", C[C.RIGHT_CURLY_BRACKET = 125] = "RIGHT_CURLY_BRACKET", C[C.TILDE = 126] = "TILDE";
})(charset || (charset = {}));
charset.QUOTATION_MARK + "", charset.QUOTATION_MARK, charset.REVERSE_SOLIDUS + "", charset.REVERSE_SOLIDUS, charset.SOLIDUS + "", charset.SOLIDUS, charset.LATIN_SMALL_LETTER_B + "", charset.BACKSPACE, charset.LATIN_SMALL_LETTER_F + "", charset.FORM_FEED, charset.LATIN_SMALL_LETTER_N + "", charset.NEWLINE, charset.LATIN_SMALL_LETTER_R + "", charset.CARRIAGE_RETURN, charset.LATIN_SMALL_LETTER_T + "", charset.TAB;
var TokenType;
(function(C) {
  C[C.LEFT_BRACE = 0] = "LEFT_BRACE", C[C.RIGHT_BRACE = 1] = "RIGHT_BRACE", C[C.LEFT_BRACKET = 2] = "LEFT_BRACKET", C[C.RIGHT_BRACKET = 3] = "RIGHT_BRACKET", C[C.COLON = 4] = "COLON", C[C.COMMA = 5] = "COMMA", C[C.TRUE = 6] = "TRUE", C[C.FALSE = 7] = "FALSE", C[C.NULL = 8] = "NULL", C[C.STRING = 9] = "STRING", C[C.NUMBER = 10] = "NUMBER", C[C.SEPARATOR = 11] = "SEPARATOR";
})(TokenType || (TokenType = {}));
var TokenizerStates;
(function(C) {
  C[C.START = 0] = "START", C[C.ENDED = 1] = "ENDED", C[C.ERROR = 2] = "ERROR", C[C.TRUE1 = 3] = "TRUE1", C[C.TRUE2 = 4] = "TRUE2", C[C.TRUE3 = 5] = "TRUE3", C[C.FALSE1 = 6] = "FALSE1", C[C.FALSE2 = 7] = "FALSE2", C[C.FALSE3 = 8] = "FALSE3", C[C.FALSE4 = 9] = "FALSE4", C[C.NULL1 = 10] = "NULL1", C[C.NULL2 = 11] = "NULL2", C[C.NULL3 = 12] = "NULL3", C[C.STRING_DEFAULT = 13] = "STRING_DEFAULT", C[C.STRING_AFTER_BACKSLASH = 14] = "STRING_AFTER_BACKSLASH", C[C.STRING_UNICODE_DIGIT_1 = 15] = "STRING_UNICODE_DIGIT_1", C[C.STRING_UNICODE_DIGIT_2 = 16] = "STRING_UNICODE_DIGIT_2", C[C.STRING_UNICODE_DIGIT_3 = 17] = "STRING_UNICODE_DIGIT_3", C[C.STRING_UNICODE_DIGIT_4 = 18] = "STRING_UNICODE_DIGIT_4", C[C.STRING_INCOMPLETE_CHAR = 19] = "STRING_INCOMPLETE_CHAR", C[C.NUMBER_AFTER_INITIAL_MINUS = 20] = "NUMBER_AFTER_INITIAL_MINUS", C[C.NUMBER_AFTER_INITIAL_ZERO = 21] = "NUMBER_AFTER_INITIAL_ZERO", C[C.NUMBER_AFTER_INITIAL_NON_ZERO = 22] = "NUMBER_AFTER_INITIAL_NON_ZERO", C[C.NUMBER_AFTER_FULL_STOP = 23] = "NUMBER_AFTER_FULL_STOP", C[C.NUMBER_AFTER_DECIMAL = 24] = "NUMBER_AFTER_DECIMAL", C[C.NUMBER_AFTER_E = 25] = "NUMBER_AFTER_E", C[C.NUMBER_AFTER_E_AND_SIGN = 26] = "NUMBER_AFTER_E_AND_SIGN", C[C.NUMBER_AFTER_E_AND_DIGIT = 27] = "NUMBER_AFTER_E_AND_DIGIT", C[C.SEPARATOR = 28] = "SEPARATOR", C[C.BOM_OR_START = 29] = "BOM_OR_START", C[C.BOM = 30] = "BOM";
})(TokenizerStates || (TokenizerStates = {}));
var TokenParserMode;
(function(C) {
  C[C.OBJECT = 0] = "OBJECT", C[C.ARRAY = 1] = "ARRAY";
})(TokenParserMode || (TokenParserMode = {}));
var TokenParserState;
(function(C) {
  C[C.VALUE = 0] = "VALUE", C[C.KEY = 1] = "KEY", C[C.COLON = 2] = "COLON", C[C.COMMA = 3] = "COMMA", C[C.ENDED = 4] = "ENDED", C[C.ERROR = 5] = "ERROR", C[C.SEPARATOR = 6] = "SEPARATOR";
})(TokenParserState || (TokenParserState = {}));
async function downloadFile(C) {
  if ("showSaveFilePicker" in window) {
    const W = await (await window.showSaveFilePicker({ suggestedName: C.name })).createWritable();
    await W.write(C), await W.close();
  } else {
    const A = URL.createObjectURL(C), W = document.createElement("a");
    W.download = C.name, W.href = A, W.click(), URL.revokeObjectURL(A);
  }
}
var browser = function(C) {
  var L = {};
  function A(W) {
    if (L[W]) return L[W].exports;
    var X = L[W] = { i: W, l: !1, exports: {} };
    return C[W].call(X.exports, X, X.exports, A), X.l = !0, X.exports;
  }
  return A.m = C, A.c = L, A.d = function(W, X, J) {
    A.o(W, X) || Object.defineProperty(W, X, { enumerable: !0, get: J });
  }, A.r = function(W) {
    typeof Symbol < "u" && Symbol.toStringTag && Object.defineProperty(W, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(W, "__esModule", { value: !0 });
  }, A.t = function(W, X) {
    if (1 & X && (W = A(W)), 8 & X || 4 & X && typeof W == "object" && W && W.__esModule) return W;
    var J = /* @__PURE__ */ Object.create(null);
    if (A.r(J), Object.defineProperty(J, "default", { enumerable: !0, value: W }), 2 & X && typeof W != "string") for (var te in W) A.d(J, te, (function(oe) {
      return W[oe];
    }).bind(null, te));
    return J;
  }, A.n = function(W) {
    var X = W && W.__esModule ? function() {
      return W.default;
    } : function() {
      return W;
    };
    return A.d(X, "a", X), X;
  }, A.o = function(W, X) {
    return Object.prototype.hasOwnProperty.call(W, X);
  }, A.p = "", A(A.s = 32);
}([function(C, L) {
  var A;
  A = /* @__PURE__ */ function() {
    return this;
  }();
  try {
    A = A || Function("return this")() || (0, eval)("this");
  } catch {
    typeof window == "object" && (A = window);
  }
  C.exports = A;
}, function(C, L, A) {
  var W = A(6), X = Object.keys || function(pe) {
    var me = [];
    for (var Me in pe) me.push(Me);
    return me;
  };
  C.exports = ue;
  var J = A(5);
  J.inherits = A(2);
  var te = A(23), oe = A(14);
  J.inherits(ue, te);
  for (var ne = X(oe.prototype), re = 0; re < ne.length; re++) {
    var ce = ne[re];
    ue.prototype[ce] || (ue.prototype[ce] = oe.prototype[ce]);
  }
  function ue(pe) {
    if (!(this instanceof ue)) return new ue(pe);
    te.call(this, pe), oe.call(this, pe), pe && pe.readable === !1 && (this.readable = !1), pe && pe.writable === !1 && (this.writable = !1), this.allowHalfOpen = !0, pe && pe.allowHalfOpen === !1 && (this.allowHalfOpen = !1), this.once("end", de);
  }
  function de() {
    this.allowHalfOpen || this._writableState.ended || W.nextTick(be, this);
  }
  function be(pe) {
    pe.end();
  }
  Object.defineProperty(ue.prototype, "writableHighWaterMark", { enumerable: !1, get: function() {
    return this._writableState.highWaterMark;
  } }), Object.defineProperty(ue.prototype, "destroyed", { get: function() {
    return this._readableState !== void 0 && this._writableState !== void 0 && this._readableState.destroyed && this._writableState.destroyed;
  }, set: function(pe) {
    this._readableState !== void 0 && this._writableState !== void 0 && (this._readableState.destroyed = pe, this._writableState.destroyed = pe);
  } }), ue.prototype._destroy = function(pe, me) {
    this.push(null), this.end(), W.nextTick(me, pe);
  };
}, function(C, L) {
  typeof Object.create == "function" ? C.exports = function(A, W) {
    A.super_ = W, A.prototype = Object.create(W.prototype, { constructor: { value: A, enumerable: !1, writable: !0, configurable: !0 } });
  } : C.exports = function(A, W) {
    A.super_ = W;
    var X = function() {
    };
    X.prototype = W.prototype, A.prototype = new X(), A.prototype.constructor = A;
  };
}, function(C, L, A) {
  (function(W) {
    /*!
     * The buffer module from node.js, for the browser.
     *
     * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
     * @license  MIT
     */
    var X = A(38), J = A(39), te = A(40);
    function oe() {
      return re.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823;
    }
    function ne(fe, _e) {
      if (oe() < _e) throw new RangeError("Invalid typed array length");
      return re.TYPED_ARRAY_SUPPORT ? (fe = new Uint8Array(_e)).__proto__ = re.prototype : (fe === null && (fe = new re(_e)), fe.length = _e), fe;
    }
    function re(fe, _e, je) {
      if (!(re.TYPED_ARRAY_SUPPORT || this instanceof re)) return new re(fe, _e, je);
      if (typeof fe == "number") {
        if (typeof _e == "string") throw new Error("If encoding is specified then the first argument must be a string");
        return de(this, fe);
      }
      return ce(this, fe, _e, je);
    }
    function ce(fe, _e, je, Ne) {
      if (typeof _e == "number") throw new TypeError('"value" argument must not be a number');
      return typeof ArrayBuffer < "u" && _e instanceof ArrayBuffer ? function(Ie, Xe, ft, It) {
        if (Xe.byteLength, ft < 0 || Xe.byteLength < ft) throw new RangeError("'offset' is out of bounds");
        if (Xe.byteLength < ft + (It || 0)) throw new RangeError("'length' is out of bounds");
        return Xe = ft === void 0 && It === void 0 ? new Uint8Array(Xe) : It === void 0 ? new Uint8Array(Xe, ft) : new Uint8Array(Xe, ft, It), re.TYPED_ARRAY_SUPPORT ? (Ie = Xe).__proto__ = re.prototype : Ie = be(Ie, Xe), Ie;
      }(fe, _e, je, Ne) : typeof _e == "string" ? function(Ie, Xe, ft) {
        if (typeof ft == "string" && ft !== "" || (ft = "utf8"), !re.isEncoding(ft)) throw new TypeError('"encoding" must be a valid string encoding');
        var It = 0 | me(Xe, ft), jt = (Ie = ne(Ie, It)).write(Xe, ft);
        return jt !== It && (Ie = Ie.slice(0, jt)), Ie;
      }(fe, _e, je) : function(Ie, Xe) {
        if (re.isBuffer(Xe)) {
          var ft = 0 | pe(Xe.length);
          return (Ie = ne(Ie, ft)).length === 0 || Xe.copy(Ie, 0, 0, ft), Ie;
        }
        if (Xe) {
          if (typeof ArrayBuffer < "u" && Xe.buffer instanceof ArrayBuffer || "length" in Xe) return typeof Xe.length != "number" || function(It) {
            return It != It;
          }(Xe.length) ? ne(Ie, 0) : be(Ie, Xe);
          if (Xe.type === "Buffer" && te(Xe.data)) return be(Ie, Xe.data);
        }
        throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.");
      }(fe, _e);
    }
    function ue(fe) {
      if (typeof fe != "number") throw new TypeError('"size" argument must be a number');
      if (fe < 0) throw new RangeError('"size" argument must not be negative');
    }
    function de(fe, _e) {
      if (ue(_e), fe = ne(fe, _e < 0 ? 0 : 0 | pe(_e)), !re.TYPED_ARRAY_SUPPORT) for (var je = 0; je < _e; ++je) fe[je] = 0;
      return fe;
    }
    function be(fe, _e) {
      var je = _e.length < 0 ? 0 : 0 | pe(_e.length);
      fe = ne(fe, je);
      for (var Ne = 0; Ne < je; Ne += 1) fe[Ne] = 255 & _e[Ne];
      return fe;
    }
    function pe(fe) {
      if (fe >= oe()) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + oe().toString(16) + " bytes");
      return 0 | fe;
    }
    function me(fe, _e) {
      if (re.isBuffer(fe)) return fe.length;
      if (typeof ArrayBuffer < "u" && typeof ArrayBuffer.isView == "function" && (ArrayBuffer.isView(fe) || fe instanceof ArrayBuffer)) return fe.byteLength;
      typeof fe != "string" && (fe = "" + fe);
      var je = fe.length;
      if (je === 0) return 0;
      for (var Ne = !1; ; ) switch (_e) {
        case "ascii":
        case "latin1":
        case "binary":
          return je;
        case "utf8":
        case "utf-8":
        case void 0:
          return ot(fe).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return 2 * je;
        case "hex":
          return je >>> 1;
        case "base64":
          return Be(fe).length;
        default:
          if (Ne) return ot(fe).length;
          _e = ("" + _e).toLowerCase(), Ne = !0;
      }
    }
    function Me(fe, _e, je) {
      var Ne = fe[_e];
      fe[_e] = fe[je], fe[je] = Ne;
    }
    function he(fe, _e, je, Ne, Ie) {
      if (fe.length === 0) return -1;
      if (typeof je == "string" ? (Ne = je, je = 0) : je > 2147483647 ? je = 2147483647 : je < -2147483648 && (je = -2147483648), je = +je, isNaN(je) && (je = Ie ? 0 : fe.length - 1), je < 0 && (je = fe.length + je), je >= fe.length) {
        if (Ie) return -1;
        je = fe.length - 1;
      } else if (je < 0) {
        if (!Ie) return -1;
        je = 0;
      }
      if (typeof _e == "string" && (_e = re.from(_e, Ne)), re.isBuffer(_e)) return _e.length === 0 ? -1 : ge(fe, _e, je, Ne, Ie);
      if (typeof _e == "number") return _e &= 255, re.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf == "function" ? Ie ? Uint8Array.prototype.indexOf.call(fe, _e, je) : Uint8Array.prototype.lastIndexOf.call(fe, _e, je) : ge(fe, [_e], je, Ne, Ie);
      throw new TypeError("val must be string, number or Buffer");
    }
    function ge(fe, _e, je, Ne, Ie) {
      var Xe, ft = 1, It = fe.length, jt = _e.length;
      if (Ne !== void 0 && ((Ne = String(Ne).toLowerCase()) === "ucs2" || Ne === "ucs-2" || Ne === "utf16le" || Ne === "utf-16le")) {
        if (fe.length < 2 || _e.length < 2) return -1;
        ft = 2, It /= 2, jt /= 2, je /= 2;
      }
      function Ot(tr, Wt) {
        return ft === 1 ? tr[Wt] : tr.readUInt16BE(Wt * ft);
      }
      if (Ie) {
        var Ut = -1;
        for (Xe = je; Xe < It; Xe++) if (Ot(fe, Xe) === Ot(_e, Ut === -1 ? 0 : Xe - Ut)) {
          if (Ut === -1 && (Ut = Xe), Xe - Ut + 1 === jt) return Ut * ft;
        } else Ut !== -1 && (Xe -= Xe - Ut), Ut = -1;
      } else for (je + jt > It && (je = It - jt), Xe = je; Xe >= 0; Xe--) {
        for (var kt = !0, Xt = 0; Xt < jt; Xt++) if (Ot(fe, Xe + Xt) !== Ot(_e, Xt)) {
          kt = !1;
          break;
        }
        if (kt) return Xe;
      }
      return -1;
    }
    function Ce(fe, _e, je, Ne) {
      je = Number(je) || 0;
      var Ie = fe.length - je;
      Ne ? (Ne = Number(Ne)) > Ie && (Ne = Ie) : Ne = Ie;
      var Xe = _e.length;
      if (Xe % 2 != 0) throw new TypeError("Invalid hex string");
      Ne > Xe / 2 && (Ne = Xe / 2);
      for (var ft = 0; ft < Ne; ++ft) {
        var It = parseInt(_e.substr(2 * ft, 2), 16);
        if (isNaN(It)) return ft;
        fe[je + ft] = It;
      }
      return ft;
    }
    function Se(fe, _e, je, Ne) {
      return Ve(ot(_e, fe.length - je), fe, je, Ne);
    }
    function Ae(fe, _e, je, Ne) {
      return Ve(function(Ie) {
        for (var Xe = [], ft = 0; ft < Ie.length; ++ft) Xe.push(255 & Ie.charCodeAt(ft));
        return Xe;
      }(_e), fe, je, Ne);
    }
    function Le(fe, _e, je, Ne) {
      return Ae(fe, _e, je, Ne);
    }
    function ve(fe, _e, je, Ne) {
      return Ve(Be(_e), fe, je, Ne);
    }
    function De(fe, _e, je, Ne) {
      return Ve(function(Ie, Xe) {
        for (var ft, It, jt, Ot = [], Ut = 0; Ut < Ie.length && !((Xe -= 2) < 0); ++Ut) It = (ft = Ie.charCodeAt(Ut)) >> 8, jt = ft % 256, Ot.push(jt), Ot.push(It);
        return Ot;
      }(_e, fe.length - je), fe, je, Ne);
    }
    function Ue(fe, _e, je) {
      return _e === 0 && je === fe.length ? X.fromByteArray(fe) : X.fromByteArray(fe.slice(_e, je));
    }
    function Fe(fe, _e, je) {
      je = Math.min(fe.length, je);
      for (var Ne = [], Ie = _e; Ie < je; ) {
        var Xe, ft, It, jt, Ot = fe[Ie], Ut = null, kt = Ot > 239 ? 4 : Ot > 223 ? 3 : Ot > 191 ? 2 : 1;
        if (Ie + kt <= je) switch (kt) {
          case 1:
            Ot < 128 && (Ut = Ot);
            break;
          case 2:
            (192 & (Xe = fe[Ie + 1])) == 128 && (jt = (31 & Ot) << 6 | 63 & Xe) > 127 && (Ut = jt);
            break;
          case 3:
            Xe = fe[Ie + 1], ft = fe[Ie + 2], (192 & Xe) == 128 && (192 & ft) == 128 && (jt = (15 & Ot) << 12 | (63 & Xe) << 6 | 63 & ft) > 2047 && (jt < 55296 || jt > 57343) && (Ut = jt);
            break;
          case 4:
            Xe = fe[Ie + 1], ft = fe[Ie + 2], It = fe[Ie + 3], (192 & Xe) == 128 && (192 & ft) == 128 && (192 & It) == 128 && (jt = (15 & Ot) << 18 | (63 & Xe) << 12 | (63 & ft) << 6 | 63 & It) > 65535 && jt < 1114112 && (Ut = jt);
        }
        Ut === null ? (Ut = 65533, kt = 1) : Ut > 65535 && (Ut -= 65536, Ne.push(Ut >>> 10 & 1023 | 55296), Ut = 56320 | 1023 & Ut), Ne.push(Ut), Ie += kt;
      }
      return function(Xt) {
        var tr = Xt.length;
        if (tr <= We) return String.fromCharCode.apply(String, Xt);
        for (var Wt = "", xt = 0; xt < tr; ) Wt += String.fromCharCode.apply(String, Xt.slice(xt, xt += We));
        return Wt;
      }(Ne);
    }
    L.Buffer = re, L.SlowBuffer = function(fe) {
      return +fe != fe && (fe = 0), re.alloc(+fe);
    }, L.INSPECT_MAX_BYTES = 50, re.TYPED_ARRAY_SUPPORT = W.TYPED_ARRAY_SUPPORT !== void 0 ? W.TYPED_ARRAY_SUPPORT : function() {
      try {
        var fe = new Uint8Array(1);
        return fe.__proto__ = { __proto__: Uint8Array.prototype, foo: function() {
          return 42;
        } }, fe.foo() === 42 && typeof fe.subarray == "function" && fe.subarray(1, 1).byteLength === 0;
      } catch {
        return !1;
      }
    }(), L.kMaxLength = oe(), re.poolSize = 8192, re._augment = function(fe) {
      return fe.__proto__ = re.prototype, fe;
    }, re.from = function(fe, _e, je) {
      return ce(null, fe, _e, je);
    }, re.TYPED_ARRAY_SUPPORT && (re.prototype.__proto__ = Uint8Array.prototype, re.__proto__ = Uint8Array, typeof Symbol < "u" && Symbol.species && re[Symbol.species] === re && Object.defineProperty(re, Symbol.species, { value: null, configurable: !0 })), re.alloc = function(fe, _e, je) {
      return function(Ne, Ie, Xe, ft) {
        return ue(Ie), Ie <= 0 ? ne(Ne, Ie) : Xe !== void 0 ? typeof ft == "string" ? ne(Ne, Ie).fill(Xe, ft) : ne(Ne, Ie).fill(Xe) : ne(Ne, Ie);
      }(null, fe, _e, je);
    }, re.allocUnsafe = function(fe) {
      return de(null, fe);
    }, re.allocUnsafeSlow = function(fe) {
      return de(null, fe);
    }, re.isBuffer = function(fe) {
      return !(fe == null || !fe._isBuffer);
    }, re.compare = function(fe, _e) {
      if (!re.isBuffer(fe) || !re.isBuffer(_e)) throw new TypeError("Arguments must be Buffers");
      if (fe === _e) return 0;
      for (var je = fe.length, Ne = _e.length, Ie = 0, Xe = Math.min(je, Ne); Ie < Xe; ++Ie) if (fe[Ie] !== _e[Ie]) {
        je = fe[Ie], Ne = _e[Ie];
        break;
      }
      return je < Ne ? -1 : Ne < je ? 1 : 0;
    }, re.isEncoding = function(fe) {
      switch (String(fe).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return !0;
        default:
          return !1;
      }
    }, re.concat = function(fe, _e) {
      if (!te(fe)) throw new TypeError('"list" argument must be an Array of Buffers');
      if (fe.length === 0) return re.alloc(0);
      var je;
      if (_e === void 0) for (_e = 0, je = 0; je < fe.length; ++je) _e += fe[je].length;
      var Ne = re.allocUnsafe(_e), Ie = 0;
      for (je = 0; je < fe.length; ++je) {
        var Xe = fe[je];
        if (!re.isBuffer(Xe)) throw new TypeError('"list" argument must be an Array of Buffers');
        Xe.copy(Ne, Ie), Ie += Xe.length;
      }
      return Ne;
    }, re.byteLength = me, re.prototype._isBuffer = !0, re.prototype.swap16 = function() {
      var fe = this.length;
      if (fe % 2 != 0) throw new RangeError("Buffer size must be a multiple of 16-bits");
      for (var _e = 0; _e < fe; _e += 2) Me(this, _e, _e + 1);
      return this;
    }, re.prototype.swap32 = function() {
      var fe = this.length;
      if (fe % 4 != 0) throw new RangeError("Buffer size must be a multiple of 32-bits");
      for (var _e = 0; _e < fe; _e += 4) Me(this, _e, _e + 3), Me(this, _e + 1, _e + 2);
      return this;
    }, re.prototype.swap64 = function() {
      var fe = this.length;
      if (fe % 8 != 0) throw new RangeError("Buffer size must be a multiple of 64-bits");
      for (var _e = 0; _e < fe; _e += 8) Me(this, _e, _e + 7), Me(this, _e + 1, _e + 6), Me(this, _e + 2, _e + 5), Me(this, _e + 3, _e + 4);
      return this;
    }, re.prototype.toString = function() {
      var fe = 0 | this.length;
      return fe === 0 ? "" : arguments.length === 0 ? Fe(this, 0, fe) : (function(_e, je, Ne) {
        var Ie = !1;
        if ((je === void 0 || je < 0) && (je = 0), je > this.length || ((Ne === void 0 || Ne > this.length) && (Ne = this.length), Ne <= 0) || (Ne >>>= 0) <= (je >>>= 0)) return "";
        for (_e || (_e = "utf8"); ; ) switch (_e) {
          case "hex":
            return Qe(this, je, Ne);
          case "utf8":
          case "utf-8":
            return Fe(this, je, Ne);
          case "ascii":
            return Ke(this, je, Ne);
          case "latin1":
          case "binary":
            return it(this, je, Ne);
          case "base64":
            return Ue(this, je, Ne);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return vt(this, je, Ne);
          default:
            if (Ie) throw new TypeError("Unknown encoding: " + _e);
            _e = (_e + "").toLowerCase(), Ie = !0;
        }
      }).apply(this, arguments);
    }, re.prototype.equals = function(fe) {
      if (!re.isBuffer(fe)) throw new TypeError("Argument must be a Buffer");
      return this === fe || re.compare(this, fe) === 0;
    }, re.prototype.inspect = function() {
      var fe = "", _e = L.INSPECT_MAX_BYTES;
      return this.length > 0 && (fe = this.toString("hex", 0, _e).match(/.{2}/g).join(" "), this.length > _e && (fe += " ... ")), "<Buffer " + fe + ">";
    }, re.prototype.compare = function(fe, _e, je, Ne, Ie) {
      if (!re.isBuffer(fe)) throw new TypeError("Argument must be a Buffer");
      if (_e === void 0 && (_e = 0), je === void 0 && (je = fe ? fe.length : 0), Ne === void 0 && (Ne = 0), Ie === void 0 && (Ie = this.length), _e < 0 || je > fe.length || Ne < 0 || Ie > this.length) throw new RangeError("out of range index");
      if (Ne >= Ie && _e >= je) return 0;
      if (Ne >= Ie) return -1;
      if (_e >= je) return 1;
      if (_e >>>= 0, je >>>= 0, Ne >>>= 0, Ie >>>= 0, this === fe) return 0;
      for (var Xe = Ie - Ne, ft = je - _e, It = Math.min(Xe, ft), jt = this.slice(Ne, Ie), Ot = fe.slice(_e, je), Ut = 0; Ut < It; ++Ut) if (jt[Ut] !== Ot[Ut]) {
        Xe = jt[Ut], ft = Ot[Ut];
        break;
      }
      return Xe < ft ? -1 : ft < Xe ? 1 : 0;
    }, re.prototype.includes = function(fe, _e, je) {
      return this.indexOf(fe, _e, je) !== -1;
    }, re.prototype.indexOf = function(fe, _e, je) {
      return he(this, fe, _e, je, !0);
    }, re.prototype.lastIndexOf = function(fe, _e, je) {
      return he(this, fe, _e, je, !1);
    }, re.prototype.write = function(fe, _e, je, Ne) {
      if (_e === void 0) Ne = "utf8", je = this.length, _e = 0;
      else if (je === void 0 && typeof _e == "string") Ne = _e, je = this.length, _e = 0;
      else {
        if (!isFinite(_e)) throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
        _e |= 0, isFinite(je) ? (je |= 0, Ne === void 0 && (Ne = "utf8")) : (Ne = je, je = void 0);
      }
      var Ie = this.length - _e;
      if ((je === void 0 || je > Ie) && (je = Ie), fe.length > 0 && (je < 0 || _e < 0) || _e > this.length) throw new RangeError("Attempt to write outside buffer bounds");
      Ne || (Ne = "utf8");
      for (var Xe = !1; ; ) switch (Ne) {
        case "hex":
          return Ce(this, fe, _e, je);
        case "utf8":
        case "utf-8":
          return Se(this, fe, _e, je);
        case "ascii":
          return Ae(this, fe, _e, je);
        case "latin1":
        case "binary":
          return Le(this, fe, _e, je);
        case "base64":
          return ve(this, fe, _e, je);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return De(this, fe, _e, je);
        default:
          if (Xe) throw new TypeError("Unknown encoding: " + Ne);
          Ne = ("" + Ne).toLowerCase(), Xe = !0;
      }
    }, re.prototype.toJSON = function() {
      return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
    };
    var We = 4096;
    function Ke(fe, _e, je) {
      var Ne = "";
      je = Math.min(fe.length, je);
      for (var Ie = _e; Ie < je; ++Ie) Ne += String.fromCharCode(127 & fe[Ie]);
      return Ne;
    }
    function it(fe, _e, je) {
      var Ne = "";
      je = Math.min(fe.length, je);
      for (var Ie = _e; Ie < je; ++Ie) Ne += String.fromCharCode(fe[Ie]);
      return Ne;
    }
    function Qe(fe, _e, je) {
      var Ne = fe.length;
      (!_e || _e < 0) && (_e = 0), (!je || je < 0 || je > Ne) && (je = Ne);
      for (var Ie = "", Xe = _e; Xe < je; ++Xe) Ie += Ye(fe[Xe]);
      return Ie;
    }
    function vt(fe, _e, je) {
      for (var Ne = fe.slice(_e, je), Ie = "", Xe = 0; Xe < Ne.length; Xe += 2) Ie += String.fromCharCode(Ne[Xe] + 256 * Ne[Xe + 1]);
      return Ie;
    }
    function Ct(fe, _e, je) {
      if (fe % 1 != 0 || fe < 0) throw new RangeError("offset is not uint");
      if (fe + _e > je) throw new RangeError("Trying to access beyond buffer length");
    }
    function Tt(fe, _e, je, Ne, Ie, Xe) {
      if (!re.isBuffer(fe)) throw new TypeError('"buffer" argument must be a Buffer instance');
      if (_e > Ie || _e < Xe) throw new RangeError('"value" argument is out of bounds');
      if (je + Ne > fe.length) throw new RangeError("Index out of range");
    }
    function St(fe, _e, je, Ne) {
      _e < 0 && (_e = 65535 + _e + 1);
      for (var Ie = 0, Xe = Math.min(fe.length - je, 2); Ie < Xe; ++Ie) fe[je + Ie] = (_e & 255 << 8 * (Ne ? Ie : 1 - Ie)) >>> 8 * (Ne ? Ie : 1 - Ie);
    }
    function Je(fe, _e, je, Ne) {
      _e < 0 && (_e = 4294967295 + _e + 1);
      for (var Ie = 0, Xe = Math.min(fe.length - je, 4); Ie < Xe; ++Ie) fe[je + Ie] = _e >>> 8 * (Ne ? Ie : 3 - Ie) & 255;
    }
    function He(fe, _e, je, Ne, Ie, Xe) {
      if (je + Ne > fe.length) throw new RangeError("Index out of range");
      if (je < 0) throw new RangeError("Index out of range");
    }
    function qe(fe, _e, je, Ne, Ie) {
      return Ie || He(fe, 0, je, 4), J.write(fe, _e, je, Ne, 23, 4), je + 4;
    }
    function Ze(fe, _e, je, Ne, Ie) {
      return Ie || He(fe, 0, je, 8), J.write(fe, _e, je, Ne, 52, 8), je + 8;
    }
    re.prototype.slice = function(fe, _e) {
      var je, Ne = this.length;
      if (fe = ~~fe, _e = _e === void 0 ? Ne : ~~_e, fe < 0 ? (fe += Ne) < 0 && (fe = 0) : fe > Ne && (fe = Ne), _e < 0 ? (_e += Ne) < 0 && (_e = 0) : _e > Ne && (_e = Ne), _e < fe && (_e = fe), re.TYPED_ARRAY_SUPPORT) (je = this.subarray(fe, _e)).__proto__ = re.prototype;
      else {
        var Ie = _e - fe;
        je = new re(Ie, void 0);
        for (var Xe = 0; Xe < Ie; ++Xe) je[Xe] = this[Xe + fe];
      }
      return je;
    }, re.prototype.readUIntLE = function(fe, _e, je) {
      fe |= 0, _e |= 0, je || Ct(fe, _e, this.length);
      for (var Ne = this[fe], Ie = 1, Xe = 0; ++Xe < _e && (Ie *= 256); ) Ne += this[fe + Xe] * Ie;
      return Ne;
    }, re.prototype.readUIntBE = function(fe, _e, je) {
      fe |= 0, _e |= 0, je || Ct(fe, _e, this.length);
      for (var Ne = this[fe + --_e], Ie = 1; _e > 0 && (Ie *= 256); ) Ne += this[fe + --_e] * Ie;
      return Ne;
    }, re.prototype.readUInt8 = function(fe, _e) {
      return _e || Ct(fe, 1, this.length), this[fe];
    }, re.prototype.readUInt16LE = function(fe, _e) {
      return _e || Ct(fe, 2, this.length), this[fe] | this[fe + 1] << 8;
    }, re.prototype.readUInt16BE = function(fe, _e) {
      return _e || Ct(fe, 2, this.length), this[fe] << 8 | this[fe + 1];
    }, re.prototype.readUInt32LE = function(fe, _e) {
      return _e || Ct(fe, 4, this.length), (this[fe] | this[fe + 1] << 8 | this[fe + 2] << 16) + 16777216 * this[fe + 3];
    }, re.prototype.readUInt32BE = function(fe, _e) {
      return _e || Ct(fe, 4, this.length), 16777216 * this[fe] + (this[fe + 1] << 16 | this[fe + 2] << 8 | this[fe + 3]);
    }, re.prototype.readIntLE = function(fe, _e, je) {
      fe |= 0, _e |= 0, je || Ct(fe, _e, this.length);
      for (var Ne = this[fe], Ie = 1, Xe = 0; ++Xe < _e && (Ie *= 256); ) Ne += this[fe + Xe] * Ie;
      return Ne >= (Ie *= 128) && (Ne -= Math.pow(2, 8 * _e)), Ne;
    }, re.prototype.readIntBE = function(fe, _e, je) {
      fe |= 0, _e |= 0, je || Ct(fe, _e, this.length);
      for (var Ne = _e, Ie = 1, Xe = this[fe + --Ne]; Ne > 0 && (Ie *= 256); ) Xe += this[fe + --Ne] * Ie;
      return Xe >= (Ie *= 128) && (Xe -= Math.pow(2, 8 * _e)), Xe;
    }, re.prototype.readInt8 = function(fe, _e) {
      return _e || Ct(fe, 1, this.length), 128 & this[fe] ? -1 * (255 - this[fe] + 1) : this[fe];
    }, re.prototype.readInt16LE = function(fe, _e) {
      _e || Ct(fe, 2, this.length);
      var je = this[fe] | this[fe + 1] << 8;
      return 32768 & je ? 4294901760 | je : je;
    }, re.prototype.readInt16BE = function(fe, _e) {
      _e || Ct(fe, 2, this.length);
      var je = this[fe + 1] | this[fe] << 8;
      return 32768 & je ? 4294901760 | je : je;
    }, re.prototype.readInt32LE = function(fe, _e) {
      return _e || Ct(fe, 4, this.length), this[fe] | this[fe + 1] << 8 | this[fe + 2] << 16 | this[fe + 3] << 24;
    }, re.prototype.readInt32BE = function(fe, _e) {
      return _e || Ct(fe, 4, this.length), this[fe] << 24 | this[fe + 1] << 16 | this[fe + 2] << 8 | this[fe + 3];
    }, re.prototype.readFloatLE = function(fe, _e) {
      return _e || Ct(fe, 4, this.length), J.read(this, fe, !0, 23, 4);
    }, re.prototype.readFloatBE = function(fe, _e) {
      return _e || Ct(fe, 4, this.length), J.read(this, fe, !1, 23, 4);
    }, re.prototype.readDoubleLE = function(fe, _e) {
      return _e || Ct(fe, 8, this.length), J.read(this, fe, !0, 52, 8);
    }, re.prototype.readDoubleBE = function(fe, _e) {
      return _e || Ct(fe, 8, this.length), J.read(this, fe, !1, 52, 8);
    }, re.prototype.writeUIntLE = function(fe, _e, je, Ne) {
      fe = +fe, _e |= 0, je |= 0, Ne || Tt(this, fe, _e, je, Math.pow(2, 8 * je) - 1, 0);
      var Ie = 1, Xe = 0;
      for (this[_e] = 255 & fe; ++Xe < je && (Ie *= 256); ) this[_e + Xe] = fe / Ie & 255;
      return _e + je;
    }, re.prototype.writeUIntBE = function(fe, _e, je, Ne) {
      fe = +fe, _e |= 0, je |= 0, Ne || Tt(this, fe, _e, je, Math.pow(2, 8 * je) - 1, 0);
      var Ie = je - 1, Xe = 1;
      for (this[_e + Ie] = 255 & fe; --Ie >= 0 && (Xe *= 256); ) this[_e + Ie] = fe / Xe & 255;
      return _e + je;
    }, re.prototype.writeUInt8 = function(fe, _e, je) {
      return fe = +fe, _e |= 0, je || Tt(this, fe, _e, 1, 255, 0), re.TYPED_ARRAY_SUPPORT || (fe = Math.floor(fe)), this[_e] = 255 & fe, _e + 1;
    }, re.prototype.writeUInt16LE = function(fe, _e, je) {
      return fe = +fe, _e |= 0, je || Tt(this, fe, _e, 2, 65535, 0), re.TYPED_ARRAY_SUPPORT ? (this[_e] = 255 & fe, this[_e + 1] = fe >>> 8) : St(this, fe, _e, !0), _e + 2;
    }, re.prototype.writeUInt16BE = function(fe, _e, je) {
      return fe = +fe, _e |= 0, je || Tt(this, fe, _e, 2, 65535, 0), re.TYPED_ARRAY_SUPPORT ? (this[_e] = fe >>> 8, this[_e + 1] = 255 & fe) : St(this, fe, _e, !1), _e + 2;
    }, re.prototype.writeUInt32LE = function(fe, _e, je) {
      return fe = +fe, _e |= 0, je || Tt(this, fe, _e, 4, 4294967295, 0), re.TYPED_ARRAY_SUPPORT ? (this[_e + 3] = fe >>> 24, this[_e + 2] = fe >>> 16, this[_e + 1] = fe >>> 8, this[_e] = 255 & fe) : Je(this, fe, _e, !0), _e + 4;
    }, re.prototype.writeUInt32BE = function(fe, _e, je) {
      return fe = +fe, _e |= 0, je || Tt(this, fe, _e, 4, 4294967295, 0), re.TYPED_ARRAY_SUPPORT ? (this[_e] = fe >>> 24, this[_e + 1] = fe >>> 16, this[_e + 2] = fe >>> 8, this[_e + 3] = 255 & fe) : Je(this, fe, _e, !1), _e + 4;
    }, re.prototype.writeIntLE = function(fe, _e, je, Ne) {
      if (fe = +fe, _e |= 0, !Ne) {
        var Ie = Math.pow(2, 8 * je - 1);
        Tt(this, fe, _e, je, Ie - 1, -Ie);
      }
      var Xe = 0, ft = 1, It = 0;
      for (this[_e] = 255 & fe; ++Xe < je && (ft *= 256); ) fe < 0 && It === 0 && this[_e + Xe - 1] !== 0 && (It = 1), this[_e + Xe] = (fe / ft >> 0) - It & 255;
      return _e + je;
    }, re.prototype.writeIntBE = function(fe, _e, je, Ne) {
      if (fe = +fe, _e |= 0, !Ne) {
        var Ie = Math.pow(2, 8 * je - 1);
        Tt(this, fe, _e, je, Ie - 1, -Ie);
      }
      var Xe = je - 1, ft = 1, It = 0;
      for (this[_e + Xe] = 255 & fe; --Xe >= 0 && (ft *= 256); ) fe < 0 && It === 0 && this[_e + Xe + 1] !== 0 && (It = 1), this[_e + Xe] = (fe / ft >> 0) - It & 255;
      return _e + je;
    }, re.prototype.writeInt8 = function(fe, _e, je) {
      return fe = +fe, _e |= 0, je || Tt(this, fe, _e, 1, 127, -128), re.TYPED_ARRAY_SUPPORT || (fe = Math.floor(fe)), fe < 0 && (fe = 255 + fe + 1), this[_e] = 255 & fe, _e + 1;
    }, re.prototype.writeInt16LE = function(fe, _e, je) {
      return fe = +fe, _e |= 0, je || Tt(this, fe, _e, 2, 32767, -32768), re.TYPED_ARRAY_SUPPORT ? (this[_e] = 255 & fe, this[_e + 1] = fe >>> 8) : St(this, fe, _e, !0), _e + 2;
    }, re.prototype.writeInt16BE = function(fe, _e, je) {
      return fe = +fe, _e |= 0, je || Tt(this, fe, _e, 2, 32767, -32768), re.TYPED_ARRAY_SUPPORT ? (this[_e] = fe >>> 8, this[_e + 1] = 255 & fe) : St(this, fe, _e, !1), _e + 2;
    }, re.prototype.writeInt32LE = function(fe, _e, je) {
      return fe = +fe, _e |= 0, je || Tt(this, fe, _e, 4, 2147483647, -2147483648), re.TYPED_ARRAY_SUPPORT ? (this[_e] = 255 & fe, this[_e + 1] = fe >>> 8, this[_e + 2] = fe >>> 16, this[_e + 3] = fe >>> 24) : Je(this, fe, _e, !0), _e + 4;
    }, re.prototype.writeInt32BE = function(fe, _e, je) {
      return fe = +fe, _e |= 0, je || Tt(this, fe, _e, 4, 2147483647, -2147483648), fe < 0 && (fe = 4294967295 + fe + 1), re.TYPED_ARRAY_SUPPORT ? (this[_e] = fe >>> 24, this[_e + 1] = fe >>> 16, this[_e + 2] = fe >>> 8, this[_e + 3] = 255 & fe) : Je(this, fe, _e, !1), _e + 4;
    }, re.prototype.writeFloatLE = function(fe, _e, je) {
      return qe(this, fe, _e, !0, je);
    }, re.prototype.writeFloatBE = function(fe, _e, je) {
      return qe(this, fe, _e, !1, je);
    }, re.prototype.writeDoubleLE = function(fe, _e, je) {
      return Ze(this, fe, _e, !0, je);
    }, re.prototype.writeDoubleBE = function(fe, _e, je) {
      return Ze(this, fe, _e, !1, je);
    }, re.prototype.copy = function(fe, _e, je, Ne) {
      if (je || (je = 0), Ne || Ne === 0 || (Ne = this.length), _e >= fe.length && (_e = fe.length), _e || (_e = 0), Ne > 0 && Ne < je && (Ne = je), Ne === je || fe.length === 0 || this.length === 0) return 0;
      if (_e < 0) throw new RangeError("targetStart out of bounds");
      if (je < 0 || je >= this.length) throw new RangeError("sourceStart out of bounds");
      if (Ne < 0) throw new RangeError("sourceEnd out of bounds");
      Ne > this.length && (Ne = this.length), fe.length - _e < Ne - je && (Ne = fe.length - _e + je);
      var Ie, Xe = Ne - je;
      if (this === fe && je < _e && _e < Ne) for (Ie = Xe - 1; Ie >= 0; --Ie) fe[Ie + _e] = this[Ie + je];
      else if (Xe < 1e3 || !re.TYPED_ARRAY_SUPPORT) for (Ie = 0; Ie < Xe; ++Ie) fe[Ie + _e] = this[Ie + je];
      else Uint8Array.prototype.set.call(fe, this.subarray(je, je + Xe), _e);
      return Xe;
    }, re.prototype.fill = function(fe, _e, je, Ne) {
      if (typeof fe == "string") {
        if (typeof _e == "string" ? (Ne = _e, _e = 0, je = this.length) : typeof je == "string" && (Ne = je, je = this.length), fe.length === 1) {
          var Ie = fe.charCodeAt(0);
          Ie < 256 && (fe = Ie);
        }
        if (Ne !== void 0 && typeof Ne != "string") throw new TypeError("encoding must be a string");
        if (typeof Ne == "string" && !re.isEncoding(Ne)) throw new TypeError("Unknown encoding: " + Ne);
      } else typeof fe == "number" && (fe &= 255);
      if (_e < 0 || this.length < _e || this.length < je) throw new RangeError("Out of range index");
      if (je <= _e) return this;
      var Xe;
      if (_e >>>= 0, je = je === void 0 ? this.length : je >>> 0, fe || (fe = 0), typeof fe == "number") for (Xe = _e; Xe < je; ++Xe) this[Xe] = fe;
      else {
        var ft = re.isBuffer(fe) ? fe : ot(new re(fe, Ne).toString()), It = ft.length;
        for (Xe = 0; Xe < je - _e; ++Xe) this[Xe + _e] = ft[Xe % It];
      }
      return this;
    };
    var Pe = /[^+\/0-9A-Za-z-_]/g;
    function Ye(fe) {
      return fe < 16 ? "0" + fe.toString(16) : fe.toString(16);
    }
    function ot(fe, _e) {
      var je;
      _e = _e || 1 / 0;
      for (var Ne = fe.length, Ie = null, Xe = [], ft = 0; ft < Ne; ++ft) {
        if ((je = fe.charCodeAt(ft)) > 55295 && je < 57344) {
          if (!Ie) {
            if (je > 56319) {
              (_e -= 3) > -1 && Xe.push(239, 191, 189);
              continue;
            }
            if (ft + 1 === Ne) {
              (_e -= 3) > -1 && Xe.push(239, 191, 189);
              continue;
            }
            Ie = je;
            continue;
          }
          if (je < 56320) {
            (_e -= 3) > -1 && Xe.push(239, 191, 189), Ie = je;
            continue;
          }
          je = 65536 + (Ie - 55296 << 10 | je - 56320);
        } else Ie && (_e -= 3) > -1 && Xe.push(239, 191, 189);
        if (Ie = null, je < 128) {
          if ((_e -= 1) < 0) break;
          Xe.push(je);
        } else if (je < 2048) {
          if ((_e -= 2) < 0) break;
          Xe.push(je >> 6 | 192, 63 & je | 128);
        } else if (je < 65536) {
          if ((_e -= 3) < 0) break;
          Xe.push(je >> 12 | 224, je >> 6 & 63 | 128, 63 & je | 128);
        } else {
          if (!(je < 1114112)) throw new Error("Invalid code point");
          if ((_e -= 4) < 0) break;
          Xe.push(je >> 18 | 240, je >> 12 & 63 | 128, je >> 6 & 63 | 128, 63 & je | 128);
        }
      }
      return Xe;
    }
    function Be(fe) {
      return X.toByteArray(function(_e) {
        if ((_e = function(je) {
          return je.trim ? je.trim() : je.replace(/^\s+|\s+$/g, "");
        }(_e).replace(Pe, "")).length < 2) return "";
        for (; _e.length % 4 != 0; ) _e += "=";
        return _e;
      }(fe));
    }
    function Ve(fe, _e, je, Ne) {
      for (var Ie = 0; Ie < Ne && !(Ie + je >= _e.length || Ie >= fe.length); ++Ie) _e[Ie + je] = fe[Ie];
      return Ie;
    }
  }).call(this, A(0));
}, function(C, L) {
  var A, W, X = C.exports = {};
  function J() {
    throw new Error("setTimeout has not been defined");
  }
  function te() {
    throw new Error("clearTimeout has not been defined");
  }
  function oe(Me) {
    if (A === setTimeout) return setTimeout(Me, 0);
    if ((A === J || !A) && setTimeout) return A = setTimeout, setTimeout(Me, 0);
    try {
      return A(Me, 0);
    } catch {
      try {
        return A.call(null, Me, 0);
      } catch {
        return A.call(this, Me, 0);
      }
    }
  }
  (function() {
    try {
      A = typeof setTimeout == "function" ? setTimeout : J;
    } catch {
      A = J;
    }
    try {
      W = typeof clearTimeout == "function" ? clearTimeout : te;
    } catch {
      W = te;
    }
  })();
  var ne, re = [], ce = !1, ue = -1;
  function de() {
    ce && ne && (ce = !1, ne.length ? re = ne.concat(re) : ue = -1, re.length && be());
  }
  function be() {
    if (!ce) {
      var Me = oe(de);
      ce = !0;
      for (var he = re.length; he; ) {
        for (ne = re, re = []; ++ue < he; ) ne && ne[ue].run();
        ue = -1, he = re.length;
      }
      ne = null, ce = !1, function(ge) {
        if (W === clearTimeout) return clearTimeout(ge);
        if ((W === te || !W) && clearTimeout) return W = clearTimeout, clearTimeout(ge);
        try {
          W(ge);
        } catch {
          try {
            return W.call(null, ge);
          } catch {
            return W.call(this, ge);
          }
        }
      }(Me);
    }
  }
  function pe(Me, he) {
    this.fun = Me, this.array = he;
  }
  function me() {
  }
  X.nextTick = function(Me) {
    var he = new Array(arguments.length - 1);
    if (arguments.length > 1) for (var ge = 1; ge < arguments.length; ge++) he[ge - 1] = arguments[ge];
    re.push(new pe(Me, he)), re.length !== 1 || ce || oe(be);
  }, pe.prototype.run = function() {
    this.fun.apply(null, this.array);
  }, X.title = "browser", X.browser = !0, X.env = {}, X.argv = [], X.version = "", X.versions = {}, X.on = me, X.addListener = me, X.once = me, X.off = me, X.removeListener = me, X.removeAllListeners = me, X.emit = me, X.prependListener = me, X.prependOnceListener = me, X.listeners = function(Me) {
    return [];
  }, X.binding = function(Me) {
    throw new Error("process.binding is not supported");
  }, X.cwd = function() {
    return "/";
  }, X.chdir = function(Me) {
    throw new Error("process.chdir is not supported");
  }, X.umask = function() {
    return 0;
  };
}, function(C, L, A) {
  (function(W) {
    function X(J) {
      return Object.prototype.toString.call(J);
    }
    L.isArray = function(J) {
      return Array.isArray ? Array.isArray(J) : X(J) === "[object Array]";
    }, L.isBoolean = function(J) {
      return typeof J == "boolean";
    }, L.isNull = function(J) {
      return J === null;
    }, L.isNullOrUndefined = function(J) {
      return J == null;
    }, L.isNumber = function(J) {
      return typeof J == "number";
    }, L.isString = function(J) {
      return typeof J == "string";
    }, L.isSymbol = function(J) {
      return typeof J == "symbol";
    }, L.isUndefined = function(J) {
      return J === void 0;
    }, L.isRegExp = function(J) {
      return X(J) === "[object RegExp]";
    }, L.isObject = function(J) {
      return typeof J == "object" && J !== null;
    }, L.isDate = function(J) {
      return X(J) === "[object Date]";
    }, L.isError = function(J) {
      return X(J) === "[object Error]" || J instanceof Error;
    }, L.isFunction = function(J) {
      return typeof J == "function";
    }, L.isPrimitive = function(J) {
      return J === null || typeof J == "boolean" || typeof J == "number" || typeof J == "string" || typeof J == "symbol" || J === void 0;
    }, L.isBuffer = W.isBuffer;
  }).call(this, A(3).Buffer);
}, function(C, L, A) {
  (function(W) {
    !W.version || W.version.indexOf("v0.") === 0 || W.version.indexOf("v1.") === 0 && W.version.indexOf("v1.8.") !== 0 ? C.exports = { nextTick: function(X, J, te, oe) {
      if (typeof X != "function") throw new TypeError('"callback" argument must be a function');
      var ne, re, ce = arguments.length;
      switch (ce) {
        case 0:
        case 1:
          return W.nextTick(X);
        case 2:
          return W.nextTick(function() {
            X.call(null, J);
          });
        case 3:
          return W.nextTick(function() {
            X.call(null, J, te);
          });
        case 4:
          return W.nextTick(function() {
            X.call(null, J, te, oe);
          });
        default:
          for (ne = new Array(ce - 1), re = 0; re < ne.length; ) ne[re++] = arguments[re];
          return W.nextTick(function() {
            X.apply(null, ne);
          });
      }
    } } : C.exports = W;
  }).call(this, A(4));
}, function(C, L, A) {
  var W = A(3), X = W.Buffer;
  function J(oe, ne) {
    for (var re in oe) ne[re] = oe[re];
  }
  function te(oe, ne, re) {
    return X(oe, ne, re);
  }
  X.from && X.alloc && X.allocUnsafe && X.allocUnsafeSlow ? C.exports = W : (J(W, L), L.Buffer = te), J(X, te), te.from = function(oe, ne, re) {
    if (typeof oe == "number") throw new TypeError("Argument must not be a number");
    return X(oe, ne, re);
  }, te.alloc = function(oe, ne, re) {
    if (typeof oe != "number") throw new TypeError("Argument must be a number");
    var ce = X(oe);
    return ne !== void 0 ? typeof re == "string" ? ce.fill(ne, re) : ce.fill(ne) : ce.fill(0), ce;
  }, te.allocUnsafe = function(oe) {
    if (typeof oe != "number") throw new TypeError("Argument must be a number");
    return X(oe);
  }, te.allocUnsafeSlow = function(oe) {
    if (typeof oe != "number") throw new TypeError("Argument must be a number");
    return W.SlowBuffer(oe);
  };
}, function(C, L, A) {
  var W = A(17)(Object, "create");
  C.exports = W;
}, function(C, L, A) {
  var W = A(31);
  C.exports = function(X, J) {
    for (var te = X.length; te--; ) if (W(X[te][0], J)) return te;
    return -1;
  };
}, function(C, L, A) {
  var W = A(96);
  C.exports = function(X, J) {
    var te = X.__data__;
    return W(J) ? te[typeof J == "string" ? "string" : "hash"] : te.map;
  };
}, function(C, L, A) {
  (function(W) {
    var X = W !== void 0 && W || typeof self < "u" && self || window, J = Function.prototype.apply;
    function te(oe, ne) {
      this._id = oe, this._clearFn = ne;
    }
    L.setTimeout = function() {
      return new te(J.call(setTimeout, X, arguments), clearTimeout);
    }, L.setInterval = function() {
      return new te(J.call(setInterval, X, arguments), clearInterval);
    }, L.clearTimeout = L.clearInterval = function(oe) {
      oe && oe.close();
    }, te.prototype.unref = te.prototype.ref = function() {
    }, te.prototype.close = function() {
      this._clearFn.call(X, this._id);
    }, L.enroll = function(oe, ne) {
      clearTimeout(oe._idleTimeoutId), oe._idleTimeout = ne;
    }, L.unenroll = function(oe) {
      clearTimeout(oe._idleTimeoutId), oe._idleTimeout = -1;
    }, L._unrefActive = L.active = function(oe) {
      clearTimeout(oe._idleTimeoutId);
      var ne = oe._idleTimeout;
      ne >= 0 && (oe._idleTimeoutId = setTimeout(function() {
        oe._onTimeout && oe._onTimeout();
      }, ne));
    }, A(35), L.setImmediate = typeof self < "u" && self.setImmediate || W !== void 0 && W.setImmediate || this && this.setImmediate, L.clearImmediate = typeof self < "u" && self.clearImmediate || W !== void 0 && W.clearImmediate || this && this.clearImmediate;
  }).call(this, A(0));
}, function(C, L) {
  function A() {
    this._events = this._events || {}, this._maxListeners = this._maxListeners || void 0;
  }
  function W(te) {
    return typeof te == "function";
  }
  function X(te) {
    return typeof te == "object" && te !== null;
  }
  function J(te) {
    return te === void 0;
  }
  C.exports = A, A.EventEmitter = A, A.prototype._events = void 0, A.prototype._maxListeners = void 0, A.defaultMaxListeners = 10, A.prototype.setMaxListeners = function(te) {
    if (!/* @__PURE__ */ function(oe) {
      return typeof oe == "number";
    }(te) || te < 0 || isNaN(te)) throw TypeError("n must be a positive number");
    return this._maxListeners = te, this;
  }, A.prototype.emit = function(te) {
    var oe, ne, re, ce, ue, de;
    if (this._events || (this._events = {}), te === "error" && (!this._events.error || X(this._events.error) && !this._events.error.length)) {
      if ((oe = arguments[1]) instanceof Error) throw oe;
      var be = new Error('Uncaught, unspecified "error" event. (' + oe + ")");
      throw be.context = oe, be;
    }
    if (J(ne = this._events[te])) return !1;
    if (W(ne)) switch (arguments.length) {
      case 1:
        ne.call(this);
        break;
      case 2:
        ne.call(this, arguments[1]);
        break;
      case 3:
        ne.call(this, arguments[1], arguments[2]);
        break;
      default:
        ce = Array.prototype.slice.call(arguments, 1), ne.apply(this, ce);
    }
    else if (X(ne)) for (ce = Array.prototype.slice.call(arguments, 1), re = (de = ne.slice()).length, ue = 0; ue < re; ue++) de[ue].apply(this, ce);
    return !0;
  }, A.prototype.addListener = function(te, oe) {
    var ne;
    if (!W(oe)) throw TypeError("listener must be a function");
    return this._events || (this._events = {}), this._events.newListener && this.emit("newListener", te, W(oe.listener) ? oe.listener : oe), this._events[te] ? X(this._events[te]) ? this._events[te].push(oe) : this._events[te] = [this._events[te], oe] : this._events[te] = oe, X(this._events[te]) && !this._events[te].warned && (ne = J(this._maxListeners) ? A.defaultMaxListeners : this._maxListeners) && ne > 0 && this._events[te].length > ne && (this._events[te].warned = !0, console.error("(node) warning: possible EventEmitter memory leak detected. %d listeners added. Use emitter.setMaxListeners() to increase limit.", this._events[te].length), typeof console.trace == "function" && console.trace()), this;
  }, A.prototype.on = A.prototype.addListener, A.prototype.once = function(te, oe) {
    if (!W(oe)) throw TypeError("listener must be a function");
    var ne = !1;
    function re() {
      this.removeListener(te, re), ne || (ne = !0, oe.apply(this, arguments));
    }
    return re.listener = oe, this.on(te, re), this;
  }, A.prototype.removeListener = function(te, oe) {
    var ne, re, ce, ue;
    if (!W(oe)) throw TypeError("listener must be a function");
    if (!this._events || !this._events[te]) return this;
    if (ce = (ne = this._events[te]).length, re = -1, ne === oe || W(ne.listener) && ne.listener === oe) delete this._events[te], this._events.removeListener && this.emit("removeListener", te, oe);
    else if (X(ne)) {
      for (ue = ce; ue-- > 0; ) if (ne[ue] === oe || ne[ue].listener && ne[ue].listener === oe) {
        re = ue;
        break;
      }
      if (re < 0) return this;
      ne.length === 1 ? (ne.length = 0, delete this._events[te]) : ne.splice(re, 1), this._events.removeListener && this.emit("removeListener", te, oe);
    }
    return this;
  }, A.prototype.removeAllListeners = function(te) {
    var oe, ne;
    if (!this._events) return this;
    if (!this._events.removeListener) return arguments.length === 0 ? this._events = {} : this._events[te] && delete this._events[te], this;
    if (arguments.length === 0) {
      for (oe in this._events) oe !== "removeListener" && this.removeAllListeners(oe);
      return this.removeAllListeners("removeListener"), this._events = {}, this;
    }
    if (W(ne = this._events[te])) this.removeListener(te, ne);
    else if (ne) for (; ne.length; ) this.removeListener(te, ne[ne.length - 1]);
    return delete this._events[te], this;
  }, A.prototype.listeners = function(te) {
    return this._events && this._events[te] ? W(this._events[te]) ? [this._events[te]] : this._events[te].slice() : [];
  }, A.prototype.listenerCount = function(te) {
    if (this._events) {
      var oe = this._events[te];
      if (W(oe)) return 1;
      if (oe) return oe.length;
    }
    return 0;
  }, A.listenerCount = function(te, oe) {
    return te.listenerCount(oe);
  };
}, function(C, L, A) {
  (L = C.exports = A(23)).Stream = L, L.Readable = L, L.Writable = A(14), L.Duplex = A(1), L.Transform = A(27), L.PassThrough = A(45);
}, function(C, L, A) {
  (function(W, X, J) {
    var te = A(6);
    function oe(Fe) {
      var We = this;
      this.next = null, this.entry = null, this.finish = function() {
        (function(Ke, it, Qe) {
          var vt = Ke.entry;
          for (Ke.entry = null; vt; ) {
            var Ct = vt.callback;
            it.pendingcb--, Ct(void 0), vt = vt.next;
          }
          it.corkedRequestsFree ? it.corkedRequestsFree.next = Ke : it.corkedRequestsFree = Ke;
        })(We, Fe);
      };
    }
    C.exports = Ce;
    var ne, re = !W.browser && ["v0.10", "v0.9."].indexOf(W.version.slice(0, 5)) > -1 ? X : te.nextTick;
    Ce.WritableState = ge;
    var ce = A(5);
    ce.inherits = A(2);
    var ue, de = { deprecate: A(44) }, be = A(24), pe = A(7).Buffer, me = J.Uint8Array || function() {
    }, Me = A(25);
    function he() {
    }
    function ge(Fe, We) {
      ne = ne || A(1), Fe = Fe || {};
      var Ke = We instanceof ne;
      this.objectMode = !!Fe.objectMode, Ke && (this.objectMode = this.objectMode || !!Fe.writableObjectMode);
      var it = Fe.highWaterMark, Qe = Fe.writableHighWaterMark, vt = this.objectMode ? 16 : 16384;
      this.highWaterMark = it || it === 0 ? it : Ke && (Qe || Qe === 0) ? Qe : vt, this.highWaterMark = Math.floor(this.highWaterMark), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
      var Ct = Fe.decodeStrings === !1;
      this.decodeStrings = !Ct, this.defaultEncoding = Fe.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function(Tt) {
        (function(St, Je) {
          var He = St._writableState, qe = He.sync, Ze = He.writecb;
          if (function(Ye) {
            Ye.writing = !1, Ye.writecb = null, Ye.length -= Ye.writelen, Ye.writelen = 0;
          }(He), Je) (function(Ye, ot, Be, Ve, fe) {
            --ot.pendingcb, Be ? (te.nextTick(fe, Ve), te.nextTick(Ue, Ye, ot), Ye._writableState.errorEmitted = !0, Ye.emit("error", Ve)) : (fe(Ve), Ye._writableState.errorEmitted = !0, Ye.emit("error", Ve), Ue(Ye, ot));
          })(St, He, qe, Je, Ze);
          else {
            var Pe = ve(He);
            Pe || He.corked || He.bufferProcessing || !He.bufferedRequest || Le(St, He), qe ? re(Ae, St, He, Pe, Ze) : Ae(St, He, Pe, Ze);
          }
        })(We, Tt);
      }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.bufferedRequestCount = 0, this.corkedRequestsFree = new oe(this);
    }
    function Ce(Fe) {
      if (ne = ne || A(1), !(ue.call(Ce, this) || this instanceof ne)) return new Ce(Fe);
      this._writableState = new ge(Fe, this), this.writable = !0, Fe && (typeof Fe.write == "function" && (this._write = Fe.write), typeof Fe.writev == "function" && (this._writev = Fe.writev), typeof Fe.destroy == "function" && (this._destroy = Fe.destroy), typeof Fe.final == "function" && (this._final = Fe.final)), be.call(this);
    }
    function Se(Fe, We, Ke, it, Qe, vt, Ct) {
      We.writelen = it, We.writecb = Ct, We.writing = !0, We.sync = !0, Ke ? Fe._writev(Qe, We.onwrite) : Fe._write(Qe, vt, We.onwrite), We.sync = !1;
    }
    function Ae(Fe, We, Ke, it) {
      Ke || function(Qe, vt) {
        vt.length === 0 && vt.needDrain && (vt.needDrain = !1, Qe.emit("drain"));
      }(Fe, We), We.pendingcb--, it(), Ue(Fe, We);
    }
    function Le(Fe, We) {
      We.bufferProcessing = !0;
      var Ke = We.bufferedRequest;
      if (Fe._writev && Ke && Ke.next) {
        var it = We.bufferedRequestCount, Qe = new Array(it), vt = We.corkedRequestsFree;
        vt.entry = Ke;
        for (var Ct = 0, Tt = !0; Ke; ) Qe[Ct] = Ke, Ke.isBuf || (Tt = !1), Ke = Ke.next, Ct += 1;
        Qe.allBuffers = Tt, Se(Fe, We, !0, We.length, Qe, "", vt.finish), We.pendingcb++, We.lastBufferedRequest = null, vt.next ? (We.corkedRequestsFree = vt.next, vt.next = null) : We.corkedRequestsFree = new oe(We), We.bufferedRequestCount = 0;
      } else {
        for (; Ke; ) {
          var St = Ke.chunk, Je = Ke.encoding, He = Ke.callback;
          if (Se(Fe, We, !1, We.objectMode ? 1 : St.length, St, Je, He), Ke = Ke.next, We.bufferedRequestCount--, We.writing) break;
        }
        Ke === null && (We.lastBufferedRequest = null);
      }
      We.bufferedRequest = Ke, We.bufferProcessing = !1;
    }
    function ve(Fe) {
      return Fe.ending && Fe.length === 0 && Fe.bufferedRequest === null && !Fe.finished && !Fe.writing;
    }
    function De(Fe, We) {
      Fe._final(function(Ke) {
        We.pendingcb--, Ke && Fe.emit("error", Ke), We.prefinished = !0, Fe.emit("prefinish"), Ue(Fe, We);
      });
    }
    function Ue(Fe, We) {
      var Ke = ve(We);
      return Ke && (function(it, Qe) {
        Qe.prefinished || Qe.finalCalled || (typeof it._final == "function" ? (Qe.pendingcb++, Qe.finalCalled = !0, te.nextTick(De, it, Qe)) : (Qe.prefinished = !0, it.emit("prefinish")));
      }(Fe, We), We.pendingcb === 0 && (We.finished = !0, Fe.emit("finish"))), Ke;
    }
    ce.inherits(Ce, be), ge.prototype.getBuffer = function() {
      for (var Fe = this.bufferedRequest, We = []; Fe; ) We.push(Fe), Fe = Fe.next;
      return We;
    }, function() {
      try {
        Object.defineProperty(ge.prototype, "buffer", { get: de.deprecate(function() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003") });
      } catch {
      }
    }(), typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (ue = Function.prototype[Symbol.hasInstance], Object.defineProperty(Ce, Symbol.hasInstance, { value: function(Fe) {
      return !!ue.call(this, Fe) || this === Ce && Fe && Fe._writableState instanceof ge;
    } })) : ue = function(Fe) {
      return Fe instanceof this;
    }, Ce.prototype.pipe = function() {
      this.emit("error", new Error("Cannot pipe, not readable"));
    }, Ce.prototype.write = function(Fe, We, Ke) {
      var it = this._writableState, Qe = !1, vt = !it.objectMode && function(Ct) {
        return pe.isBuffer(Ct) || Ct instanceof me;
      }(Fe);
      return vt && !pe.isBuffer(Fe) && (Fe = function(Ct) {
        return pe.from(Ct);
      }(Fe)), typeof We == "function" && (Ke = We, We = null), vt ? We = "buffer" : We || (We = it.defaultEncoding), typeof Ke != "function" && (Ke = he), it.ended ? function(Ct, Tt) {
        var St = new Error("write after end");
        Ct.emit("error", St), te.nextTick(Tt, St);
      }(this, Ke) : (vt || function(Ct, Tt, St, Je) {
        var He = !0, qe = !1;
        return St === null ? qe = new TypeError("May not write null values to stream") : typeof St == "string" || St === void 0 || Tt.objectMode || (qe = new TypeError("Invalid non-string/buffer chunk")), qe && (Ct.emit("error", qe), te.nextTick(Je, qe), He = !1), He;
      }(this, it, Fe, Ke)) && (it.pendingcb++, Qe = function(Ct, Tt, St, Je, He, qe) {
        if (!St) {
          var Ze = function(Be, Ve, fe) {
            return Be.objectMode || Be.decodeStrings === !1 || typeof Ve != "string" || (Ve = pe.from(Ve, fe)), Ve;
          }(Tt, Je, He);
          Je !== Ze && (St = !0, He = "buffer", Je = Ze);
        }
        var Pe = Tt.objectMode ? 1 : Je.length;
        Tt.length += Pe;
        var Ye = Tt.length < Tt.highWaterMark;
        if (Ye || (Tt.needDrain = !0), Tt.writing || Tt.corked) {
          var ot = Tt.lastBufferedRequest;
          Tt.lastBufferedRequest = { chunk: Je, encoding: He, isBuf: St, callback: qe, next: null }, ot ? ot.next = Tt.lastBufferedRequest : Tt.bufferedRequest = Tt.lastBufferedRequest, Tt.bufferedRequestCount += 1;
        } else Se(Ct, Tt, !1, Pe, Je, He, qe);
        return Ye;
      }(this, it, vt, Fe, We, Ke)), Qe;
    }, Ce.prototype.cork = function() {
      this._writableState.corked++;
    }, Ce.prototype.uncork = function() {
      var Fe = this._writableState;
      Fe.corked && (Fe.corked--, Fe.writing || Fe.corked || Fe.finished || Fe.bufferProcessing || !Fe.bufferedRequest || Le(this, Fe));
    }, Ce.prototype.setDefaultEncoding = function(Fe) {
      if (typeof Fe == "string" && (Fe = Fe.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((Fe + "").toLowerCase()) > -1)) throw new TypeError("Unknown encoding: " + Fe);
      return this._writableState.defaultEncoding = Fe, this;
    }, Object.defineProperty(Ce.prototype, "writableHighWaterMark", { enumerable: !1, get: function() {
      return this._writableState.highWaterMark;
    } }), Ce.prototype._write = function(Fe, We, Ke) {
      Ke(new Error("_write() is not implemented"));
    }, Ce.prototype._writev = null, Ce.prototype.end = function(Fe, We, Ke) {
      var it = this._writableState;
      typeof Fe == "function" ? (Ke = Fe, Fe = null, We = null) : typeof We == "function" && (Ke = We, We = null), Fe != null && this.write(Fe, We), it.corked && (it.corked = 1, this.uncork()), it.ending || it.finished || function(Qe, vt, Ct) {
        vt.ending = !0, Ue(Qe, vt), Ct && (vt.finished ? te.nextTick(Ct) : Qe.once("finish", Ct)), vt.ended = !0, Qe.writable = !1;
      }(this, it, Ke);
    }, Object.defineProperty(Ce.prototype, "destroyed", { get: function() {
      return this._writableState !== void 0 && this._writableState.destroyed;
    }, set: function(Fe) {
      this._writableState && (this._writableState.destroyed = Fe);
    } }), Ce.prototype.destroy = Me.destroy, Ce.prototype._undestroy = Me.undestroy, Ce.prototype._destroy = function(Fe, We) {
      this.end(), We(Fe);
    };
  }).call(this, A(4), A(11).setImmediate, A(0));
}, function(C, L, A) {
  (function(W, X, J) {
    C.exports = function te(oe, ne, re) {
      function ce(be, pe) {
        if (!ne[be]) {
          if (!oe[be]) {
            var me = typeof _dereq_ == "function" && _dereq_;
            if (!pe && me) return me(be, !0);
            if (ue) return ue(be, !0);
            var Me = new Error("Cannot find module '" + be + "'");
            throw Me.code = "MODULE_NOT_FOUND", Me;
          }
          var he = ne[be] = { exports: {} };
          oe[be][0].call(he.exports, function(ge) {
            return ce(oe[be][1][ge] || ge);
          }, he, he.exports, te, oe, ne, re);
        }
        return ne[be].exports;
      }
      for (var ue = typeof _dereq_ == "function" && _dereq_, de = 0; de < re.length; de++) ce(re[de]);
      return ce;
    }({ 1: [function(te, oe, ne) {
      oe.exports = function(re) {
        var ce = re._SomePromiseArray;
        function ue(de) {
          var be = new ce(de), pe = be.promise();
          return be.setHowMany(1), be.setUnwrap(), be.init(), pe;
        }
        re.any = function(de) {
          return ue(de);
        }, re.prototype.any = function() {
          return ue(this);
        };
      };
    }, {}], 2: [function(te, oe, ne) {
      var re;
      try {
        throw new Error();
      } catch (he) {
        re = he;
      }
      var ce = te("./schedule"), ue = te("./queue"), de = te("./util");
      function be() {
        this._customScheduler = !1, this._isTickUsed = !1, this._lateQueue = new ue(16), this._normalQueue = new ue(16), this._haveDrainedQueues = !1, this._trampolineEnabled = !0;
        var he = this;
        this.drainQueues = function() {
          he._drainQueues();
        }, this._schedule = ce;
      }
      function pe(he, ge, Ce) {
        this._lateQueue.push(he, ge, Ce), this._queueTick();
      }
      function me(he, ge, Ce) {
        this._normalQueue.push(he, ge, Ce), this._queueTick();
      }
      function Me(he) {
        this._normalQueue._pushOne(he), this._queueTick();
      }
      be.prototype.setScheduler = function(he) {
        var ge = this._schedule;
        return this._schedule = he, this._customScheduler = !0, ge;
      }, be.prototype.hasCustomScheduler = function() {
        return this._customScheduler;
      }, be.prototype.enableTrampoline = function() {
        this._trampolineEnabled = !0;
      }, be.prototype.disableTrampolineIfNecessary = function() {
        de.hasDevTools && (this._trampolineEnabled = !1);
      }, be.prototype.haveItemsQueued = function() {
        return this._isTickUsed || this._haveDrainedQueues;
      }, be.prototype.fatalError = function(he, ge) {
        ge ? (W.stderr.write("Fatal " + (he instanceof Error ? he.stack : he) + `
`), W.exit(2)) : this.throwLater(he);
      }, be.prototype.throwLater = function(he, ge) {
        if (arguments.length === 1 && (ge = he, he = function() {
          throw ge;
        }), typeof setTimeout < "u") setTimeout(function() {
          he(ge);
        }, 0);
        else try {
          this._schedule(function() {
            he(ge);
          });
        } catch {
          throw new Error(`No async scheduler available

    See http://goo.gl/MqrFmX
`);
        }
      }, de.hasDevTools ? (be.prototype.invokeLater = function(he, ge, Ce) {
        this._trampolineEnabled ? pe.call(this, he, ge, Ce) : this._schedule(function() {
          setTimeout(function() {
            he.call(ge, Ce);
          }, 100);
        });
      }, be.prototype.invoke = function(he, ge, Ce) {
        this._trampolineEnabled ? me.call(this, he, ge, Ce) : this._schedule(function() {
          he.call(ge, Ce);
        });
      }, be.prototype.settlePromises = function(he) {
        this._trampolineEnabled ? Me.call(this, he) : this._schedule(function() {
          he._settlePromises();
        });
      }) : (be.prototype.invokeLater = pe, be.prototype.invoke = me, be.prototype.settlePromises = Me), be.prototype._drainQueue = function(he) {
        for (; he.length() > 0; ) {
          var ge = he.shift();
          if (typeof ge == "function") {
            var Ce = he.shift(), Se = he.shift();
            ge.call(Ce, Se);
          } else ge._settlePromises();
        }
      }, be.prototype._drainQueues = function() {
        this._drainQueue(this._normalQueue), this._reset(), this._haveDrainedQueues = !0, this._drainQueue(this._lateQueue);
      }, be.prototype._queueTick = function() {
        this._isTickUsed || (this._isTickUsed = !0, this._schedule(this.drainQueues));
      }, be.prototype._reset = function() {
        this._isTickUsed = !1;
      }, oe.exports = be, oe.exports.firstLineError = re;
    }, { "./queue": 26, "./schedule": 29, "./util": 36 }], 3: [function(te, oe, ne) {
      oe.exports = function(re, ce, ue, de) {
        var be = !1, pe = function(ge, Ce) {
          this._reject(Ce);
        }, me = function(ge, Ce) {
          Ce.promiseRejectionQueued = !0, Ce.bindingPromise._then(pe, pe, null, this, ge);
        }, Me = function(ge, Ce) {
          !(50397184 & this._bitField) && this._resolveCallback(Ce.target);
        }, he = function(ge, Ce) {
          Ce.promiseRejectionQueued || this._reject(ge);
        };
        re.prototype.bind = function(ge) {
          be || (be = !0, re.prototype._propagateFrom = de.propagateFromFunction(), re.prototype._boundValue = de.boundValueFunction());
          var Ce = ue(ge), Se = new re(ce);
          Se._propagateFrom(this, 1);
          var Ae = this._target();
          if (Se._setBoundTo(Ce), Ce instanceof re) {
            var Le = { promiseRejectionQueued: !1, promise: Se, target: Ae, bindingPromise: Ce };
            Ae._then(ce, me, void 0, Se, Le), Ce._then(Me, he, void 0, Se, Le), Se._setOnCancel(Ce);
          } else Se._resolveCallback(Ae);
          return Se;
        }, re.prototype._setBoundTo = function(ge) {
          ge !== void 0 ? (this._bitField = 2097152 | this._bitField, this._boundTo = ge) : this._bitField = -2097153 & this._bitField;
        }, re.prototype._isBound = function() {
          return (2097152 & this._bitField) == 2097152;
        }, re.bind = function(ge, Ce) {
          return re.resolve(Ce).bind(ge);
        };
      };
    }, {}], 4: [function(te, oe, ne) {
      var re;
      typeof Promise < "u" && (re = Promise);
      var ce = te("./promise")();
      ce.noConflict = function() {
        try {
          Promise === ce && (Promise = re);
        } catch {
        }
        return ce;
      }, oe.exports = ce;
    }, { "./promise": 22 }], 5: [function(te, oe, ne) {
      var re = Object.create;
      if (re) {
        var ce = re(null), ue = re(null);
        ce[" size"] = ue[" size"] = 0;
      }
      oe.exports = function(de) {
        var be = te("./util"), pe = be.canEvaluate;
        function me(ge) {
          return function(Ce, Se) {
            var Ae;
            if (Ce != null && (Ae = Ce[Se]), typeof Ae != "function") {
              var Le = "Object " + be.classString(Ce) + " has no method '" + be.toString(Se) + "'";
              throw new de.TypeError(Le);
            }
            return Ae;
          }(ge, this.pop()).apply(ge, this);
        }
        function Me(ge) {
          return ge[this];
        }
        function he(ge) {
          var Ce = +this;
          return Ce < 0 && (Ce = Math.max(0, Ce + ge.length)), ge[Ce];
        }
        be.isIdentifier, de.prototype.call = function(ge) {
          var Ce = [].slice.call(arguments, 1);
          return Ce.push(ge), this._then(me, void 0, void 0, Ce, void 0);
        }, de.prototype.get = function(ge) {
          var Ce;
          if (typeof ge == "number") Ce = he;
          else if (pe) {
            var Se = (void 0)(ge);
            Ce = Se !== null ? Se : Me;
          } else Ce = Me;
          return this._then(Ce, void 0, void 0, ge, void 0);
        };
      };
    }, { "./util": 36 }], 6: [function(te, oe, ne) {
      oe.exports = function(re, ce, ue, de) {
        var be = te("./util"), pe = be.tryCatch, me = be.errorObj, Me = re._async;
        re.prototype.break = re.prototype.cancel = function() {
          if (!de.cancellation()) return this._warn("cancellation is disabled");
          for (var he = this, ge = he; he._isCancellable(); ) {
            if (!he._cancelBy(ge)) {
              ge._isFollowing() ? ge._followee().cancel() : ge._cancelBranched();
              break;
            }
            var Ce = he._cancellationParent;
            if (Ce == null || !Ce._isCancellable()) {
              he._isFollowing() ? he._followee().cancel() : he._cancelBranched();
              break;
            }
            he._isFollowing() && he._followee().cancel(), he._setWillBeCancelled(), ge = he, he = Ce;
          }
        }, re.prototype._branchHasCancelled = function() {
          this._branchesRemainingToCancel--;
        }, re.prototype._enoughBranchesHaveCancelled = function() {
          return this._branchesRemainingToCancel === void 0 || this._branchesRemainingToCancel <= 0;
        }, re.prototype._cancelBy = function(he) {
          return he === this ? (this._branchesRemainingToCancel = 0, this._invokeOnCancel(), !0) : (this._branchHasCancelled(), !!this._enoughBranchesHaveCancelled() && (this._invokeOnCancel(), !0));
        }, re.prototype._cancelBranched = function() {
          this._enoughBranchesHaveCancelled() && this._cancel();
        }, re.prototype._cancel = function() {
          this._isCancellable() && (this._setCancelled(), Me.invoke(this._cancelPromises, this, void 0));
        }, re.prototype._cancelPromises = function() {
          this._length() > 0 && this._settlePromises();
        }, re.prototype._unsetOnCancel = function() {
          this._onCancelField = void 0;
        }, re.prototype._isCancellable = function() {
          return this.isPending() && !this._isCancelled();
        }, re.prototype.isCancellable = function() {
          return this.isPending() && !this.isCancelled();
        }, re.prototype._doInvokeOnCancel = function(he, ge) {
          if (be.isArray(he)) for (var Ce = 0; Ce < he.length; ++Ce) this._doInvokeOnCancel(he[Ce], ge);
          else if (he !== void 0) if (typeof he == "function") {
            if (!ge) {
              var Se = pe(he).call(this._boundValue());
              Se === me && (this._attachExtraTrace(Se.e), Me.throwLater(Se.e));
            }
          } else he._resultCancelled(this);
        }, re.prototype._invokeOnCancel = function() {
          var he = this._onCancel();
          this._unsetOnCancel(), Me.invoke(this._doInvokeOnCancel, this, he);
        }, re.prototype._invokeInternalOnCancel = function() {
          this._isCancellable() && (this._doInvokeOnCancel(this._onCancel(), !0), this._unsetOnCancel());
        }, re.prototype._resultCancelled = function() {
          this.cancel();
        };
      };
    }, { "./util": 36 }], 7: [function(te, oe, ne) {
      oe.exports = function(re) {
        var ce = te("./util"), ue = te("./es5").keys, de = ce.tryCatch, be = ce.errorObj;
        return function(pe, me, Me) {
          return function(he) {
            var ge = Me._boundValue();
            e: for (var Ce = 0; Ce < pe.length; ++Ce) {
              var Se = pe[Ce];
              if (Se === Error || Se != null && Se.prototype instanceof Error) {
                if (he instanceof Se) return de(me).call(ge, he);
              } else if (typeof Se == "function") {
                var Ae = de(Se).call(ge, he);
                if (Ae === be) return Ae;
                if (Ae) return de(me).call(ge, he);
              } else if (ce.isObject(he)) {
                for (var Le = ue(Se), ve = 0; ve < Le.length; ++ve) {
                  var De = Le[ve];
                  if (Se[De] != he[De]) continue e;
                }
                return de(me).call(ge, he);
              }
            }
            return re;
          };
        };
      };
    }, { "./es5": 13, "./util": 36 }], 8: [function(te, oe, ne) {
      oe.exports = function(re) {
        var ce = !1, ue = [];
        function de() {
          this._trace = new de.CapturedTrace(be());
        }
        function be() {
          var pe = ue.length - 1;
          if (pe >= 0) return ue[pe];
        }
        return re.prototype._promiseCreated = function() {
        }, re.prototype._pushContext = function() {
        }, re.prototype._popContext = function() {
          return null;
        }, re._peekContext = re.prototype._peekContext = function() {
        }, de.prototype._pushContext = function() {
          this._trace !== void 0 && (this._trace._promiseCreated = null, ue.push(this._trace));
        }, de.prototype._popContext = function() {
          if (this._trace !== void 0) {
            var pe = ue.pop(), me = pe._promiseCreated;
            return pe._promiseCreated = null, me;
          }
          return null;
        }, de.CapturedTrace = null, de.create = function() {
          if (ce) return new de();
        }, de.deactivateLongStackTraces = function() {
        }, de.activateLongStackTraces = function() {
          var pe = re.prototype._pushContext, me = re.prototype._popContext, Me = re._peekContext, he = re.prototype._peekContext, ge = re.prototype._promiseCreated;
          de.deactivateLongStackTraces = function() {
            re.prototype._pushContext = pe, re.prototype._popContext = me, re._peekContext = Me, re.prototype._peekContext = he, re.prototype._promiseCreated = ge, ce = !1;
          }, ce = !0, re.prototype._pushContext = de.prototype._pushContext, re.prototype._popContext = de.prototype._popContext, re._peekContext = re.prototype._peekContext = be, re.prototype._promiseCreated = function() {
            var Ce = this._peekContext();
            Ce && Ce._promiseCreated == null && (Ce._promiseCreated = this);
          };
        }, de;
      };
    }, {}], 9: [function(te, oe, ne) {
      oe.exports = function(re, ce) {
        var ue, de, be, pe = re._getDomain, me = re._async, Me = te("./errors").Warning, he = te("./util"), ge = he.canAttachTrace, Ce = /[\\\/]bluebird[\\\/]js[\\\/](release|debug|instrumented)/, Se = /\((?:timers\.js):\d+:\d+\)/, Ae = /[\/<\(](.+?):(\d+):(\d+)\)?\s*$/, Le = null, ve = null, De = !1, Ue = he.env("BLUEBIRD_DEBUG") != 0, Fe = !(he.env("BLUEBIRD_WARNINGS") == 0 || !Ue && !he.env("BLUEBIRD_WARNINGS")), We = !(he.env("BLUEBIRD_LONG_STACK_TRACES") == 0 || !Ue && !he.env("BLUEBIRD_LONG_STACK_TRACES")), Ke = he.env("BLUEBIRD_W_FORGOTTEN_RETURN") != 0 && (Fe || !!he.env("BLUEBIRD_W_FORGOTTEN_RETURN"));
        re.prototype.suppressUnhandledRejections = function() {
          var xt = this._target();
          xt._bitField = -1048577 & xt._bitField | 524288;
        }, re.prototype._ensurePossibleRejectionHandled = function() {
          if (!(524288 & this._bitField)) {
            this._setRejectionIsUnhandled();
            var xt = this;
            setTimeout(function() {
              xt._notifyUnhandledRejection();
            }, 1);
          }
        }, re.prototype._notifyUnhandledRejectionIsHandled = function() {
          ft("rejectionHandled", ue, void 0, this);
        }, re.prototype._setReturnedNonUndefined = function() {
          this._bitField = 268435456 | this._bitField;
        }, re.prototype._returnedNonUndefined = function() {
          return (268435456 & this._bitField) != 0;
        }, re.prototype._notifyUnhandledRejection = function() {
          if (this._isRejectionUnhandled()) {
            var xt = this._settledValue();
            this._setUnhandledRejectionIsNotified(), ft("unhandledRejection", de, xt, this);
          }
        }, re.prototype._setUnhandledRejectionIsNotified = function() {
          this._bitField = 262144 | this._bitField;
        }, re.prototype._unsetUnhandledRejectionIsNotified = function() {
          this._bitField = -262145 & this._bitField;
        }, re.prototype._isUnhandledRejectionNotified = function() {
          return (262144 & this._bitField) > 0;
        }, re.prototype._setRejectionIsUnhandled = function() {
          this._bitField = 1048576 | this._bitField;
        }, re.prototype._unsetRejectionIsUnhandled = function() {
          this._bitField = -1048577 & this._bitField, this._isUnhandledRejectionNotified() && (this._unsetUnhandledRejectionIsNotified(), this._notifyUnhandledRejectionIsHandled());
        }, re.prototype._isRejectionUnhandled = function() {
          return (1048576 & this._bitField) > 0;
        }, re.prototype._warn = function(xt, Lt, Et) {
          return je(xt, Lt, Et || this);
        }, re.onPossiblyUnhandledRejection = function(xt) {
          var Lt = pe();
          de = typeof xt == "function" ? Lt === null ? xt : he.domainBind(Lt, xt) : void 0;
        }, re.onUnhandledRejectionHandled = function(xt) {
          var Lt = pe();
          ue = typeof xt == "function" ? Lt === null ? xt : he.domainBind(Lt, xt) : void 0;
        };
        var it = function() {
        };
        re.longStackTraces = function() {
          if (me.haveItemsQueued() && !Wt.longStackTraces) throw new Error(`cannot enable long stack traces after promises have been created

    See http://goo.gl/MqrFmX
`);
          if (!Wt.longStackTraces && jt()) {
            var xt = re.prototype._captureStackTrace, Lt = re.prototype._attachExtraTrace;
            Wt.longStackTraces = !0, it = function() {
              if (me.haveItemsQueued() && !Wt.longStackTraces) throw new Error(`cannot enable long stack traces after promises have been created

    See http://goo.gl/MqrFmX
`);
              re.prototype._captureStackTrace = xt, re.prototype._attachExtraTrace = Lt, ce.deactivateLongStackTraces(), me.enableTrampoline(), Wt.longStackTraces = !1;
            }, re.prototype._captureStackTrace = fe, re.prototype._attachExtraTrace = _e, ce.activateLongStackTraces(), me.disableTrampolineIfNecessary();
          }
        }, re.hasLongStackTraces = function() {
          return Wt.longStackTraces && jt();
        };
        var Qe = function() {
          try {
            if (typeof CustomEvent == "function") {
              var xt = new CustomEvent("CustomEvent");
              return he.global.dispatchEvent(xt), function(Lt, Et) {
                var Dt = new CustomEvent(Lt.toLowerCase(), { detail: Et, cancelable: !0 });
                return !he.global.dispatchEvent(Dt);
              };
            }
            return typeof Event == "function" ? (xt = new Event("CustomEvent"), he.global.dispatchEvent(xt), function(Lt, Et) {
              var Dt = new Event(Lt.toLowerCase(), { cancelable: !0 });
              return Dt.detail = Et, !he.global.dispatchEvent(Dt);
            }) : ((xt = document.createEvent("CustomEvent")).initCustomEvent("testingtheevent", !1, !0, {}), he.global.dispatchEvent(xt), function(Lt, Et) {
              var Dt = document.createEvent("CustomEvent");
              return Dt.initCustomEvent(Lt.toLowerCase(), !1, !0, Et), !he.global.dispatchEvent(Dt);
            });
          } catch {
          }
          return function() {
            return !1;
          };
        }(), vt = he.isNode ? function() {
          return W.emit.apply(W, arguments);
        } : he.global ? function(xt) {
          var Lt = "on" + xt.toLowerCase(), Et = he.global[Lt];
          return !!Et && (Et.apply(he.global, [].slice.call(arguments, 1)), !0);
        } : function() {
          return !1;
        };
        function Ct(xt, Lt) {
          return { promise: Lt };
        }
        var Tt = { promiseCreated: Ct, promiseFulfilled: Ct, promiseRejected: Ct, promiseResolved: Ct, promiseCancelled: Ct, promiseChained: function(xt, Lt, Et) {
          return { promise: Lt, child: Et };
        }, warning: function(xt, Lt) {
          return { warning: Lt };
        }, unhandledRejection: function(xt, Lt, Et) {
          return { reason: Lt, promise: Et };
        }, rejectionHandled: Ct }, St = function(xt) {
          var Lt = !1;
          try {
            Lt = vt.apply(null, arguments);
          } catch (Dt) {
            me.throwLater(Dt), Lt = !0;
          }
          var Et = !1;
          try {
            Et = Qe(xt, Tt[xt].apply(null, arguments));
          } catch (Dt) {
            me.throwLater(Dt), Et = !0;
          }
          return Et || Lt;
        };
        function Je() {
          return !1;
        }
        function He(xt, Lt, Et) {
          var Dt = this;
          try {
            xt(Lt, Et, function(Pt) {
              if (typeof Pt != "function") throw new TypeError("onCancel must be a function, got: " + he.toString(Pt));
              Dt._attachCancellationCallback(Pt);
            });
          } catch (Pt) {
            return Pt;
          }
        }
        function qe(xt) {
          if (!this._isCancellable()) return this;
          var Lt = this._onCancel();
          Lt !== void 0 ? he.isArray(Lt) ? Lt.push(xt) : this._setOnCancel([Lt, xt]) : this._setOnCancel(xt);
        }
        function Ze() {
          return this._onCancelField;
        }
        function Pe(xt) {
          this._onCancelField = xt;
        }
        function Ye() {
          this._cancellationParent = void 0, this._onCancelField = void 0;
        }
        function ot(xt, Lt) {
          if (1 & Lt) {
            this._cancellationParent = xt;
            var Et = xt._branchesRemainingToCancel;
            Et === void 0 && (Et = 0), xt._branchesRemainingToCancel = Et + 1;
          }
          2 & Lt && xt._isBound() && this._setBoundTo(xt._boundTo);
        }
        re.config = function(xt) {
          if ("longStackTraces" in (xt = Object(xt)) && (xt.longStackTraces ? re.longStackTraces() : !xt.longStackTraces && re.hasLongStackTraces() && it()), "warnings" in xt) {
            var Lt = xt.warnings;
            Wt.warnings = !!Lt, Ke = Wt.warnings, he.isObject(Lt) && "wForgottenReturn" in Lt && (Ke = !!Lt.wForgottenReturn);
          }
          if ("cancellation" in xt && xt.cancellation && !Wt.cancellation) {
            if (me.haveItemsQueued()) throw new Error("cannot enable cancellation after promises are in use");
            re.prototype._clearCancellationData = Ye, re.prototype._propagateFrom = ot, re.prototype._onCancel = Ze, re.prototype._setOnCancel = Pe, re.prototype._attachCancellationCallback = qe, re.prototype._execute = He, Be = ot, Wt.cancellation = !0;
          }
          return "monitoring" in xt && (xt.monitoring && !Wt.monitoring ? (Wt.monitoring = !0, re.prototype._fireEvent = St) : !xt.monitoring && Wt.monitoring && (Wt.monitoring = !1, re.prototype._fireEvent = Je)), re;
        }, re.prototype._fireEvent = Je, re.prototype._execute = function(xt, Lt, Et) {
          try {
            xt(Lt, Et);
          } catch (Dt) {
            return Dt;
          }
        }, re.prototype._onCancel = function() {
        }, re.prototype._setOnCancel = function(xt) {
        }, re.prototype._attachCancellationCallback = function(xt) {
        }, re.prototype._captureStackTrace = function() {
        }, re.prototype._attachExtraTrace = function() {
        }, re.prototype._clearCancellationData = function() {
        }, re.prototype._propagateFrom = function(xt, Lt) {
        };
        var Be = function(xt, Lt) {
          2 & Lt && xt._isBound() && this._setBoundTo(xt._boundTo);
        };
        function Ve() {
          var xt = this._boundTo;
          return xt !== void 0 && xt instanceof re ? xt.isFulfilled() ? xt.value() : void 0 : xt;
        }
        function fe() {
          this._trace = new Xt(this._peekContext());
        }
        function _e(xt, Lt) {
          if (ge(xt)) {
            var Et = this._trace;
            if (Et !== void 0 && Lt && (Et = Et._parent), Et !== void 0) Et.attachExtraTrace(xt);
            else if (!xt.__stackCleaned__) {
              var Dt = Ie(xt);
              he.notEnumerableProp(xt, "stack", Dt.message + `
` + Dt.stack.join(`
`)), he.notEnumerableProp(xt, "__stackCleaned__", !0);
            }
          }
        }
        function je(xt, Lt, Et) {
          if (Wt.warnings) {
            var Dt, Pt = new Me(xt);
            if (Lt) Et._attachExtraTrace(Pt);
            else if (Wt.longStackTraces && (Dt = re._peekContext())) Dt.attachExtraTrace(Pt);
            else {
              var zt = Ie(Pt);
              Pt.stack = zt.message + `
` + zt.stack.join(`
`);
            }
            St("warning", Pt) || Xe(Pt, "", !0);
          }
        }
        function Ne(xt) {
          for (var Lt = [], Et = 0; Et < xt.length; ++Et) {
            var Dt = xt[Et], Pt = Dt === "    (No stack trace)" || Le.test(Dt), zt = Pt && Ot(Dt);
            Pt && !zt && (De && Dt.charAt(0) !== " " && (Dt = "    " + Dt), Lt.push(Dt));
          }
          return Lt;
        }
        function Ie(xt) {
          var Lt = xt.stack, Et = xt.toString();
          return Lt = typeof Lt == "string" && Lt.length > 0 ? function(Dt) {
            for (var Pt = Dt.stack.replace(/\s+$/g, "").split(`
`), zt = 0; zt < Pt.length; ++zt) {
              var At = Pt[zt];
              if (At === "    (No stack trace)" || Le.test(At)) break;
            }
            return zt > 0 && Dt.name != "SyntaxError" && (Pt = Pt.slice(zt)), Pt;
          }(xt) : ["    (No stack trace)"], { message: Et, stack: xt.name == "SyntaxError" ? Lt : Ne(Lt) };
        }
        function Xe(xt, Lt, Et) {
          if (typeof console < "u") {
            var Dt;
            if (he.isObject(xt)) {
              var Pt = xt.stack;
              Dt = Lt + ve(Pt, xt);
            } else Dt = Lt + String(xt);
            typeof be == "function" ? be(Dt, Et) : typeof console.log != "function" && typeof console.log != "object" || console.log(Dt);
          }
        }
        function ft(xt, Lt, Et, Dt) {
          var Pt = !1;
          try {
            typeof Lt == "function" && (Pt = !0, xt === "rejectionHandled" ? Lt(Dt) : Lt(Et, Dt));
          } catch (zt) {
            me.throwLater(zt);
          }
          xt === "unhandledRejection" ? St(xt, Et, Dt) || Pt || Xe(Et, "Unhandled rejection ") : St(xt, Dt);
        }
        function It(xt) {
          var Lt;
          if (typeof xt == "function") Lt = "[function " + (xt.name || "anonymous") + "]";
          else {
            if (Lt = xt && typeof xt.toString == "function" ? xt.toString() : he.toString(xt), /\[object [a-zA-Z0-9$_]+\]/.test(Lt)) try {
              Lt = JSON.stringify(xt);
            } catch {
            }
            Lt.length === 0 && (Lt = "(empty array)");
          }
          return "(<" + function(Et) {
            return Et.length < 41 ? Et : Et.substr(0, 38) + "...";
          }(Lt) + ">, no stack trace)";
        }
        function jt() {
          return typeof tr == "function";
        }
        var Ot = function() {
          return !1;
        }, Ut = /[\/<\(]([^:\/]+):(\d+):(?:\d+)\)?\s*$/;
        function kt(xt) {
          var Lt = xt.match(Ut);
          if (Lt) return { fileName: Lt[1], line: parseInt(Lt[2], 10) };
        }
        function Xt(xt) {
          this._parent = xt, this._promisesCreated = 0;
          var Lt = this._length = 1 + (xt === void 0 ? 0 : xt._length);
          tr(this, Xt), Lt > 32 && this.uncycle();
        }
        he.inherits(Xt, Error), ce.CapturedTrace = Xt, Xt.prototype.uncycle = function() {
          var xt = this._length;
          if (!(xt < 2)) {
            for (var Lt = [], Et = {}, Dt = 0, Pt = this; Pt !== void 0; ++Dt) Lt.push(Pt), Pt = Pt._parent;
            for (Dt = (xt = this._length = Dt) - 1; Dt >= 0; --Dt) {
              var zt = Lt[Dt].stack;
              Et[zt] === void 0 && (Et[zt] = Dt);
            }
            for (Dt = 0; Dt < xt; ++Dt) {
              var At = Et[Lt[Dt].stack];
              if (At !== void 0 && At !== Dt) {
                At > 0 && (Lt[At - 1]._parent = void 0, Lt[At - 1]._length = 1), Lt[Dt]._parent = void 0, Lt[Dt]._length = 1;
                var ze = Dt > 0 ? Lt[Dt - 1] : this;
                At < xt - 1 ? (ze._parent = Lt[At + 1], ze._parent.uncycle(), ze._length = ze._parent._length + 1) : (ze._parent = void 0, ze._length = 1);
                for (var ye = ze._length + 1, we = Dt - 2; we >= 0; --we) Lt[we]._length = ye, ye++;
                return;
              }
            }
          }
        }, Xt.prototype.attachExtraTrace = function(xt) {
          if (!xt.__stackCleaned__) {
            this.uncycle();
            for (var Lt = Ie(xt), Et = Lt.message, Dt = [Lt.stack], Pt = this; Pt !== void 0; ) Dt.push(Ne(Pt.stack.split(`
`))), Pt = Pt._parent;
            (function(zt) {
              for (var At = zt[0], ze = 1; ze < zt.length; ++ze) {
                for (var ye = zt[ze], we = At.length - 1, Ge = At[we], tt = -1, Mt = ye.length - 1; Mt >= 0; --Mt) if (ye[Mt] === Ge) {
                  tt = Mt;
                  break;
                }
                for (Mt = tt; Mt >= 0; --Mt) {
                  var Nt = ye[Mt];
                  if (At[we] !== Nt) break;
                  At.pop(), we--;
                }
                At = ye;
              }
            })(Dt), function(zt) {
              for (var At = 0; At < zt.length; ++At) (zt[At].length === 0 || At + 1 < zt.length && zt[At][0] === zt[At + 1][0]) && (zt.splice(At, 1), At--);
            }(Dt), he.notEnumerableProp(xt, "stack", function(zt, At) {
              for (var ze = 0; ze < At.length - 1; ++ze) At[ze].push("From previous event:"), At[ze] = At[ze].join(`
`);
              return ze < At.length && (At[ze] = At[ze].join(`
`)), zt + `
` + At.join(`
`);
            }(Et, Dt)), he.notEnumerableProp(xt, "__stackCleaned__", !0);
          }
        };
        var tr = function() {
          var xt = /^\s*at\s*/, Lt = function(zt, At) {
            return typeof zt == "string" ? zt : At.name !== void 0 && At.message !== void 0 ? At.toString() : It(At);
          };
          if (typeof Error.stackTraceLimit == "number" && typeof Error.captureStackTrace == "function") {
            Error.stackTraceLimit += 6, Le = xt, ve = Lt;
            var Et = Error.captureStackTrace;
            return Ot = function(zt) {
              return Ce.test(zt);
            }, function(zt, At) {
              Error.stackTraceLimit += 6, Et(zt, At), Error.stackTraceLimit -= 6;
            };
          }
          var Dt, Pt = new Error();
          if (typeof Pt.stack == "string" && Pt.stack.split(`
`)[0].indexOf("stackDetection@") >= 0) return Le = /@/, ve = Lt, De = !0, function(zt) {
            zt.stack = new Error().stack;
          };
          try {
            throw new Error();
          } catch (zt) {
            Dt = "stack" in zt;
          }
          return "stack" in Pt || !Dt || typeof Error.stackTraceLimit != "number" ? (ve = function(zt, At) {
            return typeof zt == "string" ? zt : typeof At != "object" && typeof At != "function" || At.name === void 0 || At.message === void 0 ? It(At) : At.toString();
          }, null) : (Le = xt, ve = Lt, function(zt) {
            Error.stackTraceLimit += 6;
            try {
              throw new Error();
            } catch (At) {
              zt.stack = At.stack;
            }
            Error.stackTraceLimit -= 6;
          });
        }();
        typeof console < "u" && console.warn !== void 0 && (be = function(xt) {
          console.warn(xt);
        }, he.isNode && W.stderr.isTTY ? be = function(xt, Lt) {
          var Et = Lt ? "\x1B[33m" : "\x1B[31m";
          console.warn(Et + xt + `\x1B[0m
`);
        } : he.isNode || typeof new Error().stack != "string" || (be = function(xt, Lt) {
          console.warn("%c" + xt, Lt ? "color: darkorange" : "color: red");
        }));
        var Wt = { warnings: Fe, longStackTraces: !1, cancellation: !1, monitoring: !1 };
        return We && re.longStackTraces(), { longStackTraces: function() {
          return Wt.longStackTraces;
        }, warnings: function() {
          return Wt.warnings;
        }, cancellation: function() {
          return Wt.cancellation;
        }, monitoring: function() {
          return Wt.monitoring;
        }, propagateFromFunction: function() {
          return Be;
        }, boundValueFunction: function() {
          return Ve;
        }, checkForgottenReturns: function(xt, Lt, Et, Dt, Pt) {
          if (xt === void 0 && Lt !== null && Ke) {
            if (Pt !== void 0 && Pt._returnedNonUndefined() || !(65535 & Dt._bitField)) return;
            Et && (Et += " ");
            var zt = "", At = "";
            if (Lt._trace) {
              for (var ze = Lt._trace.stack.split(`
`), ye = Ne(ze), we = ye.length - 1; we >= 0; --we) {
                var Ge = ye[we];
                if (!Se.test(Ge)) {
                  var tt = Ge.match(Ae);
                  tt && (zt = "at " + tt[1] + ":" + tt[2] + ":" + tt[3] + " ");
                  break;
                }
              }
              if (ye.length > 0) {
                var Mt = ye[0];
                for (we = 0; we < ze.length; ++we) if (ze[we] === Mt) {
                  we > 0 && (At = `
` + ze[we - 1]);
                  break;
                }
              }
            }
            var Nt = "a promise was created in a " + Et + "handler " + zt + "but was not returned from it, see http://goo.gl/rRqMUw" + At;
            Dt._warn(Nt, !0, Lt);
          }
        }, setBounds: function(xt, Lt) {
          if (jt()) {
            for (var Et, Dt, Pt = xt.stack.split(`
`), zt = Lt.stack.split(`
`), At = -1, ze = -1, ye = 0; ye < Pt.length; ++ye) if (we = kt(Pt[ye])) {
              Et = we.fileName, At = we.line;
              break;
            }
            for (ye = 0; ye < zt.length; ++ye) {
              var we;
              if (we = kt(zt[ye])) {
                Dt = we.fileName, ze = we.line;
                break;
              }
            }
            At < 0 || ze < 0 || !Et || !Dt || Et !== Dt || At >= ze || (Ot = function(Ge) {
              if (Ce.test(Ge)) return !0;
              var tt = kt(Ge);
              return !!(tt && tt.fileName === Et && At <= tt.line && tt.line <= ze);
            });
          }
        }, warn: je, deprecated: function(xt, Lt) {
          var Et = xt + " is deprecated and will be removed in a future version.";
          return Lt && (Et += " Use " + Lt + " instead."), je(Et);
        }, CapturedTrace: Xt, fireDomEvent: Qe, fireGlobalEvent: vt };
      };
    }, { "./errors": 12, "./util": 36 }], 10: [function(te, oe, ne) {
      oe.exports = function(re) {
        function ce() {
          return this.value;
        }
        function ue() {
          throw this.reason;
        }
        re.prototype.return = re.prototype.thenReturn = function(de) {
          return de instanceof re && de.suppressUnhandledRejections(), this._then(ce, void 0, void 0, { value: de }, void 0);
        }, re.prototype.throw = re.prototype.thenThrow = function(de) {
          return this._then(ue, void 0, void 0, { reason: de }, void 0);
        }, re.prototype.catchThrow = function(de) {
          if (arguments.length <= 1) return this._then(void 0, ue, void 0, { reason: de }, void 0);
          var be = arguments[1];
          return this.caught(de, function() {
            throw be;
          });
        }, re.prototype.catchReturn = function(de) {
          if (arguments.length <= 1) return de instanceof re && de.suppressUnhandledRejections(), this._then(void 0, ce, void 0, { value: de }, void 0);
          var be = arguments[1];
          return be instanceof re && be.suppressUnhandledRejections(), this.caught(de, function() {
            return be;
          });
        };
      };
    }, {}], 11: [function(te, oe, ne) {
      oe.exports = function(re, ce) {
        var ue = re.reduce, de = re.all;
        function be() {
          return de(this);
        }
        re.prototype.each = function(pe) {
          return ue(this, pe, ce, 0)._then(be, void 0, void 0, this, void 0);
        }, re.prototype.mapSeries = function(pe) {
          return ue(this, pe, ce, ce);
        }, re.each = function(pe, me) {
          return ue(pe, me, ce, 0)._then(be, void 0, void 0, pe, void 0);
        }, re.mapSeries = function(pe, me) {
          return ue(pe, me, ce, ce);
        };
      };
    }, {}], 12: [function(te, oe, ne) {
      var re, ce, ue = te("./es5"), de = ue.freeze, be = te("./util"), pe = be.inherits, me = be.notEnumerableProp;
      function Me(Fe, We) {
        function Ke(it) {
          if (!(this instanceof Ke)) return new Ke(it);
          me(this, "message", typeof it == "string" ? it : We), me(this, "name", Fe), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : Error.call(this);
        }
        return pe(Ke, Error), Ke;
      }
      var he = Me("Warning", "warning"), ge = Me("CancellationError", "cancellation error"), Ce = Me("TimeoutError", "timeout error"), Se = Me("AggregateError", "aggregate error");
      try {
        re = TypeError, ce = RangeError;
      } catch {
        re = Me("TypeError", "type error"), ce = Me("RangeError", "range error");
      }
      for (var Ae = "join pop push shift unshift slice filter forEach some every map indexOf lastIndexOf reduce reduceRight sort reverse".split(" "), Le = 0; Le < Ae.length; ++Le) typeof Array.prototype[Ae[Le]] == "function" && (Se.prototype[Ae[Le]] = Array.prototype[Ae[Le]]);
      ue.defineProperty(Se.prototype, "length", { value: 0, configurable: !1, writable: !0, enumerable: !0 }), Se.prototype.isOperational = !0;
      var ve = 0;
      function De(Fe) {
        if (!(this instanceof De)) return new De(Fe);
        me(this, "name", "OperationalError"), me(this, "message", Fe), this.cause = Fe, this.isOperational = !0, Fe instanceof Error ? (me(this, "message", Fe.message), me(this, "stack", Fe.stack)) : Error.captureStackTrace && Error.captureStackTrace(this, this.constructor);
      }
      Se.prototype.toString = function() {
        var Fe = Array(4 * ve + 1).join(" "), We = `
` + Fe + `AggregateError of:
`;
        ve++, Fe = Array(4 * ve + 1).join(" ");
        for (var Ke = 0; Ke < this.length; ++Ke) {
          for (var it = this[Ke] === this ? "[Circular AggregateError]" : this[Ke] + "", Qe = it.split(`
`), vt = 0; vt < Qe.length; ++vt) Qe[vt] = Fe + Qe[vt];
          We += (it = Qe.join(`
`)) + `
`;
        }
        return ve--, We;
      }, pe(De, Error);
      var Ue = Error.__BluebirdErrorTypes__;
      Ue || (Ue = de({ CancellationError: ge, TimeoutError: Ce, OperationalError: De, RejectionError: De, AggregateError: Se }), ue.defineProperty(Error, "__BluebirdErrorTypes__", { value: Ue, writable: !1, enumerable: !1, configurable: !1 })), oe.exports = { Error, TypeError: re, RangeError: ce, CancellationError: Ue.CancellationError, OperationalError: Ue.OperationalError, TimeoutError: Ue.TimeoutError, AggregateError: Ue.AggregateError, Warning: he };
    }, { "./es5": 13, "./util": 36 }], 13: [function(te, oe, ne) {
      var re = /* @__PURE__ */ function() {
        return this === void 0;
      }();
      if (re) oe.exports = { freeze: Object.freeze, defineProperty: Object.defineProperty, getDescriptor: Object.getOwnPropertyDescriptor, keys: Object.keys, names: Object.getOwnPropertyNames, getPrototypeOf: Object.getPrototypeOf, isArray: Array.isArray, isES5: re, propertyIsWritable: function(pe, me) {
        var Me = Object.getOwnPropertyDescriptor(pe, me);
        return !(Me && !Me.writable && !Me.set);
      } };
      else {
        var ce = {}.hasOwnProperty, ue = {}.toString, de = {}.constructor.prototype, be = function(pe) {
          var me = [];
          for (var Me in pe) ce.call(pe, Me) && me.push(Me);
          return me;
        };
        oe.exports = { isArray: function(pe) {
          try {
            return ue.call(pe) === "[object Array]";
          } catch {
            return !1;
          }
        }, keys: be, names: be, defineProperty: function(pe, me, Me) {
          return pe[me] = Me.value, pe;
        }, getDescriptor: function(pe, me) {
          return { value: pe[me] };
        }, freeze: function(pe) {
          return pe;
        }, getPrototypeOf: function(pe) {
          try {
            return Object(pe).constructor.prototype;
          } catch {
            return de;
          }
        }, isES5: re, propertyIsWritable: function() {
          return !0;
        } };
      }
    }, {}], 14: [function(te, oe, ne) {
      oe.exports = function(re, ce) {
        var ue = re.map;
        re.prototype.filter = function(de, be) {
          return ue(this, de, be, ce);
        }, re.filter = function(de, be, pe) {
          return ue(de, be, pe, ce);
        };
      };
    }, {}], 15: [function(te, oe, ne) {
      oe.exports = function(re, ce, ue) {
        var de = te("./util"), be = re.CancellationError, pe = de.errorObj, me = te("./catch_filter")(ue);
        function Me(Le, ve, De) {
          this.promise = Le, this.type = ve, this.handler = De, this.called = !1, this.cancelPromise = null;
        }
        function he(Le) {
          this.finallyHandler = Le;
        }
        function ge(Le, ve) {
          return Le.cancelPromise != null && (arguments.length > 1 ? Le.cancelPromise._reject(ve) : Le.cancelPromise._cancel(), Le.cancelPromise = null, !0);
        }
        function Ce() {
          return Ae.call(this, this.promise._target()._settledValue());
        }
        function Se(Le) {
          if (!ge(this, Le)) return pe.e = Le, pe;
        }
        function Ae(Le) {
          var ve = this.promise, De = this.handler;
          if (!this.called) {
            this.called = !0;
            var Ue = this.isFinallyHandler() ? De.call(ve._boundValue()) : De.call(ve._boundValue(), Le);
            if (Ue === ue) return Ue;
            if (Ue !== void 0) {
              ve._setReturnedNonUndefined();
              var Fe = ce(Ue, ve);
              if (Fe instanceof re) {
                if (this.cancelPromise != null) {
                  if (Fe._isCancelled()) {
                    var We = new be("late cancellation observer");
                    return ve._attachExtraTrace(We), pe.e = We, pe;
                  }
                  Fe.isPending() && Fe._attachCancellationCallback(new he(this));
                }
                return Fe._then(Ce, Se, void 0, this, void 0);
              }
            }
          }
          return ve.isRejected() ? (ge(this), pe.e = Le, pe) : (ge(this), Le);
        }
        return Me.prototype.isFinallyHandler = function() {
          return this.type === 0;
        }, he.prototype._resultCancelled = function() {
          ge(this.finallyHandler);
        }, re.prototype._passThrough = function(Le, ve, De, Ue) {
          return typeof Le != "function" ? this.then() : this._then(De, Ue, void 0, new Me(this, ve, Le), void 0);
        }, re.prototype.lastly = re.prototype.finally = function(Le) {
          return this._passThrough(Le, 0, Ae, Ae);
        }, re.prototype.tap = function(Le) {
          return this._passThrough(Le, 1, Ae);
        }, re.prototype.tapCatch = function(Le) {
          var ve = arguments.length;
          if (ve === 1) return this._passThrough(Le, 1, void 0, Ae);
          var De, Ue = new Array(ve - 1), Fe = 0;
          for (De = 0; De < ve - 1; ++De) {
            var We = arguments[De];
            if (!de.isObject(We)) return re.reject(new TypeError("tapCatch statement predicate: expecting an object but got " + de.classString(We)));
            Ue[Fe++] = We;
          }
          Ue.length = Fe;
          var Ke = arguments[De];
          return this._passThrough(me(Ue, Ke, this), 1, void 0, Ae);
        }, Me;
      };
    }, { "./catch_filter": 7, "./util": 36 }], 16: [function(te, oe, ne) {
      oe.exports = function(re, ce, ue, de, be, pe) {
        var me = te("./errors").TypeError, Me = te("./util"), he = Me.errorObj, ge = Me.tryCatch, Ce = [];
        function Se(Ae, Le, ve, De) {
          if (pe.cancellation()) {
            var Ue = new re(ue), Fe = this._finallyPromise = new re(ue);
            this._promise = Ue.lastly(function() {
              return Fe;
            }), Ue._captureStackTrace(), Ue._setOnCancel(this);
          } else (this._promise = new re(ue))._captureStackTrace();
          this._stack = De, this._generatorFunction = Ae, this._receiver = Le, this._generator = void 0, this._yieldHandlers = typeof ve == "function" ? [ve].concat(Ce) : Ce, this._yieldedPromise = null, this._cancellationPhase = !1;
        }
        Me.inherits(Se, be), Se.prototype._isResolved = function() {
          return this._promise === null;
        }, Se.prototype._cleanup = function() {
          this._promise = this._generator = null, pe.cancellation() && this._finallyPromise !== null && (this._finallyPromise._fulfill(), this._finallyPromise = null);
        }, Se.prototype._promiseCancelled = function() {
          if (!this._isResolved()) {
            var Ae;
            if (this._generator.return !== void 0) this._promise._pushContext(), Ae = ge(this._generator.return).call(this._generator, void 0), this._promise._popContext();
            else {
              var Le = new re.CancellationError("generator .return() sentinel");
              re.coroutine.returnSentinel = Le, this._promise._attachExtraTrace(Le), this._promise._pushContext(), Ae = ge(this._generator.throw).call(this._generator, Le), this._promise._popContext();
            }
            this._cancellationPhase = !0, this._yieldedPromise = null, this._continue(Ae);
          }
        }, Se.prototype._promiseFulfilled = function(Ae) {
          this._yieldedPromise = null, this._promise._pushContext();
          var Le = ge(this._generator.next).call(this._generator, Ae);
          this._promise._popContext(), this._continue(Le);
        }, Se.prototype._promiseRejected = function(Ae) {
          this._yieldedPromise = null, this._promise._attachExtraTrace(Ae), this._promise._pushContext();
          var Le = ge(this._generator.throw).call(this._generator, Ae);
          this._promise._popContext(), this._continue(Le);
        }, Se.prototype._resultCancelled = function() {
          if (this._yieldedPromise instanceof re) {
            var Ae = this._yieldedPromise;
            this._yieldedPromise = null, Ae.cancel();
          }
        }, Se.prototype.promise = function() {
          return this._promise;
        }, Se.prototype._run = function() {
          this._generator = this._generatorFunction.call(this._receiver), this._receiver = this._generatorFunction = void 0, this._promiseFulfilled(void 0);
        }, Se.prototype._continue = function(Ae) {
          var Le = this._promise;
          if (Ae === he) return this._cleanup(), this._cancellationPhase ? Le.cancel() : Le._rejectCallback(Ae.e, !1);
          var ve = Ae.value;
          if (Ae.done === !0) return this._cleanup(), this._cancellationPhase ? Le.cancel() : Le._resolveCallback(ve);
          var De = de(ve, this._promise);
          if (De instanceof re || (De = function(Fe, We, Ke) {
            for (var it = 0; it < We.length; ++it) {
              Ke._pushContext();
              var Qe = ge(We[it])(Fe);
              if (Ke._popContext(), Qe === he) {
                Ke._pushContext();
                var vt = re.reject(he.e);
                return Ke._popContext(), vt;
              }
              var Ct = de(Qe, Ke);
              if (Ct instanceof re) return Ct;
            }
            return null;
          }(De, this._yieldHandlers, this._promise)) !== null) {
            var Ue = (De = De._target())._bitField;
            50397184 & Ue ? 33554432 & Ue ? re._async.invoke(this._promiseFulfilled, this, De._value()) : 16777216 & Ue ? re._async.invoke(this._promiseRejected, this, De._reason()) : this._promiseCancelled() : (this._yieldedPromise = De, De._proxy(this, null));
          } else this._promiseRejected(new me(`A value %s was yielded that could not be treated as a promise

    See http://goo.gl/MqrFmX

`.replace("%s", String(ve)) + `From coroutine:
` + this._stack.split(`
`).slice(1, -7).join(`
`)));
        }, re.coroutine = function(Ae, Le) {
          if (typeof Ae != "function") throw new me(`generatorFunction must be a function

    See http://goo.gl/MqrFmX
`);
          var ve = Object(Le).yieldHandler, De = Se, Ue = new Error().stack;
          return function() {
            var Fe = Ae.apply(this, arguments), We = new De(void 0, void 0, ve, Ue), Ke = We.promise();
            return We._generator = Fe, We._promiseFulfilled(void 0), Ke;
          };
        }, re.coroutine.addYieldHandler = function(Ae) {
          if (typeof Ae != "function") throw new me("expecting a function but got " + Me.classString(Ae));
          Ce.push(Ae);
        }, re.spawn = function(Ae) {
          if (pe.deprecated("Promise.spawn()", "Promise.coroutine()"), typeof Ae != "function") return ce(`generatorFunction must be a function

    See http://goo.gl/MqrFmX
`);
          var Le = new Se(Ae, this), ve = Le.promise();
          return Le._run(re.spawn), ve;
        };
      };
    }, { "./errors": 12, "./util": 36 }], 17: [function(te, oe, ne) {
      oe.exports = function(re, ce, ue, de, be, pe) {
        var me = te("./util");
        me.canEvaluate, me.tryCatch, me.errorObj, re.join = function() {
          var Me, he = arguments.length - 1;
          he > 0 && typeof arguments[he] == "function" && (Me = arguments[he]);
          var ge = [].slice.call(arguments);
          Me && ge.pop();
          var Ce = new ce(ge).promise();
          return Me !== void 0 ? Ce.spread(Me) : Ce;
        };
      };
    }, { "./util": 36 }], 18: [function(te, oe, ne) {
      oe.exports = function(re, ce, ue, de, be, pe) {
        var me = re._getDomain, Me = te("./util"), he = Me.tryCatch, ge = Me.errorObj, Ce = re._async;
        function Se(Le, ve, De, Ue) {
          this.constructor$(Le), this._promise._captureStackTrace();
          var Fe = me();
          this._callback = Fe === null ? ve : Me.domainBind(Fe, ve), this._preservedValues = Ue === be ? new Array(this.length()) : null, this._limit = De, this._inFlight = 0, this._queue = [], Ce.invoke(this._asyncInit, this, void 0);
        }
        function Ae(Le, ve, De, Ue) {
          if (typeof ve != "function") return ue("expecting a function but got " + Me.classString(ve));
          var Fe = 0;
          if (De !== void 0) {
            if (typeof De != "object" || De === null) return re.reject(new TypeError("options argument must be an object but it is " + Me.classString(De)));
            if (typeof De.concurrency != "number") return re.reject(new TypeError("'concurrency' must be a number but it is " + Me.classString(De.concurrency)));
            Fe = De.concurrency;
          }
          return new Se(Le, ve, Fe = typeof Fe == "number" && isFinite(Fe) && Fe >= 1 ? Fe : 0, Ue).promise();
        }
        Me.inherits(Se, ce), Se.prototype._asyncInit = function() {
          this._init$(void 0, -2);
        }, Se.prototype._init = function() {
        }, Se.prototype._promiseFulfilled = function(Le, ve) {
          var De = this._values, Ue = this.length(), Fe = this._preservedValues, We = this._limit;
          if (ve < 0) {
            if (De[ve = -1 * ve - 1] = Le, We >= 1 && (this._inFlight--, this._drainQueue(), this._isResolved())) return !0;
          } else {
            if (We >= 1 && this._inFlight >= We) return De[ve] = Le, this._queue.push(ve), !1;
            Fe !== null && (Fe[ve] = Le);
            var Ke = this._promise, it = this._callback, Qe = Ke._boundValue();
            Ke._pushContext();
            var vt = he(it).call(Qe, Le, ve, Ue), Ct = Ke._popContext();
            if (pe.checkForgottenReturns(vt, Ct, Fe !== null ? "Promise.filter" : "Promise.map", Ke), vt === ge) return this._reject(vt.e), !0;
            var Tt = de(vt, this._promise);
            if (Tt instanceof re) {
              var St = (Tt = Tt._target())._bitField;
              if (!(50397184 & St)) return We >= 1 && this._inFlight++, De[ve] = Tt, Tt._proxy(this, -1 * (ve + 1)), !1;
              if (!(33554432 & St)) return 16777216 & St ? (this._reject(Tt._reason()), !0) : (this._cancel(), !0);
              vt = Tt._value();
            }
            De[ve] = vt;
          }
          return ++this._totalResolved >= Ue && (Fe !== null ? this._filter(De, Fe) : this._resolve(De), !0);
        }, Se.prototype._drainQueue = function() {
          for (var Le = this._queue, ve = this._limit, De = this._values; Le.length > 0 && this._inFlight < ve; ) {
            if (this._isResolved()) return;
            var Ue = Le.pop();
            this._promiseFulfilled(De[Ue], Ue);
          }
        }, Se.prototype._filter = function(Le, ve) {
          for (var De = ve.length, Ue = new Array(De), Fe = 0, We = 0; We < De; ++We) Le[We] && (Ue[Fe++] = ve[We]);
          Ue.length = Fe, this._resolve(Ue);
        }, Se.prototype.preservedValues = function() {
          return this._preservedValues;
        }, re.prototype.map = function(Le, ve) {
          return Ae(this, Le, ve, null);
        }, re.map = function(Le, ve, De, Ue) {
          return Ae(Le, ve, De, Ue);
        };
      };
    }, { "./util": 36 }], 19: [function(te, oe, ne) {
      oe.exports = function(re, ce, ue, de, be) {
        var pe = te("./util"), me = pe.tryCatch;
        re.method = function(Me) {
          if (typeof Me != "function") throw new re.TypeError("expecting a function but got " + pe.classString(Me));
          return function() {
            var he = new re(ce);
            he._captureStackTrace(), he._pushContext();
            var ge = me(Me).apply(this, arguments), Ce = he._popContext();
            return be.checkForgottenReturns(ge, Ce, "Promise.method", he), he._resolveFromSyncValue(ge), he;
          };
        }, re.attempt = re.try = function(Me) {
          if (typeof Me != "function") return de("expecting a function but got " + pe.classString(Me));
          var he, ge = new re(ce);
          if (ge._captureStackTrace(), ge._pushContext(), arguments.length > 1) {
            be.deprecated("calling Promise.try with more than 1 argument");
            var Ce = arguments[1], Se = arguments[2];
            he = pe.isArray(Ce) ? me(Me).apply(Se, Ce) : me(Me).call(Se, Ce);
          } else he = me(Me)();
          var Ae = ge._popContext();
          return be.checkForgottenReturns(he, Ae, "Promise.try", ge), ge._resolveFromSyncValue(he), ge;
        }, re.prototype._resolveFromSyncValue = function(Me) {
          Me === pe.errorObj ? this._rejectCallback(Me.e, !1) : this._resolveCallback(Me, !0);
        };
      };
    }, { "./util": 36 }], 20: [function(te, oe, ne) {
      var re = te("./util"), ce = re.maybeWrapAsError, ue = te("./errors").OperationalError, de = te("./es5"), be = /^(?:name|message|stack|cause)$/;
      function pe(me) {
        var Me;
        if (function(Se) {
          return Se instanceof Error && de.getPrototypeOf(Se) === Error.prototype;
        }(me)) {
          (Me = new ue(me)).name = me.name, Me.message = me.message, Me.stack = me.stack;
          for (var he = de.keys(me), ge = 0; ge < he.length; ++ge) {
            var Ce = he[ge];
            be.test(Ce) || (Me[Ce] = me[Ce]);
          }
          return Me;
        }
        return re.markAsOriginatingFromRejection(me), me;
      }
      oe.exports = function(me, Me) {
        return function(he, ge) {
          if (me !== null) {
            if (he) {
              var Ce = pe(ce(he));
              me._attachExtraTrace(Ce), me._reject(Ce);
            } else if (Me) {
              var Se = [].slice.call(arguments, 1);
              me._fulfill(Se);
            } else me._fulfill(ge);
            me = null;
          }
        };
      };
    }, { "./errors": 12, "./es5": 13, "./util": 36 }], 21: [function(te, oe, ne) {
      oe.exports = function(re) {
        var ce = te("./util"), ue = re._async, de = ce.tryCatch, be = ce.errorObj;
        function pe(he, ge) {
          if (!ce.isArray(he)) return me.call(this, he, ge);
          var Ce = de(ge).apply(this._boundValue(), [null].concat(he));
          Ce === be && ue.throwLater(Ce.e);
        }
        function me(he, ge) {
          var Ce = this._boundValue(), Se = he === void 0 ? de(ge).call(Ce, null) : de(ge).call(Ce, null, he);
          Se === be && ue.throwLater(Se.e);
        }
        function Me(he, ge) {
          if (!he) {
            var Ce = new Error(he + "");
            Ce.cause = he, he = Ce;
          }
          var Se = de(ge).call(this._boundValue(), he);
          Se === be && ue.throwLater(Se.e);
        }
        re.prototype.asCallback = re.prototype.nodeify = function(he, ge) {
          if (typeof he == "function") {
            var Ce = me;
            ge !== void 0 && Object(ge).spread && (Ce = pe), this._then(Ce, Me, void 0, this, he);
          }
          return this;
        };
      };
    }, { "./util": 36 }], 22: [function(te, oe, ne) {
      oe.exports = function() {
        var re = function() {
          return new Se(`circular promise resolution chain

    See http://goo.gl/MqrFmX
`);
        }, ce = function() {
          return new Je.PromiseInspection(this._target());
        }, ue = function(Pe) {
          return Je.reject(new Se(Pe));
        };
        function de() {
        }
        var be, pe = {}, me = te("./util");
        be = me.isNode ? function() {
          var Pe = W.domain;
          return Pe === void 0 && (Pe = null), Pe;
        } : function() {
          return null;
        }, me.notEnumerableProp(Je, "_getDomain", be);
        var Me = te("./es5"), he = te("./async"), ge = new he();
        Me.defineProperty(Je, "_async", { value: ge });
        var Ce = te("./errors"), Se = Je.TypeError = Ce.TypeError;
        Je.RangeError = Ce.RangeError;
        var Ae = Je.CancellationError = Ce.CancellationError;
        Je.TimeoutError = Ce.TimeoutError, Je.OperationalError = Ce.OperationalError, Je.RejectionError = Ce.OperationalError, Je.AggregateError = Ce.AggregateError;
        var Le = function() {
        }, ve = {}, De = {}, Ue = te("./thenables")(Je, Le), Fe = te("./promise_array")(Je, Le, Ue, ue, de), We = te("./context")(Je), Ke = We.create, it = te("./debuggability")(Je, We), Qe = (it.CapturedTrace, te("./finally")(Je, Ue, De)), vt = te("./catch_filter")(De), Ct = te("./nodeback"), Tt = me.errorObj, St = me.tryCatch;
        function Je(Pe) {
          Pe !== Le && function(Ye, ot) {
            if (Ye == null || Ye.constructor !== Je) throw new Se(`the promise constructor cannot be invoked directly

    See http://goo.gl/MqrFmX
`);
            if (typeof ot != "function") throw new Se("expecting a function but got " + me.classString(ot));
          }(this, Pe), this._bitField = 0, this._fulfillmentHandler0 = void 0, this._rejectionHandler0 = void 0, this._promise0 = void 0, this._receiver0 = void 0, this._resolveFromExecutor(Pe), this._promiseCreated(), this._fireEvent("promiseCreated", this);
        }
        function He(Pe) {
          this.promise._resolveCallback(Pe);
        }
        function qe(Pe) {
          this.promise._rejectCallback(Pe, !1);
        }
        function Ze(Pe) {
          var Ye = new Je(Le);
          Ye._fulfillmentHandler0 = Pe, Ye._rejectionHandler0 = Pe, Ye._promise0 = Pe, Ye._receiver0 = Pe;
        }
        return Je.prototype.toString = function() {
          return "[object Promise]";
        }, Je.prototype.caught = Je.prototype.catch = function(Pe) {
          var Ye = arguments.length;
          if (Ye > 1) {
            var ot, Be = new Array(Ye - 1), Ve = 0;
            for (ot = 0; ot < Ye - 1; ++ot) {
              var fe = arguments[ot];
              if (!me.isObject(fe)) return ue("Catch statement predicate: expecting an object but got " + me.classString(fe));
              Be[Ve++] = fe;
            }
            return Be.length = Ve, Pe = arguments[ot], this.then(void 0, vt(Be, Pe, this));
          }
          return this.then(void 0, Pe);
        }, Je.prototype.reflect = function() {
          return this._then(ce, ce, void 0, this, void 0);
        }, Je.prototype.then = function(Pe, Ye) {
          if (it.warnings() && arguments.length > 0 && typeof Pe != "function" && typeof Ye != "function") {
            var ot = ".then() only accepts functions but was passed: " + me.classString(Pe);
            arguments.length > 1 && (ot += ", " + me.classString(Ye)), this._warn(ot);
          }
          return this._then(Pe, Ye, void 0, void 0, void 0);
        }, Je.prototype.done = function(Pe, Ye) {
          this._then(Pe, Ye, void 0, void 0, void 0)._setIsFinal();
        }, Je.prototype.spread = function(Pe) {
          return typeof Pe != "function" ? ue("expecting a function but got " + me.classString(Pe)) : this.all()._then(Pe, void 0, void 0, ve, void 0);
        }, Je.prototype.toJSON = function() {
          var Pe = { isFulfilled: !1, isRejected: !1, fulfillmentValue: void 0, rejectionReason: void 0 };
          return this.isFulfilled() ? (Pe.fulfillmentValue = this.value(), Pe.isFulfilled = !0) : this.isRejected() && (Pe.rejectionReason = this.reason(), Pe.isRejected = !0), Pe;
        }, Je.prototype.all = function() {
          return arguments.length > 0 && this._warn(".all() was passed arguments but it does not take any"), new Fe(this).promise();
        }, Je.prototype.error = function(Pe) {
          return this.caught(me.originatesFromRejection, Pe);
        }, Je.getNewLibraryCopy = oe.exports, Je.is = function(Pe) {
          return Pe instanceof Je;
        }, Je.fromNode = Je.fromCallback = function(Pe) {
          var Ye = new Je(Le);
          Ye._captureStackTrace();
          var ot = arguments.length > 1 && !!Object(arguments[1]).multiArgs, Be = St(Pe)(Ct(Ye, ot));
          return Be === Tt && Ye._rejectCallback(Be.e, !0), Ye._isFateSealed() || Ye._setAsyncGuaranteed(), Ye;
        }, Je.all = function(Pe) {
          return new Fe(Pe).promise();
        }, Je.cast = function(Pe) {
          var Ye = Ue(Pe);
          return Ye instanceof Je || ((Ye = new Je(Le))._captureStackTrace(), Ye._setFulfilled(), Ye._rejectionHandler0 = Pe), Ye;
        }, Je.resolve = Je.fulfilled = Je.cast, Je.reject = Je.rejected = function(Pe) {
          var Ye = new Je(Le);
          return Ye._captureStackTrace(), Ye._rejectCallback(Pe, !0), Ye;
        }, Je.setScheduler = function(Pe) {
          if (typeof Pe != "function") throw new Se("expecting a function but got " + me.classString(Pe));
          return ge.setScheduler(Pe);
        }, Je.prototype._then = function(Pe, Ye, ot, Be, Ve) {
          var fe = Ve !== void 0, _e = fe ? Ve : new Je(Le), je = this._target(), Ne = je._bitField;
          fe || (_e._propagateFrom(this, 3), _e._captureStackTrace(), Be === void 0 && 2097152 & this._bitField && (Be = 50397184 & Ne ? this._boundValue() : je === this ? void 0 : this._boundTo), this._fireEvent("promiseChained", this, _e));
          var Ie = be();
          if (50397184 & Ne) {
            var Xe, ft, It = je._settlePromiseCtx;
            33554432 & Ne ? (ft = je._rejectionHandler0, Xe = Pe) : 16777216 & Ne ? (ft = je._fulfillmentHandler0, Xe = Ye, je._unsetRejectionIsUnhandled()) : (It = je._settlePromiseLateCancellationObserver, ft = new Ae("late cancellation observer"), je._attachExtraTrace(ft), Xe = Ye), ge.invoke(It, je, { handler: Ie === null ? Xe : typeof Xe == "function" && me.domainBind(Ie, Xe), promise: _e, receiver: Be, value: ft });
          } else je._addCallbacks(Pe, Ye, _e, Be, Ie);
          return _e;
        }, Je.prototype._length = function() {
          return 65535 & this._bitField;
        }, Je.prototype._isFateSealed = function() {
          return (117506048 & this._bitField) != 0;
        }, Je.prototype._isFollowing = function() {
          return (67108864 & this._bitField) == 67108864;
        }, Je.prototype._setLength = function(Pe) {
          this._bitField = -65536 & this._bitField | 65535 & Pe;
        }, Je.prototype._setFulfilled = function() {
          this._bitField = 33554432 | this._bitField, this._fireEvent("promiseFulfilled", this);
        }, Je.prototype._setRejected = function() {
          this._bitField = 16777216 | this._bitField, this._fireEvent("promiseRejected", this);
        }, Je.prototype._setFollowing = function() {
          this._bitField = 67108864 | this._bitField, this._fireEvent("promiseResolved", this);
        }, Je.prototype._setIsFinal = function() {
          this._bitField = 4194304 | this._bitField;
        }, Je.prototype._isFinal = function() {
          return (4194304 & this._bitField) > 0;
        }, Je.prototype._unsetCancelled = function() {
          this._bitField = -65537 & this._bitField;
        }, Je.prototype._setCancelled = function() {
          this._bitField = 65536 | this._bitField, this._fireEvent("promiseCancelled", this);
        }, Je.prototype._setWillBeCancelled = function() {
          this._bitField = 8388608 | this._bitField;
        }, Je.prototype._setAsyncGuaranteed = function() {
          ge.hasCustomScheduler() || (this._bitField = 134217728 | this._bitField);
        }, Je.prototype._receiverAt = function(Pe) {
          var Ye = Pe === 0 ? this._receiver0 : this[4 * Pe - 4 + 3];
          if (Ye !== pe) return Ye === void 0 && this._isBound() ? this._boundValue() : Ye;
        }, Je.prototype._promiseAt = function(Pe) {
          return this[4 * Pe - 4 + 2];
        }, Je.prototype._fulfillmentHandlerAt = function(Pe) {
          return this[4 * Pe - 4 + 0];
        }, Je.prototype._rejectionHandlerAt = function(Pe) {
          return this[4 * Pe - 4 + 1];
        }, Je.prototype._boundValue = function() {
        }, Je.prototype._migrateCallback0 = function(Pe) {
          Pe._bitField;
          var Ye = Pe._fulfillmentHandler0, ot = Pe._rejectionHandler0, Be = Pe._promise0, Ve = Pe._receiverAt(0);
          Ve === void 0 && (Ve = pe), this._addCallbacks(Ye, ot, Be, Ve, null);
        }, Je.prototype._migrateCallbackAt = function(Pe, Ye) {
          var ot = Pe._fulfillmentHandlerAt(Ye), Be = Pe._rejectionHandlerAt(Ye), Ve = Pe._promiseAt(Ye), fe = Pe._receiverAt(Ye);
          fe === void 0 && (fe = pe), this._addCallbacks(ot, Be, Ve, fe, null);
        }, Je.prototype._addCallbacks = function(Pe, Ye, ot, Be, Ve) {
          var fe = this._length();
          if (fe >= 65531 && (fe = 0, this._setLength(0)), fe === 0) this._promise0 = ot, this._receiver0 = Be, typeof Pe == "function" && (this._fulfillmentHandler0 = Ve === null ? Pe : me.domainBind(Ve, Pe)), typeof Ye == "function" && (this._rejectionHandler0 = Ve === null ? Ye : me.domainBind(Ve, Ye));
          else {
            var _e = 4 * fe - 4;
            this[_e + 2] = ot, this[_e + 3] = Be, typeof Pe == "function" && (this[_e + 0] = Ve === null ? Pe : me.domainBind(Ve, Pe)), typeof Ye == "function" && (this[_e + 1] = Ve === null ? Ye : me.domainBind(Ve, Ye));
          }
          return this._setLength(fe + 1), fe;
        }, Je.prototype._proxy = function(Pe, Ye) {
          this._addCallbacks(void 0, void 0, Ye, Pe, null);
        }, Je.prototype._resolveCallback = function(Pe, Ye) {
          if (!(117506048 & this._bitField)) {
            if (Pe === this) return this._rejectCallback(re(), !1);
            var ot = Ue(Pe, this);
            if (!(ot instanceof Je)) return this._fulfill(Pe);
            Ye && this._propagateFrom(ot, 2);
            var Be = ot._target();
            if (Be !== this) {
              var Ve = Be._bitField;
              if (50397184 & Ve)
                if (33554432 & Ve) this._fulfill(Be._value());
                else if (16777216 & Ve) this._reject(Be._reason());
                else {
                  var je = new Ae("late cancellation observer");
                  Be._attachExtraTrace(je), this._reject(je);
                }
              else {
                var fe = this._length();
                fe > 0 && Be._migrateCallback0(this);
                for (var _e = 1; _e < fe; ++_e) Be._migrateCallbackAt(this, _e);
                this._setFollowing(), this._setLength(0), this._setFollowee(Be);
              }
            } else this._reject(re());
          }
        }, Je.prototype._rejectCallback = function(Pe, Ye, ot) {
          var Be = me.ensureErrorObject(Pe), Ve = Be === Pe;
          if (!Ve && !ot && it.warnings()) {
            var fe = "a promise was rejected with a non-error: " + me.classString(Pe);
            this._warn(fe, !0);
          }
          this._attachExtraTrace(Be, !!Ye && Ve), this._reject(Pe);
        }, Je.prototype._resolveFromExecutor = function(Pe) {
          if (Pe !== Le) {
            var Ye = this;
            this._captureStackTrace(), this._pushContext();
            var ot = !0, Be = this._execute(Pe, function(Ve) {
              Ye._resolveCallback(Ve);
            }, function(Ve) {
              Ye._rejectCallback(Ve, ot);
            });
            ot = !1, this._popContext(), Be !== void 0 && Ye._rejectCallback(Be, !0);
          }
        }, Je.prototype._settlePromiseFromHandler = function(Pe, Ye, ot, Be) {
          var Ve = Be._bitField;
          if (!(65536 & Ve)) {
            var fe;
            Be._pushContext(), Ye === ve ? ot && typeof ot.length == "number" ? fe = St(Pe).apply(this._boundValue(), ot) : (fe = Tt).e = new Se("cannot .spread() a non-array: " + me.classString(ot)) : fe = St(Pe).call(Ye, ot);
            var _e = Be._popContext();
            !(65536 & (Ve = Be._bitField)) && (fe === De ? Be._reject(ot) : fe === Tt ? Be._rejectCallback(fe.e, !1) : (it.checkForgottenReturns(fe, _e, "", Be, this), Be._resolveCallback(fe)));
          }
        }, Je.prototype._target = function() {
          for (var Pe = this; Pe._isFollowing(); ) Pe = Pe._followee();
          return Pe;
        }, Je.prototype._followee = function() {
          return this._rejectionHandler0;
        }, Je.prototype._setFollowee = function(Pe) {
          this._rejectionHandler0 = Pe;
        }, Je.prototype._settlePromise = function(Pe, Ye, ot, Be) {
          var Ve = Pe instanceof Je, fe = this._bitField, _e = (134217728 & fe) != 0;
          65536 & fe ? (Ve && Pe._invokeInternalOnCancel(), ot instanceof Qe && ot.isFinallyHandler() ? (ot.cancelPromise = Pe, St(Ye).call(ot, Be) === Tt && Pe._reject(Tt.e)) : Ye === ce ? Pe._fulfill(ce.call(ot)) : ot instanceof de ? ot._promiseCancelled(Pe) : Ve || Pe instanceof Fe ? Pe._cancel() : ot.cancel()) : typeof Ye == "function" ? Ve ? (_e && Pe._setAsyncGuaranteed(), this._settlePromiseFromHandler(Ye, ot, Be, Pe)) : Ye.call(ot, Be, Pe) : ot instanceof de ? ot._isResolved() || (33554432 & fe ? ot._promiseFulfilled(Be, Pe) : ot._promiseRejected(Be, Pe)) : Ve && (_e && Pe._setAsyncGuaranteed(), 33554432 & fe ? Pe._fulfill(Be) : Pe._reject(Be));
        }, Je.prototype._settlePromiseLateCancellationObserver = function(Pe) {
          var Ye = Pe.handler, ot = Pe.promise, Be = Pe.receiver, Ve = Pe.value;
          typeof Ye == "function" ? ot instanceof Je ? this._settlePromiseFromHandler(Ye, Be, Ve, ot) : Ye.call(Be, Ve, ot) : ot instanceof Je && ot._reject(Ve);
        }, Je.prototype._settlePromiseCtx = function(Pe) {
          this._settlePromise(Pe.promise, Pe.handler, Pe.receiver, Pe.value);
        }, Je.prototype._settlePromise0 = function(Pe, Ye, ot) {
          var Be = this._promise0, Ve = this._receiverAt(0);
          this._promise0 = void 0, this._receiver0 = void 0, this._settlePromise(Be, Pe, Ve, Ye);
        }, Je.prototype._clearCallbackDataAtIndex = function(Pe) {
          var Ye = 4 * Pe - 4;
          this[Ye + 2] = this[Ye + 3] = this[Ye + 0] = this[Ye + 1] = void 0;
        }, Je.prototype._fulfill = function(Pe) {
          var Ye = this._bitField;
          if (!((117506048 & Ye) >>> 16)) {
            if (Pe === this) {
              var ot = re();
              return this._attachExtraTrace(ot), this._reject(ot);
            }
            this._setFulfilled(), this._rejectionHandler0 = Pe, (65535 & Ye) > 0 && (134217728 & Ye ? this._settlePromises() : ge.settlePromises(this));
          }
        }, Je.prototype._reject = function(Pe) {
          var Ye = this._bitField;
          if (!((117506048 & Ye) >>> 16)) {
            if (this._setRejected(), this._fulfillmentHandler0 = Pe, this._isFinal()) return ge.fatalError(Pe, me.isNode);
            (65535 & Ye) > 0 ? ge.settlePromises(this) : this._ensurePossibleRejectionHandled();
          }
        }, Je.prototype._fulfillPromises = function(Pe, Ye) {
          for (var ot = 1; ot < Pe; ot++) {
            var Be = this._fulfillmentHandlerAt(ot), Ve = this._promiseAt(ot), fe = this._receiverAt(ot);
            this._clearCallbackDataAtIndex(ot), this._settlePromise(Ve, Be, fe, Ye);
          }
        }, Je.prototype._rejectPromises = function(Pe, Ye) {
          for (var ot = 1; ot < Pe; ot++) {
            var Be = this._rejectionHandlerAt(ot), Ve = this._promiseAt(ot), fe = this._receiverAt(ot);
            this._clearCallbackDataAtIndex(ot), this._settlePromise(Ve, Be, fe, Ye);
          }
        }, Je.prototype._settlePromises = function() {
          var Pe = this._bitField, Ye = 65535 & Pe;
          if (Ye > 0) {
            if (16842752 & Pe) {
              var ot = this._fulfillmentHandler0;
              this._settlePromise0(this._rejectionHandler0, ot, Pe), this._rejectPromises(Ye, ot);
            } else {
              var Be = this._rejectionHandler0;
              this._settlePromise0(this._fulfillmentHandler0, Be, Pe), this._fulfillPromises(Ye, Be);
            }
            this._setLength(0);
          }
          this._clearCancellationData();
        }, Je.prototype._settledValue = function() {
          var Pe = this._bitField;
          return 33554432 & Pe ? this._rejectionHandler0 : 16777216 & Pe ? this._fulfillmentHandler0 : void 0;
        }, Je.defer = Je.pending = function() {
          return it.deprecated("Promise.defer", "new Promise"), { promise: new Je(Le), resolve: He, reject: qe };
        }, me.notEnumerableProp(Je, "_makeSelfResolutionError", re), te("./method")(Je, Le, Ue, ue, it), te("./bind")(Je, Le, Ue, it), te("./cancel")(Je, Fe, ue, it), te("./direct_resolve")(Je), te("./synchronous_inspection")(Je), te("./join")(Je, Fe, Ue, Le, ge, be), Je.Promise = Je, Je.version = "3.5.1", te("./map.js")(Je, Fe, ue, Ue, Le, it), te("./call_get.js")(Je), te("./using.js")(Je, ue, Ue, Ke, Le, it), te("./timers.js")(Je, Le, it), te("./generators.js")(Je, ue, Le, Ue, de, it), te("./nodeify.js")(Je), te("./promisify.js")(Je, Le), te("./props.js")(Je, Fe, Ue, ue), te("./race.js")(Je, Le, Ue, ue), te("./reduce.js")(Je, Fe, ue, Ue, Le, it), te("./settle.js")(Je, Fe, it), te("./some.js")(Je, Fe, ue), te("./filter.js")(Je, Le), te("./each.js")(Je, Le), te("./any.js")(Je), me.toFastProperties(Je), me.toFastProperties(Je.prototype), Ze({ a: 1 }), Ze({ b: 2 }), Ze({ c: 3 }), Ze(1), Ze(function() {
        }), Ze(void 0), Ze(!1), Ze(new Je(Le)), it.setBounds(he.firstLineError, me.lastLineError), Je;
      };
    }, { "./any.js": 1, "./async": 2, "./bind": 3, "./call_get.js": 5, "./cancel": 6, "./catch_filter": 7, "./context": 8, "./debuggability": 9, "./direct_resolve": 10, "./each.js": 11, "./errors": 12, "./es5": 13, "./filter.js": 14, "./finally": 15, "./generators.js": 16, "./join": 17, "./map.js": 18, "./method": 19, "./nodeback": 20, "./nodeify.js": 21, "./promise_array": 23, "./promisify.js": 24, "./props.js": 25, "./race.js": 27, "./reduce.js": 28, "./settle.js": 30, "./some.js": 31, "./synchronous_inspection": 32, "./thenables": 33, "./timers.js": 34, "./using.js": 35, "./util": 36 }], 23: [function(te, oe, ne) {
      oe.exports = function(re, ce, ue, de, be) {
        var pe = te("./util");
        function me(Me) {
          var he = this._promise = new re(ce);
          Me instanceof re && he._propagateFrom(Me, 3), he._setOnCancel(this), this._values = Me, this._length = 0, this._totalResolved = 0, this._init(void 0, -2);
        }
        return pe.isArray, pe.inherits(me, be), me.prototype.length = function() {
          return this._length;
        }, me.prototype.promise = function() {
          return this._promise;
        }, me.prototype._init = function Me(he, ge) {
          var Ce = ue(this._values, this._promise);
          if (Ce instanceof re) {
            var Se = (Ce = Ce._target())._bitField;
            if (this._values = Ce, (50397184 & Se) == 0) return this._promise._setAsyncGuaranteed(), Ce._then(Me, this._reject, void 0, this, ge);
            if (!(33554432 & Se)) return 16777216 & Se ? this._reject(Ce._reason()) : this._cancel();
            Ce = Ce._value();
          }
          if ((Ce = pe.asArray(Ce)) !== null) Ce.length !== 0 ? this._iterate(Ce) : ge === -5 ? this._resolveEmptyArray() : this._resolve(function(Le) {
            switch (ge) {
              case -2:
                return [];
              case -3:
                return {};
              case -6:
                return /* @__PURE__ */ new Map();
            }
          }());
          else {
            var Ae = de("expecting an array or an iterable object but got " + pe.classString(Ce)).reason();
            this._promise._rejectCallback(Ae, !1);
          }
        }, me.prototype._iterate = function(Me) {
          var he = this.getActualLength(Me.length);
          this._length = he, this._values = this.shouldCopyValues() ? new Array(he) : this._values;
          for (var ge = this._promise, Ce = !1, Se = null, Ae = 0; Ae < he; ++Ae) {
            var Le = ue(Me[Ae], ge);
            Se = Le instanceof re ? (Le = Le._target())._bitField : null, Ce ? Se !== null && Le.suppressUnhandledRejections() : Se !== null ? 50397184 & Se ? Ce = 33554432 & Se ? this._promiseFulfilled(Le._value(), Ae) : 16777216 & Se ? this._promiseRejected(Le._reason(), Ae) : this._promiseCancelled(Ae) : (Le._proxy(this, Ae), this._values[Ae] = Le) : Ce = this._promiseFulfilled(Le, Ae);
          }
          Ce || ge._setAsyncGuaranteed();
        }, me.prototype._isResolved = function() {
          return this._values === null;
        }, me.prototype._resolve = function(Me) {
          this._values = null, this._promise._fulfill(Me);
        }, me.prototype._cancel = function() {
          !this._isResolved() && this._promise._isCancellable() && (this._values = null, this._promise._cancel());
        }, me.prototype._reject = function(Me) {
          this._values = null, this._promise._rejectCallback(Me, !1);
        }, me.prototype._promiseFulfilled = function(Me, he) {
          return this._values[he] = Me, ++this._totalResolved >= this._length && (this._resolve(this._values), !0);
        }, me.prototype._promiseCancelled = function() {
          return this._cancel(), !0;
        }, me.prototype._promiseRejected = function(Me) {
          return this._totalResolved++, this._reject(Me), !0;
        }, me.prototype._resultCancelled = function() {
          if (!this._isResolved()) {
            var Me = this._values;
            if (this._cancel(), Me instanceof re) Me.cancel();
            else for (var he = 0; he < Me.length; ++he) Me[he] instanceof re && Me[he].cancel();
          }
        }, me.prototype.shouldCopyValues = function() {
          return !0;
        }, me.prototype.getActualLength = function(Me) {
          return Me;
        }, me;
      };
    }, { "./util": 36 }], 24: [function(te, oe, ne) {
      oe.exports = function(re, ce) {
        var ue = {}, de = te("./util"), be = te("./nodeback"), pe = de.withAppended, me = de.maybeWrapAsError, Me = de.canEvaluate, he = te("./errors").TypeError, ge = { __isPromisified__: !0 }, Ce = new RegExp("^(?:" + ["arity", "length", "name", "arguments", "caller", "callee", "prototype", "__isPromisified__"].join("|") + ")$"), Se = function(Ke) {
          return de.isIdentifier(Ke) && Ke.charAt(0) !== "_" && Ke !== "constructor";
        };
        function Ae(Ke) {
          return !Ce.test(Ke);
        }
        function Le(Ke) {
          try {
            return Ke.__isPromisified__ === !0;
          } catch {
            return !1;
          }
        }
        function ve(Ke, it, Qe) {
          var vt = de.getDataPropertyOrDefault(Ke, it + Qe, ge);
          return !!vt && Le(vt);
        }
        function De(Ke, it, Qe, vt) {
          for (var Ct = de.inheritedDataKeys(Ke), Tt = [], St = 0; St < Ct.length; ++St) {
            var Je = Ct[St], He = Ke[Je], qe = vt === Se || Se(Je);
            typeof He != "function" || Le(He) || ve(Ke, Je, it) || !vt(Je, He, Ke, qe) || Tt.push(Je, He);
          }
          return function(Ze, Pe, Ye) {
            for (var ot = 0; ot < Ze.length; ot += 2) {
              var Be = Ze[ot];
              if (Ye.test(Be)) {
                for (var Ve = Be.replace(Ye, ""), fe = 0; fe < Ze.length; fe += 2) if (Ze[fe] === Ve) throw new he(`Cannot promisify an API that has normal methods with '%s'-suffix

    See http://goo.gl/MqrFmX
`.replace("%s", Pe));
              }
            }
          }(Tt, it, Qe), Tt;
        }
        var Ue = function(Ke) {
          return Ke.replace(/([$])/, "\\$");
        }, Fe = Me ? void 0 : function(Ke, it, Qe, vt, Ct, Tt) {
          var St = /* @__PURE__ */ function() {
            return this;
          }(), Je = Ke;
          function He() {
            var qe = it;
            it === ue && (qe = this);
            var Ze = new re(ce);
            Ze._captureStackTrace();
            var Pe = typeof Je == "string" && this !== St ? this[Je] : Ke, Ye = be(Ze, Tt);
            try {
              Pe.apply(qe, pe(arguments, Ye));
            } catch (ot) {
              Ze._rejectCallback(me(ot), !0, !0);
            }
            return Ze._isFateSealed() || Ze._setAsyncGuaranteed(), Ze;
          }
          return typeof Je == "string" && (Ke = vt), de.notEnumerableProp(He, "__isPromisified__", !0), He;
        };
        function We(Ke, it, Qe, vt, Ct) {
          for (var Tt = new RegExp(Ue(it) + "$"), St = De(Ke, it, Tt, Qe), Je = 0, He = St.length; Je < He; Je += 2) {
            var qe = St[Je], Ze = St[Je + 1], Pe = qe + it;
            if (vt === Fe) Ke[Pe] = Fe(qe, ue, qe, Ze, it, Ct);
            else {
              var Ye = vt(Ze, function() {
                return Fe(qe, ue, qe, Ze, it, Ct);
              });
              de.notEnumerableProp(Ye, "__isPromisified__", !0), Ke[Pe] = Ye;
            }
          }
          return de.toFastProperties(Ke), Ke;
        }
        re.promisify = function(Ke, it) {
          if (typeof Ke != "function") throw new he("expecting a function but got " + de.classString(Ke));
          if (Le(Ke)) return Ke;
          var Qe = (it = Object(it)).context === void 0 ? ue : it.context, vt = !!it.multiArgs, Ct = function(Tt, St, Je) {
            return Fe(Tt, St, void 0, Tt, null, vt);
          }(Ke, Qe);
          return de.copyDescriptors(Ke, Ct, Ae), Ct;
        }, re.promisifyAll = function(Ke, it) {
          if (typeof Ke != "function" && typeof Ke != "object") throw new he(`the target of promisifyAll must be an object or a function

    See http://goo.gl/MqrFmX
`);
          var Qe = !!(it = Object(it)).multiArgs, vt = it.suffix;
          typeof vt != "string" && (vt = "Async");
          var Ct = it.filter;
          typeof Ct != "function" && (Ct = Se);
          var Tt = it.promisifier;
          if (typeof Tt != "function" && (Tt = Fe), !de.isIdentifier(vt)) throw new RangeError(`suffix must be a valid identifier

    See http://goo.gl/MqrFmX
`);
          for (var St = de.inheritedDataKeys(Ke), Je = 0; Je < St.length; ++Je) {
            var He = Ke[St[Je]];
            St[Je] !== "constructor" && de.isClass(He) && (We(He.prototype, vt, Ct, Tt, Qe), We(He, vt, Ct, Tt, Qe));
          }
          return We(Ke, vt, Ct, Tt, Qe);
        };
      };
    }, { "./errors": 12, "./nodeback": 20, "./util": 36 }], 25: [function(te, oe, ne) {
      oe.exports = function(re, ce, ue, de) {
        var be, pe = te("./util"), me = pe.isObject, Me = te("./es5");
        typeof Map == "function" && (be = Map);
        var he = /* @__PURE__ */ function() {
          var Se = 0, Ae = 0;
          function Le(ve, De) {
            this[Se] = ve, this[Se + Ae] = De, Se++;
          }
          return function(ve) {
            Ae = ve.size, Se = 0;
            var De = new Array(2 * ve.size);
            return ve.forEach(Le, De), De;
          };
        }();
        function ge(Se) {
          var Ae, Le = !1;
          if (be !== void 0 && Se instanceof be) Ae = he(Se), Le = !0;
          else {
            var ve = Me.keys(Se), De = ve.length;
            Ae = new Array(2 * De);
            for (var Ue = 0; Ue < De; ++Ue) {
              var Fe = ve[Ue];
              Ae[Ue] = Se[Fe], Ae[Ue + De] = Fe;
            }
          }
          this.constructor$(Ae), this._isMap = Le, this._init$(void 0, Le ? -6 : -3);
        }
        function Ce(Se) {
          var Ae, Le = ue(Se);
          return me(Le) ? (Ae = Le instanceof re ? Le._then(re.props, void 0, void 0, void 0, void 0) : new ge(Le).promise(), Le instanceof re && Ae._propagateFrom(Le, 2), Ae) : de(`cannot await properties of a non-object

    See http://goo.gl/MqrFmX
`);
        }
        pe.inherits(ge, ce), ge.prototype._init = function() {
        }, ge.prototype._promiseFulfilled = function(Se, Ae) {
          if (this._values[Ae] = Se, ++this._totalResolved >= this._length) {
            var Le;
            if (this._isMap) Le = function(Fe) {
              for (var We = new be(), Ke = Fe.length / 2 | 0, it = 0; it < Ke; ++it) {
                var Qe = Fe[Ke + it], vt = Fe[it];
                We.set(Qe, vt);
              }
              return We;
            }(this._values);
            else {
              Le = {};
              for (var ve = this.length(), De = 0, Ue = this.length(); De < Ue; ++De) Le[this._values[De + ve]] = this._values[De];
            }
            return this._resolve(Le), !0;
          }
          return !1;
        }, ge.prototype.shouldCopyValues = function() {
          return !1;
        }, ge.prototype.getActualLength = function(Se) {
          return Se >> 1;
        }, re.prototype.props = function() {
          return Ce(this);
        }, re.props = function(Se) {
          return Ce(Se);
        };
      };
    }, { "./es5": 13, "./util": 36 }], 26: [function(te, oe, ne) {
      function re(ce) {
        this._capacity = ce, this._length = 0, this._front = 0;
      }
      re.prototype._willBeOverCapacity = function(ce) {
        return this._capacity < ce;
      }, re.prototype._pushOne = function(ce) {
        var ue = this.length();
        this._checkCapacity(ue + 1), this[this._front + ue & this._capacity - 1] = ce, this._length = ue + 1;
      }, re.prototype.push = function(ce, ue, de) {
        var be = this.length() + 3;
        if (this._willBeOverCapacity(be)) return this._pushOne(ce), this._pushOne(ue), void this._pushOne(de);
        var pe = this._front + be - 3;
        this._checkCapacity(be);
        var me = this._capacity - 1;
        this[pe + 0 & me] = ce, this[pe + 1 & me] = ue, this[pe + 2 & me] = de, this._length = be;
      }, re.prototype.shift = function() {
        var ce = this._front, ue = this[ce];
        return this[ce] = void 0, this._front = ce + 1 & this._capacity - 1, this._length--, ue;
      }, re.prototype.length = function() {
        return this._length;
      }, re.prototype._checkCapacity = function(ce) {
        this._capacity < ce && this._resizeTo(this._capacity << 1);
      }, re.prototype._resizeTo = function(ce) {
        var ue = this._capacity;
        this._capacity = ce, function(de, be, pe, me, Me) {
          for (var he = 0; he < Me; ++he) pe[he + me] = de[he + 0], de[he + 0] = void 0;
        }(this, 0, this, ue, this._front + this._length & ue - 1);
      }, oe.exports = re;
    }, {}], 27: [function(te, oe, ne) {
      oe.exports = function(re, ce, ue, de) {
        var be = te("./util"), pe = function(Me) {
          return Me.then(function(he) {
            return me(he, Me);
          });
        };
        function me(Me, he) {
          var ge = ue(Me);
          if (ge instanceof re) return pe(ge);
          if ((Me = be.asArray(Me)) === null) return de("expecting an array or an iterable object but got " + be.classString(Me));
          var Ce = new re(ce);
          he !== void 0 && Ce._propagateFrom(he, 3);
          for (var Se = Ce._fulfill, Ae = Ce._reject, Le = 0, ve = Me.length; Le < ve; ++Le) {
            var De = Me[Le];
            (De !== void 0 || Le in Me) && re.cast(De)._then(Se, Ae, void 0, Ce, null);
          }
          return Ce;
        }
        re.race = function(Me) {
          return me(Me, void 0);
        }, re.prototype.race = function() {
          return me(this, void 0);
        };
      };
    }, { "./util": 36 }], 28: [function(te, oe, ne) {
      oe.exports = function(re, ce, ue, de, be, pe) {
        var me = re._getDomain, Me = te("./util"), he = Me.tryCatch;
        function ge(ve, De, Ue, Fe) {
          this.constructor$(ve);
          var We = me();
          this._fn = We === null ? De : Me.domainBind(We, De), Ue !== void 0 && (Ue = re.resolve(Ue))._attachCancellationCallback(this), this._initialValue = Ue, this._currentCancellable = null, this._eachValues = Fe === be ? Array(this._length) : Fe === 0 ? null : void 0, this._promise._captureStackTrace(), this._init$(void 0, -5);
        }
        function Ce(ve, De) {
          this.isFulfilled() ? De._resolve(ve) : De._reject(ve);
        }
        function Se(ve, De, Ue, Fe) {
          return typeof De != "function" ? ue("expecting a function but got " + Me.classString(De)) : new ge(ve, De, Ue, Fe).promise();
        }
        function Ae(ve) {
          this.accum = ve, this.array._gotAccum(ve);
          var De = de(this.value, this.array._promise);
          return De instanceof re ? (this.array._currentCancellable = De, De._then(Le, void 0, void 0, this, void 0)) : Le.call(this, De);
        }
        function Le(ve) {
          var De, Ue = this.array, Fe = Ue._promise, We = he(Ue._fn);
          Fe._pushContext(), (De = Ue._eachValues !== void 0 ? We.call(Fe._boundValue(), ve, this.index, this.length) : We.call(Fe._boundValue(), this.accum, ve, this.index, this.length)) instanceof re && (Ue._currentCancellable = De);
          var Ke = Fe._popContext();
          return pe.checkForgottenReturns(De, Ke, Ue._eachValues !== void 0 ? "Promise.each" : "Promise.reduce", Fe), De;
        }
        Me.inherits(ge, ce), ge.prototype._gotAccum = function(ve) {
          this._eachValues !== void 0 && this._eachValues !== null && ve !== be && this._eachValues.push(ve);
        }, ge.prototype._eachComplete = function(ve) {
          return this._eachValues !== null && this._eachValues.push(ve), this._eachValues;
        }, ge.prototype._init = function() {
        }, ge.prototype._resolveEmptyArray = function() {
          this._resolve(this._eachValues !== void 0 ? this._eachValues : this._initialValue);
        }, ge.prototype.shouldCopyValues = function() {
          return !1;
        }, ge.prototype._resolve = function(ve) {
          this._promise._resolveCallback(ve), this._values = null;
        }, ge.prototype._resultCancelled = function(ve) {
          if (ve === this._initialValue) return this._cancel();
          this._isResolved() || (this._resultCancelled$(), this._currentCancellable instanceof re && this._currentCancellable.cancel(), this._initialValue instanceof re && this._initialValue.cancel());
        }, ge.prototype._iterate = function(ve) {
          var De, Ue;
          this._values = ve;
          var Fe = ve.length;
          if (this._initialValue !== void 0 ? (De = this._initialValue, Ue = 0) : (De = re.resolve(ve[0]), Ue = 1), this._currentCancellable = De, !De.isRejected()) for (; Ue < Fe; ++Ue) {
            var We = { accum: null, value: ve[Ue], index: Ue, length: Fe, array: this };
            De = De._then(Ae, void 0, void 0, We, void 0);
          }
          this._eachValues !== void 0 && (De = De._then(this._eachComplete, void 0, void 0, this, void 0)), De._then(Ce, Ce, void 0, De, this);
        }, re.prototype.reduce = function(ve, De) {
          return Se(this, ve, De, null);
        }, re.reduce = function(ve, De, Ue, Fe) {
          return Se(ve, De, Ue, Fe);
        };
      };
    }, { "./util": 36 }], 29: [function(te, oe, ne) {
      var re, ce = te("./util"), ue = ce.getNativePromise();
      if (ce.isNode && typeof MutationObserver > "u") {
        var de = X.setImmediate, be = W.nextTick;
        re = ce.isRecentNode ? function(me) {
          de.call(X, me);
        } : function(me) {
          be.call(W, me);
        };
      } else if (typeof ue == "function" && typeof ue.resolve == "function") {
        var pe = ue.resolve();
        re = function(me) {
          pe.then(me);
        };
      } else re = typeof MutationObserver > "u" || typeof window < "u" && window.navigator && (window.navigator.standalone || window.cordova) ? J !== void 0 ? function(me) {
        J(me);
      } : typeof setTimeout < "u" ? function(me) {
        setTimeout(me, 0);
      } : function() {
        throw new Error(`No async scheduler available

    See http://goo.gl/MqrFmX
`);
      } : function() {
        var me = document.createElement("div"), Me = { attributes: !0 }, he = !1, ge = document.createElement("div");
        return new MutationObserver(function() {
          me.classList.toggle("foo"), he = !1;
        }).observe(ge, Me), function(Ce) {
          var Se = new MutationObserver(function() {
            Se.disconnect(), Ce();
          });
          Se.observe(me, Me), he || (he = !0, ge.classList.toggle("foo"));
        };
      }();
      oe.exports = re;
    }, { "./util": 36 }], 30: [function(te, oe, ne) {
      oe.exports = function(re, ce, ue) {
        var de = re.PromiseInspection;
        function be(pe) {
          this.constructor$(pe);
        }
        te("./util").inherits(be, ce), be.prototype._promiseResolved = function(pe, me) {
          return this._values[pe] = me, ++this._totalResolved >= this._length && (this._resolve(this._values), !0);
        }, be.prototype._promiseFulfilled = function(pe, me) {
          var Me = new de();
          return Me._bitField = 33554432, Me._settledValueField = pe, this._promiseResolved(me, Me);
        }, be.prototype._promiseRejected = function(pe, me) {
          var Me = new de();
          return Me._bitField = 16777216, Me._settledValueField = pe, this._promiseResolved(me, Me);
        }, re.settle = function(pe) {
          return ue.deprecated(".settle()", ".reflect()"), new be(pe).promise();
        }, re.prototype.settle = function() {
          return re.settle(this);
        };
      };
    }, { "./util": 36 }], 31: [function(te, oe, ne) {
      oe.exports = function(re, ce, ue) {
        var de = te("./util"), be = te("./errors").RangeError, pe = te("./errors").AggregateError, me = de.isArray, Me = {};
        function he(Ce) {
          this.constructor$(Ce), this._howMany = 0, this._unwrap = !1, this._initialized = !1;
        }
        function ge(Ce, Se) {
          if ((0 | Se) !== Se || Se < 0) return ue(`expecting a positive integer

    See http://goo.gl/MqrFmX
`);
          var Ae = new he(Ce), Le = Ae.promise();
          return Ae.setHowMany(Se), Ae.init(), Le;
        }
        de.inherits(he, ce), he.prototype._init = function() {
          if (this._initialized) if (this._howMany !== 0) {
            this._init$(void 0, -5);
            var Ce = me(this._values);
            !this._isResolved() && Ce && this._howMany > this._canPossiblyFulfill() && this._reject(this._getRangeError(this.length()));
          } else this._resolve([]);
        }, he.prototype.init = function() {
          this._initialized = !0, this._init();
        }, he.prototype.setUnwrap = function() {
          this._unwrap = !0;
        }, he.prototype.howMany = function() {
          return this._howMany;
        }, he.prototype.setHowMany = function(Ce) {
          this._howMany = Ce;
        }, he.prototype._promiseFulfilled = function(Ce) {
          return this._addFulfilled(Ce), this._fulfilled() === this.howMany() && (this._values.length = this.howMany(), this.howMany() === 1 && this._unwrap ? this._resolve(this._values[0]) : this._resolve(this._values), !0);
        }, he.prototype._promiseRejected = function(Ce) {
          return this._addRejected(Ce), this._checkOutcome();
        }, he.prototype._promiseCancelled = function() {
          return this._values instanceof re || this._values == null ? this._cancel() : (this._addRejected(Me), this._checkOutcome());
        }, he.prototype._checkOutcome = function() {
          if (this.howMany() > this._canPossiblyFulfill()) {
            for (var Ce = new pe(), Se = this.length(); Se < this._values.length; ++Se) this._values[Se] !== Me && Ce.push(this._values[Se]);
            return Ce.length > 0 ? this._reject(Ce) : this._cancel(), !0;
          }
          return !1;
        }, he.prototype._fulfilled = function() {
          return this._totalResolved;
        }, he.prototype._rejected = function() {
          return this._values.length - this.length();
        }, he.prototype._addRejected = function(Ce) {
          this._values.push(Ce);
        }, he.prototype._addFulfilled = function(Ce) {
          this._values[this._totalResolved++] = Ce;
        }, he.prototype._canPossiblyFulfill = function() {
          return this.length() - this._rejected();
        }, he.prototype._getRangeError = function(Ce) {
          var Se = "Input array must contain at least " + this._howMany + " items but contains only " + Ce + " items";
          return new be(Se);
        }, he.prototype._resolveEmptyArray = function() {
          this._reject(this._getRangeError(0));
        }, re.some = function(Ce, Se) {
          return ge(Ce, Se);
        }, re.prototype.some = function(Ce) {
          return ge(this, Ce);
        }, re._SomePromiseArray = he;
      };
    }, { "./errors": 12, "./util": 36 }], 32: [function(te, oe, ne) {
      oe.exports = function(re) {
        function ce(he) {
          he !== void 0 ? (he = he._target(), this._bitField = he._bitField, this._settledValueField = he._isFateSealed() ? he._settledValue() : void 0) : (this._bitField = 0, this._settledValueField = void 0);
        }
        ce.prototype._settledValue = function() {
          return this._settledValueField;
        };
        var ue = ce.prototype.value = function() {
          if (!this.isFulfilled()) throw new TypeError(`cannot get fulfillment value of a non-fulfilled promise

    See http://goo.gl/MqrFmX
`);
          return this._settledValue();
        }, de = ce.prototype.error = ce.prototype.reason = function() {
          if (!this.isRejected()) throw new TypeError(`cannot get rejection reason of a non-rejected promise

    See http://goo.gl/MqrFmX
`);
          return this._settledValue();
        }, be = ce.prototype.isFulfilled = function() {
          return (33554432 & this._bitField) != 0;
        }, pe = ce.prototype.isRejected = function() {
          return (16777216 & this._bitField) != 0;
        }, me = ce.prototype.isPending = function() {
          return (50397184 & this._bitField) == 0;
        }, Me = ce.prototype.isResolved = function() {
          return (50331648 & this._bitField) != 0;
        };
        ce.prototype.isCancelled = function() {
          return (8454144 & this._bitField) != 0;
        }, re.prototype.__isCancelled = function() {
          return (65536 & this._bitField) == 65536;
        }, re.prototype._isCancelled = function() {
          return this._target().__isCancelled();
        }, re.prototype.isCancelled = function() {
          return (8454144 & this._target()._bitField) != 0;
        }, re.prototype.isPending = function() {
          return me.call(this._target());
        }, re.prototype.isRejected = function() {
          return pe.call(this._target());
        }, re.prototype.isFulfilled = function() {
          return be.call(this._target());
        }, re.prototype.isResolved = function() {
          return Me.call(this._target());
        }, re.prototype.value = function() {
          return ue.call(this._target());
        }, re.prototype.reason = function() {
          var he = this._target();
          return he._unsetRejectionIsUnhandled(), de.call(he);
        }, re.prototype._value = function() {
          return this._settledValue();
        }, re.prototype._reason = function() {
          return this._unsetRejectionIsUnhandled(), this._settledValue();
        }, re.PromiseInspection = ce;
      };
    }, {}], 33: [function(te, oe, ne) {
      oe.exports = function(re, ce) {
        var ue = te("./util"), de = ue.errorObj, be = ue.isObject, pe = {}.hasOwnProperty;
        return function(me, Me) {
          if (be(me)) {
            if (me instanceof re) return me;
            var he = function(Ce) {
              try {
                return function(Se) {
                  return Se.then;
                }(Ce);
              } catch (Se) {
                return de.e = Se, de;
              }
            }(me);
            if (he === de) {
              Me && Me._pushContext();
              var ge = re.reject(he.e);
              return Me && Me._popContext(), ge;
            }
            if (typeof he == "function") return function(Ce) {
              try {
                return pe.call(Ce, "_promise0");
              } catch {
                return !1;
              }
            }(me) ? (ge = new re(ce), me._then(ge._fulfill, ge._reject, void 0, ge, null), ge) : function(Ce, Se, Ae) {
              var Le = new re(ce), ve = Le;
              Ae && Ae._pushContext(), Le._captureStackTrace(), Ae && Ae._popContext();
              var De = !0, Ue = ue.tryCatch(Se).call(Ce, function(Fe) {
                Le && (Le._resolveCallback(Fe), Le = null);
              }, function(Fe) {
                Le && (Le._rejectCallback(Fe, De, !0), Le = null);
              });
              return De = !1, Le && Ue === de && (Le._rejectCallback(Ue.e, !0, !0), Le = null), ve;
            }(me, he, Me);
          }
          return me;
        };
      };
    }, { "./util": 36 }], 34: [function(te, oe, ne) {
      oe.exports = function(re, ce, ue) {
        var de = te("./util"), be = re.TimeoutError;
        function pe(Ce) {
          this.handle = Ce;
        }
        pe.prototype._resultCancelled = function() {
          clearTimeout(this.handle);
        };
        var me = function(Ce) {
          return Me(+this).thenReturn(Ce);
        }, Me = re.delay = function(Ce, Se) {
          var Ae, Le;
          return Se !== void 0 ? (Ae = re.resolve(Se)._then(me, null, null, Ce, void 0), ue.cancellation() && Se instanceof re && Ae._setOnCancel(Se)) : (Ae = new re(ce), Le = setTimeout(function() {
            Ae._fulfill();
          }, +Ce), ue.cancellation() && Ae._setOnCancel(new pe(Le)), Ae._captureStackTrace()), Ae._setAsyncGuaranteed(), Ae;
        };
        function he(Ce) {
          return clearTimeout(this.handle), Ce;
        }
        function ge(Ce) {
          throw clearTimeout(this.handle), Ce;
        }
        re.prototype.delay = function(Ce) {
          return Me(Ce, this);
        }, re.prototype.timeout = function(Ce, Se) {
          var Ae, Le;
          Ce = +Ce;
          var ve = new pe(setTimeout(function() {
            Ae.isPending() && function(De, Ue, Fe) {
              var We;
              We = typeof Ue != "string" ? Ue instanceof Error ? Ue : new be("operation timed out") : new be(Ue), de.markAsOriginatingFromRejection(We), De._attachExtraTrace(We), De._reject(We), Fe != null && Fe.cancel();
            }(Ae, Se, Le);
          }, Ce));
          return ue.cancellation() ? (Le = this.then(), (Ae = Le._then(he, ge, void 0, ve, void 0))._setOnCancel(ve)) : Ae = this._then(he, ge, void 0, ve, void 0), Ae;
        };
      };
    }, { "./util": 36 }], 35: [function(te, oe, ne) {
      oe.exports = function(re, ce, ue, de, be, pe) {
        var me = te("./util"), Me = te("./errors").TypeError, he = te("./util").inherits, ge = me.errorObj, Ce = me.tryCatch, Se = {};
        function Ae(We) {
          setTimeout(function() {
            throw We;
          }, 0);
        }
        function Le(We, Ke) {
          var it = 0, Qe = We.length, vt = new re(be);
          return function Ct() {
            if (it >= Qe) return vt._fulfill();
            var Tt = function(St) {
              var Je = ue(St);
              return Je !== St && typeof St._isDisposable == "function" && typeof St._getDisposer == "function" && St._isDisposable() && Je._setDisposable(St._getDisposer()), Je;
            }(We[it++]);
            if (Tt instanceof re && Tt._isDisposable()) {
              try {
                Tt = ue(Tt._getDisposer().tryDispose(Ke), We.promise);
              } catch (St) {
                return Ae(St);
              }
              if (Tt instanceof re) return Tt._then(Ct, Ae, null, null, null);
            }
            Ct();
          }(), vt;
        }
        function ve(We, Ke, it) {
          this._data = We, this._promise = Ke, this._context = it;
        }
        function De(We, Ke, it) {
          this.constructor$(We, Ke, it);
        }
        function Ue(We) {
          return ve.isDisposer(We) ? (this.resources[this.index]._setDisposable(We), We.promise()) : We;
        }
        function Fe(We) {
          this.length = We, this.promise = null, this[We - 1] = null;
        }
        ve.prototype.data = function() {
          return this._data;
        }, ve.prototype.promise = function() {
          return this._promise;
        }, ve.prototype.resource = function() {
          return this.promise().isFulfilled() ? this.promise().value() : Se;
        }, ve.prototype.tryDispose = function(We) {
          var Ke = this.resource(), it = this._context;
          it !== void 0 && it._pushContext();
          var Qe = Ke !== Se ? this.doDispose(Ke, We) : null;
          return it !== void 0 && it._popContext(), this._promise._unsetDisposable(), this._data = null, Qe;
        }, ve.isDisposer = function(We) {
          return We != null && typeof We.resource == "function" && typeof We.tryDispose == "function";
        }, he(De, ve), De.prototype.doDispose = function(We, Ke) {
          return this.data().call(We, We, Ke);
        }, Fe.prototype._resultCancelled = function() {
          for (var We = this.length, Ke = 0; Ke < We; ++Ke) {
            var it = this[Ke];
            it instanceof re && it.cancel();
          }
        }, re.using = function() {
          var We = arguments.length;
          if (We < 2) return ce("you must pass at least 2 arguments to Promise.using");
          var Ke, it = arguments[We - 1];
          if (typeof it != "function") return ce("expecting a function but got " + me.classString(it));
          var Qe = !0;
          We === 2 && Array.isArray(arguments[0]) ? (We = (Ke = arguments[0]).length, Qe = !1) : (Ke = arguments, We--);
          for (var vt = new Fe(We), Ct = 0; Ct < We; ++Ct) {
            var Tt = Ke[Ct];
            if (ve.isDisposer(Tt)) {
              var St = Tt;
              (Tt = Tt.promise())._setDisposable(St);
            } else {
              var Je = ue(Tt);
              Je instanceof re && (Tt = Je._then(Ue, null, null, { resources: vt, index: Ct }, void 0));
            }
            vt[Ct] = Tt;
          }
          var He = new Array(vt.length);
          for (Ct = 0; Ct < He.length; ++Ct) He[Ct] = re.resolve(vt[Ct]).reflect();
          var qe = re.all(He).then(function(Pe) {
            for (var Ye = 0; Ye < Pe.length; ++Ye) {
              var ot = Pe[Ye];
              if (ot.isRejected()) return ge.e = ot.error(), ge;
              if (!ot.isFulfilled()) return void qe.cancel();
              Pe[Ye] = ot.value();
            }
            Ze._pushContext(), it = Ce(it);
            var Be = Qe ? it.apply(void 0, Pe) : it(Pe), Ve = Ze._popContext();
            return pe.checkForgottenReturns(Be, Ve, "Promise.using", Ze), Be;
          }), Ze = qe.lastly(function() {
            var Pe = new re.PromiseInspection(qe);
            return Le(vt, Pe);
          });
          return vt.promise = Ze, Ze._setOnCancel(vt), Ze;
        }, re.prototype._setDisposable = function(We) {
          this._bitField = 131072 | this._bitField, this._disposer = We;
        }, re.prototype._isDisposable = function() {
          return (131072 & this._bitField) > 0;
        }, re.prototype._getDisposer = function() {
          return this._disposer;
        }, re.prototype._unsetDisposable = function() {
          this._bitField = -131073 & this._bitField, this._disposer = void 0;
        }, re.prototype.disposer = function(We) {
          if (typeof We == "function") return new De(We, this, de());
          throw new Me();
        };
      };
    }, { "./errors": 12, "./util": 36 }], 36: [function(te, oe, ne) {
      var re, ce = te("./es5"), ue = typeof navigator > "u", de = { e: {} }, be = typeof self < "u" ? self : typeof window < "u" ? window : X !== void 0 ? X : this !== void 0 ? this : null;
      function pe() {
        try {
          var Qe = re;
          return re = null, Qe.apply(this, arguments);
        } catch (vt) {
          return de.e = vt, de;
        }
      }
      function me(Qe) {
        return Qe == null || Qe === !0 || Qe === !1 || typeof Qe == "string" || typeof Qe == "number";
      }
      function Me(Qe, vt, Ct) {
        if (me(Qe)) return Qe;
        var Tt = { value: Ct, configurable: !0, enumerable: !1, writable: !0 };
        return ce.defineProperty(Qe, vt, Tt), Qe;
      }
      var he = function() {
        var Qe = [Array.prototype, Object.prototype, Function.prototype], vt = function(St) {
          for (var Je = 0; Je < Qe.length; ++Je) if (Qe[Je] === St) return !0;
          return !1;
        };
        if (ce.isES5) {
          var Ct = Object.getOwnPropertyNames;
          return function(St) {
            for (var Je = [], He = /* @__PURE__ */ Object.create(null); St != null && !vt(St); ) {
              var qe;
              try {
                qe = Ct(St);
              } catch {
                return Je;
              }
              for (var Ze = 0; Ze < qe.length; ++Ze) {
                var Pe = qe[Ze];
                if (!He[Pe]) {
                  He[Pe] = !0;
                  var Ye = Object.getOwnPropertyDescriptor(St, Pe);
                  Ye != null && Ye.get == null && Ye.set == null && Je.push(Pe);
                }
              }
              St = ce.getPrototypeOf(St);
            }
            return Je;
          };
        }
        var Tt = {}.hasOwnProperty;
        return function(St) {
          if (vt(St)) return [];
          var Je = [];
          e: for (var He in St) if (Tt.call(St, He)) Je.push(He);
          else {
            for (var qe = 0; qe < Qe.length; ++qe) if (Tt.call(Qe[qe], He)) continue e;
            Je.push(He);
          }
          return Je;
        };
      }(), ge = /this\s*\.\s*\S+\s*=/, Ce = /^[a-z$_][a-z$_0-9]*$/i;
      function Se(Qe) {
        try {
          return Qe + "";
        } catch {
          return "[no string representation]";
        }
      }
      function Ae(Qe) {
        return Qe instanceof Error || Qe !== null && typeof Qe == "object" && typeof Qe.message == "string" && typeof Qe.name == "string";
      }
      function Le(Qe) {
        return Ae(Qe) && ce.propertyIsWritable(Qe, "stack");
      }
      var ve = "stack" in new Error() ? function(Qe) {
        return Le(Qe) ? Qe : new Error(Se(Qe));
      } : function(Qe) {
        if (Le(Qe)) return Qe;
        try {
          throw new Error(Se(Qe));
        } catch (vt) {
          return vt;
        }
      };
      function De(Qe) {
        return {}.toString.call(Qe);
      }
      var Ue = function(Qe) {
        return ce.isArray(Qe) ? Qe : null;
      };
      if (typeof Symbol < "u" && Symbol.iterator) {
        var Fe = typeof Array.from == "function" ? function(Qe) {
          return Array.from(Qe);
        } : function(Qe) {
          for (var vt, Ct = [], Tt = Qe[Symbol.iterator](); !(vt = Tt.next()).done; ) Ct.push(vt.value);
          return Ct;
        };
        Ue = function(Qe) {
          return ce.isArray(Qe) ? Qe : Qe != null && typeof Qe[Symbol.iterator] == "function" ? Fe(Qe) : null;
        };
      }
      var We = W !== void 0 && De(W).toLowerCase() === "[object process]", Ke = W !== void 0 && W.env !== void 0, it = { isClass: function(Qe) {
        try {
          if (typeof Qe == "function") {
            var vt = ce.names(Qe.prototype), Ct = ce.isES5 && vt.length > 1, Tt = vt.length > 0 && !(vt.length === 1 && vt[0] === "constructor"), St = ge.test(Qe + "") && ce.names(Qe).length > 0;
            if (Ct || Tt || St) return !0;
          }
          return !1;
        } catch {
          return !1;
        }
      }, isIdentifier: function(Qe) {
        return Ce.test(Qe);
      }, inheritedDataKeys: he, getDataPropertyOrDefault: function(Qe, vt, Ct) {
        if (!ce.isES5) return {}.hasOwnProperty.call(Qe, vt) ? Qe[vt] : void 0;
        var Tt = Object.getOwnPropertyDescriptor(Qe, vt);
        return Tt != null ? Tt.get == null && Tt.set == null ? Tt.value : Ct : void 0;
      }, thrower: function(Qe) {
        throw Qe;
      }, isArray: ce.isArray, asArray: Ue, notEnumerableProp: Me, isPrimitive: me, isObject: function(Qe) {
        return typeof Qe == "function" || typeof Qe == "object" && Qe !== null;
      }, isError: Ae, canEvaluate: ue, errorObj: de, tryCatch: function(Qe) {
        return re = Qe, pe;
      }, inherits: function(Qe, vt) {
        var Ct = {}.hasOwnProperty;
        function Tt() {
          for (var St in this.constructor = Qe, this.constructor$ = vt, vt.prototype) Ct.call(vt.prototype, St) && St.charAt(St.length - 1) !== "$" && (this[St + "$"] = vt.prototype[St]);
        }
        return Tt.prototype = vt.prototype, Qe.prototype = new Tt(), Qe.prototype;
      }, withAppended: function(Qe, vt) {
        var Ct, Tt = Qe.length, St = new Array(Tt + 1);
        for (Ct = 0; Ct < Tt; ++Ct) St[Ct] = Qe[Ct];
        return St[Ct] = vt, St;
      }, maybeWrapAsError: function(Qe) {
        return me(Qe) ? new Error(Se(Qe)) : Qe;
      }, toFastProperties: function(Qe) {
        return Qe;
      }, filledRange: function(Qe, vt, Ct) {
        for (var Tt = new Array(Qe), St = 0; St < Qe; ++St) Tt[St] = vt + St + Ct;
        return Tt;
      }, toString: Se, canAttachTrace: Le, ensureErrorObject: ve, originatesFromRejection: function(Qe) {
        return Qe != null && (Qe instanceof Error.__BluebirdErrorTypes__.OperationalError || Qe.isOperational === !0);
      }, markAsOriginatingFromRejection: function(Qe) {
        try {
          Me(Qe, "isOperational", !0);
        } catch {
        }
      }, classString: De, copyDescriptors: function(Qe, vt, Ct) {
        for (var Tt = ce.names(Qe), St = 0; St < Tt.length; ++St) {
          var Je = Tt[St];
          if (Ct(Je)) try {
            ce.defineProperty(vt, Je, ce.getDescriptor(Qe, Je));
          } catch {
          }
        }
      }, hasDevTools: typeof chrome < "u" && chrome && typeof chrome.loadTimes == "function", isNode: We, hasEnvVariables: Ke, env: function(Qe) {
        return Ke ? W.env[Qe] : void 0;
      }, global: be, getNativePromise: function() {
        if (typeof Promise == "function") try {
          var Qe = new Promise(function() {
          });
          if ({}.toString.call(Qe) === "[object Promise]") return Promise;
        } catch {
        }
      }, domainBind: function(Qe, vt) {
        return Qe.bind(vt);
      } };
      it.isRecentNode = it.isNode && function() {
        var Qe = W.versions.node.split(".").map(Number);
        return Qe[0] === 0 && Qe[1] > 10 || Qe[0] > 0;
      }(), it.isNode && it.toFastProperties(W);
      try {
        throw new Error();
      } catch (Qe) {
        it.lastLineError = Qe;
      }
      oe.exports = it;
    }, { "./es5": 13 }] }, {}, [4])(4), typeof window < "u" && window !== null ? window.P = window.Promise : typeof self < "u" && self !== null && (self.P = self.Promise);
  }).call(this, A(4), A(0), A(11).setImmediate);
}, function(C, L, A) {
  Object.defineProperty(L, "__esModule", { value: !0 }), L.default = function(W, X) {
    if (!X.eol && W) {
      for (var J = 0, te = W.length; J < te; J++) if (W[J] === "\r") {
        if (W[J + 1] === `
`) {
          X.eol = `\r
`;
          break;
        }
        if (W[J + 1]) {
          X.eol = "\r";
          break;
        }
      } else if (W[J] === `
`) {
        X.eol = `
`;
        break;
      }
    }
    return X.eol || `
`;
  };
}, function(C, L, A) {
  var W = A(65), X = A(73);
  C.exports = function(J, te) {
    var oe = X(J, te);
    return W(oe) ? oe : void 0;
  };
}, function(C, L, A) {
  var W = A(19).Symbol;
  C.exports = W;
}, function(C, L, A) {
  var W = A(67), X = typeof self == "object" && self && self.Object === Object && self, J = W || X || Function("return this")();
  C.exports = J;
}, function(C, L) {
  C.exports = function(A) {
    var W = typeof A;
    return A != null && (W == "object" || W == "function");
  };
}, function(C, L) {
  var A = Array.isArray;
  C.exports = A;
}, function(C, L, A) {
  var W = A(30), X = A(76);
  C.exports = function(J) {
    return typeof J == "symbol" || X(J) && W(J) == "[object Symbol]";
  };
}, function(C, L, A) {
  (function(W, X) {
    var J = A(6);
    C.exports = Se;
    var te, oe = A(37);
    Se.ReadableState = Ce, A(12).EventEmitter;
    var ne = function(He, qe) {
      return He.listeners(qe).length;
    }, re = A(24), ce = A(7).Buffer, ue = W.Uint8Array || function() {
    }, de = A(5);
    de.inherits = A(2);
    var be = A(41), pe = void 0;
    pe = be && be.debuglog ? be.debuglog("stream") : function() {
    };
    var me, Me = A(42), he = A(25);
    de.inherits(Se, re);
    var ge = ["error", "close", "destroy", "pause", "resume"];
    function Ce(He, qe) {
      te = te || A(1), He = He || {};
      var Ze = qe instanceof te;
      this.objectMode = !!He.objectMode, Ze && (this.objectMode = this.objectMode || !!He.readableObjectMode);
      var Pe = He.highWaterMark, Ye = He.readableHighWaterMark, ot = this.objectMode ? 16 : 16384;
      this.highWaterMark = Pe || Pe === 0 ? Pe : Ze && (Ye || Ye === 0) ? Ye : ot, this.highWaterMark = Math.floor(this.highWaterMark), this.buffer = new Me(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.destroyed = !1, this.defaultEncoding = He.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, He.encoding && (me || (me = A(26).StringDecoder), this.decoder = new me(He.encoding), this.encoding = He.encoding);
    }
    function Se(He) {
      if (te = te || A(1), !(this instanceof Se)) return new Se(He);
      this._readableState = new Ce(He, this), this.readable = !0, He && (typeof He.read == "function" && (this._read = He.read), typeof He.destroy == "function" && (this._destroy = He.destroy)), re.call(this);
    }
    function Ae(He, qe, Ze, Pe, Ye) {
      var ot, Be = He._readableState;
      return qe === null ? (Be.reading = !1, function(Ve, fe) {
        if (!fe.ended) {
          if (fe.decoder) {
            var _e = fe.decoder.end();
            _e && _e.length && (fe.buffer.push(_e), fe.length += fe.objectMode ? 1 : _e.length);
          }
          fe.ended = !0, Ue(Ve);
        }
      }(He, Be)) : (Ye || (ot = function(Ve, fe) {
        var _e;
        return function(je) {
          return ce.isBuffer(je) || je instanceof ue;
        }(fe) || typeof fe == "string" || fe === void 0 || Ve.objectMode || (_e = new TypeError("Invalid non-string/buffer chunk")), _e;
      }(Be, qe)), ot ? He.emit("error", ot) : Be.objectMode || qe && qe.length > 0 ? (typeof qe == "string" || Be.objectMode || Object.getPrototypeOf(qe) === ce.prototype || (qe = function(Ve) {
        return ce.from(Ve);
      }(qe)), Pe ? Be.endEmitted ? He.emit("error", new Error("stream.unshift() after end event")) : Le(He, Be, qe, !0) : Be.ended ? He.emit("error", new Error("stream.push() after EOF")) : (Be.reading = !1, Be.decoder && !Ze ? (qe = Be.decoder.write(qe), Be.objectMode || qe.length !== 0 ? Le(He, Be, qe, !1) : We(He, Be)) : Le(He, Be, qe, !1))) : Pe || (Be.reading = !1)), function(Ve) {
        return !Ve.ended && (Ve.needReadable || Ve.length < Ve.highWaterMark || Ve.length === 0);
      }(Be);
    }
    function Le(He, qe, Ze, Pe) {
      qe.flowing && qe.length === 0 && !qe.sync ? (He.emit("data", Ze), He.read(0)) : (qe.length += qe.objectMode ? 1 : Ze.length, Pe ? qe.buffer.unshift(Ze) : qe.buffer.push(Ze), qe.needReadable && Ue(He)), We(He, qe);
    }
    Object.defineProperty(Se.prototype, "destroyed", { get: function() {
      return this._readableState !== void 0 && this._readableState.destroyed;
    }, set: function(He) {
      this._readableState && (this._readableState.destroyed = He);
    } }), Se.prototype.destroy = he.destroy, Se.prototype._undestroy = he.undestroy, Se.prototype._destroy = function(He, qe) {
      this.push(null), qe(He);
    }, Se.prototype.push = function(He, qe) {
      var Ze, Pe = this._readableState;
      return Pe.objectMode ? Ze = !0 : typeof He == "string" && ((qe = qe || Pe.defaultEncoding) !== Pe.encoding && (He = ce.from(He, qe), qe = ""), Ze = !0), Ae(this, He, qe, !1, Ze);
    }, Se.prototype.unshift = function(He) {
      return Ae(this, He, null, !0, !1);
    }, Se.prototype.isPaused = function() {
      return this._readableState.flowing === !1;
    }, Se.prototype.setEncoding = function(He) {
      return me || (me = A(26).StringDecoder), this._readableState.decoder = new me(He), this._readableState.encoding = He, this;
    };
    var ve = 8388608;
    function De(He, qe) {
      return He <= 0 || qe.length === 0 && qe.ended ? 0 : qe.objectMode ? 1 : He != He ? qe.flowing && qe.length ? qe.buffer.head.data.length : qe.length : (He > qe.highWaterMark && (qe.highWaterMark = function(Ze) {
        return Ze >= ve ? Ze = ve : (Ze--, Ze |= Ze >>> 1, Ze |= Ze >>> 2, Ze |= Ze >>> 4, Ze |= Ze >>> 8, Ze |= Ze >>> 16, Ze++), Ze;
      }(He)), He <= qe.length ? He : qe.ended ? qe.length : (qe.needReadable = !0, 0));
    }
    function Ue(He) {
      var qe = He._readableState;
      qe.needReadable = !1, qe.emittedReadable || (pe("emitReadable", qe.flowing), qe.emittedReadable = !0, qe.sync ? J.nextTick(Fe, He) : Fe(He));
    }
    function Fe(He) {
      pe("emit readable"), He.emit("readable"), vt(He);
    }
    function We(He, qe) {
      qe.readingMore || (qe.readingMore = !0, J.nextTick(Ke, He, qe));
    }
    function Ke(He, qe) {
      for (var Ze = qe.length; !qe.reading && !qe.flowing && !qe.ended && qe.length < qe.highWaterMark && (pe("maybeReadMore read 0"), He.read(0), Ze !== qe.length); ) Ze = qe.length;
      qe.readingMore = !1;
    }
    function it(He) {
      pe("readable nexttick read 0"), He.read(0);
    }
    function Qe(He, qe) {
      qe.reading || (pe("resume read 0"), He.read(0)), qe.resumeScheduled = !1, qe.awaitDrain = 0, He.emit("resume"), vt(He), qe.flowing && !qe.reading && He.read(0);
    }
    function vt(He) {
      var qe = He._readableState;
      for (pe("flow", qe.flowing); qe.flowing && He.read() !== null; ) ;
    }
    function Ct(He, qe) {
      return qe.length === 0 ? null : (qe.objectMode ? Ze = qe.buffer.shift() : !He || He >= qe.length ? (Ze = qe.decoder ? qe.buffer.join("") : qe.buffer.length === 1 ? qe.buffer.head.data : qe.buffer.concat(qe.length), qe.buffer.clear()) : Ze = function(Pe, Ye, ot) {
        var Be;
        return Pe < Ye.head.data.length ? (Be = Ye.head.data.slice(0, Pe), Ye.head.data = Ye.head.data.slice(Pe)) : Be = Pe === Ye.head.data.length ? Ye.shift() : ot ? function(Ve, fe) {
          var _e = fe.head, je = 1, Ne = _e.data;
          for (Ve -= Ne.length; _e = _e.next; ) {
            var Ie = _e.data, Xe = Ve > Ie.length ? Ie.length : Ve;
            if (Xe === Ie.length ? Ne += Ie : Ne += Ie.slice(0, Ve), (Ve -= Xe) == 0) {
              Xe === Ie.length ? (++je, _e.next ? fe.head = _e.next : fe.head = fe.tail = null) : (fe.head = _e, _e.data = Ie.slice(Xe));
              break;
            }
            ++je;
          }
          return fe.length -= je, Ne;
        }(Pe, Ye) : function(Ve, fe) {
          var _e = ce.allocUnsafe(Ve), je = fe.head, Ne = 1;
          for (je.data.copy(_e), Ve -= je.data.length; je = je.next; ) {
            var Ie = je.data, Xe = Ve > Ie.length ? Ie.length : Ve;
            if (Ie.copy(_e, _e.length - Ve, 0, Xe), (Ve -= Xe) == 0) {
              Xe === Ie.length ? (++Ne, je.next ? fe.head = je.next : fe.head = fe.tail = null) : (fe.head = je, je.data = Ie.slice(Xe));
              break;
            }
            ++Ne;
          }
          return fe.length -= Ne, _e;
        }(Pe, Ye), Be;
      }(He, qe.buffer, qe.decoder), Ze);
      var Ze;
    }
    function Tt(He) {
      var qe = He._readableState;
      if (qe.length > 0) throw new Error('"endReadable()" called on non-empty stream');
      qe.endEmitted || (qe.ended = !0, J.nextTick(St, qe, He));
    }
    function St(He, qe) {
      He.endEmitted || He.length !== 0 || (He.endEmitted = !0, qe.readable = !1, qe.emit("end"));
    }
    function Je(He, qe) {
      for (var Ze = 0, Pe = He.length; Ze < Pe; Ze++) if (He[Ze] === qe) return Ze;
      return -1;
    }
    Se.prototype.read = function(He) {
      pe("read", He), He = parseInt(He, 10);
      var qe = this._readableState, Ze = He;
      if (He !== 0 && (qe.emittedReadable = !1), He === 0 && qe.needReadable && (qe.length >= qe.highWaterMark || qe.ended)) return pe("read: emitReadable", qe.length, qe.ended), qe.length === 0 && qe.ended ? Tt(this) : Ue(this), null;
      if ((He = De(He, qe)) === 0 && qe.ended) return qe.length === 0 && Tt(this), null;
      var Pe, Ye = qe.needReadable;
      return pe("need readable", Ye), (qe.length === 0 || qe.length - He < qe.highWaterMark) && pe("length less than watermark", Ye = !0), qe.ended || qe.reading ? pe("reading or ended", Ye = !1) : Ye && (pe("do read"), qe.reading = !0, qe.sync = !0, qe.length === 0 && (qe.needReadable = !0), this._read(qe.highWaterMark), qe.sync = !1, qe.reading || (He = De(Ze, qe))), (Pe = He > 0 ? Ct(He, qe) : null) === null ? (qe.needReadable = !0, He = 0) : qe.length -= He, qe.length === 0 && (qe.ended || (qe.needReadable = !0), Ze !== He && qe.ended && Tt(this)), Pe !== null && this.emit("data", Pe), Pe;
    }, Se.prototype._read = function(He) {
      this.emit("error", new Error("_read() is not implemented"));
    }, Se.prototype.pipe = function(He, qe) {
      var Ze = this, Pe = this._readableState;
      switch (Pe.pipesCount) {
        case 0:
          Pe.pipes = He;
          break;
        case 1:
          Pe.pipes = [Pe.pipes, He];
          break;
        default:
          Pe.pipes.push(He);
      }
      Pe.pipesCount += 1, pe("pipe count=%d opts=%j", Pe.pipesCount, qe);
      var Ye = qe && qe.end === !1 || He === X.stdout || He === X.stderr ? Xe : ot;
      function ot() {
        pe("onend"), He.end();
      }
      Pe.endEmitted ? J.nextTick(Ye) : Ze.once("end", Ye), He.on("unpipe", function ft(It, jt) {
        pe("onunpipe"), It === Ze && jt && jt.hasUnpiped === !1 && (jt.hasUnpiped = !0, pe("cleanup"), He.removeListener("close", Ne), He.removeListener("finish", Ie), He.removeListener("drain", Be), He.removeListener("error", je), He.removeListener("unpipe", ft), Ze.removeListener("end", ot), Ze.removeListener("end", Xe), Ze.removeListener("data", _e), Ve = !0, !Pe.awaitDrain || He._writableState && !He._writableState.needDrain || Be());
      });
      var Be = /* @__PURE__ */ function(ft) {
        return function() {
          var It = ft._readableState;
          pe("pipeOnDrain", It.awaitDrain), It.awaitDrain && It.awaitDrain--, It.awaitDrain === 0 && ne(ft, "data") && (It.flowing = !0, vt(ft));
        };
      }(Ze);
      He.on("drain", Be);
      var Ve = !1, fe = !1;
      function _e(ft) {
        pe("ondata"), fe = !1, He.write(ft) !== !1 || fe || ((Pe.pipesCount === 1 && Pe.pipes === He || Pe.pipesCount > 1 && Je(Pe.pipes, He) !== -1) && !Ve && (pe("false write response, pause", Ze._readableState.awaitDrain), Ze._readableState.awaitDrain++, fe = !0), Ze.pause());
      }
      function je(ft) {
        pe("onerror", ft), Xe(), He.removeListener("error", je), ne(He, "error") === 0 && He.emit("error", ft);
      }
      function Ne() {
        He.removeListener("finish", Ie), Xe();
      }
      function Ie() {
        pe("onfinish"), He.removeListener("close", Ne), Xe();
      }
      function Xe() {
        pe("unpipe"), Ze.unpipe(He);
      }
      return Ze.on("data", _e), function(ft, It, jt) {
        if (typeof ft.prependListener == "function") return ft.prependListener(It, jt);
        ft._events && ft._events[It] ? oe(ft._events[It]) ? ft._events[It].unshift(jt) : ft._events[It] = [jt, ft._events[It]] : ft.on(It, jt);
      }(He, "error", je), He.once("close", Ne), He.once("finish", Ie), He.emit("pipe", Ze), Pe.flowing || (pe("pipe resume"), Ze.resume()), He;
    }, Se.prototype.unpipe = function(He) {
      var qe = this._readableState, Ze = { hasUnpiped: !1 };
      if (qe.pipesCount === 0) return this;
      if (qe.pipesCount === 1) return He && He !== qe.pipes ? this : (He || (He = qe.pipes), qe.pipes = null, qe.pipesCount = 0, qe.flowing = !1, He && He.emit("unpipe", this, Ze), this);
      if (!He) {
        var Pe = qe.pipes, Ye = qe.pipesCount;
        qe.pipes = null, qe.pipesCount = 0, qe.flowing = !1;
        for (var ot = 0; ot < Ye; ot++) Pe[ot].emit("unpipe", this, Ze);
        return this;
      }
      var Be = Je(qe.pipes, He);
      return Be === -1 ? this : (qe.pipes.splice(Be, 1), qe.pipesCount -= 1, qe.pipesCount === 1 && (qe.pipes = qe.pipes[0]), He.emit("unpipe", this, Ze), this);
    }, Se.prototype.on = function(He, qe) {
      var Ze = re.prototype.on.call(this, He, qe);
      if (He === "data") this._readableState.flowing !== !1 && this.resume();
      else if (He === "readable") {
        var Pe = this._readableState;
        Pe.endEmitted || Pe.readableListening || (Pe.readableListening = Pe.needReadable = !0, Pe.emittedReadable = !1, Pe.reading ? Pe.length && Ue(this) : J.nextTick(it, this));
      }
      return Ze;
    }, Se.prototype.addListener = Se.prototype.on, Se.prototype.resume = function() {
      var He = this._readableState;
      return He.flowing || (pe("resume"), He.flowing = !0, function(qe, Ze) {
        Ze.resumeScheduled || (Ze.resumeScheduled = !0, J.nextTick(Qe, qe, Ze));
      }(this, He)), this;
    }, Se.prototype.pause = function() {
      return pe("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1 && (pe("pause"), this._readableState.flowing = !1, this.emit("pause")), this;
    }, Se.prototype.wrap = function(He) {
      var qe = this, Ze = this._readableState, Pe = !1;
      for (var Ye in He.on("end", function() {
        if (pe("wrapped end"), Ze.decoder && !Ze.ended) {
          var Be = Ze.decoder.end();
          Be && Be.length && qe.push(Be);
        }
        qe.push(null);
      }), He.on("data", function(Be) {
        pe("wrapped data"), Ze.decoder && (Be = Ze.decoder.write(Be)), (!Ze.objectMode || Be != null) && (Ze.objectMode || Be && Be.length) && (qe.push(Be) || (Pe = !0, He.pause()));
      }), He) this[Ye] === void 0 && typeof He[Ye] == "function" && (this[Ye] = /* @__PURE__ */ function(Be) {
        return function() {
          return He[Be].apply(He, arguments);
        };
      }(Ye));
      for (var ot = 0; ot < ge.length; ot++) He.on(ge[ot], this.emit.bind(this, ge[ot]));
      return this._read = function(Be) {
        pe("wrapped _read", Be), Pe && (Pe = !1, He.resume());
      }, this;
    }, Object.defineProperty(Se.prototype, "readableHighWaterMark", { enumerable: !1, get: function() {
      return this._readableState.highWaterMark;
    } }), Se._fromList = Ct;
  }).call(this, A(0), A(4));
}, function(C, L, A) {
  C.exports = A(12).EventEmitter;
}, function(C, L, A) {
  var W = A(6);
  function X(J, te) {
    J.emit("error", te);
  }
  C.exports = { destroy: function(J, te) {
    var oe = this, ne = this._readableState && this._readableState.destroyed, re = this._writableState && this._writableState.destroyed;
    return ne || re ? (te ? te(J) : !J || this._writableState && this._writableState.errorEmitted || W.nextTick(X, this, J), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this._writableState.destroyed = !0), this._destroy(J || null, function(ce) {
      !te && ce ? (W.nextTick(X, oe, ce), oe._writableState && (oe._writableState.errorEmitted = !0)) : te && te(ce);
    }), this);
  }, undestroy: function() {
    this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending = !1, this._writableState.finished = !1, this._writableState.errorEmitted = !1);
  } };
}, function(C, L, A) {
  var W = A(7).Buffer, X = W.isEncoding || function(pe) {
    switch ((pe = "" + pe) && pe.toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
      case "raw":
        return !0;
      default:
        return !1;
    }
  };
  function J(pe) {
    var me;
    switch (this.encoding = function(Me) {
      var he = function(ge) {
        if (!ge) return "utf8";
        for (var Ce; ; ) switch (ge) {
          case "utf8":
          case "utf-8":
            return "utf8";
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return "utf16le";
          case "latin1":
          case "binary":
            return "latin1";
          case "base64":
          case "ascii":
          case "hex":
            return ge;
          default:
            if (Ce) return;
            ge = ("" + ge).toLowerCase(), Ce = !0;
        }
      }(Me);
      if (typeof he != "string" && (W.isEncoding === X || !X(Me))) throw new Error("Unknown encoding: " + Me);
      return he || Me;
    }(pe), this.encoding) {
      case "utf16le":
        this.text = ne, this.end = re, me = 4;
        break;
      case "utf8":
        this.fillLast = oe, me = 4;
        break;
      case "base64":
        this.text = ce, this.end = ue, me = 3;
        break;
      default:
        return this.write = de, void (this.end = be);
    }
    this.lastNeed = 0, this.lastTotal = 0, this.lastChar = W.allocUnsafe(me);
  }
  function te(pe) {
    return pe <= 127 ? 0 : pe >> 5 == 6 ? 2 : pe >> 4 == 14 ? 3 : pe >> 3 == 30 ? 4 : pe >> 6 == 2 ? -1 : -2;
  }
  function oe(pe) {
    var me = this.lastTotal - this.lastNeed, Me = function(he, ge, Ce) {
      if ((192 & ge[0]) != 128) return he.lastNeed = 0, "�";
      if (he.lastNeed > 1 && ge.length > 1) {
        if ((192 & ge[1]) != 128) return he.lastNeed = 1, "�";
        if (he.lastNeed > 2 && ge.length > 2 && (192 & ge[2]) != 128) return he.lastNeed = 2, "�";
      }
    }(this, pe);
    return Me !== void 0 ? Me : this.lastNeed <= pe.length ? (pe.copy(this.lastChar, me, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal)) : (pe.copy(this.lastChar, me, 0, pe.length), void (this.lastNeed -= pe.length));
  }
  function ne(pe, me) {
    if ((pe.length - me) % 2 == 0) {
      var Me = pe.toString("utf16le", me);
      if (Me) {
        var he = Me.charCodeAt(Me.length - 1);
        if (he >= 55296 && he <= 56319) return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = pe[pe.length - 2], this.lastChar[1] = pe[pe.length - 1], Me.slice(0, -1);
      }
      return Me;
    }
    return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = pe[pe.length - 1], pe.toString("utf16le", me, pe.length - 1);
  }
  function re(pe) {
    var me = pe && pe.length ? this.write(pe) : "";
    if (this.lastNeed) {
      var Me = this.lastTotal - this.lastNeed;
      return me + this.lastChar.toString("utf16le", 0, Me);
    }
    return me;
  }
  function ce(pe, me) {
    var Me = (pe.length - me) % 3;
    return Me === 0 ? pe.toString("base64", me) : (this.lastNeed = 3 - Me, this.lastTotal = 3, Me === 1 ? this.lastChar[0] = pe[pe.length - 1] : (this.lastChar[0] = pe[pe.length - 2], this.lastChar[1] = pe[pe.length - 1]), pe.toString("base64", me, pe.length - Me));
  }
  function ue(pe) {
    var me = pe && pe.length ? this.write(pe) : "";
    return this.lastNeed ? me + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : me;
  }
  function de(pe) {
    return pe.toString(this.encoding);
  }
  function be(pe) {
    return pe && pe.length ? this.write(pe) : "";
  }
  L.StringDecoder = J, J.prototype.write = function(pe) {
    if (pe.length === 0) return "";
    var me, Me;
    if (this.lastNeed) {
      if ((me = this.fillLast(pe)) === void 0) return "";
      Me = this.lastNeed, this.lastNeed = 0;
    } else Me = 0;
    return Me < pe.length ? me ? me + this.text(pe, Me) : this.text(pe, Me) : me || "";
  }, J.prototype.end = function(pe) {
    var me = pe && pe.length ? this.write(pe) : "";
    return this.lastNeed ? me + "�" : me;
  }, J.prototype.text = function(pe, me) {
    var Me = function(ge, Ce, Se) {
      var Ae = Ce.length - 1;
      if (Ae < Se) return 0;
      var Le = te(Ce[Ae]);
      return Le >= 0 ? (Le > 0 && (ge.lastNeed = Le - 1), Le) : --Ae < Se || Le === -2 ? 0 : (Le = te(Ce[Ae])) >= 0 ? (Le > 0 && (ge.lastNeed = Le - 2), Le) : --Ae < Se || Le === -2 ? 0 : (Le = te(Ce[Ae])) >= 0 ? (Le > 0 && (Le === 2 ? Le = 0 : ge.lastNeed = Le - 3), Le) : 0;
    }(this, pe, me);
    if (!this.lastNeed) return pe.toString("utf8", me);
    this.lastTotal = Me;
    var he = pe.length - (Me - this.lastNeed);
    return pe.copy(this.lastChar, 0, he), pe.toString("utf8", me, he);
  }, J.prototype.fillLast = function(pe) {
    if (this.lastNeed <= pe.length) return pe.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
    pe.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, pe.length), this.lastNeed -= pe.length;
  };
}, function(C, L, A) {
  C.exports = J;
  var W = A(1), X = A(5);
  function J(ne) {
    if (!(this instanceof J)) return new J(ne);
    W.call(this, ne), this._transformState = { afterTransform: (function(re, ce) {
      var ue = this._transformState;
      ue.transforming = !1;
      var de = ue.writecb;
      if (!de) return this.emit("error", new Error("write callback called multiple times"));
      ue.writechunk = null, ue.writecb = null, ce != null && this.push(ce), de(re);
      var be = this._readableState;
      be.reading = !1, (be.needReadable || be.length < be.highWaterMark) && this._read(be.highWaterMark);
    }).bind(this), needTransform: !1, transforming: !1, writecb: null, writechunk: null, writeencoding: null }, this._readableState.needReadable = !0, this._readableState.sync = !1, ne && (typeof ne.transform == "function" && (this._transform = ne.transform), typeof ne.flush == "function" && (this._flush = ne.flush)), this.on("prefinish", te);
  }
  function te() {
    var ne = this;
    typeof this._flush == "function" ? this._flush(function(re, ce) {
      oe(ne, re, ce);
    }) : oe(this, null, null);
  }
  function oe(ne, re, ce) {
    if (re) return ne.emit("error", re);
    if (ce != null && ne.push(ce), ne._writableState.length) throw new Error("Calling transform done when ws.length != 0");
    if (ne._transformState.transforming) throw new Error("Calling transform done when still transforming");
    return ne.push(null);
  }
  X.inherits = A(2), X.inherits(J, W), J.prototype.push = function(ne, re) {
    return this._transformState.needTransform = !1, W.prototype.push.call(this, ne, re);
  }, J.prototype._transform = function(ne, re, ce) {
    throw new Error("_transform() is not implemented");
  }, J.prototype._write = function(ne, re, ce) {
    var ue = this._transformState;
    if (ue.writecb = ce, ue.writechunk = ne, ue.writeencoding = re, !ue.transforming) {
      var de = this._readableState;
      (ue.needTransform || de.needReadable || de.length < de.highWaterMark) && this._read(de.highWaterMark);
    }
  }, J.prototype._read = function(ne) {
    var re = this._transformState;
    re.writechunk !== null && re.writecb && !re.transforming ? (re.transforming = !0, this._transform(re.writechunk, re.writeencoding, re.afterTransform)) : re.needTransform = !0;
  }, J.prototype._destroy = function(ne, re) {
    var ce = this;
    W.prototype._destroy.call(this, ne, function(ue) {
      re(ue), ce.emit("close");
    });
  };
}, function(C, L, A) {
  (function(W) {
    Object.defineProperty(L, "__esModule", { value: !0 }), L.bufFromString = function(X) {
      var J = W.byteLength(X), te = W.allocUnsafe ? W.allocUnsafe(J) : new W(J);
      return te.write(X), te;
    }, L.emptyBuffer = function() {
      return W.allocUnsafe ? W.allocUnsafe(0) : new W(0);
    }, L.filterArray = function(X, J) {
      for (var te = [], oe = 0; oe < X.length; oe++) J.indexOf(oe) > -1 && te.push(X[oe]);
      return te;
    }, L.trimLeft = String.prototype.trimLeft ? function(X) {
      return X.trimLeft();
    } : function(X) {
      return X.replace(/^\s+/, "");
    }, L.trimRight = String.prototype.trimRight ? function(X) {
      return X.trimRight();
    } : function(X) {
      return X.replace(/\s+$/, "");
    };
  }).call(this, A(3).Buffer);
}, function(C, L, A) {
  var W = this && this.__extends || function() {
    var J = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(te, oe) {
      te.__proto__ = oe;
    } || function(te, oe) {
      for (var ne in oe) oe.hasOwnProperty(ne) && (te[ne] = oe[ne]);
    };
    return function(te, oe) {
      function ne() {
        this.constructor = te;
      }
      J(te, oe), te.prototype = oe === null ? Object.create(oe) : (ne.prototype = oe.prototype, new ne());
    };
  }();
  Object.defineProperty(L, "__esModule", { value: !0 });
  var X = function(J) {
    function te(oe, ne, re) {
      var ce = J.call(this, "Error: " + oe + ". JSON Line number: " + ne + (re ? " near: " + re : "")) || this;
      return ce.err = oe, ce.line = ne, ce.extra = re, ce.name = "CSV Parse Error", ce;
    }
    return W(te, J), te.column_mismatched = function(oe, ne) {
      return new te("column_mismatched", oe, ne);
    }, te.unclosed_quote = function(oe, ne) {
      return new te("unclosed_quote", oe, ne);
    }, te.fromJSON = function(oe) {
      return new te(oe.err, oe.line, oe.extra);
    }, te.prototype.toJSON = function() {
      return { err: this.err, line: this.line, extra: this.extra };
    }, te;
  }(Error);
  L.default = X;
}, function(C, L, A) {
  var W = A(18), X = A(68), J = A(69), te = W ? W.toStringTag : void 0;
  C.exports = function(oe) {
    return oe == null ? oe === void 0 ? "[object Undefined]" : "[object Null]" : te && te in Object(oe) ? X(oe) : J(oe);
  };
}, function(C, L) {
  C.exports = function(A, W) {
    return A === W || A != A && W != W;
  };
}, function(C, L, A) {
  C.exports = A(33);
}, function(C, L, A) {
  var W = A(34), X = function(J, te) {
    return new W.Converter(J, te);
  };
  X.csv = X, X.Converter = W.Converter, C.exports = X;
}, function(C, L, A) {
  (function(W) {
    var X = this && this.__extends || function() {
      var be = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(pe, me) {
        pe.__proto__ = me;
      } || function(pe, me) {
        for (var Me in me) me.hasOwnProperty(Me) && (pe[Me] = me[Me]);
      };
      return function(pe, me) {
        function Me() {
          this.constructor = pe;
        }
        be(pe, me), pe.prototype = me === null ? Object.create(me) : (Me.prototype = me.prototype, new Me());
      };
    }(), J = this && this.__importDefault || function(be) {
      return be && be.__esModule ? be : { default: be };
    };
    Object.defineProperty(L, "__esModule", { value: !0 });
    var te = A(36), oe = A(50), ne = A(51), re = J(A(15)), ce = A(52), ue = A(105), de = function(be) {
      function pe(me, Me) {
        Me === void 0 && (Me = {});
        var he = be.call(this, Me) || this;
        return he.options = Me, he.params = oe.mergeParams(me), he.runtime = ne.initParseRuntime(he), he.result = new ue.Result(he), he.processor = new ce.ProcessorLocal(he), he.once("error", function(ge) {
          W(function() {
            he.result.processError(ge), he.emit("done", ge);
          });
        }), he.once("done", function() {
          he.processor.destroy();
        }), he;
      }
      return X(pe, be), pe.prototype.preRawData = function(me) {
        return this.runtime.preRawDataHook = me, this;
      }, pe.prototype.preFileLine = function(me) {
        return this.runtime.preFileLineHook = me, this;
      }, pe.prototype.subscribe = function(me, Me, he) {
        return this.parseRuntime.subscribe = { onNext: me, onError: Me, onCompleted: he }, this;
      }, pe.prototype.fromFile = function(me, Me) {
        var he = this, ge = A(!function() {
          var Ce = new Error("Cannot find module 'fs'");
          throw Ce.code = "MODULE_NOT_FOUND", Ce;
        }());
        return ge.exists(me, function(Ce) {
          Ce ? ge.createReadStream(me, Me).pipe(he) : he.emit("error", new Error("File does not exist. Check to make sure the file path to your csv is correct."));
        }), this;
      }, pe.prototype.fromStream = function(me) {
        return me.pipe(this), this;
      }, pe.prototype.fromString = function(me) {
        me.toString();
        var Me = new te.Readable(), he = 0;
        return Me._read = function(ge) {
          if (he >= me.length) this.push(null);
          else {
            var Ce = me.substr(he, ge);
            this.push(Ce), he += ge;
          }
        }, this.fromStream(Me);
      }, pe.prototype.then = function(me, Me) {
        var he = this;
        return new re.default(function(ge, Ce) {
          he.parseRuntime.then = { onfulfilled: function(Se) {
            ge(me ? me(Se) : Se);
          }, onrejected: function(Se) {
            Me ? ge(Me(Se)) : Ce(Se);
          } };
        });
      }, Object.defineProperty(pe.prototype, "parseParam", { get: function() {
        return this.params;
      }, enumerable: !0, configurable: !0 }), Object.defineProperty(pe.prototype, "parseRuntime", { get: function() {
        return this.runtime;
      }, enumerable: !0, configurable: !0 }), pe.prototype._transform = function(me, Me, he) {
        var ge = this;
        this.processor.process(me).then(function(Ce) {
          if (Ce.length > 0) return ge.runtime.started = !0, ge.result.processResult(Ce);
        }).then(function() {
          ge.emit("drained"), he();
        }, function(Ce) {
          ge.runtime.hasError = !0, ge.runtime.error = Ce, ge.emit("error", Ce), he();
        });
      }, pe.prototype._flush = function(me) {
        var Me = this;
        this.processor.flush().then(function(he) {
          if (he.length > 0) return Me.result.processResult(he);
        }).then(function() {
          Me.processEnd(me);
        }, function(he) {
          Me.emit("error", he), me();
        });
      }, pe.prototype.processEnd = function(me) {
        this.result.endProcess(), this.emit("done"), me();
      }, Object.defineProperty(pe.prototype, "parsedLineNumber", { get: function() {
        return this.runtime.parsedLineNumber;
      }, enumerable: !0, configurable: !0 }), pe;
    }(te.Transform);
    L.Converter = de;
  }).call(this, A(11).setImmediate);
}, function(C, L, A) {
  (function(W, X) {
    (function(J, te) {
      if (!J.setImmediate) {
        var oe, ne = 1, re = {}, ce = !1, ue = J.document, de = Object.getPrototypeOf && Object.getPrototypeOf(J);
        de = de && de.setTimeout ? de : J, {}.toString.call(J.process) === "[object process]" ? oe = function(me) {
          X.nextTick(function() {
            pe(me);
          });
        } : function() {
          if (J.postMessage && !J.importScripts) {
            var me = !0, Me = J.onmessage;
            return J.onmessage = function() {
              me = !1;
            }, J.postMessage("", "*"), J.onmessage = Me, me;
          }
        }() ? function() {
          var me = "setImmediate$" + Math.random() + "$", Me = function(he) {
            he.source === J && typeof he.data == "string" && he.data.indexOf(me) === 0 && pe(+he.data.slice(me.length));
          };
          J.addEventListener ? J.addEventListener("message", Me, !1) : J.attachEvent("onmessage", Me), oe = function(he) {
            J.postMessage(me + he, "*");
          };
        }() : J.MessageChannel ? function() {
          var me = new MessageChannel();
          me.port1.onmessage = function(Me) {
            pe(Me.data);
          }, oe = function(Me) {
            me.port2.postMessage(Me);
          };
        }() : ue && "onreadystatechange" in ue.createElement("script") ? function() {
          var me = ue.documentElement;
          oe = function(Me) {
            var he = ue.createElement("script");
            he.onreadystatechange = function() {
              pe(Me), he.onreadystatechange = null, me.removeChild(he), he = null;
            }, me.appendChild(he);
          };
        }() : oe = function(me) {
          setTimeout(pe, 0, me);
        }, de.setImmediate = function(me) {
          typeof me != "function" && (me = new Function("" + me));
          for (var Me = new Array(arguments.length - 1), he = 0; he < Me.length; he++) Me[he] = arguments[he + 1];
          var ge = { callback: me, args: Me };
          return re[ne] = ge, oe(ne), ne++;
        }, de.clearImmediate = be;
      }
      function be(me) {
        delete re[me];
      }
      function pe(me) {
        if (ce) setTimeout(pe, 0, me);
        else {
          var Me = re[me];
          if (Me) {
            ce = !0;
            try {
              (function(he) {
                var ge = he.callback, Ce = he.args;
                switch (Ce.length) {
                  case 0:
                    ge();
                    break;
                  case 1:
                    ge(Ce[0]);
                    break;
                  case 2:
                    ge(Ce[0], Ce[1]);
                    break;
                  case 3:
                    ge(Ce[0], Ce[1], Ce[2]);
                    break;
                  default:
                    ge.apply(te, Ce);
                }
              })(Me);
            } finally {
              be(me), ce = !1;
            }
          }
        }
      }
    })(typeof self > "u" ? W === void 0 ? this : W : self);
  }).call(this, A(0), A(4));
}, function(C, L, A) {
  C.exports = X;
  var W = A(12).EventEmitter;
  function X() {
    W.call(this);
  }
  A(2)(X, W), X.Readable = A(13), X.Writable = A(46), X.Duplex = A(47), X.Transform = A(48), X.PassThrough = A(49), X.Stream = X, X.prototype.pipe = function(J, te) {
    var oe = this;
    function ne(me) {
      J.writable && J.write(me) === !1 && oe.pause && oe.pause();
    }
    function re() {
      oe.readable && oe.resume && oe.resume();
    }
    oe.on("data", ne), J.on("drain", re), J._isStdio || te && te.end === !1 || (oe.on("end", ue), oe.on("close", de));
    var ce = !1;
    function ue() {
      ce || (ce = !0, J.end());
    }
    function de() {
      ce || (ce = !0, typeof J.destroy == "function" && J.destroy());
    }
    function be(me) {
      if (pe(), W.listenerCount(this, "error") === 0) throw me;
    }
    function pe() {
      oe.removeListener("data", ne), J.removeListener("drain", re), oe.removeListener("end", ue), oe.removeListener("close", de), oe.removeListener("error", be), J.removeListener("error", be), oe.removeListener("end", pe), oe.removeListener("close", pe), J.removeListener("close", pe);
    }
    return oe.on("error", be), J.on("error", be), oe.on("end", pe), oe.on("close", pe), J.on("close", pe), J.emit("pipe", oe), J;
  };
}, function(C, L) {
  var A = {}.toString;
  C.exports = Array.isArray || function(W) {
    return A.call(W) == "[object Array]";
  };
}, function(C, L, A) {
  L.byteLength = function(de) {
    var be = re(de), pe = be[0], me = be[1];
    return 3 * (pe + me) / 4 - me;
  }, L.toByteArray = function(de) {
    for (var be, pe = re(de), me = pe[0], Me = pe[1], he = new J(3 * (me + Me) / 4 - Me), ge = 0, Ce = Me > 0 ? me - 4 : me, Se = 0; Se < Ce; Se += 4) be = X[de.charCodeAt(Se)] << 18 | X[de.charCodeAt(Se + 1)] << 12 | X[de.charCodeAt(Se + 2)] << 6 | X[de.charCodeAt(Se + 3)], he[ge++] = be >> 16 & 255, he[ge++] = be >> 8 & 255, he[ge++] = 255 & be;
    return Me === 2 && (be = X[de.charCodeAt(Se)] << 2 | X[de.charCodeAt(Se + 1)] >> 4, he[ge++] = 255 & be), Me === 1 && (be = X[de.charCodeAt(Se)] << 10 | X[de.charCodeAt(Se + 1)] << 4 | X[de.charCodeAt(Se + 2)] >> 2, he[ge++] = be >> 8 & 255, he[ge++] = 255 & be), he;
  }, L.fromByteArray = function(de) {
    for (var be, pe = de.length, me = pe % 3, Me = [], he = 0, ge = pe - me; he < ge; he += 16383) Me.push(ue(de, he, he + 16383 > ge ? ge : he + 16383));
    return me === 1 ? (be = de[pe - 1], Me.push(W[be >> 2] + W[be << 4 & 63] + "==")) : me === 2 && (be = (de[pe - 2] << 8) + de[pe - 1], Me.push(W[be >> 10] + W[be >> 4 & 63] + W[be << 2 & 63] + "=")), Me.join("");
  };
  for (var W = [], X = [], J = typeof Uint8Array < "u" ? Uint8Array : Array, te = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", oe = 0, ne = te.length; oe < ne; ++oe) W[oe] = te[oe], X[te.charCodeAt(oe)] = oe;
  function re(de) {
    var be = de.length;
    if (be % 4 > 0) throw new Error("Invalid string. Length must be a multiple of 4");
    var pe = de.indexOf("=");
    return pe === -1 && (pe = be), [pe, pe === be ? 0 : 4 - pe % 4];
  }
  function ce(de) {
    return W[de >> 18 & 63] + W[de >> 12 & 63] + W[de >> 6 & 63] + W[63 & de];
  }
  function ue(de, be, pe) {
    for (var me, Me = [], he = be; he < pe; he += 3) me = (de[he] << 16 & 16711680) + (de[he + 1] << 8 & 65280) + (255 & de[he + 2]), Me.push(ce(me));
    return Me.join("");
  }
  X[45] = 62, X[95] = 63;
}, function(C, L) {
  L.read = function(A, W, X, J, te) {
    var oe, ne, re = 8 * te - J - 1, ce = (1 << re) - 1, ue = ce >> 1, de = -7, be = X ? te - 1 : 0, pe = X ? -1 : 1, me = A[W + be];
    for (be += pe, oe = me & (1 << -de) - 1, me >>= -de, de += re; de > 0; oe = 256 * oe + A[W + be], be += pe, de -= 8) ;
    for (ne = oe & (1 << -de) - 1, oe >>= -de, de += J; de > 0; ne = 256 * ne + A[W + be], be += pe, de -= 8) ;
    if (oe === 0) oe = 1 - ue;
    else {
      if (oe === ce) return ne ? NaN : 1 / 0 * (me ? -1 : 1);
      ne += Math.pow(2, J), oe -= ue;
    }
    return (me ? -1 : 1) * ne * Math.pow(2, oe - J);
  }, L.write = function(A, W, X, J, te, oe) {
    var ne, re, ce, ue = 8 * oe - te - 1, de = (1 << ue) - 1, be = de >> 1, pe = te === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, me = J ? 0 : oe - 1, Me = J ? 1 : -1, he = W < 0 || W === 0 && 1 / W < 0 ? 1 : 0;
    for (W = Math.abs(W), isNaN(W) || W === 1 / 0 ? (re = isNaN(W) ? 1 : 0, ne = de) : (ne = Math.floor(Math.log(W) / Math.LN2), W * (ce = Math.pow(2, -ne)) < 1 && (ne--, ce *= 2), (W += ne + be >= 1 ? pe / ce : pe * Math.pow(2, 1 - be)) * ce >= 2 && (ne++, ce /= 2), ne + be >= de ? (re = 0, ne = de) : ne + be >= 1 ? (re = (W * ce - 1) * Math.pow(2, te), ne += be) : (re = W * Math.pow(2, be - 1) * Math.pow(2, te), ne = 0)); te >= 8; A[X + me] = 255 & re, me += Me, re /= 256, te -= 8) ;
    for (ne = ne << te | re, ue += te; ue > 0; A[X + me] = 255 & ne, me += Me, ne /= 256, ue -= 8) ;
    A[X + me - Me] |= 128 * he;
  };
}, function(C, L) {
  var A = {}.toString;
  C.exports = Array.isArray || function(W) {
    return A.call(W) == "[object Array]";
  };
}, function(C, L) {
}, function(C, L, A) {
  var W = A(7).Buffer, X = A(43);
  function J(te, oe, ne) {
    te.copy(oe, ne);
  }
  C.exports = function() {
    function te() {
      (function(oe, ne) {
        if (!(oe instanceof ne)) throw new TypeError("Cannot call a class as a function");
      })(this, te), this.head = null, this.tail = null, this.length = 0;
    }
    return te.prototype.push = function(oe) {
      var ne = { data: oe, next: null };
      this.length > 0 ? this.tail.next = ne : this.head = ne, this.tail = ne, ++this.length;
    }, te.prototype.unshift = function(oe) {
      var ne = { data: oe, next: this.head };
      this.length === 0 && (this.tail = ne), this.head = ne, ++this.length;
    }, te.prototype.shift = function() {
      if (this.length !== 0) {
        var oe = this.head.data;
        return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, oe;
      }
    }, te.prototype.clear = function() {
      this.head = this.tail = null, this.length = 0;
    }, te.prototype.join = function(oe) {
      if (this.length === 0) return "";
      for (var ne = this.head, re = "" + ne.data; ne = ne.next; ) re += oe + ne.data;
      return re;
    }, te.prototype.concat = function(oe) {
      if (this.length === 0) return W.alloc(0);
      if (this.length === 1) return this.head.data;
      for (var ne = W.allocUnsafe(oe >>> 0), re = this.head, ce = 0; re; ) J(re.data, ne, ce), ce += re.data.length, re = re.next;
      return ne;
    }, te;
  }(), X && X.inspect && X.inspect.custom && (C.exports.prototype[X.inspect.custom] = function() {
    var te = X.inspect({ length: this.length });
    return this.constructor.name + " " + te;
  });
}, function(C, L) {
}, function(C, L, A) {
  (function(W) {
    function X(J) {
      try {
        if (!W.localStorage) return !1;
      } catch {
        return !1;
      }
      var te = W.localStorage[J];
      return te != null && String(te).toLowerCase() === "true";
    }
    C.exports = function(J, te) {
      if (X("noDeprecation")) return J;
      var oe = !1;
      return function() {
        if (!oe) {
          if (X("throwDeprecation")) throw new Error(te);
          X("traceDeprecation") ? console.trace(te) : console.warn(te), oe = !0;
        }
        return J.apply(this, arguments);
      };
    };
  }).call(this, A(0));
}, function(C, L, A) {
  C.exports = J;
  var W = A(27), X = A(5);
  function J(te) {
    if (!(this instanceof J)) return new J(te);
    W.call(this, te);
  }
  X.inherits = A(2), X.inherits(J, W), J.prototype._transform = function(te, oe, ne) {
    ne(null, te);
  };
}, function(C, L, A) {
  C.exports = A(14);
}, function(C, L, A) {
  C.exports = A(1);
}, function(C, L, A) {
  C.exports = A(13).Transform;
}, function(C, L, A) {
  C.exports = A(13).PassThrough;
}, function(C, L, A) {
  Object.defineProperty(L, "__esModule", { value: !0 }), L.mergeParams = function(W) {
    var X = { delimiter: ",", ignoreColumns: void 0, includeColumns: void 0, quote: '"', trim: !0, checkType: !1, ignoreEmpty: !1, noheader: !1, headers: void 0, flatKeys: !1, maxRowLength: 0, checkColumn: !1, escape: '"', colParser: {}, eol: void 0, alwaysSplitAtEOL: !1, output: "json", nullObject: !1, downstreamFormat: "line", needEmitAll: !0 };
    for (var J in W || (W = {}), W) W.hasOwnProperty(J) && (Array.isArray(W[J]) ? X[J] = [].concat(W[J]) : X[J] = W[J]);
    return X;
  };
}, function(C, L, A) {
  Object.defineProperty(L, "__esModule", { value: !0 }), L.initParseRuntime = function(W) {
    var X = W.parseParam, J = { needProcessIgnoreColumn: !1, needProcessIncludeColumn: !1, selectedColumns: void 0, ended: !1, hasError: !1, error: void 0, delimiter: W.parseParam.delimiter, eol: W.parseParam.eol, columnConv: [], headerType: [], headerTitle: [], headerFlag: [], headers: void 0, started: !1, parsedLineNumber: 0, columnValueSetter: [] };
    return X.ignoreColumns && (J.needProcessIgnoreColumn = !0), X.includeColumns && (J.needProcessIncludeColumn = !0), J;
  };
}, function(C, L, A) {
  (function(W) {
    var X = this && this.__extends || function() {
      var Me = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(he, ge) {
        he.__proto__ = ge;
      } || function(he, ge) {
        for (var Ce in ge) ge.hasOwnProperty(Ce) && (he[Ce] = ge[Ce]);
      };
      return function(he, ge) {
        function Ce() {
          this.constructor = he;
        }
        Me(he, ge), he.prototype = ge === null ? Object.create(ge) : (Ce.prototype = ge.prototype, new Ce());
      };
    }(), J = this && this.__importDefault || function(Me) {
      return Me && Me.__esModule ? Me : { default: Me };
    };
    Object.defineProperty(L, "__esModule", { value: !0 });
    var te = A(53), oe = J(A(15)), ne = A(54), re = J(A(16)), ce = A(57), ue = A(28), de = A(58), be = J(A(59)), pe = J(A(29)), me = function(Me) {
      function he() {
        var ge = Me !== null && Me.apply(this, arguments) || this;
        return ge.rowSplit = new de.RowSplit(ge.converter), ge.eolEmitted = !1, ge._needEmitEol = void 0, ge.headEmitted = !1, ge._needEmitHead = void 0, ge;
      }
      return X(he, Me), he.prototype.flush = function() {
        var ge = this;
        if (this.runtime.csvLineBuffer && this.runtime.csvLineBuffer.length > 0) {
          var Ce = this.runtime.csvLineBuffer;
          return this.runtime.csvLineBuffer = void 0, this.process(Ce, !0).then(function(Se) {
            return ge.runtime.csvLineBuffer && ge.runtime.csvLineBuffer.length > 0 ? oe.default.reject(pe.default.unclosed_quote(ge.runtime.parsedLineNumber, ge.runtime.csvLineBuffer.toString())) : oe.default.resolve(Se);
          });
        }
        return oe.default.resolve([]);
      }, he.prototype.destroy = function() {
        return oe.default.resolve();
      }, Object.defineProperty(he.prototype, "needEmitEol", { get: function() {
        return this._needEmitEol === void 0 && (this._needEmitEol = this.converter.listeners("eol").length > 0), this._needEmitEol;
      }, enumerable: !0, configurable: !0 }), Object.defineProperty(he.prototype, "needEmitHead", { get: function() {
        return this._needEmitHead === void 0 && (this._needEmitHead = this.converter.listeners("header").length > 0), this._needEmitHead;
      }, enumerable: !0, configurable: !0 }), he.prototype.process = function(ge, Ce) {
        var Se, Ae = this;
        return Ce === void 0 && (Ce = !1), Se = Ce ? ge.toString() : ne.prepareData(ge, this.converter.parseRuntime), oe.default.resolve().then(function() {
          return Ae.runtime.preRawDataHook ? Ae.runtime.preRawDataHook(Se) : Se;
        }).then(function(Le) {
          return Le && Le.length > 0 ? Ae.processCSV(Le, Ce) : oe.default.resolve([]);
        });
      }, he.prototype.processCSV = function(ge, Ce) {
        var Se = this, Ae = this.params, Le = this.runtime;
        Le.eol || re.default(ge, Le), this.needEmitEol && !this.eolEmitted && Le.eol && (this.converter.emit("eol", Le.eol), this.eolEmitted = !0), Ae.ignoreEmpty && !Le.started && (ge = ue.trimLeft(ge));
        var ve = ce.stringToLines(ge, Le);
        return Ce ? (ve.lines.push(ve.partial), ve.partial = "") : this.prependLeftBuf(ue.bufFromString(ve.partial)), ve.lines.length > 0 ? (Le.preFileLineHook ? this.runPreLineHook(ve.lines) : oe.default.resolve(ve.lines)).then(function(De) {
          return Le.started || Se.runtime.headers ? Se.processCSVBody(De) : Se.processDataWithHead(De);
        }) : oe.default.resolve([]);
      }, he.prototype.processDataWithHead = function(ge) {
        if (this.params.noheader) this.params.headers ? this.runtime.headers = this.params.headers : this.runtime.headers = [];
        else {
          for (var Ce = "", Se = []; ge.length; ) {
            var Ae = Ce + ge.shift(), Le = this.rowSplit.parse(Ae);
            if (Le.closed) {
              Se = Le.cells, Ce = "";
              break;
            }
            Ce = Ae + re.default(Ae, this.runtime);
          }
          if (this.prependLeftBuf(ue.bufFromString(Ce)), Se.length === 0) return [];
          this.params.headers ? this.runtime.headers = this.params.headers : this.runtime.headers = Se;
        }
        return (this.runtime.needProcessIgnoreColumn || this.runtime.needProcessIncludeColumn) && this.filterHeader(), this.needEmitHead && !this.headEmitted && (this.converter.emit("header", this.runtime.headers), this.headEmitted = !0), this.processCSVBody(ge);
      }, he.prototype.filterHeader = function() {
        if (this.runtime.selectedColumns = [], this.runtime.headers) {
          for (var ge = this.runtime.headers, Ce = 0; Ce < ge.length; Ce++) if (this.params.ignoreColumns) if (this.params.ignoreColumns.test(ge[Ce])) {
            if (!this.params.includeColumns || !this.params.includeColumns.test(ge[Ce])) continue;
            this.runtime.selectedColumns.push(Ce);
          } else this.runtime.selectedColumns.push(Ce);
          else this.params.includeColumns ? this.params.includeColumns.test(ge[Ce]) && this.runtime.selectedColumns.push(Ce) : this.runtime.selectedColumns.push(Ce);
          this.runtime.headers = ue.filterArray(this.runtime.headers, this.runtime.selectedColumns);
        }
      }, he.prototype.processCSVBody = function(ge) {
        if (this.params.output === "line") return ge;
        var Ce = this.rowSplit.parseMultiLines(ge);
        return this.prependLeftBuf(ue.bufFromString(Ce.partial)), this.params.output === "csv" ? Ce.rowsCells : be.default(Ce.rowsCells, this.converter);
      }, he.prototype.prependLeftBuf = function(ge) {
        ge && (this.runtime.csvLineBuffer ? this.runtime.csvLineBuffer = W.concat([ge, this.runtime.csvLineBuffer]) : this.runtime.csvLineBuffer = ge);
      }, he.prototype.runPreLineHook = function(ge) {
        var Ce = this;
        return new oe.default(function(Se, Ae) {
          (function Le(ve, De, Ue, Fe) {
            if (Ue >= ve.length) Fe();
            else if (De.preFileLineHook) {
              var We = ve[Ue], Ke = De.preFileLineHook(We, De.parsedLineNumber + Ue);
              if (Ue++, Ke && Ke.then) Ke.then(function(it) {
                ve[Ue - 1] = it, Le(ve, De, Ue, Fe);
              });
              else {
                for (ve[Ue - 1] = Ke; Ue < ve.length; ) ve[Ue] = De.preFileLineHook(ve[Ue], De.parsedLineNumber + Ue), Ue++;
                Fe();
              }
            } else Fe();
          })(ge, Ce.runtime, 0, function(Le) {
            Le ? Ae(Le) : Se(ge);
          });
        });
      }, he;
    }(te.Processor);
    L.ProcessorLocal = me;
  }).call(this, A(3).Buffer);
}, function(C, L, A) {
  Object.defineProperty(L, "__esModule", { value: !0 });
  var W = function(X) {
    this.converter = X, this.params = X.parseParam, this.runtime = X.parseRuntime;
  };
  L.Processor = W;
}, function(C, L, A) {
  (function(W) {
    var X = this && this.__importDefault || function(te) {
      return te && te.__esModule ? te : { default: te };
    };
    Object.defineProperty(L, "__esModule", { value: !0 });
    var J = X(A(55));
    L.prepareData = function(te, oe) {
      var ne = function(ce, ue) {
        return ue.csvLineBuffer && ue.csvLineBuffer.length > 0 ? W.concat([ue.csvLineBuffer, ce]) : ce;
      }(te, oe);
      oe.csvLineBuffer = void 0;
      var re = function(ce, ue) {
        var de = ce.length - 1;
        if (128 & ce[de]) {
          for (; (192 & ce[de]) == 128; ) de--;
          de--;
        }
        return de != ce.length - 1 ? (ue.csvLineBuffer = ce.slice(de + 1), ce.slice(0, de + 1)) : ce;
      }(ne, oe).toString("utf8");
      return oe.started === !1 ? J.default(re) : re;
    };
  }).call(this, A(3).Buffer);
}, function(C, L, A) {
  (function(W) {
    var X = A(56);
    C.exports = function(J) {
      return typeof J == "string" && J.charCodeAt(0) === 65279 ? J.slice(1) : W.isBuffer(J) && X(J) && J[0] === 239 && J[1] === 187 && J[2] === 191 ? J.slice(3) : J;
    };
  }).call(this, A(3).Buffer);
}, function(C, L) {
  C.exports = function(A) {
    for (var W = 0; W < A.length; ) if (A[W] == 9 || A[W] == 10 || A[W] == 13 || 32 <= A[W] && A[W] <= 126) W += 1;
    else if (194 <= A[W] && A[W] <= 223 && 128 <= A[W + 1] && A[W + 1] <= 191) W += 2;
    else if (A[W] == 224 && 160 <= A[W + 1] && A[W + 1] <= 191 && 128 <= A[W + 2] && A[W + 2] <= 191 || (225 <= A[W] && A[W] <= 236 || A[W] == 238 || A[W] == 239) && 128 <= A[W + 1] && A[W + 1] <= 191 && 128 <= A[W + 2] && A[W + 2] <= 191 || A[W] == 237 && 128 <= A[W + 1] && A[W + 1] <= 159 && 128 <= A[W + 2] && A[W + 2] <= 191) W += 3;
    else {
      if (!(A[W] == 240 && 144 <= A[W + 1] && A[W + 1] <= 191 && 128 <= A[W + 2] && A[W + 2] <= 191 && 128 <= A[W + 3] && A[W + 3] <= 191 || 241 <= A[W] && A[W] <= 243 && 128 <= A[W + 1] && A[W + 1] <= 191 && 128 <= A[W + 2] && A[W + 2] <= 191 && 128 <= A[W + 3] && A[W + 3] <= 191 || A[W] == 244 && 128 <= A[W + 1] && A[W + 1] <= 143 && 128 <= A[W + 2] && A[W + 2] <= 191 && 128 <= A[W + 3] && A[W + 3] <= 191)) return !1;
      W += 4;
    }
    return !0;
  };
}, function(C, L, A) {
  var W = this && this.__importDefault || function(J) {
    return J && J.__esModule ? J : { default: J };
  };
  Object.defineProperty(L, "__esModule", { value: !0 });
  var X = W(A(16));
  L.stringToLines = function(J, te) {
    var oe = X.default(J, te), ne = J.split(oe);
    return { lines: ne, partial: ne.pop() || "" };
  };
}, function(C, L, A) {
  var W = this && this.__importDefault || function(ne) {
    return ne && ne.__esModule ? ne : { default: ne };
  };
  Object.defineProperty(L, "__esModule", { value: !0 });
  var X = W(A(16)), J = A(28), te = [",", "|", "	", ";", ":"], oe = function() {
    function ne(re) {
      this.conv = re, this.cachedRegExp = {}, this.delimiterEmitted = !1, this._needEmitDelimiter = void 0, this.quote = re.parseParam.quote, this.trim = re.parseParam.trim, this.escape = re.parseParam.escape;
    }
    return Object.defineProperty(ne.prototype, "needEmitDelimiter", { get: function() {
      return this._needEmitDelimiter === void 0 && (this._needEmitDelimiter = this.conv.listeners("delimiter").length > 0), this._needEmitDelimiter;
    }, enumerable: !0, configurable: !0 }), ne.prototype.parse = function(re) {
      if (re.length === 0 || this.conv.parseParam.ignoreEmpty && re.trim().length === 0) return { cells: [], closed: !0 };
      var ce = this.quote, ue = this.trim;
      this.escape, (this.conv.parseRuntime.delimiter instanceof Array || this.conv.parseRuntime.delimiter.toLowerCase() === "auto") && (this.conv.parseRuntime.delimiter = this.getDelimiter(re)), this.needEmitDelimiter && !this.delimiterEmitted && (this.conv.emit("delimiter", this.conv.parseRuntime.delimiter), this.delimiterEmitted = !0);
      var de = this.conv.parseRuntime.delimiter, be = re.split(de);
      if (ce === "off") {
        if (ue) for (var pe = 0; pe < be.length; pe++) be[pe] = be[pe].trim();
        return { cells: be, closed: !0 };
      }
      return this.toCSVRow(be, ue, ce, de);
    }, ne.prototype.toCSVRow = function(re, ce, ue, de) {
      for (var be = [], pe = !1, me = "", Me = 0, he = re.length; Me < he; Me++) {
        var ge = re[Me];
        !pe && ce && (ge = J.trimLeft(ge));
        var Ce = ge.length;
        if (pe) this.isQuoteClose(ge) ? (pe = !1, me += de + (ge = ge.substr(0, Ce - 1)), me = this.escapeQuote(me), ce && (me = J.trimRight(me)), be.push(me), me = "") : me += de + ge;
        else {
          if (Ce === 2 && ge === this.quote + this.quote) {
            be.push("");
            continue;
          }
          if (this.isQuoteOpen(ge)) {
            if (ge = ge.substr(1), this.isQuoteClose(ge)) {
              ge = ge.substring(0, ge.lastIndexOf(ue)), ge = this.escapeQuote(ge), be.push(ge);
              continue;
            }
            if (ge.indexOf(ue) !== -1) {
              for (var Se = 0, Ae = "", Le = 0, ve = ge; Le < ve.length; Le++) {
                var De = ve[Le];
                De === ue && Ae !== this.escape ? (Se++, Ae = "") : Ae = De;
              }
              if (Se % 2 == 1) {
                ce && (ge = J.trimRight(ge)), be.push(ue + ge);
                continue;
              }
              pe = !0, me += ge;
              continue;
            }
            pe = !0, me += ge;
            continue;
          }
          ce && (ge = J.trimRight(ge)), be.push(ge);
        }
      }
      return { cells: be, closed: !pe };
    }, ne.prototype.getDelimiter = function(re) {
      var ce;
      if (this.conv.parseParam.delimiter === "auto") ce = te;
      else {
        if (!(this.conv.parseParam.delimiter instanceof Array)) return this.conv.parseParam.delimiter;
        ce = this.conv.parseParam.delimiter;
      }
      var ue = 0, de = ",";
      return ce.forEach(function(be) {
        var pe = re.split(be).length;
        pe > ue && (de = be, ue = pe);
      }), de;
    }, ne.prototype.isQuoteOpen = function(re) {
      var ce = this.quote, ue = this.escape;
      return re[0] === ce && (re[1] !== ce || re[1] === ue && (re[2] === ce || re.length === 2));
    }, ne.prototype.isQuoteClose = function(re) {
      var ce = this.quote, ue = this.escape;
      this.conv.parseParam.trim && (re = J.trimRight(re));
      for (var de = 0, be = re.length - 1; re[be] === ce || re[be] === ue; ) be--, de++;
      return de % 2 != 0;
    }, ne.prototype.escapeQuote = function(re) {
      var ce = "es|" + this.quote + "|" + this.escape;
      this.cachedRegExp[ce] === void 0 && (this.cachedRegExp[ce] = new RegExp("\\" + this.escape + "\\" + this.quote, "g"));
      var ue = this.cachedRegExp[ce];
      return re.replace(ue, this.quote);
    }, ne.prototype.parseMultiLines = function(re) {
      for (var ce = [], ue = ""; re.length; ) {
        var de = ue + re.shift(), be = this.parse(de);
        be.cells.length === 0 && this.conv.parseParam.ignoreEmpty || (be.closed || this.conv.parseParam.alwaysSplitAtEOL ? (this.conv.parseRuntime.selectedColumns ? ce.push(J.filterArray(be.cells, this.conv.parseRuntime.selectedColumns)) : ce.push(be.cells), ue = "") : ue = de + (X.default(de, this.conv.parseRuntime) || `
`));
      }
      return { rowsCells: ce, partial: ue };
    }, ne;
  }();
  L.RowSplit = oe;
}, function(C, L, A) {
  var W = this && this.__importDefault || function(he) {
    return he && he.__esModule ? he : { default: he };
  };
  Object.defineProperty(L, "__esModule", { value: !0 });
  var X = W(A(29)), J = W(A(60)), te = /^[-+]?[0-9]*\.?[0-9]+([eE][-+]?[0-9]+)?$/;
  function oe(he, ge, Ce) {
    if (ge.parseParam.checkColumn && ge.parseRuntime.headers && he.length !== ge.parseRuntime.headers.length) throw X.default.column_mismatched(ge.parseRuntime.parsedLineNumber + Ce);
    return function(Se, Ae, Le) {
      for (var ve = !1, De = {}, Ue = 0, Fe = Se.length; Ue < Fe; Ue++) {
        var We = Se[Ue];
        if (!Le.parseParam.ignoreEmpty || We !== "") {
          ve = !0;
          var Ke = Ae[Ue];
          Ke && Ke !== "" || (Ke = Ae[Ue] = "field" + (Ue + 1));
          var it = re(Ke, Ue, Le);
          if (it) {
            var Qe = it(We, Ke, De, Se, Ue);
            Qe !== void 0 && ce(De, Ke, Qe, Le, Ue);
          } else
            Le.parseParam.checkType && (We = be(We, Ke, Ue, Le)(We)), We !== void 0 && ce(De, Ke, We, Le, Ue);
        }
      }
      return ve ? De : null;
    }(he, ge.parseRuntime.headers || [], ge) || null;
  }
  L.default = function(he, ge) {
    for (var Ce = [], Se = 0, Ae = he.length; Se < Ae; Se++) {
      var Le = oe(he[Se], ge, Se);
      Le && Ce.push(Le);
    }
    return Ce;
  };
  var ne = { string: me, number: pe, omit: function() {
  } };
  function re(he, ge, Ce) {
    if (Ce.parseRuntime.columnConv[ge] !== void 0) return Ce.parseRuntime.columnConv[ge];
    var Se = Ce.parseParam.colParser[he];
    if (Se === void 0) return Ce.parseRuntime.columnConv[ge] = null;
    if (typeof Se == "object" && (Se = Se.cellParser || "string"), typeof Se == "string") {
      Se = Se.trim().toLowerCase();
      var Ae = ne[Se];
      return Ce.parseRuntime.columnConv[ge] = Ae || null;
    }
    return Ce.parseRuntime.columnConv[ge] = typeof Se == "function" ? Se : null;
  }
  function ce(he, ge, Ce, Se, Ae) {
    if (!Se.parseRuntime.columnValueSetter[Ae]) if (Se.parseParam.flatKeys) Se.parseRuntime.columnValueSetter[Ae] = ue;
    else if (ge.indexOf(".") > -1) {
      for (var Le = ge.split("."), ve = !0; Le.length > 0; ) if (Le.shift().length === 0) {
        ve = !1;
        break;
      }
      !ve || Se.parseParam.colParser[ge] && Se.parseParam.colParser[ge].flat ? Se.parseRuntime.columnValueSetter[Ae] = ue : Se.parseRuntime.columnValueSetter[Ae] = de;
    } else Se.parseRuntime.columnValueSetter[Ae] = ue;
    Se.parseParam.nullObject === !0 && Ce === "null" && (Ce = null), Se.parseRuntime.columnValueSetter[Ae](he, ge, Ce);
  }
  function ue(he, ge, Ce) {
    he[ge] = Ce;
  }
  function de(he, ge, Ce) {
    J.default(he, ge, Ce);
  }
  function be(he, ge, Ce, Se) {
    return Se.parseRuntime.headerType[Ce] ? Se.parseRuntime.headerType[Ce] : ge.indexOf("number#!") > -1 ? Se.parseRuntime.headerType[Ce] = pe : ge.indexOf("string#!") > -1 ? Se.parseRuntime.headerType[Ce] = me : Se.parseParam.checkType ? Se.parseRuntime.headerType[Ce] = Me : Se.parseRuntime.headerType[Ce] = me;
  }
  function pe(he) {
    var ge = parseFloat(he);
    return isNaN(ge) ? he : ge;
  }
  function me(he) {
    return he.toString();
  }
  function Me(he) {
    var ge = he.trim();
    return ge === "" ? me(he) : te.test(ge) ? pe(he) : ge.length === 5 && ge.toLowerCase() === "false" || ge.length === 4 && ge.toLowerCase() === "true" ? function(Ce) {
      var Se = Ce.trim();
      return Se.length !== 5 || Se.toLowerCase() !== "false";
    }(he) : ge[0] === "{" && ge[ge.length - 1] === "}" || ge[0] === "[" && ge[ge.length - 1] === "]" ? function(Ce) {
      try {
        return JSON.parse(Ce);
      } catch {
        return Ce;
      }
    }(he) : me(he);
  }
}, function(C, L, A) {
  var W = A(61);
  C.exports = function(X, J, te) {
    return X == null ? X : W(X, J, te);
  };
}, function(C, L, A) {
  var W = A(62), X = A(74), J = A(103), te = A(20), oe = A(104);
  C.exports = function(ne, re, ce, ue) {
    if (!te(ne)) return ne;
    for (var de = -1, be = (re = X(re, ne)).length, pe = be - 1, me = ne; me != null && ++de < be; ) {
      var Me = oe(re[de]), he = ce;
      if (de != pe) {
        var ge = me[Me];
        (he = ue ? ue(ge, Me, me) : void 0) === void 0 && (he = te(ge) ? ge : J(re[de + 1]) ? [] : {});
      }
      W(me, Me, he), me = me[Me];
    }
    return ne;
  };
}, function(C, L, A) {
  var W = A(63), X = A(31), J = Object.prototype.hasOwnProperty;
  C.exports = function(te, oe, ne) {
    var re = te[oe];
    J.call(te, oe) && X(re, ne) && (ne !== void 0 || oe in te) || W(te, oe, ne);
  };
}, function(C, L, A) {
  var W = A(64);
  C.exports = function(X, J, te) {
    J == "__proto__" && W ? W(X, J, { configurable: !0, enumerable: !0, value: te, writable: !0 }) : X[J] = te;
  };
}, function(C, L, A) {
  var W = A(17), X = function() {
    try {
      var J = W(Object, "defineProperty");
      return J({}, "", {}), J;
    } catch {
    }
  }();
  C.exports = X;
}, function(C, L, A) {
  var W = A(66), X = A(70), J = A(20), te = A(72), oe = /^\[object .+?Constructor\]$/, ne = Function.prototype, re = Object.prototype, ce = ne.toString, ue = re.hasOwnProperty, de = RegExp("^" + ce.call(ue).replace(/[\\^$.*+?()[\]{}|]/g, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
  C.exports = function(be) {
    return !(!J(be) || X(be)) && (W(be) ? de : oe).test(te(be));
  };
}, function(C, L, A) {
  var W = A(30), X = A(20);
  C.exports = function(J) {
    if (!X(J)) return !1;
    var te = W(J);
    return te == "[object Function]" || te == "[object GeneratorFunction]" || te == "[object AsyncFunction]" || te == "[object Proxy]";
  };
}, function(C, L, A) {
  (function(W) {
    var X = typeof W == "object" && W && W.Object === Object && W;
    C.exports = X;
  }).call(this, A(0));
}, function(C, L, A) {
  var W = A(18), X = Object.prototype, J = X.hasOwnProperty, te = X.toString, oe = W ? W.toStringTag : void 0;
  C.exports = function(ne) {
    var re = J.call(ne, oe), ce = ne[oe];
    try {
      ne[oe] = void 0;
      var ue = !0;
    } catch {
    }
    var de = te.call(ne);
    return ue && (re ? ne[oe] = ce : delete ne[oe]), de;
  };
}, function(C, L) {
  var A = Object.prototype.toString;
  C.exports = function(W) {
    return A.call(W);
  };
}, function(C, L, A) {
  var W = A(71), X = function() {
    var J = /[^.]+$/.exec(W && W.keys && W.keys.IE_PROTO || "");
    return J ? "Symbol(src)_1." + J : "";
  }();
  C.exports = function(J) {
    return !!X && X in J;
  };
}, function(C, L, A) {
  var W = A(19)["__core-js_shared__"];
  C.exports = W;
}, function(C, L) {
  var A = Function.prototype.toString;
  C.exports = function(W) {
    if (W != null) {
      try {
        return A.call(W);
      } catch {
      }
      try {
        return W + "";
      } catch {
      }
    }
    return "";
  };
}, function(C, L) {
  C.exports = function(A, W) {
    return A == null ? void 0 : A[W];
  };
}, function(C, L, A) {
  var W = A(21), X = A(75), J = A(77), te = A(100);
  C.exports = function(oe, ne) {
    return W(oe) ? oe : X(oe, ne) ? [oe] : J(te(oe));
  };
}, function(C, L, A) {
  var W = A(21), X = A(22), J = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, te = /^\w*$/;
  C.exports = function(oe, ne) {
    if (W(oe)) return !1;
    var re = typeof oe;
    return !(re != "number" && re != "symbol" && re != "boolean" && oe != null && !X(oe)) || te.test(oe) || !J.test(oe) || ne != null && oe in Object(ne);
  };
}, function(C, L) {
  C.exports = function(A) {
    return A != null && typeof A == "object";
  };
}, function(C, L, A) {
  var W = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, X = /\\(\\)?/g, J = A(78)(function(te) {
    var oe = [];
    return te.charCodeAt(0) === 46 && oe.push(""), te.replace(W, function(ne, re, ce, ue) {
      oe.push(ce ? ue.replace(X, "$1") : re || ne);
    }), oe;
  });
  C.exports = J;
}, function(C, L, A) {
  var W = A(79);
  C.exports = function(X) {
    var J = W(X, function(oe) {
      return te.size === 500 && te.clear(), oe;
    }), te = J.cache;
    return J;
  };
}, function(C, L, A) {
  var W = A(80), X = "Expected a function";
  function J(te, oe) {
    if (typeof te != "function" || oe != null && typeof oe != "function") throw new TypeError(X);
    var ne = function() {
      var re = arguments, ce = oe ? oe.apply(this, re) : re[0], ue = ne.cache;
      if (ue.has(ce)) return ue.get(ce);
      var de = te.apply(this, re);
      return ne.cache = ue.set(ce, de) || ue, de;
    };
    return ne.cache = new (J.Cache || W)(), ne;
  }
  J.Cache = W, C.exports = J;
}, function(C, L, A) {
  var W = A(81), X = A(95), J = A(97), te = A(98), oe = A(99);
  function ne(re) {
    var ce = -1, ue = re == null ? 0 : re.length;
    for (this.clear(); ++ce < ue; ) {
      var de = re[ce];
      this.set(de[0], de[1]);
    }
  }
  ne.prototype.clear = W, ne.prototype.delete = X, ne.prototype.get = J, ne.prototype.has = te, ne.prototype.set = oe, C.exports = ne;
}, function(C, L, A) {
  var W = A(82), X = A(88), J = A(94);
  C.exports = function() {
    this.size = 0, this.__data__ = { hash: new W(), map: new (J || X)(), string: new W() };
  };
}, function(C, L, A) {
  var W = A(83), X = A(84), J = A(85), te = A(86), oe = A(87);
  function ne(re) {
    var ce = -1, ue = re == null ? 0 : re.length;
    for (this.clear(); ++ce < ue; ) {
      var de = re[ce];
      this.set(de[0], de[1]);
    }
  }
  ne.prototype.clear = W, ne.prototype.delete = X, ne.prototype.get = J, ne.prototype.has = te, ne.prototype.set = oe, C.exports = ne;
}, function(C, L, A) {
  var W = A(8);
  C.exports = function() {
    this.__data__ = W ? W(null) : {}, this.size = 0;
  };
}, function(C, L) {
  C.exports = function(A) {
    var W = this.has(A) && delete this.__data__[A];
    return this.size -= W ? 1 : 0, W;
  };
}, function(C, L, A) {
  var W = A(8), X = Object.prototype.hasOwnProperty;
  C.exports = function(J) {
    var te = this.__data__;
    if (W) {
      var oe = te[J];
      return oe === "__lodash_hash_undefined__" ? void 0 : oe;
    }
    return X.call(te, J) ? te[J] : void 0;
  };
}, function(C, L, A) {
  var W = A(8), X = Object.prototype.hasOwnProperty;
  C.exports = function(J) {
    var te = this.__data__;
    return W ? te[J] !== void 0 : X.call(te, J);
  };
}, function(C, L, A) {
  var W = A(8);
  C.exports = function(X, J) {
    var te = this.__data__;
    return this.size += this.has(X) ? 0 : 1, te[X] = W && J === void 0 ? "__lodash_hash_undefined__" : J, this;
  };
}, function(C, L, A) {
  var W = A(89), X = A(90), J = A(91), te = A(92), oe = A(93);
  function ne(re) {
    var ce = -1, ue = re == null ? 0 : re.length;
    for (this.clear(); ++ce < ue; ) {
      var de = re[ce];
      this.set(de[0], de[1]);
    }
  }
  ne.prototype.clear = W, ne.prototype.delete = X, ne.prototype.get = J, ne.prototype.has = te, ne.prototype.set = oe, C.exports = ne;
}, function(C, L) {
  C.exports = function() {
    this.__data__ = [], this.size = 0;
  };
}, function(C, L, A) {
  var W = A(9), X = Array.prototype.splice;
  C.exports = function(J) {
    var te = this.__data__, oe = W(te, J);
    return !(oe < 0 || (oe == te.length - 1 ? te.pop() : X.call(te, oe, 1), --this.size, 0));
  };
}, function(C, L, A) {
  var W = A(9);
  C.exports = function(X) {
    var J = this.__data__, te = W(J, X);
    return te < 0 ? void 0 : J[te][1];
  };
}, function(C, L, A) {
  var W = A(9);
  C.exports = function(X) {
    return W(this.__data__, X) > -1;
  };
}, function(C, L, A) {
  var W = A(9);
  C.exports = function(X, J) {
    var te = this.__data__, oe = W(te, X);
    return oe < 0 ? (++this.size, te.push([X, J])) : te[oe][1] = J, this;
  };
}, function(C, L, A) {
  var W = A(17)(A(19), "Map");
  C.exports = W;
}, function(C, L, A) {
  var W = A(10);
  C.exports = function(X) {
    var J = W(this, X).delete(X);
    return this.size -= J ? 1 : 0, J;
  };
}, function(C, L) {
  C.exports = function(A) {
    var W = typeof A;
    return W == "string" || W == "number" || W == "symbol" || W == "boolean" ? A !== "__proto__" : A === null;
  };
}, function(C, L, A) {
  var W = A(10);
  C.exports = function(X) {
    return W(this, X).get(X);
  };
}, function(C, L, A) {
  var W = A(10);
  C.exports = function(X) {
    return W(this, X).has(X);
  };
}, function(C, L, A) {
  var W = A(10);
  C.exports = function(X, J) {
    var te = W(this, X), oe = te.size;
    return te.set(X, J), this.size += te.size == oe ? 0 : 1, this;
  };
}, function(C, L, A) {
  var W = A(101);
  C.exports = function(X) {
    return X == null ? "" : W(X);
  };
}, function(C, L, A) {
  var W = A(18), X = A(102), J = A(21), te = A(22), oe = W ? W.prototype : void 0, ne = oe ? oe.toString : void 0;
  C.exports = function re(ce) {
    if (typeof ce == "string") return ce;
    if (J(ce)) return X(ce, re) + "";
    if (te(ce)) return ne ? ne.call(ce) : "";
    var ue = ce + "";
    return ue == "0" && 1 / ce == -1 / 0 ? "-0" : ue;
  };
}, function(C, L) {
  C.exports = function(A, W) {
    for (var X = -1, J = A == null ? 0 : A.length, te = Array(J); ++X < J; ) te[X] = W(A[X], X, A);
    return te;
  };
}, function(C, L) {
  var A = /^(?:0|[1-9]\d*)$/;
  C.exports = function(W, X) {
    var J = typeof W;
    return !!(X = X ?? 9007199254740991) && (J == "number" || J != "symbol" && A.test(W)) && W > -1 && W % 1 == 0 && W < X;
  };
}, function(C, L, A) {
  var W = A(22);
  C.exports = function(X) {
    if (typeof X == "string" || W(X)) return X;
    var J = X + "";
    return J == "0" && 1 / X == -1 / 0 ? "-0" : J;
  };
}, function(C, L, A) {
  var W = this && this.__importDefault || function(ne) {
    return ne && ne.__esModule ? ne : { default: ne };
  };
  Object.defineProperty(L, "__esModule", { value: !0 });
  var X = W(A(15)), J = A(106), te = function() {
    function ne(re) {
      this.converter = re, this.finalResult = [];
    }
    return Object.defineProperty(ne.prototype, "needEmitLine", { get: function() {
      return !!this.converter.parseRuntime.subscribe && !!this.converter.parseRuntime.subscribe.onNext || this.needPushDownstream;
    }, enumerable: !0, configurable: !0 }), Object.defineProperty(ne.prototype, "needPushDownstream", { get: function() {
      return this._needPushDownstream === void 0 && (this._needPushDownstream = this.converter.listeners("data").length > 0 || this.converter.listeners("readable").length > 0), this._needPushDownstream;
    }, enumerable: !0, configurable: !0 }), Object.defineProperty(ne.prototype, "needEmitAll", { get: function() {
      return !!this.converter.parseRuntime.then && this.converter.parseParam.needEmitAll;
    }, enumerable: !0, configurable: !0 }), ne.prototype.processResult = function(re) {
      var ce = this, ue = this.converter.parseRuntime.parsedLineNumber;
      return this.needPushDownstream && this.converter.parseParam.downstreamFormat === "array" && ue === 0 && oe(this.converter, "[" + J.EOL), new X.default(function(de, be) {
        ce.needEmitLine ? function pe(me, Me, he, ge, Ce) {
          if (he >= me.length) Ce();
          else if (Me.parseRuntime.subscribe && Me.parseRuntime.subscribe.onNext) {
            var Se = Me.parseRuntime.subscribe.onNext, Ae = me[he], Le = Se(Ae, Me.parseRuntime.parsedLineNumber + he);
            if (he++, Le && Le.then) Le.then(function() {
              (function(De, Ue, Fe, We, Ke, it, Qe) {
                Ke && oe(Fe, Qe), pe(De, Fe, We, Ke, it);
              })(me, 0, Me, he, ge, Ce, Ae);
            }, Ce);
            else {
              for (ge && oe(Me, Ae); he < me.length; ) {
                var ve = me[he];
                Se(ve, Me.parseRuntime.parsedLineNumber + he), he++, ge && oe(Me, ve);
              }
              Ce();
            }
          } else {
            if (ge) for (; he < me.length; ) ve = me[he++], oe(Me, ve);
            Ce();
          }
        }(re, ce.converter, 0, ce.needPushDownstream, function(pe) {
          pe ? be(pe) : (ce.appendFinalResult(re), de());
        }) : (ce.appendFinalResult(re), de());
      });
    }, ne.prototype.appendFinalResult = function(re) {
      this.needEmitAll && (this.finalResult = this.finalResult.concat(re)), this.converter.parseRuntime.parsedLineNumber += re.length;
    }, ne.prototype.processError = function(re) {
      this.converter.parseRuntime.subscribe && this.converter.parseRuntime.subscribe.onError && this.converter.parseRuntime.subscribe.onError(re), this.converter.parseRuntime.then && this.converter.parseRuntime.then.onrejected && this.converter.parseRuntime.then.onrejected(re);
    }, ne.prototype.endProcess = function() {
      this.converter.parseRuntime.then && this.converter.parseRuntime.then.onfulfilled && (this.needEmitAll ? this.converter.parseRuntime.then.onfulfilled(this.finalResult) : this.converter.parseRuntime.then.onfulfilled([])), this.converter.parseRuntime.subscribe && this.converter.parseRuntime.subscribe.onCompleted && this.converter.parseRuntime.subscribe.onCompleted(), this.needPushDownstream && this.converter.parseParam.downstreamFormat === "array" && oe(this.converter, "]" + J.EOL);
    }, ne;
  }();
  function oe(ne, re) {
    if (typeof re != "object" || ne.options.objectMode) ne.push(re);
    else {
      var ce = JSON.stringify(re);
      ne.push(ce + (ne.parseParam.downstreamFormat === "array" ? "," + J.EOL : J.EOL), "utf8");
    }
  }
  L.Result = te;
}, function(C, L) {
  L.endianness = function() {
    return "LE";
  }, L.hostname = function() {
    return typeof location < "u" ? location.hostname : "";
  }, L.loadavg = function() {
    return [];
  }, L.uptime = function() {
    return 0;
  }, L.freemem = function() {
    return Number.MAX_VALUE;
  }, L.totalmem = function() {
    return Number.MAX_VALUE;
  }, L.cpus = function() {
    return [];
  }, L.type = function() {
    return "Browser";
  }, L.release = function() {
    return typeof navigator < "u" ? navigator.appVersion : "";
  }, L.networkInterfaces = L.getNetworkInterfaces = function() {
    return {};
  }, L.arch = function() {
    return "javascript";
  }, L.platform = function() {
    return "browser";
  }, L.tmpdir = L.tmpDir = function() {
    return "/tmp";
  }, L.EOL = `
`, L.homedir = function() {
    return "/";
  };
}]);
const csv = /* @__PURE__ */ getDefaultExportFromCjs$1(browser), rr = class rr {
  get src() {
    return this._src;
  }
  /**
   * returns the IANA media type as defined by
   * https://www.iana.org/assignments/media-types/media-types.xhtml
   *
   * You should always trust this getter over the file objects type because
   * the file object can be incomplete or incorrect
   */
  get mediaType() {
    if (!this.file)
      throw new Error("File is not defined");
    return this.file.type ?? this.fileExtensionMediaType(this.file.name);
  }
  async updateSrc(L) {
    this._src = L;
    const A = await fetch(L);
    if (!A.ok)
      throw new Error(`Could not fetch data: ${A.statusText} (${A.status})`);
    const W = await A.text(), X = A.headers.get("Content-Type");
    return this.file = new File([W], this.src ?? "data", { type: X ?? "" }), this.jsonModels = await this.generateSubjects(), this;
  }
  async subjects() {
    return this.jsonModels ?? (this.jsonModels = await this.generateSubjects());
  }
  async generateSubjects() {
    if (!this.file)
      throw new Error("File is not defined");
    const L = await this.file.text();
    let A;
    switch (this.mediaType) {
      case "application/json": {
        A = JSON.parse(L);
        break;
      }
      case "text/csv": {
        A = await csv({ flatKeys: !0 }).fromString(L);
        break;
      }
      case "text/tab-separated-values": {
        A = await csv({ flatKeys: !0, delimiter: "	" }).fromString(L);
        break;
      }
      default:
        throw rr.unsupportedFormatError;
    }
    return A;
  }
  /**
   * Attempts to extract the MIME media type using the file extension
   * This should always be used as a last resort for when the browser cannot
   * determine the correct MIME type.
   */
  fileExtensionMediaType(L) {
    var X;
    const A = (X = L.split(".").at(-1)) == null ? void 0 : X.toLowerCase();
    if (!A)
      throw rr.undeterminedFormatError;
    const W = {
      csv: "text/csv",
      tsv: "text/tab-separated-values",
      json: "application/json"
    };
    if (A in W)
      return W[A];
    throw rr.unsupportedFormatError;
  }
};
rr.unsupportedFormatError = new Error("Unsupported file format"), rr.undeterminedFormatError = new Error("Could not determine file format");
let DataSourceFetcher = rr;
const dataSourceStyles = "";
var __defProp$5 = Object.defineProperty, __getOwnPropDesc$5 = Object.getOwnPropertyDescriptor, __decorateClass$5 = (C, L, A, W) => {
  for (var X = W > 1 ? void 0 : W ? __getOwnPropDesc$5(L, A) : L, J = C.length - 1, te; J >= 0; J--)
    (te = C[J]) && (X = (W ? te(L, A, X) : te(X)) || X);
  return W && X && __defProp$5(L, A, X), X;
};
let DataSourceComponent = class extends AbstractComponent(h$1) {
  constructor() {
    super(...arguments), this.local = !1, this.random = !1, this.canDownload = !1, this.decisionHandler = this.handleDecision.bind(this);
  }
  willUpdate(C) {
    if (C.has("for") && this.for || C.has("src") && this.src) {
      const L = document.getElementById(this.for);
      L && L instanceof VerificationGridComponent && (this.verificationGrid && this.verificationGrid.removeEventListener(
        VerificationGridComponent.decisionMadeEventName,
        this.decisionHandler
      ), this.verificationGrid = L, this.verificationGrid.addEventListener(VerificationGridComponent.decisionMadeEventName, this.decisionHandler), this.updateVerificationGrid());
    }
  }
  async downloadResults() {
    var re;
    if (this.canDownload) {
      if (!((re = this.dataFetcher) != null && re.file))
        throw new Error("File is not defined");
    } else return;
    const C = await this.resultRows(), L = this.dataFetcher.mediaType ?? "", A = this.dataFetcher.file.name, W = A.lastIndexOf("."), X = A.slice(0, W).split("/").at(-1), J = A.slice(W), te = `${X}_verified${J}`;
    let oe = "";
    if (L === "application/json")
      oe = JSON.stringify(C);
    else if (L === "text/csv")
      oe = new JSON2CSVParser().parse(C);
    else if (L === "text/tab-separated-values")
      oe = new JSON2CSVParser({ delimiter: "	" }).parse(C);
    else
      throw new Error("Unsupported file format");
    const ne = new File([oe], te, { type: this.dataFetcher.file.type });
    downloadFile(ne);
  }
  async resultRows() {
    if (!this.dataFetcher)
      throw new Error("Data fetcher is not defined");
    const C = await this.dataFetcher.subjects() ?? [];
    if (!this.verificationGrid)
      return C;
    const L = this.verificationGrid.subjectHistory, A = this.verificationGrid.currentPage, W = [...L, ...A];
    return C.map((X) => this.rowDecision(X, W));
  }
  rowDecision(C, L) {
    const A = L.find((ne) => ne.subject && C && ne.subject === C);
    if (!A)
      return C;
    const W = DataSourceComponent.columnNamespace, X = A.verification, J = A.classifications, te = {}, oe = {};
    if (J)
      for (const ne of J) {
        const re = `${W}${ne.tag.text}`, ce = ne.confirmed;
        te[re] = ce;
      }
    return X && (oe[`${W}tag`] = A.tag, oe[`${W}confirmed`] = X.confirmed), {
      ...C,
      ...oe,
      ...te
    };
  }
  handleDecision() {
    this.canDownload = !0;
  }
  handleFileChange(C) {
    var W;
    const A = (W = C.target.files) == null ? void 0 : W.item(0);
    !A || !this.verificationGrid || (this.src = URL.createObjectURL(A));
  }
  buildCallback(C) {
    if (!Array.isArray(C))
      throw new Error("Response is not an array");
    return async (L) => {
      if (!this.verificationGrid)
        return {
          subjects: [],
          context: L
        };
      const W = (L.page ?? -1) + 1, X = DataSourceComponent.pageSize, J = X * W, te = J + X;
      return L.page = W, {
        subjects: C.slice(J, te),
        context: L
      };
    };
  }
  async updateVerificationGrid() {
    if (!this.verificationGrid || !this.src)
      return;
    if (!this.for)
      throw new Error("for attribute must be set on a data source");
    if (this.dataFetcher = await new DataSourceFetcher().updateSrc(this.src), !this.dataFetcher.file)
      throw new Error("Data fetcher does not have a file.");
    this.fileName = this.dataFetcher.file.name;
    const C = await this.dataFetcher.subjects();
    if (Array.isArray(C)) {
      if (C.length === 0)
        return;
    } else throw new Error("Response is not an array");
    const L = this.buildCallback(C);
    L && (this.verificationGrid.getPage = L);
  }
  fileInputTemplate() {
    return ke$1`
      <span>
        <button
          class="file-input oe-btn-secondary"
          part="file-picker"
          @click="${(L) => {
      L.preventDefault(), this.fileInput.click();
    }}"
          aria-controls="browser-file-input"
        >
          ${this.fileName ? `File: ${this.fileName}` : "Browse files"}
        </button>
        <input
          id="browser-file-input"
          class="hidden"
          type="file"
          accept=".csv,.json"
          @change="${this.handleFileChange}"
        />
      </span>
    `;
  }
  render() {
    const C = this.local ? this.fileInputTemplate() : D;
    return ke$1`
      <div class="data-source">
        ${C}

        <button
          data-testid="download-results-button"
          class="oe-btn-secondary"
          @click="${this.downloadResults}"
          ?disabled="${!this.canDownload}"
        >
          Download Results
        </button>
      </div>
    `;
  }
};
DataSourceComponent.styles = r$6(dataSourceStyles);
DataSourceComponent.columnNamespace = "oe_";
DataSourceComponent.pageSize = 10;
__decorateClass$5([
  n$1({ type: String })
], DataSourceComponent.prototype, "src", 2);
__decorateClass$5([
  required(),
  n$1({ type: String })
], DataSourceComponent.prototype, "for", 2);
__decorateClass$5([
  n$1({ type: Boolean, converter: booleanConverter })
], DataSourceComponent.prototype, "local", 2);
__decorateClass$5([
  n$1({ type: Boolean, converter: booleanConverter })
], DataSourceComponent.prototype, "random", 2);
__decorateClass$5([
  r$3()
], DataSourceComponent.prototype, "canDownload", 2);
__decorateClass$5([
  r$3()
], DataSourceComponent.prototype, "fileName", 2);
__decorateClass$5([
  e$6("input[type=file]")
], DataSourceComponent.prototype, "fileInput", 2);
DataSourceComponent = __decorateClass$5([
  t$4("oe-data-source")
], DataSourceComponent);
function* loop(C, L) {
  if (C !== void 0) {
    let A = 0;
    for (const W of C) {
      const X = A == 0, J = A == C.length - 1, te = A % 2 == 0, oe = !te;
      yield L(W, { index: A++, first: X, last: J, even: te, odd: oe });
    }
  }
}
const helpDialogStyles = "#help-dialog{position:fixed}#help-dialog h1{font-weight:600}#help-dialog h2,#help-dialog h3{font-weight:500;margin-bottom:0}#help-dialog hr{position:relative;margin-top:1em;margin-bottom:1.5em}#help-dialog section{position:relative;width:fix-content;max-width:60em;padding:var(--oe-spacing)}.dialog-content{display:flex;flex-wrap:wrap;gap:var(--oe-spacing)}.dialog-content>*{flex:1}.dialog-content>*:not(:first-child){border-left:1px dotted var(--oe-font-color)}.dialog-controls{display:block;position:relative}";
var __defProp$4 = Object.defineProperty, __getOwnPropDesc$4 = Object.getOwnPropertyDescriptor, __decorateClass$4 = (C, L, A, W) => {
  for (var X = W > 1 ? void 0 : W ? __getOwnPropDesc$4(L, A) : L, J = C.length - 1, te; J >= 0; J--)
    (te = C[J]) && (X = (W ? te(L, A, X) : te(X)) || X);
  return W && X && __defProp$4(L, A, X), X;
};
const helpPreferenceLocalStorageKey = "oe-verification-grid-dialog-preferences";
let VerificationHelpDialogComponent = class extends AbstractComponent(h$1) {
  constructor() {
    super(...arguments), this.showRememberOption = !0;
  }
  get open() {
    return this.helpDialogElement.open;
  }
  get hasVerificationTask() {
    return this.verificationTasksCount > 0;
  }
  get hasClassificationTask() {
    return this.classificationTasksCount > 0;
  }
  firstUpdated() {
    localStorage.getItem(helpPreferenceLocalStorageKey) === null && this.showModal();
  }
  showModal(C = !0) {
    this.showRememberOption = C, this.helpDialogElement.showModal(), this.dispatchEvent(new CustomEvent("open"));
  }
  handleDialogClose() {
    this.dispatchEvent(new CustomEvent("close"));
    const C = this.dialogPreferenceElement;
    if (!C)
      return;
    C.checked && localStorage.setItem(helpPreferenceLocalStorageKey, "true");
  }
  keyboardShortcutTemplate(C) {
    return ke$1`
      <div class="keyboard-shortcuts">
        ${C.map(
      (L) => ke$1` <div>
              ${loop(
        L.key.split("+"),
        (A, { last: W }) => ke$1`
                  <kbd class="key">${A}</kbd>
                  ${nn(!W, () => "+")}
                `
      )}

              <span class="description">${L.description}</span>
            </div>`
    )}
      </div>
    `;
  }
  verificationTasks() {
    return ["verify if the tag applied is correct or not"];
  }
  classificationTasks() {
    return [
      `Classify each audio segment ${this.classificationTasksCount} time${this.classificationTasksCount > 0 ? "s" : ""}, one for each of the classes`
    ];
  }
  informationTemplate() {
    const C = this.verificationTasksCount + this.classificationTasksCount, L = [];
    return this.hasVerificationTask && L.push(...this.verificationTasks()), this.hasClassificationTask && L.push(...this.classificationTasks()), ke$1`
      <p>
        The Verification grid is a tool to help you validate and verify audio events either generated by a machine
        learning model or by a human annotator.
      </p>

      <p>For each audio segment you will need to complete ${C} action</p>

      <ol>
        ${oo$1(L, (A) => ke$1`<li>${A}</li>`)}
      </ol>

      <p>
        Any recordings that you do not apply a decision to will be marked as "SKIP" when the results are downloaded.
      </p>

      <p>
        We highly recommend that you use the verification grids "Fullscreen Mode" by using the fullscreen icon or by
        pressing <kbd>F11</kbd> on your keyboard.
      </p>
    `;
  }
  render() {
    var A;
    const C = [
      { key: "Ctrl + A", description: "Select all items" },
      { key: "Shift + Click", description: "Add a range of items to the sub-selection" },
      { key: "Ctrl + Click", description: "Toggle the selection of a single item" },
      { key: "Ctrl + Shift + Click", description: "Select a range of items" },
      { key: "Esc", description: "Deselect all items" },
      { key: "Ctrl + D", description: "Deselect all items" },
      { key: "Alt", description: "Show possible keyboard shortcuts" },
      { key: "Left Arrow", description: "Go back to the previous page" },
      { key: "Right Arrow", description: "Go to the next page (when viewing history)" }
    ], L = [
      ...(((A = this.decisionElements) == null ? void 0 : A.map((W) => ({
        key: W.shortcut,
        description: `${W.innerText} ${W.additionalTags.length ? `(${W.additionalTags.map((X) => X.text)})` : ""}`
      }))) ?? []).filter((W) => W.key)
    ];
    return ke$1`
      <dialog
        id="help-dialog"
        @pointerdown="${() => this.helpDialogElement.close()}"
        @close="${this.handleDialogClose}"
      >
        <div class="dialog-container" @pointerdown="${(W) => W.stopPropagation()}">
          <h1>Information</h1>
          ${this.informationTemplate()}

          <div class="dialog-content">
            <section>
              <h2>Decisions</h2>
              <p>Review the samples, press the button that makes the most sense</p>

              ${this.selectionBehavior !== "tablet" ? ke$1`
                    <h3>Keyboard Shortcuts</h3>
                    ${this.keyboardShortcutTemplate(L)}
                  ` : D}
            </section>

            <section>
              <h2>Sub-Selection</h2>
              <p>You can apply a decision to only a few items in the grid by clicking on them.</p>

              ${this.selectionBehavior !== "tablet" ? ke$1`
                    <h3>Keyboard Shortcuts</h3>
                    <p>
                      You can also use <kbd>Alt</kbd> + <math>a number</math> (e.g. <kbd>Alt</kbd> + <kbd>1</kbd>) to
                      select a tile using you keyboard. It is possible to see the possible keyboard shortcuts for
                      selection by holding down the <kbd>Alt</kbd> key.
                    </p>

                    ${this.keyboardShortcutTemplate(C)}
                  ` : D}
            </section>
          </div>

          <hr />

          <form class="dialog-controls" method="dialog">
            <label class="show-again">
              ${this.showRememberOption ? ke$1`
                    <input
                      id="dialog-preference"
                      name="dialog-preference"
                      type="checkbox"
                      ?checked="${localStorage.getItem(helpPreferenceLocalStorageKey) !== null}"
                    />
                    Do not show this dialog again
                  ` : D}
            </label>
            <button
              data-testid="dismiss-help-dialog-btn"
              class="oe-btn oe-btn-primary close-btn"
              type="submit"
              autofocus
            >
              Close
            </button>
          </form>
        </div>
      </dialog>
    `;
  }
};
VerificationHelpDialogComponent.styles = r$6(helpDialogStyles);
__decorateClass$4([
  n$1({ type: Array })
], VerificationHelpDialogComponent.prototype, "decisionElements", 2);
__decorateClass$4([
  n$1({ type: String })
], VerificationHelpDialogComponent.prototype, "selectionBehavior", 2);
__decorateClass$4([
  n$1({ type: Number })
], VerificationHelpDialogComponent.prototype, "verificationTasksCount", 2);
__decorateClass$4([
  n$1({ type: Number })
], VerificationHelpDialogComponent.prototype, "classificationTasksCount", 2);
__decorateClass$4([
  r$3()
], VerificationHelpDialogComponent.prototype, "showRememberOption", 2);
__decorateClass$4([
  e$6("#help-dialog")
], VerificationHelpDialogComponent.prototype, "helpDialogElement", 2);
__decorateClass$4([
  e$6("#dialog-preference")
], VerificationHelpDialogComponent.prototype, "dialogPreferenceElement", 2);
VerificationHelpDialogComponent = __decorateClass$4([
  t$4("oe-verification-help-dialog")
], VerificationHelpDialogComponent);
const decisionStyles = "#decision-button{position:relative;height:100%}#decision-button>div{display:block;min-height:1em}#decision-button .additional-tags{font-size:var(--oe-font-size)}#decision-button>*{pointer-events:none}#decision-button:active:not(.cancel-next):not(.disabled,:disabled),#decision-button.show-decision-color:not(.disabled,:disabled){outline:none;border:none;border:var(--oe-border-width) solid var(--decision-color);--background-color: var(--decision-color)}.decision-button{--decision-color: none}.skip{background:repeating-linear-gradient(45deg,var(--oe-warning-color),var(--oe-warning-color) 10px,transparent 10px,transparent 20px)!important}";
var __defProp$3 = Object.defineProperty, __getOwnPropDesc$3 = Object.getOwnPropertyDescriptor, __decorateClass$3 = (C, L, A, W) => {
  for (var X = W > 1 ? void 0 : W ? __getOwnPropDesc$3(L, A) : L, J = C.length - 1, te; J >= 0; J--)
    (te = C[J]) && (X = (W ? te(L, A, X) : te(X)) || X);
  return W && X && __defProp$3(L, A, X), X;
};
let DecisionComponent = class extends AbstractComponent(h$1) {
  constructor() {
    super(), this.additionalTags = [], this.disabled = !1, this.verified = DecisionOptions.TRUE, this.highlighted = !1, this.decisionId = 0, this.selectionMode = "desktop", this.keyboardHeldDown = !1, this.shouldEmitNext = !0, this.keyUpHandler = this.handleKeyUp.bind(this), this.keyDownHandler = this.handleKeyDown.bind(this);
  }
  willUpdate(C) {
    if (this.decisionModels ?? (this.decisionModels = this.generateDecisionModels()), C.has("verified"))
      for (const L of this.decisionModels)
        L.confirmed = this.verified;
    if (C.has("decisionId"))
      for (const L of this.decisionModels)
        L.decisionId = this.decisionId;
  }
  // override in decision components that extend this base abstract decision
  // component with an implementation that generates decision models that will
  // be emitted when clicked / the shortcut key is pressed
  generateDecisionModels() {
    return [];
  }
  isShowingDecisionColor() {
    return this.keyboardHeldDown || this.highlighted;
  }
  connectedCallback() {
    super.connectedCallback(), document.addEventListener("keydown", this.keyDownHandler), document.addEventListener("keyup", this.keyUpHandler);
  }
  disconnectedCallback() {
    document.removeEventListener("keydown", this.keyDownHandler), document.removeEventListener("keyup", this.keyUpHandler), super.disconnectedCallback();
  }
  handleKeyUp(C) {
    C.key !== ESCAPE_KEY && this.isShortcutKey(C) && this.emitDecision();
  }
  handleKeyDown(C) {
    if (this.isShortcutKey(C)) {
      this.keyboardHeldDown = !0;
      return;
    }
    this.keyboardHeldDown && C.key === ESCAPE_KEY && (this.shouldEmitNext = !1, this.keyboardHeldDown = !1);
  }
  isShortcutKey(C) {
    return this.shortcut === void 0 ? !1 : C.key.toLowerCase() === this.shortcut.toLowerCase();
  }
  emitDecision() {
    if (this.keyboardHeldDown = !1, this.disabled)
      return;
    const C = this.shouldEmitNext;
    if (this.shouldEmitNext = !0, C) {
      if (this.decisionModels === void 0)
        throw new Error("Decision model is not initialized");
    } else return;
    this.decisionButton.focus();
    const L = new CustomEvent(DecisionComponent.decisionEventName, {
      detail: {
        value: this.decisionModels,
        target: this
      },
      bubbles: !0
    });
    this.dispatchEvent(L);
  }
  render() {
    const C = this.additionalTags.length ? ke$1`(${this.additionalTags.map((W) => W.text).join(", ")})` : D, L = this.shortcut && this.selectionMode !== "tablet" ? ke$1`<kbd>${this.shortcut.toUpperCase()}</kbd>` : D, A = Rt({
      disabled: !!this.disabled,
      "show-decision-color": this.isShowingDecisionColor(),
      "cancel-next": !this.shouldEmitNext,
      [`decision-${this.decisionId}`]: this.verified !== DecisionOptions.SKIP,
      skip: this.verified === DecisionOptions.SKIP && this.highlighted
    });
    return ke$1`
      <button
        id="decision-button"
        class="oe-btn-primary decision-button ${A}"
        part="decision-button"
        title="Shortcut: ${this.shortcut}"
        aria-disabled="${this.disabled}"
        @click="${this.emitDecision}"
      >
        <div class="tag-text"><slot></slot></div>
        <div class="additional-tags">${C}</div>
        ${this.selectionMode !== "tablet" ? ke$1`<div class="keyboard-legend">${L}</div>` : D}
      </button>
    `;
  }
};
DecisionComponent.styles = [r$6(decisionStyles), decisionColors];
DecisionComponent.decisionEventName = "decision";
__decorateClass$3([
  n$1({ attribute: "additional-tags", type: Array, converter: tagArrayConverter, reflect: !0 })
], DecisionComponent.prototype, "additionalTags", 2);
__decorateClass$3([
  n$1({ attribute: "disabled", type: Boolean, converter: booleanConverter, reflect: !0 })
], DecisionComponent.prototype, "disabled", 2);
__decorateClass$3([
  n$1({ type: String, converter: enumConverter(DecisionOptions) })
], DecisionComponent.prototype, "verified", 2);
__decorateClass$3([
  n$1({ type: String, reflect: !0 })
], DecisionComponent.prototype, "shortcut", 2);
__decorateClass$3([
  n$1({ attribute: !1, type: Boolean })
], DecisionComponent.prototype, "highlighted", 2);
__decorateClass$3([
  n$1({ attribute: !1, type: Number })
], DecisionComponent.prototype, "decisionId", 2);
__decorateClass$3([
  n$1({ attribute: !1 })
], DecisionComponent.prototype, "selectionMode", 2);
__decorateClass$3([
  e$6("#decision-button")
], DecisionComponent.prototype, "decisionButton", 2);
__decorateClass$3([
  r$3()
], DecisionComponent.prototype, "keyboardHeldDown", 2);
__decorateClass$3([
  r$3()
], DecisionComponent.prototype, "shouldEmitNext", 2);
DecisionComponent = __decorateClass$3([
  t$4("oe-decision")
], DecisionComponent);
var __defProp$2 = Object.defineProperty, __getOwnPropDesc$2 = Object.getOwnPropertyDescriptor, __decorateClass$2 = (C, L, A, W) => {
  for (var X = W > 1 ? void 0 : W ? __getOwnPropDesc$2(L, A) : L, J = C.length - 1, te; J >= 0; J--)
    (te = C[J]) && (X = (W ? te(L, A, X) : te(X)) || X);
  return W && X && __defProp$2(L, A, X), X;
};
let ClassificationComponent = class extends DecisionComponent {
  generateDecisionModels() {
    return [new Classification(this.verified, this.decisionId, this.tag)];
  }
};
__decorateClass$2([
  required(),
  n$1({ type: String, converter: tagConverter })
], ClassificationComponent.prototype, "tag", 2);
ClassificationComponent = __decorateClass$2([
  t$4("oe-classification")
], ClassificationComponent);
var __defProp$1 = Object.defineProperty, __getOwnPropDesc$1 = Object.getOwnPropertyDescriptor, __decorateClass$1 = (C, L, A, W) => {
  for (var X = W > 1 ? void 0 : W ? __getOwnPropDesc$1(L, A) : L, J = C.length - 1, te; J >= 0; J--)
    (te = C[J]) && (X = (W ? te(L, A, X) : te(X)) || X);
  return W && X && __defProp$1(L, A, X), X;
};
let VerificationComponent = class extends DecisionComponent {
  generateDecisionModels() {
    const C = new Verification(this.verified, this.decisionId), L = [];
    for (const A of this.additionalTags) {
      const W = new Classification(this.verified, this.decisionId, A);
      L.push(W);
    }
    return [C, ...L];
  }
};
VerificationComponent = __decorateClass$1([
  t$4("oe-verification")
], VerificationComponent);
const settingComponentStyles = ":host{display:inline-flex}.settings-container{display:flex}sl-dropdown,sl-tooltip{display:flex;width:100%;height:100%}";
var __defProp = Object.defineProperty, __getOwnPropDesc = Object.getOwnPropertyDescriptor, __decorateClass = (C, L, A, W) => {
  for (var X = W > 1 ? void 0 : W ? __getOwnPropDesc(L, A) : L, J = C.length - 1, te; J >= 0; J--)
    (te = C[J]) && (X = (W ? te(L, A, X) : te(X)) || X);
  return W && X && __defProp(L, A, X), X;
};
let VerificationGridSettingsComponent = class extends AbstractComponent(h$1) {
  constructor() {
    super(...arguments), this.isFullscreen = !1, this.fullscreenChangeHandler = this.updateFullscreenState.bind(this);
  }
  connectedCallback() {
    super.connectedCallback(), document.addEventListener("fullscreenchange", this.fullscreenChangeHandler);
  }
  disconnectedCallback() {
    document.removeEventListener("fullscreenchange", this.fullscreenChangeHandler), super.disconnectedCallback();
  }
  toggleFullscreen(C) {
    const L = C ?? !this.isFullscreen, A = this.verificationGrid;
    if (L) {
      if (!A)
        throw new Error("Could not find verification element to fullscreen");
      A.requestFullscreen();
    } else
      document.exitFullscreen();
    this.updateFullscreenState();
  }
  updateFullscreenState() {
    this.isFullscreen = document.fullscreenElement === this.verificationGrid;
  }
  updateGridSizeState() {
    if (!this.verificationGrid)
      throw new Error("Could not find associated verification grid component");
    this.gridSize = this.verificationGrid.gridSize;
  }
  handleGridSizeChange(C) {
    if (!this.verificationGrid)
      throw new Error("Could not find associated verification grid component");
    const L = C.target.value, A = Number(L);
    this.verificationGrid.gridSize = A, this.updateGridSizeState();
  }
  gridSizeSettingsTemplate() {
    if (!this.verificationGrid)
      throw new Error("Could not find associated verification grid component");
    return ke$1`
      <sl-dropdown placement="top-start">
        <sl-tooltip slot="trigger" content="Change the verification grid size">
          <button
            id="grid-size-trigger"
            @click="${this.updateGridSizeState}"
            class="oe-btn-secondary"
            ?disabled="${!this.verificationGrid}"
            aria-label="Change the verification grid size"
          >
            <sl-icon name="grid" class="large-icon"></sl-icon>
          </button>
        </sl-tooltip>

        <sl-menu>
          <label id="grid-size-label">
            ${this.gridSize}
            <input
              id="grid-size-input"
              @change="${this.handleGridSizeChange}"
              type="range"
              value="${to(this.gridSize)}"
              min="1"
              max="20"
            />
          </label>
        </sl-menu>
      </sl-dropdown>
    `;
  }
  fullscreenSettingsTemplate() {
    const C = document.fullscreenEnabled, L = `${this.isFullscreen ? "Exit" : "Enter"} fullscreen mode`;
    return ke$1`
      <sl-tooltip content="${L}">
        <button
          id="fullscreen-button"
          class="oe-btn-secondary"
          @click="${() => this.toggleFullscreen()}"
          ?disabled="${!C}"
          aria-label="${L}"
        >
          <sl-icon name="${this.isFullscreen ? "fullscreen-exit" : "arrows-fullscreen"}" class="large-icon"></sl-icon>
        </button>
      </sl-tooltip>
    `;
  }
  gridTemplateSettings() {
    if (!this.verificationGrid)
      throw new Error("Could not find associated verification grid component");
    const C = (L) => (A) => {
      const W = A.target.checked;
      this.verificationGrid.settings[L].value = W;
    };
    return ke$1`
      <sl-dropdown data-testid="template-dropdown">
        <sl-tooltip slot="trigger" content="Change the verification grids template">
          <button
            id="settings-template-trigger"
            class="oe-btn-secondary"
            aria-label="Change the verification grids template"
          >
            <sl-icon name="sliders" class="large-icon"></sl-icon>
          </button>
        </sl-tooltip>

        <sl-menu>
          <sl-menu-item>
            <label>
              <input
                @change="${C("mediaControls")}"
                class="template-change-input"
                type="checkbox"
                ?checked="${s(this.verificationGrid.settings.mediaControls)}"
              />
              Media Controls
            </label>
          </sl-menu-item>

          <sl-menu-item>
            <label>
              <input
                @change="${C("indicator")}"
                class="template-change-input"
                type="checkbox"
                ?checked="${s(this.verificationGrid.settings.indicator)}"
              />
              Playback Indicator
            </label>
          </sl-menu-item>

          <sl-menu-item>
            <label>
              <input
                @change="${C("axes")}"
                class="template-change-input"
                type="checkbox"
                ?checked="${s(this.verificationGrid.settings.axes)}"
              />
              Axes
            </label>
          </sl-menu-item>
        </sl-menu>
      </sl-dropdown>
    `;
  }
  render() {
    return ke$1`
      <div class="settings-container">
        ${this.gridSizeSettingsTemplate()}
        ${this.fullscreenSettingsTemplate()}
        ${this.gridTemplateSettings()}
      </div>
    `;
  }
};
VerificationGridSettingsComponent.styles = r$6(settingComponentStyles);
__decorateClass([
  c$1({ context: verificationGridContext, subscribe: !0 }),
  n$1({ attribute: !1 })
], VerificationGridSettingsComponent.prototype, "settings", 2);
__decorateClass([
  n$1({ attribute: !1, type: Boolean })
], VerificationGridSettingsComponent.prototype, "isFullscreen", 2);
__decorateClass([
  r$3()
], VerificationGridSettingsComponent.prototype, "gridSize", 2);
__decorateClass([
  queryParentElement({ selector: "oe-verification-grid" })
], VerificationGridSettingsComponent.prototype, "verificationGrid", 2);
VerificationGridSettingsComponent = __decorateClass([
  t$4("oe-verification-grid-settings")
], VerificationGridSettingsComponent);
setBasePath("/node_modules/@shoelace-style/shoelace/dist");
export {
  AxesComponent,
  ClassificationComponent,
  DataSourceComponent,
  DecisionComponent,
  IndicatorComponent,
  InfoCardComponent,
  LoggerImplementation,
  MediaControlsComponent,
  SpectrogramComponent,
  VerificationComponent,
  VerificationGridComponent,
  VerificationGridSettingsComponent,
  VerificationGridTileComponent,
  VerificationHelpDialogComponent,
  gridTileContext,
  rootContext,
  verificationGridContext
};
